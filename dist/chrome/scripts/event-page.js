/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5);


/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*
	* loglevel - https://github.com/pimterry/loglevel
	*
	* Copyright (c) 2013 Tim Perry
	* Licensed under the MIT license.
	*/
	(function (root, definition) {
	    "use strict";
	
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
	        module.exports = definition();
	    } else {
	        root.log = definition();
	    }
	})(undefined, function () {
	    "use strict";
	
	    // Slightly dubious tricks to cut down minimized file size
	
	    var noop = function noop() {};
	    var undefinedType = "undefined";
	
	    var logMethods = ["trace", "debug", "info", "warn", "error"];
	
	    // Cross-browser bind equivalent that works at least back to IE6
	    function bindMethod(obj, methodName) {
	        var method = obj[methodName];
	        if (typeof method.bind === 'function') {
	            return method.bind(obj);
	        } else {
	            try {
	                return Function.prototype.bind.call(method, obj);
	            } catch (e) {
	                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
	                return function () {
	                    return Function.prototype.apply.apply(method, [obj, arguments]);
	                };
	            }
	        }
	    }
	
	    // Build the best logging method possible for this env
	    // Wherever possible we want to bind, not wrap, to preserve stack traces
	    function realMethod(methodName) {
	        if (methodName === 'debug') {
	            methodName = 'log';
	        }
	
	        if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType) {
	            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
	        } else if (console[methodName] !== undefined) {
	            return bindMethod(console, methodName);
	        } else if (console.log !== undefined) {
	            return bindMethod(console, 'log');
	        } else {
	            return noop;
	        }
	    }
	
	    // These private functions always need `this` to be set properly
	
	    function replaceLoggingMethods(level, loggerName) {
	        /*jshint validthis:true */
	        for (var i = 0; i < logMethods.length; i++) {
	            var methodName = logMethods[i];
	            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
	        }
	
	        // Define log.log as an alias for log.debug
	        this.log = this.debug;
	    }
	
	    // In old IE versions, the console isn't present until you first open it.
	    // We build realMethod() replacements here that regenerate logging methods
	    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
	        return function () {
	            if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== undefinedType) {
	                replaceLoggingMethods.call(this, level, loggerName);
	                this[methodName].apply(this, arguments);
	            }
	        };
	    }
	
	    // By default, we use closely bound real methods wherever possible, and
	    // otherwise we wait for a console to appear, and then try again.
	    function defaultMethodFactory(methodName, level, loggerName) {
	        /*jshint validthis:true */
	        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
	    }
	
	    function Logger(name, defaultLevel, factory) {
	        var self = this;
	        var currentLevel;
	        var storageKey = "loglevel";
	        if (name) {
	            storageKey += ":" + name;
	        }
	
	        function persistLevelIfPossible(levelNum) {
	            var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            // Use localStorage if available
	            try {
	                window.localStorage[storageKey] = levelName;
	                return;
	            } catch (ignore) {}
	
	            // Use session cookie as fallback
	            try {
	                window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
	            } catch (ignore) {}
	        }
	
	        function getPersistedLevel() {
	            var storedLevel;
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            try {
	                storedLevel = window.localStorage[storageKey];
	            } catch (ignore) {}
	
	            // Fallback to cookies if local storage gives us nothing
	            if ((typeof storedLevel === 'undefined' ? 'undefined' : _typeof(storedLevel)) === undefinedType) {
	                try {
	                    var cookie = window.document.cookie;
	                    var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
	                    if (location) {
	                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
	                    }
	                } catch (ignore) {}
	            }
	
	            // If the stored level is not valid, treat it as if nothing was stored.
	            if (self.levels[storedLevel] === undefined) {
	                storedLevel = undefined;
	            }
	
	            return storedLevel;
	        }
	
	        /*
	         *
	         * Public logger API - see https://github.com/pimterry/loglevel for details
	         *
	         */
	
	        self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
	            "ERROR": 4, "SILENT": 5 };
	
	        self.methodFactory = factory || defaultMethodFactory;
	
	        self.getLevel = function () {
	            return currentLevel;
	        };
	
	        self.setLevel = function (level, persist) {
	            if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
	                level = self.levels[level.toUpperCase()];
	            }
	            if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
	                currentLevel = level;
	                if (persist !== false) {
	                    // defaults to true
	                    persistLevelIfPossible(level);
	                }
	                replaceLoggingMethods.call(self, level, name);
	                if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType && level < self.levels.SILENT) {
	                    return "No console available for logging";
	                }
	            } else {
	                throw "log.setLevel() called with invalid level: " + level;
	            }
	        };
	
	        self.setDefaultLevel = function (level) {
	            if (!getPersistedLevel()) {
	                self.setLevel(level, false);
	            }
	        };
	
	        self.enableAll = function (persist) {
	            self.setLevel(self.levels.TRACE, persist);
	        };
	
	        self.disableAll = function (persist) {
	            self.setLevel(self.levels.SILENT, persist);
	        };
	
	        // Initialize with the right level
	        var initialLevel = getPersistedLevel();
	        if (initialLevel == null) {
	            initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
	        }
	        self.setLevel(initialLevel, false);
	    }
	
	    /*
	     *
	     * Top-level API
	     *
	     */
	
	    var defaultLogger = new Logger();
	
	    var _loggersByName = {};
	    defaultLogger.getLogger = function getLogger(name) {
	        if (typeof name !== "string" || name === "") {
	            throw new TypeError("You must supply a name when creating a logger.");
	        }
	
	        var logger = _loggersByName[name];
	        if (!logger) {
	            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
	        }
	        return logger;
	    };
	
	    // Grab the current global log variable in case of overwrite
	    var _log = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType ? window.log : undefined;
	    defaultLogger.noConflict = function () {
	        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType && window.log === defaultLogger) {
	            window.log = _log;
	        }
	
	        return defaultLogger;
	    };
	
	    return defaultLogger;
	});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(6);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _explaainSearch = __webpack_require__(12);
	
	var _explaainSearch2 = _interopRequireDefault(_explaainSearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var UserIDs = {
	  live: {
	    Jeremy: '1627888800569309',
	    Matt: '1455707247850069',
	    Carol: '1459068990878077',
	    Harriet: '1478776232161468',
	    Jonny: '1513554438729753'
	  },
	  staging: {
	    Jeremy: '1366746370089527',
	    Matt: '1528134990563202'
	  },
	  local: {
	    Jeremy: '1300120880110773',
	    Matt: '1428419100528438'
	  },
	  drive: {
	    Jeremy: '104380110279658920175',
	    ACME: '101118387301286232222'
	  }
	};
	
	var UserID = UserIDs.live.ACME;
	var PageResults = {};
	var UserCards = [];
	var LastRefresh = 0;
	
	var algoliaParams = { // Need to send these to app.vue to avoid duplication!
	  appID: 'I2VKMNNAXI',
	  apiKey: '2b8406f84cd4cc507da173032c46ee7b',
	  index: 'ForgetMeNot_Context_Test'
	};
	_vue2.default.use(_explaainSearch2.default, algoliaParams);
	
	chrome.browserAction.onClicked.addListener(function (tab) {
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    chrome.tabs.sendMessage(tabs[0].id, { action: 'toggleDrawer' }, function (res) {
	      _loglevel2.default.info(res);
	    });
	  });
	});
	
	chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
	  try {
	    _loglevel2.default.debug(sender.tab ? "From a content script: " + sender.tab.url : "From the extension", request);
	
	    if (request.action == "getPageResults") {
	      getCurrentPageResults(request.data).then(function (res) {
	        _loglevel2.default.debug(res);
	        sendResponse(res);
	      });
	      return true;
	    }
	    if (request.action == "checkPage") {
	      _loglevel2.default.trace(request.data);
	      checkRefresh().then(function () {
	        return _explaainSearch2.default.getPageResults(UserID, request.data, UserCards);
	      }).then(function (res) {
	        addToPageResults(sender.tab.id, res);
	        PageResults = res;
	        sendResponse(res);
	      }).catch(function (e) {
	        _loglevel2.default.error(e);
	      });
	      return true;
	    }
	    if (request.action == "getUser") {
	      sendResponse(UserID);
	      return true;
	    }
	    if (request.action == "refreshCards") {
	      getAllUserCards();
	      return true;
	    }
	    if (request.event == "popupOpened") {
	      chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	        chrome.tabs.sendMessage(tabs[0].id, { event: 'popupOpened' }, function (response) {});
	      });
	      return true;
	    }
	  } catch (e) {
	    _loglevel2.default.error(e);
	  }
	});
	
	var getCurrentPageResults = function getCurrentPageResults(data) {
	  var d = _q2.default.defer();
	  var tabID;
	  _loglevel2.default.debug(1);
	  checkRefresh().then(getCurrentTab).then(function (tab) {
	    _loglevel2.default.debug(tab.id);
	    tabID = tab.id;
	    _loglevel2.default.debug(PageResults);
	    if (PageResults[tabID]) {
	      d.resolve(PageResults[tabID]);
	    } else {
	      if (!data) data = { tabID: tabID };
	      _loglevel2.default.debug(data);
	      getPageData(data).then(function (res) {
	        _loglevel2.default.debug(res);
	        return _explaainSearch2.default.getPageResults(UserID, res, UserCards);
	      }).then(function (res) {
	        _loglevel2.default.debug(res);
	        addToPageResults(tabID, res);
	        d.resolve(res);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	    }
	  }).catch(function (e) {
	    d.reject(e);
	  });
	  return d.promise;
	};
	
	var getCurrentTab = function getCurrentTab() {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    d.resolve(tabs[0]);
	  });
	  return d.promise;
	};
	
	var getPageData = function getPageData(data) {
	  var d = _q2.default.defer();
	  if (data.pageData) {
	    d.resolve(data.pageData);
	  } else if (data.tabID) {
	    sendMessageToTab(tabID, { action: 'getPageData' }).then(function (res) {
	      d.resolve(res);
	    });
	  } else {
	    d.reject();
	  }
	  return d.promise;
	};
	
	var sendMessageToTab = function sendMessageToTab(tabID, data) {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.sendMessage(tabID, data, function (res) {
	    _loglevel2.default.debug(res);
	    d.resolve(res);
	  });
	  return d.promise;
	};
	
	var addToPageResults = function addToPageResults(tabID, data) {
	  PageResults[tabID] = data;
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    Object.keys(PageResults).forEach(function (pageTabID) {
	      if (tabs.filter(function (tab) {
	        return tab.id == pageTabID;
	      }).length == 0) delete PageResults[pageTabID];
	    });
	    _loglevel2.default.debug(PageResults);
	  });
	};
	
	var checkRefresh = function checkRefresh() {
	  var d = _q2.default.defer();
	  var now = new Date();
	  if (now - LastRefresh > 300000) {
	    getAllUserCards().then(function () {
	      d.resolve();
	    }).catch(function (e) {
	      _loglevel2.default.error(e);
	      d.reject(e);
	    });
	  } else {
	    d.resolve();
	  }
	  return d.promise;
	};
	
	var getAllUserCards = function getAllUserCards() {
	  var d = _q2.default.defer();
	  LastRefresh = new Date();
	  _explaainSearch2.default.searchCards(UserID, '', 1000).then(function (results) {
	    UserCards = results;
	    _loglevel2.default.debug(UserCards);
	    d.resolve();
	  }).catch(function (e) {
	    _loglevel2.default.error(e);
	    d.reject(e);
	  });
	  return d.promise;
	};
	getAllUserCards();

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * Vue.js v2.4.2
	 * (c) 2014-2017 Evan You
	 * Released under the MIT License.
	 */
	/*  */
	
	// these helpers produces better vm code in JS engines due to their
	// explicitness and function inlining
	function isUndef(v) {
	  return v === undefined || v === null;
	}
	
	function isDef(v) {
	  return v !== undefined && v !== null;
	}
	
	function isTrue(v) {
	  return v === true;
	}
	
	function isFalse(v) {
	  return v === false;
	}
	
	/**
	 * Check if value is primitive
	 */
	function isPrimitive(value) {
	  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	}
	
	var _toString = Object.prototype.toString;
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	function isPlainObject(obj) {
	  return _toString.call(obj) === '[object Object]';
	}
	
	function isRegExp(v) {
	  return _toString.call(v) === '[object RegExp]';
	}
	
	/**
	 * Check if val is a valid array index.
	 */
	function isValidArrayIndex(val) {
	  var n = parseFloat(val);
	  return n >= 0 && Math.floor(n) === n && isFinite(val);
	}
	
	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function toString(val) {
	  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
	}
	
	/**
	 * Convert a input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber(val) {
	  var n = parseFloat(val);
	  return isNaN(n) ? val : n;
	}
	
	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap(str, expectsLowerCase) {
	  var map = Object.create(null);
	  var list = str.split(',');
	  for (var i = 0; i < list.length; i++) {
	    map[list[i]] = true;
	  }
	  return expectsLowerCase ? function (val) {
	    return map[val.toLowerCase()];
	  } : function (val) {
	    return map[val];
	  };
	}
	
	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);
	
	/**
	 * Check if a attribute is a reserved attribute.
	 */
	var isReservedAttribute = makeMap('key,ref,slot,is');
	
	/**
	 * Remove an item from an array
	 */
	function remove(arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1);
	    }
	  }
	}
	
	/**
	 * Check whether the object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Create a cached version of a pure function.
	 */
	function cached(fn) {
	  var cache = Object.create(null);
	  return function cachedFn(str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str));
	  };
	}
	
	/**
	 * Camelize a hyphen-delimited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	  return str.replace(camelizeRE, function (_, c) {
	    return c ? c.toUpperCase() : '';
	  });
	});
	
	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1);
	});
	
	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /([^-])([A-Z])/g;
	var hyphenate = cached(function (str) {
	  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
	});
	
	/**
	 * Simple bind, faster than native
	 */
	function bind(fn, ctx) {
	  function boundFn(a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  }
	  // record original fn length
	  boundFn._length = fn.length;
	  return boundFn;
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 */
	function extend(to, _from) {
	  for (var key in _from) {
	    to[key] = _from[key];
	  }
	  return to;
	}
	
	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject(arr) {
	  var res = {};
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i]) {
	      extend(res, arr[i]);
	    }
	  }
	  return res;
	}
	
	/**
	 * Perform no operation.
	 * Stubbing args to make Flow happy without leaving useless transpiled code
	 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
	 */
	function noop(a, b, c) {}
	
	/**
	 * Always return false.
	 */
	var no = function no(a, b, c) {
	  return false;
	};
	
	/**
	 * Return same value
	 */
	var identity = function identity(_) {
	  return _;
	};
	
	/**
	 * Generate a static keys string from compiler modules.
	 */
	function genStaticKeys(modules) {
	  return modules.reduce(function (keys, m) {
	    return keys.concat(m.staticKeys || []);
	  }, []).join(',');
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual(a, b) {
	  if (a === b) {
	    return true;
	  }
	  var isObjectA = isObject(a);
	  var isObjectB = isObject(b);
	  if (isObjectA && isObjectB) {
	    try {
	      var isArrayA = Array.isArray(a);
	      var isArrayB = Array.isArray(b);
	      if (isArrayA && isArrayB) {
	        return a.length === b.length && a.every(function (e, i) {
	          return looseEqual(e, b[i]);
	        });
	      } else if (!isArrayA && !isArrayB) {
	        var keysA = Object.keys(a);
	        var keysB = Object.keys(b);
	        return keysA.length === keysB.length && keysA.every(function (key) {
	          return looseEqual(a[key], b[key]);
	        });
	      } else {
	        /* istanbul ignore next */
	        return false;
	      }
	    } catch (e) {
	      /* istanbul ignore next */
	      return false;
	    }
	  } else if (!isObjectA && !isObjectB) {
	    return String(a) === String(b);
	  } else {
	    return false;
	  }
	}
	
	function looseIndexOf(arr, val) {
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	/**
	 * Ensure a function is called only once.
	 */
	function once(fn) {
	  var called = false;
	  return function () {
	    if (!called) {
	      called = true;
	      fn.apply(this, arguments);
	    }
	  };
	}
	
	var SSR_ATTR = 'data-server-rendered';
	
	var ASSET_TYPES = ['component', 'directive', 'filter'];
	
	var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];
	
	/*  */
	
	var config = {
	  /**
	   * Option merge strategies (used in core/util/options)
	   */
	  optionMergeStrategies: Object.create(null),
	
	  /**
	   * Whether to suppress warnings.
	   */
	  silent: false,
	
	  /**
	   * Show production mode tip message on boot?
	   */
	  productionTip: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to enable devtools
	   */
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to record perf
	   */
	  performance: false,
	
	  /**
	   * Error handler for watcher errors
	   */
	  errorHandler: null,
	
	  /**
	   * Warn handler for watcher warns
	   */
	  warnHandler: null,
	
	  /**
	   * Ignore certain custom elements
	   */
	  ignoredElements: [],
	
	  /**
	   * Custom user key aliases for v-on
	   */
	  keyCodes: Object.create(null),
	
	  /**
	   * Check if a tag is reserved so that it cannot be registered as a
	   * component. This is platform-dependent and may be overwritten.
	   */
	  isReservedTag: no,
	
	  /**
	   * Check if an attribute is reserved so that it cannot be used as a component
	   * prop. This is platform-dependent and may be overwritten.
	   */
	  isReservedAttr: no,
	
	  /**
	   * Check if a tag is an unknown element.
	   * Platform-dependent.
	   */
	  isUnknownElement: no,
	
	  /**
	   * Get the namespace of an element
	   */
	  getTagNamespace: noop,
	
	  /**
	   * Parse the real tag name for the specific platform.
	   */
	  parsePlatformTagName: identity,
	
	  /**
	   * Check if an attribute must be bound using property, e.g. value
	   * Platform-dependent.
	   */
	  mustUseProp: no,
	
	  /**
	   * Exposed for legacy reasons
	   */
	  _lifecycleHooks: LIFECYCLE_HOOKS
	};
	
	/*  */
	
	var emptyObject = Object.freeze({});
	
	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Define a property.
	 */
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Parse simple path.
	 */
	var bailRE = /[^\w.$]/;
	function parsePath(path) {
	  if (bailRE.test(path)) {
	    return;
	  }
	  var segments = path.split('.');
	  return function (obj) {
	    for (var i = 0; i < segments.length; i++) {
	      if (!obj) {
	        return;
	      }
	      obj = obj[segments[i]];
	    }
	    return obj;
	  };
	}
	
	/*  */
	
	var warn = noop;
	var tip = noop;
	var formatComponentName = null; // work around flow check
	
	if (process.env.NODE_ENV !== 'production') {
	  var hasConsole = typeof console !== 'undefined';
	  var classifyRE = /(?:^|[-_])(\w)/g;
	  var classify = function classify(str) {
	    return str.replace(classifyRE, function (c) {
	      return c.toUpperCase();
	    }).replace(/[-_]/g, '');
	  };
	
	  warn = function warn(msg, vm) {
	    var trace = vm ? generateComponentTrace(vm) : '';
	
	    if (config.warnHandler) {
	      config.warnHandler.call(null, msg, vm, trace);
	    } else if (hasConsole && !config.silent) {
	      console.error("[Vue warn]: " + msg + trace);
	    }
	  };
	
	  tip = function tip(msg, vm) {
	    if (hasConsole && !config.silent) {
	      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
	    }
	  };
	
	  formatComponentName = function formatComponentName(vm, includeFile) {
	    if (vm.$root === vm) {
	      return '<Root>';
	    }
	    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;
	
	    var file = vm._isVue && vm.$options.__file;
	    if (!name && file) {
	      var match = file.match(/([^/\\]+)\.vue$/);
	      name = match && match[1];
	    }
	
	    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
	  };
	
	  var repeat = function repeat(str, n) {
	    var res = '';
	    while (n) {
	      if (n % 2 === 1) {
	        res += str;
	      }
	      if (n > 1) {
	        str += str;
	      }
	      n >>= 1;
	    }
	    return res;
	  };
	
	  var generateComponentTrace = function generateComponentTrace(vm) {
	    if (vm._isVue && vm.$parent) {
	      var tree = [];
	      var currentRecursiveSequence = 0;
	      while (vm) {
	        if (tree.length > 0) {
	          var last = tree[tree.length - 1];
	          if (last.constructor === vm.constructor) {
	            currentRecursiveSequence++;
	            vm = vm.$parent;
	            continue;
	          } else if (currentRecursiveSequence > 0) {
	            tree[tree.length - 1] = [last, currentRecursiveSequence];
	            currentRecursiveSequence = 0;
	          }
	        }
	        tree.push(vm);
	        vm = vm.$parent;
	      }
	      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
	        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
	      }).join('\n');
	    } else {
	      return "\n\n(found in " + formatComponentName(vm) + ")";
	    }
	  };
	}
	
	/*  */
	
	function handleError(err, vm, info) {
	  if (config.errorHandler) {
	    config.errorHandler.call(null, err, vm, info);
	  } else {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
	    }
	    /* istanbul ignore else */
	    if (inBrowser && typeof console !== 'undefined') {
	      console.error(err);
	    } else {
	      throw err;
	    }
	  }
	}
	
	/*  */
	/* globals MutationObserver */
	
	// can we use __proto__?
	var hasProto = '__proto__' in {};
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
	var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
	
	// Firefix has a "watch" function on Object.prototype...
	var nativeWatch = {}.watch;
	
	var supportsPassive = false;
	if (inBrowser) {
	  try {
	    var opts = {};
	    Object.defineProperty(opts, 'passive', {
	      get: function get() {
	        /* istanbul ignore next */
	        supportsPassive = true;
	      }
	    }); // https://github.com/facebook/flow/issues/285
	    window.addEventListener('test-passive', null, opts);
	  } catch (e) {}
	}
	
	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function isServerRendering() {
	  if (_isServer === undefined) {
	    /* istanbul ignore if */
	    if (!inBrowser && typeof global !== 'undefined') {
	      // detect presence of vue-server-renderer and avoid
	      // Webpack shimming the process
	      _isServer = global['process'].env.VUE_ENV === 'server';
	    } else {
	      _isServer = false;
	    }
	  }
	  return _isServer;
	};
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	/* istanbul ignore next */
	function isNative(Ctor) {
	  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
	}
	
	var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
	
	/**
	 * Defer a task to execute it asynchronously.
	 */
	var nextTick = function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  // the nextTick behavior leverages the microtask queue, which can be accessed
	  // via either native Promise.then or MutationObserver.
	  // MutationObserver has wider support, however it is seriously bugged in
	  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	  // completely stops working after triggering a few times... so, if native
	  // Promise is available, we will use it:
	  /* istanbul ignore if */
	  if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p = Promise.resolve();
	    var logError = function logError(err) {
	      console.error(err);
	    };
	    timerFunc = function timerFunc() {
	      p.then(nextTickHandler).catch(logError);
	      // in problematic UIWebViews, Promise.then doesn't completely break, but
	      // it can get stuck in a weird state where callbacks are pushed into the
	      // microtask queue but the queue isn't being flushed, until the browser
	      // needs to do some other work, e.g. handle a timer. Therefore we can
	      // "force" the microtask queue to be flushed by adding an empty timer.
	      if (isIOS) {
	        setTimeout(noop);
	      }
	    };
	  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
	  // PhantomJS and iOS 7.x
	  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
	    // use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS IE11, iOS7, Android 4.4
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(String(counter));
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function timerFunc() {
	      counter = (counter + 1) % 2;
	      textNode.data = String(counter);
	    };
	  } else {
	    // fallback to setTimeout
	    /* istanbul ignore next */
	    timerFunc = function timerFunc() {
	      setTimeout(nextTickHandler, 0);
	    };
	  }
	
	  return function queueNextTick(cb, ctx) {
	    var _resolve;
	    callbacks.push(function () {
	      if (cb) {
	        try {
	          cb.call(ctx);
	        } catch (e) {
	          handleError(e, ctx, 'nextTick');
	        }
	      } else if (_resolve) {
	        _resolve(ctx);
	      }
	    });
	    if (!pending) {
	      pending = true;
	      timerFunc();
	    }
	    if (!cb && typeof Promise !== 'undefined') {
	      return new Promise(function (resolve, reject) {
	        _resolve = resolve;
	      });
	    }
	  };
	}();
	
	var _Set;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && isNative(Set)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    function Set() {
	      this.set = Object.create(null);
	    }
	    Set.prototype.has = function has(key) {
	      return this.set[key] === true;
	    };
	    Set.prototype.add = function add(key) {
	      this.set[key] = true;
	    };
	    Set.prototype.clear = function clear() {
	      this.set = Object.create(null);
	    };
	
	    return Set;
	  }();
	}
	
	/*  */
	
	var uid = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 */
	var Dep = function Dep() {
	  this.id = uid++;
	  this.subs = [];
	};
	
	Dep.prototype.addSub = function addSub(sub) {
	  this.subs.push(sub);
	};
	
	Dep.prototype.removeSub = function removeSub(sub) {
	  remove(this.subs, sub);
	};
	
	Dep.prototype.depend = function depend() {
	  if (Dep.target) {
	    Dep.target.addDep(this);
	  }
	};
	
	Dep.prototype.notify = function notify() {
	  // stabilize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	var targetStack = [];
	
	function pushTarget(_target) {
	  if (Dep.target) {
	    targetStack.push(Dep.target);
	  }
	  Dep.target = _target;
	}
	
	function popTarget() {
	  Dep.target = targetStack.pop();
	}
	
	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    var args = [],
	        len = arguments.length;
	    while (len--) {
	      args[len] = arguments[len];
	    }var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) {
	      ob.observeArray(inserted);
	    }
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/*  */
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However when passing down props,
	 * we don't want to force conversion because the value may be a nested value
	 * under a frozen data structure. Converting it would defeat the optimization.
	 */
	var observerState = {
	  shouldConvert: true
	};
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 */
	var Observer = function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  this.vmCount = 0;
	  def(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	};
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 */
	Observer.prototype.walk = function walk(obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0; i < keys.length; i++) {
	    defineReactive$$1(obj, keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 */
	Observer.prototype.observeArray = function observeArray(items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 */
	function protoAugment(target, src, keys) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 */
	/* istanbul ignore next */
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe(value, asRootData) {
	  if (!isObject(value)) {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (asRootData && ob) {
	    ob.vmCount++;
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive$$1(obj, key, val, customSetter, shallow) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = !shallow && observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          dependArray(value);
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      /* eslint-disable no-self-compare */
	      if (newVal === value || newVal !== newVal && value !== value) {
	        return;
	      }
	      /* eslint-enable no-self-compare */
	      if (process.env.NODE_ENV !== 'production' && customSetter) {
	        customSetter();
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = !shallow && observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 */
	function set(target, key, val) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.length = Math.max(target.length, key);
	    target.splice(key, 1, val);
	    return val;
	  }
	  if (hasOwn(target, key)) {
	    target[key] = val;
	    return val;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
	    return val;
	  }
	  if (!ob) {
	    target[key] = val;
	    return val;
	  }
	  defineReactive$$1(ob.value, key, val);
	  ob.dep.notify();
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 */
	function del(target, key) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.splice(key, 1);
	    return;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
	    return;
	  }
	  if (!hasOwn(target, key)) {
	    return;
	  }
	  delete target[key];
	  if (!ob) {
	    return;
	  }
	  ob.dep.notify();
	}
	
	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray(value) {
	  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
	    e = value[i];
	    e && e.__ob__ && e.__ob__.dep.depend();
	    if (Array.isArray(e)) {
	      dependArray(e);
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;
	
	/**
	 * Options with restrictions
	 */
	if (process.env.NODE_ENV !== 'production') {
	  strats.el = strats.propsData = function (parent, child, vm, key) {
	    if (!vm) {
	      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
	    }
	    return defaultStrat(parent, child);
	  };
	}
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData(to, from) {
	  if (!from) {
	    return to;
	  }
	  var key, toVal, fromVal;
	  var keys = Object.keys(from);
	  for (var i = 0; i < keys.length; i++) {
	    key = keys[i];
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	function mergeDataOrFn(parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	}
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    if (childVal && typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	
	      return parentVal;
	    }
	    return mergeDataOrFn.call(this, parentVal, childVal);
	  }
	
	  return mergeDataOrFn(parentVal, childVal, vm);
	};
	
	/**
	 * Hooks and props are merged as arrays.
	 */
	function mergeHook(parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
	}
	
	LIFECYCLE_HOOKS.forEach(function (hook) {
	  strats[hook] = mergeHook;
	});
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, childVal) : res;
	}
	
	ASSET_TYPES.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal) {
	  // work around Firefox's Object.prototype.watch...
	  if (parentVal === nativeWatch) {
	    parentVal = undefined;
	  }
	  if (childVal === nativeWatch) {
	    childVal = undefined;
	  }
	  /* istanbul ignore if */
	  if (!childVal) {
	    return Object.create(parentVal || null);
	  }
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !Array.isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  if (childVal) {
	    extend(ret, childVal);
	  }
	  return ret;
	};
	strats.provide = mergeDataOrFn;
	
	/**
	 * Default strategy.
	 */
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Validate component names
	 */
	function checkComponents(options) {
	  for (var key in options.components) {
	    var lower = key.toLowerCase();
	    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
	      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps(options) {
	  var props = options.props;
	  if (!props) {
	    return;
	  }
	  var res = {};
	  var i, val, name;
	  if (Array.isArray(props)) {
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        name = camelize(val);
	        res[name] = { type: null };
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('props must be strings when using array syntax.');
	      }
	    }
	  } else if (isPlainObject(props)) {
	    for (var key in props) {
	      val = props[key];
	      name = camelize(key);
	      res[name] = isPlainObject(val) ? val : { type: val };
	    }
	  }
	  options.props = res;
	}
	
	/**
	 * Normalize all injections into Object-based format
	 */
	function normalizeInject(options) {
	  var inject = options.inject;
	  if (Array.isArray(inject)) {
	    var normalized = options.inject = {};
	    for (var i = 0; i < inject.length; i++) {
	      normalized[inject[i]] = inject[i];
	    }
	  }
	}
	
	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives(options) {
	  var dirs = options.directives;
	  if (dirs) {
	    for (var key in dirs) {
	      var def = dirs[key];
	      if (typeof def === 'function') {
	        dirs[key] = { bind: def, update: def };
	      }
	    }
	  }
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions(parent, child, vm) {
	  if (process.env.NODE_ENV !== 'production') {
	    checkComponents(child);
	  }
	
	  if (typeof child === 'function') {
	    child = child.options;
	  }
	
	  normalizeProps(child);
	  normalizeInject(child);
	  normalizeDirectives(child);
	  var extendsFrom = child.extends;
	  if (extendsFrom) {
	    parent = mergeOptions(parent, extendsFrom, vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  var options = {};
	  var key;
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  // check local registration variations first
	  if (hasOwn(assets, id)) {
	    return assets[id];
	  }
	  var camelizedId = camelize(id);
	  if (hasOwn(assets, camelizedId)) {
	    return assets[camelizedId];
	  }
	  var PascalCaseId = capitalize(camelizedId);
	  if (hasOwn(assets, PascalCaseId)) {
	    return assets[PascalCaseId];
	  }
	  // fallback to prototype chain
	  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	/*  */
	
	function validateProp(key, propOptions, propsData, vm) {
	  var prop = propOptions[key];
	  var absent = !hasOwn(propsData, key);
	  var value = propsData[key];
	  // handle boolean props
	  if (isType(Boolean, prop.type)) {
	    if (absent && !hasOwn(prop, 'default')) {
	      value = false;
	    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
	      value = true;
	    }
	  }
	  // check default value
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop, key);
	    // since the default value is a fresh copy,
	    // make sure to observe it.
	    var prevShouldConvert = observerState.shouldConvert;
	    observerState.shouldConvert = true;
	    observe(value);
	    observerState.shouldConvert = prevShouldConvert;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    assertProp(prop, key, value, vm, absent);
	  }
	  return value;
	}
	
	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue(vm, prop, key) {
	  // no default, return undefined
	  if (!hasOwn(prop, 'default')) {
	    return undefined;
	  }
	  var def = prop.default;
	  // warn against non-factory defaults for Object & Array
	  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
	    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // the raw prop value was also undefined from previous render,
	  // return previous default value to avoid unnecessary watcher trigger
	  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
	    return vm._props[key];
	  }
	  // call factory function for non-Function types
	  // a value is Function if its prototype is function even across different execution context
	  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp(prop, name, value, vm, absent) {
	  if (prop.required && absent) {
	    warn('Missing required prop: "' + name + '"', vm);
	    return;
	  }
	  if (value == null && !prop.required) {
	    return;
	  }
	  var type = prop.type;
	  var valid = !type || type === true;
	  var expectedTypes = [];
	  if (type) {
	    if (!Array.isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType || '');
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
	    return;
	  }
	  var validator = prop.validator;
	  if (validator) {
	    if (!validator(value)) {
	      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
	    }
	  }
	}
	
	var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
	
	function assertType(value, type) {
	  var valid;
	  var expectedType = getType(type);
	  if (simpleCheckRE.test(expectedType)) {
	    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();
	  } else if (expectedType === 'Object') {
	    valid = isPlainObject(value);
	  } else if (expectedType === 'Array') {
	    valid = Array.isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType(fn) {
	  var match = fn && fn.toString().match(/^\s*function (\w+)/);
	  return match ? match[1] : '';
	}
	
	function isType(type, fn) {
	  if (!Array.isArray(fn)) {
	    return getType(fn) === getType(type);
	  }
	  for (var i = 0, len = fn.length; i < len; i++) {
	    if (getType(fn[i]) === getType(type)) {
	      return true;
	    }
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	/*  */
	
	var mark;
	var measure;
	
	if (process.env.NODE_ENV !== 'production') {
	  var perf = inBrowser && window.performance;
	  /* istanbul ignore if */
	  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
	    mark = function mark(tag) {
	      return perf.mark(tag);
	    };
	    measure = function measure(name, startTag, endTag) {
	      perf.measure(name, startTag, endTag);
	      perf.clearMarks(startTag);
	      perf.clearMarks(endTag);
	      perf.clearMeasures(name);
	    };
	  }
	}
	
	/* not type checking this file because flow doesn't play well with Proxy */
	
	var initProxy;
	
	if (process.env.NODE_ENV !== 'production') {
	  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
	  );
	
	  var warnNonPresent = function warnNonPresent(target, key) {
	    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
	  };
	
	  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);
	
	  if (hasProxy) {
	    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
	    config.keyCodes = new Proxy(config.keyCodes, {
	      set: function set(target, key, value) {
	        if (isBuiltInModifier(key)) {
	          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
	          return false;
	        } else {
	          target[key] = value;
	          return true;
	        }
	      }
	    });
	  }
	
	  var hasHandler = {
	    has: function has(target, key) {
	      var has = key in target;
	      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
	      if (!has && !isAllowed) {
	        warnNonPresent(target, key);
	      }
	      return has || !isAllowed;
	    }
	  };
	
	  var getHandler = {
	    get: function get(target, key) {
	      if (typeof key === 'string' && !(key in target)) {
	        warnNonPresent(target, key);
	      }
	      return target[key];
	    }
	  };
	
	  initProxy = function initProxy(vm) {
	    if (hasProxy) {
	      // determine which proxy handler to use
	      var options = vm.$options;
	      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
	      vm._renderProxy = new Proxy(vm, handlers);
	    } else {
	      vm._renderProxy = vm;
	    }
	  };
	}
	
	/*  */
	
	var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
	  this.tag = tag;
	  this.data = data;
	  this.children = children;
	  this.text = text;
	  this.elm = elm;
	  this.ns = undefined;
	  this.context = context;
	  this.functionalContext = undefined;
	  this.key = data && data.key;
	  this.componentOptions = componentOptions;
	  this.componentInstance = undefined;
	  this.parent = undefined;
	  this.raw = false;
	  this.isStatic = false;
	  this.isRootInsert = true;
	  this.isComment = false;
	  this.isCloned = false;
	  this.isOnce = false;
	  this.asyncFactory = asyncFactory;
	  this.asyncMeta = undefined;
	  this.isAsyncPlaceholder = false;
	};
	
	var prototypeAccessors = { child: {} };
	
	// DEPRECATED: alias for componentInstance for backwards compat.
	/* istanbul ignore next */
	prototypeAccessors.child.get = function () {
	  return this.componentInstance;
	};
	
	Object.defineProperties(VNode.prototype, prototypeAccessors);
	
	var createEmptyVNode = function createEmptyVNode(text) {
	  if (text === void 0) text = '';
	
	  var node = new VNode();
	  node.text = text;
	  node.isComment = true;
	  return node;
	};
	
	function createTextVNode(val) {
	  return new VNode(undefined, undefined, undefined, String(val));
	}
	
	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode(vnode) {
	  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
	  cloned.ns = vnode.ns;
	  cloned.isStatic = vnode.isStatic;
	  cloned.key = vnode.key;
	  cloned.isComment = vnode.isComment;
	  cloned.isCloned = true;
	  return cloned;
	}
	
	function cloneVNodes(vnodes) {
	  var len = vnodes.length;
	  var res = new Array(len);
	  for (var i = 0; i < len; i++) {
	    res[i] = cloneVNode(vnodes[i]);
	  }
	  return res;
	}
	
	/*  */
	
	var normalizeEvent = cached(function (name) {
	  var passive = name.charAt(0) === '&';
	  name = passive ? name.slice(1) : name;
	  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
	  name = once$$1 ? name.slice(1) : name;
	  var capture = name.charAt(0) === '!';
	  name = capture ? name.slice(1) : name;
	  return {
	    name: name,
	    once: once$$1,
	    capture: capture,
	    passive: passive
	  };
	});
	
	function createFnInvoker(fns) {
	  function invoker() {
	    var arguments$1 = arguments;
	
	    var fns = invoker.fns;
	    if (Array.isArray(fns)) {
	      var cloned = fns.slice();
	      for (var i = 0; i < cloned.length; i++) {
	        cloned[i].apply(null, arguments$1);
	      }
	    } else {
	      // return handler return value for single handlers
	      return fns.apply(null, arguments);
	    }
	  }
	  invoker.fns = fns;
	  return invoker;
	}
	
	function updateListeners(on, oldOn, add, remove$$1, vm) {
	  var name, cur, old, event;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    event = normalizeEvent(name);
	    if (isUndef(cur)) {
	      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
	    } else if (isUndef(old)) {
	      if (isUndef(cur.fns)) {
	        cur = on[name] = createFnInvoker(cur);
	      }
	      add(event.name, cur, event.once, event.capture, event.passive);
	    } else if (cur !== old) {
	      old.fns = cur;
	      on[name] = old;
	    }
	  }
	  for (name in oldOn) {
	    if (isUndef(on[name])) {
	      event = normalizeEvent(name);
	      remove$$1(event.name, oldOn[name], event.capture);
	    }
	  }
	}
	
	/*  */
	
	function mergeVNodeHook(def, hookKey, hook) {
	  var invoker;
	  var oldHook = def[hookKey];
	
	  function wrappedHook() {
	    hook.apply(this, arguments);
	    // important: remove merged hook to ensure it's called only once
	    // and prevent memory leak
	    remove(invoker.fns, wrappedHook);
	  }
	
	  if (isUndef(oldHook)) {
	    // no existing hook
	    invoker = createFnInvoker([wrappedHook]);
	  } else {
	    /* istanbul ignore if */
	    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
	      // already a merged invoker
	      invoker = oldHook;
	      invoker.fns.push(wrappedHook);
	    } else {
	      // existing plain hook
	      invoker = createFnInvoker([oldHook, wrappedHook]);
	    }
	  }
	
	  invoker.merged = true;
	  def[hookKey] = invoker;
	}
	
	/*  */
	
	function extractPropsFromVNodeData(data, Ctor, tag) {
	  // we are only extracting raw values here.
	  // validation and default values are handled in the child
	  // component itself.
	  var propOptions = Ctor.options.props;
	  if (isUndef(propOptions)) {
	    return;
	  }
	  var res = {};
	  var attrs = data.attrs;
	  var props = data.props;
	  if (isDef(attrs) || isDef(props)) {
	    for (var key in propOptions) {
	      var altKey = hyphenate(key);
	      if (process.env.NODE_ENV !== 'production') {
	        var keyInLowerCase = key.toLowerCase();
	        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
	          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
	        }
	      }
	      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
	    }
	  }
	  return res;
	}
	
	function checkProp(res, hash, key, altKey, preserve) {
	  if (isDef(hash)) {
	    if (hasOwn(hash, key)) {
	      res[key] = hash[key];
	      if (!preserve) {
	        delete hash[key];
	      }
	      return true;
	    } else if (hasOwn(hash, altKey)) {
	      res[key] = hash[altKey];
	      if (!preserve) {
	        delete hash[altKey];
	      }
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	// The template compiler attempts to minimize the need for normalization by
	// statically analyzing the template at compile time.
	//
	// For plain HTML markup, normalization can be completely skipped because the
	// generated render function is guaranteed to return Array<VNode>. There are
	// two cases where extra normalization is needed:
	
	// 1. When the children contains components - because a functional component
	// may return an Array instead of a single root. In this case, just a simple
	// normalization is needed - if any child is an Array, we flatten the whole
	// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
	// because functional components already normalize their own children.
	function simpleNormalizeChildren(children) {
	  for (var i = 0; i < children.length; i++) {
	    if (Array.isArray(children[i])) {
	      return Array.prototype.concat.apply([], children);
	    }
	  }
	  return children;
	}
	
	// 2. When the children contains constructs that always generated nested Arrays,
	// e.g. <template>, <slot>, v-for, or when the children is provided by user
	// with hand-written render functions / JSX. In such cases a full normalization
	// is needed to cater to all possible types of children values.
	function normalizeChildren(children) {
	  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
	}
	
	function isTextNode(node) {
	  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
	}
	
	function normalizeArrayChildren(children, nestedIndex) {
	  var res = [];
	  var i, c, last;
	  for (i = 0; i < children.length; i++) {
	    c = children[i];
	    if (isUndef(c) || typeof c === 'boolean') {
	      continue;
	    }
	    last = res[res.length - 1];
	    //  nested
	    if (Array.isArray(c)) {
	      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
	    } else if (isPrimitive(c)) {
	      if (isTextNode(last)) {
	        // merge adjacent text nodes
	        // this is necessary for SSR hydration because text nodes are
	        // essentially merged when rendered to HTML strings
	        last.text += String(c);
	      } else if (c !== '') {
	        // convert primitive to vnode
	        res.push(createTextVNode(c));
	      }
	    } else {
	      if (isTextNode(c) && isTextNode(last)) {
	        // merge adjacent text nodes
	        res[res.length - 1] = createTextVNode(last.text + c.text);
	      } else {
	        // default key for nested array children (likely generated by v-for)
	        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
	          c.key = "__vlist" + nestedIndex + "_" + i + "__";
	        }
	        res.push(c);
	      }
	    }
	  }
	  return res;
	}
	
	/*  */
	
	function ensureCtor(comp, base) {
	  if (comp.__esModule && comp.default) {
	    comp = comp.default;
	  }
	  return isObject(comp) ? base.extend(comp) : comp;
	}
	
	function createAsyncPlaceholder(factory, data, context, children, tag) {
	  var node = createEmptyVNode();
	  node.asyncFactory = factory;
	  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
	  return node;
	}
	
	function resolveAsyncComponent(factory, baseCtor, context) {
	  if (isTrue(factory.error) && isDef(factory.errorComp)) {
	    return factory.errorComp;
	  }
	
	  if (isDef(factory.resolved)) {
	    return factory.resolved;
	  }
	
	  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
	    return factory.loadingComp;
	  }
	
	  if (isDef(factory.contexts)) {
	    // already pending
	    factory.contexts.push(context);
	  } else {
	    var contexts = factory.contexts = [context];
	    var sync = true;
	
	    var forceRender = function forceRender() {
	      for (var i = 0, l = contexts.length; i < l; i++) {
	        contexts[i].$forceUpdate();
	      }
	    };
	
	    var resolve = once(function (res) {
	      // cache resolved
	      factory.resolved = ensureCtor(res, baseCtor);
	      // invoke callbacks only if this is not a synchronous resolve
	      // (async resolves are shimmed as synchronous during SSR)
	      if (!sync) {
	        forceRender();
	      }
	    });
	
	    var reject = once(function (reason) {
	      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
	      if (isDef(factory.errorComp)) {
	        factory.error = true;
	        forceRender();
	      }
	    });
	
	    var res = factory(resolve, reject);
	
	    if (isObject(res)) {
	      if (typeof res.then === 'function') {
	        // () => Promise
	        if (isUndef(factory.resolved)) {
	          res.then(resolve, reject);
	        }
	      } else if (isDef(res.component) && typeof res.component.then === 'function') {
	        res.component.then(resolve, reject);
	
	        if (isDef(res.error)) {
	          factory.errorComp = ensureCtor(res.error, baseCtor);
	        }
	
	        if (isDef(res.loading)) {
	          factory.loadingComp = ensureCtor(res.loading, baseCtor);
	          if (res.delay === 0) {
	            factory.loading = true;
	          } else {
	            setTimeout(function () {
	              if (isUndef(factory.resolved) && isUndef(factory.error)) {
	                factory.loading = true;
	                forceRender();
	              }
	            }, res.delay || 200);
	          }
	        }
	
	        if (isDef(res.timeout)) {
	          setTimeout(function () {
	            if (isUndef(factory.resolved)) {
	              reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
	            }
	          }, res.timeout);
	        }
	      }
	    }
	
	    sync = false;
	    // return in case resolved synchronously
	    return factory.loading ? factory.loadingComp : factory.resolved;
	  }
	}
	
	/*  */
	
	function getFirstComponentChild(children) {
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      var c = children[i];
	      if (isDef(c) && isDef(c.componentOptions)) {
	        return c;
	      }
	    }
	  }
	}
	
	/*  */
	
	/*  */
	
	function initEvents(vm) {
	  vm._events = Object.create(null);
	  vm._hasHookEvent = false;
	  // init parent attached events
	  var listeners = vm.$options._parentListeners;
	  if (listeners) {
	    updateComponentListeners(vm, listeners);
	  }
	}
	
	var target;
	
	function add(event, fn, once$$1) {
	  if (once$$1) {
	    target.$once(event, fn);
	  } else {
	    target.$on(event, fn);
	  }
	}
	
	function remove$1(event, fn) {
	  target.$off(event, fn);
	}
	
	function updateComponentListeners(vm, listeners, oldListeners) {
	  target = vm;
	  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
	}
	
	function eventsMixin(Vue) {
	  var hookRE = /^hook:/;
	  Vue.prototype.$on = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    if (Array.isArray(event)) {
	      for (var i = 0, l = event.length; i < l; i++) {
	        this$1.$on(event[i], fn);
	      }
	    } else {
	      (vm._events[event] || (vm._events[event] = [])).push(fn);
	      // optimize hook:event cost by using a boolean flag marked at registration
	      // instead of a hash lookup
	      if (hookRE.test(event)) {
	        vm._hasHookEvent = true;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$once = function (event, fn) {
	    var vm = this;
	    function on() {
	      vm.$off(event, on);
	      fn.apply(vm, arguments);
	    }
	    on.fn = fn;
	    vm.$on(event, on);
	    return vm;
	  };
	
	  Vue.prototype.$off = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    // all
	    if (!arguments.length) {
	      vm._events = Object.create(null);
	      return vm;
	    }
	    // array of events
	    if (Array.isArray(event)) {
	      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
	        this$1.$off(event[i$1], fn);
	      }
	      return vm;
	    }
	    // specific event
	    var cbs = vm._events[event];
	    if (!cbs) {
	      return vm;
	    }
	    if (arguments.length === 1) {
	      vm._events[event] = null;
	      return vm;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$emit = function (event) {
	    var vm = this;
	    if (process.env.NODE_ENV !== 'production') {
	      var lowerCaseEvent = event.toLowerCase();
	      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
	        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
	      }
	    }
	    var cbs = vm._events[event];
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        try {
	          cbs[i].apply(vm, args);
	        } catch (e) {
	          handleError(e, vm, "event handler for \"" + event + "\"");
	        }
	      }
	    }
	    return vm;
	  };
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving raw children VNodes into a slot object.
	 */
	function resolveSlots(children, context) {
	  var slots = {};
	  if (!children) {
	    return slots;
	  }
	  var defaultSlot = [];
	  for (var i = 0, l = children.length; i < l; i++) {
	    var child = children[i];
	    // named slots should only be respected if the vnode was rendered in the
	    // same context.
	    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {
	      var name = child.data.slot;
	      var slot = slots[name] || (slots[name] = []);
	      if (child.tag === 'template') {
	        slot.push.apply(slot, child.children);
	      } else {
	        slot.push(child);
	      }
	    } else {
	      defaultSlot.push(child);
	    }
	  }
	  // ignore whitespace
	  if (!defaultSlot.every(isWhitespace)) {
	    slots.default = defaultSlot;
	  }
	  return slots;
	}
	
	function isWhitespace(node) {
	  return node.isComment || node.text === ' ';
	}
	
	function resolveScopedSlots(fns, // see flow/vnode
	res) {
	  res = res || {};
	  for (var i = 0; i < fns.length; i++) {
	    if (Array.isArray(fns[i])) {
	      resolveScopedSlots(fns[i], res);
	    } else {
	      res[fns[i].key] = fns[i].fn;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var activeInstance = null;
	var isUpdatingChildComponent = false;
	
	function initLifecycle(vm) {
	  var options = vm.$options;
	
	  // locate first non-abstract parent
	  var parent = options.parent;
	  if (parent && !options.abstract) {
	    while (parent.$options.abstract && parent.$parent) {
	      parent = parent.$parent;
	    }
	    parent.$children.push(vm);
	  }
	
	  vm.$parent = parent;
	  vm.$root = parent ? parent.$root : vm;
	
	  vm.$children = [];
	  vm.$refs = {};
	
	  vm._watcher = null;
	  vm._inactive = null;
	  vm._directInactive = false;
	  vm._isMounted = false;
	  vm._isDestroyed = false;
	  vm._isBeingDestroyed = false;
	}
	
	function lifecycleMixin(Vue) {
	  Vue.prototype._update = function (vnode, hydrating) {
	    var vm = this;
	    if (vm._isMounted) {
	      callHook(vm, 'beforeUpdate');
	    }
	    var prevEl = vm.$el;
	    var prevVnode = vm._vnode;
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    vm._vnode = vnode;
	    // Vue.prototype.__patch__ is injected in entry points
	    // based on the rendering backend used.
	    if (!prevVnode) {
	      // initial render
	      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
	      , vm.$options._parentElm, vm.$options._refElm);
	      // no need for the ref nodes after initial patch
	      // this prevents keeping a detached DOM tree in memory (#5851)
	      vm.$options._parentElm = vm.$options._refElm = null;
	    } else {
	      // updates
	      vm.$el = vm.__patch__(prevVnode, vnode);
	    }
	    activeInstance = prevActiveInstance;
	    // update __vue__ reference
	    if (prevEl) {
	      prevEl.__vue__ = null;
	    }
	    if (vm.$el) {
	      vm.$el.__vue__ = vm;
	    }
	    // if parent is an HOC, update its $el as well
	    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	      vm.$parent.$el = vm.$el;
	    }
	    // updated hook is called by the scheduler to ensure that children are
	    // updated in a parent's updated hook.
	  };
	
	  Vue.prototype.$forceUpdate = function () {
	    var vm = this;
	    if (vm._watcher) {
	      vm._watcher.update();
	    }
	  };
	
	  Vue.prototype.$destroy = function () {
	    var vm = this;
	    if (vm._isBeingDestroyed) {
	      return;
	    }
	    callHook(vm, 'beforeDestroy');
	    vm._isBeingDestroyed = true;
	    // remove self from parent
	    var parent = vm.$parent;
	    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	      remove(parent.$children, vm);
	    }
	    // teardown watchers
	    if (vm._watcher) {
	      vm._watcher.teardown();
	    }
	    var i = vm._watchers.length;
	    while (i--) {
	      vm._watchers[i].teardown();
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (vm._data.__ob__) {
	      vm._data.__ob__.vmCount--;
	    }
	    // call the last hook...
	    vm._isDestroyed = true;
	    // invoke destroy hooks on current rendered tree
	    vm.__patch__(vm._vnode, null);
	    // fire destroyed hook
	    callHook(vm, 'destroyed');
	    // turn off all instance listeners.
	    vm.$off();
	    // remove __vue__ reference
	    if (vm.$el) {
	      vm.$el.__vue__ = null;
	    }
	  };
	}
	
	function mountComponent(vm, el, hydrating) {
	  vm.$el = el;
	  if (!vm.$options.render) {
	    vm.$options.render = createEmptyVNode;
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
	        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
	      } else {
	        warn('Failed to mount component: template or render function not defined.', vm);
	      }
	    }
	  }
	  callHook(vm, 'beforeMount');
	
	  var updateComponent;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	    updateComponent = function updateComponent() {
	      var name = vm._name;
	      var id = vm._uid;
	      var startTag = "vue-perf-start:" + id;
	      var endTag = "vue-perf-end:" + id;
	
	      mark(startTag);
	      var vnode = vm._render();
	      mark(endTag);
	      measure(name + " render", startTag, endTag);
	
	      mark(startTag);
	      vm._update(vnode, hydrating);
	      mark(endTag);
	      measure(name + " patch", startTag, endTag);
	    };
	  } else {
	    updateComponent = function updateComponent() {
	      vm._update(vm._render(), hydrating);
	    };
	  }
	
	  vm._watcher = new Watcher(vm, updateComponent, noop);
	  hydrating = false;
	
	  // manually mounted instance, call mounted on self
	  // mounted is called for render-created child components in its inserted hook
	  if (vm.$vnode == null) {
	    vm._isMounted = true;
	    callHook(vm, 'mounted');
	  }
	  return vm;
	}
	
	function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = true;
	  }
	
	  // determine whether component has slot children
	  // we need to do this before overwriting $options._renderChildren
	  var hasChildren = !!(renderChildren || // has new static slots
	  vm.$options._renderChildren || // has old static slots
	  parentVnode.data.scopedSlots || // has new scoped slots
	  vm.$scopedSlots !== emptyObject // has old scoped slots
	  );
	
	  vm.$options._parentVnode = parentVnode;
	  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
	
	  if (vm._vnode) {
	    // update child tree's parent
	    vm._vnode.parent = parentVnode;
	  }
	  vm.$options._renderChildren = renderChildren;
	
	  // update $attrs and $listensers hash
	  // these are also reactive so they may trigger child update if the child
	  // used them during render
	  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
	  vm.$listeners = listeners;
	
	  // update props
	  if (propsData && vm.$options.props) {
	    observerState.shouldConvert = false;
	    var props = vm._props;
	    var propKeys = vm.$options._propKeys || [];
	    for (var i = 0; i < propKeys.length; i++) {
	      var key = propKeys[i];
	      props[key] = validateProp(key, vm.$options.props, propsData, vm);
	    }
	    observerState.shouldConvert = true;
	    // keep a copy of raw propsData
	    vm.$options.propsData = propsData;
	  }
	
	  // update listeners
	  if (listeners) {
	    var oldListeners = vm.$options._parentListeners;
	    vm.$options._parentListeners = listeners;
	    updateComponentListeners(vm, listeners, oldListeners);
	  }
	  // resolve slots + force update if has children
	  if (hasChildren) {
	    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
	    vm.$forceUpdate();
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = false;
	  }
	}
	
	function isInInactiveTree(vm) {
	  while (vm && (vm = vm.$parent)) {
	    if (vm._inactive) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function activateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = false;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  } else if (vm._directInactive) {
	    return;
	  }
	  if (vm._inactive || vm._inactive === null) {
	    vm._inactive = false;
	    for (var i = 0; i < vm.$children.length; i++) {
	      activateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'activated');
	  }
	}
	
	function deactivateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = true;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  }
	  if (!vm._inactive) {
	    vm._inactive = true;
	    for (var i = 0; i < vm.$children.length; i++) {
	      deactivateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'deactivated');
	  }
	}
	
	function callHook(vm, hook) {
	  var handlers = vm.$options[hook];
	  if (handlers) {
	    for (var i = 0, j = handlers.length; i < j; i++) {
	      try {
	        handlers[i].call(vm);
	      } catch (e) {
	        handleError(e, vm, hook + " hook");
	      }
	    }
	  }
	  if (vm._hasHookEvent) {
	    vm.$emit('hook:' + hook);
	  }
	}
	
	/*  */
	
	var MAX_UPDATE_COUNT = 100;
	
	var queue = [];
	var activatedChildren = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;
	
	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState() {
	  index = queue.length = activatedChildren.length = 0;
	  has = {};
	  if (process.env.NODE_ENV !== 'production') {
	    circular = {};
	  }
	  waiting = flushing = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue() {
	  flushing = true;
	  var watcher, id;
	
	  // Sort queue before flush.
	  // This ensures that:
	  // 1. Components are updated from parent to child. (because parent is always
	  //    created before the child)
	  // 2. A component's user watchers are run before its render watcher (because
	  //    user watchers are created before the render watcher)
	  // 3. If a component is destroyed during a parent component's watcher run,
	  //    its watchers can be skipped.
	  queue.sort(function (a, b) {
	    return a.id - b.id;
	  });
	
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (index = 0; index < queue.length; index++) {
	    watcher = queue[index];
	    id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > MAX_UPDATE_COUNT) {
	        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
	        break;
	      }
	    }
	  }
	
	  // keep copies of post queues before resetting state
	  var activatedQueue = activatedChildren.slice();
	  var updatedQueue = queue.slice();
	
	  resetSchedulerState();
	
	  // call component updated and activated hooks
	  callActivatedHooks(activatedQueue);
	  callUpdatedHooks(updatedQueue);
	
	  // devtool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }
	}
	
	function callUpdatedHooks(queue) {
	  var i = queue.length;
	  while (i--) {
	    var watcher = queue[i];
	    var vm = watcher.vm;
	    if (vm._watcher === watcher && vm._isMounted) {
	      callHook(vm, 'updated');
	    }
	  }
	}
	
	/**
	 * Queue a kept-alive component that was activated during patch.
	 * The queue will be processed after the entire tree has been patched.
	 */
	function queueActivatedComponent(vm) {
	  // setting _inactive to false here so that a render function can
	  // rely on checking whether it's in an inactive tree (e.g. router-view)
	  vm._inactive = false;
	  activatedChildren.push(vm);
	}
	
	function callActivatedHooks(queue) {
	  for (var i = 0; i < queue.length; i++) {
	    queue[i]._inactive = true;
	    activateChildComponent(queue[i], true /* true */);
	  }
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    has[id] = true;
	    if (!flushing) {
	      queue.push(watcher);
	    } else {
	      // if already flushing, splice the watcher based on its id
	      // if already past its id, it will be run next immediately.
	      var i = queue.length - 1;
	      while (i > index && queue[i].id > watcher.id) {
	        i--;
	      }
	      queue.splice(i + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushSchedulerQueue);
	    }
	  }
	}
	
	/*  */
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 */
	var Watcher = function Watcher(vm, expOrFn, cb, options) {
	  this.vm = vm;
	  vm._watchers.push(this);
	  // options
	  if (options) {
	    this.deep = !!options.deep;
	    this.user = !!options.user;
	    this.lazy = !!options.lazy;
	    this.sync = !!options.sync;
	  } else {
	    this.deep = this.user = this.lazy = this.sync = false;
	  }
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
	  // parse expression for getter
	  if (typeof expOrFn === 'function') {
	    this.getter = expOrFn;
	  } else {
	    this.getter = parsePath(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
	    }
	  }
	  this.value = this.lazy ? undefined : this.get();
	};
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	Watcher.prototype.get = function get() {
	  pushTarget(this);
	  var value;
	  var vm = this.vm;
	  try {
	    value = this.getter.call(vm, vm);
	  } catch (e) {
	    if (this.user) {
	      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
	    } else {
	      throw e;
	    }
	  } finally {
	    // "touch" every property so they are all tracked as
	    // dependencies for deep watching
	    if (this.deep) {
	      traverse(value);
	    }
	    popTarget();
	    this.cleanupDeps();
	  }
	  return value;
	};
	
	/**
	 * Add a dependency to this directive.
	 */
	Watcher.prototype.addDep = function addDep(dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	Watcher.prototype.cleanupDeps = function cleanupDeps() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this$1.deps[i];
	    if (!this$1.newDepIds.has(dep.id)) {
	      dep.removeSub(this$1);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 */
	Watcher.prototype.update = function update() {
	  /* istanbul ignore else */
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync) {
	    this.run();
	  } else {
	    queueWatcher(this);
	  }
	};
	
	/**
	 * Scheduler job interface.
	 * Will be called by the scheduler.
	 */
	Watcher.prototype.run = function run() {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated.
	    isObject(value) || this.deep) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      if (this.user) {
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	Watcher.prototype.evaluate = function evaluate() {
	  this.value = this.get();
	  this.dirty = false;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	Watcher.prototype.depend = function depend() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    this$1.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subscriber list.
	 */
	Watcher.prototype.teardown = function teardown() {
	  var this$1 = this;
	
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed.
	    if (!this.vm._isBeingDestroyed) {
	      remove(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this$1.deps[i].removeSub(this$1);
	    }
	    this.active = false;
	  }
	};
	
	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	var seenObjects = new _Set();
	function traverse(val) {
	  seenObjects.clear();
	  _traverse(val, seenObjects);
	}
	
	function _traverse(val, seen) {
	  var i, keys;
	  var isA = Array.isArray(val);
	  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
	    return;
	  }
	  if (val.__ob__) {
	    var depId = val.__ob__.dep.id;
	    if (seen.has(depId)) {
	      return;
	    }
	    seen.add(depId);
	  }
	  if (isA) {
	    i = val.length;
	    while (i--) {
	      _traverse(val[i], seen);
	    }
	  } else {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      _traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	/*  */
	
	var sharedPropertyDefinition = {
	  enumerable: true,
	  configurable: true,
	  get: noop,
	  set: noop
	};
	
	function proxy(target, sourceKey, key) {
	  sharedPropertyDefinition.get = function proxyGetter() {
	    return this[sourceKey][key];
	  };
	  sharedPropertyDefinition.set = function proxySetter(val) {
	    this[sourceKey][key] = val;
	  };
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function initState(vm) {
	  vm._watchers = [];
	  var opts = vm.$options;
	  if (opts.props) {
	    initProps(vm, opts.props);
	  }
	  if (opts.methods) {
	    initMethods(vm, opts.methods);
	  }
	  if (opts.data) {
	    initData(vm);
	  } else {
	    observe(vm._data = {}, true /* asRootData */);
	  }
	  if (opts.computed) {
	    initComputed(vm, opts.computed);
	  }
	  if (opts.watch && opts.watch !== nativeWatch) {
	    initWatch(vm, opts.watch);
	  }
	}
	
	function checkOptionType(vm, name) {
	  var option = vm.$options[name];
	  if (!isPlainObject(option)) {
	    warn("component option \"" + name + "\" should be an object.", vm);
	  }
	}
	
	function initProps(vm, propsOptions) {
	  var propsData = vm.$options.propsData || {};
	  var props = vm._props = {};
	  // cache prop keys so that future props updates can iterate using Array
	  // instead of dynamic object key enumeration.
	  var keys = vm.$options._propKeys = [];
	  var isRoot = !vm.$parent;
	  // root instance props should be converted
	  observerState.shouldConvert = isRoot;
	  var loop = function loop(key) {
	    keys.push(key);
	    var value = validateProp(key, propsOptions, propsData, vm);
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
	        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
	      }
	      defineReactive$$1(props, key, value, function () {
	        if (vm.$parent && !isUpdatingChildComponent) {
	          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
	        }
	      });
	    } else {
	      defineReactive$$1(props, key, value);
	    }
	    // static props are already proxied on the component's prototype
	    // during Vue.extend(). We only need to proxy props defined at
	    // instantiation here.
	    if (!(key in vm)) {
	      proxy(vm, "_props", key);
	    }
	  };
	
	  for (var key in propsOptions) {
	    loop(key);
	  }observerState.shouldConvert = true;
	}
	
	function initData(vm) {
	  var data = vm.$options.data;
	  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
	  if (!isPlainObject(data)) {
	    data = {};
	    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var props = vm.$options.props;
	  var methods = vm.$options.methods;
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods && hasOwn(methods, key)) {
	        warn("method \"" + key + "\" has already been defined as a data property.", vm);
	      }
	    }
	    if (props && hasOwn(props, key)) {
	      process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
	    } else if (!isReserved(key)) {
	      proxy(vm, "_data", key);
	    }
	  }
	  // observe data
	  observe(data, true /* asRootData */);
	}
	
	function getData(data, vm) {
	  try {
	    return data.call(vm);
	  } catch (e) {
	    handleError(e, vm, "data()");
	    return {};
	  }
	}
	
	var computedWatcherOptions = { lazy: true };
	
	function initComputed(vm, computed) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');
	  var watchers = vm._computedWatchers = Object.create(null);
	
	  for (var key in computed) {
	    var userDef = computed[key];
	    var getter = typeof userDef === 'function' ? userDef : userDef.get;
	    if (process.env.NODE_ENV !== 'production' && getter == null) {
	      warn("Getter is missing for computed property \"" + key + "\".", vm);
	    }
	    // create internal watcher for the computed property.
	    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
	
	    // component-defined computed properties are already defined on the
	    // component prototype. We only need to define computed properties defined
	    // at instantiation here.
	    if (!(key in vm)) {
	      defineComputed(vm, key, userDef);
	    } else if (process.env.NODE_ENV !== 'production') {
	      if (key in vm.$data) {
	        warn("The computed property \"" + key + "\" is already defined in data.", vm);
	      } else if (vm.$options.props && key in vm.$options.props) {
	        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function defineComputed(target, key, userDef) {
	  if (typeof userDef === 'function') {
	    sharedPropertyDefinition.get = createComputedGetter(key);
	    sharedPropertyDefinition.set = noop;
	  } else {
	    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
	    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
	  }
	  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
	    sharedPropertyDefinition.set = function () {
	      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
	    };
	  }
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function createComputedGetter(key) {
	  return function computedGetter() {
	    var watcher = this._computedWatchers && this._computedWatchers[key];
	    if (watcher) {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    }
	  };
	}
	
	function initMethods(vm, methods) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');
	  var props = vm.$options.props;
	  for (var key in methods) {
	    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods[key] == null) {
	        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
	      }
	      if (props && hasOwn(props, key)) {
	        warn("method \"" + key + "\" has already been defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function initWatch(vm, watch) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');
	  for (var key in watch) {
	    var handler = watch[key];
	    if (Array.isArray(handler)) {
	      for (var i = 0; i < handler.length; i++) {
	        createWatcher(vm, key, handler[i]);
	      }
	    } else {
	      createWatcher(vm, key, handler);
	    }
	  }
	}
	
	function createWatcher(vm, keyOrFn, handler, options) {
	  if (isPlainObject(handler)) {
	    options = handler;
	    handler = handler.handler;
	  }
	  if (typeof handler === 'string') {
	    handler = vm[handler];
	  }
	  return vm.$watch(keyOrFn, handler, options);
	}
	
	function stateMixin(Vue) {
	  // flow somehow has problems with directly declared definition object
	  // when using Object.defineProperty, so we have to procedurally build up
	  // the object here.
	  var dataDef = {};
	  dataDef.get = function () {
	    return this._data;
	  };
	  var propsDef = {};
	  propsDef.get = function () {
	    return this._props;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    dataDef.set = function (newData) {
	      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
	    };
	    propsDef.set = function () {
	      warn("$props is readonly.", this);
	    };
	  }
	  Object.defineProperty(Vue.prototype, '$data', dataDef);
	  Object.defineProperty(Vue.prototype, '$props', propsDef);
	
	  Vue.prototype.$set = set;
	  Vue.prototype.$delete = del;
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    if (isPlainObject(cb)) {
	      return createWatcher(vm, expOrFn, cb, options);
	    }
	    options = options || {};
	    options.user = true;
	    var watcher = new Watcher(vm, expOrFn, cb, options);
	    if (options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	}
	
	/*  */
	
	function initProvide(vm) {
	  var provide = vm.$options.provide;
	  if (provide) {
	    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
	  }
	}
	
	function initInjections(vm) {
	  var result = resolveInject(vm.$options.inject, vm);
	  if (result) {
	    observerState.shouldConvert = false;
	    Object.keys(result).forEach(function (key) {
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        defineReactive$$1(vm, key, result[key], function () {
	          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
	        });
	      } else {
	        defineReactive$$1(vm, key, result[key]);
	      }
	    });
	    observerState.shouldConvert = true;
	  }
	}
	
	function resolveInject(inject, vm) {
	  if (inject) {
	    // inject is :any because flow is not smart enough to figure out cached
	    var result = Object.create(null);
	    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
	
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var provideKey = inject[key];
	      var source = vm;
	      while (source) {
	        if (source._provided && provideKey in source._provided) {
	          result[key] = source._provided[provideKey];
	          break;
	        }
	        source = source.$parent;
	      }
	      if (process.env.NODE_ENV !== 'production' && !source) {
	        warn("Injection \"" + key + "\" not found", vm);
	      }
	    }
	    return result;
	  }
	}
	
	/*  */
	
	function createFunctionalComponent(Ctor, propsData, data, context, children) {
	  var props = {};
	  var propOptions = Ctor.options.props;
	  if (isDef(propOptions)) {
	    for (var key in propOptions) {
	      props[key] = validateProp(key, propOptions, propsData || {});
	    }
	  } else {
	    if (isDef(data.attrs)) {
	      mergeProps(props, data.attrs);
	    }
	    if (isDef(data.props)) {
	      mergeProps(props, data.props);
	    }
	  }
	  // ensure the createElement function in functional components
	  // gets a unique context - this is necessary for correct named slot check
	  var _context = Object.create(context);
	  var h = function h(a, b, c, d) {
	    return createElement(_context, a, b, c, d, true);
	  };
	  var vnode = Ctor.options.render.call(null, h, {
	    data: data,
	    props: props,
	    children: children,
	    parent: context,
	    listeners: data.on || {},
	    injections: resolveInject(Ctor.options.inject, context),
	    slots: function slots() {
	      return resolveSlots(children, context);
	    }
	  });
	  if (vnode instanceof VNode) {
	    vnode.functionalContext = context;
	    vnode.functionalOptions = Ctor.options;
	    if (data.slot) {
	      (vnode.data || (vnode.data = {})).slot = data.slot;
	    }
	  }
	  return vnode;
	}
	
	function mergeProps(to, from) {
	  for (var key in from) {
	    to[camelize(key)] = from[key];
	  }
	}
	
	/*  */
	
	// hooks to be invoked on component VNodes during patch
	var componentVNodeHooks = {
	  init: function init(vnode, hydrating, parentElm, refElm) {
	    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
	      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
	      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	    } else if (vnode.data.keepAlive) {
	      // kept-alive components, treat as a patch
	      var mountedNode = vnode; // work around flow
	      componentVNodeHooks.prepatch(mountedNode, mountedNode);
	    }
	  },
	
	  prepatch: function prepatch(oldVnode, vnode) {
	    var options = vnode.componentOptions;
	    var child = vnode.componentInstance = oldVnode.componentInstance;
	    updateChildComponent(child, options.propsData, // updated props
	    options.listeners, // updated listeners
	    vnode, // new parent vnode
	    options.children // new children
	    );
	  },
	
	  insert: function insert(vnode) {
	    var context = vnode.context;
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isMounted) {
	      componentInstance._isMounted = true;
	      callHook(componentInstance, 'mounted');
	    }
	    if (vnode.data.keepAlive) {
	      if (context._isMounted) {
	        // vue-router#1212
	        // During updates, a kept-alive component's child components may
	        // change, so directly walking the tree here may call activated hooks
	        // on incorrect children. Instead we push them into a queue which will
	        // be processed after the whole patch process ended.
	        queueActivatedComponent(componentInstance);
	      } else {
	        activateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  },
	
	  destroy: function destroy(vnode) {
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isDestroyed) {
	      if (!vnode.data.keepAlive) {
	        componentInstance.$destroy();
	      } else {
	        deactivateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  }
	};
	
	var hooksToMerge = Object.keys(componentVNodeHooks);
	
	function createComponent(Ctor, data, context, children, tag) {
	  if (isUndef(Ctor)) {
	    return;
	  }
	
	  var baseCtor = context.$options._base;
	
	  // plain options object: turn it into a constructor
	  if (isObject(Ctor)) {
	    Ctor = baseCtor.extend(Ctor);
	  }
	
	  // if at this stage it's not a constructor or an async component factory,
	  // reject.
	  if (typeof Ctor !== 'function') {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Invalid Component definition: " + String(Ctor), context);
	    }
	    return;
	  }
	
	  // async component
	  var asyncFactory;
	  if (isUndef(Ctor.cid)) {
	    asyncFactory = Ctor;
	    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
	    if (Ctor === undefined) {
	      // return a placeholder node for async component, which is rendered
	      // as a comment node but preserves all the raw information for the node.
	      // the information will be used for async server-rendering and hydration.
	      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
	    }
	  }
	
	  data = data || {};
	
	  // resolve constructor options in case global mixins are applied after
	  // component constructor creation
	  resolveConstructorOptions(Ctor);
	
	  // transform component v-model data into props & events
	  if (isDef(data.model)) {
	    transformModel(Ctor.options, data);
	  }
	
	  // extract props
	  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
	
	  // functional component
	  if (isTrue(Ctor.options.functional)) {
	    return createFunctionalComponent(Ctor, propsData, data, context, children);
	  }
	
	  // extract listeners, since these needs to be treated as
	  // child component listeners instead of DOM listeners
	  var listeners = data.on;
	  // replace with listeners with .native modifier
	  // so it gets processed during parent component patch.
	  data.on = data.nativeOn;
	
	  if (isTrue(Ctor.options.abstract)) {
	    // abstract components do not keep anything
	    // other than props & listeners & slot
	
	    // work around flow
	    var slot = data.slot;
	    data = {};
	    if (slot) {
	      data.slot = slot;
	    }
	  }
	
	  // merge component management hooks onto the placeholder node
	  mergeHooks(data);
	
	  // return a placeholder vnode
	  var name = Ctor.options.name || tag;
	  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
	  return vnode;
	}
	
	function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
	parent, // activeInstance in lifecycle state
	parentElm, refElm) {
	  var vnodeComponentOptions = vnode.componentOptions;
	  var options = {
	    _isComponent: true,
	    parent: parent,
	    propsData: vnodeComponentOptions.propsData,
	    _componentTag: vnodeComponentOptions.tag,
	    _parentVnode: vnode,
	    _parentListeners: vnodeComponentOptions.listeners,
	    _renderChildren: vnodeComponentOptions.children,
	    _parentElm: parentElm || null,
	    _refElm: refElm || null
	  };
	  // check inline-template render functions
	  var inlineTemplate = vnode.data.inlineTemplate;
	  if (isDef(inlineTemplate)) {
	    options.render = inlineTemplate.render;
	    options.staticRenderFns = inlineTemplate.staticRenderFns;
	  }
	  return new vnodeComponentOptions.Ctor(options);
	}
	
	function mergeHooks(data) {
	  if (!data.hook) {
	    data.hook = {};
	  }
	  for (var i = 0; i < hooksToMerge.length; i++) {
	    var key = hooksToMerge[i];
	    var fromParent = data.hook[key];
	    var ours = componentVNodeHooks[key];
	    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
	  }
	}
	
	function mergeHook$1(one, two) {
	  return function (a, b, c, d) {
	    one(a, b, c, d);
	    two(a, b, c, d);
	  };
	}
	
	// transform component v-model info (value and callback) into
	// prop and event handler respectively.
	function transformModel(options, data) {
	  var prop = options.model && options.model.prop || 'value';
	  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
	  var on = data.on || (data.on = {});
	  if (isDef(on[event])) {
	    on[event] = [data.model.callback].concat(on[event]);
	  } else {
	    on[event] = data.model.callback;
	  }
	}
	
	/*  */
	
	var SIMPLE_NORMALIZE = 1;
	var ALWAYS_NORMALIZE = 2;
	
	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
	  if (Array.isArray(data) || isPrimitive(data)) {
	    normalizationType = children;
	    children = data;
	    data = undefined;
	  }
	  if (isTrue(alwaysNormalize)) {
	    normalizationType = ALWAYS_NORMALIZE;
	  }
	  return _createElement(context, tag, data, children, normalizationType);
	}
	
	function _createElement(context, tag, data, children, normalizationType) {
	  if (isDef(data) && isDef(data.__ob__)) {
	    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
	    return createEmptyVNode();
	  }
	  // object syntax in v-bind
	  if (isDef(data) && isDef(data.is)) {
	    tag = data.is;
	  }
	  if (!tag) {
	    // in case of component :is set to falsy value
	    return createEmptyVNode();
	  }
	  // warn against non-primitive key
	  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
	    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
	  }
	  // support single function children as default scoped slot
	  if (Array.isArray(children) && typeof children[0] === 'function') {
	    data = data || {};
	    data.scopedSlots = { default: children[0] };
	    children.length = 0;
	  }
	  if (normalizationType === ALWAYS_NORMALIZE) {
	    children = normalizeChildren(children);
	  } else if (normalizationType === SIMPLE_NORMALIZE) {
	    children = simpleNormalizeChildren(children);
	  }
	  var vnode, ns;
	  if (typeof tag === 'string') {
	    var Ctor;
	    ns = config.getTagNamespace(tag);
	    if (config.isReservedTag(tag)) {
	      // platform built-in elements
	      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
	    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
	      // component
	      vnode = createComponent(Ctor, data, context, children, tag);
	    } else {
	      // unknown or unlisted namespaced elements
	      // check at runtime because it may get assigned a namespace when its
	      // parent normalizes children
	      vnode = new VNode(tag, data, children, undefined, undefined, context);
	    }
	  } else {
	    // direct component options / constructor
	    vnode = createComponent(tag, data, context, children);
	  }
	  if (isDef(vnode)) {
	    if (ns) {
	      applyNS(vnode, ns);
	    }
	    return vnode;
	  } else {
	    return createEmptyVNode();
	  }
	}
	
	function applyNS(vnode, ns) {
	  vnode.ns = ns;
	  if (vnode.tag === 'foreignObject') {
	    // use default namespace inside foreignObject
	    return;
	  }
	  if (isDef(vnode.children)) {
	    for (var i = 0, l = vnode.children.length; i < l; i++) {
	      var child = vnode.children[i];
	      if (isDef(child.tag) && isUndef(child.ns)) {
	        applyNS(child, ns);
	      }
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering v-for lists.
	 */
	function renderList(val, render) {
	  var ret, i, l, keys, key;
	  if (Array.isArray(val) || typeof val === 'string') {
	    ret = new Array(val.length);
	    for (i = 0, l = val.length; i < l; i++) {
	      ret[i] = render(val[i], i);
	    }
	  } else if (typeof val === 'number') {
	    ret = new Array(val);
	    for (i = 0; i < val; i++) {
	      ret[i] = render(i + 1, i);
	    }
	  } else if (isObject(val)) {
	    keys = Object.keys(val);
	    ret = new Array(keys.length);
	    for (i = 0, l = keys.length; i < l; i++) {
	      key = keys[i];
	      ret[i] = render(val[key], key, i);
	    }
	  }
	  if (isDef(ret)) {
	    ret._isVList = true;
	  }
	  return ret;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering <slot>
	 */
	function renderSlot(name, fallback, props, bindObject) {
	  var scopedSlotFn = this.$scopedSlots[name];
	  if (scopedSlotFn) {
	    // scoped slot
	    props = props || {};
	    if (bindObject) {
	      props = extend(extend({}, bindObject), props);
	    }
	    return scopedSlotFn(props) || fallback;
	  } else {
	    var slotNodes = this.$slots[name];
	    // warn duplicate slot usage
	    if (slotNodes && process.env.NODE_ENV !== 'production') {
	      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
	      slotNodes._rendered = true;
	    }
	    return slotNodes || fallback;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving filters
	 */
	function resolveFilter(id) {
	  return resolveAsset(this.$options, 'filters', id, true) || identity;
	}
	
	/*  */
	
	/**
	 * Runtime helper for checking keyCodes from config.
	 */
	function checkKeyCodes(eventKeyCode, key, builtInAlias) {
	  var keyCodes = config.keyCodes[key] || builtInAlias;
	  if (Array.isArray(keyCodes)) {
	    return keyCodes.indexOf(eventKeyCode) === -1;
	  } else {
	    return keyCodes !== eventKeyCode;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for merging v-bind="object" into a VNode's data.
	 */
	function bindObjectProps(data, tag, value, asProp, isSync) {
	  if (value) {
	    if (!isObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
	    } else {
	      if (Array.isArray(value)) {
	        value = toObject(value);
	      }
	      var hash;
	      var loop = function loop(key) {
	        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
	          hash = data;
	        } else {
	          var type = data.attrs && data.attrs.type;
	          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
	        }
	        if (!(key in hash)) {
	          hash[key] = value[key];
	
	          if (isSync) {
	            var on = data.on || (data.on = {});
	            on["update:" + key] = function ($event) {
	              value[key] = $event;
	            };
	          }
	        }
	      };
	
	      for (var key in value) {
	        loop(key);
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering static trees.
	 */
	function renderStatic(index, isInFor) {
	  var tree = this._staticTrees[index];
	  // if has already-rendered static tree and not inside v-for,
	  // we can reuse the same tree by doing a shallow clone.
	  if (tree && !isInFor) {
	    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
	  }
	  // otherwise, render a fresh tree.
	  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
	  markStatic(tree, "__static__" + index, false);
	  return tree;
	}
	
	/**
	 * Runtime helper for v-once.
	 * Effectively it means marking the node as static with a unique key.
	 */
	function markOnce(tree, index, key) {
	  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
	  return tree;
	}
	
	function markStatic(tree, key, isOnce) {
	  if (Array.isArray(tree)) {
	    for (var i = 0; i < tree.length; i++) {
	      if (tree[i] && typeof tree[i] !== 'string') {
	        markStaticNode(tree[i], key + "_" + i, isOnce);
	      }
	    }
	  } else {
	    markStaticNode(tree, key, isOnce);
	  }
	}
	
	function markStaticNode(node, key, isOnce) {
	  node.isStatic = true;
	  node.key = key;
	  node.isOnce = isOnce;
	}
	
	/*  */
	
	function bindObjectListeners(data, value) {
	  if (value) {
	    if (!isPlainObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
	    } else {
	      var on = data.on = data.on ? extend({}, data.on) : {};
	      for (var key in value) {
	        var existing = on[key];
	        var ours = value[key];
	        on[key] = existing ? [].concat(ours, existing) : ours;
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	function initRender(vm) {
	  vm._vnode = null; // the root of the child tree
	  vm._staticTrees = null;
	  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
	  var renderContext = parentVnode && parentVnode.context;
	  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
	  vm.$scopedSlots = emptyObject;
	  // bind the createElement fn to this instance
	  // so that we get proper render context inside it.
	  // args order: tag, data, children, normalizationType, alwaysNormalize
	  // internal version is used by render functions compiled from templates
	  vm._c = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, false);
	  };
	  // normalization is always applied for the public version, used in
	  // user-written render functions.
	  vm.$createElement = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, true);
	  };
	
	  // $attrs & $listeners are exposed for easier HOC creation.
	  // they need to be reactive so that HOCs using them are always updated
	  var parentData = parentVnode && parentVnode.data;
	  /* istanbul ignore else */
	  if (process.env.NODE_ENV !== 'production') {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
	      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
	    }, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
	      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
	    }, true);
	  } else {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);
	  }
	}
	
	function renderMixin(Vue) {
	  Vue.prototype.$nextTick = function (fn) {
	    return nextTick(fn, this);
	  };
	
	  Vue.prototype._render = function () {
	    var vm = this;
	    var ref = vm.$options;
	    var render = ref.render;
	    var staticRenderFns = ref.staticRenderFns;
	    var _parentVnode = ref._parentVnode;
	
	    if (vm._isMounted) {
	      // clone slot nodes on re-renders
	      for (var key in vm.$slots) {
	        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
	      }
	    }
	
	    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;
	
	    if (staticRenderFns && !vm._staticTrees) {
	      vm._staticTrees = [];
	    }
	    // set parent vnode. this allows render functions to have access
	    // to the data on the placeholder node.
	    vm.$vnode = _parentVnode;
	    // render self
	    var vnode;
	    try {
	      vnode = render.call(vm._renderProxy, vm.$createElement);
	    } catch (e) {
	      handleError(e, vm, "render function");
	      // return error render result,
	      // or previous vnode to prevent render error causing blank component
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
	      } else {
	        vnode = vm._vnode;
	      }
	    }
	    // return empty vnode in case the render function errored out
	    if (!(vnode instanceof VNode)) {
	      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
	        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
	      }
	      vnode = createEmptyVNode();
	    }
	    // set parent
	    vnode.parent = _parentVnode;
	    return vnode;
	  };
	
	  // internal render helpers.
	  // these are exposed on the instance prototype to reduce generated render
	  // code size.
	  Vue.prototype._o = markOnce;
	  Vue.prototype._n = toNumber;
	  Vue.prototype._s = toString;
	  Vue.prototype._l = renderList;
	  Vue.prototype._t = renderSlot;
	  Vue.prototype._q = looseEqual;
	  Vue.prototype._i = looseIndexOf;
	  Vue.prototype._m = renderStatic;
	  Vue.prototype._f = resolveFilter;
	  Vue.prototype._k = checkKeyCodes;
	  Vue.prototype._b = bindObjectProps;
	  Vue.prototype._v = createTextVNode;
	  Vue.prototype._e = createEmptyVNode;
	  Vue.prototype._u = resolveScopedSlots;
	  Vue.prototype._g = bindObjectListeners;
	}
	
	/*  */
	
	var uid$1 = 0;
	
	function initMixin(Vue) {
	  Vue.prototype._init = function (options) {
	    var vm = this;
	    // a uid
	    vm._uid = uid$1++;
	
	    var startTag, endTag;
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      startTag = "vue-perf-init:" + vm._uid;
	      endTag = "vue-perf-end:" + vm._uid;
	      mark(startTag);
	    }
	
	    // a flag to avoid this being observed
	    vm._isVue = true;
	    // merge options
	    if (options && options._isComponent) {
	      // optimize internal component instantiation
	      // since dynamic options merging is pretty slow, and none of the
	      // internal component options needs special treatment.
	      initInternalComponent(vm, options);
	    } else {
	      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
	    }
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      initProxy(vm);
	    } else {
	      vm._renderProxy = vm;
	    }
	    // expose real self
	    vm._self = vm;
	    initLifecycle(vm);
	    initEvents(vm);
	    initRender(vm);
	    callHook(vm, 'beforeCreate');
	    initInjections(vm); // resolve injections before data/props
	    initState(vm);
	    initProvide(vm); // resolve provide after data/props
	    callHook(vm, 'created');
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      vm._name = formatComponentName(vm, false);
	      mark(endTag);
	      measure(vm._name + " init", startTag, endTag);
	    }
	
	    if (vm.$options.el) {
	      vm.$mount(vm.$options.el);
	    }
	  };
	}
	
	function initInternalComponent(vm, options) {
	  var opts = vm.$options = Object.create(vm.constructor.options);
	  // doing this because it's faster than dynamic enumeration.
	  opts.parent = options.parent;
	  opts.propsData = options.propsData;
	  opts._parentVnode = options._parentVnode;
	  opts._parentListeners = options._parentListeners;
	  opts._renderChildren = options._renderChildren;
	  opts._componentTag = options._componentTag;
	  opts._parentElm = options._parentElm;
	  opts._refElm = options._refElm;
	  if (options.render) {
	    opts.render = options.render;
	    opts.staticRenderFns = options.staticRenderFns;
	  }
	}
	
	function resolveConstructorOptions(Ctor) {
	  var options = Ctor.options;
	  if (Ctor.super) {
	    var superOptions = resolveConstructorOptions(Ctor.super);
	    var cachedSuperOptions = Ctor.superOptions;
	    if (superOptions !== cachedSuperOptions) {
	      // super option changed,
	      // need to resolve new options.
	      Ctor.superOptions = superOptions;
	      // check if there are any late-modified/attached options (#4976)
	      var modifiedOptions = resolveModifiedOptions(Ctor);
	      // update base extend options
	      if (modifiedOptions) {
	        extend(Ctor.extendOptions, modifiedOptions);
	      }
	      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
	      if (options.name) {
	        options.components[options.name] = Ctor;
	      }
	    }
	  }
	  return options;
	}
	
	function resolveModifiedOptions(Ctor) {
	  var modified;
	  var latest = Ctor.options;
	  var extended = Ctor.extendOptions;
	  var sealed = Ctor.sealedOptions;
	  for (var key in latest) {
	    if (latest[key] !== sealed[key]) {
	      if (!modified) {
	        modified = {};
	      }
	      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
	    }
	  }
	  return modified;
	}
	
	function dedupe(latest, extended, sealed) {
	  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
	  // between merges
	  if (Array.isArray(latest)) {
	    var res = [];
	    sealed = Array.isArray(sealed) ? sealed : [sealed];
	    extended = Array.isArray(extended) ? extended : [extended];
	    for (var i = 0; i < latest.length; i++) {
	      // push original options and not sealed options to exclude duplicated options
	      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
	        res.push(latest[i]);
	      }
	    }
	    return res;
	  } else {
	    return latest;
	  }
	}
	
	function Vue$3(options) {
	  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
	    warn('Vue is a constructor and should be called with the `new` keyword');
	  }
	  this._init(options);
	}
	
	initMixin(Vue$3);
	stateMixin(Vue$3);
	eventsMixin(Vue$3);
	lifecycleMixin(Vue$3);
	renderMixin(Vue$3);
	
	/*  */
	
	function initUse(Vue) {
	  Vue.use = function (plugin) {
	    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
	    if (installedPlugins.indexOf(plugin) > -1) {
	      return this;
	    }
	
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else if (typeof plugin === 'function') {
	      plugin.apply(null, args);
	    }
	    installedPlugins.push(plugin);
	    return this;
	  };
	}
	
	/*  */
	
	function initMixin$1(Vue) {
	  Vue.mixin = function (mixin) {
	    this.options = mergeOptions(this.options, mixin);
	    return this;
	  };
	}
	
	/*  */
	
	function initExtend(Vue) {
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   */
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var SuperId = Super.cid;
	    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
	    if (cachedCtors[SuperId]) {
	      return cachedCtors[SuperId];
	    }
	
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
	      }
	    }
	
	    var Sub = function VueComponent(options) {
	      this._init(options);
	    };
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	
	    // For props and computed properties, we define the proxy getters on
	    // the Vue instances at extension time, on the extended prototype. This
	    // avoids Object.defineProperty calls for each instance created.
	    if (Sub.options.props) {
	      initProps$1(Sub);
	    }
	    if (Sub.options.computed) {
	      initComputed$1(Sub);
	    }
	
	    // allow further extension/mixin/plugin usage
	    Sub.extend = Super.extend;
	    Sub.mixin = Super.mixin;
	    Sub.use = Super.use;
	
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    ASSET_TYPES.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	
	    // keep a reference to the super options at extension time.
	    // later at instantiation we can check if Super's options have
	    // been updated.
	    Sub.superOptions = Super.options;
	    Sub.extendOptions = extendOptions;
	    Sub.sealedOptions = extend({}, Sub.options);
	
	    // cache constructor
	    cachedCtors[SuperId] = Sub;
	    return Sub;
	  };
	}
	
	function initProps$1(Comp) {
	  var props = Comp.options.props;
	  for (var key in props) {
	    proxy(Comp.prototype, "_props", key);
	  }
	}
	
	function initComputed$1(Comp) {
	  var computed = Comp.options.computed;
	  for (var key in computed) {
	    defineComputed(Comp.prototype, key, computed[key]);
	  }
	}
	
	/*  */
	
	function initAssetRegisters(Vue) {
	  /**
	   * Create asset registration methods.
	   */
	  ASSET_TYPES.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && config.isReservedTag(id)) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = definition.name || id;
	          definition = this.options._base.extend(definition);
	        }
	        if (type === 'directive' && typeof definition === 'function') {
	          definition = { bind: definition, update: definition };
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	}
	
	/*  */
	
	var patternTypes = [String, RegExp, Array];
	
	function getComponentName(opts) {
	  return opts && (opts.Ctor.options.name || opts.tag);
	}
	
	function matches(pattern, name) {
	  if (Array.isArray(pattern)) {
	    return pattern.indexOf(name) > -1;
	  } else if (typeof pattern === 'string') {
	    return pattern.split(',').indexOf(name) > -1;
	  } else if (isRegExp(pattern)) {
	    return pattern.test(name);
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	function pruneCache(cache, current, filter) {
	  for (var key in cache) {
	    var cachedNode = cache[key];
	    if (cachedNode) {
	      var name = getComponentName(cachedNode.componentOptions);
	      if (name && !filter(name)) {
	        if (cachedNode !== current) {
	          pruneCacheEntry(cachedNode);
	        }
	        cache[key] = null;
	      }
	    }
	  }
	}
	
	function pruneCacheEntry(vnode) {
	  if (vnode) {
	    vnode.componentInstance.$destroy();
	  }
	}
	
	var KeepAlive = {
	  name: 'keep-alive',
	  abstract: true,
	
	  props: {
	    include: patternTypes,
	    exclude: patternTypes
	  },
	
	  created: function created() {
	    this.cache = Object.create(null);
	  },
	
	  destroyed: function destroyed() {
	    var this$1 = this;
	
	    for (var key in this$1.cache) {
	      pruneCacheEntry(this$1.cache[key]);
	    }
	  },
	
	  watch: {
	    include: function include(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return matches(val, name);
	      });
	    },
	    exclude: function exclude(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return !matches(val, name);
	      });
	    }
	  },
	
	  render: function render() {
	    var vnode = getFirstComponentChild(this.$slots.default);
	    var componentOptions = vnode && vnode.componentOptions;
	    if (componentOptions) {
	      // check pattern
	      var name = getComponentName(componentOptions);
	      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
	        return vnode;
	      }
	      var key = vnode.key == null
	      // same constructor may get registered as different local components
	      // so cid alone is not enough (#3269)
	      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
	      if (this.cache[key]) {
	        vnode.componentInstance = this.cache[key].componentInstance;
	      } else {
	        this.cache[key] = vnode;
	      }
	      vnode.data.keepAlive = true;
	    }
	    return vnode;
	  }
	};
	
	var builtInComponents = {
	  KeepAlive: KeepAlive
	};
	
	/*  */
	
	function initGlobalAPI(Vue) {
	  // config
	  var configDef = {};
	  configDef.get = function () {
	    return config;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    configDef.set = function () {
	      warn('Do not replace the Vue.config object, set individual fields instead.');
	    };
	  }
	  Object.defineProperty(Vue, 'config', configDef);
	
	  // exposed util methods.
	  // NOTE: these are not considered part of the public API - avoid relying on
	  // them unless you are aware of the risk.
	  Vue.util = {
	    warn: warn,
	    extend: extend,
	    mergeOptions: mergeOptions,
	    defineReactive: defineReactive$$1
	  };
	
	  Vue.set = set;
	  Vue.delete = del;
	  Vue.nextTick = nextTick;
	
	  Vue.options = Object.create(null);
	  ASSET_TYPES.forEach(function (type) {
	    Vue.options[type + 's'] = Object.create(null);
	  });
	
	  // this is used to identify the "base" constructor to extend all plain-object
	  // components with in Weex's multi-instance scenarios.
	  Vue.options._base = Vue;
	
	  extend(Vue.options.components, builtInComponents);
	
	  initUse(Vue);
	  initMixin$1(Vue);
	  initExtend(Vue);
	  initAssetRegisters(Vue);
	}
	
	initGlobalAPI(Vue$3);
	
	Object.defineProperty(Vue$3.prototype, '$isServer', {
	  get: isServerRendering
	});
	
	Object.defineProperty(Vue$3.prototype, '$ssrContext', {
	  get: function get() {
	    /* istanbul ignore next */
	    return this.$vnode && this.$vnode.ssrContext;
	  }
	});
	
	Vue$3.version = '2.4.2';
	
	/*  */
	
	// these are reserved for web because they are directly compiled away
	// during template compilation
	var isReservedAttr = makeMap('style,class');
	
	// attributes that should be using props for binding
	var acceptValue = makeMap('input,textarea,option,select');
	var mustUseProp = function mustUseProp(tag, type, attr) {
	  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
	};
	
	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
	
	var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
	
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	
	var isXlink = function isXlink(name) {
	  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
	};
	
	var getXlinkProp = function getXlinkProp(name) {
	  return isXlink(name) ? name.slice(6, name.length) : '';
	};
	
	var isFalsyAttrValue = function isFalsyAttrValue(val) {
	  return val == null || val === false;
	};
	
	/*  */
	
	function genClassForVnode(vnode) {
	  var data = vnode.data;
	  var parentNode = vnode;
	  var childNode = vnode;
	  while (isDef(childNode.componentInstance)) {
	    childNode = childNode.componentInstance._vnode;
	    if (childNode.data) {
	      data = mergeClassData(childNode.data, data);
	    }
	  }
	  while (isDef(parentNode = parentNode.parent)) {
	    if (parentNode.data) {
	      data = mergeClassData(data, parentNode.data);
	    }
	  }
	  return renderClass(data.staticClass, data.class);
	}
	
	function mergeClassData(child, parent) {
	  return {
	    staticClass: concat(child.staticClass, parent.staticClass),
	    class: isDef(child.class) ? [child.class, parent.class] : parent.class
	  };
	}
	
	function renderClass(staticClass, dynamicClass) {
	  if (isDef(staticClass) || isDef(dynamicClass)) {
	    return concat(staticClass, stringifyClass(dynamicClass));
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function concat(a, b) {
	  return a ? b ? a + ' ' + b : a : b || '';
	}
	
	function stringifyClass(value) {
	  if (Array.isArray(value)) {
	    return stringifyArray(value);
	  }
	  if (isObject(value)) {
	    return stringifyObject(value);
	  }
	  if (typeof value === 'string') {
	    return value;
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function stringifyArray(value) {
	  var res = '';
	  var stringified;
	  for (var i = 0, l = value.length; i < l; i++) {
	    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
	      if (res) {
	        res += ' ';
	      }
	      res += stringified;
	    }
	  }
	  return res;
	}
	
	function stringifyObject(value) {
	  var res = '';
	  for (var key in value) {
	    if (value[key]) {
	      if (res) {
	        res += ' ';
	      }
	      res += key;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var namespaceMap = {
	  svg: 'http://www.w3.org/2000/svg',
	  math: 'http://www.w3.org/1998/Math/MathML'
	};
	
	var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');
	
	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
	
	var isPreTag = function isPreTag(tag) {
	  return tag === 'pre';
	};
	
	var isReservedTag = function isReservedTag(tag) {
	  return isHTMLTag(tag) || isSVG(tag);
	};
	
	function getTagNamespace(tag) {
	  if (isSVG(tag)) {
	    return 'svg';
	  }
	  // basic support for MathML
	  // note it doesn't support other MathML elements being component roots
	  if (tag === 'math') {
	    return 'math';
	  }
	}
	
	var unknownElementCache = Object.create(null);
	function isUnknownElement(tag) {
	  /* istanbul ignore if */
	  if (!inBrowser) {
	    return true;
	  }
	  if (isReservedTag(tag)) {
	    return false;
	  }
	  tag = tag.toLowerCase();
	  /* istanbul ignore if */
	  if (unknownElementCache[tag] != null) {
	    return unknownElementCache[tag];
	  }
	  var el = document.createElement(tag);
	  if (tag.indexOf('-') > -1) {
	    // http://stackoverflow.com/a/28210364/1070244
	    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	  } else {
	    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
	  }
	}
	
	/*  */
	
	/**
	 * Query an element selector if it's not an element already.
	 */
	function query(el) {
	  if (typeof el === 'string') {
	    var selected = document.querySelector(el);
	    if (!selected) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
	      return document.createElement('div');
	    }
	    return selected;
	  } else {
	    return el;
	  }
	}
	
	/*  */
	
	function createElement$1(tagName, vnode) {
	  var elm = document.createElement(tagName);
	  if (tagName !== 'select') {
	    return elm;
	  }
	  // false or null will remove the attribute but undefined will not
	  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
	    elm.setAttribute('multiple', 'multiple');
	  }
	  return elm;
	}
	
	function createElementNS(namespace, tagName) {
	  return document.createElementNS(namespaceMap[namespace], tagName);
	}
	
	function createTextNode(text) {
	  return document.createTextNode(text);
	}
	
	function createComment(text) {
	  return document.createComment(text);
	}
	
	function insertBefore(parentNode, newNode, referenceNode) {
	  parentNode.insertBefore(newNode, referenceNode);
	}
	
	function removeChild(node, child) {
	  node.removeChild(child);
	}
	
	function appendChild(node, child) {
	  node.appendChild(child);
	}
	
	function parentNode(node) {
	  return node.parentNode;
	}
	
	function nextSibling(node) {
	  return node.nextSibling;
	}
	
	function tagName(node) {
	  return node.tagName;
	}
	
	function setTextContent(node, text) {
	  node.textContent = text;
	}
	
	function setAttribute(node, key, val) {
	  node.setAttribute(key, val);
	}
	
	var nodeOps = Object.freeze({
	  createElement: createElement$1,
	  createElementNS: createElementNS,
	  createTextNode: createTextNode,
	  createComment: createComment,
	  insertBefore: insertBefore,
	  removeChild: removeChild,
	  appendChild: appendChild,
	  parentNode: parentNode,
	  nextSibling: nextSibling,
	  tagName: tagName,
	  setTextContent: setTextContent,
	  setAttribute: setAttribute
	});
	
	/*  */
	
	var ref = {
	  create: function create(_, vnode) {
	    registerRef(vnode);
	  },
	  update: function update(oldVnode, vnode) {
	    if (oldVnode.data.ref !== vnode.data.ref) {
	      registerRef(oldVnode, true);
	      registerRef(vnode);
	    }
	  },
	  destroy: function destroy(vnode) {
	    registerRef(vnode, true);
	  }
	};
	
	function registerRef(vnode, isRemoval) {
	  var key = vnode.data.ref;
	  if (!key) {
	    return;
	  }
	
	  var vm = vnode.context;
	  var ref = vnode.componentInstance || vnode.elm;
	  var refs = vm.$refs;
	  if (isRemoval) {
	    if (Array.isArray(refs[key])) {
	      remove(refs[key], ref);
	    } else if (refs[key] === ref) {
	      refs[key] = undefined;
	    }
	  } else {
	    if (vnode.data.refInFor) {
	      if (!Array.isArray(refs[key])) {
	        refs[key] = [ref];
	      } else if (refs[key].indexOf(ref) < 0) {
	        // $flow-disable-line
	        refs[key].push(ref);
	      }
	    } else {
	      refs[key] = ref;
	    }
	  }
	}
	
	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *
	
	/*
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */
	
	var emptyNode = new VNode('', {}, []);
	
	var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
	
	function sameVnode(a, b) {
	  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
	}
	
	// Some browsers do not support dynamically changing type for <input>
	// so they need to be treated as different nodes
	function sameInputType(a, b) {
	  if (a.tag !== 'input') {
	    return true;
	  }
	  var i;
	  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
	  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
	  return typeA === typeB;
	}
	
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, key;
	  var map = {};
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) {
	      map[key] = i;
	    }
	  }
	  return map;
	}
	
	function createPatchFunction(backend) {
	  var i, j;
	  var cbs = {};
	
	  var modules = backend.modules;
	  var nodeOps = backend.nodeOps;
	
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (isDef(modules[j][hooks[i]])) {
	        cbs[hooks[i]].push(modules[j][hooks[i]]);
	      }
	    }
	  }
	
	  function emptyNodeAt(elm) {
	    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
	  }
	
	  function createRmCb(childElm, listeners) {
	    function remove$$1() {
	      if (--remove$$1.listeners === 0) {
	        removeNode(childElm);
	      }
	    }
	    remove$$1.listeners = listeners;
	    return remove$$1;
	  }
	
	  function removeNode(el) {
	    var parent = nodeOps.parentNode(el);
	    // element may have already been removed due to v-html / v-text
	    if (isDef(parent)) {
	      nodeOps.removeChild(parent, el);
	    }
	  }
	
	  var inPre = 0;
	  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
	    vnode.isRootInsert = !nested; // for transition enter check
	    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	      return;
	    }
	
	    var data = vnode.data;
	    var children = vnode.children;
	    var tag = vnode.tag;
	    if (isDef(tag)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (data && data.pre) {
	          inPre++;
	        }
	        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
	        }
	      }
	      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
	      setScope(vnode);
	
	      /* istanbul ignore if */
	      {
	        createChildren(vnode, children, insertedVnodeQueue);
	        if (isDef(data)) {
	          invokeCreateHooks(vnode, insertedVnodeQueue);
	        }
	        insert(parentElm, vnode.elm, refElm);
	      }
	
	      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
	        inPre--;
	      }
	    } else if (isTrue(vnode.isComment)) {
	      vnode.elm = nodeOps.createComment(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    } else {
	      vnode.elm = nodeOps.createTextNode(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    }
	  }
	
	  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i = vnode.data;
	    if (isDef(i)) {
	      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
	      if (isDef(i = i.hook) && isDef(i = i.init)) {
	        i(vnode, false /* hydrating */, parentElm, refElm);
	      }
	      // after calling the init hook, if the vnode is a child component
	      // it should've created a child instance and mounted it. the child
	      // component also has set the placeholder vnode's elm.
	      // in that case we can just return the element and be done.
	      if (isDef(vnode.componentInstance)) {
	        initComponent(vnode, insertedVnodeQueue);
	        if (isTrue(isReactivated)) {
	          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
	        }
	        return true;
	      }
	    }
	  }
	
	  function initComponent(vnode, insertedVnodeQueue) {
	    if (isDef(vnode.data.pendingInsert)) {
	      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	      vnode.data.pendingInsert = null;
	    }
	    vnode.elm = vnode.componentInstance.$el;
	    if (isPatchable(vnode)) {
	      invokeCreateHooks(vnode, insertedVnodeQueue);
	      setScope(vnode);
	    } else {
	      // empty component root.
	      // skip all element-related modules except for ref (#3455)
	      registerRef(vnode);
	      // make sure to invoke the insert hook
	      insertedVnodeQueue.push(vnode);
	    }
	  }
	
	  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i;
	    // hack for #4339: a reactivated component with inner transition
	    // does not trigger because the inner node's created hooks are not called
	    // again. It's not ideal to involve module-specific logic in here but
	    // there doesn't seem to be a better way to do it.
	    var innerNode = vnode;
	    while (innerNode.componentInstance) {
	      innerNode = innerNode.componentInstance._vnode;
	      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
	        for (i = 0; i < cbs.activate.length; ++i) {
	          cbs.activate[i](emptyNode, innerNode);
	        }
	        insertedVnodeQueue.push(innerNode);
	        break;
	      }
	    }
	    // unlike a newly created component,
	    // a reactivated keep-alive component doesn't insert itself
	    insert(parentElm, vnode.elm, refElm);
	  }
	
	  function insert(parent, elm, ref$$1) {
	    if (isDef(parent)) {
	      if (isDef(ref$$1)) {
	        if (ref$$1.parentNode === parent) {
	          nodeOps.insertBefore(parent, elm, ref$$1);
	        }
	      } else {
	        nodeOps.appendChild(parent, elm);
	      }
	    }
	  }
	
	  function createChildren(vnode, children, insertedVnodeQueue) {
	    if (Array.isArray(children)) {
	      for (var i = 0; i < children.length; ++i) {
	        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
	      }
	    } else if (isPrimitive(vnode.text)) {
	      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
	    }
	  }
	
	  function isPatchable(vnode) {
	    while (vnode.componentInstance) {
	      vnode = vnode.componentInstance._vnode;
	    }
	    return isDef(vnode.tag);
	  }
	
	  function invokeCreateHooks(vnode, insertedVnodeQueue) {
	    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
	      cbs.create[i$1](emptyNode, vnode);
	    }
	    i = vnode.data.hook; // Reuse variable
	    if (isDef(i)) {
	      if (isDef(i.create)) {
	        i.create(emptyNode, vnode);
	      }
	      if (isDef(i.insert)) {
	        insertedVnodeQueue.push(vnode);
	      }
	    }
	  }
	
	  // set scope id attribute for scoped CSS.
	  // this is implemented as a special case to avoid the overhead
	  // of going through the normal attribute patching process.
	  function setScope(vnode) {
	    var i;
	    var ancestor = vnode;
	    while (ancestor) {
	      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
	        nodeOps.setAttribute(vnode.elm, i, '');
	      }
	      ancestor = ancestor.parent;
	    }
	    // for slot content they should also get the scopeId from the host instance.
	    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	  }
	
	  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
	    }
	  }
	
	  function invokeDestroyHook(vnode) {
	    var i, j;
	    var data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
	        i(vnode);
	      }
	      for (i = 0; i < cbs.destroy.length; ++i) {
	        cbs.destroy[i](vnode);
	      }
	    }
	    if (isDef(i = vnode.children)) {
	      for (j = 0; j < vnode.children.length; ++j) {
	        invokeDestroyHook(vnode.children[j]);
	      }
	    }
	  }
	
	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.tag)) {
	          removeAndInvokeRemoveHook(ch);
	          invokeDestroyHook(ch);
	        } else {
	          // Text node
	          removeNode(ch.elm);
	        }
	      }
	    }
	  }
	
	  function removeAndInvokeRemoveHook(vnode, rm) {
	    if (isDef(rm) || isDef(vnode.data)) {
	      var i;
	      var listeners = cbs.remove.length + 1;
	      if (isDef(rm)) {
	        // we have a recursively passed down rm callback
	        // increase the listeners count
	        rm.listeners += listeners;
	      } else {
	        // directly removing
	        rm = createRmCb(vnode.elm, listeners);
	      }
	      // recursively invoke hooks on child component root node
	      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
	        removeAndInvokeRemoveHook(i, rm);
	      }
	      for (i = 0; i < cbs.remove.length; ++i) {
	        cbs.remove[i](vnode, rm);
	      }
	      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
	        i(vnode, rm);
	      } else {
	        rm();
	      }
	    } else {
	      removeNode(vnode.elm);
	    }
	  }
	
	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	    var oldStartIdx = 0;
	    var newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, refElm;
	
	    // removeOnly is a special flag used only by <transition-group>
	    // to ensure removed elements stay in correct relative positions
	    // during leaving transitions
	    var canMove = !removeOnly;
	
	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) {
	        // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) {
	        // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) {
	          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        }
	        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
	        if (isUndef(idxInOld)) {
	          // New element
	          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
	            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
	          }
	          if (sameVnode(elmToMove, newStartVnode)) {
	            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	            oldCh[idxInOld] = undefined;
	            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          } else {
	            // same key but different element. treat as new element
	            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          }
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }
	
	  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
	    if (oldVnode === vnode) {
	      return;
	    }
	
	    var elm = vnode.elm = oldVnode.elm;
	
	    if (isTrue(oldVnode.isAsyncPlaceholder)) {
	      if (isDef(vnode.asyncFactory.resolved)) {
	        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
	      } else {
	        vnode.isAsyncPlaceholder = true;
	      }
	      return;
	    }
	
	    // reuse element for static trees.
	    // note we only do this if the vnode is cloned -
	    // if the new node is not cloned it means the render functions have been
	    // reset by the hot-reload-api and we need to do a proper re-render.
	    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
	      vnode.componentInstance = oldVnode.componentInstance;
	      return;
	    }
	
	    var i;
	    var data = vnode.data;
	    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
	      i(oldVnode, vnode);
	    }
	
	    var oldCh = oldVnode.children;
	    var ch = vnode.children;
	    if (isDef(data) && isPatchable(vnode)) {
	      for (i = 0; i < cbs.update.length; ++i) {
	        cbs.update[i](oldVnode, vnode);
	      }
	      if (isDef(i = data.hook) && isDef(i = i.update)) {
	        i(oldVnode, vnode);
	      }
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) {
	          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
	        }
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) {
	          nodeOps.setTextContent(elm, '');
	        }
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        nodeOps.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      nodeOps.setTextContent(elm, vnode.text);
	    }
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
	        i(oldVnode, vnode);
	      }
	    }
	  }
	
	  function invokeInsertHook(vnode, queue, initial) {
	    // delay insert hooks for component root nodes, invoke them after the
	    // element is really inserted
	    if (isTrue(initial) && isDef(vnode.parent)) {
	      vnode.parent.data.pendingInsert = queue;
	    } else {
	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].data.hook.insert(queue[i]);
	      }
	    }
	  }
	
	  var bailed = false;
	  // list of modules that can skip create hook during hydration because they
	  // are already rendered on the client or has no need for initialization
	  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
	
	  // Note: this is a browser-only function so we can assume elms are DOM nodes.
	  function hydrate(elm, vnode, insertedVnodeQueue) {
	    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
	      vnode.elm = elm;
	      vnode.isAsyncPlaceholder = true;
	      return true;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (!assertNodeMatch(elm, vnode)) {
	        return false;
	      }
	    }
	    vnode.elm = elm;
	    var tag = vnode.tag;
	    var data = vnode.data;
	    var children = vnode.children;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) {
	        i(vnode, true /* hydrating */);
	      }
	      if (isDef(i = vnode.componentInstance)) {
	        // child component. it should have hydrated its own tree.
	        initComponent(vnode, insertedVnodeQueue);
	        return true;
	      }
	    }
	    if (isDef(tag)) {
	      if (isDef(children)) {
	        // empty element, allow client to pick up and populate children
	        if (!elm.hasChildNodes()) {
	          createChildren(vnode, children, insertedVnodeQueue);
	        } else {
	          var childrenMatch = true;
	          var childNode = elm.firstChild;
	          for (var i$1 = 0; i$1 < children.length; i$1++) {
	            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
	              childrenMatch = false;
	              break;
	            }
	            childNode = childNode.nextSibling;
	          }
	          // if childNode is not null, it means the actual childNodes list is
	          // longer than the virtual children list.
	          if (!childrenMatch || childNode) {
	            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
	              bailed = true;
	              console.warn('Parent: ', elm);
	              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
	            }
	            return false;
	          }
	        }
	      }
	      if (isDef(data)) {
	        for (var key in data) {
	          if (!isRenderedModule(key)) {
	            invokeCreateHooks(vnode, insertedVnodeQueue);
	            break;
	          }
	        }
	      }
	    } else if (elm.data !== vnode.text) {
	      elm.data = vnode.text;
	    }
	    return true;
	  }
	
	  function assertNodeMatch(node, vnode) {
	    if (isDef(vnode.tag)) {
	      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
	    } else {
	      return node.nodeType === (vnode.isComment ? 8 : 3);
	    }
	  }
	
	  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
	    if (isUndef(vnode)) {
	      if (isDef(oldVnode)) {
	        invokeDestroyHook(oldVnode);
	      }
	      return;
	    }
	
	    var isInitialPatch = false;
	    var insertedVnodeQueue = [];
	
	    if (isUndef(oldVnode)) {
	      // empty mount (likely as component), create new root element
	      isInitialPatch = true;
	      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
	    } else {
	      var isRealElement = isDef(oldVnode.nodeType);
	      if (!isRealElement && sameVnode(oldVnode, vnode)) {
	        // patch existing root node
	        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
	      } else {
	        if (isRealElement) {
	          // mounting to a real element
	          // check if this is server-rendered content and if we can perform
	          // a successful hydration.
	          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
	            oldVnode.removeAttribute(SSR_ATTR);
	            hydrating = true;
	          }
	          if (isTrue(hydrating)) {
	            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	              invokeInsertHook(vnode, insertedVnodeQueue, true);
	              return oldVnode;
	            } else if (process.env.NODE_ENV !== 'production') {
	              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
	            }
	          }
	          // either not server-rendered, or hydration failed.
	          // create an empty node and replace it
	          oldVnode = emptyNodeAt(oldVnode);
	        }
	        // replacing existing element
	        var oldElm = oldVnode.elm;
	        var parentElm$1 = nodeOps.parentNode(oldElm);
	        createElm(vnode, insertedVnodeQueue,
	        // extremely rare edge case: do not insert if old element is in a
	        // leaving transition. Only happens when combining transition +
	        // keep-alive + HOCs. (#4590)
	        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));
	
	        if (isDef(vnode.parent)) {
	          // component root element replaced.
	          // update parent placeholder node element, recursively
	          var ancestor = vnode.parent;
	          while (ancestor) {
	            ancestor.elm = vnode.elm;
	            ancestor = ancestor.parent;
	          }
	          if (isPatchable(vnode)) {
	            for (var i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode.parent);
	            }
	          }
	        }
	
	        if (isDef(parentElm$1)) {
	          removeVnodes(parentElm$1, [oldVnode], 0, 0);
	        } else if (isDef(oldVnode.tag)) {
	          invokeDestroyHook(oldVnode);
	        }
	      }
	    }
	
	    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	    return vnode.elm;
	  };
	}
	
	/*  */
	
	var directives = {
	  create: updateDirectives,
	  update: updateDirectives,
	  destroy: function unbindDirectives(vnode) {
	    updateDirectives(vnode, emptyNode);
	  }
	};
	
	function updateDirectives(oldVnode, vnode) {
	  if (oldVnode.data.directives || vnode.data.directives) {
	    _update(oldVnode, vnode);
	  }
	}
	
	function _update(oldVnode, vnode) {
	  var isCreate = oldVnode === emptyNode;
	  var isDestroy = vnode === emptyNode;
	  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
	  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
	
	  var dirsWithInsert = [];
	  var dirsWithPostpatch = [];
	
	  var key, oldDir, dir;
	  for (key in newDirs) {
	    oldDir = oldDirs[key];
	    dir = newDirs[key];
	    if (!oldDir) {
	      // new directive, bind
	      callHook$1(dir, 'bind', vnode, oldVnode);
	      if (dir.def && dir.def.inserted) {
	        dirsWithInsert.push(dir);
	      }
	    } else {
	      // existing directive, update
	      dir.oldValue = oldDir.value;
	      callHook$1(dir, 'update', vnode, oldVnode);
	      if (dir.def && dir.def.componentUpdated) {
	        dirsWithPostpatch.push(dir);
	      }
	    }
	  }
	
	  if (dirsWithInsert.length) {
	    var callInsert = function callInsert() {
	      for (var i = 0; i < dirsWithInsert.length; i++) {
	        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
	      }
	    };
	    if (isCreate) {
	      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
	    } else {
	      callInsert();
	    }
	  }
	
	  if (dirsWithPostpatch.length) {
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
	      for (var i = 0; i < dirsWithPostpatch.length; i++) {
	        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
	      }
	    });
	  }
	
	  if (!isCreate) {
	    for (key in oldDirs) {
	      if (!newDirs[key]) {
	        // no longer present, unbind
	        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
	      }
	    }
	  }
	}
	
	var emptyModifiers = Object.create(null);
	
	function normalizeDirectives$1(dirs, vm) {
	  var res = Object.create(null);
	  if (!dirs) {
	    return res;
	  }
	  var i, dir;
	  for (i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (!dir.modifiers) {
	      dir.modifiers = emptyModifiers;
	    }
	    res[getRawDirName(dir)] = dir;
	    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
	  }
	  return res;
	}
	
	function getRawDirName(dir) {
	  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
	}
	
	function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
	  var fn = dir.def && dir.def[hook];
	  if (fn) {
	    try {
	      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
	    } catch (e) {
	      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
	    }
	  }
	}
	
	var baseModules = [ref, directives];
	
	/*  */
	
	function updateAttrs(oldVnode, vnode) {
	  var opts = vnode.componentOptions;
	  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
	    return;
	  }
	  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
	    return;
	  }
	  var key, cur, old;
	  var elm = vnode.elm;
	  var oldAttrs = oldVnode.data.attrs || {};
	  var attrs = vnode.data.attrs || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(attrs.__ob__)) {
	    attrs = vnode.data.attrs = extend({}, attrs);
	  }
	
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      setAttr(elm, key, cur);
	    }
	  }
	  // #4391: in IE9, setting type can reset value for input[type=radio]
	  /* istanbul ignore if */
	  if (isIE9 && attrs.value !== oldAttrs.value) {
	    setAttr(elm, 'value', attrs.value);
	  }
	  for (key in oldAttrs) {
	    if (isUndef(attrs[key])) {
	      if (isXlink(key)) {
	        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	      } else if (!isEnumeratedAttr(key)) {
	        elm.removeAttribute(key);
	      }
	    }
	  }
	}
	
	function setAttr(el, key, value) {
	  if (isBooleanAttr(key)) {
	    // set attribute for blank value
	    // e.g. <option disabled>Select one</option>
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, key);
	    }
	  } else if (isEnumeratedAttr(key)) {
	    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
	  } else if (isXlink(key)) {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, value);
	    }
	  }
	}
	
	var attrs = {
	  create: updateAttrs,
	  update: updateAttrs
	};
	
	/*  */
	
	function updateClass(oldVnode, vnode) {
	  var el = vnode.elm;
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
	    return;
	  }
	
	  var cls = genClassForVnode(vnode);
	
	  // handle transition classes
	  var transitionClass = el._transitionClasses;
	  if (isDef(transitionClass)) {
	    cls = concat(cls, stringifyClass(transitionClass));
	  }
	
	  // set the class
	  if (cls !== el._prevClass) {
	    el.setAttribute('class', cls);
	    el._prevClass = cls;
	  }
	}
	
	var klass = {
	  create: updateClass,
	  update: updateClass
	};
	
	/*  */
	
	var validDivisionCharRE = /[\w).+\-_$\]]/;
	
	function parseFilters(exp) {
	  var inSingle = false;
	  var inDouble = false;
	  var inTemplateString = false;
	  var inRegex = false;
	  var curly = 0;
	  var square = 0;
	  var paren = 0;
	  var lastFilterIndex = 0;
	  var c, prev, i, expression, filters;
	
	  for (i = 0; i < exp.length; i++) {
	    prev = c;
	    c = exp.charCodeAt(i);
	    if (inSingle) {
	      if (c === 0x27 && prev !== 0x5C) {
	        inSingle = false;
	      }
	    } else if (inDouble) {
	      if (c === 0x22 && prev !== 0x5C) {
	        inDouble = false;
	      }
	    } else if (inTemplateString) {
	      if (c === 0x60 && prev !== 0x5C) {
	        inTemplateString = false;
	      }
	    } else if (inRegex) {
	      if (c === 0x2f && prev !== 0x5C) {
	        inRegex = false;
	      }
	    } else if (c === 0x7C && // pipe
	    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
	      if (expression === undefined) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        expression = exp.slice(0, i).trim();
	      } else {
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x60:
	          inTemplateString = true;break; // `
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	      if (c === 0x2f) {
	        // /
	        var j = i - 1;
	        var p = void 0;
	        // find first non-whitespace prev char
	        for (; j >= 0; j--) {
	          p = exp.charAt(j);
	          if (p !== ' ') {
	            break;
	          }
	        }
	        if (!p || !validDivisionCharRE.test(p)) {
	          inRegex = true;
	        }
	      }
	    }
	  }
	
	  if (expression === undefined) {
	    expression = exp.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  function pushFilter() {
	    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
	    lastFilterIndex = i + 1;
	  }
	
	  if (filters) {
	    for (i = 0; i < filters.length; i++) {
	      expression = wrapFilter(expression, filters[i]);
	    }
	  }
	
	  return expression;
	}
	
	function wrapFilter(exp, filter) {
	  var i = filter.indexOf('(');
	  if (i < 0) {
	    // _f: resolveFilter
	    return "_f(\"" + filter + "\")(" + exp + ")";
	  } else {
	    var name = filter.slice(0, i);
	    var args = filter.slice(i + 1);
	    return "_f(\"" + name + "\")(" + exp + "," + args;
	  }
	}
	
	/*  */
	
	function baseWarn(msg) {
	  console.error("[Vue compiler]: " + msg);
	}
	
	function pluckModuleFunction(modules, key) {
	  return modules ? modules.map(function (m) {
	    return m[key];
	  }).filter(function (_) {
	    return _;
	  }) : [];
	}
	
	function addProp(el, name, value) {
	  (el.props || (el.props = [])).push({ name: name, value: value });
	}
	
	function addAttr(el, name, value) {
	  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
	}
	
	function addDirective(el, name, rawName, value, arg, modifiers) {
	  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
	}
	
	function addHandler(el, name, value, modifiers, important, warn) {
	  // warn prevent and passive modifier
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {
	    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
	  }
	  // check capture modifier
	  if (modifiers && modifiers.capture) {
	    delete modifiers.capture;
	    name = '!' + name; // mark the event as captured
	  }
	  if (modifiers && modifiers.once) {
	    delete modifiers.once;
	    name = '~' + name; // mark the event as once
	  }
	  /* istanbul ignore if */
	  if (modifiers && modifiers.passive) {
	    delete modifiers.passive;
	    name = '&' + name; // mark the event as passive
	  }
	  var events;
	  if (modifiers && modifiers.native) {
	    delete modifiers.native;
	    events = el.nativeEvents || (el.nativeEvents = {});
	  } else {
	    events = el.events || (el.events = {});
	  }
	  var newHandler = { value: value, modifiers: modifiers };
	  var handlers = events[name];
	  /* istanbul ignore if */
	  if (Array.isArray(handlers)) {
	    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
	  } else if (handlers) {
	    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
	  } else {
	    events[name] = newHandler;
	  }
	}
	
	function getBindingAttr(el, name, getStatic) {
	  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
	  if (dynamicValue != null) {
	    return parseFilters(dynamicValue);
	  } else if (getStatic !== false) {
	    var staticValue = getAndRemoveAttr(el, name);
	    if (staticValue != null) {
	      return JSON.stringify(staticValue);
	    }
	  }
	}
	
	function getAndRemoveAttr(el, name) {
	  var val;
	  if ((val = el.attrsMap[name]) != null) {
	    var list = el.attrsList;
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (list[i].name === name) {
	        list.splice(i, 1);
	        break;
	      }
	    }
	  }
	  return val;
	}
	
	/*  */
	
	/**
	 * Cross-platform code generation for component v-model
	 */
	function genComponentModel(el, value, modifiers) {
	  var ref = modifiers || {};
	  var number = ref.number;
	  var trim = ref.trim;
	
	  var baseValueExpression = '$$v';
	  var valueExpression = baseValueExpression;
	  if (trim) {
	    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	  var assignment = genAssignmentCode(value, valueExpression);
	
	  el.model = {
	    value: "(" + value + ")",
	    expression: "\"" + value + "\"",
	    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
	  };
	}
	
	/**
	 * Cross-platform codegen helper for generating v-model value assignment code.
	 */
	function genAssignmentCode(value, assignment) {
	  var modelRs = parseModel(value);
	  if (modelRs.idx === null) {
	    return value + "=" + assignment;
	  } else {
	    return "$set(" + modelRs.exp + ", " + modelRs.idx + ", " + assignment + ")";
	  }
	}
	
	/**
	 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
	 *
	 * for loop possible cases:
	 *
	 * - test
	 * - test[idx]
	 * - test[test1[idx]]
	 * - test["a"][idx]
	 * - xxx.test[a[a].test1[idx]]
	 * - test.xxx.a["asa"][test1[idx]]
	 *
	 */
	
	var len;
	var str;
	var chr;
	var index$1;
	var expressionPos;
	var expressionEndPos;
	
	function parseModel(val) {
	  str = val;
	  len = str.length;
	  index$1 = expressionPos = expressionEndPos = 0;
	
	  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
	    return {
	      exp: val,
	      idx: null
	    };
	  }
	
	  while (!eof()) {
	    chr = next();
	    /* istanbul ignore if */
	    if (isStringStart(chr)) {
	      parseString(chr);
	    } else if (chr === 0x5B) {
	      parseBracket(chr);
	    }
	  }
	
	  return {
	    exp: val.substring(0, expressionPos),
	    idx: val.substring(expressionPos + 1, expressionEndPos)
	  };
	}
	
	function next() {
	  return str.charCodeAt(++index$1);
	}
	
	function eof() {
	  return index$1 >= len;
	}
	
	function isStringStart(chr) {
	  return chr === 0x22 || chr === 0x27;
	}
	
	function parseBracket(chr) {
	  var inBracket = 1;
	  expressionPos = index$1;
	  while (!eof()) {
	    chr = next();
	    if (isStringStart(chr)) {
	      parseString(chr);
	      continue;
	    }
	    if (chr === 0x5B) {
	      inBracket++;
	    }
	    if (chr === 0x5D) {
	      inBracket--;
	    }
	    if (inBracket === 0) {
	      expressionEndPos = index$1;
	      break;
	    }
	  }
	}
	
	function parseString(chr) {
	  var stringQuote = chr;
	  while (!eof()) {
	    chr = next();
	    if (chr === stringQuote) {
	      break;
	    }
	  }
	}
	
	/*  */
	
	var warn$1;
	
	// in some cases, the event used has to be determined at runtime
	// so we used some reserved tokens during compile.
	var RANGE_TOKEN = '__r';
	var CHECKBOX_RADIO_TOKEN = '__c';
	
	function model(el, dir, _warn) {
	  warn$1 = _warn;
	  var value = dir.value;
	  var modifiers = dir.modifiers;
	  var tag = el.tag;
	  var type = el.attrsMap.type;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
	    if (tag === 'input' && dynamicType) {
	      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
	    }
	    // inputs with type="file" are read only and setting the input's
	    // value will throw an error.
	    if (tag === 'input' && type === 'file') {
	      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
	    }
	  }
	
	  if (el.component) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (tag === 'select') {
	    genSelect(el, value, modifiers);
	  } else if (tag === 'input' && type === 'checkbox') {
	    genCheckboxModel(el, value, modifiers);
	  } else if (tag === 'input' && type === 'radio') {
	    genRadioModel(el, value, modifiers);
	  } else if (tag === 'input' || tag === 'textarea') {
	    genDefaultModel(el, value, modifiers);
	  } else if (!config.isReservedTag(tag)) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
	  }
	
	  // ensure runtime directive metadata
	  return true;
	}
	
	function genCheckboxModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
	  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
	  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
	  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
	}
	
	function genRadioModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
	  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
	  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
	}
	
	function genSelect(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
	
	  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
	  var code = "var $$selectedVal = " + selectedVal + ";";
	  code = code + " " + genAssignmentCode(value, assignment);
	  addHandler(el, 'change', code, null, true);
	}
	
	function genDefaultModel(el, value, modifiers) {
	  var type = el.attrsMap.type;
	  var ref = modifiers || {};
	  var lazy = ref.lazy;
	  var number = ref.number;
	  var trim = ref.trim;
	  var needCompositionGuard = !lazy && type !== 'range';
	  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
	
	  var valueExpression = '$event.target.value';
	  if (trim) {
	    valueExpression = "$event.target.value.trim()";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	
	  var code = genAssignmentCode(value, valueExpression);
	  if (needCompositionGuard) {
	    code = "if($event.target.composing)return;" + code;
	  }
	
	  addProp(el, 'value', "(" + value + ")");
	  addHandler(el, event, code, null, true);
	  if (trim || number) {
	    addHandler(el, 'blur', '$forceUpdate()');
	  }
	}
	
	/*  */
	
	// normalize v-model event tokens that can only be determined at runtime.
	// it's important to place the event as the first in the array because
	// the whole point is ensuring the v-model callback gets called before
	// user-attached handlers.
	function normalizeEvents(on) {
	  var event;
	  /* istanbul ignore if */
	  if (isDef(on[RANGE_TOKEN])) {
	    // IE input[type=range] only supports `change` event
	    event = isIE ? 'change' : 'input';
	    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
	    delete on[RANGE_TOKEN];
	  }
	  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
	    // Chrome fires microtasks in between click/change, leads to #4521
	    event = isChrome ? 'click' : 'change';
	    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
	    delete on[CHECKBOX_RADIO_TOKEN];
	  }
	}
	
	var target$1;
	
	function add$1(event, _handler, once$$1, capture, passive) {
	  if (once$$1) {
	    var oldHandler = _handler;
	    var _target = target$1; // save current target element in closure
	    _handler = function handler(ev) {
	      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
	      if (res !== null) {
	        remove$2(event, _handler, capture, _target);
	      }
	    };
	  }
	  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);
	}
	
	function remove$2(event, handler, capture, _target) {
	  (_target || target$1).removeEventListener(event, handler, capture);
	}
	
	function updateDOMListeners(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
	    return;
	  }
	  var on = vnode.data.on || {};
	  var oldOn = oldVnode.data.on || {};
	  target$1 = vnode.elm;
	  normalizeEvents(on);
	  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
	}
	
	var events = {
	  create: updateDOMListeners,
	  update: updateDOMListeners
	};
	
	/*  */
	
	function updateDOMProps(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
	    return;
	  }
	  var key, cur;
	  var elm = vnode.elm;
	  var oldProps = oldVnode.data.domProps || {};
	  var props = vnode.data.domProps || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(props.__ob__)) {
	    props = vnode.data.domProps = extend({}, props);
	  }
	
	  for (key in oldProps) {
	    if (isUndef(props[key])) {
	      elm[key] = '';
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    // ignore children if the node has textContent or innerHTML,
	    // as these will throw away existing DOM nodes and cause removal errors
	    // on subsequent patches (#3360)
	    if (key === 'textContent' || key === 'innerHTML') {
	      if (vnode.children) {
	        vnode.children.length = 0;
	      }
	      if (cur === oldProps[key]) {
	        continue;
	      }
	    }
	
	    if (key === 'value') {
	      // store value as _value as well since
	      // non-string values will be stringified
	      elm._value = cur;
	      // avoid resetting cursor position when value is the same
	      var strCur = isUndef(cur) ? '' : String(cur);
	      if (shouldUpdateValue(elm, vnode, strCur)) {
	        elm.value = strCur;
	      }
	    } else {
	      elm[key] = cur;
	    }
	  }
	}
	
	// check platforms/web/util/attrs.js acceptValue
	
	
	function shouldUpdateValue(elm, vnode, checkVal) {
	  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
	}
	
	function isDirty(elm, checkVal) {
	  // return true when textbox (.number and .trim) loses focus and its value is
	  // not equal to the updated value
	  var notInFocus = true;
	  // #6157
	  // work around IE bug when accessing document.activeElement in an iframe
	  try {
	    notInFocus = document.activeElement !== elm;
	  } catch (e) {}
	  return notInFocus && elm.value !== checkVal;
	}
	
	function isInputChanged(elm, newVal) {
	  var value = elm.value;
	  var modifiers = elm._vModifiers; // injected by v-model runtime
	  if (isDef(modifiers) && modifiers.number) {
	    return toNumber(value) !== toNumber(newVal);
	  }
	  if (isDef(modifiers) && modifiers.trim) {
	    return value.trim() !== newVal.trim();
	  }
	  return value !== newVal;
	}
	
	var domProps = {
	  create: updateDOMProps,
	  update: updateDOMProps
	};
	
	/*  */
	
	var parseStyleText = cached(function (cssText) {
	  var res = {};
	  var listDelimiter = /;(?![^(]*\))/g;
	  var propertyDelimiter = /:(.+)/;
	  cssText.split(listDelimiter).forEach(function (item) {
	    if (item) {
	      var tmp = item.split(propertyDelimiter);
	      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
	    }
	  });
	  return res;
	});
	
	// merge static and dynamic style data on the same vnode
	function normalizeStyleData(data) {
	  var style = normalizeStyleBinding(data.style);
	  // static style is pre-processed into an object during compilation
	  // and is always a fresh object, so it's safe to merge into it
	  return data.staticStyle ? extend(data.staticStyle, style) : style;
	}
	
	// normalize possible array / string values into Object
	function normalizeStyleBinding(bindingStyle) {
	  if (Array.isArray(bindingStyle)) {
	    return toObject(bindingStyle);
	  }
	  if (typeof bindingStyle === 'string') {
	    return parseStyleText(bindingStyle);
	  }
	  return bindingStyle;
	}
	
	/**
	 * parent component style should be after child's
	 * so that parent component's style could override it
	 */
	function getStyle(vnode, checkChild) {
	  var res = {};
	  var styleData;
	
	  if (checkChild) {
	    var childNode = vnode;
	    while (childNode.componentInstance) {
	      childNode = childNode.componentInstance._vnode;
	      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
	        extend(res, styleData);
	      }
	    }
	  }
	
	  if (styleData = normalizeStyleData(vnode.data)) {
	    extend(res, styleData);
	  }
	
	  var parentNode = vnode;
	  while (parentNode = parentNode.parent) {
	    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
	      extend(res, styleData);
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var cssVarRE = /^--/;
	var importantRE = /\s*!important$/;
	var setProp = function setProp(el, name, val) {
	  /* istanbul ignore if */
	  if (cssVarRE.test(name)) {
	    el.style.setProperty(name, val);
	  } else if (importantRE.test(val)) {
	    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
	  } else {
	    var normalizedName = normalize(name);
	    if (Array.isArray(val)) {
	      // Support values array created by autoprefixer, e.g.
	      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
	      // Set them one by one, and the browser will only set those it can recognize
	      for (var i = 0, len = val.length; i < len; i++) {
	        el.style[normalizedName] = val[i];
	      }
	    } else {
	      el.style[normalizedName] = val;
	    }
	  }
	};
	
	var vendorNames = ['Webkit', 'Moz', 'ms'];
	
	var emptyStyle;
	var normalize = cached(function (prop) {
	  emptyStyle = emptyStyle || document.createElement('div').style;
	  prop = camelize(prop);
	  if (prop !== 'filter' && prop in emptyStyle) {
	    return prop;
	  }
	  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
	  for (var i = 0; i < vendorNames.length; i++) {
	    var name = vendorNames[i] + capName;
	    if (name in emptyStyle) {
	      return name;
	    }
	  }
	});
	
	function updateStyle(oldVnode, vnode) {
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	
	  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
	    return;
	  }
	
	  var cur, name;
	  var el = vnode.elm;
	  var oldStaticStyle = oldData.staticStyle;
	  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
	
	  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
	  var oldStyle = oldStaticStyle || oldStyleBinding;
	
	  var style = normalizeStyleBinding(vnode.data.style) || {};
	
	  // store normalized style under a different key for next diff
	  // make sure to clone it if it's reactive, since the user likley wants
	  // to mutate it.
	  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
	
	  var newStyle = getStyle(vnode, true);
	
	  for (name in oldStyle) {
	    if (isUndef(newStyle[name])) {
	      setProp(el, name, '');
	    }
	  }
	  for (name in newStyle) {
	    cur = newStyle[name];
	    if (cur !== oldStyle[name]) {
	      // ie9 setting to null has no effect, must use empty string
	      setProp(el, name, cur == null ? '' : cur);
	    }
	  }
	}
	
	var style = {
	  create: updateStyle,
	  update: updateStyle
	};
	
	/*  */
	
	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.add(c);
	      });
	    } else {
	      el.classList.add(cls);
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.remove(c);
	      });
	    } else {
	      el.classList.remove(cls);
	    }
	    if (!el.classList.length) {
	      el.removeAttribute('class');
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    cur = cur.trim();
	    if (cur) {
	      el.setAttribute('class', cur);
	    } else {
	      el.removeAttribute('class');
	    }
	  }
	}
	
	/*  */
	
	function resolveTransition(def$$1) {
	  if (!def$$1) {
	    return;
	  }
	  /* istanbul ignore else */
	  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
	    var res = {};
	    if (def$$1.css !== false) {
	      extend(res, autoCssTransition(def$$1.name || 'v'));
	    }
	    extend(res, def$$1);
	    return res;
	  } else if (typeof def$$1 === 'string') {
	    return autoCssTransition(def$$1);
	  }
	}
	
	var autoCssTransition = cached(function (name) {
	  return {
	    enterClass: name + "-enter",
	    enterToClass: name + "-enter-to",
	    enterActiveClass: name + "-enter-active",
	    leaveClass: name + "-leave",
	    leaveToClass: name + "-leave-to",
	    leaveActiveClass: name + "-leave-active"
	  };
	});
	
	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';
	
	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	  /* istanbul ignore if */
	  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
	    transitionProp = 'WebkitTransition';
	    transitionEndEvent = 'webkitTransitionEnd';
	  }
	  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
	    animationProp = 'WebkitAnimation';
	    animationEndEvent = 'webkitAnimationEnd';
	  }
	}
	
	// binding to window is necessary to make hot reload work in IE in strict mode
	var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;
	
	function nextFrame(fn) {
	  raf(function () {
	    raf(fn);
	  });
	}
	
	function addTransitionClass(el, cls) {
	  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
	  if (transitionClasses.indexOf(cls) < 0) {
	    transitionClasses.push(cls);
	    addClass(el, cls);
	  }
	}
	
	function removeTransitionClass(el, cls) {
	  if (el._transitionClasses) {
	    remove(el._transitionClasses, cls);
	  }
	  removeClass(el, cls);
	}
	
	function whenTransitionEnds(el, expectedType, cb) {
	  var ref = getTransitionInfo(el, expectedType);
	  var type = ref.type;
	  var timeout = ref.timeout;
	  var propCount = ref.propCount;
	  if (!type) {
	    return cb();
	  }
	  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	  var ended = 0;
	  var end = function end() {
	    el.removeEventListener(event, onEnd);
	    cb();
	  };
	  var onEnd = function onEnd(e) {
	    if (e.target === el) {
	      if (++ended >= propCount) {
	        end();
	      }
	    }
	  };
	  setTimeout(function () {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(event, onEnd);
	}
	
	var transformRE = /\b(transform|all)(,|$)/;
	
	function getTransitionInfo(el, expectedType) {
	  var styles = window.getComputedStyle(el);
	  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
	  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
	  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	  var animationDelays = styles[animationProp + 'Delay'].split(', ');
	  var animationDurations = styles[animationProp + 'Duration'].split(', ');
	  var animationTimeout = getTimeout(animationDelays, animationDurations);
	
	  var type;
	  var timeout = 0;
	  var propCount = 0;
	  /* istanbul ignore if */
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
	    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
	  }
	  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
	  return {
	    type: type,
	    timeout: timeout,
	    propCount: propCount,
	    hasTransform: hasTransform
	  };
	}
	
	function getTimeout(delays, durations) {
	  /* istanbul ignore next */
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }
	
	  return Math.max.apply(null, durations.map(function (d, i) {
	    return toMs(d) + toMs(delays[i]);
	  }));
	}
	
	function toMs(s) {
	  return Number(s.slice(0, -1)) * 1000;
	}
	
	/*  */
	
	function enter(vnode, toggleDisplay) {
	  var el = vnode.elm;
	
	  // call leave callback now
	  if (isDef(el._leaveCb)) {
	    el._leaveCb.cancelled = true;
	    el._leaveCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return;
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._enterCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var enterClass = data.enterClass;
	  var enterToClass = data.enterToClass;
	  var enterActiveClass = data.enterActiveClass;
	  var appearClass = data.appearClass;
	  var appearToClass = data.appearToClass;
	  var appearActiveClass = data.appearActiveClass;
	  var beforeEnter = data.beforeEnter;
	  var enter = data.enter;
	  var afterEnter = data.afterEnter;
	  var enterCancelled = data.enterCancelled;
	  var beforeAppear = data.beforeAppear;
	  var appear = data.appear;
	  var afterAppear = data.afterAppear;
	  var appearCancelled = data.appearCancelled;
	  var duration = data.duration;
	
	  // activeInstance will always be the <transition> component managing this
	  // transition. One edge case to check is when the <transition> is placed
	  // as the root node of a child component. In that case we need to check
	  // <transition>'s parent for appear check.
	  var context = activeInstance;
	  var transitionNode = activeInstance.$vnode;
	  while (transitionNode && transitionNode.parent) {
	    transitionNode = transitionNode.parent;
	    context = transitionNode.context;
	  }
	
	  var isAppear = !context._isMounted || !vnode.isRootInsert;
	
	  if (isAppear && !appear && appear !== '') {
	    return;
	  }
	
	  var startClass = isAppear && appearClass ? appearClass : enterClass;
	  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
	  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
	
	  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
	  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
	  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
	  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
	
	  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
	
	  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
	    checkDuration(explicitEnterDuration, 'enter', vnode);
	  }
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(enterHook);
	
	  var cb = el._enterCb = once(function () {
	    if (expectsCSS) {
	      removeTransitionClass(el, toClass);
	      removeTransitionClass(el, activeClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, startClass);
	      }
	      enterCancelledHook && enterCancelledHook(el);
	    } else {
	      afterEnterHook && afterEnterHook(el);
	    }
	    el._enterCb = null;
	  });
	
	  if (!vnode.data.show) {
	    // remove pending leave element on enter by injecting an insert hook
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
	      var parent = el.parentNode;
	      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
	        pendingNode.elm._leaveCb();
	      }
	      enterHook && enterHook(el, cb);
	    });
	  }
	
	  // start enter transition
	  beforeEnterHook && beforeEnterHook(el);
	  if (expectsCSS) {
	    addTransitionClass(el, startClass);
	    addTransitionClass(el, activeClass);
	    nextFrame(function () {
	      addTransitionClass(el, toClass);
	      removeTransitionClass(el, startClass);
	      if (!cb.cancelled && !userWantsControl) {
	        if (isValidDuration(explicitEnterDuration)) {
	          setTimeout(cb, explicitEnterDuration);
	        } else {
	          whenTransitionEnds(el, type, cb);
	        }
	      }
	    });
	  }
	
	  if (vnode.data.show) {
	    toggleDisplay && toggleDisplay();
	    enterHook && enterHook(el, cb);
	  }
	
	  if (!expectsCSS && !userWantsControl) {
	    cb();
	  }
	}
	
	function leave(vnode, rm) {
	  var el = vnode.elm;
	
	  // call enter callback now
	  if (isDef(el._enterCb)) {
	    el._enterCb.cancelled = true;
	    el._enterCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return rm();
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._leaveCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var leaveClass = data.leaveClass;
	  var leaveToClass = data.leaveToClass;
	  var leaveActiveClass = data.leaveActiveClass;
	  var beforeLeave = data.beforeLeave;
	  var leave = data.leave;
	  var afterLeave = data.afterLeave;
	  var leaveCancelled = data.leaveCancelled;
	  var delayLeave = data.delayLeave;
	  var duration = data.duration;
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(leave);
	
	  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
	
	  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
	    checkDuration(explicitLeaveDuration, 'leave', vnode);
	  }
	
	  var cb = el._leaveCb = once(function () {
	    if (el.parentNode && el.parentNode._pending) {
	      el.parentNode._pending[vnode.key] = null;
	    }
	    if (expectsCSS) {
	      removeTransitionClass(el, leaveToClass);
	      removeTransitionClass(el, leaveActiveClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, leaveClass);
	      }
	      leaveCancelled && leaveCancelled(el);
	    } else {
	      rm();
	      afterLeave && afterLeave(el);
	    }
	    el._leaveCb = null;
	  });
	
	  if (delayLeave) {
	    delayLeave(performLeave);
	  } else {
	    performLeave();
	  }
	
	  function performLeave() {
	    // the delayed leave may have already been cancelled
	    if (cb.cancelled) {
	      return;
	    }
	    // record leaving element
	    if (!vnode.data.show) {
	      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
	    }
	    beforeLeave && beforeLeave(el);
	    if (expectsCSS) {
	      addTransitionClass(el, leaveClass);
	      addTransitionClass(el, leaveActiveClass);
	      nextFrame(function () {
	        addTransitionClass(el, leaveToClass);
	        removeTransitionClass(el, leaveClass);
	        if (!cb.cancelled && !userWantsControl) {
	          if (isValidDuration(explicitLeaveDuration)) {
	            setTimeout(cb, explicitLeaveDuration);
	          } else {
	            whenTransitionEnds(el, type, cb);
	          }
	        }
	      });
	    }
	    leave && leave(el, cb);
	    if (!expectsCSS && !userWantsControl) {
	      cb();
	    }
	  }
	}
	
	// only used in dev mode
	function checkDuration(val, name, vnode) {
	  if (typeof val !== 'number') {
	    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
	  } else if (isNaN(val)) {
	    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
	  }
	}
	
	function isValidDuration(val) {
	  return typeof val === 'number' && !isNaN(val);
	}
	
	/**
	 * Normalize a transition hook's argument length. The hook may be:
	 * - a merged hook (invoker) with the original in .fns
	 * - a wrapped component method (check ._length)
	 * - a plain function (.length)
	 */
	function getHookArgumentsLength(fn) {
	  if (isUndef(fn)) {
	    return false;
	  }
	  var invokerFns = fn.fns;
	  if (isDef(invokerFns)) {
	    // invoker
	    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
	  } else {
	    return (fn._length || fn.length) > 1;
	  }
	}
	
	function _enter(_, vnode) {
	  if (vnode.data.show !== true) {
	    enter(vnode);
	  }
	}
	
	var transition = inBrowser ? {
	  create: _enter,
	  activate: _enter,
	  remove: function remove$$1(vnode, rm) {
	    /* istanbul ignore else */
	    if (vnode.data.show !== true) {
	      leave(vnode, rm);
	    } else {
	      rm();
	    }
	  }
	} : {};
	
	var platformModules = [attrs, klass, events, domProps, style, transition];
	
	/*  */
	
	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);
	
	var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
	
	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */
	
	var isTextInputType = makeMap('text,number,password,search,email,tel,url');
	
	/* istanbul ignore if */
	if (isIE9) {
	  // http://www.matts411.com/post/internet-explorer-9-oninput/
	  document.addEventListener('selectionchange', function () {
	    var el = document.activeElement;
	    if (el && el.vmodel) {
	      trigger(el, 'input');
	    }
	  });
	}
	
	var model$1 = {
	  inserted: function inserted(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      var cb = function cb() {
	        setSelected(el, binding, vnode.context);
	      };
	      cb();
	      /* istanbul ignore if */
	      if (isIE || isEdge) {
	        setTimeout(cb, 0);
	      }
	      el._vOptions = [].map.call(el.options, getValue);
	    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
	      el._vModifiers = binding.modifiers;
	      if (!binding.modifiers.lazy) {
	        // Safari < 10.2 & UIWebView doesn't fire compositionend when
	        // switching focus before confirming composition choice
	        // this also fixes the issue where some browsers e.g. iOS Chrome
	        // fires "change" instead of "input" on autocomplete.
	        el.addEventListener('change', onCompositionEnd);
	        if (!isAndroid) {
	          el.addEventListener('compositionstart', onCompositionStart);
	          el.addEventListener('compositionend', onCompositionEnd);
	        }
	        /* istanbul ignore if */
	        if (isIE9) {
	          el.vmodel = true;
	        }
	      }
	    }
	  },
	  componentUpdated: function componentUpdated(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      setSelected(el, binding, vnode.context);
	      // in case the options rendered by v-for have changed,
	      // it's possible that the value is out-of-sync with the rendered options.
	      // detect such cases and filter out values that no longer has a matching
	      // option in the DOM.
	      var prevOptions = el._vOptions;
	      var curOptions = el._vOptions = [].map.call(el.options, getValue);
	      if (curOptions.some(function (o, i) {
	        return !looseEqual(o, prevOptions[i]);
	      })) {
	        trigger(el, 'change');
	      }
	    }
	  }
	};
	
	function setSelected(el, binding, vm) {
	  var value = binding.value;
	  var isMultiple = el.multiple;
	  if (isMultiple && !Array.isArray(value)) {
	    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
	    return;
	  }
	  var selected, option;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    option = el.options[i];
	    if (isMultiple) {
	      selected = looseIndexOf(value, getValue(option)) > -1;
	      if (option.selected !== selected) {
	        option.selected = selected;
	      }
	    } else {
	      if (looseEqual(getValue(option), value)) {
	        if (el.selectedIndex !== i) {
	          el.selectedIndex = i;
	        }
	        return;
	      }
	    }
	  }
	  if (!isMultiple) {
	    el.selectedIndex = -1;
	  }
	}
	
	function getValue(option) {
	  return '_value' in option ? option._value : option.value;
	}
	
	function onCompositionStart(e) {
	  e.target.composing = true;
	}
	
	function onCompositionEnd(e) {
	  // prevent triggering an input event for no reason
	  if (!e.target.composing) {
	    return;
	  }
	  e.target.composing = false;
	  trigger(e.target, 'input');
	}
	
	function trigger(el, type) {
	  var e = document.createEvent('HTMLEvents');
	  e.initEvent(type, true, true);
	  el.dispatchEvent(e);
	}
	
	/*  */
	
	// recursively search for possible transition defined inside the component root
	function locateNode(vnode) {
	  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
	}
	
	var show = {
	  bind: function bind(el, ref, vnode) {
	    var value = ref.value;
	
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
	    if (value && transition$$1) {
	      vnode.data.show = true;
	      enter(vnode, function () {
	        el.style.display = originalDisplay;
	      });
	    } else {
	      el.style.display = value ? originalDisplay : 'none';
	    }
	  },
	
	  update: function update(el, ref, vnode) {
	    var value = ref.value;
	    var oldValue = ref.oldValue;
	
	    /* istanbul ignore if */
	    if (value === oldValue) {
	      return;
	    }
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    if (transition$$1) {
	      vnode.data.show = true;
	      if (value) {
	        enter(vnode, function () {
	          el.style.display = el.__vOriginalDisplay;
	        });
	      } else {
	        leave(vnode, function () {
	          el.style.display = 'none';
	        });
	      }
	    } else {
	      el.style.display = value ? el.__vOriginalDisplay : 'none';
	    }
	  },
	
	  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
	    if (!isDestroy) {
	      el.style.display = el.__vOriginalDisplay;
	    }
	  }
	};
	
	var platformDirectives = {
	  model: model$1,
	  show: show
	};
	
	/*  */
	
	// Provides transition support for a single element/component.
	// supports transition mode (out-in / in-out)
	
	var transitionProps = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  duration: [Number, String, Object]
	};
	
	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild(vnode) {
	  var compOptions = vnode && vnode.componentOptions;
	  if (compOptions && compOptions.Ctor.options.abstract) {
	    return getRealChild(getFirstComponentChild(compOptions.children));
	  } else {
	    return vnode;
	  }
	}
	
	function extractTransitionData(comp) {
	  var data = {};
	  var options = comp.$options;
	  // props
	  for (var key in options.propsData) {
	    data[key] = comp[key];
	  }
	  // events.
	  // extract listeners and pass them directly to the transition methods
	  var listeners = options._parentListeners;
	  for (var key$1 in listeners) {
	    data[camelize(key$1)] = listeners[key$1];
	  }
	  return data;
	}
	
	function placeholder(h, rawChild) {
	  if (/\d-keep-alive$/.test(rawChild.tag)) {
	    return h('keep-alive', {
	      props: rawChild.componentOptions.propsData
	    });
	  }
	}
	
	function hasParentTransition(vnode) {
	  while (vnode = vnode.parent) {
	    if (vnode.data.transition) {
	      return true;
	    }
	  }
	}
	
	function isSameChild(child, oldChild) {
	  return oldChild.key === child.key && oldChild.tag === child.tag;
	}
	
	function isAsyncPlaceholder(node) {
	  return node.isComment && node.asyncFactory;
	}
	
	var Transition = {
	  name: 'transition',
	  props: transitionProps,
	  abstract: true,
	
	  render: function render(h) {
	    var this$1 = this;
	
	    var children = this.$options._renderChildren;
	    if (!children) {
	      return;
	    }
	
	    // filter out text nodes (possible whitespaces)
	    children = children.filter(function (c) {
	      return c.tag || isAsyncPlaceholder(c);
	    });
	    /* istanbul ignore if */
	    if (!children.length) {
	      return;
	    }
	
	    // warn multiple elements
	    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
	      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
	    }
	
	    var mode = this.mode;
	
	    // warn invalid mode
	    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
	      warn('invalid <transition> mode: ' + mode, this.$parent);
	    }
	
	    var rawChild = children[0];
	
	    // if this is a component root node and the component's
	    // parent container node also has transition, skip.
	    if (hasParentTransition(this.$vnode)) {
	      return rawChild;
	    }
	
	    // apply transition data to child
	    // use getRealChild() to ignore abstract components e.g. keep-alive
	    var child = getRealChild(rawChild);
	    /* istanbul ignore if */
	    if (!child) {
	      return rawChild;
	    }
	
	    if (this._leaving) {
	      return placeholder(h, rawChild);
	    }
	
	    // ensure a key that is unique to the vnode type and to this transition
	    // component instance. This key will be used to remove pending leaving nodes
	    // during entering.
	    var id = "__transition-" + this._uid + "-";
	    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
	
	    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
	    var oldRawChild = this._vnode;
	    var oldChild = getRealChild(oldRawChild);
	
	    // mark v-show
	    // so that the transition module can hand over the control to the directive
	    if (child.data.directives && child.data.directives.some(function (d) {
	      return d.name === 'show';
	    })) {
	      child.data.show = true;
	    }
	
	    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
	      // replace old child transition data with fresh one
	      // important for dynamic transitions!
	      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
	      // handle transition mode
	      if (mode === 'out-in') {
	        // return placeholder node and queue update when leave finishes
	        this._leaving = true;
	        mergeVNodeHook(oldData, 'afterLeave', function () {
	          this$1._leaving = false;
	          this$1.$forceUpdate();
	        });
	        return placeholder(h, rawChild);
	      } else if (mode === 'in-out') {
	        if (isAsyncPlaceholder(child)) {
	          return oldRawChild;
	        }
	        var delayedLeave;
	        var performLeave = function performLeave() {
	          delayedLeave();
	        };
	        mergeVNodeHook(data, 'afterEnter', performLeave);
	        mergeVNodeHook(data, 'enterCancelled', performLeave);
	        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	          delayedLeave = leave;
	        });
	      }
	    }
	
	    return rawChild;
	  }
	};
	
	/*  */
	
	// Provides transition support for list items.
	// supports move transitions using the FLIP technique.
	
	// Because the vdom's children update algorithm is "unstable" - i.e.
	// it doesn't guarantee the relative positioning of removed elements,
	// we force transition-group to update its children into two passes:
	// in the first pass, we remove all nodes that need to be removed,
	// triggering their leaving transition; in the second pass, we insert/move
	// into the final desired state. This way in the second pass removed
	// nodes will remain where they should be.
	
	var props = extend({
	  tag: String,
	  moveClass: String
	}, transitionProps);
	
	delete props.mode;
	
	var TransitionGroup = {
	  props: props,
	
	  render: function render(h) {
	    var tag = this.tag || this.$vnode.data.tag || 'span';
	    var map = Object.create(null);
	    var prevChildren = this.prevChildren = this.children;
	    var rawChildren = this.$slots.default || [];
	    var children = this.children = [];
	    var transitionData = extractTransitionData(this);
	
	    for (var i = 0; i < rawChildren.length; i++) {
	      var c = rawChildren[i];
	      if (c.tag) {
	        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	          children.push(c);
	          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
	        } else if (process.env.NODE_ENV !== 'production') {
	          var opts = c.componentOptions;
	          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
	          warn("<transition-group> children must be keyed: <" + name + ">");
	        }
	      }
	    }
	
	    if (prevChildren) {
	      var kept = [];
	      var removed = [];
	      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
	        var c$1 = prevChildren[i$1];
	        c$1.data.transition = transitionData;
	        c$1.data.pos = c$1.elm.getBoundingClientRect();
	        if (map[c$1.key]) {
	          kept.push(c$1);
	        } else {
	          removed.push(c$1);
	        }
	      }
	      this.kept = h(tag, null, kept);
	      this.removed = removed;
	    }
	
	    return h(tag, null, children);
	  },
	
	  beforeUpdate: function beforeUpdate() {
	    // force removing pass
	    this.__patch__(this._vnode, this.kept, false, // hydrating
	    true // removeOnly (!important, avoids unnecessary moves)
	    );
	    this._vnode = this.kept;
	  },
	
	  updated: function updated() {
	    var children = this.prevChildren;
	    var moveClass = this.moveClass || (this.name || 'v') + '-move';
	    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	      return;
	    }
	
	    // we divide the work into three loops to avoid mixing DOM reads and writes
	    // in each iteration - which helps prevent layout thrashing.
	    children.forEach(callPendingCbs);
	    children.forEach(recordPosition);
	    children.forEach(applyTranslation);
	
	    // force reflow to put everything in position
	    var body = document.body;
	    var f = body.offsetHeight; // eslint-disable-line
	
	    children.forEach(function (c) {
	      if (c.data.moved) {
	        var el = c.elm;
	        var s = el.style;
	        addTransitionClass(el, moveClass);
	        s.transform = s.WebkitTransform = s.transitionDuration = '';
	        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
	          if (!e || /transform$/.test(e.propertyName)) {
	            el.removeEventListener(transitionEndEvent, cb);
	            el._moveCb = null;
	            removeTransitionClass(el, moveClass);
	          }
	        });
	      }
	    });
	  },
	
	  methods: {
	    hasMove: function hasMove(el, moveClass) {
	      /* istanbul ignore if */
	      if (!hasTransition) {
	        return false;
	      }
	      /* istanbul ignore if */
	      if (this._hasMove) {
	        return this._hasMove;
	      }
	      // Detect whether an element with the move class applied has
	      // CSS transitions. Since the element may be inside an entering
	      // transition at this very moment, we make a clone of it and remove
	      // all other transition classes applied to ensure only the move class
	      // is applied.
	      var clone = el.cloneNode();
	      if (el._transitionClasses) {
	        el._transitionClasses.forEach(function (cls) {
	          removeClass(clone, cls);
	        });
	      }
	      addClass(clone, moveClass);
	      clone.style.display = 'none';
	      this.$el.appendChild(clone);
	      var info = getTransitionInfo(clone);
	      this.$el.removeChild(clone);
	      return this._hasMove = info.hasTransform;
	    }
	  }
	};
	
	function callPendingCbs(c) {
	  /* istanbul ignore if */
	  if (c.elm._moveCb) {
	    c.elm._moveCb();
	  }
	  /* istanbul ignore if */
	  if (c.elm._enterCb) {
	    c.elm._enterCb();
	  }
	}
	
	function recordPosition(c) {
	  c.data.newPos = c.elm.getBoundingClientRect();
	}
	
	function applyTranslation(c) {
	  var oldPos = c.data.pos;
	  var newPos = c.data.newPos;
	  var dx = oldPos.left - newPos.left;
	  var dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    c.data.moved = true;
	    var s = c.elm.style;
	    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
	    s.transitionDuration = '0s';
	  }
	}
	
	var platformComponents = {
	  Transition: Transition,
	  TransitionGroup: TransitionGroup
	};
	
	/*  */
	
	// install platform specific utils
	Vue$3.config.mustUseProp = mustUseProp;
	Vue$3.config.isReservedTag = isReservedTag;
	Vue$3.config.isReservedAttr = isReservedAttr;
	Vue$3.config.getTagNamespace = getTagNamespace;
	Vue$3.config.isUnknownElement = isUnknownElement;
	
	// install platform runtime directives & components
	extend(Vue$3.options.directives, platformDirectives);
	extend(Vue$3.options.components, platformComponents);
	
	// install platform patch function
	Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
	
	// public mount method
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && inBrowser ? query(el) : undefined;
	  return mountComponent(this, el, hydrating);
	};
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue$3);
	    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
	      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
	    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
	  }
	}, 0);
	
	/*  */
	
	// check whether current browser encodes a char inside attribute values
	function shouldDecode(content, encoded) {
	  var div = document.createElement('div');
	  div.innerHTML = "<div a=\"" + content + "\"/>";
	  return div.innerHTML.indexOf(encoded) > 0;
	}
	
	// #3663
	// IE encodes newlines inside attribute values while other browsers don't
	var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;
	
	/*  */
	
	var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	
	var buildRegex = cached(function (delimiters) {
	  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
	  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
	  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
	});
	
	function parseText(text, delimiters) {
	  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
	  if (!tagRE.test(text)) {
	    return;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index;
	  while (match = tagRE.exec(text)) {
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
	    }
	    // tag token
	    var exp = parseFilters(match[1].trim());
	    tokens.push("_s(" + exp + ")");
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push(JSON.stringify(text.slice(lastIndex)));
	  }
	  return tokens.join('+');
	}
	
	/*  */
	
	function transformNode(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticClass = getAndRemoveAttr(el, 'class');
	  if (process.env.NODE_ENV !== 'production' && staticClass) {
	    var expression = parseText(staticClass, options.delimiters);
	    if (expression) {
	      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
	    }
	  }
	  if (staticClass) {
	    el.staticClass = JSON.stringify(staticClass);
	  }
	  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
	  if (classBinding) {
	    el.classBinding = classBinding;
	  }
	}
	
	function genData(el) {
	  var data = '';
	  if (el.staticClass) {
	    data += "staticClass:" + el.staticClass + ",";
	  }
	  if (el.classBinding) {
	    data += "class:" + el.classBinding + ",";
	  }
	  return data;
	}
	
	var klass$1 = {
	  staticKeys: ['staticClass'],
	  transformNode: transformNode,
	  genData: genData
	};
	
	/*  */
	
	function transformNode$1(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticStyle = getAndRemoveAttr(el, 'style');
	  if (staticStyle) {
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      var expression = parseText(staticStyle, options.delimiters);
	      if (expression) {
	        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
	      }
	    }
	    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
	  }
	
	  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
	  if (styleBinding) {
	    el.styleBinding = styleBinding;
	  }
	}
	
	function genData$1(el) {
	  var data = '';
	  if (el.staticStyle) {
	    data += "staticStyle:" + el.staticStyle + ",";
	  }
	  if (el.styleBinding) {
	    data += "style:(" + el.styleBinding + "),";
	  }
	  return data;
	}
	
	var style$1 = {
	  staticKeys: ['staticStyle'],
	  transformNode: transformNode$1,
	  genData: genData$1
	};
	
	var modules$1 = [klass$1, style$1];
	
	/*  */
	
	function text(el, dir) {
	  if (dir.value) {
	    addProp(el, 'textContent', "_s(" + dir.value + ")");
	  }
	}
	
	/*  */
	
	function html(el, dir) {
	  if (dir.value) {
	    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
	  }
	}
	
	var directives$1 = {
	  model: model,
	  text: text,
	  html: html
	};
	
	/*  */
	
	var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');
	
	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
	
	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
	
	/*  */
	
	var baseOptions = {
	  expectHTML: true,
	  modules: modules$1,
	  directives: directives$1,
	  isPreTag: isPreTag,
	  isUnaryTag: isUnaryTag,
	  mustUseProp: mustUseProp,
	  canBeLeftOpenTag: canBeLeftOpenTag,
	  isReservedTag: isReservedTag,
	  getTagNamespace: getTagNamespace,
	  staticKeys: genStaticKeys(modules$1)
	};
	
	/*  */
	
	var decoder;
	
	var he = {
	  decode: function decode(html) {
	    decoder = decoder || document.createElement('div');
	    decoder.innerHTML = html;
	    return decoder.textContent;
	  }
	};
	
	/**
	 * Not type-checking this file because it's mostly vendor code.
	 */
	
	/*!
	 * HTML Parser By John Resig (ejohn.org)
	 * Modified by Juriy "kangax" Zaytsev
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 */
	
	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/;
	var singleAttrAssign = /(?:=)/;
	var singleAttrValues = [
	// attr value double quotes
	/"([^"]*)"+/.source,
	// attr value, single quotes
	/'([^']*)'+/.source,
	// attr value, no quotes
	/([^\s"'=<>`]+)/.source];
	var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');
	
	// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	// but for Vue templates we can enforce a simple charset
	var ncname = '[a-zA-Z_][\\w\\-\\.]*';
	var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
	var startTagOpen = new RegExp('^<' + qnameCapture);
	var startTagClose = /^\s*(\/?)>/;
	var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
	var doctype = /^<!DOCTYPE [^>]+>/i;
	var comment = /^<!--/;
	var conditionalComment = /^<!\[/;
	
	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function (m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});
	
	// Special Elements (can contain anything)
	var isPlainTextElement = makeMap('script,style,textarea', true);
	var reCache = {};
	
	var decodingMap = {
	  '&lt;': '<',
	  '&gt;': '>',
	  '&quot;': '"',
	  '&amp;': '&',
	  '&#10;': '\n'
	};
	var encodedAttr = /&(?:lt|gt|quot|amp);/g;
	var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;
	
	// #5992
	var isIgnoreNewlineTag = makeMap('pre,textarea', true);
	var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
	  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
	};
	
	function decodeAttr(value, shouldDecodeNewlines) {
	  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
	  return value.replace(re, function (match) {
	    return decodingMap[match];
	  });
	}
	
	function parseHTML(html, options) {
	  var stack = [];
	  var expectHTML = options.expectHTML;
	  var isUnaryTag$$1 = options.isUnaryTag || no;
	  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
	  var index = 0;
	  var last, lastTag;
	  while (html) {
	    last = html;
	    // Make sure we're not in a plaintext content element like script/style
	    if (!lastTag || !isPlainTextElement(lastTag)) {
	      var textEnd = html.indexOf('<');
	      if (textEnd === 0) {
	        // Comment:
	        if (comment.test(html)) {
	          var commentEnd = html.indexOf('-->');
	
	          if (commentEnd >= 0) {
	            if (options.shouldKeepComment) {
	              options.comment(html.substring(4, commentEnd));
	            }
	            advance(commentEnd + 3);
	            continue;
	          }
	        }
	
	        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	        if (conditionalComment.test(html)) {
	          var conditionalEnd = html.indexOf(']>');
	
	          if (conditionalEnd >= 0) {
	            advance(conditionalEnd + 2);
	            continue;
	          }
	        }
	
	        // Doctype:
	        var doctypeMatch = html.match(doctype);
	        if (doctypeMatch) {
	          advance(doctypeMatch[0].length);
	          continue;
	        }
	
	        // End tag:
	        var endTagMatch = html.match(endTag);
	        if (endTagMatch) {
	          var curIndex = index;
	          advance(endTagMatch[0].length);
	          parseEndTag(endTagMatch[1], curIndex, index);
	          continue;
	        }
	
	        // Start tag:
	        var startTagMatch = parseStartTag();
	        if (startTagMatch) {
	          handleStartTag(startTagMatch);
	          if (shouldIgnoreFirstNewline(lastTag, html)) {
	            advance(1);
	          }
	          continue;
	        }
	      }
	
	      var text = void 0,
	          rest = void 0,
	          next = void 0;
	      if (textEnd >= 0) {
	        rest = html.slice(textEnd);
	        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
	          // < in plain text, be forgiving and treat it as text
	          next = rest.indexOf('<', 1);
	          if (next < 0) {
	            break;
	          }
	          textEnd += next;
	          rest = html.slice(textEnd);
	        }
	        text = html.substring(0, textEnd);
	        advance(textEnd);
	      }
	
	      if (textEnd < 0) {
	        text = html;
	        html = '';
	      }
	
	      if (options.chars && text) {
	        options.chars(text);
	      }
	    } else {
	      var endTagLength = 0;
	      var stackedTag = lastTag.toLowerCase();
	      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
	      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
	        endTagLength = endTag.length;
	        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
	          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	        }
	        if (shouldIgnoreFirstNewline(stackedTag, text)) {
	          text = text.slice(1);
	        }
	        if (options.chars) {
	          options.chars(text);
	        }
	        return '';
	      });
	      index += html.length - rest$1.length;
	      html = rest$1;
	      parseEndTag(stackedTag, index - endTagLength, index);
	    }
	
	    if (html === last) {
	      options.chars && options.chars(html);
	      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
	        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
	      }
	      break;
	    }
	  }
	
	  // Clean up any remaining tags
	  parseEndTag();
	
	  function advance(n) {
	    index += n;
	    html = html.substring(n);
	  }
	
	  function parseStartTag() {
	    var start = html.match(startTagOpen);
	    if (start) {
	      var match = {
	        tagName: start[1],
	        attrs: [],
	        start: index
	      };
	      advance(start[0].length);
	      var end, attr;
	      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
	        advance(attr[0].length);
	        match.attrs.push(attr);
	      }
	      if (end) {
	        match.unarySlash = end[1];
	        advance(end[0].length);
	        match.end = index;
	        return match;
	      }
	    }
	  }
	
	  function handleStartTag(match) {
	    var tagName = match.tagName;
	    var unarySlash = match.unarySlash;
	
	    if (expectHTML) {
	      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
	        parseEndTag(lastTag);
	      }
	      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
	        parseEndTag(tagName);
	      }
	    }
	
	    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
	
	    var l = match.attrs.length;
	    var attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      var args = match.attrs[i];
	      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	        if (args[3] === '') {
	          delete args[3];
	        }
	        if (args[4] === '') {
	          delete args[4];
	        }
	        if (args[5] === '') {
	          delete args[5];
	        }
	      }
	      var value = args[3] || args[4] || args[5] || '';
	      attrs[i] = {
	        name: args[1],
	        value: decodeAttr(value, options.shouldDecodeNewlines)
	      };
	    }
	
	    if (!unary) {
	      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
	      lastTag = tagName;
	    }
	
	    if (options.start) {
	      options.start(tagName, attrs, unary, match.start, match.end);
	    }
	  }
	
	  function parseEndTag(tagName, start, end) {
	    var pos, lowerCasedTagName;
	    if (start == null) {
	      start = index;
	    }
	    if (end == null) {
	      end = index;
	    }
	
	    if (tagName) {
	      lowerCasedTagName = tagName.toLowerCase();
	    }
	
	    // Find the closest opened tag of the same type
	    if (tagName) {
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
	          break;
	        }
	      }
	    } else {
	      // If no tag name is provided, clean shop
	      pos = 0;
	    }
	
	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (var i = stack.length - 1; i >= pos; i--) {
	        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
	          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
	        }
	        if (options.end) {
	          options.end(stack[i].tag, start, end);
	        }
	      }
	
	      // Remove the open elements from the stack
	      stack.length = pos;
	      lastTag = pos && stack[pos - 1].tag;
	    } else if (lowerCasedTagName === 'br') {
	      if (options.start) {
	        options.start(tagName, [], true, start, end);
	      }
	    } else if (lowerCasedTagName === 'p') {
	      if (options.start) {
	        options.start(tagName, [], false, start, end);
	      }
	      if (options.end) {
	        options.end(tagName, start, end);
	      }
	    }
	  }
	}
	
	/*  */
	
	var onRE = /^@|^v-on:/;
	var dirRE = /^v-|^@|^:/;
	var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
	var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
	
	var argRE = /:(.*)$/;
	var bindRE = /^:|^v-bind:/;
	var modifierRE = /\.[^.]+/g;
	
	var decodeHTMLCached = cached(he.decode);
	
	// configurable state
	var warn$2;
	var delimiters;
	var transforms;
	var preTransforms;
	var postTransforms;
	var platformIsPreTag;
	var platformMustUseProp;
	var platformGetTagNamespace;
	
	/**
	 * Convert HTML string to AST.
	 */
	function parse(template, options) {
	  warn$2 = options.warn || baseWarn;
	
	  platformIsPreTag = options.isPreTag || no;
	  platformMustUseProp = options.mustUseProp || no;
	  platformGetTagNamespace = options.getTagNamespace || no;
	
	  transforms = pluckModuleFunction(options.modules, 'transformNode');
	  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
	  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
	
	  delimiters = options.delimiters;
	
	  var stack = [];
	  var preserveWhitespace = options.preserveWhitespace !== false;
	  var root;
	  var currentParent;
	  var inVPre = false;
	  var inPre = false;
	  var warned = false;
	
	  function warnOnce(msg) {
	    if (!warned) {
	      warned = true;
	      warn$2(msg);
	    }
	  }
	
	  function endPre(element) {
	    // check pre state
	    if (element.pre) {
	      inVPre = false;
	    }
	    if (platformIsPreTag(element.tag)) {
	      inPre = false;
	    }
	  }
	
	  parseHTML(template, {
	    warn: warn$2,
	    expectHTML: options.expectHTML,
	    isUnaryTag: options.isUnaryTag,
	    canBeLeftOpenTag: options.canBeLeftOpenTag,
	    shouldDecodeNewlines: options.shouldDecodeNewlines,
	    shouldKeepComment: options.comments,
	    start: function start(tag, attrs, unary) {
	      // check namespace.
	      // inherit parent ns if there is one
	      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);
	
	      // handle IE svg bug
	      /* istanbul ignore if */
	      if (isIE && ns === 'svg') {
	        attrs = guardIESVGBug(attrs);
	      }
	
	      var element = {
	        type: 1,
	        tag: tag,
	        attrsList: attrs,
	        attrsMap: makeAttrsMap(attrs),
	        parent: currentParent,
	        children: []
	      };
	      if (ns) {
	        element.ns = ns;
	      }
	
	      if (isForbiddenTag(element) && !isServerRendering()) {
	        element.forbidden = true;
	        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
	      }
	
	      // apply pre-transforms
	      for (var i = 0; i < preTransforms.length; i++) {
	        preTransforms[i](element, options);
	      }
	
	      if (!inVPre) {
	        processPre(element);
	        if (element.pre) {
	          inVPre = true;
	        }
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = true;
	      }
	      if (inVPre) {
	        processRawAttrs(element);
	      } else {
	        processFor(element);
	        processIf(element);
	        processOnce(element);
	        processKey(element);
	
	        // determine whether this is a plain element after
	        // removing structural attributes
	        element.plain = !element.key && !attrs.length;
	
	        processRef(element);
	        processSlot(element);
	        processComponent(element);
	        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
	          transforms[i$1](element, options);
	        }
	        processAttrs(element);
	      }
	
	      function checkRootConstraints(el) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (el.tag === 'slot' || el.tag === 'template') {
	            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
	          }
	          if (el.attrsMap.hasOwnProperty('v-for')) {
	            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
	          }
	        }
	      }
	
	      // tree management
	      if (!root) {
	        root = element;
	        checkRootConstraints(root);
	      } else if (!stack.length) {
	        // allow root elements with v-if, v-else-if and v-else
	        if (root.if && (element.elseif || element.else)) {
	          checkRootConstraints(element);
	          addIfCondition(root, {
	            exp: element.elseif,
	            block: element
	          });
	        } else if (process.env.NODE_ENV !== 'production') {
	          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
	        }
	      }
	      if (currentParent && !element.forbidden) {
	        if (element.elseif || element.else) {
	          processIfConditions(element, currentParent);
	        } else if (element.slotScope) {
	          // scoped slot
	          currentParent.plain = false;
	          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	        } else {
	          currentParent.children.push(element);
	          element.parent = currentParent;
	        }
	      }
	      if (!unary) {
	        currentParent = element;
	        stack.push(element);
	      } else {
	        endPre(element);
	      }
	      // apply post-transforms
	      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
	        postTransforms[i$2](element, options);
	      }
	    },
	
	    end: function end() {
	      // remove trailing whitespace
	      var element = stack[stack.length - 1];
	      var lastNode = element.children[element.children.length - 1];
	      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
	        element.children.pop();
	      }
	      // pop stack
	      stack.length -= 1;
	      currentParent = stack[stack.length - 1];
	      endPre(element);
	    },
	
	    chars: function chars(text) {
	      if (!currentParent) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (text === template) {
	            warnOnce('Component template requires a root element, rather than just text.');
	          } else if (text = text.trim()) {
	            warnOnce("text \"" + text + "\" outside root element will be ignored.");
	          }
	        }
	        return;
	      }
	      // IE textarea placeholder bug
	      /* istanbul ignore if */
	      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
	        return;
	      }
	      var children = currentParent.children;
	      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
	      // only preserve whitespace if its not right after a starting tag
	      : preserveWhitespace && children.length ? ' ' : '';
	      if (text) {
	        var expression;
	        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
	          children.push({
	            type: 2,
	            expression: expression,
	            text: text
	          });
	        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
	          children.push({
	            type: 3,
	            text: text
	          });
	        }
	      }
	    },
	    comment: function comment(text) {
	      currentParent.children.push({
	        type: 3,
	        text: text,
	        isComment: true
	      });
	    }
	  });
	  return root;
	}
	
	function processPre(el) {
	  if (getAndRemoveAttr(el, 'v-pre') != null) {
	    el.pre = true;
	  }
	}
	
	function processRawAttrs(el) {
	  var l = el.attrsList.length;
	  if (l) {
	    var attrs = el.attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      attrs[i] = {
	        name: el.attrsList[i].name,
	        value: JSON.stringify(el.attrsList[i].value)
	      };
	    }
	  } else if (!el.pre) {
	    // non root node in pre blocks with no attributes
	    el.plain = true;
	  }
	}
	
	function processKey(el) {
	  var exp = getBindingAttr(el, 'key');
	  if (exp) {
	    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
	      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
	    }
	    el.key = exp;
	  }
	}
	
	function processRef(el) {
	  var ref = getBindingAttr(el, 'ref');
	  if (ref) {
	    el.ref = ref;
	    el.refInFor = checkInFor(el);
	  }
	}
	
	function processFor(el) {
	  var exp;
	  if (exp = getAndRemoveAttr(el, 'v-for')) {
	    var inMatch = exp.match(forAliasRE);
	    if (!inMatch) {
	      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
	      return;
	    }
	    el.for = inMatch[2].trim();
	    var alias = inMatch[1].trim();
	    var iteratorMatch = alias.match(forIteratorRE);
	    if (iteratorMatch) {
	      el.alias = iteratorMatch[1].trim();
	      el.iterator1 = iteratorMatch[2].trim();
	      if (iteratorMatch[3]) {
	        el.iterator2 = iteratorMatch[3].trim();
	      }
	    } else {
	      el.alias = alias;
	    }
	  }
	}
	
	function processIf(el) {
	  var exp = getAndRemoveAttr(el, 'v-if');
	  if (exp) {
	    el.if = exp;
	    addIfCondition(el, {
	      exp: exp,
	      block: el
	    });
	  } else {
	    if (getAndRemoveAttr(el, 'v-else') != null) {
	      el.else = true;
	    }
	    var elseif = getAndRemoveAttr(el, 'v-else-if');
	    if (elseif) {
	      el.elseif = elseif;
	    }
	  }
	}
	
	function processIfConditions(el, parent) {
	  var prev = findPrevElement(parent.children);
	  if (prev && prev.if) {
	    addIfCondition(prev, {
	      exp: el.elseif,
	      block: el
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
	  }
	}
	
	function findPrevElement(children) {
	  var i = children.length;
	  while (i--) {
	    if (children[i].type === 1) {
	      return children[i];
	    } else {
	      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
	        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
	      }
	      children.pop();
	    }
	  }
	}
	
	function addIfCondition(el, condition) {
	  if (!el.ifConditions) {
	    el.ifConditions = [];
	  }
	  el.ifConditions.push(condition);
	}
	
	function processOnce(el) {
	  var once$$1 = getAndRemoveAttr(el, 'v-once');
	  if (once$$1 != null) {
	    el.once = true;
	  }
	}
	
	function processSlot(el) {
	  if (el.tag === 'slot') {
	    el.slotName = getBindingAttr(el, 'name');
	    if (process.env.NODE_ENV !== 'production' && el.key) {
	      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
	    }
	  } else {
	    var slotTarget = getBindingAttr(el, 'slot');
	    if (slotTarget) {
	      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
	    }
	    if (el.tag === 'template') {
	      el.slotScope = getAndRemoveAttr(el, 'scope');
	    }
	  }
	}
	
	function processComponent(el) {
	  var binding;
	  if (binding = getBindingAttr(el, 'is')) {
	    el.component = binding;
	  }
	  if (getAndRemoveAttr(el, 'inline-template') != null) {
	    el.inlineTemplate = true;
	  }
	}
	
	function processAttrs(el) {
	  var list = el.attrsList;
	  var i, l, name, rawName, value, modifiers, isProp;
	  for (i = 0, l = list.length; i < l; i++) {
	    name = rawName = list[i].name;
	    value = list[i].value;
	    if (dirRE.test(name)) {
	      // mark element as dynamic
	      el.hasBindings = true;
	      // modifiers
	      modifiers = parseModifiers(name);
	      if (modifiers) {
	        name = name.replace(modifierRE, '');
	      }
	      if (bindRE.test(name)) {
	        // v-bind
	        name = name.replace(bindRE, '');
	        value = parseFilters(value);
	        isProp = false;
	        if (modifiers) {
	          if (modifiers.prop) {
	            isProp = true;
	            name = camelize(name);
	            if (name === 'innerHtml') {
	              name = 'innerHTML';
	            }
	          }
	          if (modifiers.camel) {
	            name = camelize(name);
	          }
	          if (modifiers.sync) {
	            addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
	          }
	        }
	        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
	          addProp(el, name, value);
	        } else {
	          addAttr(el, name, value);
	        }
	      } else if (onRE.test(name)) {
	        // v-on
	        name = name.replace(onRE, '');
	        addHandler(el, name, value, modifiers, false, warn$2);
	      } else {
	        // normal directives
	        name = name.replace(dirRE, '');
	        // parse arg
	        var argMatch = name.match(argRE);
	        var arg = argMatch && argMatch[1];
	        if (arg) {
	          name = name.slice(0, -(arg.length + 1));
	        }
	        addDirective(el, name, rawName, value, arg, modifiers);
	        if (process.env.NODE_ENV !== 'production' && name === 'model') {
	          checkForAliasModel(el, value);
	        }
	      }
	    } else {
	      // literal attribute
	      if (process.env.NODE_ENV !== 'production') {
	        var expression = parseText(value, delimiters);
	        if (expression) {
	          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
	        }
	      }
	      addAttr(el, name, JSON.stringify(value));
	    }
	  }
	}
	
	function checkInFor(el) {
	  var parent = el;
	  while (parent) {
	    if (parent.for !== undefined) {
	      return true;
	    }
	    parent = parent.parent;
	  }
	  return false;
	}
	
	function parseModifiers(name) {
	  var match = name.match(modifierRE);
	  if (match) {
	    var ret = {};
	    match.forEach(function (m) {
	      ret[m.slice(1)] = true;
	    });
	    return ret;
	  }
	}
	
	function makeAttrsMap(attrs) {
	  var map = {};
	  for (var i = 0, l = attrs.length; i < l; i++) {
	    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
	      warn$2('duplicate attribute: ' + attrs[i].name);
	    }
	    map[attrs[i].name] = attrs[i].value;
	  }
	  return map;
	}
	
	// for script (e.g. type="x/template") or style, do not decode content
	function isTextTag(el) {
	  return el.tag === 'script' || el.tag === 'style';
	}
	
	function isForbiddenTag(el) {
	  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
	}
	
	var ieNSBug = /^xmlns:NS\d+/;
	var ieNSPrefix = /^NS\d+:/;
	
	/* istanbul ignore next */
	function guardIESVGBug(attrs) {
	  var res = [];
	  for (var i = 0; i < attrs.length; i++) {
	    var attr = attrs[i];
	    if (!ieNSBug.test(attr.name)) {
	      attr.name = attr.name.replace(ieNSPrefix, '');
	      res.push(attr);
	    }
	  }
	  return res;
	}
	
	function checkForAliasModel(el, value) {
	  var _el = el;
	  while (_el) {
	    if (_el.for && _el.alias === value) {
	      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
	    }
	    _el = _el.parent;
	  }
	}
	
	/*  */
	
	var isStaticKey;
	var isPlatformReservedTag;
	
	var genStaticKeysCached = cached(genStaticKeys$1);
	
	/**
	 * Goal of the optimizer: walk the generated template AST tree
	 * and detect sub-trees that are purely static, i.e. parts of
	 * the DOM that never needs to change.
	 *
	 * Once we detect these sub-trees, we can:
	 *
	 * 1. Hoist them into constants, so that we no longer need to
	 *    create fresh nodes for them on each re-render;
	 * 2. Completely skip them in the patching process.
	 */
	function optimize(root, options) {
	  if (!root) {
	    return;
	  }
	  isStaticKey = genStaticKeysCached(options.staticKeys || '');
	  isPlatformReservedTag = options.isReservedTag || no;
	  // first pass: mark all non-static nodes.
	  markStatic$1(root);
	  // second pass: mark static roots.
	  markStaticRoots(root, false);
	}
	
	function genStaticKeys$1(keys) {
	  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
	}
	
	function markStatic$1(node) {
	  node.static = isStatic(node);
	  if (node.type === 1) {
	    // do not make component slot content static. this avoids
	    // 1. components not able to mutate slot nodes
	    // 2. static slot content fails for hot-reloading
	    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
	      return;
	    }
	    for (var i = 0, l = node.children.length; i < l; i++) {
	      var child = node.children[i];
	      markStatic$1(child);
	      if (!child.static) {
	        node.static = false;
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        var block = node.ifConditions[i$1].block;
	        markStatic$1(block);
	        if (!block.static) {
	          node.static = false;
	        }
	      }
	    }
	  }
	}
	
	function markStaticRoots(node, isInFor) {
	  if (node.type === 1) {
	    if (node.static || node.once) {
	      node.staticInFor = isInFor;
	    }
	    // For a node to qualify as a static root, it should have children that
	    // are not just static text. Otherwise the cost of hoisting out will
	    // outweigh the benefits and it's better off to just always render it fresh.
	    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
	      node.staticRoot = true;
	      return;
	    } else {
	      node.staticRoot = false;
	    }
	    if (node.children) {
	      for (var i = 0, l = node.children.length; i < l; i++) {
	        markStaticRoots(node.children[i], isInFor || !!node.for);
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        markStaticRoots(node.ifConditions[i$1].block, isInFor);
	      }
	    }
	  }
	}
	
	function isStatic(node) {
	  if (node.type === 2) {
	    // expression
	    return false;
	  }
	  if (node.type === 3) {
	    // text
	    return true;
	  }
	  return !!(node.pre || !node.hasBindings && // no dynamic bindings
	  !node.if && !node.for && // not v-if or v-for or v-else
	  !isBuiltInTag(node.tag) && // not a built-in
	  isPlatformReservedTag(node.tag) && // not a component
	  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
	}
	
	function isDirectChildOfTemplateFor(node) {
	  while (node.parent) {
	    node = node.parent;
	    if (node.tag !== 'template') {
	      return false;
	    }
	    if (node.for) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
	var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  'delete': [8, 46]
	};
	
	// #4868: modifiers that prevent the execution of the listener
	// need to explicitly return null so that we can determine whether to remove
	// the listener for .once
	var genGuard = function genGuard(condition) {
	  return "if(" + condition + ")return null;";
	};
	
	var modifierCode = {
	  stop: '$event.stopPropagation();',
	  prevent: '$event.preventDefault();',
	  self: genGuard("$event.target !== $event.currentTarget"),
	  ctrl: genGuard("!$event.ctrlKey"),
	  shift: genGuard("!$event.shiftKey"),
	  alt: genGuard("!$event.altKey"),
	  meta: genGuard("!$event.metaKey"),
	  left: genGuard("'button' in $event && $event.button !== 0"),
	  middle: genGuard("'button' in $event && $event.button !== 1"),
	  right: genGuard("'button' in $event && $event.button !== 2")
	};
	
	function genHandlers(events, isNative, warn) {
	  var res = isNative ? 'nativeOn:{' : 'on:{';
	  for (var name in events) {
	    var handler = events[name];
	    // #5330: warn click.right, since right clicks do not actually fire click events.
	    if (process.env.NODE_ENV !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {
	      warn("Use \"contextmenu\" instead of \"click.right\" since right clicks " + "do not actually fire \"click\" events.");
	    }
	    res += "\"" + name + "\":" + genHandler(name, handler) + ",";
	  }
	  return res.slice(0, -1) + '}';
	}
	
	function genHandler(name, handler) {
	  if (!handler) {
	    return 'function(){}';
	  }
	
	  if (Array.isArray(handler)) {
	    return "[" + handler.map(function (handler) {
	      return genHandler(name, handler);
	    }).join(',') + "]";
	  }
	
	  var isMethodPath = simplePathRE.test(handler.value);
	  var isFunctionExpression = fnExpRE.test(handler.value);
	
	  if (!handler.modifiers) {
	    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
	  } else {
	    var code = '';
	    var genModifierCode = '';
	    var keys = [];
	    for (var key in handler.modifiers) {
	      if (modifierCode[key]) {
	        genModifierCode += modifierCode[key];
	        // left/right
	        if (keyCodes[key]) {
	          keys.push(key);
	        }
	      } else {
	        keys.push(key);
	      }
	    }
	    if (keys.length) {
	      code += genKeyFilter(keys);
	    }
	    // Make sure modifiers like prevent and stop get executed after key filtering
	    if (genModifierCode) {
	      code += genModifierCode;
	    }
	    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
	    return "function($event){" + code + handlerCode + "}";
	  }
	}
	
	function genKeyFilter(keys) {
	  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
	}
	
	function genFilterCode(key) {
	  var keyVal = parseInt(key, 10);
	  if (keyVal) {
	    return "$event.keyCode!==" + keyVal;
	  }
	  var alias = keyCodes[key];
	  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
	}
	
	/*  */
	
	function on(el, dir) {
	  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {
	    warn("v-on without argument does not support modifiers.");
	  }
	  el.wrapListeners = function (code) {
	    return "_g(" + code + "," + dir.value + ")";
	  };
	}
	
	/*  */
	
	function bind$1(el, dir) {
	  el.wrapData = function (code) {
	    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
	  };
	}
	
	/*  */
	
	var baseDirectives = {
	  on: on,
	  bind: bind$1,
	  cloak: noop
	};
	
	/*  */
	
	var CodegenState = function CodegenState(options) {
	  this.options = options;
	  this.warn = options.warn || baseWarn;
	  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
	  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
	  this.directives = extend(extend({}, baseDirectives), options.directives);
	  var isReservedTag = options.isReservedTag || no;
	  this.maybeComponent = function (el) {
	    return !isReservedTag(el.tag);
	  };
	  this.onceId = 0;
	  this.staticRenderFns = [];
	};
	
	function generate(ast, options) {
	  var state = new CodegenState(options);
	  var code = ast ? genElement(ast, state) : '_c("div")';
	  return {
	    render: "with(this){return " + code + "}",
	    staticRenderFns: state.staticRenderFns
	  };
	}
	
	function genElement(el, state) {
	  if (el.staticRoot && !el.staticProcessed) {
	    return genStatic(el, state);
	  } else if (el.once && !el.onceProcessed) {
	    return genOnce(el, state);
	  } else if (el.for && !el.forProcessed) {
	    return genFor(el, state);
	  } else if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.tag === 'template' && !el.slotTarget) {
	    return genChildren(el, state) || 'void 0';
	  } else if (el.tag === 'slot') {
	    return genSlot(el, state);
	  } else {
	    // component or element
	    var code;
	    if (el.component) {
	      code = genComponent(el.component, el, state);
	    } else {
	      var data = el.plain ? undefined : genData$2(el, state);
	
	      var children = el.inlineTemplate ? null : genChildren(el, state, true);
	      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
	    }
	    // module transforms
	    for (var i = 0; i < state.transforms.length; i++) {
	      code = state.transforms[i](el, code);
	    }
	    return code;
	  }
	}
	
	// hoist static sub-trees out
	function genStatic(el, state) {
	  el.staticProcessed = true;
	  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
	  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
	}
	
	// v-once
	function genOnce(el, state) {
	  el.onceProcessed = true;
	  if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.staticInFor) {
	    var key = '';
	    var parent = el.parent;
	    while (parent) {
	      if (parent.for) {
	        key = parent.key;
	        break;
	      }
	      parent = parent.parent;
	    }
	    if (!key) {
	      process.env.NODE_ENV !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
	      return genElement(el, state);
	    }
	    return "_o(" + genElement(el, state) + "," + state.onceId++ + (key ? "," + key : "") + ")";
	  } else {
	    return genStatic(el, state);
	  }
	}
	
	function genIf(el, state, altGen, altEmpty) {
	  el.ifProcessed = true; // avoid recursion
	  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
	}
	
	function genIfConditions(conditions, state, altGen, altEmpty) {
	  if (!conditions.length) {
	    return altEmpty || '_e()';
	  }
	
	  var condition = conditions.shift();
	  if (condition.exp) {
	    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
	  } else {
	    return "" + genTernaryExp(condition.block);
	  }
	
	  // v-if with v-once should generate code like (a)?_m(0):_m(1)
	  function genTernaryExp(el) {
	    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
	  }
	}
	
	function genFor(el, state, altGen, altHelper) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	
	  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
	    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
	    );
	  }
	
	  el.forProcessed = true; // avoid recursion
	  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
	}
	
	function genData$2(el, state) {
	  var data = '{';
	
	  // directives first.
	  // directives may mutate the el's other properties before they are generated.
	  var dirs = genDirectives(el, state);
	  if (dirs) {
	    data += dirs + ',';
	  }
	
	  // key
	  if (el.key) {
	    data += "key:" + el.key + ",";
	  }
	  // ref
	  if (el.ref) {
	    data += "ref:" + el.ref + ",";
	  }
	  if (el.refInFor) {
	    data += "refInFor:true,";
	  }
	  // pre
	  if (el.pre) {
	    data += "pre:true,";
	  }
	  // record original tag name for components using "is" attribute
	  if (el.component) {
	    data += "tag:\"" + el.tag + "\",";
	  }
	  // module data generation functions
	  for (var i = 0; i < state.dataGenFns.length; i++) {
	    data += state.dataGenFns[i](el);
	  }
	  // attributes
	  if (el.attrs) {
	    data += "attrs:{" + genProps(el.attrs) + "},";
	  }
	  // DOM props
	  if (el.props) {
	    data += "domProps:{" + genProps(el.props) + "},";
	  }
	  // event handlers
	  if (el.events) {
	    data += genHandlers(el.events, false, state.warn) + ",";
	  }
	  if (el.nativeEvents) {
	    data += genHandlers(el.nativeEvents, true, state.warn) + ",";
	  }
	  // slot target
	  if (el.slotTarget) {
	    data += "slot:" + el.slotTarget + ",";
	  }
	  // scoped slots
	  if (el.scopedSlots) {
	    data += genScopedSlots(el.scopedSlots, state) + ",";
	  }
	  // component v-model
	  if (el.model) {
	    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
	  }
	  // inline-template
	  if (el.inlineTemplate) {
	    var inlineTemplate = genInlineTemplate(el, state);
	    if (inlineTemplate) {
	      data += inlineTemplate + ",";
	    }
	  }
	  data = data.replace(/,$/, '') + '}';
	  // v-bind data wrap
	  if (el.wrapData) {
	    data = el.wrapData(data);
	  }
	  // v-on data wrap
	  if (el.wrapListeners) {
	    data = el.wrapListeners(data);
	  }
	  return data;
	}
	
	function genDirectives(el, state) {
	  var dirs = el.directives;
	  if (!dirs) {
	    return;
	  }
	  var res = 'directives:[';
	  var hasRuntime = false;
	  var i, l, dir, needRuntime;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    dir = dirs[i];
	    needRuntime = true;
	    var gen = state.directives[dir.name];
	    if (gen) {
	      // compile-time directive that manipulates AST.
	      // returns true if it also needs a runtime counterpart.
	      needRuntime = !!gen(el, dir, state.warn);
	    }
	    if (needRuntime) {
	      hasRuntime = true;
	      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
	    }
	  }
	  if (hasRuntime) {
	    return res.slice(0, -1) + ']';
	  }
	}
	
	function genInlineTemplate(el, state) {
	  var ast = el.children[0];
	  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
	    state.warn('Inline-template components must have exactly one child element.');
	  }
	  if (ast.type === 1) {
	    var inlineRenderFns = generate(ast, state.options);
	    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
	      return "function(){" + code + "}";
	    }).join(',') + "]}";
	  }
	}
	
	function genScopedSlots(slots, state) {
	  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
	    return genScopedSlot(key, slots[key], state);
	  }).join(',') + "])";
	}
	
	function genScopedSlot(key, el, state) {
	  if (el.for && !el.forProcessed) {
	    return genForScopedSlot(key, el, state);
	  }
	  return "{key:" + key + ",fn:function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + "}}";
	}
	
	function genForScopedSlot(key, el, state) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	  el.forProcessed = true; // avoid recursion
	  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
	}
	
	function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
	  var children = el.children;
	  if (children.length) {
	    var el$1 = children[0];
	    // optimize single v-for
	    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
	      return (altGenElement || genElement)(el$1, state);
	    }
	    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
	    var gen = altGenNode || genNode;
	    return "[" + children.map(function (c) {
	      return gen(c, state);
	    }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
	  }
	}
	
	// determine the normalization needed for the children array.
	// 0: no normalization needed
	// 1: simple normalization needed (possible 1-level deep nested array)
	// 2: full normalization needed
	function getNormalizationType(children, maybeComponent) {
	  var res = 0;
	  for (var i = 0; i < children.length; i++) {
	    var el = children[i];
	    if (el.type !== 1) {
	      continue;
	    }
	    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return needsNormalization(c.block);
	    })) {
	      res = 2;
	      break;
	    }
	    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return maybeComponent(c.block);
	    })) {
	      res = 1;
	    }
	  }
	  return res;
	}
	
	function needsNormalization(el) {
	  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
	}
	
	function genNode(node, state) {
	  if (node.type === 1) {
	    return genElement(node, state);
	  }if (node.type === 3 && node.isComment) {
	    return genComment(node);
	  } else {
	    return genText(node);
	  }
	}
	
	function genText(text) {
	  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
	  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
	}
	
	function genComment(comment) {
	  return "_e(" + JSON.stringify(comment.text) + ")";
	}
	
	function genSlot(el, state) {
	  var slotName = el.slotName || '"default"';
	  var children = genChildren(el, state);
	  var res = "_t(" + slotName + (children ? "," + children : '');
	  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
	    return camelize(a.name) + ":" + a.value;
	  }).join(',') + "}";
	  var bind$$1 = el.attrsMap['v-bind'];
	  if ((attrs || bind$$1) && !children) {
	    res += ",null";
	  }
	  if (attrs) {
	    res += "," + attrs;
	  }
	  if (bind$$1) {
	    res += (attrs ? '' : ',null') + "," + bind$$1;
	  }
	  return res + ')';
	}
	
	// componentName is el.component, take it as argument to shun flow's pessimistic refinement
	function genComponent(componentName, el, state) {
	  var children = el.inlineTemplate ? null : genChildren(el, state, true);
	  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
	}
	
	function genProps(props) {
	  var res = '';
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
	  }
	  return res.slice(0, -1);
	}
	
	// #3895, #4268
	function transformSpecialNewlines(text) {
	  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
	}
	
	/*  */
	
	// these keywords should not appear inside expressions, but operators like
	// typeof, instanceof and in are allowed
	var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');
	
	// these unary operators should not be used as property/method names
	var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');
	
	// check valid identifier for v-for
	var identRE = /[A-Za-z_$][\w$]*/;
	
	// strip strings in expressions
	var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
	
	// detect problematic expressions in a template
	function detectErrors(ast) {
	  var errors = [];
	  if (ast) {
	    checkNode(ast, errors);
	  }
	  return errors;
	}
	
	function checkNode(node, errors) {
	  if (node.type === 1) {
	    for (var name in node.attrsMap) {
	      if (dirRE.test(name)) {
	        var value = node.attrsMap[name];
	        if (value) {
	          if (name === 'v-for') {
	            checkFor(node, "v-for=\"" + value + "\"", errors);
	          } else if (onRE.test(name)) {
	            checkEvent(value, name + "=\"" + value + "\"", errors);
	          } else {
	            checkExpression(value, name + "=\"" + value + "\"", errors);
	          }
	        }
	      }
	    }
	    if (node.children) {
	      for (var i = 0; i < node.children.length; i++) {
	        checkNode(node.children[i], errors);
	      }
	    }
	  } else if (node.type === 2) {
	    checkExpression(node.expression, node.text, errors);
	  }
	}
	
	function checkEvent(exp, text, errors) {
	  var stipped = exp.replace(stripStringRE, '');
	  var keywordMatch = stipped.match(unaryOperatorsRE);
	  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
	    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	  }
	  checkExpression(exp, text, errors);
	}
	
	function checkFor(node, text, errors) {
	  checkExpression(node.for || '', text, errors);
	  checkIdentifier(node.alias, 'v-for alias', text, errors);
	  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
	  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
	}
	
	function checkIdentifier(ident, type, text, errors) {
	  if (typeof ident === 'string' && !identRE.test(ident)) {
	    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
	  }
	}
	
	function checkExpression(exp, text, errors) {
	  try {
	    new Function("return " + exp);
	  } catch (e) {
	    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
	    if (keywordMatch) {
	      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	    } else {
	      errors.push("invalid expression: " + text.trim());
	    }
	  }
	}
	
	/*  */
	
	function createFunction(code, errors) {
	  try {
	    return new Function(code);
	  } catch (err) {
	    errors.push({ err: err, code: code });
	    return noop;
	  }
	}
	
	function createCompileToFunctionFn(compile) {
	  var cache = Object.create(null);
	
	  return function compileToFunctions(template, options, vm) {
	    options = options || {};
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      // detect possible CSP restriction
	      try {
	        new Function('return 1');
	      } catch (e) {
	        if (e.toString().match(/unsafe-eval|CSP/)) {
	          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
	        }
	      }
	    }
	
	    // check cache
	    var key = options.delimiters ? String(options.delimiters) + template : template;
	    if (cache[key]) {
	      return cache[key];
	    }
	
	    // compile
	    var compiled = compile(template, options);
	
	    // check compilation errors/tips
	    if (process.env.NODE_ENV !== 'production') {
	      if (compiled.errors && compiled.errors.length) {
	        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
	          return "- " + e;
	        }).join('\n') + '\n', vm);
	      }
	      if (compiled.tips && compiled.tips.length) {
	        compiled.tips.forEach(function (msg) {
	          return tip(msg, vm);
	        });
	      }
	    }
	
	    // turn code into functions
	    var res = {};
	    var fnGenErrors = [];
	    res.render = createFunction(compiled.render, fnGenErrors);
	    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
	      return createFunction(code, fnGenErrors);
	    });
	
	    // check function generation errors.
	    // this should only happen if there is a bug in the compiler itself.
	    // mostly for codegen development use
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
	        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
	          var err = ref.err;
	          var code = ref.code;
	
	          return err.toString() + " in\n\n" + code + "\n";
	        }).join('\n'), vm);
	      }
	    }
	
	    return cache[key] = res;
	  };
	}
	
	/*  */
	
	function createCompilerCreator(baseCompile) {
	  return function createCompiler(baseOptions) {
	    function compile(template, options) {
	      var finalOptions = Object.create(baseOptions);
	      var errors = [];
	      var tips = [];
	      finalOptions.warn = function (msg, tip) {
	        (tip ? tips : errors).push(msg);
	      };
	
	      if (options) {
	        // merge custom modules
	        if (options.modules) {
	          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
	        }
	        // merge custom directives
	        if (options.directives) {
	          finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
	        }
	        // copy other options
	        for (var key in options) {
	          if (key !== 'modules' && key !== 'directives') {
	            finalOptions[key] = options[key];
	          }
	        }
	      }
	
	      var compiled = baseCompile(template, finalOptions);
	      if (process.env.NODE_ENV !== 'production') {
	        errors.push.apply(errors, detectErrors(compiled.ast));
	      }
	      compiled.errors = errors;
	      compiled.tips = tips;
	      return compiled;
	    }
	
	    return {
	      compile: compile,
	      compileToFunctions: createCompileToFunctionFn(compile)
	    };
	  };
	}
	
	/*  */
	
	// `createCompilerCreator` allows creating compilers that use alternative
	// parser/optimizer/codegen, e.g the SSR optimizing compiler.
	// Here we just export a default compiler using the default parts.
	var createCompiler = createCompilerCreator(function baseCompile(template, options) {
	  var ast = parse(template.trim(), options);
	  optimize(ast, options);
	  var code = generate(ast, options);
	  return {
	    ast: ast,
	    render: code.render,
	    staticRenderFns: code.staticRenderFns
	  };
	});
	
	/*  */
	
	var ref$1 = createCompiler(baseOptions);
	var compileToFunctions = ref$1.compileToFunctions;
	
	/*  */
	
	var idToTemplate = cached(function (id) {
	  var el = query(id);
	  return el && el.innerHTML;
	});
	
	var mount = Vue$3.prototype.$mount;
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && query(el);
	
	  /* istanbul ignore if */
	  if (el === document.body || el === document.documentElement) {
	    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
	    return this;
	  }
	
	  var options = this.$options;
	  // resolve template/el and convert to render function
	  if (!options.render) {
	    var template = options.template;
	    if (template) {
	      if (typeof template === 'string') {
	        if (template.charAt(0) === '#') {
	          template = idToTemplate(template);
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !template) {
	            warn("Template element not found or is empty: " + options.template, this);
	          }
	        }
	      } else if (template.nodeType) {
	        template = template.innerHTML;
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          warn('invalid template option:' + template, this);
	        }
	        return this;
	      }
	    } else if (el) {
	      template = getOuterHTML(el);
	    }
	    if (template) {
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile');
	      }
	
	      var ref = compileToFunctions(template, {
	        shouldDecodeNewlines: shouldDecodeNewlines,
	        delimiters: options.delimiters,
	        comments: options.comments
	      }, this);
	      var render = ref.render;
	      var staticRenderFns = ref.staticRenderFns;
	      options.render = render;
	      options.staticRenderFns = staticRenderFns;
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile end');
	        measure(this._name + " compile", 'compile', 'compile end');
	      }
	    }
	  }
	  return mount.call(this, el, hydrating);
	};
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 */
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	Vue$3.compile = compileToFunctions;
	
	exports.default = Vue$3;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) {
	    return [];
	};
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, module) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
	 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	
	(function (definition) {
	    "use strict";
	
	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.
	
	    // Montage Require
	
	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);
	
	        // CommonJS
	    } else if (( false ? "undefined" : _typeof(exports)) === "object" && ( false ? "undefined" : _typeof(module)) === "object") {
	        module.exports = definition();
	
	        // RequireJS
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	        // SES (Secure EcmaScript)
	    } else if (typeof ses !== "undefined") {
	        if (!ses.ok()) {
	            return;
	        } else {
	            ses.makeQ = definition;
	        }
	
	        // <script>
	    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
	        // Prefer window over self for add-on scripts. Use self for
	        // non-windowed contexts.
	        var global = typeof window !== "undefined" ? window : self;
	
	        // Get the `window` object, save the previous Q global
	        // and initialize Q as a global.
	        var previousQ = global.Q;
	        global.Q = definition();
	
	        // Add a noConflict function so Q can be removed from the
	        // global namespace.
	        global.Q.noConflict = function () {
	            global.Q = previousQ;
	            return this;
	        };
	    } else {
	        throw new Error("This environment was not anticipated by Q. Please file a bug.");
	    }
	})(function () {
	    "use strict";
	
	    var hasStacks = false;
	    try {
	        throw new Error();
	    } catch (e) {
	        hasStacks = !!e.stack;
	    }
	
	    // All code after this point will be filtered from stack traces reported
	    // by Q.
	    var qStartingLine = captureLine();
	    var qFileName;
	
	    // shims
	
	    // used for fallback in "allResolved"
	    var noop = function noop() {};
	
	    // Use the fastest possible means to execute a task in a future turn
	    // of the event loop.
	    var nextTick = function () {
	        // linked list of tasks (single, with head node)
	        var head = { task: void 0, next: null };
	        var tail = head;
	        var flushing = false;
	        var requestTick = void 0;
	        var isNodeJS = false;
	        // queue for late tasks, used by unhandled rejection tracking
	        var laterQueue = [];
	
	        function flush() {
	            /* jshint loopfunc: true */
	            var task, domain;
	
	            while (head.next) {
	                head = head.next;
	                task = head.task;
	                head.task = void 0;
	                domain = head.domain;
	
	                if (domain) {
	                    head.domain = void 0;
	                    domain.enter();
	                }
	                runSingle(task, domain);
	            }
	            while (laterQueue.length) {
	                task = laterQueue.pop();
	                runSingle(task);
	            }
	            flushing = false;
	        }
	        // runs a single function in the async queue
	        function runSingle(task, domain) {
	            try {
	                task();
	            } catch (e) {
	                if (isNodeJS) {
	                    // In node, uncaught exceptions are considered fatal errors.
	                    // Re-throw them synchronously to interrupt flushing!
	
	                    // Ensure continuation if the uncaught exception is suppressed
	                    // listening "uncaughtException" events (as domains does).
	                    // Continue in next event to avoid tick recursion.
	                    if (domain) {
	                        domain.exit();
	                    }
	                    setTimeout(flush, 0);
	                    if (domain) {
	                        domain.enter();
	                    }
	
	                    throw e;
	                } else {
	                    // In browsers, uncaught exceptions are not fatal.
	                    // Re-throw them asynchronously to avoid slow-downs.
	                    setTimeout(function () {
	                        throw e;
	                    }, 0);
	                }
	            }
	
	            if (domain) {
	                domain.exit();
	            }
	        }
	
	        nextTick = function nextTick(task) {
	            tail = tail.next = {
	                task: task,
	                domain: isNodeJS && process.domain,
	                next: null
	            };
	
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.toString() === "[object process]" && process.nextTick) {
	            // Ensure Q is in a real Node environment, with a `process.nextTick`.
	            // To see through fake Node environments:
	            // * Mocha test runner - exposes a `process` global without a `nextTick`
	            // * Browserify - exposes a `process.nexTick` function that uses
	            //   `setTimeout`. In this case `setImmediate` is preferred because
	            //    it is faster. Browserify's `process.toString()` yields
	            //   "[object Object]", while in a real Node environment
	            //   `process.toString()` yields "[object process]".
	            isNodeJS = true;
	
	            requestTick = function requestTick() {
	                process.nextTick(flush);
	            };
	        } else if (typeof setImmediate === "function") {
	            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	            if (typeof window !== "undefined") {
	                requestTick = setImmediate.bind(window, flush);
	            } else {
	                requestTick = function requestTick() {
	                    setImmediate(flush);
	                };
	            }
	        } else if (typeof MessageChannel !== "undefined") {
	            // modern browsers
	            // http://www.nonblocking.io/2011/06/windownexttick.html
	            var channel = new MessageChannel();
	            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	            // working message ports the first time a page loads.
	            channel.port1.onmessage = function () {
	                requestTick = requestPortTick;
	                channel.port1.onmessage = flush;
	                flush();
	            };
	            var requestPortTick = function requestPortTick() {
	                // Opera requires us to provide a message payload, regardless of
	                // whether we use it.
	                channel.port2.postMessage(0);
	            };
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	                requestPortTick();
	            };
	        } else {
	            // old browsers
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	            };
	        }
	        // runs a task after all other tasks have been run
	        // this is useful for unhandled rejection tracking that needs to happen
	        // after all `then`d tasks have been run.
	        nextTick.runAfter = function (task) {
	            laterQueue.push(task);
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	        return nextTick;
	    }();
	
	    // Attempt to make generics safe in the face of downstream
	    // modifications.
	    // There is no situation where this is necessary.
	    // If you need a security guarantee, these primordials need to be
	    // deeply frozen anyway, and if you don’t need a security guarantee,
	    // this is just plain paranoid.
	    // However, this **might** have the nice side-effect of reducing the size of
	    // the minified code by reducing x.call() to merely x()
	    // See Mark Miller’s explanation of what this does.
	    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	    var call = Function.call;
	    function uncurryThis(f) {
	        return function () {
	            return call.apply(f, arguments);
	        };
	    }
	    // This is equivalent, but slower:
	    // uncurryThis = Function_bind.bind(Function_bind.call);
	    // http://jsperf.com/uncurrythis
	
	    var array_slice = uncurryThis(Array.prototype.slice);
	
	    var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    });
	
	    var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    });
	
	    var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    });
	
	    var object_create = Object.create || function (prototype) {
	        function Type() {}
	        Type.prototype = prototype;
	        return new Type();
	    };
	
	    var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
	        obj[prop] = descriptor.value;
	        return obj;
	    };
	
	    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
	
	    var object_keys = Object.keys || function (object) {
	        var keys = [];
	        for (var key in object) {
	            if (object_hasOwnProperty(object, key)) {
	                keys.push(key);
	            }
	        }
	        return keys;
	    };
	
	    var object_toString = uncurryThis(Object.prototype.toString);
	
	    function isObject(value) {
	        return value === Object(value);
	    }
	
	    // generator related shims
	
	    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	    function isStopIteration(exception) {
	        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
	    }
	
	    // FIXME: Remove this helper and Q.return once ES6 generators are in
	    // SpiderMonkey.
	    var QReturnValue;
	    if (typeof ReturnValue !== "undefined") {
	        QReturnValue = ReturnValue;
	    } else {
	        QReturnValue = function QReturnValue(value) {
	            this.value = value;
	        };
	    }
	
	    // long stack traces
	
	    var STACK_JUMP_SEPARATOR = "From previous event:";
	
	    function makeStackTraceLong(error, promise) {
	        // If possible, transform the error stack trace by removing Node and Q
	        // cruft, then concatenating with the stack trace of `promise`. See #57.
	        if (hasStacks && promise.stack && (typeof error === "undefined" ? "undefined" : _typeof(error)) === "object" && error !== null && error.stack) {
	            var stacks = [];
	            for (var p = promise; !!p; p = p.source) {
	                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
	                    object_defineProperty(error, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
	                    stacks.unshift(p.stack);
	                }
	            }
	            stacks.unshift(error.stack);
	
	            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	            var stack = filterStackString(concatedStacks);
	            object_defineProperty(error, "stack", { value: stack, configurable: true });
	        }
	    }
	
	    function filterStackString(stackString) {
	        var lines = stackString.split("\n");
	        var desiredLines = [];
	        for (var i = 0; i < lines.length; ++i) {
	            var line = lines[i];
	
	            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	                desiredLines.push(line);
	            }
	        }
	        return desiredLines.join("\n");
	    }
	
	    function isNodeFrame(stackLine) {
	        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
	    }
	
	    function getFileNameAndLineNumber(stackLine) {
	        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	        // In IE10 function name can have spaces ("Anonymous function") O_o
	        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	        if (attempt1) {
	            return [attempt1[1], Number(attempt1[2])];
	        }
	
	        // Anonymous functions: "at filename:lineNumber:columnNumber"
	        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	        if (attempt2) {
	            return [attempt2[1], Number(attempt2[2])];
	        }
	
	        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	        if (attempt3) {
	            return [attempt3[1], Number(attempt3[2])];
	        }
	    }
	
	    function isInternalFrame(stackLine) {
	        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
	
	        if (!fileNameAndLineNumber) {
	            return false;
	        }
	
	        var fileName = fileNameAndLineNumber[0];
	        var lineNumber = fileNameAndLineNumber[1];
	
	        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
	    }
	
	    // discover own file name and line number range for filtering stack
	    // traces
	    function captureLine() {
	        if (!hasStacks) {
	            return;
	        }
	
	        try {
	            throw new Error();
	        } catch (e) {
	            var lines = e.stack.split("\n");
	            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	            if (!fileNameAndLineNumber) {
	                return;
	            }
	
	            qFileName = fileNameAndLineNumber[0];
	            return fileNameAndLineNumber[1];
	        }
	    }
	
	    function deprecate(callback, name, alternative) {
	        return function () {
	            if (typeof console !== "undefined" && typeof console.warn === "function") {
	                console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
	            }
	            return callback.apply(callback, arguments);
	        };
	    }
	
	    // end of shims
	    // beginning of real work
	
	    /**
	     * Constructs a promise for an immediate reference, passes promises through, or
	     * coerces promises from different systems.
	     * @param value immediate reference or promise
	     */
	    function Q(value) {
	        // If the object is already a Promise, return it directly.  This enables
	        // the resolve function to both be used to created references from objects,
	        // but to tolerably coerce non-promises to promises.
	        if (value instanceof Promise) {
	            return value;
	        }
	
	        // assimilate thenables
	        if (isPromiseAlike(value)) {
	            return coerce(value);
	        } else {
	            return fulfill(value);
	        }
	    }
	    Q.resolve = Q;
	
	    /**
	     * Performs a task in a future turn of the event loop.
	     * @param {Function} task
	     */
	    Q.nextTick = nextTick;
	
	    /**
	     * Controls whether or not long stack traces will be on
	     */
	    Q.longStackSupport = false;
	
	    /**
	     * The counter is used to determine the stopping point for building
	     * long stack traces. In makeStackTraceLong we walk backwards through
	     * the linked list of promises, only stacks which were created before
	     * the rejection are concatenated.
	     */
	    var longStackCounter = 1;
	
	    // enable long stacks if Q_DEBUG is set
	    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.env && process.env.Q_DEBUG) {
	        Q.longStackSupport = true;
	    }
	
	    /**
	     * Constructs a {promise, resolve, reject} object.
	     *
	     * `resolve` is a callback to invoke with a more resolved value for the
	     * promise. To fulfill the promise, invoke `resolve` with any value that is
	     * not a thenable. To reject the promise, invoke `resolve` with a rejected
	     * thenable, or invoke `reject` with the reason directly. To resolve the
	     * promise to another thenable, thus putting it in the same state, invoke
	     * `resolve` with that other thenable.
	     */
	    Q.defer = defer;
	    function defer() {
	        // if "messages" is an "Array", that indicates that the promise has not yet
	        // been resolved.  If it is "undefined", it has been resolved.  Each
	        // element of the messages array is itself an array of complete arguments to
	        // forward to the resolved promise.  We coerce the resolution value to a
	        // promise using the `resolve` function because it handles both fully
	        // non-thenable values and other thenables gracefully.
	        var messages = [],
	            progressListeners = [],
	            resolvedPromise;
	
	        var deferred = object_create(defer.prototype);
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, operands) {
	            var args = array_slice(arguments);
	            if (messages) {
	                messages.push(args);
	                if (op === "when" && operands[1]) {
	                    // progress operand
	                    progressListeners.push(operands[1]);
	                }
	            } else {
	                Q.nextTick(function () {
	                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	                });
	            }
	        };
	
	        // XXX deprecated
	        promise.valueOf = function () {
	            if (messages) {
	                return promise;
	            }
	            var nearerValue = nearer(resolvedPromise);
	            if (isPromise(nearerValue)) {
	                resolvedPromise = nearerValue; // shorten chain
	            }
	            return nearerValue;
	        };
	
	        promise.inspect = function () {
	            if (!resolvedPromise) {
	                return { state: "pending" };
	            }
	            return resolvedPromise.inspect();
	        };
	
	        if (Q.longStackSupport && hasStacks) {
	            try {
	                throw new Error();
	            } catch (e) {
	                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	                // accessor around; that causes memory leaks as per GH-111. Just
	                // reify the stack trace as a string ASAP.
	                //
	                // At the same time, cut off the first line; it's always just
	                // "[object Promise]\n", as per the `toString`.
	                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	                promise.stackCounter = longStackCounter++;
	            }
	        }
	
	        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	        // consolidating them into `become`, since otherwise we'd create new
	        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
	
	        function become(newPromise) {
	            resolvedPromise = newPromise;
	
	            if (Q.longStackSupport && hasStacks) {
	                // Only hold a reference to the new promise if long stacks
	                // are enabled to reduce memory usage
	                promise.source = newPromise;
	            }
	
	            array_reduce(messages, function (undefined, message) {
	                Q.nextTick(function () {
	                    newPromise.promiseDispatch.apply(newPromise, message);
	                });
	            }, void 0);
	
	            messages = void 0;
	            progressListeners = void 0;
	        }
	
	        deferred.promise = promise;
	        deferred.resolve = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(Q(value));
	        };
	
	        deferred.fulfill = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(fulfill(value));
	        };
	        deferred.reject = function (reason) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(reject(reason));
	        };
	        deferred.notify = function (progress) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            array_reduce(progressListeners, function (undefined, progressListener) {
	                Q.nextTick(function () {
	                    progressListener(progress);
	                });
	            }, void 0);
	        };
	
	        return deferred;
	    }
	
	    /**
	     * Creates a Node-style callback that will resolve or reject the deferred
	     * promise.
	     * @returns a nodeback
	     */
	    defer.prototype.makeNodeResolver = function () {
	        var self = this;
	        return function (error, value) {
	            if (error) {
	                self.reject(error);
	            } else if (arguments.length > 2) {
	                self.resolve(array_slice(arguments, 1));
	            } else {
	                self.resolve(value);
	            }
	        };
	    };
	
	    /**
	     * @param resolver {Function} a function that returns nothing and accepts
	     * the resolve, reject, and notify functions for a deferred.
	     * @returns a promise that may be resolved with the given resolve and reject
	     * functions, or rejected by a thrown exception in resolver
	     */
	    Q.Promise = promise; // ES6
	    Q.promise = promise;
	    function promise(resolver) {
	        if (typeof resolver !== "function") {
	            throw new TypeError("resolver must be a function.");
	        }
	        var deferred = defer();
	        try {
	            resolver(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (reason) {
	            deferred.reject(reason);
	        }
	        return deferred.promise;
	    }
	
	    promise.race = race; // ES6
	    promise.all = all; // ES6
	    promise.reject = reject; // ES6
	    promise.resolve = Q; // ES6
	
	    // XXX experimental.  This method is a way to denote that a local value is
	    // serializable and should be immediately dispatched to a remote upon request,
	    // instead of passing a reference.
	    Q.passByCopy = function (object) {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return object;
	    };
	
	    Promise.prototype.passByCopy = function () {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return this;
	    };
	
	    /**
	     * If two promises eventually fulfill to the same value, promises that value,
	     * but otherwise rejects.
	     * @param x {Any*}
	     * @param y {Any*}
	     * @returns {Any*} a promise for x and y if they are the same, but a rejection
	     * otherwise.
	     *
	     */
	    Q.join = function (x, y) {
	        return Q(x).join(y);
	    };
	
	    Promise.prototype.join = function (that) {
	        return Q([this, that]).spread(function (x, y) {
	            if (x === y) {
	                // TODO: "===" should be Object.is or equiv
	                return x;
	            } else {
	                throw new Error("Q can't join: not the same: " + x + " " + y);
	            }
	        });
	    };
	
	    /**
	     * Returns a promise for the first of an array of promises to become settled.
	     * @param answers {Array[Any*]} promises to race
	     * @returns {Any*} the first promise to be settled
	     */
	    Q.race = race;
	    function race(answerPs) {
	        return promise(function (resolve, reject) {
	            // Switch to this once we can assume at least ES5
	            // answerPs.forEach(function (answerP) {
	            //     Q(answerP).then(resolve, reject);
	            // });
	            // Use this in the meantime
	            for (var i = 0, len = answerPs.length; i < len; i++) {
	                Q(answerPs[i]).then(resolve, reject);
	            }
	        });
	    }
	
	    Promise.prototype.race = function () {
	        return this.then(Q.race);
	    };
	
	    /**
	     * Constructs a Promise with a promise descriptor object and optional fallback
	     * function.  The descriptor contains methods like when(rejected), get(name),
	     * set(name, value), post(name, args), and delete(name), which all
	     * return either a value, a promise for a value, or a rejection.  The fallback
	     * accepts the operation name, a resolver, and any further arguments that would
	     * have been forwarded to the appropriate method above had a method been
	     * provided with the proper name.  The API makes no guarantees about the nature
	     * of the returned object, apart from that it is usable whereever promises are
	     * bought and sold.
	     */
	    Q.makePromise = Promise;
	    function Promise(descriptor, fallback, inspect) {
	        if (fallback === void 0) {
	            fallback = function fallback(op) {
	                return reject(new Error("Promise does not support operation: " + op));
	            };
	        }
	        if (inspect === void 0) {
	            inspect = function inspect() {
	                return { state: "unknown" };
	            };
	        }
	
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, args) {
	            var result;
	            try {
	                if (descriptor[op]) {
	                    result = descriptor[op].apply(promise, args);
	                } else {
	                    result = fallback.call(promise, op, args);
	                }
	            } catch (exception) {
	                result = reject(exception);
	            }
	            if (resolve) {
	                resolve(result);
	            }
	        };
	
	        promise.inspect = inspect;
	
	        // XXX deprecated `valueOf` and `exception` support
	        if (inspect) {
	            var inspected = inspect();
	            if (inspected.state === "rejected") {
	                promise.exception = inspected.reason;
	            }
	
	            promise.valueOf = function () {
	                var inspected = inspect();
	                if (inspected.state === "pending" || inspected.state === "rejected") {
	                    return promise;
	                }
	                return inspected.value;
	            };
	        }
	
	        return promise;
	    }
	
	    Promise.prototype.toString = function () {
	        return "[object Promise]";
	    };
	
	    Promise.prototype.then = function (fulfilled, rejected, progressed) {
	        var self = this;
	        var deferred = defer();
	        var done = false; // ensure the untrusted promise makes at most a
	        // single call to one of the callbacks
	
	        function _fulfilled(value) {
	            try {
	                return typeof fulfilled === "function" ? fulfilled(value) : value;
	            } catch (exception) {
	                return reject(exception);
	            }
	        }
	
	        function _rejected(exception) {
	            if (typeof rejected === "function") {
	                makeStackTraceLong(exception, self);
	                try {
	                    return rejected(exception);
	                } catch (newException) {
	                    return reject(newException);
	                }
	            }
	            return reject(exception);
	        }
	
	        function _progressed(value) {
	            return typeof progressed === "function" ? progressed(value) : value;
	        }
	
	        Q.nextTick(function () {
	            self.promiseDispatch(function (value) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_fulfilled(value));
	            }, "when", [function (exception) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_rejected(exception));
	            }]);
	        });
	
	        // Progress propagator need to be attached in the current tick.
	        self.promiseDispatch(void 0, "when", [void 0, function (value) {
	            var newValue;
	            var threw = false;
	            try {
	                newValue = _progressed(value);
	            } catch (e) {
	                threw = true;
	                if (Q.onerror) {
	                    Q.onerror(e);
	                } else {
	                    throw e;
	                }
	            }
	
	            if (!threw) {
	                deferred.notify(newValue);
	            }
	        }]);
	
	        return deferred.promise;
	    };
	
	    Q.tap = function (promise, callback) {
	        return Q(promise).tap(callback);
	    };
	
	    /**
	     * Works almost like "finally", but not called for rejections.
	     * Original resolution value is passed through callback unaffected.
	     * Callback may return a promise that will be awaited for.
	     * @param {Function} callback
	     * @returns {Q.Promise}
	     * @example
	     * doSomething()
	     *   .then(...)
	     *   .tap(console.log)
	     *   .then(...);
	     */
	    Promise.prototype.tap = function (callback) {
	        callback = Q(callback);
	
	        return this.then(function (value) {
	            return callback.fcall(value).thenResolve(value);
	        });
	    };
	
	    /**
	     * Registers an observer on a promise.
	     *
	     * Guarantees:
	     *
	     * 1. that fulfilled and rejected will be called only once.
	     * 2. that either the fulfilled callback or the rejected callback will be
	     *    called, but not both.
	     * 3. that fulfilled and rejected will not be called in this turn.
	     *
	     * @param value      promise or immediate reference to observe
	     * @param fulfilled  function to be called with the fulfilled value
	     * @param rejected   function to be called with the rejection exception
	     * @param progressed function to be called on any progress notifications
	     * @return promise for the return value from the invoked callback
	     */
	    Q.when = when;
	    function when(value, fulfilled, rejected, progressed) {
	        return Q(value).then(fulfilled, rejected, progressed);
	    }
	
	    Promise.prototype.thenResolve = function (value) {
	        return this.then(function () {
	            return value;
	        });
	    };
	
	    Q.thenResolve = function (promise, value) {
	        return Q(promise).thenResolve(value);
	    };
	
	    Promise.prototype.thenReject = function (reason) {
	        return this.then(function () {
	            throw reason;
	        });
	    };
	
	    Q.thenReject = function (promise, reason) {
	        return Q(promise).thenReject(reason);
	    };
	
	    /**
	     * If an object is not a promise, it is as "near" as possible.
	     * If a promise is rejected, it is as "near" as possible too.
	     * If it’s a fulfilled promise, the fulfillment value is nearer.
	     * If it’s a deferred promise and the deferred has been resolved, the
	     * resolution is "nearer".
	     * @param object
	     * @returns most resolved (nearest) form of the object
	     */
	
	    // XXX should we re-do this?
	    Q.nearer = nearer;
	    function nearer(value) {
	        if (isPromise(value)) {
	            var inspected = value.inspect();
	            if (inspected.state === "fulfilled") {
	                return inspected.value;
	            }
	        }
	        return value;
	    }
	
	    /**
	     * @returns whether the given object is a promise.
	     * Otherwise it is a fulfilled value.
	     */
	    Q.isPromise = isPromise;
	    function isPromise(object) {
	        return object instanceof Promise;
	    }
	
	    Q.isPromiseAlike = isPromiseAlike;
	    function isPromiseAlike(object) {
	        return isObject(object) && typeof object.then === "function";
	    }
	
	    /**
	     * @returns whether the given object is a pending promise, meaning not
	     * fulfilled or rejected.
	     */
	    Q.isPending = isPending;
	    function isPending(object) {
	        return isPromise(object) && object.inspect().state === "pending";
	    }
	
	    Promise.prototype.isPending = function () {
	        return this.inspect().state === "pending";
	    };
	
	    /**
	     * @returns whether the given object is a value or fulfilled
	     * promise.
	     */
	    Q.isFulfilled = isFulfilled;
	    function isFulfilled(object) {
	        return !isPromise(object) || object.inspect().state === "fulfilled";
	    }
	
	    Promise.prototype.isFulfilled = function () {
	        return this.inspect().state === "fulfilled";
	    };
	
	    /**
	     * @returns whether the given object is a rejected promise.
	     */
	    Q.isRejected = isRejected;
	    function isRejected(object) {
	        return isPromise(object) && object.inspect().state === "rejected";
	    }
	
	    Promise.prototype.isRejected = function () {
	        return this.inspect().state === "rejected";
	    };
	
	    //// BEGIN UNHANDLED REJECTION TRACKING
	
	    // This promise library consumes exceptions thrown in handlers so they can be
	    // handled by a subsequent promise.  The exceptions get added to this array when
	    // they are created, and removed when they are handled.  Note that in ES6 or
	    // shimmed environments, this would naturally be a `Set`.
	    var unhandledReasons = [];
	    var unhandledRejections = [];
	    var reportedUnhandledRejections = [];
	    var trackUnhandledRejections = true;
	
	    function resetUnhandledRejections() {
	        unhandledReasons.length = 0;
	        unhandledRejections.length = 0;
	
	        if (!trackUnhandledRejections) {
	            trackUnhandledRejections = true;
	        }
	    }
	
	    function trackRejection(promise, reason) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	            Q.nextTick.runAfter(function () {
	                if (array_indexOf(unhandledRejections, promise) !== -1) {
	                    process.emit("unhandledRejection", reason, promise);
	                    reportedUnhandledRejections.push(promise);
	                }
	            });
	        }
	
	        unhandledRejections.push(promise);
	        if (reason && typeof reason.stack !== "undefined") {
	            unhandledReasons.push(reason.stack);
	        } else {
	            unhandledReasons.push("(no stack) " + reason);
	        }
	    }
	
	    function untrackRejection(promise) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	
	        var at = array_indexOf(unhandledRejections, promise);
	        if (at !== -1) {
	            if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	                Q.nextTick.runAfter(function () {
	                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
	                    if (atReport !== -1) {
	                        process.emit("rejectionHandled", unhandledReasons[at], promise);
	                        reportedUnhandledRejections.splice(atReport, 1);
	                    }
	                });
	            }
	            unhandledRejections.splice(at, 1);
	            unhandledReasons.splice(at, 1);
	        }
	    }
	
	    Q.resetUnhandledRejections = resetUnhandledRejections;
	
	    Q.getUnhandledReasons = function () {
	        // Make a copy so that consumers can't interfere with our internal state.
	        return unhandledReasons.slice();
	    };
	
	    Q.stopUnhandledRejectionTracking = function () {
	        resetUnhandledRejections();
	        trackUnhandledRejections = false;
	    };
	
	    resetUnhandledRejections();
	
	    //// END UNHANDLED REJECTION TRACKING
	
	    /**
	     * Constructs a rejected promise.
	     * @param reason value describing the failure
	     */
	    Q.reject = reject;
	    function reject(reason) {
	        var rejection = Promise({
	            "when": function when(rejected) {
	                // note that the error has been handled
	                if (rejected) {
	                    untrackRejection(this);
	                }
	                return rejected ? rejected(reason) : this;
	            }
	        }, function fallback() {
	            return this;
	        }, function inspect() {
	            return { state: "rejected", reason: reason };
	        });
	
	        // Note that the reason has not been handled.
	        trackRejection(rejection, reason);
	
	        return rejection;
	    }
	
	    /**
	     * Constructs a fulfilled promise for an immediate reference.
	     * @param value immediate reference
	     */
	    Q.fulfill = fulfill;
	    function fulfill(value) {
	        return Promise({
	            "when": function when() {
	                return value;
	            },
	            "get": function get(name) {
	                return value[name];
	            },
	            "set": function set(name, rhs) {
	                value[name] = rhs;
	            },
	            "delete": function _delete(name) {
	                delete value[name];
	            },
	            "post": function post(name, args) {
	                // Mark Miller proposes that post with no name should apply a
	                // promised function.
	                if (name === null || name === void 0) {
	                    return value.apply(void 0, args);
	                } else {
	                    return value[name].apply(value, args);
	                }
	            },
	            "apply": function apply(thisp, args) {
	                return value.apply(thisp, args);
	            },
	            "keys": function keys() {
	                return object_keys(value);
	            }
	        }, void 0, function inspect() {
	            return { state: "fulfilled", value: value };
	        });
	    }
	
	    /**
	     * Converts thenables to Q promises.
	     * @param promise thenable promise
	     * @returns a Q promise
	     */
	    function coerce(promise) {
	        var deferred = defer();
	        Q.nextTick(function () {
	            try {
	                promise.then(deferred.resolve, deferred.reject, deferred.notify);
	            } catch (exception) {
	                deferred.reject(exception);
	            }
	        });
	        return deferred.promise;
	    }
	
	    /**
	     * Annotates an object such that it will never be
	     * transferred away from this process over any promise
	     * communication channel.
	     * @param object
	     * @returns promise a wrapping of that object that
	     * additionally responds to the "isDef" message
	     * without a rejection.
	     */
	    Q.master = master;
	    function master(object) {
	        return Promise({
	            "isDef": function isDef() {}
	        }, function fallback(op, args) {
	            return dispatch(object, op, args);
	        }, function () {
	            return Q(object).inspect();
	        });
	    }
	
	    /**
	     * Spreads the values of a promised array of arguments into the
	     * fulfillment callback.
	     * @param fulfilled callback that receives variadic arguments from the
	     * promised array
	     * @param rejected callback that receives the exception if the promise
	     * is rejected.
	     * @returns a promise for the return value or thrown exception of
	     * either callback.
	     */
	    Q.spread = spread;
	    function spread(value, fulfilled, rejected) {
	        return Q(value).spread(fulfilled, rejected);
	    }
	
	    Promise.prototype.spread = function (fulfilled, rejected) {
	        return this.all().then(function (array) {
	            return fulfilled.apply(void 0, array);
	        }, rejected);
	    };
	
	    /**
	     * The async function is a decorator for generator functions, turning
	     * them into asynchronous generators.  Although generators are only part
	     * of the newest ECMAScript 6 drafts, this code does not cause syntax
	     * errors in older engines.  This code should continue to work and will
	     * in fact improve over time as the language improves.
	     *
	     * ES6 generators are currently part of V8 version 3.19 with the
	     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	     * for longer, but under an older Python-inspired form.  This function
	     * works on both kinds of generators.
	     *
	     * Decorates a generator function such that:
	     *  - it may yield promises
	     *  - execution will continue when that promise is fulfilled
	     *  - the value of the yield expression will be the fulfilled value
	     *  - it returns a promise for the return value (when the generator
	     *    stops iterating)
	     *  - the decorated function returns a promise for the return value
	     *    of the generator or the first rejected promise among those
	     *    yielded.
	     *  - if an error is thrown in the generator, it propagates through
	     *    every following yield until it is caught, or until it escapes
	     *    the generator function altogether, and is translated into a
	     *    rejection for the promise returned by the decorated generator.
	     */
	    Q.async = async;
	    function async(makeGenerator) {
	        return function () {
	            // when verb is "send", arg is a value
	            // when verb is "throw", arg is an exception
	            function continuer(verb, arg) {
	                var result;
	
	                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	                // engine that has a deployed base of browsers that support generators.
	                // However, SM's generators use the Python-inspired semantics of
	                // outdated ES6 drafts.  We would like to support ES6, but we'd also
	                // like to make it possible to use generators in deployed browsers, so
	                // we also support Python-style generators.  At some point we can remove
	                // this block.
	
	                if (typeof StopIteration === "undefined") {
	                    // ES6 Generators
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        return reject(exception);
	                    }
	                    if (result.done) {
	                        return Q(result.value);
	                    } else {
	                        return when(result.value, callback, errback);
	                    }
	                } else {
	                    // SpiderMonkey Generators
	                    // FIXME: Remove this case when SM does ES6 generators.
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        if (isStopIteration(exception)) {
	                            return Q(exception.value);
	                        } else {
	                            return reject(exception);
	                        }
	                    }
	                    return when(result, callback, errback);
	                }
	            }
	            var generator = makeGenerator.apply(this, arguments);
	            var callback = continuer.bind(continuer, "next");
	            var errback = continuer.bind(continuer, "throw");
	            return callback();
	        };
	    }
	
	    /**
	     * The spawn function is a small wrapper around async that immediately
	     * calls the generator and also ends the promise chain, so that any
	     * unhandled errors are thrown instead of forwarded to the error
	     * handler. This is useful because it's extremely common to run
	     * generators at the top-level to work with libraries.
	     */
	    Q.spawn = spawn;
	    function spawn(makeGenerator) {
	        Q.done(Q.async(makeGenerator)());
	    }
	
	    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	    /**
	     * Throws a ReturnValue exception to stop an asynchronous generator.
	     *
	     * This interface is a stop-gap measure to support generator return
	     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	     * generators like Chromium 29, just use "return" in your generator
	     * functions.
	     *
	     * @param value the return value for the surrounding generator
	     * @throws ReturnValue exception with the value.
	     * @example
	     * // ES6 style
	     * Q.async(function* () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      return foo + bar;
	     * })
	     * // Older SpiderMonkey style
	     * Q.async(function () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      Q.return(foo + bar);
	     * })
	     */
	    Q["return"] = _return;
	    function _return(value) {
	        throw new QReturnValue(value);
	    }
	
	    /**
	     * The promised function decorator ensures that any promise arguments
	     * are settled and passed as values (`this` is also settled and passed
	     * as a value).  It will also ensure that the result of a function is
	     * always a promise.
	     *
	     * @example
	     * var add = Q.promised(function (a, b) {
	     *     return a + b;
	     * });
	     * add(Q(a), Q(B));
	     *
	     * @param {function} callback The function to decorate
	     * @returns {function} a function that has been decorated.
	     */
	    Q.promised = promised;
	    function promised(callback) {
	        return function () {
	            return spread([this, all(arguments)], function (self, args) {
	                return callback.apply(self, args);
	            });
	        };
	    }
	
	    /**
	     * sends a message to a value in a future turn
	     * @param object* the recipient
	     * @param op the name of the message operation, e.g., "when",
	     * @param args further arguments to be forwarded to the operation
	     * @returns result {Promise} a promise for the result of the operation
	     */
	    Q.dispatch = dispatch;
	    function dispatch(object, op, args) {
	        return Q(object).dispatch(op, args);
	    }
	
	    Promise.prototype.dispatch = function (op, args) {
	        var self = this;
	        var deferred = defer();
	        Q.nextTick(function () {
	            self.promiseDispatch(deferred.resolve, op, args);
	        });
	        return deferred.promise;
	    };
	
	    /**
	     * Gets the value of a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to get
	     * @return promise for the property value
	     */
	    Q.get = function (object, key) {
	        return Q(object).dispatch("get", [key]);
	    };
	
	    Promise.prototype.get = function (key) {
	        return this.dispatch("get", [key]);
	    };
	
	    /**
	     * Sets the value of a property in a future turn.
	     * @param object    promise or immediate reference for object object
	     * @param name      name of property to set
	     * @param value     new value of property
	     * @return promise for the return value
	     */
	    Q.set = function (object, key, value) {
	        return Q(object).dispatch("set", [key, value]);
	    };
	
	    Promise.prototype.set = function (key, value) {
	        return this.dispatch("set", [key, value]);
	    };
	
	    /**
	     * Deletes a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to delete
	     * @return promise for the return value
	     */
	    Q.del = // XXX legacy
	    Q["delete"] = function (object, key) {
	        return Q(object).dispatch("delete", [key]);
	    };
	
	    Promise.prototype.del = // XXX legacy
	    Promise.prototype["delete"] = function (key) {
	        return this.dispatch("delete", [key]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param value     a value to post, typically an array of
	     *                  invocation arguments for promises that
	     *                  are ultimately backed with `resolve` values,
	     *                  as opposed to those backed with URLs
	     *                  wherein the posted value can be any
	     *                  JSON serializable object.
	     * @return promise for the return value
	     */
	    // bound locally because it is used by other methods
	    Q.mapply = // XXX As proposed by "Redsandro"
	    Q.post = function (object, name, args) {
	        return Q(object).dispatch("post", [name, args]);
	    };
	
	    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.post = function (name, args) {
	        return this.dispatch("post", [name, args]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param ...args   array of invocation arguments
	     * @return promise for the return value
	     */
	    Q.send = // XXX Mark Miller's proposed parlance
	    Q.mcall = // XXX As proposed by "Redsandro"
	    Q.invoke = function (object, name /*...args*/) {
	        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	    };
	
	    Promise.prototype.send = // XXX Mark Miller's proposed parlance
	    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	    Promise.prototype.invoke = function (name /*...args*/) {
	        return this.dispatch("post", [name, array_slice(arguments, 1)]);
	    };
	
	    /**
	     * Applies the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param args      array of application arguments
	     */
	    Q.fapply = function (object, args) {
	        return Q(object).dispatch("apply", [void 0, args]);
	    };
	
	    Promise.prototype.fapply = function (args) {
	        return this.dispatch("apply", [void 0, args]);
	    };
	
	    /**
	     * Calls the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q["try"] = Q.fcall = function (object /* ...args*/) {
	        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	    };
	
	    Promise.prototype.fcall = function () /*...args*/{
	        return this.dispatch("apply", [void 0, array_slice(arguments)]);
	    };
	
	    /**
	     * Binds the promised function, transforming return values into a fulfilled
	     * promise and thrown errors into a rejected one.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q.fbind = function (object /*...args*/) {
	        var promise = Q(object);
	        var args = array_slice(arguments, 1);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	    Promise.prototype.fbind = function () /*...args*/{
	        var promise = this;
	        var args = array_slice(arguments);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	
	    /**
	     * Requests the names of the owned properties of a promised
	     * object in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @return promise for the keys of the eventually settled object
	     */
	    Q.keys = function (object) {
	        return Q(object).dispatch("keys", []);
	    };
	
	    Promise.prototype.keys = function () {
	        return this.dispatch("keys", []);
	    };
	
	    /**
	     * Turns an array of promises into a promise for an array.  If any of
	     * the promises gets rejected, the whole array is rejected immediately.
	     * @param {Array*} an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns a promise for an array of the corresponding values
	     */
	    // By Mark Miller
	    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	    Q.all = all;
	    function all(promises) {
	        return when(promises, function (promises) {
	            var pendingCount = 0;
	            var deferred = defer();
	            array_reduce(promises, function (undefined, promise, index) {
	                var snapshot;
	                if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
	                    promises[index] = snapshot.value;
	                } else {
	                    ++pendingCount;
	                    when(promise, function (value) {
	                        promises[index] = value;
	                        if (--pendingCount === 0) {
	                            deferred.resolve(promises);
	                        }
	                    }, deferred.reject, function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    });
	                }
	            }, void 0);
	            if (pendingCount === 0) {
	                deferred.resolve(promises);
	            }
	            return deferred.promise;
	        });
	    }
	
	    Promise.prototype.all = function () {
	        return all(this);
	    };
	
	    /**
	     * Returns the first resolved promise of an array. Prior rejected promises are
	     * ignored.  Rejects only if all promises are rejected.
	     * @param {Array*} an array containing values or promises for values
	     * @returns a promise fulfilled with the value of the first resolved promise,
	     * or a rejected promise if all promises are rejected.
	     */
	    Q.any = any;
	
	    function any(promises) {
	        if (promises.length === 0) {
	            return Q.resolve();
	        }
	
	        var deferred = Q.defer();
	        var pendingCount = 0;
	        array_reduce(promises, function (prev, current, index) {
	            var promise = promises[index];
	
	            pendingCount++;
	
	            when(promise, onFulfilled, onRejected, onProgress);
	            function onFulfilled(result) {
	                deferred.resolve(result);
	            }
	            function onRejected(err) {
	                pendingCount--;
	                if (pendingCount === 0) {
	                    err.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + err.message;
	                    deferred.reject(err);
	                }
	            }
	            function onProgress(progress) {
	                deferred.notify({
	                    index: index,
	                    value: progress
	                });
	            }
	        }, undefined);
	
	        return deferred.promise;
	    }
	
	    Promise.prototype.any = function () {
	        return any(this);
	    };
	
	    /**
	     * Waits for all promises to be settled, either fulfilled or
	     * rejected.  This is distinct from `all` since that would stop
	     * waiting at the first rejection.  The promise returned by
	     * `allResolved` will never be rejected.
	     * @param promises a promise for an array (or an array) of promises
	     * (or values)
	     * @return a promise for an array of promises
	     */
	    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	    function allResolved(promises) {
	        return when(promises, function (promises) {
	            promises = array_map(promises, Q);
	            return when(all(array_map(promises, function (promise) {
	                return when(promise, noop, noop);
	            })), function () {
	                return promises;
	            });
	        });
	    }
	
	    Promise.prototype.allResolved = function () {
	        return allResolved(this);
	    };
	
	    /**
	     * @see Promise#allSettled
	     */
	    Q.allSettled = allSettled;
	    function allSettled(promises) {
	        return Q(promises).allSettled();
	    }
	
	    /**
	     * Turns an array of promises into a promise for an array of their states (as
	     * returned by `inspect`) when they have all settled.
	     * @param {Array[Any*]} values an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns {Array[State]} an array of states for the respective values.
	     */
	    Promise.prototype.allSettled = function () {
	        return this.then(function (promises) {
	            return all(array_map(promises, function (promise) {
	                promise = Q(promise);
	                function regardless() {
	                    return promise.inspect();
	                }
	                return promise.then(regardless, regardless);
	            }));
	        });
	    };
	
	    /**
	     * Captures the failure of a promise, giving an oportunity to recover
	     * with a callback.  If the given promise is fulfilled, the returned
	     * promise is fulfilled.
	     * @param {Any*} promise for something
	     * @param {Function} callback to fulfill the returned promise if the
	     * given promise is rejected
	     * @returns a promise for the return value of the callback
	     */
	    Q.fail = // XXX legacy
	    Q["catch"] = function (object, rejected) {
	        return Q(object).then(void 0, rejected);
	    };
	
	    Promise.prototype.fail = // XXX legacy
	    Promise.prototype["catch"] = function (rejected) {
	        return this.then(void 0, rejected);
	    };
	
	    /**
	     * Attaches a listener that can respond to progress notifications from a
	     * promise's originating deferred. This listener receives the exact arguments
	     * passed to ``deferred.notify``.
	     * @param {Any*} promise for something
	     * @param {Function} callback to receive any progress notifications
	     * @returns the given promise, unchanged
	     */
	    Q.progress = progress;
	    function progress(object, progressed) {
	        return Q(object).then(void 0, void 0, progressed);
	    }
	
	    Promise.prototype.progress = function (progressed) {
	        return this.then(void 0, void 0, progressed);
	    };
	
	    /**
	     * Provides an opportunity to observe the settling of a promise,
	     * regardless of whether the promise is fulfilled or rejected.  Forwards
	     * the resolution to the returned promise when the callback is done.
	     * The callback can return a promise to defer completion.
	     * @param {Any*} promise
	     * @param {Function} callback to observe the resolution of the given
	     * promise, takes no arguments.
	     * @returns a promise for the resolution of the given promise when
	     * ``fin`` is done.
	     */
	    Q.fin = // XXX legacy
	    Q["finally"] = function (object, callback) {
	        return Q(object)["finally"](callback);
	    };
	
	    Promise.prototype.fin = // XXX legacy
	    Promise.prototype["finally"] = function (callback) {
	        if (!callback || typeof callback.apply !== "function") {
	            throw new Error("Q can't apply finally callback");
	        }
	        callback = Q(callback);
	        return this.then(function (value) {
	            return callback.fcall().then(function () {
	                return value;
	            });
	        }, function (reason) {
	            // TODO attempt to recycle the rejection with "this".
	            return callback.fcall().then(function () {
	                throw reason;
	            });
	        });
	    };
	
	    /**
	     * Terminates a chain of promises, forcing rejections to be
	     * thrown as exceptions.
	     * @param {Any*} promise at the end of a chain of promises
	     * @returns nothing
	     */
	    Q.done = function (object, fulfilled, rejected, progress) {
	        return Q(object).done(fulfilled, rejected, progress);
	    };
	
	    Promise.prototype.done = function (fulfilled, rejected, progress) {
	        var onUnhandledError = function onUnhandledError(error) {
	            // forward to a future turn so that ``when``
	            // does not catch it and turn it into a rejection.
	            Q.nextTick(function () {
	                makeStackTraceLong(error, promise);
	                if (Q.onerror) {
	                    Q.onerror(error);
	                } else {
	                    throw error;
	                }
	            });
	        };
	
	        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.domain) {
	            onUnhandledError = process.domain.bind(onUnhandledError);
	        }
	
	        promise.then(void 0, onUnhandledError);
	    };
	
	    /**
	     * Causes a promise to be rejected if it does not get fulfilled before
	     * some milliseconds time out.
	     * @param {Any*} promise
	     * @param {Number} milliseconds timeout
	     * @param {Any*} custom error message or Error object (optional)
	     * @returns a promise for the resolution of the given promise if it is
	     * fulfilled before the timeout, otherwise rejected.
	     */
	    Q.timeout = function (object, ms, error) {
	        return Q(object).timeout(ms, error);
	    };
	
	    Promise.prototype.timeout = function (ms, error) {
	        var deferred = defer();
	        var timeoutId = setTimeout(function () {
	            if (!error || "string" === typeof error) {
	                error = new Error(error || "Timed out after " + ms + " ms");
	                error.code = "ETIMEDOUT";
	            }
	            deferred.reject(error);
	        }, ms);
	
	        this.then(function (value) {
	            clearTimeout(timeoutId);
	            deferred.resolve(value);
	        }, function (exception) {
	            clearTimeout(timeoutId);
	            deferred.reject(exception);
	        }, deferred.notify);
	
	        return deferred.promise;
	    };
	
	    /**
	     * Returns a promise for the given value (or promised value), some
	     * milliseconds after it resolved. Passes rejections immediately.
	     * @param {Any*} promise
	     * @param {Number} milliseconds
	     * @returns a promise for the resolution of the given promise after milliseconds
	     * time has elapsed since the resolution of the given promise.
	     * If the given promise rejects, that is passed immediately.
	     */
	    Q.delay = function (object, timeout) {
	        if (timeout === void 0) {
	            timeout = object;
	            object = void 0;
	        }
	        return Q(object).delay(timeout);
	    };
	
	    Promise.prototype.delay = function (timeout) {
	        return this.then(function (value) {
	            var deferred = defer();
	            setTimeout(function () {
	                deferred.resolve(value);
	            }, timeout);
	            return deferred.promise;
	        });
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided as an array, and returns a promise.
	     *
	     *      Q.nfapply(FS.readFile, [__filename])
	     *      .then(function (content) {
	     *      })
	     *
	     */
	    Q.nfapply = function (callback, args) {
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfapply = function (args) {
	        var deferred = defer();
	        var nodeArgs = array_slice(args);
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided individually, and returns a promise.
	     * @example
	     * Q.nfcall(FS.readFile, __filename)
	     * .then(function (content) {
	     * })
	     *
	     */
	    Q.nfcall = function (callback /*...args*/) {
	        var args = array_slice(arguments, 1);
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfcall = function () /*...args*/{
	        var nodeArgs = array_slice(arguments);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Wraps a NodeJS continuation passing function and returns an equivalent
	     * version that returns a promise.
	     * @example
	     * Q.nfbind(FS.readFile, __filename)("utf-8")
	     * .then(console.log)
	     * .done()
	     */
	    Q.nfbind = Q.denodeify = function (callback /*...args*/) {
	        if (callback === undefined) {
	            throw new Error("Q can't wrap an undefined function");
	        }
	        var baseArgs = array_slice(arguments, 1);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            Q(callback).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nfbind = Promise.prototype.denodeify = function () /*...args*/{
	        var args = array_slice(arguments);
	        args.unshift(this);
	        return Q.denodeify.apply(void 0, args);
	    };
	
	    Q.nbind = function (callback, thisp /*...args*/) {
	        var baseArgs = array_slice(arguments, 2);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            function bound() {
	                return callback.apply(thisp, arguments);
	            }
	            Q(bound).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nbind = function () /*thisp, ...args*/{
	        var args = array_slice(arguments, 0);
	        args.unshift(this);
	        return Q.nbind.apply(void 0, args);
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback with a given array of arguments, plus a provided callback.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param {Array} args arguments to pass to the method; the callback
	     * will be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nmapply = // XXX As proposed by "Redsandro"
	    Q.npost = function (object, name, args) {
	        return Q(object).npost(name, args);
	    };
	
	    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.npost = function (name, args) {
	        var nodeArgs = array_slice(args || []);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback, forwarding the given variadic arguments, plus a provided
	     * callback argument.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param ...args arguments to pass to the method; the callback will
	     * be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nsend = // XXX Based on Mark Miller's proposed "send"
	    Q.nmcall = // XXX Based on "Redsandro's" proposal
	    Q.ninvoke = function (object, name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 2);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	    Promise.prototype.ninvoke = function (name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 1);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * If a function would like to support both Node continuation-passing-style and
	     * promise-returning-style, it can end its internal promise chain with
	     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	     * elects to use a nodeback, the result will be sent there.  If they do not
	     * pass a nodeback, they will receive the result promise.
	     * @param object a result (or a promise for a result)
	     * @param {Function} nodeback a Node.js-style callback
	     * @returns either the promise or nothing
	     */
	    Q.nodeify = nodeify;
	    function nodeify(object, nodeback) {
	        return Q(object).nodeify(nodeback);
	    }
	
	    Promise.prototype.nodeify = function (nodeback) {
	        if (nodeback) {
	            this.then(function (value) {
	                Q.nextTick(function () {
	                    nodeback(null, value);
	                });
	            }, function (error) {
	                Q.nextTick(function () {
	                    nodeback(error);
	                });
	            });
	        } else {
	            return this;
	        }
	    };
	
	    Q.noConflict = function () {
	        throw new Error("Q.noConflict only works when Q is used as a global");
	    };
	
	    // All code before this point will be filtered from stack traces.
	    var qEndingLine = captureLine();
	
	    return Q;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(9).setImmediate, __webpack_require__(11)(module)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function () {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function () {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout = exports.clearInterval = function (timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function () {};
	Timeout.prototype.close = function () {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function (item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function (item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function (item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout) item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(10);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	
	(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	        // Callback can either be a function or a string
	        if (typeof callback !== "function") {
	            callback = new Function("" + callback);
	        }
	        // Copy function arguments
	        var args = new Array(arguments.length - 1);
	        for (var i = 0; i < args.length; i++) {
	            args[i] = arguments[i + 1];
	        }
	        // Store and register the task
	        var task = { callback: callback, args: args };
	        tasksByHandle[nextHandle] = task;
	        registerImmediate(nextHandle);
	        return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	            case 0:
	                callback();
	                break;
	            case 1:
	                callback(args[0]);
	                break;
	            case 2:
	                callback(args[0], args[1]);
	                break;
	            case 3:
	                callback(args[0], args[1], args[2]);
	                break;
	            default:
	                callback.apply(undefined, args);
	                break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            process.nextTick(function () {
	                runIfPresent(handle);
	            });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function () {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function onGlobalMessage(event) {
	            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function registerImmediate(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function registerImmediate(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function registerImmediate(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _algoliasearch = __webpack_require__(13);
	
	var _algoliasearch2 = _interopRequireDefault(_algoliasearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var escapeRegExp = function escapeRegExp(str) {
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	};
	
	var Search = {
	  install: function install(Vue, options) {
	    _loglevel2.default.trace(options);
	    var AlgoliaClient = (0, _algoliasearch2.default)(options.appID, options.apiKey, {
	      protocol: 'https:'
	    });
	    var AlgoliaIndex = AlgoliaClient.initIndex(options.index);
	
	    var advancedSearch = function advancedSearch(params) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.clearCache();
	      AlgoliaIndex.search(params, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          fetchListItemCards(content.hits).then(function () {
	            d.resolve(content.hits);
	          });
	        }
	      });
	      return d.promise;
	    };
	
	    var searchCards = function searchCards(userID, searchText, hitsPerPage) {
	      var d = _q2.default.defer();
	      var params = {
	        query: searchText,
	        filters: userID.length ? 'userID: ' + userID : '',
	        hitsPerPage: hitsPerPage || null
	      };
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (hits) {
	        _loglevel2.default.trace(hits);
	        d.resolve(hits);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var fetchListItemCards = function fetchListItemCards(cards) {
	      var d = _q2.default.defer();
	      var self = this;
	      var promises = [];
	      cards.forEach(function (card) {
	        console.log(JSON.stringify(card));
	        console.log(JSON.stringify(card.content));
	        card = correctCard(card);
	        console.log(JSON.stringify(card.content));
	        card.content.listCards = [];
	        if (!card.content.listItems) card.content.listItems = [];
	        card.content.listItems.forEach(function (key) {
	          console.log(key);
	          var p = _q2.default.defer();
	          promises.push(getCard(key)); // Do we need to notify the card or provide callbacks etc here?
	          // promises.push(p.promise)
	        });
	      });
	      _loglevel2.default.trace(promises);
	      _q2.default.allSettled(promises).then(function (results) {
	        console.log(results);
	        console.log(cards);
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getCard = function getCard(objectID) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.getObject(objectID, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          d.resolve(content);
	        }
	      });
	      return d.promise;
	    };
	
	    var correctCard = function correctCard(card) {
	      console.log(JSON.stringify(card.content));
	      if (!card.content) card.content = {
	        description: card.description || card.sentence || card.text,
	        listItems: card.listItems || []
	      };
	      console.log(JSON.stringify(card.content));
	      if (card.sentence) delete card.sentence;
	      if (card.text) delete card.text;
	      if (card.description) delete card.description;
	      if (card.objectID == "624391002") console.log(hit);
	      return card;
	    };
	
	    var compoundSearch = function compoundSearch(userID, searchText) {
	      var d = _q2.default.defer();
	      var maxLength = 400;
	      var searchTextArray = [];
	      var hitsPerPage = Math.min(Math.max(Math.ceil(10 / (searchText.length / maxLength)), 3), 12);
	      for (var i = 0; i < searchText.length; i += maxLength) {
	        searchTextArray.push(searchText.substring(i, i + maxLength));
	      }
	      var promises = searchTextArray.map(function (t, j) {
	        return searchCards(userID, t, hitsPerPage);
	      });
	      _q2.default.allSettled(promises).then(function (results) {
	        var results = [].concat.apply([], results.map(function (r) {
	          return r.value;
	        }));
	        results = removeDuplicates(results, 'objectID');
	        _loglevel2.default.trace(results);
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	      });
	      return d.promise;
	    };
	
	    var removeDuplicates = function removeDuplicates(originalArray, objKey) {
	      var trimmedArray = [],
	          values = [],
	          value;
	      for (var i = 0; i < originalArray.length; i++) {
	        value = originalArray[i][objKey];
	        if (values.indexOf(value) === -1) {
	          trimmedArray.push(originalArray[i]);
	          values.push(value);
	        }
	      }
	      return trimmedArray;
	    };
	
	    var checkPageHit = function checkPageHit(pageData, results) {
	      //Not yet accounting for capitals
	      var boringWords = ['favourite', 'world', 'name', 'this', 'plan', 'need', 'best', 'like', 'the', 'are', 'is', 'my', 'my'];
	      var hits = [];
	      results.forEach(function (result, i) {
	        _loglevel2.default.trace('---');
	        _loglevel2.default.trace(i);
	        var count = [];
	        result.context.forEach(function (c) {
	          if (pageData.pageText.indexOf(c.value) > -1 && hits.indexOf(result.objectID) == -1 && c.value && c.value.length > 3 && boringWords.indexOf(c.value) == -1 && count.indexOf(c.value) == -1) {
	            _loglevel2.default.trace(c.value);
	            count.push(c.value);
	            (c.value.match(/ /g) || []).forEach(function () {
	              count.push(c.value);
	            });
	          }
	        });
	        if (count.length > 2) {
	          _loglevel2.default.trace(result.sentence);
	          hits.push(result);
	        }
	        _loglevel2.default.trace('---');
	      });
	
	      // return hits;
	      //Force no hits
	      return [];
	    };
	
	    var checkPageReminder = function checkPageReminder(userID, pageData) {
	      var d = _q2.default.defer();
	      _loglevel2.default.trace(pageData);
	      var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	      var params = {
	        query: '',
	        filters: 'userID: ' + userID + ' AND (triggerUrl: ' + urlRoot + ' OR triggerUrl: ' + urlRoot + '.com OR triggerUrl: ' + urlRoot + '.co.uk OR triggerUrl: ' + urlRoot + '.org OR triggerURL: ' + urlRoot + ' OR triggerURL: ' + urlRoot + '.com OR triggerURL: ' + urlRoot + '.co.uk OR triggerURL: ' + urlRoot + '.org)'
	      };
	      _loglevel2.default.trace('params');
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (reminders) {
	        _loglevel2.default.trace('reminders');
	        _loglevel2.default.trace(reminders);
	        d.resolve(reminders);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getPageResults = function getPageResults(userID, pageData, allUserCards) {
	      var d = _q2.default.defer();
	      // Gets all results
	      var pageResults = {
	        hits: [],
	        reminders: [],
	        pings: [],
	        memories: []
	      };
	      _loglevel2.default.trace(userID, pageData);
	      var gmailBoringPhrases = ['Skip to content', 'Using', 'with screen readers', 'Search', 'Mail', 'COMPOSE', 'Labels', 'Inbox', 'Starred', 'Sent Mail', 'Drafts', 'More', '---------- Forwarded message ----------', 'From: ', 'Date: ', 'Subject: ', 'To: ', 'Click here to Reply or Forward', 'GB', 'GB used', 'Manage', 'Program Policies', 'Powered by Google', 'Last account activity:', 'hour ago', 'hours ago', 'Details'];
	      gmailBoringPhrases.forEach(function (phrase) {
	        pageData.pageText = pageData.pageText.replace(phrase, '');
	      });
	      var boringWords = ["i", "a", "of", "me", "my", "is", "im", "so", "all", "get", "how", "new", "out", "the", "use", "best", "name", "next", "take", "what", "image", "something"];
	
	      try {
	        var allWords = [];
	        allUserCards.forEach(function (card) {
	          var score = 0;
	          card.context.forEach(function (entity) {
	            var val = String(entity.value);
	            if (boringWords.indexOf(val.toLowerCase()) == -1 && val.length > 1) {
	              var reg = new RegExp(escapeRegExp(val), "gi");
	              var points = (pageData.pageText.match(reg) || []).length * val.length;
	              score += points;
	              if (points) {
	                if (allWords.indexOf(val) == -1) allWords.push(val);
	              }
	            }
	          });
	          if (score > 100) {
	            pageResults.hits.push(card);
	          } else if (score > 0) {
	            pageResults.memories.push(card);
	          }
	        });
	        _loglevel2.default.debug(allWords);
	
	        pageResults.reminders = allUserCards.filter(function (card) {
	          var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	          _loglevel2.default.info(card.triggerURL);
	          return card.triggerURL && (card.triggerURL.indexOf(urlRoot) > -1 || card.triggerURL.indexOf(urlRoot) > -1);
	        });
	        pageResults.pings = pageResults.reminders; //.concat(pageResults.hits)
	        pageResults.pings.forEach(function (ping) {
	          ping.highlight = true;
	        });
	        // pageResults.memories = pageResults.pings.concat(pageResults.memories)
	        pageResults.memories = removeDuplicates(pageResults.memories, 'objectID');
	        _loglevel2.default.debug(pageResults);
	        d.resolve(pageResults);
	      } catch (e) {
	        _loglevel2.default.error(e);
	      }
	
	      // compoundSearch(userID, pageData.pageText)
	      // .then(function(results) {
	      //   log.trace(1);
	      //   log.trace(results);
	      //   pageResults.memories = results;
	      //   // Checks whether a ping is required
	      //   pageResults.hits = checkPageHit(pageData, results);
	      //   log.trace(2);
	      //   log.trace(pageResults.hits);
	      //   return checkPageReminder(userID, pageData)
	      // }).then(function(reminders) {
	      //   pageResults.reminders = reminders;
	      //   log.trace(3);
	      //   log.trace(pageResults.reminders);
	      //   // Returns results plus ping
	      //   pageResults.pings = pageResults.reminders.concat(pageResults.hits)
	      //   pageResults.pings.forEach(function(ping) {
	      //     log.trace(ping.objectID);
	      //     ping.highlight = true;
	      //   })
	      //   pageResults.memories = pageResults.pings.concat(pageResults.memories)
	      //   pageResults.memories = removeDuplicates(pageResults.memories, 'objectID')
	      //   log.trace(pageResults);
	      //   d.resolve(pageResults)
	      // }).catch(function(e) {
	      //   log.trace(e);
	      //   d.reject(e)
	      // })
	      return d.promise;
	    };
	
	    this.advancedSearch = advancedSearch;
	    this.searchCards = searchCards;
	    this.compoundSearch = compoundSearch;
	    this.getPageResults = getPageResults;
	  }
	};
	
	exports.default = Search;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var AlgoliaSearch = __webpack_require__(14);
	var createAlgoliasearch = __webpack_require__(38);
	
	module.exports = createAlgoliasearch(AlgoliaSearch);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = AlgoliaSearch;
	
	var Index = __webpack_require__(15);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var AlgoliaSearchCore = __webpack_require__(33);
	var inherits = __webpack_require__(16);
	var errors = __webpack_require__(19);
	
	function AlgoliaSearch() {
	  AlgoliaSearchCore.apply(this, arguments);
	}
	
	inherits(AlgoliaSearch, AlgoliaSearchCore);
	
	/*
	 * Delete an index
	 *
	 * @param indexName the name of index to delete
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.deleteIndex = function (indexName, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexName),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Move an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy of
	 * srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.moveIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'move', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Copy an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy
	 * of srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.copyIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'copy', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Return last log entries.
	 * @param offset Specify the first entry to retrieve (0-based, 0 is the most recent log entry).
	 * @param length Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param type Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.getLogs = function (offset, length, callback) {
	  var clone = __webpack_require__(24);
	  var params = {};
	  if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) === 'object') {
	    // getLogs(params)
	    params = clone(offset);
	    callback = length;
	  } else if (arguments.length === 0 || typeof offset === 'function') {
	    // getLogs([cb])
	    callback = offset;
	  } else if (arguments.length === 1 || typeof length === 'function') {
	    // getLogs(1, [cb)]
	    callback = length;
	    params.offset = offset;
	  } else {
	    // getLogs(1, 2, [cb])
	    params.offset = offset;
	    params.length = length;
	  }
	
	  if (params.offset === undefined) params.offset = 0;
	  if (params.length === undefined) params.length = 10;
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/logs?' + this._getSearchParams(params, ''),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * List all existing indexes (paginated)
	 *
	 * @param page The page to retrieve, starting at 0.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with index list
	 */
	AlgoliaSearch.prototype.listIndexes = function (page, callback) {
	  var params = '';
	
	  if (page === undefined || typeof page === 'function') {
	    callback = page;
	  } else {
	    params = '?page=' + page;
	  }
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes' + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearch.prototype.initIndex = function (indexName) {
	  return new Index(this, indexName);
	};
	
	/*
	 * @deprecated use client.listApiKeys
	 */
	AlgoliaSearch.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('client.listUserKeys()', 'client.listApiKeys()'));
	
	/*
	 * List all existing api keys with their associated ACLs
	 *
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with api keys list
	 */
	AlgoliaSearch.prototype.listApiKeys = function (callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.getApiKey
	 */
	AlgoliaSearch.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('client.getUserKeyACL()', 'client.getApiKey()'));
	
	/*
	 * Get an API key
	 *
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the right API key
	 */
	AlgoliaSearch.prototype.getApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.deleteApiKey
	 */
	AlgoliaSearch.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('client.deleteUserKey()', 'client.deleteApiKey()'));
	
	/*
	 * Delete an existing API key
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the date of deletion
	 */
	AlgoliaSearch.prototype.deleteApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see client.addApiKey
	 */
	AlgoliaSearch.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKey()', 'client.addApiKey()'));
	
	/*
	 * Add a new global API key
	 *
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the added API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.addUserKey(['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#AddKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.indexes = params.indexes;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * @deprecated Please use client.addApiKey()
	 */
	AlgoliaSearch.prototype.addUserKeyWithValidity = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKeyWithValidity()', 'client.addApiKey()'));
	
	/**
	 * @deprecated Please use client.updateApiKey()
	 */
	AlgoliaSearch.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('client.updateUserKey()', 'client.updateApiKey()'));
	
	/**
	 * Update an existing API key
	 * @param {string} key - The key to update
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the modified API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.updateApiKey('APIKEY', ['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.indexes = params.indexes;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'PUT',
	    url: '/1/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Initialize a new batch of search queries
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.startQueriesBatch = deprecate(function startQueriesBatchDeprecated() {
	  this._batch = [];
	}, deprecatedMessage('client.startQueriesBatch()', 'client.search()'));
	
	/**
	 * Add a search query in the batch
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.addQueryInBatch = deprecate(function addQueryInBatchDeprecated(indexName, query, args) {
	  this._batch.push({
	    indexName: indexName,
	    query: query,
	    params: args
	  });
	}, deprecatedMessage('client.addQueryInBatch()', 'client.search()'));
	
	/**
	 * Launch the batch of queries using XMLHttpRequest.
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.sendQueriesBatch = deprecate(function sendQueriesBatchDeprecated(callback) {
	  return this.search(this._batch, callback);
	}, deprecatedMessage('client.sendQueriesBatch()', 'client.search()'));
	
	/**
	 * Perform write operations accross multiple indexes.
	 *
	 * To reduce the amount of time spent on network round trips,
	 * you can create, update, or delete several objects in one call,
	 * using the batch endpoint (all operations are done in the given order).
	 *
	 * Available actions:
	 *   - addObject
	 *   - updateObject
	 *   - partialUpdateObject
	 *   - partialUpdateObjectNoCreate
	 *   - deleteObject
	 *
	 * https://www.algolia.com/doc/rest_api#Indexes
	 * @param  {Object[]} operations An array of operations to perform
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.batch([{
	 *   action: 'addObject',
	 *   indexName: 'clients',
	 *   body: {
	 *     name: 'Bill'
	 *   }
	 * }, {
	 *   action: 'udpateObject',
	 *   indexName: 'fruits',
	 *   body: {
	 *     objectID: '29138',
	 *     name: 'banana'
	 *   }
	 * }], cb)
	 */
	AlgoliaSearch.prototype.batch = function (operations, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.batch(operations[, callback])';
	
	  if (!isArray(operations)) {
	    throw new Error(usage);
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/batch',
	    body: {
	      requests: operations
	    },
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	// environment specific methods
	AlgoliaSearch.prototype.destroy = notImplemented;
	AlgoliaSearch.prototype.enableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.disableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.useSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.disableSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.generateSecuredApiKey = notImplemented;
	
	function notImplemented() {
	  var message = 'Not implemented in this environment.\n' + 'If you feel this is a mistake, write to support@algolia.com';
	
	  throw new errors.AlgoliaSearchError(message);
	}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var inherits = __webpack_require__(16);
	var IndexCore = __webpack_require__(17);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var exitPromise = __webpack_require__(30);
	var errors = __webpack_require__(19);
	
	var deprecateForwardToSlaves = deprecate(function () {}, deprecatedMessage('forwardToSlaves', 'forwardToReplicas'));
	
	module.exports = Index;
	
	function Index() {
	  IndexCore.apply(this, arguments);
	}
	
	inherits(Index, IndexCore);
	
	/*
	* Add an object in this index
	*
	* @param content contains the javascript object to add inside the index
	* @param objectID (optional) an objectID you want to attribute to this object
	* (if the attribute already exist the old object will be overwrite)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.addObject = function (content, objectID, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof objectID === 'function') {
	    callback = objectID;
	    objectID = undefined;
	  }
	
	  return this.as._jsonRequest({
	    method: objectID !== undefined ? 'PUT' : // update or create
	    'POST', // create (API generates an objectID)
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + ( // create
	    objectID !== undefined ? '/' + encodeURIComponent(objectID) : ''), // update or create
	    body: content,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Add several objects
	*
	* @param objects contains an array of objects to add
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.addObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'addObject',
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Update partially an object (only update attributes passed in argument)
	*
	* @param partialObject contains the javascript attributes to override, the
	*  object must contains an objectID attribute
	* @param createIfNotExists (optional) if false, avoid an automatic creation of the object
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.partialUpdateObject = function (partialObject, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = undefined;
	  }
	
	  var indexObj = this;
	  var url = '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(partialObject.objectID) + '/partial';
	  if (createIfNotExists === false) {
	    url += '?createIfNotExists=false';
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: url,
	    body: partialObject,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Partially Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.partialUpdateObjects = function (objects, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = true;
	  }
	
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.partialUpdateObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: createIfNotExists === true ? 'partialUpdateObject' : 'partialUpdateObjectNoCreate',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of object
	*
	* @param object contains the javascript object to save, the object must contains an objectID attribute
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObject = function (object, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(object.objectID),
	    body: object,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.saveObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'updateObject',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete an object from the index
	*
	* @param objectID the unique identifier of object to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObject = function (objectID, callback) {
	  if (typeof objectID === 'function' || typeof objectID !== 'string' && typeof objectID !== 'number') {
	    var err = new errors.AlgoliaSearchError('Cannot delete an object without an objectID');
	    callback = objectID;
	    if (typeof callback === 'function') {
	      return callback(err);
	    }
	
	    return this.as._promise.reject(err);
	  }
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete several objects from an index
	*
	* @param objectIDs contains an array of objectID to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObjects = function (objectIDs, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.deleteObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      return {
	        action: 'deleteObject',
	        objectID: objectID,
	        body: {
	          objectID: objectID
	        }
	      };
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete all objects matching a query
	*
	* @param query the query string
	* @param params the optional query parameters
	* @param callback (optional) the result callback called with one argument
	*  error: null or Error('message')
	*/
	Index.prototype.deleteByQuery = function (query, params, callback) {
	  var clone = __webpack_require__(24);
	  var map = __webpack_require__(29);
	
	  var indexObj = this;
	  var client = indexObj.as;
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else {
	    params = clone(params);
	  }
	
	  params.attributesToRetrieve = 'objectID';
	  params.hitsPerPage = 1000;
	  params.distinct = false;
	
	  // when deleting, we should never use cache to get the
	  // search results
	  this.clearCache();
	
	  // there's a problem in how we use the promise chain,
	  // see how waitTask is done
	  var promise = this.search(query, params).then(stopOrDelete);
	
	  function stopOrDelete(searchContent) {
	    // stop here
	    if (searchContent.nbHits === 0) {
	      // return indexObj.as._request.resolve();
	      return searchContent;
	    }
	
	    // continue and do a recursive call
	    var objectIDs = map(searchContent.hits, function getObjectID(object) {
	      return object.objectID;
	    });
	
	    return indexObj.deleteObjects(objectIDs).then(waitTask).then(doDeleteByQuery);
	  }
	
	  function waitTask(deleteObjectsContent) {
	    return indexObj.waitTask(deleteObjectsContent.taskID);
	  }
	
	  function doDeleteByQuery() {
	    return indexObj.deleteByQuery(query, params);
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(success, failure);
	
	  function success() {
	    exitPromise(function exit() {
	      callback(null);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failure(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* Browse all content from an index using events. Basically this will do
	* .browse() -> .browseFrom -> .browseFrom -> .. until all the results are returned
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @return {EventEmitter}
	* @example
	* var browser = index.browseAll('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* });
	*
	* browser.on('result', function resultCallback(content) {
	*   console.log(content.hits);
	* });
	*
	* // if any error occurs, you get it
	* browser.on('error', function(err) {
	*   throw err;
	* });
	*
	* // when you have browsed the whole index, you get this event
	* browser.on('end', function() {
	*   console.log('finished');
	* });
	*
	* // at any point if you want to stop the browsing process, you can stop it manually
	* // otherwise it will go on and on
	* browser.stop();
	*
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	Index.prototype.browseAll = function (query, queryParameters) {
	  if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
	    queryParameters = query;
	    query = undefined;
	  }
	
	  var merge = __webpack_require__(23);
	
	  var IndexBrowser = __webpack_require__(31);
	
	  var browser = new IndexBrowser();
	  var client = this.as;
	  var index = this;
	  var params = client._getSearchParams(merge({}, queryParameters || {}, {
	    query: query
	  }), '');
	
	  // start browsing
	  browseLoop();
	
	  function browseLoop(cursor) {
	    if (browser._stopped) {
	      return;
	    }
	
	    var body;
	
	    if (cursor !== undefined) {
	      body = {
	        cursor: cursor
	      };
	    } else {
	      body = {
	        params: params
	      };
	    }
	
	    client._jsonRequest({
	      method: 'POST',
	      url: '/1/indexes/' + encodeURIComponent(index.indexName) + '/browse',
	      hostType: 'read',
	      body: body,
	      callback: browseCallback
	    });
	  }
	
	  function browseCallback(err, content) {
	    if (browser._stopped) {
	      return;
	    }
	
	    if (err) {
	      browser._error(err);
	      return;
	    }
	
	    browser._result(content);
	
	    // no cursor means we are finished browsing
	    if (content.cursor === undefined) {
	      browser._end();
	      return;
	    }
	
	    browseLoop(content.cursor);
	  }
	
	  return browser;
	};
	
	/*
	* Get a Typeahead.js adapter
	* @param searchParams contains an object with query parameters (see search for details)
	*/
	Index.prototype.ttAdapter = deprecate(function (params) {
	  var self = this;
	  return function ttAdapter(query, syncCb, asyncCb) {
	    var cb;
	
	    if (typeof asyncCb === 'function') {
	      // typeahead 0.11
	      cb = asyncCb;
	    } else {
	      // pre typeahead 0.11
	      cb = syncCb;
	    }
	
	    self.search(query, params, function searchDone(err, content) {
	      if (err) {
	        cb(err);
	        return;
	      }
	
	      cb(content.hits);
	    });
	  };
	}, 'ttAdapter is not necessary anymore and will be removed in the next version,\n' + 'have a look at autocomplete.js (https://github.com/algolia/autocomplete.js)');
	
	/*
	* Wait the publication of a task on the server.
	* All server task are asynchronous and you can check with this method that the task is published.
	*
	* @param taskID the id of the task returned by server
	* @param callback the result callback with with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains the list of results
	*/
	Index.prototype.waitTask = function (taskID, callback) {
	  // wait minimum 100ms before retrying
	  var baseDelay = 100;
	  // wait maximum 5s before retrying
	  var maxDelay = 5000;
	  var loop = 0;
	
	  // waitTask() must be handled differently from other methods,
	  // it's a recursive method using a timeout
	  var indexObj = this;
	  var client = indexObj.as;
	
	  var promise = retryLoop();
	
	  function retryLoop() {
	    return client._jsonRequest({
	      method: 'GET',
	      hostType: 'read',
	      url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/task/' + taskID
	    }).then(function success(content) {
	      loop++;
	      var delay = baseDelay * loop * loop;
	      if (delay > maxDelay) {
	        delay = maxDelay;
	      }
	
	      if (content.status !== 'published') {
	        return client._promise.delay(delay).then(retryLoop);
	      }
	
	      return content;
	    });
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(successCb, failureCb);
	
	  function successCb(content) {
	    exitPromise(function exit() {
	      callback(null, content);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failureCb(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* This function deletes the index content. Settings and index specific API keys are kept untouched.
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.clearIndex = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/clear',
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Get settings of this index
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.getSettings = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?getVersion=2',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.searchSynonyms = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveSynonym = function (synonym, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(synonym.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: synonym,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getSynonym = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteSynonym = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearSynonyms = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchSynonyms = function (synonyms, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/batch' + '?forwardToReplicas=' + forwardToReplicas + '&replaceExistingSynonyms=' + (opts.replaceExistingSynonyms ? 'true' : 'false'),
	    hostType: 'write',
	    body: synonyms,
	    callback: callback
	  });
	};
	
	Index.prototype.searchRules = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveRule = function (rule, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(rule.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: rule,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getRule = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteRule = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearRules = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchRules = function (rules, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/batch' + '?forwardToReplicas=' + forwardToReplicas + '&clearExistingRules=' + (opts.clearExistingRules === true ? 'true' : 'false'),
	    hostType: 'write',
	    body: rules,
	    callback: callback
	  });
	};
	
	/*
	* Set settings for this index
	*
	* @param settigns the settings object that can contains :
	* - minWordSizefor1Typo: (integer) the minimum number of characters to accept one typo (default = 3).
	* - minWordSizefor2Typos: (integer) the minimum number of characters to accept two typos (default = 7).
	* - hitsPerPage: (integer) the number of hits per page (default = 10).
	* - attributesToRetrieve: (array of strings) default list of attributes to retrieve in objects.
	*   If set to null, all attributes are retrieved.
	* - attributesToHighlight: (array of strings) default list of attributes to highlight.
	*   If set to null, all indexed attributes are highlighted.
	* - attributesToSnippet**: (array of strings) default list of attributes to snippet alongside the number
	* of words to return (syntax is attributeName:nbWords).
	*   By default no snippet is computed. If set to null, no snippet is computed.
	* - attributesToIndex: (array of strings) the list of fields you want to index.
	*   If set to null, all textual and numerical attributes of your objects are indexed,
	*   but you should update it to get optimal results.
	*   This parameter has two important uses:
	*     - Limit the attributes to index: For example if you store a binary image in base64,
	*     you want to store it and be able to
	*       retrieve it but you don't want to search in the base64 string.
	*     - Control part of the ranking*: (see the ranking parameter for full explanation)
	*     Matches in attributes at the beginning of
	*       the list will be considered more important than matches in attributes further down the list.
	*       In one attribute, matching text at the beginning of the attribute will be
	*       considered more important than text after, you can disable
	*       this behavior if you add your attribute inside `unordered(AttributeName)`,
	*       for example attributesToIndex: ["title", "unordered(text)"].
	* - attributesForFaceting: (array of strings) The list of fields you want to use for faceting.
	*   All strings in the attribute selected for faceting are extracted and added as a facet.
	*   If set to null, no attribute is used for faceting.
	* - attributeForDistinct: (string) The attribute name used for the Distinct feature.
	* This feature is similar to the SQL "distinct" keyword: when enabled
	*   in query with the distinct=1 parameter, all hits containing a duplicate
	*   value for this attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best one is kept and others are removed.
	* - ranking: (array of strings) controls the way results are sorted.
	*   We have six available criteria:
	*    - typo: sort according to number of typos,
	*    - geo: sort according to decreassing distance when performing a geo-location based search,
	*    - proximity: sort according to the proximity of query words in hits,
	*    - attribute: sort according to the order of attributes defined by attributesToIndex,
	*    - exact:
	*        - if the user query contains one word: sort objects having an attribute
	*        that is exactly the query word before others.
	*          For example if you search for the "V" TV show, you want to find it
	*          with the "V" query and avoid to have all popular TV
	*          show starting by the v letter before it.
	*        - if the user query contains multiple words: sort according to the
	*        number of words that matched exactly (and not as a prefix).
	*    - custom: sort according to a user defined formula set in **customRanking** attribute.
	*   The standard order is ["typo", "geo", "proximity", "attribute", "exact", "custom"]
	* - customRanking: (array of strings) lets you specify part of the ranking.
	*   The syntax of this condition is an array of strings containing attributes
	*   prefixed by asc (ascending order) or desc (descending order) operator.
	*   For example `"customRanking" => ["desc(population)", "asc(name)"]`
	* - queryType: Select how the query words are interpreted, it can be one of the following value:
	*   - prefixAll: all query words are interpreted as prefixes,
	*   - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*   - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - highlightPreTag: (string) Specify the string that is inserted before
	* the highlighted parts in the query result (default to "<em>").
	* - highlightPostTag: (string) Specify the string that is inserted after
	* the highlighted parts in the query result (default to "</em>").
	* - optionalWords: (array of strings) Specify a list of words that should
	* be considered as optional when found in the query.
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer or the error message if a failure occured
	*/
	Index.prototype.setSettings = function (settings, opts, callback) {
	  if (arguments.length === 1 || typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    body: settings,
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.listApiKeys
	 */
	Index.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('index.listUserKeys()', 'index.listApiKeys()'));
	
	/*
	* List all existing API keys to this index
	*
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with API keys belonging to the index
	*/
	Index.prototype.listApiKeys = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.getApiKey
	 */
	Index.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('index.getUserKeyACL()', 'index.getApiKey()'));
	
	/*
	* Get an API key from this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the right API key
	*/
	Index.prototype.getApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.deleteApiKey
	 */
	Index.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('index.deleteUserKey()', 'index.deleteApiKey()'));
	
	/*
	* Delete an existing API key associated to this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the deletion date
	*/
	Index.prototype.deleteApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.addApiKey
	 */
	Index.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKey()', 'index.addApiKey()'));
	
	/*
	* Add a new API key to this index
	*
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the added API key
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.addUserKey(['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#AddIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	* @deprecated use index.addApiKey()
	*/
	Index.prototype.addUserKeyWithValidity = deprecate(function deprecatedAddUserKeyWithValidity(acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKeyWithValidity()', 'index.addApiKey()'));
	
	/*
	 @deprecated see index.updateApiKey
	 */
	Index.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('index.updateUserKey()', 'index.updateApiKey()'));
	
	/**
	* Update an existing API key of this index
	* @param {string} key - The key to update
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with user keys list
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.updateApiKey('APIKEY', ['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';
	
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var buildSearchMethod = __webpack_require__(18);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	
	module.exports = IndexCore;
	
	/*
	* Index class constructor.
	* You should not use this method directly but use initIndex() function
	*/
	function IndexCore(algoliasearch, indexName) {
	  this.indexName = indexName;
	  this.as = algoliasearch;
	  this.typeAheadArgs = null;
	  this.typeAheadValueOption = null;
	
	  // make sure every index instance has it's own cache
	  this.cache = {};
	}
	
	/*
	* Clear all queries in cache
	*/
	IndexCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/*
	* Search inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the full text query
	* @param {object} [args] (optional) if set, contains an object with query parameters:
	* - page: (integer) Pagination parameter used to select the page to retrieve.
	*                   Page is zero-based and defaults to 0. Thus,
	*                   to retrieve the 10th page you need to set page=9
	* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.
	* - attributesToRetrieve: a string that contains the list of object attributes
	* you want to retrieve (let you minimize the answer size).
	*   Attributes are separated with a comma (for example "name,address").
	*   You can also use an array (for example ["name","address"]).
	*   By default, all attributes are retrieved. You can also use '*' to retrieve all
	*   values when an attributesToRetrieve setting is specified for your index.
	* - attributesToHighlight: a string that contains the list of attributes you
	*   want to highlight according to the query.
	*   Attributes are separated by a comma. You can also use an array (for example ["name","address"]).
	*   If an attribute has no match for the query, the raw value is returned.
	*   By default all indexed text attributes are highlighted.
	*   You can use `*` if you want to highlight all textual attributes.
	*   Numerical attributes are not highlighted.
	*   A matchLevel is returned for each highlighted attribute and can contain:
	*      - full: if all the query terms were found in the attribute,
	*      - partial: if only some of the query terms were found,
	*      - none: if none of the query terms were found.
	* - attributesToSnippet: a string that contains the list of attributes to snippet alongside
	* the number of words to return (syntax is `attributeName:nbWords`).
	*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).
	*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).
	*    By default no snippet is computed.
	* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.
	* Defaults to 3.
	* - minWordSizefor2Typos: the minimum number of characters in a query word
	* to accept two typos in this word. Defaults to 7.
	* - getRankingInfo: if set to 1, the result hits will contain ranking
	* information in _rankingInfo attribute.
	* - aroundLatLng: search for entries around a given
	* latitude/longitude (specified as two floats separated by a comma).
	*   For example aroundLatLng=47.316669,5.016670).
	*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)
	*   and the precision for ranking with aroundPrecision
	*   (for example if you set aroundPrecision=100, two objects that are distant of
	*   less than 100m will be considered as identical for "geo" ranking parameter).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - insideBoundingBox: search entries inside a given area defined by the two extreme points
	* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).
	*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - numericFilters: a string that contains the list of numeric filters you want to
	* apply separated by a comma.
	*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.
	*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.
	*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.
	*   You can also use an array (for example numericFilters: ["price>100","price<1000"]).
	* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.
	*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).
	*   You can also use an array, for example tagFilters: ["tag1",["tag2","tag3"]]
	*   means tag1 AND (tag2 OR tag3).
	*   At indexing, tags should be added in the _tags** attribute
	*   of objects (for example {"_tags":["tag1","tag2"]}).
	* - facetFilters: filter the query by a list of facets.
	*   Facets are separated by commas and each facet is encoded as `attributeName:value`.
	*   For example: `facetFilters=category:Book,author:John%20Doe`.
	*   You can also use an array (for example `["category:Book","author:John%20Doe"]`).
	* - facets: List of object attributes that you want to use for faceting.
	*   Comma separated list: `"category,author"` or array `['category','author']`
	*   Only attributes that have been added in **attributesForFaceting** index setting
	*   can be used in this parameter.
	*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.
	* - queryType: select how the query words are interpreted, it can be one of the following value:
	*    - prefixAll: all query words are interpreted as prefixes,
	*    - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - optionalWords: a string that contains the list of words that should
	* be considered as optional when found in the query.
	*   Comma separated and array are accepted.
	* - distinct: If set to 1, enable the distinct feature (disabled by default)
	* if the attributeForDistinct index setting is set.
	*   This feature is similar to the SQL "distinct" keyword: when enabled
	*   in a query with the distinct=1 parameter,
	*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best
	*   one is kept and others are removed.
	* - restrictSearchableAttributes: List of attributes you want to use for
	* textual search (must be a subset of the attributesToIndex index setting)
	* either comma separated or as an array
	* @param {function} [callback] the result callback called with two arguments:
	*  error: null or Error('message'). If false, the content contains the error.
	*  content: the server answer that contains the list of results.
	*/
	IndexCore.prototype.search = buildSearchMethod('query');
	
	/*
	* -- BETA --
	* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the similar query
	* @param {object} [args] (optional) if set, contains an object with query parameters.
	*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters
	*   are the two most useful to restrict the similar results and get more relevant content
	*/
	IndexCore.prototype.similarSearch = buildSearchMethod('similarQuery');
	
	/*
	* Browse index content. The response content will have a `cursor` property that you can use
	* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browse('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* }, callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browse = function (query, queryParameters, callback) {
	  var merge = __webpack_require__(23);
	
	  var indexObj = this;
	
	  var page;
	  var hitsPerPage;
	
	  // we check variadic calls that are not the one defined
	  // .browse()/.browse(fn)
	  // => page = 0
	  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {
	    page = 0;
	    callback = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'number') {
	    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)
	    page = arguments[0];
	    if (typeof arguments[1] === 'number') {
	      hitsPerPage = arguments[1];
	    } else if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	      hitsPerPage = undefined;
	    }
	    query = undefined;
	    queryParameters = undefined;
	  } else if (_typeof(arguments[0]) === 'object') {
	    // .browse(queryParameters)/.browse(queryParameters, cb)
	    if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	    }
	    queryParameters = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {
	    // .browse(query, cb)
	    callback = arguments[1];
	    queryParameters = undefined;
	  }
	
	  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)
	
	  // get search query parameters combining various possible calls
	  // to .browse();
	  queryParameters = merge({}, queryParameters || {}, {
	    page: page,
	    hitsPerPage: hitsPerPage,
	    query: query
	  });
	
	  var params = this.as._getSearchParams(queryParameters, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',
	    body: { params: params },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browseFrom('14lkfsakl32', callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browseFrom = function (cursor, callback) {
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',
	    body: { cursor: cursor },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Search for facet values
	* https://www.algolia.com/doc/rest-api/search#search-for-facet-values
	*
	* @param {string} params.facetName Facet name, name of the attribute to search for values in.
	* Must be declared as a facet
	* @param {string} params.facetQuery Query for the facet search
	* @param {string} [params.*] Any search parameter of Algolia,
	* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters
	* Pagination is not supported. The page and hitsPerPage parameters will be ignored.
	* @param callback (optional)
	*/
	IndexCore.prototype.searchForFacetValues = function (params, callback) {
	  var clone = __webpack_require__(24);
	  var omit = __webpack_require__(25);
	  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';
	
	  if (params.facetName === undefined || params.facetQuery === undefined) {
	    throw new Error(usage);
	  }
	
	  var facetName = params.facetName;
	  var filteredParams = omit(clone(params), function (keyName) {
	    return keyName === 'facetName';
	  });
	  var searchParameters = this.as._getSearchParams(filteredParams, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',
	    hostType: 'read',
	    body: { params: searchParameters },
	    callback: callback
	  });
	};
	
	IndexCore.prototype.searchFacet = deprecate(function (params, callback) {
	  return this.searchForFacetValues(params, callback);
	}, deprecatedMessage('index.searchFacet(params[, callback])', 'index.searchForFacetValues(params[, callback])'));
	
	IndexCore.prototype._search = function (params, url, callback, additionalUA) {
	  return this.as._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',
	    body: { params: params },
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/' + encodeURIComponent(this.indexName),
	      body: { params: params }
	    },
	    callback: callback,
	    additionalUA: additionalUA
	  });
	};
	
	/*
	* Get an object from this index
	*
	* @param objectID the unique identifier of the object to retrieve
	* @param attrs (optional) if set, contains the array of attribute names to retrieve
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the object to retrieve or the error message if a failure occured
	*/
	IndexCore.prototype.getObject = function (objectID, attrs, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attrs === 'function') {
	    callback = attrs;
	    attrs = undefined;
	  }
	
	  var params = '';
	  if (attrs !== undefined) {
	    params = '?attributes=';
	    for (var i = 0; i < attrs.length; ++i) {
	      if (i !== 0) {
	        params += ',';
	      }
	      params += attrs[i];
	    }
	  }
	
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Get several objects from this index
	*
	* @param objectIDs the array of unique identifier of objects to retrieve
	*/
	IndexCore.prototype.getObjects = function (objectIDs, attributesToRetrieve, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {
	    callback = attributesToRetrieve;
	    attributesToRetrieve = undefined;
	  }
	
	  var body = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      var request = {
	        indexName: indexObj.indexName,
	        objectID: objectID
	      };
	
	      if (attributesToRetrieve) {
	        request.attributesToRetrieve = attributesToRetrieve.join(',');
	      }
	
	      return request;
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/objects',
	    hostType: 'read',
	    body: body,
	    callback: callback
	  });
	};
	
	IndexCore.prototype.as = null;
	IndexCore.prototype.indexName = null;
	IndexCore.prototype.typeAheadArgs = null;
	IndexCore.prototype.typeAheadValueOption = null;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = buildSearchMethod;
	
	var errors = __webpack_require__(19);
	
	/**
	 * Creates a search method to be used in clients
	 * @param {string} queryParam the name of the attribute used for the query
	 * @param {string} url the url
	 * @return {function} the search method
	 */
	function buildSearchMethod(queryParam, url) {
	  /**
	   * The search method. Prepares the data and send the query to Algolia.
	   * @param {string} query the string used for query search
	   * @param {object} args additional parameters to send with the search
	   * @param {function} [callback] the callback to be called with the client gets the answer
	   * @return {undefined|Promise} If the callback is not provided then this methods returns a Promise
	   */
	  return function search(query, args, callback) {
	    // warn V2 users on how to search
	    if (typeof query === 'function' && (typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' || (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) === 'object') {
	      // .search(query, params, cb)
	      // .search(cb, params)
	      throw new errors.AlgoliaSearchError('index.search usage is index.search(query, params, cb)');
	    }
	
	    // Normalizing the function signature
	    if (arguments.length === 0 || typeof query === 'function') {
	      // Usage : .search(), .search(cb)
	      callback = query;
	      query = '';
	    } else if (arguments.length === 1 || typeof args === 'function') {
	      // Usage : .search(query/args), .search(query, cb)
	      callback = args;
	      args = undefined;
	    }
	    // At this point we have 3 arguments with values
	
	    // Usage : .search(args) // careful: typeof null === 'object'
	    if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object' && query !== null) {
	      args = query;
	      query = undefined;
	    } else if (query === undefined || query === null) {
	      // .search(undefined/null)
	      query = '';
	    }
	
	    var params = '';
	
	    if (query !== undefined) {
	      params += queryParam + '=' + encodeURIComponent(query);
	    }
	
	    var additionalUA;
	    if (args !== undefined) {
	      if (args.additionalUA) {
	        additionalUA = args.additionalUA;
	        delete args.additionalUA;
	      }
	      // `_getSearchParams` will augment params, do not be fooled by the = versus += from previous if
	      params = this.as._getSearchParams(args, params);
	    }
	
	    return this._search(params, url, callback, additionalUA);
	  };
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This file hosts our error definitions
	// We use custom error "types" so that we can act on them when we need it
	// e.g.: if error instanceof errors.UnparsableJSON then..
	
	var inherits = __webpack_require__(16);
	
	function AlgoliaSearchError(message, extraProperties) {
	  var forEach = __webpack_require__(20);
	
	  var error = this;
	
	  // try to get a stacktrace
	  if (typeof Error.captureStackTrace === 'function') {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    error.stack = new Error().stack || 'Cannot get a stacktrace, browser is too old';
	  }
	
	  this.name = 'AlgoliaSearchError';
	  this.message = message || 'Unknown error';
	
	  if (extraProperties) {
	    forEach(extraProperties, function addToErrorObject(value, key) {
	      error[key] = value;
	    });
	  }
	}
	
	inherits(AlgoliaSearchError, Error);
	
	function createCustomError(name, message) {
	  function AlgoliaSearchCustomError() {
	    var args = Array.prototype.slice.call(arguments, 0);
	
	    // custom message not set, use default
	    if (typeof args[0] !== 'string') {
	      args.unshift(message);
	    }
	
	    AlgoliaSearchError.apply(this, args);
	    this.name = 'AlgoliaSearch' + name + 'Error';
	  }
	
	  inherits(AlgoliaSearchCustomError, AlgoliaSearchError);
	
	  return AlgoliaSearchCustomError;
	}
	
	// late exports to let various fn defs and inherits take place
	module.exports = {
	  AlgoliaSearchError: AlgoliaSearchError,
	  UnparsableJSON: createCustomError('UnparsableJSON', 'Could not parse the incoming response as JSON, see err.more for details'),
	  RequestTimeout: createCustomError('RequestTimeout', 'Request timedout before getting a response'),
	  Network: createCustomError('Network', 'Network issue, see err.more for details'),
	  JSONPScriptFail: createCustomError('JSONPScriptFail', '<script> was loaded but did not call our provided callback'),
	  JSONPScriptError: createCustomError('JSONPScriptError', '<script> unable to load due to an `error` event on it'),
	  Unknown: createCustomError('Unknown', 'Unknown error occured')
	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = function forEach(obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function deprecate(fn, message) {
	  var warned = false;
	
	  function deprecated() {
	    if (!warned) {
	      /* eslint no-console:0 */
	      console.warn(message);
	      warned = true;
	    }
	
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function deprecatedMessage(previousUsage, newUsage) {
	  var githubAnchorLink = previousUsage.toLowerCase().replace(/[\.\(\)]/g, '');
	
	  return 'algoliasearch: `' + previousUsage + '` was replaced by `' + newUsage + '`. Please see https://github.com/algolia/algoliasearch-client-javascript/wiki/Deprecated#' + githubAnchorLink;
	};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var foreach = __webpack_require__(20);
	
	module.exports = function merge(destination /* , sources */) {
	  var sources = Array.prototype.slice.call(arguments);
	
	  foreach(sources, function (source) {
	    for (var keyName in source) {
	      if (source.hasOwnProperty(keyName)) {
	        if (_typeof(destination[keyName]) === 'object' && _typeof(source[keyName]) === 'object') {
	          destination[keyName] = merge({}, destination[keyName], source[keyName]);
	        } else if (source[keyName] !== undefined) {
	          destination[keyName] = source[keyName];
	        }
	      }
	    }
	  });
	
	  return destination;
	};

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function clone(obj) {
	  return JSON.parse(JSON.stringify(obj));
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = function omit(obj, test) {
	  var keys = __webpack_require__(26);
	  var foreach = __webpack_require__(20);
	
	  var filtered = {};
	
	  foreach(keys(obj), function doFilter(keyName) {
	    if (test(keyName) !== true) {
	      filtered[keyName] = obj[keyName];
	    }
	  });
	
	  return filtered;
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// modified from https://github.com/es-shims/es5-shim
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(27);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
	var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = function () {
		/* global window */
		if (typeof window === 'undefined') {
			return false;
		}
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}();
	var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};
	
	var keysShim = function keys(object) {
		var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];
	
		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}
	
		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}
	
		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}
	
		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	
			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
	
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2);
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};
	
	module.exports = keysShim;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toStr = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	'use strict';
	
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var foreach = __webpack_require__(20);
	
	module.exports = function map(arr, fn) {
	  var newArr = [];
	  foreach(arr, function (item, itemIndex) {
	    newArr.push(fn(item, itemIndex, arr));
	  });
	  return newArr;
	};

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	"use strict";
	
	// Parse cloud does not supports setTimeout
	// We do not store a setTimeout reference in the client everytime
	// We only fallback to a fake setTimeout when not available
	// setTimeout cannot be override globally sadly
	module.exports = function exitPromise(fn, _setTimeout) {
	  _setTimeout(fn, 0);
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This is the object returned by the `index.browseAll()` method
	
	module.exports = IndexBrowser;
	
	var inherits = __webpack_require__(16);
	var EventEmitter = __webpack_require__(32).EventEmitter;
	
	function IndexBrowser() {}
	
	inherits(IndexBrowser, EventEmitter);
	
	IndexBrowser.prototype.stop = function () {
	  this._stopped = true;
	  this._clean();
	};
	
	IndexBrowser.prototype._end = function () {
	  this.emit('end');
	  this._clean();
	};
	
	IndexBrowser.prototype._error = function (err) {
	  this.emit('error', err);
	  this._clean();
	};
	
	IndexBrowser.prototype._result = function (content) {
	  this.emit('result', content);
	};
	
	IndexBrowser.prototype._clean = function () {
	  this.removeAllListeners('stop');
	  this.removeAllListeners('end');
	  this.removeAllListeners('error');
	  this.removeAllListeners('result');
	};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function (type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events) this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler)) return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function (type, listener) {
	  var m;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events) this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function (type, listener) {
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function (type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type]) return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener || isFunction(list.listener) && list.listener === listener) {
	    delete this._events[type];
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0) return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function (type) {
	  var key, listeners;
	
	  if (!this._events) return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length) {
	      this.removeListener(type, listeners[listeners.length - 1]);
	    }
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function (type) {
	  var ret;
	  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function (type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function (emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = AlgoliaSearchCore;
	
	var errors = __webpack_require__(19);
	var exitPromise = __webpack_require__(30);
	var IndexCore = __webpack_require__(17);
	var store = __webpack_require__(34);
	
	// We will always put the API KEY in the JSON body in case of too long API KEY,
	// to avoid query string being too long and failing in various conditions (our server limit, browser limit,
	// proxies limit)
	var MAX_API_KEY_LENGTH = 500;
	var RESET_APP_DATA_TIMER = process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) || 60 * 2 * 1000; // after 2 minutes reset to first host
	
	/*
	 * Algolia Search library initialization
	 * https://www.algolia.com/
	 *
	 * @param {string} applicationID - Your applicationID, found in your dashboard
	 * @param {string} apiKey - Your API key, found in your dashboard
	 * @param {Object} [opts]
	 * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,
	 * another request will be issued after this timeout
	 * @param {string} [opts.protocol='http:'] - The protocol used to query Algolia Search API.
	 *                                        Set to 'https:' to force using https.
	 *                                        Default to document.location.protocol in browsers
	 * @param {Object|Array} [opts.hosts={
	 *           read: [this.applicationID + '-dsn.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]),
	 *           write: [this.applicationID + '.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]) - The hosts to use for Algolia Search API.
	 *           If you provide them, you will less benefit from our HA implementation
	 */
	function AlgoliaSearchCore(applicationID, apiKey, opts) {
	  var debug = __webpack_require__(35)('algoliasearch');
	
	  var clone = __webpack_require__(24);
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';
	
	  if (opts._allowEmptyCredentials !== true && !applicationID) {
	    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);
	  }
	
	  if (opts._allowEmptyCredentials !== true && !apiKey) {
	    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);
	  }
	
	  this.applicationID = applicationID;
	  this.apiKey = apiKey;
	
	  this.hosts = {
	    read: [],
	    write: []
	  };
	
	  opts = opts || {};
	
	  var protocol = opts.protocol || 'https:';
	  this._timeouts = opts.timeouts || {
	    connect: 1 * 1000, // 500ms connect is GPRS latency
	    read: 2 * 1000,
	    write: 30 * 1000
	  };
	
	  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before
	  if (opts.timeout) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;
	  }
	
	  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`
	  // we also accept `http` and `https`. It's a common error.
	  if (!/:$/.test(protocol)) {
	    protocol = protocol + ':';
	  }
	
	  if (opts.protocol !== 'http:' && opts.protocol !== 'https:') {
	    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');
	  }
	
	  this._checkAppIdData();
	
	  if (!opts.hosts) {
	    var defaultHosts = map(this._shuffleResult, function (hostNumber) {
	      return applicationID + '-' + hostNumber + '.algolianet.com';
	    });
	
	    // no hosts given, compute defaults
	    this.hosts.read = [this.applicationID + '-dsn.algolia.net'].concat(defaultHosts);
	    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);
	  } else if (isArray(opts.hosts)) {
	    // when passing custom hosts, we need to have a different host index if the number
	    // of write/read hosts are different.
	    this.hosts.read = clone(opts.hosts);
	    this.hosts.write = clone(opts.hosts);
	  } else {
	    this.hosts.read = clone(opts.hosts.read);
	    this.hosts.write = clone(opts.hosts.write);
	  }
	
	  // add protocol and lowercase hosts
	  this.hosts.read = map(this.hosts.read, prepareHost(protocol));
	  this.hosts.write = map(this.hosts.write, prepareHost(protocol));
	
	  this.extraHeaders = {};
	
	  // In some situations you might want to warm the cache
	  this.cache = opts._cache || {};
	
	  this._ua = opts._ua;
	  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;
	  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;
	
	  this._setTimeout = opts._setTimeout;
	
	  debug('init done, %j', this);
	}
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearchCore.prototype.initIndex = function (indexName) {
	  return new IndexCore(this, indexName);
	};
	
	/**
	* Add an extra field to the HTTP request
	*
	* @param name the header field name
	* @param value the header field value
	*/
	AlgoliaSearchCore.prototype.setExtraHeader = function (name, value) {
	  this.extraHeaders[name.toLowerCase()] = value;
	};
	
	/**
	* Get the value of an extra HTTP header
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.getExtraHeader = function (name) {
	  return this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Remove an extra field from the HTTP request
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.unsetExtraHeader = function (name) {
	  delete this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Augment sent x-algolia-agent with more data, each agent part
	* is automatically separated from the others by a semicolon;
	*
	* @param algoliaAgent the agent to add
	*/
	AlgoliaSearchCore.prototype.addAlgoliaAgent = function (algoliaAgent) {
	  if (this._ua.indexOf(';' + algoliaAgent) === -1) {
	    this._ua += ';' + algoliaAgent;
	  }
	};
	
	/*
	 * Wrapper that try all hosts to maximize the quality of service
	 */
	AlgoliaSearchCore.prototype._jsonRequest = function (initialOpts) {
	  this._checkAppIdData();
	
	  var requestDebug = __webpack_require__(35)('algoliasearch:' + initialOpts.url);
	
	  var body;
	  var additionalUA = initialOpts.additionalUA || '';
	  var cache = initialOpts.cache;
	  var client = this;
	  var tries = 0;
	  var usingFallback = false;
	  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;
	  var headers;
	
	  if (this.apiKey.length > MAX_API_KEY_LENGTH && initialOpts.body !== undefined && (initialOpts.body.params !== undefined || // index.search()
	  initialOpts.body.requests !== undefined) // client.search()
	  ) {
	      initialOpts.body.apiKey = this.apiKey;
	      headers = this._computeRequestHeaders(additionalUA, false);
	    } else {
	    headers = this._computeRequestHeaders(additionalUA);
	  }
	
	  if (initialOpts.body !== undefined) {
	    body = safeJSONStringify(initialOpts.body);
	  }
	
	  requestDebug('request start');
	  var debugData = [];
	
	  function doRequest(requester, reqOpts) {
	    client._checkAppIdData();
	
	    var startTime = new Date();
	    var cacheID;
	
	    if (client._useCache) {
	      cacheID = initialOpts.url;
	    }
	
	    // as we sometime use POST requests to pass parameters (like query='aa'),
	    // the cacheID must also include the body to be different between calls
	    if (client._useCache && body) {
	      cacheID += '_body_' + reqOpts.body;
	    }
	
	    // handle cache existence
	    if (client._useCache && cache && cache[cacheID] !== undefined) {
	      requestDebug('serving response from cache');
	      return client._promise.resolve(JSON.parse(cache[cacheID]));
	    }
	
	    // if we reached max tries
	    if (tries >= client.hosts[initialOpts.hostType].length) {
	      if (!hasFallback || usingFallback) {
	        requestDebug('could not get any response');
	        // then stop
	        return client._promise.reject(new errors.AlgoliaSearchError('Cannot connect to the AlgoliaSearch API.' + ' Send an email to support@algolia.com to report and resolve the issue.' + ' Application id was: ' + client.applicationID, { debugData: debugData }));
	      }
	
	      requestDebug('switching to fallback');
	
	      // let's try the fallback starting from here
	      tries = 0;
	
	      // method, url and body are fallback dependent
	      reqOpts.method = initialOpts.fallback.method;
	      reqOpts.url = initialOpts.fallback.url;
	      reqOpts.jsonBody = initialOpts.fallback.body;
	      if (reqOpts.jsonBody) {
	        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);
	      }
	      // re-compute headers, they could be omitting the API KEY
	      headers = client._computeRequestHeaders(additionalUA);
	
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      client._setHostIndexByType(0, initialOpts.hostType);
	      usingFallback = true; // the current request is now using fallback
	      return doRequest(client._request.fallback, reqOpts);
	    }
	
	    var currentHost = client._getHostByType(initialOpts.hostType);
	
	    var url = currentHost + reqOpts.url;
	    var options = {
	      body: reqOpts.body,
	      jsonBody: reqOpts.jsonBody,
	      method: reqOpts.method,
	      headers: headers,
	      timeouts: reqOpts.timeouts,
	      debug: requestDebug
	    };
	
	    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d', options.method, url, options.headers, options.timeouts);
	
	    if (requester === client._request.fallback) {
	      requestDebug('using fallback');
	    }
	
	    // `requester` is any of this._request or this._request.fallback
	    // thus it needs to be called using the client as context
	    return requester.call(client, url, options).then(success, tryFallback);
	
	    function success(httpResponse) {
	      // compute the status of the response,
	      //
	      // When in browser mode, using XDR or JSONP, we have no statusCode available
	      // So we rely on our API response `status` property.
	      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)
	      // So we check if there's a `message` along `status` and it means it's an error
	      //
	      // That's the only case where we have a response.status that's not the http statusCode
	      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||
	
	      // this is important to check the request statusCode AFTER the body eventual
	      // statusCode because some implementations (jQuery XDomainRequest transport) may
	      // send statusCode 200 while we had an error
	      httpResponse.statusCode ||
	
	      // When in browser mode, using XDR or JSONP
	      // we default to success when no error (no response.status && response.message)
	      // If there was a JSON.parse() error then body is null and it fails
	      httpResponse && httpResponse.body && 200;
	
	      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j', httpResponse.statusCode, status, httpResponse.headers);
	
	      var httpResponseOk = Math.floor(status / 100) === 2;
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime,
	        statusCode: status
	      });
	
	      if (httpResponseOk) {
	        if (client._useCache && cache) {
	          cache[cacheID] = httpResponse.responseText;
	        }
	
	        return httpResponse.body;
	      }
	
	      var shouldRetry = Math.floor(status / 100) !== 4;
	
	      if (shouldRetry) {
	        tries += 1;
	        return retryRequest();
	      }
	
	      requestDebug('unrecoverable error');
	
	      // no success and no retry => fail
	      var unrecoverableError = new errors.AlgoliaSearchError(httpResponse.body && httpResponse.body.message, { debugData: debugData, statusCode: status });
	
	      return client._promise.reject(unrecoverableError);
	    }
	
	    function tryFallback(err) {
	      // error cases:
	      //  While not in fallback mode:
	      //    - CORS not supported
	      //    - network error
	      //  While in fallback mode:
	      //    - timeout
	      //    - network error
	      //    - badly formatted JSONP (script loaded, did not call our callback)
	      //  In both cases:
	      //    - uncaught exception occurs (TypeError)
	      requestDebug('error: %s, stack: %s', err.message, err.stack);
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime
	      });
	
	      if (!(err instanceof errors.AlgoliaSearchError)) {
	        err = new errors.Unknown(err && err.message, err);
	      }
	
	      tries += 1;
	
	      // stop the request implementation when:
	      if (
	      // we did not generate this error,
	      // it comes from a throw in some other piece of code
	      err instanceof errors.Unknown ||
	
	      // server sent unparsable JSON
	      err instanceof errors.UnparsableJSON ||
	
	      // max tries and already using fallback or no fallback
	      tries >= client.hosts[initialOpts.hostType].length && (usingFallback || !hasFallback)) {
	        // stop request implementation for this command
	        err.debugData = debugData;
	        return client._promise.reject(err);
	      }
	
	      // When a timeout occured, retry by raising timeout
	      if (err instanceof errors.RequestTimeout) {
	        return retryRequestWithHigherTimeout();
	      }
	
	      return retryRequest();
	    }
	
	    function retryRequest() {
	      requestDebug('retrying request');
	      client._incrementHostIndex(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	
	    function retryRequestWithHigherTimeout() {
	      requestDebug('retrying request with higher timeout');
	      client._incrementHostIndex(initialOpts.hostType);
	      client._incrementTimeoutMultipler();
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	  }
	
	  var promise = doRequest(client._request, {
	    url: initialOpts.url,
	    method: initialOpts.method,
	    body: body,
	    jsonBody: initialOpts.body,
	    timeouts: client._getTimeoutsForRequest(initialOpts.hostType)
	  });
	
	  // either we have a callback
	  // either we are using promises
	  if (typeof initialOpts.callback === 'function') {
	    promise.then(function okCb(content) {
	      exitPromise(function () {
	        initialOpts.callback(null, content);
	      }, client._setTimeout || setTimeout);
	    }, function nookCb(err) {
	      exitPromise(function () {
	        initialOpts.callback(err);
	      }, client._setTimeout || setTimeout);
	    });
	  } else {
	    return promise;
	  }
	};
	
	/*
	* Transform search param object in query string
	* @param {object} args arguments to add to the current query string
	* @param {string} params current query string
	* @return {string} the final query string
	*/
	AlgoliaSearchCore.prototype._getSearchParams = function (args, params) {
	  if (args === undefined || args === null) {
	    return params;
	  }
	  for (var key in args) {
	    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {
	      params += params === '' ? '' : '&';
	      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);
	    }
	  }
	  return params;
	};
	
	AlgoliaSearchCore.prototype._computeRequestHeaders = function (additionalUA, withAPIKey) {
	  var forEach = __webpack_require__(20);
	
	  var ua = additionalUA ? this._ua + ';' + additionalUA : this._ua;
	
	  var requestHeaders = {
	    'x-algolia-agent': ua,
	    'x-algolia-application-id': this.applicationID
	  };
	
	  // browser will inline headers in the url, node.js will use http headers
	  // but in some situations, the API KEY will be too long (big secured API keys)
	  // so if the request is a POST and the KEY is very long, we will be asked to not put
	  // it into headers but in the JSON body
	  if (withAPIKey !== false) {
	    requestHeaders['x-algolia-api-key'] = this.apiKey;
	  }
	
	  if (this.userToken) {
	    requestHeaders['x-algolia-usertoken'] = this.userToken;
	  }
	
	  if (this.securityTags) {
	    requestHeaders['x-algolia-tagfilters'] = this.securityTags;
	  }
	
	  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {
	    requestHeaders[key] = value;
	  });
	
	  return requestHeaders;
	};
	
	/**
	 * Search through multiple indices at the same time
	 * @param  {Object[]}   queries  An array of queries you want to run.
	 * @param {string} queries[].indexName The index name you want to target
	 * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`
	 * @param {Object} queries[].params Any search param like hitsPerPage, ..
	 * @param  {Function} callback Callback to be called
	 * @return {Promise|undefined} Returns a promise if no callback given
	 */
	AlgoliaSearchCore.prototype.search = function (queries, opts, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: client.search(arrayOfQueries[, callback])';
	
	  if (!isArray(queries)) {
	    throw new Error(usage);
	  }
	
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var client = this;
	
	  var postObj = {
	    requests: map(queries, function prepareRequest(query) {
	      var params = '';
	
	      // allow query.query
	      // so we are mimicing the index.search(query, params) method
	      // {indexName:, query:, params:}
	      if (query.query !== undefined) {
	        params += 'query=' + encodeURIComponent(query.query);
	      }
	
	      return {
	        indexName: query.indexName,
	        params: client._getSearchParams(query.params, params)
	      };
	    })
	  };
	
	  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {
	    return requestId + '=' + encodeURIComponent('/1/indexes/' + encodeURIComponent(request.indexName) + '?' + request.params);
	  }).join('&');
	
	  var url = '/1/indexes/*/queries';
	
	  if (opts.strategy !== undefined) {
	    url += '?strategy=' + opts.strategy;
	  }
	
	  return this._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url,
	    body: postObj,
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/*',
	      body: {
	        params: JSONPParams
	      }
	    },
	    callback: callback
	  });
	};
	
	/**
	 * Set the extra security tagFilters header
	 * @param {string|array} tags The list of tags defining the current security filters
	 */
	AlgoliaSearchCore.prototype.setSecurityTags = function (tags) {
	  if (Object.prototype.toString.call(tags) === '[object Array]') {
	    var strTags = [];
	    for (var i = 0; i < tags.length; ++i) {
	      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {
	        var oredTags = [];
	        for (var j = 0; j < tags[i].length; ++j) {
	          oredTags.push(tags[i][j]);
	        }
	        strTags.push('(' + oredTags.join(',') + ')');
	      } else {
	        strTags.push(tags[i]);
	      }
	    }
	    tags = strTags.join(',');
	  }
	
	  this.securityTags = tags;
	};
	
	/**
	 * Set the extra user token header
	 * @param {string} userToken The token identifying a uniq user (used to apply rate limits)
	 */
	AlgoliaSearchCore.prototype.setUserToken = function (userToken) {
	  this.userToken = userToken;
	};
	
	/**
	 * Clear all queries in client's cache
	 * @return undefined
	 */
	AlgoliaSearchCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/**
	* Set the number of milliseconds a request can take before automatically being terminated.
	* @deprecated
	* @param {Number} milliseconds
	*/
	AlgoliaSearchCore.prototype.setRequestTimeout = function (milliseconds) {
	  if (milliseconds) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;
	  }
	};
	
	/**
	* Set the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.setTimeouts = function (timeouts) {
	  this._timeouts = timeouts;
	};
	
	/**
	* Get the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.getTimeouts = function () {
	  return this._timeouts;
	};
	
	AlgoliaSearchCore.prototype._getAppIdData = function () {
	  var data = store.get(this.applicationID);
	  if (data !== null) this._cacheAppIdData(data);
	  return data;
	};
	
	AlgoliaSearchCore.prototype._setAppIdData = function (data) {
	  data.lastChange = new Date().getTime();
	  this._cacheAppIdData(data);
	  return store.set(this.applicationID, data);
	};
	
	AlgoliaSearchCore.prototype._checkAppIdData = function () {
	  var data = this._getAppIdData();
	  var now = new Date().getTime();
	  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {
	    return this._resetInitialAppIdData(data);
	  }
	
	  return data;
	};
	
	AlgoliaSearchCore.prototype._resetInitialAppIdData = function (data) {
	  var newData = data || {};
	  newData.hostIndexes = { read: 0, write: 0 };
	  newData.timeoutMultiplier = 1;
	  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);
	  return this._setAppIdData(newData);
	};
	
	AlgoliaSearchCore.prototype._cacheAppIdData = function (data) {
	  this._hostIndexes = data.hostIndexes;
	  this._timeoutMultiplier = data.timeoutMultiplier;
	  this._shuffleResult = data.shuffleResult;
	};
	
	AlgoliaSearchCore.prototype._partialAppIdDataUpdate = function (newData) {
	  var foreach = __webpack_require__(20);
	  var currentData = this._getAppIdData();
	  foreach(newData, function (value, key) {
	    currentData[key] = value;
	  });
	
	  return this._setAppIdData(currentData);
	};
	
	AlgoliaSearchCore.prototype._getHostByType = function (hostType) {
	  return this.hosts[hostType][this._getHostIndexByType(hostType)];
	};
	
	AlgoliaSearchCore.prototype._getTimeoutMultiplier = function () {
	  return this._timeoutMultiplier;
	};
	
	AlgoliaSearchCore.prototype._getHostIndexByType = function (hostType) {
	  return this._hostIndexes[hostType];
	};
	
	AlgoliaSearchCore.prototype._setHostIndexByType = function (hostIndex, hostType) {
	  var clone = __webpack_require__(24);
	  var newHostIndexes = clone(this._hostIndexes);
	  newHostIndexes[hostType] = hostIndex;
	  this._partialAppIdDataUpdate({ hostIndexes: newHostIndexes });
	  return hostIndex;
	};
	
	AlgoliaSearchCore.prototype._incrementHostIndex = function (hostType) {
	  return this._setHostIndexByType((this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType);
	};
	
	AlgoliaSearchCore.prototype._incrementTimeoutMultipler = function () {
	  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);
	  return this._partialAppIdDataUpdate({ timeoutMultiplier: timeoutMultiplier });
	};
	
	AlgoliaSearchCore.prototype._getTimeoutsForRequest = function (hostType) {
	  return {
	    connect: this._timeouts.connect * this._timeoutMultiplier,
	    complete: this._timeouts[hostType] * this._timeoutMultiplier
	  };
	};
	
	function prepareHost(protocol) {
	  return function prepare(host) {
	    return protocol + '//' + host.toLowerCase();
	  };
	}
	
	// Prototype.js < 1.7, a widely used library, defines a weird
	// Array.prototype.toJSON function that will fail to stringify our content
	// appropriately
	// refs:
	//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q
	//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c
	//   - http://stackoverflow.com/a/3148441/147079
	function safeJSONStringify(obj) {
	  /* eslint no-extend-native:0 */
	
	  if (Array.prototype.toJSON === undefined) {
	    return JSON.stringify(obj);
	  }
	
	  var toJSON = Array.prototype.toJSON;
	  delete Array.prototype.toJSON;
	  var out = JSON.stringify(obj);
	  Array.prototype.toJSON = toJSON;
	
	  return out;
	}
	
	function shuffle(array) {
	  var currentIndex = array.length;
	  var temporaryValue;
	  var randomIndex;
	
	  // While there remain elements to shuffle...
	  while (currentIndex !== 0) {
	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex -= 1;
	
	    // And swap it with the current element.
	    temporaryValue = array[currentIndex];
	    array[currentIndex] = array[randomIndex];
	    array[randomIndex] = temporaryValue;
	  }
	
	  return array;
	}
	
	function removeCredentials(headers) {
	  var newHeaders = {};
	
	  for (var headerName in headers) {
	    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {
	      var value;
	
	      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {
	        value = '**hidden for security purposes**';
	      } else {
	        value = headers[headerName];
	      }
	
	      newHeaders[headerName] = value;
	    }
	  }
	
	  return newHeaders;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var debug = __webpack_require__(35)('algoliasearch:src/hostIndexState.js');
	var localStorageNamespace = 'algoliasearch-client-js';
	
	var store;
	var moduleStore = {
	  state: {},
	  set: function set(key, data) {
	    this.state[key] = data;
	    return this.state[key];
	  },
	  get: function get(key) {
	    return this.state[key] || null;
	  }
	};
	
	var localStorageStore = {
	  set: function set(key, data) {
	    moduleStore.set(key, data); // always replicate localStorageStore to moduleStore in case of failure
	
	    try {
	      var namespace = JSON.parse(global.localStorage[localStorageNamespace]);
	      namespace[key] = data;
	      global.localStorage[localStorageNamespace] = JSON.stringify(namespace);
	      return namespace[key];
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  },
	  get: function get(key) {
	    try {
	      return JSON.parse(global.localStorage[localStorageNamespace])[key] || null;
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  }
	};
	
	function localStorageFailure(key, e) {
	  debug('localStorage failed with', e);
	  cleanup();
	  store = moduleStore;
	  return store.get(key);
	}
	
	store = supportsLocalStorage() ? localStorageStore : moduleStore;
	
	module.exports = {
	  get: getOrSet,
	  set: getOrSet,
	  supportsLocalStorage: supportsLocalStorage
	};
	
	function getOrSet(key, data) {
	  if (arguments.length === 1) {
	    return store.get(key);
	  }
	
	  return store.set(key, data);
	}
	
	function supportsLocalStorage() {
	  try {
	    if ('localStorage' in global && global.localStorage !== null) {
	      if (!global.localStorage[localStorageNamespace]) {
	        // actual creation of the namespace
	        global.localStorage.setItem(localStorageNamespace, JSON.stringify({}));
	      }
	      return true;
	    }
	
	    return false;
	  } catch (_) {
	    return false;
	  }
	}
	
	// In case of any error on localStorage, we clean our own namespace, this should handle
	// quota errors when a lot of keys + data are used
	function cleanup() {
	  try {
	    global.localStorage.removeItem(localStorageNamespace);
	  } catch (_) {
	    // nothing to do
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(36);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
	  // double check webkit in userAgent just in case we are in a worker
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(37);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0,
	      i;
	
	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var global = __webpack_require__(39);
	var Promise = global.Promise || __webpack_require__(40).Promise;
	
	// This is the standalone browser build entry point
	// Browser implementation of the Algolia Search JavaScript client,
	// using XMLHttpRequest, XDomainRequest and JSONP as fallback
	module.exports = function createAlgoliasearch(AlgoliaSearch, uaSuffix) {
	  var inherits = __webpack_require__(16);
	  var errors = __webpack_require__(19);
	  var inlineHeaders = __webpack_require__(42);
	  var jsonpRequest = __webpack_require__(44);
	  var places = __webpack_require__(45);
	  uaSuffix = uaSuffix || '';
	
	  if (process.env.NODE_ENV === 'debug') {
	    __webpack_require__(35).enable('algoliasearch*');
	  }
	
	  function algoliasearch(applicationID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    var getDocumentProtocol = __webpack_require__(46);
	
	    opts = cloneDeep(opts || {});
	
	    if (opts.protocol === undefined) {
	      opts.protocol = getDocumentProtocol();
	    }
	
	    opts._ua = opts._ua || algoliasearch.ua;
	
	    return new AlgoliaSearchBrowser(applicationID, apiKey, opts);
	  }
	
	  algoliasearch.version = __webpack_require__(47);
	  algoliasearch.ua = 'Algolia for vanilla JavaScript ' + uaSuffix + algoliasearch.version;
	  algoliasearch.initPlaces = places(algoliasearch);
	
	  // we expose into window no matter how we are used, this will allow
	  // us to easily debug any website running algolia
	  global.__algolia = {
	    debug: __webpack_require__(35),
	    algoliasearch: algoliasearch
	  };
	
	  var support = {
	    hasXMLHttpRequest: 'XMLHttpRequest' in global,
	    hasXDomainRequest: 'XDomainRequest' in global
	  };
	
	  if (support.hasXMLHttpRequest) {
	    support.cors = 'withCredentials' in new XMLHttpRequest();
	  }
	
	  function AlgoliaSearchBrowser() {
	    // call AlgoliaSearch constructor
	    AlgoliaSearch.apply(this, arguments);
	  }
	
	  inherits(AlgoliaSearchBrowser, AlgoliaSearch);
	
	  AlgoliaSearchBrowser.prototype._request = function request(url, opts) {
	    return new Promise(function wrapRequest(resolve, reject) {
	      // no cors or XDomainRequest, no request
	      if (!support.cors && !support.hasXDomainRequest) {
	        // very old browser, not supported
	        reject(new errors.Network('CORS not supported'));
	        return;
	      }
	
	      url = inlineHeaders(url, opts.headers);
	
	      var body = opts.body;
	      var req = support.cors ? new XMLHttpRequest() : new XDomainRequest();
	      var reqTimeout;
	      var timedOut;
	      var connected = false;
	
	      reqTimeout = setTimeout(onTimeout, opts.timeouts.connect);
	      // we set an empty onprogress listener
	      // so that XDomainRequest on IE9 is not aborted
	      // refs:
	      //  - https://github.com/algolia/algoliasearch-client-js/issues/76
	      //  - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
	      req.onprogress = onProgress;
	      if ('onreadystatechange' in req) req.onreadystatechange = onReadyStateChange;
	      req.onload = onLoad;
	      req.onerror = onError;
	
	      // do not rely on default XHR async flag, as some analytics code like hotjar
	      // breaks it and set it to false by default
	      if (req instanceof XMLHttpRequest) {
	        req.open(opts.method, url, true);
	      } else {
	        req.open(opts.method, url);
	      }
	
	      // headers are meant to be sent after open
	      if (support.cors) {
	        if (body) {
	          if (opts.method === 'POST') {
	            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests
	            req.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
	          } else {
	            req.setRequestHeader('content-type', 'application/json');
	          }
	        }
	        req.setRequestHeader('accept', 'application/json');
	      }
	
	      req.send(body);
	
	      // event object not received in IE8, at least
	      // but we do not use it, still important to note
	      function onLoad() /* event */{
	        // When browser does not supports req.timeout, we can
	        // have both a load and timeout event, since handled by a dumb setTimeout
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        var out;
	
	        try {
	          out = {
	            body: JSON.parse(req.responseText),
	            responseText: req.responseText,
	            statusCode: req.status,
	            // XDomainRequest does not have any response headers
	            headers: req.getAllResponseHeaders && req.getAllResponseHeaders() || {}
	          };
	        } catch (e) {
	          out = new errors.UnparsableJSON({
	            more: req.responseText
	          });
	        }
	
	        if (out instanceof errors.UnparsableJSON) {
	          reject(out);
	        } else {
	          resolve(out);
	        }
	      }
	
	      function onError(event) {
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        // error event is trigerred both with XDR/XHR on:
	        //   - DNS error
	        //   - unallowed cross domain request
	        reject(new errors.Network({
	          more: event
	        }));
	      }
	
	      function onTimeout() {
	        timedOut = true;
	        req.abort();
	
	        reject(new errors.RequestTimeout());
	      }
	
	      function onConnect() {
	        connected = true;
	        clearTimeout(reqTimeout);
	        reqTimeout = setTimeout(onTimeout, opts.timeouts.complete);
	      }
	
	      function onProgress() {
	        if (!connected) onConnect();
	      }
	
	      function onReadyStateChange() {
	        if (!connected && req.readyState > 1) onConnect();
	      }
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._request.fallback = function requestFallback(url, opts) {
	    url = inlineHeaders(url, opts.headers);
	
	    return new Promise(function wrapJsonpRequest(resolve, reject) {
	      jsonpRequest(url, opts, function jsonpRequestDone(err, content) {
	        if (err) {
	          reject(err);
	          return;
	        }
	
	        resolve(content);
	      });
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._promise = {
	    reject: function rejectPromise(val) {
	      return Promise.reject(val);
	    },
	    resolve: function resolvePromise(val) {
	      return Promise.resolve(val);
	    },
	    delay: function delayPromise(ms) {
	      return new Promise(function resolveOnTimeout(resolve /* , reject*/) {
	        setTimeout(resolve, ms);
	      });
	    }
	  };
	
	  return algoliasearch;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var win;
	
	if (typeof window !== "undefined") {
	    win = window;
	} else if (typeof global !== "undefined") {
	    win = global;
	} else if (typeof self !== "undefined") {
	    win = self;
	} else {
	    win = {};
	}
	
	module.exports = win;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.1.1
	 */
	
	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.ES6Promise = factory();
	})(undefined, function () {
	  'use strict';
	
	  function objectOrFunction(x) {
	    var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);
	    return x !== null && (type === 'object' || type === 'function');
	  }
	
	  function isFunction(x) {
	    return typeof x === 'function';
	  }
	
	  var _isArray = undefined;
	  if (Array.isArray) {
	    _isArray = Array.isArray;
	  } else {
	    _isArray = function _isArray(x) {
	      return Object.prototype.toString.call(x) === '[object Array]';
	    };
	  }
	
	  var isArray = _isArray;
	
	  var len = 0;
	  var vertxNext = undefined;
	  var customSchedulerFn = undefined;
	
	  var asap = function asap(callback, arg) {
	    queue[len] = callback;
	    queue[len + 1] = arg;
	    len += 2;
	    if (len === 2) {
	      // If len is 2, that means that we need to schedule an async flush.
	      // If additional callbacks are queued before the queue is flushed, they
	      // will be processed by this flush that we are scheduling.
	      if (customSchedulerFn) {
	        customSchedulerFn(flush);
	      } else {
	        scheduleFlush();
	      }
	    }
	  };
	
	  function setScheduler(scheduleFn) {
	    customSchedulerFn = scheduleFn;
	  }
	
	  function setAsap(asapFn) {
	    asap = asapFn;
	  }
	
	  var browserWindow = typeof window !== 'undefined' ? window : undefined;
	  var browserGlobal = browserWindow || {};
	  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	  // test for web worker but not in IE10
	  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	  // node
	  function useNextTick() {
	    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	    // see https://github.com/cujojs/when/issues/410 for details
	    return function () {
	      return process.nextTick(flush);
	    };
	  }
	
	  // vertx
	  function useVertxTimer() {
	    if (typeof vertxNext !== 'undefined') {
	      return function () {
	        vertxNext(flush);
	      };
	    }
	
	    return useSetTimeout();
	  }
	
	  function useMutationObserver() {
	    var iterations = 0;
	    var observer = new BrowserMutationObserver(flush);
	    var node = document.createTextNode('');
	    observer.observe(node, { characterData: true });
	
	    return function () {
	      node.data = iterations = ++iterations % 2;
	    };
	  }
	
	  // web worker
	  function useMessageChannel() {
	    var channel = new MessageChannel();
	    channel.port1.onmessage = flush;
	    return function () {
	      return channel.port2.postMessage(0);
	    };
	  }
	
	  function useSetTimeout() {
	    // Store setTimeout reference so es6-promise will be unaffected by
	    // other code modifying setTimeout (like sinon.useFakeTimers())
	    var globalSetTimeout = setTimeout;
	    return function () {
	      return globalSetTimeout(flush, 1);
	    };
	  }
	
	  var queue = new Array(1000);
	  function flush() {
	    for (var i = 0; i < len; i += 2) {
	      var callback = queue[i];
	      var arg = queue[i + 1];
	
	      callback(arg);
	
	      queue[i] = undefined;
	      queue[i + 1] = undefined;
	    }
	
	    len = 0;
	  }
	
	  function attemptVertx() {
	    try {
	      var r = require;
	      var vertx = __webpack_require__(41);
	      vertxNext = vertx.runOnLoop || vertx.runOnContext;
	      return useVertxTimer();
	    } catch (e) {
	      return useSetTimeout();
	    }
	  }
	
	  var scheduleFlush = undefined;
	  // Decide what async method to use to triggering processing of queued callbacks:
	  if (isNode) {
	    scheduleFlush = useNextTick();
	  } else if (BrowserMutationObserver) {
	    scheduleFlush = useMutationObserver();
	  } else if (isWorker) {
	    scheduleFlush = useMessageChannel();
	  } else if (browserWindow === undefined && "function" === 'function') {
	    scheduleFlush = attemptVertx();
	  } else {
	    scheduleFlush = useSetTimeout();
	  }
	
	  function then(onFulfillment, onRejection) {
	    var _arguments = arguments;
	
	    var parent = this;
	
	    var child = new this.constructor(noop);
	
	    if (child[PROMISE_ID] === undefined) {
	      makePromise(child);
	    }
	
	    var _state = parent._state;
	
	    if (_state) {
	      (function () {
	        var callback = _arguments[_state - 1];
	        asap(function () {
	          return invokeCallback(_state, child, callback, parent._result);
	        });
	      })();
	    } else {
	      subscribe(parent, child, onFulfillment, onRejection);
	    }
	
	    return child;
	  }
	
	  /**
	    `Promise.resolve` returns a promise that will become resolved with the
	    passed `value`. It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      resolve(1);
	    });
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.resolve(1);
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    @method resolve
	    @static
	    @param {Any} value value that the returned promise will be resolved with
	    Useful for tooling.
	    @return {Promise} a promise that will become fulfilled with the given
	    `value`
	  */
	  function resolve$1(object) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
	      return object;
	    }
	
	    var promise = new Constructor(noop);
	    resolve(promise, object);
	    return promise;
	  }
	
	  var PROMISE_ID = Math.random().toString(36).substring(16);
	
	  function noop() {}
	
	  var PENDING = void 0;
	  var FULFILLED = 1;
	  var REJECTED = 2;
	
	  var GET_THEN_ERROR = new ErrorObject();
	
	  function selfFulfillment() {
	    return new TypeError("You cannot resolve a promise with itself");
	  }
	
	  function cannotReturnOwn() {
	    return new TypeError('A promises callback cannot return that same promise.');
	  }
	
	  function getThen(promise) {
	    try {
	      return promise.then;
	    } catch (error) {
	      GET_THEN_ERROR.error = error;
	      return GET_THEN_ERROR;
	    }
	  }
	
	  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
	    try {
	      then$$1.call(value, fulfillmentHandler, rejectionHandler);
	    } catch (e) {
	      return e;
	    }
	  }
	
	  function handleForeignThenable(promise, thenable, then$$1) {
	    asap(function (promise) {
	      var sealed = false;
	      var error = tryThen(then$$1, thenable, function (value) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	        if (thenable !== value) {
	          resolve(promise, value);
	        } else {
	          fulfill(promise, value);
	        }
	      }, function (reason) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	
	        reject(promise, reason);
	      }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	      if (!sealed && error) {
	        sealed = true;
	        reject(promise, error);
	      }
	    }, promise);
	  }
	
	  function handleOwnThenable(promise, thenable) {
	    if (thenable._state === FULFILLED) {
	      fulfill(promise, thenable._result);
	    } else if (thenable._state === REJECTED) {
	      reject(promise, thenable._result);
	    } else {
	      subscribe(thenable, undefined, function (value) {
	        return resolve(promise, value);
	      }, function (reason) {
	        return reject(promise, reason);
	      });
	    }
	  }
	
	  function handleMaybeThenable(promise, maybeThenable, then$$1) {
	    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
	      handleOwnThenable(promise, maybeThenable);
	    } else {
	      if (then$$1 === GET_THEN_ERROR) {
	        reject(promise, GET_THEN_ERROR.error);
	        GET_THEN_ERROR.error = null;
	      } else if (then$$1 === undefined) {
	        fulfill(promise, maybeThenable);
	      } else if (isFunction(then$$1)) {
	        handleForeignThenable(promise, maybeThenable, then$$1);
	      } else {
	        fulfill(promise, maybeThenable);
	      }
	    }
	  }
	
	  function resolve(promise, value) {
	    if (promise === value) {
	      reject(promise, selfFulfillment());
	    } else if (objectOrFunction(value)) {
	      handleMaybeThenable(promise, value, getThen(value));
	    } else {
	      fulfill(promise, value);
	    }
	  }
	
	  function publishRejection(promise) {
	    if (promise._onerror) {
	      promise._onerror(promise._result);
	    }
	
	    publish(promise);
	  }
	
	  function fulfill(promise, value) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	
	    promise._result = value;
	    promise._state = FULFILLED;
	
	    if (promise._subscribers.length !== 0) {
	      asap(publish, promise);
	    }
	  }
	
	  function reject(promise, reason) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	    promise._state = REJECTED;
	    promise._result = reason;
	
	    asap(publishRejection, promise);
	  }
	
	  function subscribe(parent, child, onFulfillment, onRejection) {
	    var _subscribers = parent._subscribers;
	    var length = _subscribers.length;
	
	    parent._onerror = null;
	
	    _subscribers[length] = child;
	    _subscribers[length + FULFILLED] = onFulfillment;
	    _subscribers[length + REJECTED] = onRejection;
	
	    if (length === 0 && parent._state) {
	      asap(publish, parent);
	    }
	  }
	
	  function publish(promise) {
	    var subscribers = promise._subscribers;
	    var settled = promise._state;
	
	    if (subscribers.length === 0) {
	      return;
	    }
	
	    var child = undefined,
	        callback = undefined,
	        detail = promise._result;
	
	    for (var i = 0; i < subscribers.length; i += 3) {
	      child = subscribers[i];
	      callback = subscribers[i + settled];
	
	      if (child) {
	        invokeCallback(settled, child, callback, detail);
	      } else {
	        callback(detail);
	      }
	    }
	
	    promise._subscribers.length = 0;
	  }
	
	  function ErrorObject() {
	    this.error = null;
	  }
	
	  var TRY_CATCH_ERROR = new ErrorObject();
	
	  function tryCatch(callback, detail) {
	    try {
	      return callback(detail);
	    } catch (e) {
	      TRY_CATCH_ERROR.error = e;
	      return TRY_CATCH_ERROR;
	    }
	  }
	
	  function invokeCallback(settled, promise, callback, detail) {
	    var hasCallback = isFunction(callback),
	        value = undefined,
	        error = undefined,
	        succeeded = undefined,
	        failed = undefined;
	
	    if (hasCallback) {
	      value = tryCatch(callback, detail);
	
	      if (value === TRY_CATCH_ERROR) {
	        failed = true;
	        error = value.error;
	        value.error = null;
	      } else {
	        succeeded = true;
	      }
	
	      if (promise === value) {
	        reject(promise, cannotReturnOwn());
	        return;
	      }
	    } else {
	      value = detail;
	      succeeded = true;
	    }
	
	    if (promise._state !== PENDING) {
	      // noop
	    } else if (hasCallback && succeeded) {
	      resolve(promise, value);
	    } else if (failed) {
	      reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      reject(promise, value);
	    }
	  }
	
	  function initializePromise(promise, resolver) {
	    try {
	      resolver(function resolvePromise(value) {
	        resolve(promise, value);
	      }, function rejectPromise(reason) {
	        reject(promise, reason);
	      });
	    } catch (e) {
	      reject(promise, e);
	    }
	  }
	
	  var id = 0;
	  function nextId() {
	    return id++;
	  }
	
	  function makePromise(promise) {
	    promise[PROMISE_ID] = id++;
	    promise._state = undefined;
	    promise._result = undefined;
	    promise._subscribers = [];
	  }
	
	  function Enumerator$1(Constructor, input) {
	    this._instanceConstructor = Constructor;
	    this.promise = new Constructor(noop);
	
	    if (!this.promise[PROMISE_ID]) {
	      makePromise(this.promise);
	    }
	
	    if (isArray(input)) {
	      this.length = input.length;
	      this._remaining = input.length;
	
	      this._result = new Array(this.length);
	
	      if (this.length === 0) {
	        fulfill(this.promise, this._result);
	      } else {
	        this.length = this.length || 0;
	        this._enumerate(input);
	        if (this._remaining === 0) {
	          fulfill(this.promise, this._result);
	        }
	      }
	    } else {
	      reject(this.promise, validationError());
	    }
	  }
	
	  function validationError() {
	    return new Error('Array Methods must be provided an Array');
	  }
	
	  Enumerator$1.prototype._enumerate = function (input) {
	    for (var i = 0; this._state === PENDING && i < input.length; i++) {
	      this._eachEntry(input[i], i);
	    }
	  };
	
	  Enumerator$1.prototype._eachEntry = function (entry, i) {
	    var c = this._instanceConstructor;
	    var resolve$$1 = c.resolve;
	
	    if (resolve$$1 === resolve$1) {
	      var _then = getThen(entry);
	
	      if (_then === then && entry._state !== PENDING) {
	        this._settledAt(entry._state, i, entry._result);
	      } else if (typeof _then !== 'function') {
	        this._remaining--;
	        this._result[i] = entry;
	      } else if (c === Promise$2) {
	        var promise = new c(noop);
	        handleMaybeThenable(promise, entry, _then);
	        this._willSettleAt(promise, i);
	      } else {
	        this._willSettleAt(new c(function (resolve$$1) {
	          return resolve$$1(entry);
	        }), i);
	      }
	    } else {
	      this._willSettleAt(resolve$$1(entry), i);
	    }
	  };
	
	  Enumerator$1.prototype._settledAt = function (state, i, value) {
	    var promise = this.promise;
	
	    if (promise._state === PENDING) {
	      this._remaining--;
	
	      if (state === REJECTED) {
	        reject(promise, value);
	      } else {
	        this._result[i] = value;
	      }
	    }
	
	    if (this._remaining === 0) {
	      fulfill(promise, this._result);
	    }
	  };
	
	  Enumerator$1.prototype._willSettleAt = function (promise, i) {
	    var enumerator = this;
	
	    subscribe(promise, undefined, function (value) {
	      return enumerator._settledAt(FULFILLED, i, value);
	    }, function (reason) {
	      return enumerator._settledAt(REJECTED, i, reason);
	    });
	  };
	
	  /**
	    `Promise.all` accepts an array of promises, and returns a new promise which
	    is fulfilled with an array of fulfillment values for the passed promises, or
	    rejected with the reason of the first passed promise to be rejected. It casts all
	    elements of the passed iterable to promises as it runs this algorithm.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = resolve(2);
	    let promise3 = resolve(3);
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // The array here would be [ 1, 2, 3 ];
	    });
	    ```
	  
	    If any of the `promises` given to `all` are rejected, the first promise
	    that is rejected will be given as an argument to the returned promises's
	    rejection handler. For example:
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = reject(new Error("2"));
	    let promise3 = reject(new Error("3"));
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // Code here never runs because there are rejected promises!
	    }, function(error) {
	      // error.message === "2"
	    });
	    ```
	  
	    @method all
	    @static
	    @param {Array} entries array of promises
	    @param {String} label optional string for labeling the promise.
	    Useful for tooling.
	    @return {Promise} promise that is fulfilled when all `promises` have been
	    fulfilled, or rejected if any of them become rejected.
	    @static
	  */
	  function all$1(entries) {
	    return new Enumerator$1(this, entries).promise;
	  }
	
	  /**
	    `Promise.race` returns a new promise which is settled in the same way as the
	    first passed promise to settle.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 2');
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // result === 'promise 2' because it was resolved before promise1
	      // was resolved.
	    });
	    ```
	  
	    `Promise.race` is deterministic in that only the state of the first
	    settled promise matters. For example, even if other promises given to the
	    `promises` array argument are resolved, but the first settled promise has
	    become rejected before the other promises became fulfilled, the returned
	    promise will become rejected:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        reject(new Error('promise 2'));
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // Code here never runs
	    }, function(reason){
	      // reason.message === 'promise 2' because promise 2 became rejected before
	      // promise 1 became fulfilled
	    });
	    ```
	  
	    An example real-world use case is implementing timeouts:
	  
	    ```javascript
	    Promise.race([ajax('foo.json'), timeout(5000)])
	    ```
	  
	    @method race
	    @static
	    @param {Array} promises array of promises to observe
	    Useful for tooling.
	    @return {Promise} a promise which settles in the same way as the first passed
	    promise to settle.
	  */
	  function race$1(entries) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (!isArray(entries)) {
	      return new Constructor(function (_, reject) {
	        return reject(new TypeError('You must pass an array to race.'));
	      });
	    } else {
	      return new Constructor(function (resolve, reject) {
	        var length = entries.length;
	        for (var i = 0; i < length; i++) {
	          Constructor.resolve(entries[i]).then(resolve, reject);
	        }
	      });
	    }
	  }
	
	  /**
	    `Promise.reject` returns a promise rejected with the passed `reason`.
	    It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      reject(new Error('WHOOPS'));
	    });
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.reject(new Error('WHOOPS'));
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    @method reject
	    @static
	    @param {Any} reason value that the returned promise will be rejected with.
	    Useful for tooling.
	    @return {Promise} a promise rejected with the given `reason`.
	  */
	  function reject$1(reason) {
	    /*jshint validthis:true */
	    var Constructor = this;
	    var promise = new Constructor(noop);
	    reject(promise, reason);
	    return promise;
	  }
	
	  function needsResolver() {
	    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	  }
	
	  function needsNew() {
	    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	  }
	
	  /**
	    Promise objects represent the eventual result of an asynchronous operation. The
	    primary way of interacting with a promise is through its `then` method, which
	    registers callbacks to receive either a promise's eventual value or the reason
	    why the promise cannot be fulfilled.
	  
	    Terminology
	    -----------
	  
	    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	    - `thenable` is an object or function that defines a `then` method.
	    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	    - `exception` is a value that is thrown using the throw statement.
	    - `reason` is a value that indicates why a promise was rejected.
	    - `settled` the final resting state of a promise, fulfilled or rejected.
	  
	    A promise can be in one of three states: pending, fulfilled, or rejected.
	  
	    Promises that are fulfilled have a fulfillment value and are in the fulfilled
	    state.  Promises that are rejected have a rejection reason and are in the
	    rejected state.  A fulfillment value is never a thenable.
	  
	    Promises can also be said to *resolve* a value.  If this value is also a
	    promise, then the original promise's settled state will match the value's
	    settled state.  So a promise that *resolves* a promise that rejects will
	    itself reject, and a promise that *resolves* a promise that fulfills will
	    itself fulfill.
	  
	  
	    Basic Usage:
	    ------------
	  
	    ```js
	    let promise = new Promise(function(resolve, reject) {
	      // on success
	      resolve(value);
	  
	      // on failure
	      reject(reason);
	    });
	  
	    promise.then(function(value) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Advanced Usage:
	    ---------------
	  
	    Promises shine when abstracting away asynchronous interactions such as
	    `XMLHttpRequest`s.
	  
	    ```js
	    function getJSON(url) {
	      return new Promise(function(resolve, reject){
	        let xhr = new XMLHttpRequest();
	  
	        xhr.open('GET', url);
	        xhr.onreadystatechange = handler;
	        xhr.responseType = 'json';
	        xhr.setRequestHeader('Accept', 'application/json');
	        xhr.send();
	  
	        function handler() {
	          if (this.readyState === this.DONE) {
	            if (this.status === 200) {
	              resolve(this.response);
	            } else {
	              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	            }
	          }
	        };
	      });
	    }
	  
	    getJSON('/posts.json').then(function(json) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Unlike callbacks, promises are great composable primitives.
	  
	    ```js
	    Promise.all([
	      getJSON('/posts'),
	      getJSON('/comments')
	    ]).then(function(values){
	      values[0] // => postsJSON
	      values[1] // => commentsJSON
	  
	      return values;
	    });
	    ```
	  
	    @class Promise
	    @param {function} resolver
	    Useful for tooling.
	    @constructor
	  */
	  function Promise$2(resolver) {
	    this[PROMISE_ID] = nextId();
	    this._result = this._state = undefined;
	    this._subscribers = [];
	
	    if (noop !== resolver) {
	      typeof resolver !== 'function' && needsResolver();
	      this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
	    }
	  }
	
	  Promise$2.all = all$1;
	  Promise$2.race = race$1;
	  Promise$2.resolve = resolve$1;
	  Promise$2.reject = reject$1;
	  Promise$2._setScheduler = setScheduler;
	  Promise$2._setAsap = setAsap;
	  Promise$2._asap = asap;
	
	  Promise$2.prototype = {
	    constructor: Promise$2,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	    
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	    
	      Chaining
	      --------
	    
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	    
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	    
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	    
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	    
	      Assimilation
	      ------------
	    
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	    
	      If the assimliated promise rejects, then the downstream promise will also reject.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	    
	      Simple Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let result;
	    
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	    
	      Advanced Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let author, books;
	    
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	    
	      function foundBooks(books) {
	    
	      }
	    
	      function failure(reason) {
	    
	      }
	    
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	    then: then,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	    
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	    
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	    
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	    'catch': function _catch(onRejection) {
	      return this.then(null, onRejection);
	    }
	  };
	
	  /*global self*/
	  function polyfill$1() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	      local = global;
	    } else if (typeof self !== 'undefined') {
	      local = self;
	    } else {
	      try {
	        local = Function('return this')();
	      } catch (e) {
	        throw new Error('polyfill failed because global object is unavailable in this environment');
	      }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	      var promiseToString = null;
	      try {
	        promiseToString = Object.prototype.toString.call(P.resolve());
	      } catch (e) {
	        // silently ignored
	      }
	
	      if (promiseToString === '[object Promise]' && !P.cast) {
	        return;
	      }
	    }
	
	    local.Promise = Promise$2;
	  }
	
	  // Strange compat..
	  Promise$2.polyfill = polyfill$1;
	  Promise$2.Promise = Promise$2;
	
	  return Promise$2;
	});
	
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = inlineHeaders;
	
	var encode = __webpack_require__(43);
	
	function inlineHeaders(url, headers) {
	  if (/\?/.test(url)) {
	    url += '&';
	  } else {
	    url += '?';
	  }
	
	  return url + encode(headers);
	}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return map(objectKeys(obj), function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (isArray(obj[k])) {
	        return map(obj[k], function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};
	
	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	function map(xs, f) {
	  if (xs.map) return xs.map(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    res.push(f(xs[i], i));
	  }
	  return res;
	}
	
	var objectKeys = Object.keys || function (obj) {
	  var res = [];
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
	  }
	  return res;
	};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = jsonpRequest;
	
	var errors = __webpack_require__(19);
	
	var JSONPCounter = 0;
	
	function jsonpRequest(url, opts, cb) {
	  if (opts.method !== 'GET') {
	    cb(new Error('Method ' + opts.method + ' ' + url + ' is not supported by JSONP.'));
	    return;
	  }
	
	  opts.debug('JSONP: start');
	
	  var cbCalled = false;
	  var timedOut = false;
	
	  JSONPCounter += 1;
	  var head = document.getElementsByTagName('head')[0];
	  var script = document.createElement('script');
	  var cbName = 'algoliaJSONP_' + JSONPCounter;
	  var done = false;
	
	  window[cbName] = function (data) {
	    removeGlobals();
	
	    if (timedOut) {
	      opts.debug('JSONP: Late answer, ignoring');
	      return;
	    }
	
	    cbCalled = true;
	
	    clean();
	
	    cb(null, {
	      body: data /* ,
	                 // We do not send the statusCode, there's no statusCode in JSONP, it will be
	                 // computed using data.status && data.message like with XDR
	                 statusCode*/
	    });
	  };
	
	  // add callback by hand
	  url += '&callback=' + cbName;
	
	  // add body params manually
	  if (opts.jsonBody && opts.jsonBody.params) {
	    url += '&' + opts.jsonBody.params;
	  }
	
	  var ontimeout = setTimeout(timeout, opts.timeouts.complete);
	
	  // script onreadystatechange needed only for
	  // <= IE8
	  // https://github.com/angular/angular.js/issues/4523
	  script.onreadystatechange = readystatechange;
	  script.onload = success;
	  script.onerror = error;
	
	  script.async = true;
	  script.defer = true;
	  script.src = url;
	  head.appendChild(script);
	
	  function success() {
	    opts.debug('JSONP: success');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    done = true;
	
	    // script loaded but did not call the fn => script loading error
	    if (!cbCalled) {
	      opts.debug('JSONP: Fail. Script loaded but did not call the callback');
	      clean();
	      cb(new errors.JSONPScriptFail());
	    }
	  }
	
	  function readystatechange() {
	    if (this.readyState === 'loaded' || this.readyState === 'complete') {
	      success();
	    }
	  }
	
	  function clean() {
	    clearTimeout(ontimeout);
	    script.onload = null;
	    script.onreadystatechange = null;
	    script.onerror = null;
	    head.removeChild(script);
	  }
	
	  function removeGlobals() {
	    try {
	      delete window[cbName];
	      delete window[cbName + '_loaded'];
	    } catch (e) {
	      window[cbName] = window[cbName + '_loaded'] = undefined;
	    }
	  }
	
	  function timeout() {
	    opts.debug('JSONP: Script timeout');
	    timedOut = true;
	    clean();
	    cb(new errors.RequestTimeout());
	  }
	
	  function error() {
	    opts.debug('JSONP: Script error');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    clean();
	    cb(new errors.JSONPScriptError());
	  }
	}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = createPlacesClient;
	
	var buildSearchMethod = __webpack_require__(18);
	
	function createPlacesClient(algoliasearch) {
	  return function places(appID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    opts = opts && cloneDeep(opts) || {};
	    opts.hosts = opts.hosts || ['places-dsn.algolia.net', 'places-1.algolianet.com', 'places-2.algolianet.com', 'places-3.algolianet.com'];
	
	    // allow initPlaces() no arguments => community rate limited
	    if (arguments.length === 0 || (typeof appID === 'undefined' ? 'undefined' : _typeof(appID)) === 'object' || appID === undefined) {
	      appID = '';
	      apiKey = '';
	      opts._allowEmptyCredentials = true;
	    }
	
	    var client = algoliasearch(appID, apiKey, opts);
	    var index = client.initIndex('places');
	    index.search = buildSearchMethod('query', '/1/places/query');
	    index.getObject = function (objectID, callback) {
	      return this.as._jsonRequest({
	        method: 'GET',
	        url: '/1/places/' + encodeURIComponent(objectID),
	        hostType: 'read',
	        callback: callback
	      });
	    };
	    return index;
	  };
	}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = getDocumentProtocol;
	
	function getDocumentProtocol() {
	  var protocol = window.document.location.protocol;
	
	  // when in `file:` mode (local html file), default to `http:`
	  if (protocol !== 'http:' && protocol !== 'https:') {
	    protocol = 'http:';
	  }
	
	  return protocol;
	}

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = '3.24.3';

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODM3MjY1NDk3Njg5YjhkZjg0NWEiLCJ3ZWJwYWNrOi8vLy4vfi9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZXZlbnQtcGFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xL3EuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL2FwcC9wbHVnaW5zL2V4cGxhYWluLXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvYnVpbGRzL2FsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9BbGdvbGlhU2VhcmNoLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhDb3JlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnVpbGRTZWFyY2hNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3JlYWNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Nsb25lLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvb21pdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvbWFwLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZXhpdFByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleEJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaENvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2NyZWF0ZUFsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbG9iYWwvd2luZG93LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvaW5saW5lLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9qc29ucC1yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvcGxhY2VzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9nZXQtZG9jdW1lbnQtcHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy92ZXJzaW9uLmpzIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwiZGVmaW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwibG9nTWV0aG9kcyIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlYWxNZXRob2QiLCJjb25zb2xlIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJsb2dnZXJOYW1lIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJkZWJ1ZyIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIkxvZ2dlciIsIm5hbWUiLCJkZWZhdWx0TGV2ZWwiLCJmYWN0b3J5Iiwic2VsZiIsImN1cnJlbnRMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJ0b1VwcGVyQ2FzZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImlnbm9yZSIsImRvY3VtZW50IiwiY29va2llIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0UGVyc2lzdGVkTGV2ZWwiLCJzdG9yZWRMZXZlbCIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImxldmVscyIsImdldExldmVsIiwic2V0TGV2ZWwiLCJwZXJzaXN0IiwiU0lMRU5UIiwic2V0RGVmYXVsdExldmVsIiwiZW5hYmxlQWxsIiwiVFJBQ0UiLCJkaXNhYmxlQWxsIiwiaW5pdGlhbExldmVsIiwiZGVmYXVsdExvZ2dlciIsIl9sb2dnZXJzQnlOYW1lIiwiZ2V0TG9nZ2VyIiwiVHlwZUVycm9yIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJVc2VySURzIiwibGl2ZSIsIkplcmVteSIsIk1hdHQiLCJDYXJvbCIsIkhhcnJpZXQiLCJKb25ueSIsInN0YWdpbmciLCJsb2NhbCIsImRyaXZlIiwiQUNNRSIsIlVzZXJJRCIsIlBhZ2VSZXN1bHRzIiwiVXNlckNhcmRzIiwiTGFzdFJlZnJlc2giLCJhbGdvbGlhUGFyYW1zIiwiYXBwSUQiLCJhcGlLZXkiLCJpbmRleCIsInVzZSIsImNocm9tZSIsImJyb3dzZXJBY3Rpb24iLCJvbkNsaWNrZWQiLCJhZGRMaXN0ZW5lciIsInRhYiIsInRhYnMiLCJxdWVyeSIsImFjdGl2ZSIsImN1cnJlbnRXaW5kb3ciLCJzZW5kTWVzc2FnZSIsImlkIiwiYWN0aW9uIiwicmVzIiwiaW5mbyIsInJ1bnRpbWUiLCJvbk1lc3NhZ2UiLCJyZXF1ZXN0Iiwic2VuZGVyIiwic2VuZFJlc3BvbnNlIiwidXJsIiwiZ2V0Q3VycmVudFBhZ2VSZXN1bHRzIiwiZGF0YSIsInRoZW4iLCJ0cmFjZSIsImNoZWNrUmVmcmVzaCIsImdldFBhZ2VSZXN1bHRzIiwiYWRkVG9QYWdlUmVzdWx0cyIsImNhdGNoIiwiZXJyb3IiLCJnZXRBbGxVc2VyQ2FyZHMiLCJldmVudCIsInJlc3BvbnNlIiwiZCIsImRlZmVyIiwidGFiSUQiLCJnZXRDdXJyZW50VGFiIiwicmVzb2x2ZSIsImdldFBhZ2VEYXRhIiwicmVqZWN0IiwicHJvbWlzZSIsInBhZ2VEYXRhIiwic2VuZE1lc3NhZ2VUb1RhYiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicGFnZVRhYklEIiwiZmlsdGVyIiwibm93IiwiRGF0ZSIsInNlYXJjaENhcmRzIiwicmVzdWx0cyIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0IiwiX3RvU3RyaW5nIiwidG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwiU3RyaW5nIiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwiYiIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXkiLCJpc0FycmF5QiIsImV2ZXJ5Iiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwid2FybiIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm9wdGlvbnMiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwibWF0Y2giLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJjb25zdHJ1Y3RvciIsInB1c2giLCJoYW5kbGVFcnJvciIsImVyciIsImluQnJvd3NlciIsImhhc1Byb3RvIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwibmV4dFRpY2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwidGltZXJGdW5jIiwibmV4dFRpY2tIYW5kbGVyIiwiY29waWVzIiwiUHJvbWlzZSIsInAiLCJsb2dFcnJvciIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicXVldWVOZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ1aWQiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsInBvcCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsInBhcmVudCIsImNoaWxkIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJ0eXBlIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY2FwdHVyZSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImNoZWNrT3B0aW9uVHlwZSIsIm9wdGlvbiIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5Iiwic291cmNlIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJfY29udGV4dCIsImgiLCJjcmVhdGVFbGVtZW50IiwiaW5qZWN0aW9ucyIsImZ1bmN0aW9uYWxPcHRpb25zIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJzdGF0aWNSZW5kZXJGbnMiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwiY3VycmVudCIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImhvb2tzIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsIm1vZGVsUnMiLCJwYXJzZU1vZGVsIiwiaWR4IiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0Iiwic3Vic3RyaW5nIiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJkeW5hbWljVHlwZSIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJ0YXJnZXQkMSIsImFkZCQxIiwib2xkSGFuZGxlciIsImV2IiwicmVtb3ZlJDIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwiZW5kIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsIk51bWJlciIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwiaXNUZXh0SW5wdXRUeXBlIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJiaW5kaW5nIiwic2V0U2VsZWN0ZWQiLCJfdk9wdGlvbnMiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJzb21lIiwibyIsImlzTXVsdGlwbGUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsInNob3VsZERlY29kZSIsImNvbnRlbnQiLCJlbmNvZGVkIiwiZGl2IiwiaW5uZXJIVE1MIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsImxhc3RJbmRleCIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJtb2R1bGVzJDEiLCJodG1sIiwiZGlyZWN0aXZlcyQxIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYmFzZU9wdGlvbnMiLCJleHBlY3RIVE1MIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwic2luZ2xlQXR0cklkZW50aWZpZXIiLCJzaW5nbGVBdHRyQXNzaWduIiwic2luZ2xlQXR0clZhbHVlcyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5IiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJwYXJzZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImVsZW1lbnQiLCJjb21tZW50cyIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJzcGFjZSIsInVwIiwicmlnaHQiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsInNoaWZ0IiwiYWx0IiwibWV0YSIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJpZGVudFJFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImNyZWF0ZUZ1bmN0aW9uIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJyZWYkMSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsIkl0ZW0iLCJhcnJheSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJib290c3RyYXAiLCJzZXMiLCJvayIsIm1ha2VRIiwicHJldmlvdXNRIiwiUSIsImhhc1N0YWNrcyIsInFTdGFydGluZ0xpbmUiLCJjYXB0dXJlTGluZSIsInFGaWxlTmFtZSIsImhlYWQiLCJ0YXNrIiwidGFpbCIsInJlcXVlc3RUaWNrIiwiaXNOb2RlSlMiLCJsYXRlclF1ZXVlIiwiZmx1c2giLCJkb21haW4iLCJydW5TaW5nbGUiLCJleGl0Iiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJyZXF1ZXN0UG9ydFRpY2siLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwicnVuQWZ0ZXIiLCJ1bmN1cnJ5VGhpcyIsImFycmF5X3NsaWNlIiwiYXJyYXlfcmVkdWNlIiwiYmFzaXMiLCJhcnJheV9pbmRleE9mIiwiYXJyYXlfbWFwIiwidGhpc3AiLCJjb2xsZWN0Iiwib2JqZWN0X2NyZWF0ZSIsIlR5cGUiLCJvYmplY3RfZGVmaW5lUHJvcGVydHkiLCJkZXNjcmlwdG9yIiwib2JqZWN0X2hhc093blByb3BlcnR5Iiwib2JqZWN0X2tleXMiLCJvYmplY3QiLCJvYmplY3RfdG9TdHJpbmciLCJpc1N0b3BJdGVyYXRpb24iLCJleGNlcHRpb24iLCJRUmV0dXJuVmFsdWUiLCJSZXR1cm5WYWx1ZSIsIlNUQUNLX0pVTVBfU0VQQVJBVE9SIiwibWFrZVN0YWNrVHJhY2VMb25nIiwic3RhY2tzIiwiX19taW5pbXVtU3RhY2tDb3VudGVyX18iLCJzdGFja0NvdW50ZXIiLCJjb25jYXRlZFN0YWNrcyIsImZpbHRlclN0YWNrU3RyaW5nIiwic3RhY2tTdHJpbmciLCJsaW5lcyIsImRlc2lyZWRMaW5lcyIsImxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJpc05vZGVGcmFtZSIsInN0YWNrTGluZSIsImdldEZpbGVOYW1lQW5kTGluZU51bWJlciIsImF0dGVtcHQxIiwiYXR0ZW1wdDIiLCJhdHRlbXB0MyIsImZpbGVOYW1lQW5kTGluZU51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsInFFbmRpbmdMaW5lIiwiZmlyc3RMaW5lIiwiZGVwcmVjYXRlIiwiYWx0ZXJuYXRpdmUiLCJpc1Byb21pc2VBbGlrZSIsImNvZXJjZSIsImZ1bGZpbGwiLCJsb25nU3RhY2tTdXBwb3J0IiwibG9uZ1N0YWNrQ291bnRlciIsIlFfREVCVUciLCJtZXNzYWdlcyIsInByb2dyZXNzTGlzdGVuZXJzIiwicmVzb2x2ZWRQcm9taXNlIiwiZGVmZXJyZWQiLCJwcm9taXNlRGlzcGF0Y2giLCJvcCIsIm9wZXJhbmRzIiwidmFsdWVPZiIsIm5lYXJlclZhbHVlIiwibmVhcmVyIiwiaXNQcm9taXNlIiwiaW5zcGVjdCIsImJlY29tZSIsIm5ld1Byb21pc2UiLCJtZXNzYWdlIiwicHJvZ3Jlc3MiLCJwcm9ncmVzc0xpc3RlbmVyIiwibWFrZU5vZGVSZXNvbHZlciIsInJlc29sdmVyIiwicmFjZSIsInBhc3NCeUNvcHkiLCJ4IiwieSIsInRoYXQiLCJzcHJlYWQiLCJhbnN3ZXJQcyIsIm1ha2VQcm9taXNlIiwiaW5zcGVjdGVkIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwcm9ncmVzc2VkIiwiZG9uZSIsIl9mdWxmaWxsZWQiLCJfcmVqZWN0ZWQiLCJuZXdFeGNlcHRpb24iLCJfcHJvZ3Jlc3NlZCIsIm5ld1ZhbHVlIiwidGhyZXciLCJvbmVycm9yIiwidGFwIiwiZmNhbGwiLCJ0aGVuUmVzb2x2ZSIsIndoZW4iLCJ0aGVuUmVqZWN0IiwiaXNQZW5kaW5nIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwidW5oYW5kbGVkUmVhc29ucyIsInVuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXNldFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1JlamVjdGlvbiIsInVudHJhY2tSZWplY3Rpb24iLCJhdCIsImF0UmVwb3J0IiwiZ2V0VW5oYW5kbGVkUmVhc29ucyIsInN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyIsInJlamVjdGlvbiIsInJocyIsIm1hc3RlciIsImRpc3BhdGNoIiwiYXN5bmMiLCJtYWtlR2VuZXJhdG9yIiwiY29udGludWVyIiwidmVyYiIsIlN0b3BJdGVyYXRpb24iLCJnZW5lcmF0b3IiLCJlcnJiYWNrIiwic3Bhd24iLCJfcmV0dXJuIiwicHJvbWlzZWQiLCJtYXBwbHkiLCJwb3N0Iiwic2VuZCIsIm1jYWxsIiwiaW52b2tlIiwiZmFwcGx5IiwiZmJpbmQiLCJmYm91bmQiLCJwcm9taXNlcyIsInBlbmRpbmdDb3VudCIsInNuYXBzaG90IiwiYW55Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsImFsbFJlc29sdmVkIiwiYWxsU2V0dGxlZCIsInJlZ2FyZGxlc3MiLCJmYWlsIiwiZmluIiwib25VbmhhbmRsZWRFcnJvciIsIm1zIiwidGltZW91dElkIiwibmZhcHBseSIsIm5vZGVBcmdzIiwibmZjYWxsIiwibmZiaW5kIiwiZGVub2RlaWZ5IiwiYmFzZUFyZ3MiLCJuYmluZCIsImJvdW5kIiwibm1hcHBseSIsIm5wb3N0IiwibnNlbmQiLCJubWNhbGwiLCJuaW52b2tlIiwibm9kZWlmeSIsIm5vZGViYWNrIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJjbGVhckltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwid2VicGFja1BvbHlmaWxsIiwicGF0aHMiLCJlc2NhcGVSZWdFeHAiLCJTZWFyY2giLCJBbGdvbGlhQ2xpZW50IiwicHJvdG9jb2wiLCJBbGdvbGlhSW5kZXgiLCJpbml0SW5kZXgiLCJhZHZhbmNlZFNlYXJjaCIsInBhcmFtcyIsImNsZWFyQ2FjaGUiLCJzZWFyY2giLCJmZXRjaExpc3RJdGVtQ2FyZHMiLCJoaXRzIiwidXNlcklEIiwic2VhcmNoVGV4dCIsImhpdHNQZXJQYWdlIiwiY2FyZHMiLCJjYXJkIiwiY29ycmVjdENhcmQiLCJsaXN0Q2FyZHMiLCJsaXN0SXRlbXMiLCJnZXRDYXJkIiwib2JqZWN0SUQiLCJnZXRPYmplY3QiLCJkZXNjcmlwdGlvbiIsInNlbnRlbmNlIiwiY29tcG91bmRTZWFyY2giLCJtYXhMZW5ndGgiLCJzZWFyY2hUZXh0QXJyYXkiLCJtaW4iLCJjZWlsIiwidCIsInIiLCJyZW1vdmVEdXBsaWNhdGVzIiwib3JpZ2luYWxBcnJheSIsIm9iaktleSIsInRyaW1tZWRBcnJheSIsInZhbHVlcyIsImNoZWNrUGFnZUhpdCIsImJvcmluZ1dvcmRzIiwiY291bnQiLCJwYWdlVGV4dCIsImNoZWNrUGFnZVJlbWluZGVyIiwidXJsUm9vdCIsImJhc2VVcmwiLCJyZW1pbmRlcnMiLCJhbGxVc2VyQ2FyZHMiLCJwYWdlUmVzdWx0cyIsInBpbmdzIiwibWVtb3JpZXMiLCJnbWFpbEJvcmluZ1BocmFzZXMiLCJwaHJhc2UiLCJhbGxXb3JkcyIsInNjb3JlIiwiZW50aXR5IiwicmVnIiwicG9pbnRzIiwidHJpZ2dlclVSTCIsInBpbmciLCJoaWdobGlnaHQiLCJBbGdvbGlhU2VhcmNoIiwiY3JlYXRlQWxnb2xpYXNlYXJjaCIsIkluZGV4IiwiZGVwcmVjYXRlZE1lc3NhZ2UiLCJBbGdvbGlhU2VhcmNoQ29yZSIsImluaGVyaXRzIiwiZGVsZXRlSW5kZXgiLCJpbmRleE5hbWUiLCJfanNvblJlcXVlc3QiLCJob3N0VHlwZSIsIm1vdmVJbmRleCIsInNyY0luZGV4TmFtZSIsImRzdEluZGV4TmFtZSIsInBvc3RPYmoiLCJvcGVyYXRpb24iLCJkZXN0aW5hdGlvbiIsImNvcHlJbmRleCIsImdldExvZ3MiLCJvZmZzZXQiLCJfZ2V0U2VhcmNoUGFyYW1zIiwibGlzdEluZGV4ZXMiLCJwYWdlIiwibGlzdFVzZXJLZXlzIiwibGlzdEFwaUtleXMiLCJnZXRVc2VyS2V5QUNMIiwiZ2V0QXBpS2V5IiwiZGVsZXRlVXNlcktleSIsImRlbGV0ZUFwaUtleSIsImFkZFVzZXJLZXkiLCJhY2xzIiwiYWRkQXBpS2V5IiwidXNhZ2UiLCJhY2wiLCJ2YWxpZGl0eSIsIm1heFF1ZXJpZXNQZXJJUFBlckhvdXIiLCJtYXhIaXRzUGVyUXVlcnkiLCJpbmRleGVzIiwicXVlcnlQYXJhbWV0ZXJzIiwicmVmZXJlcnMiLCJhZGRVc2VyS2V5V2l0aFZhbGlkaXR5IiwidXBkYXRlVXNlcktleSIsInVwZGF0ZUFwaUtleSIsInB1dE9iaiIsInN0YXJ0UXVlcmllc0JhdGNoIiwic3RhcnRRdWVyaWVzQmF0Y2hEZXByZWNhdGVkIiwiX2JhdGNoIiwiYWRkUXVlcnlJbkJhdGNoIiwiYWRkUXVlcnlJbkJhdGNoRGVwcmVjYXRlZCIsInNlbmRRdWVyaWVzQmF0Y2giLCJzZW5kUXVlcmllc0JhdGNoRGVwcmVjYXRlZCIsImJhdGNoIiwib3BlcmF0aW9ucyIsInJlcXVlc3RzIiwibm90SW1wbGVtZW50ZWQiLCJlbmFibGVSYXRlTGltaXRGb3J3YXJkIiwiZGlzYWJsZVJhdGVMaW1pdEZvcndhcmQiLCJ1c2VTZWN1cmVkQVBJS2V5IiwiZGlzYWJsZVNlY3VyZWRBUElLZXkiLCJnZW5lcmF0ZVNlY3VyZWRBcGlLZXkiLCJBbGdvbGlhU2VhcmNoRXJyb3IiLCJJbmRleENvcmUiLCJleGl0UHJvbWlzZSIsImRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcyIsImFkZE9iamVjdCIsImluZGV4T2JqIiwiYXMiLCJhZGRPYmplY3RzIiwib2JqZWN0cyIsInBhcnRpYWxVcGRhdGVPYmplY3QiLCJwYXJ0aWFsT2JqZWN0IiwiY3JlYXRlSWZOb3RFeGlzdHMiLCJwYXJ0aWFsVXBkYXRlT2JqZWN0cyIsInNhdmVPYmplY3QiLCJzYXZlT2JqZWN0cyIsImRlbGV0ZU9iamVjdCIsIl9wcm9taXNlIiwiZGVsZXRlT2JqZWN0cyIsIm9iamVjdElEcyIsInByZXBhcmVSZXF1ZXN0IiwiZGVsZXRlQnlRdWVyeSIsImNsaWVudCIsImF0dHJpYnV0ZXNUb1JldHJpZXZlIiwiZGlzdGluY3QiLCJzdG9wT3JEZWxldGUiLCJzZWFyY2hDb250ZW50IiwibmJIaXRzIiwiZ2V0T2JqZWN0SUQiLCJ3YWl0VGFzayIsImRvRGVsZXRlQnlRdWVyeSIsImRlbGV0ZU9iamVjdHNDb250ZW50IiwidGFza0lEIiwic3VjY2VzcyIsImZhaWx1cmUiLCJfc2V0VGltZW91dCIsImJyb3dzZUFsbCIsIm1lcmdlIiwiSW5kZXhCcm93c2VyIiwiYnJvd3NlTG9vcCIsImN1cnNvciIsIl9zdG9wcGVkIiwiYnJvd3NlQ2FsbGJhY2siLCJfZXJyb3IiLCJfcmVzdWx0IiwiX2VuZCIsInR0QWRhcHRlciIsInN5bmNDYiIsImFzeW5jQ2IiLCJzZWFyY2hEb25lIiwiYmFzZURlbGF5IiwibWF4RGVsYXkiLCJyZXRyeUxvb3AiLCJzdGF0dXMiLCJzdWNjZXNzQ2IiLCJmYWlsdXJlQ2IiLCJjbGVhckluZGV4IiwiZ2V0U2V0dGluZ3MiLCJzZWFyY2hTeW5vbnltcyIsInNhdmVTeW5vbnltIiwic3lub255bSIsImZvcndhcmRUb1NsYXZlcyIsImZvcndhcmRUb1JlcGxpY2FzIiwiZ2V0U3lub255bSIsImRlbGV0ZVN5bm9ueW0iLCJjbGVhclN5bm9ueW1zIiwiYmF0Y2hTeW5vbnltcyIsInN5bm9ueW1zIiwicmVwbGFjZUV4aXN0aW5nU3lub255bXMiLCJzZWFyY2hSdWxlcyIsInNhdmVSdWxlIiwicnVsZSIsImdldFJ1bGUiLCJkZWxldGVSdWxlIiwiY2xlYXJSdWxlcyIsImJhdGNoUnVsZXMiLCJydWxlcyIsImNsZWFyRXhpc3RpbmdSdWxlcyIsInNldFNldHRpbmdzIiwic2V0dGluZ3MiLCJkZXByZWNhdGVkQWRkVXNlcktleVdpdGhWYWxpZGl0eSIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJUZW1wQ3RvciIsImJ1aWxkU2VhcmNoTWV0aG9kIiwiYWxnb2xpYXNlYXJjaCIsInR5cGVBaGVhZEFyZ3MiLCJ0eXBlQWhlYWRWYWx1ZU9wdGlvbiIsInNpbWlsYXJTZWFyY2giLCJicm93c2UiLCJicm93c2VGcm9tIiwic2VhcmNoRm9yRmFjZXRWYWx1ZXMiLCJvbWl0IiwiZmFjZXROYW1lIiwiZmFjZXRRdWVyeSIsImZpbHRlcmVkUGFyYW1zIiwia2V5TmFtZSIsInNlYXJjaFBhcmFtZXRlcnMiLCJzZWFyY2hGYWNldCIsIl9zZWFyY2giLCJhZGRpdGlvbmFsVUEiLCJnZXRPYmplY3RzIiwicXVlcnlQYXJhbSIsImV4dHJhUHJvcGVydGllcyIsImNhcHR1cmVTdGFja1RyYWNlIiwiYWRkVG9FcnJvck9iamVjdCIsImNyZWF0ZUN1c3RvbUVycm9yIiwiQWxnb2xpYVNlYXJjaEN1c3RvbUVycm9yIiwiVW5wYXJzYWJsZUpTT04iLCJSZXF1ZXN0VGltZW91dCIsIk5ldHdvcmsiLCJKU09OUFNjcmlwdEZhaWwiLCJKU09OUFNjcmlwdEVycm9yIiwiVW5rbm93biIsImsiLCJkZXByZWNhdGVkIiwicHJldmlvdXNVc2FnZSIsIm5ld1VzYWdlIiwiZ2l0aHViQW5jaG9yTGluayIsImZvcmVhY2giLCJzb3VyY2VzIiwiZmlsdGVyZWQiLCJkb0ZpbHRlciIsInRvU3RyIiwiaXNBcmdzIiwiaXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJoYXNEb250RW51bUJ1ZyIsImhhc1Byb3RvRW51bUJ1ZyIsImRvbnRFbnVtcyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhjbHVkZWRLZXlzIiwiJGNvbnNvbGUiLCIkZXh0ZXJuYWwiLCIkZnJhbWUiLCIkZnJhbWVFbGVtZW50IiwiJGZyYW1lcyIsIiRpbm5lckhlaWdodCIsIiRpbm5lcldpZHRoIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkc2Nyb2xsTGVmdCIsIiRzY3JvbGxUb3AiLCIkc2Nyb2xsWCIsIiRzY3JvbGxZIiwiJHNlbGYiLCIkd2Via2l0SW5kZXhlZERCIiwiJHdlYmtpdFN0b3JhZ2VJbmZvIiwiJHdpbmRvdyIsImhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSIsImtleXNTaGltIiwiaXNGdW5jdGlvbiIsImlzQXJndW1lbnRzIiwiaXNTdHJpbmciLCJ0aGVLZXlzIiwic2tpcFByb3RvIiwic2tpcENvbnN0cnVjdG9yIiwic2hpbSIsInNoaW1PYmplY3RLZXlzIiwia2V5c1dvcmtzV2l0aEFyZ3VtZW50cyIsIm9yaWdpbmFsS2V5cyIsImNhbGxlZSIsIm5ld0FyciIsIml0ZW1JbmRleCIsIkV2ZW50RW1pdHRlciIsIl9jbGVhbiIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiaXNOdW1iZXIiLCJlciIsImlzVW5kZWZpbmVkIiwibGlzdGVuZXIiLCJuZXdMaXN0ZW5lciIsImZpcmVkIiwicG9zaXRpb24iLCJsaXN0ZW5lckNvdW50IiwiZXZsaXN0ZW5lciIsImVtaXR0ZXIiLCJzdG9yZSIsIk1BWF9BUElfS0VZX0xFTkdUSCIsIlJFU0VUX0FQUF9EQVRBX1RJTUVSIiwiYXBwbGljYXRpb25JRCIsIl9hbGxvd0VtcHR5Q3JlZGVudGlhbHMiLCJob3N0cyIsInJlYWQiLCJ3cml0ZSIsIl90aW1lb3V0cyIsInRpbWVvdXRzIiwiY29ubmVjdCIsIl9jaGVja0FwcElkRGF0YSIsImRlZmF1bHRIb3N0cyIsIl9zaHVmZmxlUmVzdWx0IiwiaG9zdE51bWJlciIsInByZXBhcmVIb3N0IiwiZXh0cmFIZWFkZXJzIiwiX2NhY2hlIiwiX3VhIiwiX3VzZUNhY2hlIiwiX3VzZUZhbGxiYWNrIiwidXNlRmFsbGJhY2siLCJzZXRFeHRyYUhlYWRlciIsImdldEV4dHJhSGVhZGVyIiwidW5zZXRFeHRyYUhlYWRlciIsImFkZEFsZ29saWFBZ2VudCIsImFsZ29saWFBZ2VudCIsImluaXRpYWxPcHRzIiwicmVxdWVzdERlYnVnIiwidHJpZXMiLCJ1c2luZ0ZhbGxiYWNrIiwiaGFzRmFsbGJhY2siLCJfcmVxdWVzdCIsImhlYWRlcnMiLCJfY29tcHV0ZVJlcXVlc3RIZWFkZXJzIiwic2FmZUpTT05TdHJpbmdpZnkiLCJkZWJ1Z0RhdGEiLCJkb1JlcXVlc3QiLCJyZXF1ZXN0ZXIiLCJyZXFPcHRzIiwic3RhcnRUaW1lIiwiY2FjaGVJRCIsImpzb25Cb2R5IiwiX2dldFRpbWVvdXRzRm9yUmVxdWVzdCIsIl9zZXRIb3N0SW5kZXhCeVR5cGUiLCJjdXJyZW50SG9zdCIsIl9nZXRIb3N0QnlUeXBlIiwidHJ5RmFsbGJhY2siLCJodHRwUmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwiaHR0cFJlc3BvbnNlT2siLCJlbmRUaW1lIiwicmVtb3ZlQ3JlZGVudGlhbHMiLCJjb250ZW50TGVuZ3RoIiwicmVzcG9uc2VUZXh0Iiwic2hvdWxkUmV0cnkiLCJyZXRyeVJlcXVlc3QiLCJ1bnJlY292ZXJhYmxlRXJyb3IiLCJyZXRyeVJlcXVlc3RXaXRoSGlnaGVyVGltZW91dCIsIl9pbmNyZW1lbnRIb3N0SW5kZXgiLCJfaW5jcmVtZW50VGltZW91dE11bHRpcGxlciIsIm9rQ2IiLCJub29rQ2IiLCJ3aXRoQVBJS2V5IiwidWEiLCJyZXF1ZXN0SGVhZGVycyIsInVzZXJUb2tlbiIsInNlY3VyaXR5VGFncyIsImFkZFRvUmVxdWVzdEhlYWRlcnMiLCJxdWVyaWVzIiwiSlNPTlBQYXJhbXMiLCJwcmVwYXJlSlNPTlBQYXJhbXMiLCJyZXF1ZXN0SWQiLCJzdHJhdGVneSIsInNldFNlY3VyaXR5VGFncyIsInRhZ3MiLCJzdHJUYWdzIiwib3JlZFRhZ3MiLCJzZXRVc2VyVG9rZW4iLCJzZXRSZXF1ZXN0VGltZW91dCIsIm1pbGxpc2Vjb25kcyIsInNldFRpbWVvdXRzIiwiZ2V0VGltZW91dHMiLCJfZ2V0QXBwSWREYXRhIiwiX2NhY2hlQXBwSWREYXRhIiwiX3NldEFwcElkRGF0YSIsImxhc3RDaGFuZ2UiLCJnZXRUaW1lIiwiX3Jlc2V0SW5pdGlhbEFwcElkRGF0YSIsImhvc3RJbmRleGVzIiwidGltZW91dE11bHRpcGxpZXIiLCJzaHVmZmxlUmVzdWx0Iiwic2h1ZmZsZSIsIl9ob3N0SW5kZXhlcyIsIl90aW1lb3V0TXVsdGlwbGllciIsIl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlIiwiY3VycmVudERhdGEiLCJfZ2V0SG9zdEluZGV4QnlUeXBlIiwiX2dldFRpbWVvdXRNdWx0aXBsaWVyIiwiaG9zdEluZGV4IiwibmV3SG9zdEluZGV4ZXMiLCJjb21wbGV0ZSIsInByZXBhcmUiLCJob3N0IiwidG9KU09OIiwib3V0IiwiY3VycmVudEluZGV4IiwidGVtcG9yYXJ5VmFsdWUiLCJyYW5kb21JbmRleCIsIm5ld0hlYWRlcnMiLCJoZWFkZXJOYW1lIiwibG9jYWxTdG9yYWdlTmFtZXNwYWNlIiwibW9kdWxlU3RvcmUiLCJsb2NhbFN0b3JhZ2VTdG9yZSIsImxvY2FsU3RvcmFnZUZhaWx1cmUiLCJjbGVhbnVwIiwic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJnZXRPclNldCIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImNvbG9ycyIsIldlYmtpdEFwcGVhcmFuY2UiLCJmaXJlYnVnIiwidGFibGUiLCIkMSIsImZvcm1hdHRlcnMiLCJodW1hbml6ZSIsImRpZmYiLCJjb2xvciIsImxhc3RDIiwibmFtZXNwYWNlcyIsIkRFQlVHIiwiZW5hYmxlIiwiY3JlYXRlRGVidWciLCJkaXNhYmxlIiwiZW5hYmxlZCIsIm5hbWVzIiwic2tpcHMiLCJwcmV2VGltZSIsInNlbGVjdENvbG9yIiwiYWJzIiwiY3VyciIsImZvcm1hdCIsImZvcm1hdHRlciIsImxvZ0ZuIiwic3Vic3RyIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsInJvdW5kIiwicGx1cmFsIiwidWFTdWZmaXgiLCJpbmxpbmVIZWFkZXJzIiwianNvbnBSZXF1ZXN0IiwicGxhY2VzIiwiY2xvbmVEZWVwIiwiZ2V0RG9jdW1lbnRQcm90b2NvbCIsIkFsZ29saWFTZWFyY2hCcm93c2VyIiwiaW5pdFBsYWNlcyIsIl9fYWxnb2xpYSIsInN1cHBvcnQiLCJoYXNYTUxIdHRwUmVxdWVzdCIsImhhc1hEb21haW5SZXF1ZXN0IiwiY29ycyIsIlhNTEh0dHBSZXF1ZXN0Iiwid3JhcFJlcXVlc3QiLCJyZXEiLCJYRG9tYWluUmVxdWVzdCIsInJlcVRpbWVvdXQiLCJ0aW1lZE91dCIsImNvbm5lY3RlZCIsIm9ucHJvZ3Jlc3MiLCJvblJlYWR5U3RhdGVDaGFuZ2UiLCJvbmxvYWQiLCJvbkxvYWQiLCJvbkVycm9yIiwic2V0UmVxdWVzdEhlYWRlciIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsIm1vcmUiLCJhYm9ydCIsIm9uQ29ubmVjdCIsInJlYWR5U3RhdGUiLCJyZXF1ZXN0RmFsbGJhY2siLCJ3cmFwSnNvbnBSZXF1ZXN0IiwianNvbnBSZXF1ZXN0RG9uZSIsInJlamVjdFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZSIsImRlbGF5UHJvbWlzZSIsInJlc29sdmVPblRpbWVvdXQiLCJ3aW4iLCJFUzZQcm9taXNlIiwib2JqZWN0T3JGdW5jdGlvbiIsIl9pc0FycmF5IiwidmVydHhOZXh0IiwiY3VzdG9tU2NoZWR1bGVyRm4iLCJhc2FwIiwic2NoZWR1bGVGbHVzaCIsInNldFNjaGVkdWxlciIsInNjaGVkdWxlRm4iLCJzZXRBc2FwIiwiYXNhcEZuIiwiYnJvd3NlcldpbmRvdyIsImJyb3dzZXJHbG9iYWwiLCJCcm93c2VyTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJpc05vZGUiLCJpc1dvcmtlciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwidXNlTmV4dFRpY2siLCJ1c2VWZXJ0eFRpbWVyIiwidXNlU2V0VGltZW91dCIsInVzZU11dGF0aW9uT2JzZXJ2ZXIiLCJpdGVyYXRpb25zIiwidXNlTWVzc2FnZUNoYW5uZWwiLCJnbG9iYWxTZXRUaW1lb3V0IiwiYXR0ZW1wdFZlcnR4IiwidmVydHgiLCJydW5Pbkxvb3AiLCJydW5PbkNvbnRleHQiLCJvbkZ1bGZpbGxtZW50Iiwib25SZWplY3Rpb24iLCJfYXJndW1lbnRzIiwiUFJPTUlTRV9JRCIsIl9zdGF0ZSIsImludm9rZUNhbGxiYWNrIiwic3Vic2NyaWJlIiwicmVzb2x2ZSQxIiwiQ29uc3RydWN0b3IiLCJQRU5ESU5HIiwiRlVMRklMTEVEIiwiUkVKRUNURUQiLCJHRVRfVEhFTl9FUlJPUiIsIkVycm9yT2JqZWN0Iiwic2VsZkZ1bGZpbGxtZW50IiwiY2Fubm90UmV0dXJuT3duIiwiZ2V0VGhlbiIsInRyeVRoZW4iLCJ0aGVuJCQxIiwiZnVsZmlsbG1lbnRIYW5kbGVyIiwicmVqZWN0aW9uSGFuZGxlciIsImhhbmRsZUZvcmVpZ25UaGVuYWJsZSIsInRoZW5hYmxlIiwiX2xhYmVsIiwiaGFuZGxlT3duVGhlbmFibGUiLCJoYW5kbGVNYXliZVRoZW5hYmxlIiwibWF5YmVUaGVuYWJsZSIsInB1Ymxpc2hSZWplY3Rpb24iLCJfb25lcnJvciIsInB1Ymxpc2giLCJfc3Vic2NyaWJlcnMiLCJzdWJzY3JpYmVycyIsInNldHRsZWQiLCJkZXRhaWwiLCJUUllfQ0FUQ0hfRVJST1IiLCJ0cnlDYXRjaCIsImhhc0NhbGxiYWNrIiwic3VjY2VlZGVkIiwiZmFpbGVkIiwiaW5pdGlhbGl6ZVByb21pc2UiLCJuZXh0SWQiLCJFbnVtZXJhdG9yJDEiLCJpbnB1dCIsIl9pbnN0YW5jZUNvbnN0cnVjdG9yIiwiX3JlbWFpbmluZyIsIl9lbnVtZXJhdGUiLCJ2YWxpZGF0aW9uRXJyb3IiLCJfZWFjaEVudHJ5IiwiZW50cnkiLCJyZXNvbHZlJCQxIiwiX3RoZW4iLCJfc2V0dGxlZEF0IiwiUHJvbWlzZSQyIiwiX3dpbGxTZXR0bGVBdCIsImVudW1lcmF0b3IiLCJhbGwkMSIsImVudHJpZXMiLCJyYWNlJDEiLCJyZWplY3QkMSIsIm5lZWRzUmVzb2x2ZXIiLCJuZWVkc05ldyIsIl9zZXRTY2hlZHVsZXIiLCJfc2V0QXNhcCIsIl9hc2FwIiwiX2NhdGNoIiwicG9seWZpbGwkMSIsIlAiLCJwcm9taXNlVG9TdHJpbmciLCJjYXN0IiwicG9seWZpbGwiLCJlbmNvZGUiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJzZXAiLCJlcSIsIm9iamVjdEtleXMiLCJrcyIsInhzIiwiSlNPTlBDb3VudGVyIiwiY2JDYWxsZWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNiTmFtZSIsInJlbW92ZUdsb2JhbHMiLCJjbGVhbiIsIm9udGltZW91dCIsInJlYWR5c3RhdGVjaGFuZ2UiLCJjcmVhdGVQbGFjZXNDbGllbnQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7OztBQU1DLFlBQVVBLElBQVYsRUFBZ0JDLFVBQWhCLEVBQTRCO0FBQ3pCOztBQUNBLFNBQUksSUFBSixFQUFnRDtBQUM1Q0MsU0FBQSxvQ0FBT0QsVUFBUDtBQUNILE1BRkQsTUFFTyxJQUFJLFFBQU9FLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEJBLE9BQU9DLE9BQXpDLEVBQWtEO0FBQ3JERCxnQkFBT0MsT0FBUCxHQUFpQkgsWUFBakI7QUFDSCxNQUZNLE1BRUE7QUFDSEQsY0FBS0ssR0FBTCxHQUFXSixZQUFYO0FBQ0g7QUFDSixFQVRBLGFBU08sWUFBWTtBQUNoQjs7QUFFQTs7QUFDQSxTQUFJSyxPQUFPLFNBQVBBLElBQU8sR0FBVyxDQUFFLENBQXhCO0FBQ0EsU0FBSUMsZ0JBQWdCLFdBQXBCOztBQUVBLFNBQUlDLGFBQWEsQ0FDYixPQURhLEVBRWIsT0FGYSxFQUdiLE1BSGEsRUFJYixNQUphLEVBS2IsT0FMYSxDQUFqQjs7QUFRQTtBQUNBLGNBQVNDLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCQyxVQUF6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OEIsSUFBOUI7QUFDRDs7QUFFRCxTQUFJckssU0FBU2dFLGNBQWNoOUQsS0FBZCxFQUFxQkMsTUFBckIsRUFBNkI4TixJQUE3QixDQUFiO0FBQ0EsU0FBSTdOLFFBQVE4NEQsT0FBT3RJLFNBQVAsQ0FBaUIsUUFBakIsQ0FBWjtBQUNBeHdELFdBQU00d0QsTUFBTixHQUFlaU0sa0JBQWtCLE9BQWxCLEVBQTJCLGlCQUEzQixDQUFmO0FBQ0E3OEQsV0FBTXl4RCxTQUFOLEdBQWtCLFVBQVNELFFBQVQsRUFBbUIzbUMsUUFBbkIsRUFBNkI7QUFDN0MsY0FBTyxLQUFLa3RDLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJwNUQsaUJBQVEsS0FEa0I7QUFFMUJtRyxjQUFLLGVBQWUvRCxtQkFBbUJrMEQsUUFBbkIsQ0FGTTtBQUcxQitDLG1CQUFVLE1BSGdCO0FBSTFCMXBDLG1CQUFVQTtBQUpnQixRQUFyQixDQUFQO0FBTUQsTUFQRDtBQVFBLFlBQU83cUIsS0FBUDtBQUNELElBOUJEO0FBK0JELEU7Ozs7OztBQ3BDRDs7QUFFQXZGLFFBQU9DLE9BQVAsR0FBaUJ1eUUsbUJBQWpCOztBQUVBLFVBQVNBLG1CQUFULEdBQStCO0FBQzdCLE9BQUkzYyxXQUFXcnpELE9BQU9HLFFBQVAsQ0FBZ0JLLFFBQWhCLENBQXlCNnlELFFBQXhDOztBQUVBO0FBQ0EsT0FBSUEsYUFBYSxPQUFiLElBQXdCQSxhQUFhLFFBQXpDLEVBQW1EO0FBQ2pEQSxnQkFBVyxPQUFYO0FBQ0Q7O0FBRUQsVUFBT0EsUUFBUDtBQUNELEU7Ozs7OztBQ2JEOztBQUVBNzFELFFBQU9DLE9BQVAsR0FBaUIsUUFBakIsQyIsImZpbGUiOiJldmVudC1wYWdlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgODM3MjY1NDk3Njg5YjhkZjg0NWEiLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCdcbmltcG9ydCBRIGZyb20gJ3EnXG5cbmltcG9ydCBFeHBsYWFpblNlYXJjaCBmcm9tICcuLi9wbHVnaW5zL2V4cGxhYWluLXNlYXJjaC5qcyc7XG5cbmxvZy5zZXRMZXZlbCgnZGVidWcnKVxuXG5jb25zdCBVc2VySURzID0ge1xuICBsaXZlOiB7XG4gICAgSmVyZW15OiAnMTYyNzg4ODgwMDU2OTMwOScsXG4gICAgTWF0dDogJzE0NTU3MDcyNDc4NTAwNjknLFxuICAgIENhcm9sOiAnMTQ1OTA2ODk5MDg3ODA3NycsXG4gICAgSGFycmlldDogJzE0Nzg3NzYyMzIxNjE0NjgnLFxuICAgIEpvbm55OiAnMTUxMzU1NDQzODcyOTc1MycsXG4gIH0sXG4gIHN0YWdpbmc6IHtcbiAgICBKZXJlbXk6ICcxMzY2NzQ2MzcwMDg5NTI3JyxcbiAgICBNYXR0OiAnMTUyODEzNDk5MDU2MzIwMicsXG4gIH0sXG4gIGxvY2FsOiB7XG4gICAgSmVyZW15OiAnMTMwMDEyMDg4MDExMDc3MycsXG4gICAgTWF0dDogJzE0Mjg0MTkxMDA1Mjg0MzgnLFxuICB9LFxuICBkcml2ZToge1xuICAgIEplcmVteTogJzEwNDM4MDExMDI3OTY1ODkyMDE3NScsXG4gICAgQUNNRTogJzEwMTExODM4NzMwMTI4NjIzMjIyMidcbiAgfVxufVxuXG5jb25zdCBVc2VySUQgPSBVc2VySURzLmxpdmUuQUNNRVxudmFyIFBhZ2VSZXN1bHRzID0ge31cbnZhciBVc2VyQ2FyZHMgPSBbXVxudmFyIExhc3RSZWZyZXNoID0gMFxuXG5jb25zdCBhbGdvbGlhUGFyYW1zID0geyAvLyBOZWVkIHRvIHNlbmQgdGhlc2UgdG8gYXBwLnZ1ZSB0byBhdm9pZCBkdXBsaWNhdGlvbiFcbiAgYXBwSUQ6ICdJMlZLTU5OQVhJJyxcbiAgYXBpS2V5OiAnMmI4NDA2Zjg0Y2Q0Y2M1MDdkYTE3MzAzMmM0NmVlN2InLFxuICBpbmRleDogJ0ZvcmdldE1lTm90X0NvbnRleHRfVGVzdCdcbn1cblZ1ZS51c2UoRXhwbGFhaW5TZWFyY2gsIGFsZ29saWFQYXJhbXMpXG5cbmNocm9tZS5icm93c2VyQWN0aW9uLm9uQ2xpY2tlZC5hZGRMaXN0ZW5lcihmdW5jdGlvbih0YWIpIHtcbiAgY2hyb21lLnRhYnMucXVlcnkoe2FjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZX0sIGZ1bmN0aW9uKHRhYnMpe1xuICAgIGNocm9tZS50YWJzLnNlbmRNZXNzYWdlKHRhYnNbMF0uaWQsIHthY3Rpb246ICd0b2dnbGVEcmF3ZXInfSwgZnVuY3Rpb24ocmVzKSB7XG4gICAgICBsb2cuaW5mbyhyZXMpXG4gICAgfSlcbiAgfSlcbn0pO1xuXG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24ocmVxdWVzdCwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHtcbiAgdHJ5IHtcbiAgICBsb2cuZGVidWcoKHNlbmRlci50YWIgPyBcIkZyb20gYSBjb250ZW50IHNjcmlwdDogXCIgKyBzZW5kZXIudGFiLnVybCA6IFwiRnJvbSB0aGUgZXh0ZW5zaW9uXCIpLCByZXF1ZXN0KVxuXG4gICAgaWYocmVxdWVzdC5hY3Rpb24gPT0gXCJnZXRQYWdlUmVzdWx0c1wiKXtcbiAgICAgIGdldEN1cnJlbnRQYWdlUmVzdWx0cyhyZXF1ZXN0LmRhdGEpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgbG9nLmRlYnVnKHJlcylcbiAgICAgICAgc2VuZFJlc3BvbnNlKHJlcylcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3QuYWN0aW9uID09IFwiY2hlY2tQYWdlXCIpIHtcbiAgICAgIGxvZy50cmFjZShyZXF1ZXN0LmRhdGEpO1xuICAgICAgY2hlY2tSZWZyZXNoKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRXhwbGFhaW5TZWFyY2guZ2V0UGFnZVJlc3VsdHMoVXNlcklELCByZXF1ZXN0LmRhdGEsIFVzZXJDYXJkcylcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGFkZFRvUGFnZVJlc3VsdHMoc2VuZGVyLnRhYi5pZCwgcmVzKVxuICAgICAgICBQYWdlUmVzdWx0cyA9IHJlcztcbiAgICAgICAgc2VuZFJlc3BvbnNlKHJlcyk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGxvZy5lcnJvcihlKVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZihyZXF1ZXN0LmFjdGlvbiA9PSBcImdldFVzZXJcIil7XG4gICAgICBzZW5kUmVzcG9uc2UoVXNlcklEKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZihyZXF1ZXN0LmFjdGlvbiA9PSBcInJlZnJlc2hDYXJkc1wiKXtcbiAgICAgIGdldEFsbFVzZXJDYXJkcygpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYocmVxdWVzdC5ldmVudCA9PSBcInBvcHVwT3BlbmVkXCIpe1xuICAgICAgY2hyb21lLnRhYnMucXVlcnkoe2FjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZX0sIGZ1bmN0aW9uKHRhYnMpe1xuICAgICAgICBjaHJvbWUudGFicy5zZW5kTWVzc2FnZSh0YWJzWzBdLmlkLCB7ZXZlbnQ6ICdwb3B1cE9wZW5lZCd9LCBmdW5jdGlvbihyZXNwb25zZSkge30pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2goZSkge1xuICAgIGxvZy5lcnJvcihlKVxuICB9XG59KVxuXG5jb25zdCBnZXRDdXJyZW50UGFnZVJlc3VsdHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgdmFyIHRhYklEO1xuICBsb2cuZGVidWcoMSlcbiAgY2hlY2tSZWZyZXNoKClcbiAgLnRoZW4oZ2V0Q3VycmVudFRhYilcbiAgLnRoZW4oZnVuY3Rpb24odGFiKSB7XG4gICAgbG9nLmRlYnVnKHRhYi5pZClcbiAgICB0YWJJRCA9IHRhYi5pZFxuICAgIGxvZy5kZWJ1ZyhQYWdlUmVzdWx0cylcbiAgICBpZiAoUGFnZVJlc3VsdHNbdGFiSURdKSB7XG4gICAgICBkLnJlc29sdmUoUGFnZVJlc3VsdHNbdGFiSURdKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWRhdGEpIGRhdGEgPSB7dGFiSUQ6IHRhYklEfVxuICAgICAgbG9nLmRlYnVnKGRhdGEpXG4gICAgICBnZXRQYWdlRGF0YShkYXRhKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhyZXMpXG4gICAgICAgIHJldHVybiBFeHBsYWFpblNlYXJjaC5nZXRQYWdlUmVzdWx0cyhVc2VySUQsIHJlcywgVXNlckNhcmRzKVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgbG9nLmRlYnVnKHJlcylcbiAgICAgICAgYWRkVG9QYWdlUmVzdWx0cyh0YWJJRCwgcmVzKVxuICAgICAgICBkLnJlc29sdmUocmVzKVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBkLnJlamVjdChlKVxuICAgICAgfSlcbiAgICB9XG4gIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICBkLnJlamVjdChlKVxuICB9KVxuICByZXR1cm4gZC5wcm9taXNlXG59XG5cbmNvbnN0IGdldEN1cnJlbnRUYWIgPSBmdW5jdGlvbigpIHtcbiAgLy8gTmVlZCBlcnJvciBjYXRjaGluZyBoZXJlXG4gIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgY2hyb21lLnRhYnMucXVlcnkoe2FjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZX0sIGZ1bmN0aW9uKHRhYnMpe1xuICAgIGQucmVzb2x2ZSh0YWJzWzBdKVxuICB9KVxuICByZXR1cm4gZC5wcm9taXNlXG59XG5cbmNvbnN0IGdldFBhZ2VEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIGlmIChkYXRhLnBhZ2VEYXRhKSB7XG4gICAgZC5yZXNvbHZlKGRhdGEucGFnZURhdGEpXG4gIH0gZWxzZSBpZiAoZGF0YS50YWJJRCkge1xuICAgIHNlbmRNZXNzYWdlVG9UYWIodGFiSUQsIHthY3Rpb246ICdnZXRQYWdlRGF0YSd9KVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgZC5yZXNvbHZlKHJlcylcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGQucmVqZWN0KClcbiAgfVxuICByZXR1cm4gZC5wcm9taXNlXG59XG5cbmNvbnN0IHNlbmRNZXNzYWdlVG9UYWIgPSBmdW5jdGlvbih0YWJJRCwgZGF0YSkge1xuICAvLyBOZWVkIGVycm9yIGNhdGNoaW5nIGhlcmVcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBjaHJvbWUudGFicy5zZW5kTWVzc2FnZSh0YWJJRCwgZGF0YSwgZnVuY3Rpb24ocmVzKSB7XG4gICAgbG9nLmRlYnVnKHJlcylcbiAgICBkLnJlc29sdmUocmVzKVxuICB9KVxuICByZXR1cm4gZC5wcm9taXNlXG59XG5cbmNvbnN0IGFkZFRvUGFnZVJlc3VsdHMgPSBmdW5jdGlvbih0YWJJRCwgZGF0YSkge1xuICBQYWdlUmVzdWx0c1t0YWJJRF0gPSBkYXRhXG4gIGNocm9tZS50YWJzLnF1ZXJ5KHthY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWV9LCBmdW5jdGlvbih0YWJzKXtcbiAgICBPYmplY3Qua2V5cyhQYWdlUmVzdWx0cykuZm9yRWFjaChmdW5jdGlvbihwYWdlVGFiSUQpIHtcbiAgICAgIGlmICggdGFicy5maWx0ZXIoZnVuY3Rpb24odGFiKSB7cmV0dXJuIHRhYi5pZCA9PSBwYWdlVGFiSUR9KS5sZW5ndGggPT0gMCApXG4gICAgICAgIGRlbGV0ZSBQYWdlUmVzdWx0c1twYWdlVGFiSURdXG4gICAgfSlcbiAgICBsb2cuZGVidWcoUGFnZVJlc3VsdHMpXG4gIH0pXG59XG5cbmNvbnN0IGNoZWNrUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgaWYgKG5vdyAtIExhc3RSZWZyZXNoID4gMzAwMDAwKSB7XG4gICAgZ2V0QWxsVXNlckNhcmRzKClcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGQucmVzb2x2ZSgpXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgbG9nLmVycm9yKGUpXG4gICAgICBkLnJlamVjdChlKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZC5yZXNvbHZlKClcbiAgfVxuICByZXR1cm4gZC5wcm9taXNlXG59XG5cbmNvbnN0IGdldEFsbFVzZXJDYXJkcyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIExhc3RSZWZyZXNoID0gbmV3IERhdGUoKVxuICBFeHBsYWFpblNlYXJjaC5zZWFyY2hDYXJkcyhVc2VySUQsICcnLCAxMDAwKVxuICAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgVXNlckNhcmRzID0gcmVzdWx0cztcbiAgICBsb2cuZGVidWcoVXNlckNhcmRzKTtcbiAgICBkLnJlc29sdmUoKVxuICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgbG9nLmVycm9yKGUpXG4gICAgZC5yZWplY3QoZSlcbiAgfSlcbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuZ2V0QWxsVXNlckNhcmRzKClcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9zY3JpcHRzL2V2ZW50LXBhZ2UuanMiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi40LjJcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3QsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobnVsbCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmaXggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4uY2FsbCh0aGlzLCBwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucykge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IGluamVjdFtpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7fSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKGNvbXAuX19lc01vZHVsZSAmJiBjb21wLmRlZmF1bHQpIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBjaGlsZC5kYXRhICYmIGNoaWxkLmRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGNoaWxkLmRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5zZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycztcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycztcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tPcHRpb25UeXBlICh2bSwgbmFtZSkge1xuICB2YXIgb3B0aW9uID0gdm0uJG9wdGlvbnNbbmFtZV07XG4gIGlmICghaXNQbGFpbk9iamVjdChvcHRpb24pKSB7XG4gICAgd2FybihcbiAgICAgIChcImNvbXBvbmVudCBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzaG91bGQgYmUgYW4gb2JqZWN0LlwiKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpIHx8IGNvbmZpZy5pc1Jlc2VydmVkQXR0cihrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnY29tcHV0ZWQnKTtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciB8fCBub29wLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICdtZXRob2RzJyk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnd2F0Y2gnKTtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBrZXlPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChrZXlPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzb3VyY2UpIHtcbiAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwge30pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHBhcmVudDogY29udGV4dCxcbiAgICBsaXN0ZW5lcnM6IGRhdGEub24gfHwge30sXG4gICAgaW5qZWN0aW9uczogcmVzb2x2ZUluamVjdChDdG9yLm9wdGlvbnMuaW5qZWN0LCBjb250ZXh0KSxcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdm5vZGUuZnVuY3Rpb25hbE9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgJiYgd2FybihcbiAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhc1xuKSB7XG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChvdXJzLCBleGlzdGluZykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICBWdWUucHJvdG90eXBlLl9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDErKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi40LjInO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG5cbi8qXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQlxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgICB9XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAhYmFpbGVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXG4gICAgKTtcbiAgfVxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgXCIgKyAobW9kZWxScy5pZHgpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICB9XG59XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBzdHIgPSB2YWw7XG4gIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbCxcbiAgICAgIGlkeDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zdWJzdHJpbmcoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdCgkJHYpKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtsZXkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkICYmIChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiLz5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDBcbn1cblxuLy8gIzM2NjNcbi8vIElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IHNob3VsZERlY29kZSgnXFxuJywgJyYjMTA7JykgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4O1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBzaW5nbGVBdHRySWRlbnRpZmllciA9IC8oW15cXHNcIic8Pi89XSspLztcbnZhciBzaW5nbGVBdHRyQXNzaWduID0gLyg/Oj0pLztcbnZhciBzaW5nbGVBdHRyVmFsdWVzID0gW1xuICAvLyBhdHRyIHZhbHVlIGRvdWJsZSBxdW90ZXNcbiAgL1wiKFteXCJdKilcIisvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgc2luZ2xlIHF1b3Rlc1xuICAvJyhbXiddKiknKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBubyBxdW90ZXNcbiAgLyhbXlxcc1wiJz08PmBdKykvLnNvdXJjZVxuXTtcbnZhciBhdHRyaWJ1dGUgPSBuZXcgUmVnRXhwKFxuICAnXlxcXFxzKicgKyBzaW5nbGVBdHRySWRlbnRpZmllci5zb3VyY2UgK1xuICAnKD86XFxcXHMqKCcgKyBzaW5nbGVBdHRyQXNzaWduLnNvdXJjZSArICcpJyArXG4gICdcXFxccyooPzonICsgc2luZ2xlQXR0clZhbHVlcy5qb2luKCd8JykgKyAnKSk/J1xuKTtcblxuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXG4vLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xudmFyIHFuYW1lQ2FwdHVyZSA9ICcoKD86JyArIG5jbmFtZSArICdcXFxcOik/JyArIG5jbmFtZSArICcpJztcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKCdePCcgKyBxbmFtZUNhcHR1cmUpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKCdePFxcXFwvJyArIHFuYW1lQ2FwdHVyZSArICdbXj5dKj4nKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG52YXIgY29tbWVudCA9IC9ePCEtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMCk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCkge1xuICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmUsXG4gIHdhcm5cbikge1xuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBldmVudHNbbmFtZV07XG4gICAgLy8gIzUzMzA6IHdhcm4gY2xpY2sucmlnaHQsIHNpbmNlIHJpZ2h0IGNsaWNrcyBkbyBub3QgYWN0dWFsbHkgZmlyZSBjbGljayBldmVudHMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG5hbWUgPT09ICdjbGljaycgJiZcbiAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5tb2RpZmllcnMgJiYgaGFuZGxlci5tb2RpZmllcnMucmlnaHRcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiVXNlIFxcXCJjb250ZXh0bWVudVxcXCIgaW5zdGVhZCBvZiBcXFwiY2xpY2sucmlnaHRcXFwiIHNpbmNlIHJpZ2h0IGNsaWNrcyBcIiArXG4gICAgICAgIFwiZG8gbm90IGFjdHVhbGx5IGZpcmUgXFxcImNsaWNrXFxcIiBldmVudHMuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxuICB9XG4gIHJldHVybiBcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifX1cIlxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiAoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKCgodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8vIHZpbTp0cz00OnN0cz00OnN3PTQ6XG4vKiFcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE3IEtyaXMgS293YWwgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVRcbiAqIGxpY2Vuc2UgZm91bmQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2Jsb2IvdjEvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBQcmVmZXIgd2luZG93IG92ZXIgc2VsZiBmb3IgYWRkLW9uIHNjcmlwdHMuIFVzZSBzZWxmIGZvclxuICAgICAgICAvLyBub24td2luZG93ZWQgY29udGV4dHMuXG4gICAgICAgIHZhciBnbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcblxuICAgICAgICAvLyBHZXQgdGhlIGB3aW5kb3dgIG9iamVjdCwgc2F2ZSB0aGUgcHJldmlvdXMgUSBnbG9iYWxcbiAgICAgICAgLy8gYW5kIGluaXRpYWxpemUgUSBhcyBhIGdsb2JhbC5cbiAgICAgICAgdmFyIHByZXZpb3VzUSA9IGdsb2JhbC5RO1xuICAgICAgICBnbG9iYWwuUSA9IGRlZmluaXRpb24oKTtcblxuICAgICAgICAvLyBBZGQgYSBub0NvbmZsaWN0IGZ1bmN0aW9uIHNvIFEgY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgZ2xvYmFsLlEubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdsb2JhbC5RID0gcHJldmlvdXNRO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGVudmlyb25tZW50IHdhcyBub3QgYW50aWNpcGF0ZWQgYnkgUS4gUGxlYXNlIGZpbGUgYSBidWcuXCIpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNTdGFja3MgPSBmYWxzZTtcbnRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RhY2tzID0gISFlLnN0YWNrO1xufVxuXG4vLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWRcbi8vIGJ5IFEuXG52YXIgcVN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG52YXIgcUZpbGVOYW1lO1xuXG4vLyBzaGltc1xuXG4vLyB1c2VkIGZvciBmYWxsYmFjayBpbiBcImFsbFJlc29sdmVkXCJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cbnZhciBuZXh0VGljayA9KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbiAgICB2YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xuICAgIHZhciB0YWlsID0gaGVhZDtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSB2b2lkIDA7XG4gICAgdmFyIGlzTm9kZUpTID0gZmFsc2U7XG4gICAgLy8gcXVldWUgZm9yIGxhdGUgdGFza3MsIHVzZWQgYnkgdW5oYW5kbGVkIHJlamVjdGlvbiB0cmFja2luZ1xuICAgIHZhciBsYXRlclF1ZXVlID0gW107XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIHZhciB0YXNrLCBkb21haW47XG5cbiAgICAgICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgICAgIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgICAgICBoZWFkLnRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2ssIGRvbWFpbik7XG5cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGF0ZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhc2sgPSBsYXRlclF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJ1bnMgYSBzaW5nbGUgZnVuY3Rpb24gaW4gdGhlIGFzeW5jIHF1ZXVlXG4gICAgZnVuY3Rpb24gcnVuU2luZ2xlKHRhc2ssIGRvbWFpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV4dFRpY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgIGRvbWFpbjogaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4sXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcHJvY2Vzcy50b1N0cmluZygpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIEVuc3VyZSBRIGlzIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50LCB3aXRoIGEgYHByb2Nlc3MubmV4dFRpY2tgLlxuICAgICAgICAvLyBUbyBzZWUgdGhyb3VnaCBmYWtlIE5vZGUgZW52aXJvbm1lbnRzOlxuICAgICAgICAvLyAqIE1vY2hhIHRlc3QgcnVubmVyIC0gZXhwb3NlcyBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2BcbiAgICAgICAgLy8gKiBCcm93c2VyaWZ5IC0gZXhwb3NlcyBhIGBwcm9jZXNzLm5leFRpY2tgIGZ1bmN0aW9uIHRoYXQgdXNlc1xuICAgICAgICAvLyAgIGBzZXRUaW1lb3V0YC4gSW4gdGhpcyBjYXNlIGBzZXRJbW1lZGlhdGVgIGlzIHByZWZlcnJlZCBiZWNhdXNlXG4gICAgICAgIC8vICAgIGl0IGlzIGZhc3Rlci4gQnJvd3NlcmlmeSdzIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkc1xuICAgICAgICAvLyAgIFwiW29iamVjdCBPYmplY3RdXCIsIHdoaWxlIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50XG4gICAgICAgIC8vICAgYHByb2Nlc3MudG9TdHJpbmcoKWAgeWllbGRzIFwiW29iamVjdCBwcm9jZXNzXVwiLlxuICAgICAgICBpc05vZGVKUyA9IHRydWU7XG5cbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAvLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAvLyBBdCBsZWFzdCBTYWZhcmkgVmVyc2lvbiA2LjAuNSAoODUzNi4zMC4xKSBpbnRlcm1pdHRlbnRseSBjYW5ub3QgY3JlYXRlXG4gICAgICAgIC8vIHdvcmtpbmcgbWVzc2FnZSBwb3J0cyB0aGUgZmlyc3QgdGltZSBhIHBhZ2UgbG9hZHMuXG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSByZXF1ZXN0UG9ydFRpY2s7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3RQb3J0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIHJlcXVpcmVzIHVzIHRvIHByb3ZpZGUgYSBtZXNzYWdlIHBheWxvYWQsIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgd2UgdXNlIGl0LlxuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RQb3J0VGljaygpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJ1bnMgYSB0YXNrIGFmdGVyIGFsbCBvdGhlciB0YXNrcyBoYXZlIGJlZW4gcnVuXG4gICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmcgdGhhdCBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciBhbGwgYHRoZW5gZCB0YXNrcyBoYXZlIGJlZW4gcnVuLlxuICAgIG5leHRUaWNrLnJ1bkFmdGVyID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgbGF0ZXJRdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9kZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgb2JqW3Byb3BdID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2tcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwID0gcHJvbWlzZTsgISFwOyBwID0gcC5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChwLnN0YWNrICYmICghZXJyb3IuX19taW5pbXVtU3RhY2tDb3VudGVyX18gfHwgZXJyb3IuX19taW5pbXVtU3RhY2tDb3VudGVyX18gPiBwLnN0YWNrQ291bnRlcikpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RfZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwiX19taW5pbXVtU3RhY2tDb3VudGVyX19cIiwge3ZhbHVlOiBwLnN0YWNrQ291bnRlciwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgc3RhY2tzLnVuc2hpZnQocC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnVuc2hpZnQoZXJyb3Iuc3RhY2spO1xuXG4gICAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKFwiXFxuXCIgKyBTVEFDS19KVU1QX1NFUEFSQVRPUiArIFwiXFxuXCIpO1xuICAgICAgICB2YXIgc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgICAgIG9iamVjdF9kZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJzdGFja1wiLCB7dmFsdWU6IHN0YWNrLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN0YWNrU3RyaW5nKHN0YWNrU3RyaW5nKSB7XG4gICAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGRlc2lyZWRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICAgICAgZGVzaXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVGcmFtZShzdGFja0xpbmUpIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoXCIobW9kdWxlLmpzOlwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgc3RhY2tMaW5lLmluZGV4T2YoXCIobm9kZS5qczpcIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKSB7XG4gICAgLy8gTmFtZWQgZnVuY3Rpb25zOiBcImF0IGZ1bmN0aW9uTmFtZSAoZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXIpXCJcbiAgICAvLyBJbiBJRTEwIGZ1bmN0aW9uIG5hbWUgY2FuIGhhdmUgc3BhY2VzIChcIkFub255bW91cyBmdW5jdGlvblwiKSBPX29cbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldO1xuICAgIH1cblxuICAgIC8vIEFub255bW91cyBmdW5jdGlvbnM6IFwiYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MiA9IC9hdCAoW14gXSspOihcXGQrKTooPzpcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDIpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MlsxXSwgTnVtYmVyKGF0dGVtcHQyWzJdKV07XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogXCJmdW5jdGlvbkBmaWxlbmFtZTpsaW5lTnVtYmVyIG9yIEBmaWxlbmFtZTpsaW5lTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDMgPSAvLipAKC4rKTooXFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQzKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDNbMV0sIE51bWJlcihhdHRlbXB0M1syXSldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcm5hbEZyYW1lKHN0YWNrTGluZSkge1xuICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKTtcblxuICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG5cbiAgICByZXR1cm4gZmlsZU5hbWUgPT09IHFGaWxlTmFtZSAmJlxuICAgICAgICBsaW5lTnVtYmVyID49IHFTdGFydGluZ0xpbmUgJiZcbiAgICAgICAgbGluZU51bWJlciA8PSBxRW5kaW5nTGluZTtcbn1cblxuLy8gZGlzY292ZXIgb3duIGZpbGUgbmFtZSBhbmQgbGluZSBudW1iZXIgcmFuZ2UgZm9yIGZpbHRlcmluZyBzdGFja1xuLy8gdHJhY2VzXG5mdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXNbMF0uaW5kZXhPZihcIkBcIikgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihmaXJzdExpbmUpO1xuICAgICAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcUZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKGNhbGxiYWNrLCBuYW1lLCBhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcIiArIGFsdGVybmF0aXZlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpbnN0ZWFkLlwiLCBuZXcgRXJyb3IoXCJcIikuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vLyBlbmQgb2Ygc2hpbXNcbi8vIGJlZ2lubmluZyBvZiByZWFsIHdvcmtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZSwgcGFzc2VzIHByb21pc2VzIHRocm91Z2gsIG9yXG4gKiBjb2VyY2VzIHByb21pc2VzIGZyb20gZGlmZmVyZW50IHN5c3RlbXMuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZSBvciBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIFEodmFsdWUpIHtcbiAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIGFscmVhZHkgYSBQcm9taXNlLCByZXR1cm4gaXQgZGlyZWN0bHkuICBUaGlzIGVuYWJsZXNcbiAgICAvLyB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB0byBib3RoIGJlIHVzZWQgdG8gY3JlYXRlZCByZWZlcmVuY2VzIGZyb20gb2JqZWN0cyxcbiAgICAvLyBidXQgdG8gdG9sZXJhYmx5IGNvZXJjZSBub24tcHJvbWlzZXMgdG8gcHJvbWlzZXMuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gYXNzaW1pbGF0ZSB0aGVuYWJsZXNcbiAgICBpZiAoaXNQcm9taXNlQWxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsKHZhbHVlKTtcbiAgICB9XG59XG5RLnJlc29sdmUgPSBRO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdGFza1xuICovXG5RLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qKlxuICogQ29udHJvbHMgd2hldGhlciBvciBub3QgbG9uZyBzdGFjayB0cmFjZXMgd2lsbCBiZSBvblxuICovXG5RLmxvbmdTdGFja1N1cHBvcnQgPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgY291bnRlciBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc3RvcHBpbmcgcG9pbnQgZm9yIGJ1aWxkaW5nXG4gKiBsb25nIHN0YWNrIHRyYWNlcy4gSW4gbWFrZVN0YWNrVHJhY2VMb25nIHdlIHdhbGsgYmFja3dhcmRzIHRocm91Z2hcbiAqIHRoZSBsaW5rZWQgbGlzdCBvZiBwcm9taXNlcywgb25seSBzdGFja3Mgd2hpY2ggd2VyZSBjcmVhdGVkIGJlZm9yZVxuICogdGhlIHJlamVjdGlvbiBhcmUgY29uY2F0ZW5hdGVkLlxuICovXG52YXIgbG9uZ1N0YWNrQ291bnRlciA9IDE7XG5cbi8vIGVuYWJsZSBsb25nIHN0YWNrcyBpZiBRX0RFQlVHIGlzIHNldFxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuUV9ERUJVRykge1xuICAgIFEubG9uZ1N0YWNrU3VwcG9ydCA9IHRydWU7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyZXJWYWx1ZSA9IG5lYXJlcihyZXNvbHZlZFByb21pc2UpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKG5lYXJlclZhbHVlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmVhcmVyVmFsdWU7IC8vIHNob3J0ZW4gY2hhaW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVyVmFsdWU7XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBlbmRpbmdcIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFByb21pc2UuaW5zcGVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrQ291bnRlciA9IGxvbmdTdGFja0NvdW50ZXIrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IHdlIGRvIHRoZSBjaGVja3MgZm9yIGByZXNvbHZlZFByb21pc2VgIGluIGVhY2ggbWV0aG9kLCBpbnN0ZWFkIG9mXG4gICAgLy8gY29uc29saWRhdGluZyB0aGVtIGludG8gYGJlY29tZWAsIHNpbmNlIG90aGVyd2lzZSB3ZSdkIGNyZWF0ZSBuZXdcbiAgICAvLyBwcm9taXNlcyB3aXRoIHRoZSBsaW5lcyBgYmVjb21lKHdoYXRldmVyKHZhbHVlKSlgLiBTZWUgZS5nLiBHSC0yNTIuXG5cbiAgICBmdW5jdGlvbiBiZWNvbWUobmV3UHJvbWlzZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZXdQcm9taXNlO1xuXG4gICAgICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGhvbGQgYSByZWZlcmVuY2UgdG8gdGhlIG5ldyBwcm9taXNlIGlmIGxvbmcgc3RhY2tzXG4gICAgICAgICAgICAvLyBhcmUgZW5hYmxlZCB0byByZWR1Y2UgbWVtb3J5IHVzYWdlXG4gICAgICAgICAgICBwcm9taXNlLnNvdXJjZSA9IG5ld1Byb21pc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UobWVzc2FnZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5ld1Byb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KG5ld1Byb21pc2UsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG5cbiAgICAgICAgbWVzc2FnZXMgPSB2b2lkIDA7XG4gICAgICAgIHByb2dyZXNzTGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIH1cblxuICAgIGRlZmVycmVkLnByb21pc2UgPSBwcm9taXNlO1xuICAgIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKFEodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgZGVmZXJyZWQuZnVsZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoZnVsZmlsbCh2YWx1ZSkpO1xuICAgIH07XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUocmVqZWN0KHJlYXNvbikpO1xuICAgIH07XG4gICAgZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9ncmVzc0xpc3RlbmVycywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvZ3Jlc3NMaXN0ZW5lcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBOb2RlLXN0eWxlIGNhbGxiYWNrIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAqIHByb21pc2UuXG4gKiBAcmV0dXJucyBhIG5vZGViYWNrXG4gKi9cbmRlZmVyLnByb3RvdHlwZS5tYWtlTm9kZVJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSByZXNvbHZlciB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vdGhpbmcgYW5kIGFjY2VwdHNcbiAqIHRoZSByZXNvbHZlLCByZWplY3QsIGFuZCBub3RpZnkgZnVuY3Rpb25zIGZvciBhIGRlZmVycmVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgbWF5IGJlIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIHJlc29sdmUgYW5kIHJlamVjdFxuICogZnVuY3Rpb25zLCBvciByZWplY3RlZCBieSBhIHRocm93biBleGNlcHRpb24gaW4gcmVzb2x2ZXJcbiAqL1xuUS5Qcm9taXNlID0gcHJvbWlzZTsgLy8gRVM2XG5RLnByb21pc2UgPSBwcm9taXNlO1xuZnVuY3Rpb24gcHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxucHJvbWlzZS5yYWNlID0gcmFjZTsgLy8gRVM2XG5wcm9taXNlLmFsbCA9IGFsbDsgLy8gRVM2XG5wcm9taXNlLnJlamVjdCA9IHJlamVjdDsgLy8gRVM2XG5wcm9taXNlLnJlc29sdmUgPSBROyAvLyBFUzZcblxuLy8gWFhYIGV4cGVyaW1lbnRhbC4gIFRoaXMgbWV0aG9kIGlzIGEgd2F5IHRvIGRlbm90ZSB0aGF0IGEgbG9jYWwgdmFsdWUgaXNcbi8vIHNlcmlhbGl6YWJsZSBhbmQgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IGRpc3BhdGNoZWQgdG8gYSByZW1vdGUgdXBvbiByZXF1ZXN0LFxuLy8gaW5zdGVhZCBvZiBwYXNzaW5nIGEgcmVmZXJlbmNlLlxuUS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgdHdvIHByb21pc2VzIGV2ZW50dWFsbHkgZnVsZmlsbCB0byB0aGUgc2FtZSB2YWx1ZSwgcHJvbWlzZXMgdGhhdCB2YWx1ZSxcbiAqIGJ1dCBvdGhlcndpc2UgcmVqZWN0cy5cbiAqIEBwYXJhbSB4IHtBbnkqfVxuICogQHBhcmFtIHkge0FueSp9XG4gKiBAcmV0dXJucyB7QW55Kn0gYSBwcm9taXNlIGZvciB4IGFuZCB5IGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBidXQgYSByZWplY3Rpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKi9cblEuam9pbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIFEoeCkuam9pbih5KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHJldHVybiBRKFt0aGlzLCB0aGF0XSkuc3ByZWFkKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBcIj09PVwiIHNob3VsZCBiZSBPYmplY3QuaXMgb3IgZXF1aXZcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCBqb2luOiBub3QgdGhlIHNhbWU6IFwiICsgeCArIFwiIFwiICsgeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmaXJzdCBvZiBhbiBhcnJheSBvZiBwcm9taXNlcyB0byBiZWNvbWUgc2V0dGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHNldHRsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byB0aGlzIG9uY2Ugd2UgY2FuIGFzc3VtZSBhdCBsZWFzdCBFUzVcbiAgICAgICAgLy8gYW5zd2VyUHMuZm9yRWFjaChmdW5jdGlvbiAoYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblEudGFwID0gZnVuY3Rpb24gKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGFwKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogV29ya3MgYWxtb3N0IGxpa2UgXCJmaW5hbGx5XCIsIGJ1dCBub3QgY2FsbGVkIGZvciByZWplY3Rpb25zLlxuICogT3JpZ2luYWwgcmVzb2x1dGlvbiB2YWx1ZSBpcyBwYXNzZWQgdGhyb3VnaCBjYWxsYmFjayB1bmFmZmVjdGVkLlxuICogQ2FsbGJhY2sgbWF5IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGF3YWl0ZWQgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtRLlByb21pc2V9XG4gKiBAZXhhbXBsZVxuICogZG9Tb21ldGhpbmcoKVxuICogICAudGhlbiguLi4pXG4gKiAgIC50YXAoY29uc29sZS5sb2cpXG4gKiAgIC50aGVuKC4uLik7XG4gKi9cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwodmFsdWUpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKHJlYXNvbi5zdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKFwiKG5vIHN0YWNrKSBcIiArIHJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdFJlcG9ydCA9IGFycmF5X2luZGV4T2YocmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICBpZiAoYXRSZXBvcnQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInJlamVjdGlvbkhhbmRsZWRcIiwgdW5oYW5kbGVkUmVhc29uc1thdF0sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0UmVwb3J0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRKGV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3BlbmRpbmdDb3VudDtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tcGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChwZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSBvZiBhbiBhcnJheS4gUHJpb3IgcmVqZWN0ZWQgcHJvbWlzZXMgYXJlXG4gKiBpZ25vcmVkLiAgUmVqZWN0cyBvbmx5IGlmIGFsbCBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgY29udGFpbmluZyB2YWx1ZXMgb3IgcHJvbWlzZXMgZm9yIHZhbHVlc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSxcbiAqIG9yIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICovXG5RLmFueSA9IGFueTtcblxuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpO1xuICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZXNbaW5kZXhdO1xuXG4gICAgICAgIHBlbmRpbmdDb3VudCsrO1xuXG4gICAgICAgIHdoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpO1xuICAgICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXN1bHQpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblJlamVjdGVkKGVycikge1xuICAgICAgICAgICAgcGVuZGluZ0NvdW50LS07XG4gICAgICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSAoXCJRIGNhbid0IGdldCBmdWxmaWxsbWVudCB2YWx1ZSBmcm9tIGFueSBwcm9taXNlLCBhbGwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInByb21pc2VzIHdlcmUgcmVqZWN0ZWQuIExhc3QgZXJyb3IgbWVzc2FnZTogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2dyZXNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHVuZGVmaW5lZCk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbnkodGhpcyk7XG59O1xuXG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgdG8gYmUgc2V0dGxlZCwgZWl0aGVyIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuICBUaGlzIGlzIGRpc3RpbmN0IGZyb20gYGFsbGAgc2luY2UgdGhhdCB3b3VsZCBzdG9wXG4gKiB3YWl0aW5nIGF0IHRoZSBmaXJzdCByZWplY3Rpb24uICBUaGUgcHJvbWlzZSByZXR1cm5lZCBieVxuICogYGFsbFJlc29sdmVkYCB3aWxsIG5ldmVyIGJlIHJlamVjdGVkLlxuICogQHBhcmFtIHByb21pc2VzIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgKG9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuICogKG9yIHZhbHVlcylcbiAqIEByZXR1cm4gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBwcm9taXNlc1xuICovXG5RLmFsbFJlc29sdmVkID0gZGVwcmVjYXRlKGFsbFJlc29sdmVkLCBcImFsbFJlc29sdmVkXCIsIFwiYWxsU2V0dGxlZFwiKTtcbmZ1bmN0aW9uIGFsbFJlc29sdmVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICBwcm9taXNlcyA9IGFycmF5X21hcChwcm9taXNlcywgUSk7XG4gICAgICAgIHJldHVybiB3aGVuKGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hlbihwcm9taXNlLCBub29wLCBub29wKTtcbiAgICAgICAgfSkpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsUmVzb2x2ZWQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBzZWUgUHJvbWlzZSNhbGxTZXR0bGVkXG4gKi9cblEuYWxsU2V0dGxlZCA9IGFsbFNldHRsZWQ7XG5mdW5jdGlvbiBhbGxTZXR0bGVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZXMpLmFsbFNldHRsZWQoKTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlaXIgc3RhdGVzIChhc1xuICogcmV0dXJuZWQgYnkgYGluc3BlY3RgKSB3aGVuIHRoZXkgaGF2ZSBhbGwgc2V0dGxlZC5cbiAqIEBwYXJhbSB7QXJyYXlbQW55Kl19IHZhbHVlcyBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyB7QXJyYXlbU3RhdGVdfSBhbiBhcnJheSBvZiBzdGF0ZXMgZm9yIHRoZSByZXNwZWN0aXZlIHZhbHVlcy5cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuYWxsU2V0dGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICByZXR1cm4gYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBRKHByb21pc2UpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnYXJkbGVzcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlZ2FyZGxlc3MsIHJlZ2FyZGxlc3MpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENhcHR1cmVzIHRoZSBmYWlsdXJlIG9mIGEgcHJvbWlzZSwgZ2l2aW5nIGFuIG9wb3J0dW5pdHkgdG8gcmVjb3ZlclxuICogd2l0aCBhIGNhbGxiYWNrLiAgSWYgdGhlIGdpdmVuIHByb21pc2UgaXMgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAqIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGZ1bGZpbGwgdGhlIHJldHVybmVkIHByb21pc2UgaWYgdGhlXG4gKiBnaXZlbiBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrXG4gKi9cblEuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGxpc3RlbmVyIHRoYXQgY2FuIHJlc3BvbmQgdG8gcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBmcm9tIGFcbiAqIHByb21pc2UncyBvcmlnaW5hdGluZyBkZWZlcnJlZC4gVGhpcyBsaXN0ZW5lciByZWNlaXZlcyB0aGUgZXhhY3QgYXJndW1lbnRzXG4gKiBwYXNzZWQgdG8gYGBkZWZlcnJlZC5ub3RpZnlgYC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byByZWNlaXZlIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJucyB0aGUgZ2l2ZW4gcHJvbWlzZSwgdW5jaGFuZ2VkXG4gKi9cblEucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmZ1bmN0aW9uIHByb2dyZXNzKG9iamVjdCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gb2JzZXJ2ZSB0aGUgc2V0dGxpbmcgb2YgYSBwcm9taXNlLFxuICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBvciByZWplY3RlZC4gIEZvcndhcmRzXG4gKiB0aGUgcmVzb2x1dGlvbiB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aGVuIHRoZSBjYWxsYmFjayBpcyBkb25lLlxuICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBwcm9taXNlIHRvIGRlZmVyIGNvbXBsZXRpb24uXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIG9ic2VydmUgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuXG4gKiBwcm9taXNlLCB0YWtlcyBubyBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIHdoZW5cbiAqIGBgZmluYGAgaXMgZG9uZS5cbiAqL1xuUS5maW4gPSAvLyBYWFggbGVnYWN5XG5RW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KVtcImZpbmFsbHlcIl0oY2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmluID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2suYXBwbHkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRIGNhbid0IGFwcGx5IGZpbmFsbHkgY2FsbGJhY2tcIik7XG4gICAgfVxuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVE9ETyBhdHRlbXB0IHRvIHJlY3ljbGUgdGhlIHJlamVjdGlvbiB3aXRoIFwidGhpc1wiLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcywgZm9yY2luZyByZWplY3Rpb25zIHRvIGJlXG4gKiB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBhdCB0aGUgZW5kIG9mIGEgY2hhaW4gb2YgcHJvbWlzZXNcbiAqIEByZXR1cm5zIG5vdGhpbmdcbiAqL1xuUS5kb25lID0gZnVuY3Rpb24gKG9iamVjdCwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRvbmUoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGZvcndhcmQgdG8gYSBmdXR1cmUgdHVybiBzbyB0aGF0IGBgd2hlbmBgXG4gICAgICAgIC8vIGRvZXMgbm90IGNhdGNoIGl0IGFuZCB0dXJuIGl0IGludG8gYSByZWplY3Rpb24uXG4gICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IGBuZXh0VGlja2BpbmcgdmlhIGFuIHVubmVjZXNzYXJ5IGB3aGVuYC5cbiAgICB2YXIgcHJvbWlzZSA9IGZ1bGZpbGxlZCB8fCByZWplY3RlZCB8fCBwcm9ncmVzcyA/XG4gICAgICAgIHRoaXMudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykgOlxuICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgICAgb25VbmhhbmRsZWRFcnJvciA9IHByb2Nlc3MuZG9tYWluLmJpbmQob25VbmhhbmRsZWRFcnJvcik7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKHZvaWQgMCwgb25VbmhhbmRsZWRFcnJvcik7XG59O1xuXG4vKipcbiAqIENhdXNlcyBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgaWYgaXQgZG9lcyBub3QgZ2V0IGZ1bGZpbGxlZCBiZWZvcmVcbiAqIHNvbWUgbWlsbGlzZWNvbmRzIHRpbWUgb3V0LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzIHRpbWVvdXRcbiAqIEBwYXJhbSB7QW55Kn0gY3VzdG9tIGVycm9yIG1lc3NhZ2Ugb3IgRXJyb3Igb2JqZWN0IChvcHRpb25hbClcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgaWYgaXQgaXNcbiAqIGZ1bGZpbGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAqL1xuUS50aW1lb3V0ID0gZnVuY3Rpb24gKG9iamVjdCwgbXMsIGVycm9yKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aW1lb3V0KG1zLCBlcnJvcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBlcnJvcikge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVycm9yIHx8IFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IgfHwgXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyBtcyArIFwiIG1zXCIpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICB9LCBtcyk7XG5cbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9LCBkZWZlcnJlZC5ub3RpZnkpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgKG9yIHByb21pc2VkIHZhbHVlKSwgc29tZVxuICogbWlsbGlzZWNvbmRzIGFmdGVyIGl0IHJlc29sdmVkLiBQYXNzZXMgcmVqZWN0aW9ucyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBhZnRlciBtaWxsaXNlY29uZHNcbiAqIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSByZWplY3RzLCB0aGF0IGlzIHBhc3NlZCBpbW1lZGlhdGVseS5cbiAqL1xuUS5kZWxheSA9IGZ1bmN0aW9uIChvYmplY3QsIHRpbWVvdXQpIHtcbiAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kZWxheSh0aW1lb3V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGFzIGFuIGFycmF5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogICAgICBRLm5mYXBwbHkoRlMucmVhZEZpbGUsIFtfX2ZpbGVuYW1lXSlcbiAqICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqICAgICAgfSlcbiAqXG4gKi9cblEubmZhcHBseSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgaW5kaXZpZHVhbGx5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmNhbGwoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpXG4gKiAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogfSlcbiAqXG4gKi9cblEubmZjYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIE5vZGVKUyBjb250aW51YXRpb24gcGFzc2luZyBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbiBlcXVpdmFsZW50XG4gKiB2ZXJzaW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmJpbmQoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpKFwidXRmLThcIilcbiAqIC50aGVuKGNvbnNvbGUubG9nKVxuICogLmRvbmUoKVxuICovXG5RLm5mYmluZCA9XG5RLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3Qgd3JhcCBhbiB1bmRlZmluZWQgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIFEoY2FsbGJhY2spLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZiaW5kID1cblByb21pc2UucHJvdG90eXBlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEuZGVub2RlaWZ5LmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG5RLm5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFEoYm91bmQpLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmJpbmQgPSBmdW5jdGlvbiAoLyp0aGlzcCwgLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDApO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5uYmluZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIHdpdGggYSBnaXZlbiBhcnJheSBvZiBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZCBjYWxsYmFjay5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLm5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkubnBvc3QobmFtZSwgYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLm5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzIHx8IFtdKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2ssIGZvcndhcmRpbmcgdGhlIGdpdmVuIHZhcmlhZGljIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBhcmd1bWVudC5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSAuLi5hcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFjayB3aWxsXG4gKiBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblEubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUS5uaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5Qcm9taXNlLnByb3RvdHlwZS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5Qcm9taXNlLnByb3RvdHlwZS5uaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogSWYgYSBmdW5jdGlvbiB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgYm90aCBOb2RlIGNvbnRpbnVhdGlvbi1wYXNzaW5nLXN0eWxlIGFuZFxuICogcHJvbWlzZS1yZXR1cm5pbmctc3R5bGUsIGl0IGNhbiBlbmQgaXRzIGludGVybmFsIHByb21pc2UgY2hhaW4gd2l0aFxuICogYG5vZGVpZnkobm9kZWJhY2spYCwgZm9yd2FyZGluZyB0aGUgb3B0aW9uYWwgbm9kZWJhY2sgYXJndW1lbnQuICBJZiB0aGUgdXNlclxuICogZWxlY3RzIHRvIHVzZSBhIG5vZGViYWNrLCB0aGUgcmVzdWx0IHdpbGwgYmUgc2VudCB0aGVyZS4gIElmIHRoZXkgZG8gbm90XG4gKiBwYXNzIGEgbm9kZWJhY2ssIHRoZXkgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgcHJvbWlzZS5cbiAqIEBwYXJhbSBvYmplY3QgYSByZXN1bHQgKG9yIGEgcHJvbWlzZSBmb3IgYSByZXN1bHQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBub2RlYmFjayBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zIGVpdGhlciB0aGUgcHJvbWlzZSBvciBub3RoaW5nXG4gKi9cblEubm9kZWlmeSA9IG5vZGVpZnk7XG5mdW5jdGlvbiBub2RlaWZ5KG9iamVjdCwgbm9kZWJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5vZGVpZnkobm9kZWJhY2spO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrKSB7XG4gICAgaWYgKG5vZGViYWNrKSB7XG4gICAgICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJRLm5vQ29uZmxpY3Qgb25seSB3b3JrcyB3aGVuIFEgaXMgdXNlZCBhcyBhIGdsb2JhbFwiKTtcbn07XG5cbi8vIEFsbCBjb2RlIGJlZm9yZSB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMuXG52YXIgcUVuZGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xuXG5yZXR1cm4gUTtcblxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3EvcS5qcyIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwiaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgUSBmcm9tICdxJztcbmltcG9ydCBBbGdvbGlhIGZyb20gJ2FsZ29saWFzZWFyY2gnO1xuXG5sb2cuc2V0TGV2ZWwoJ2RlYnVnJylcblxuY29uc3QgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpO1xufVxuXG5jb25zdCBTZWFyY2ggPSB7XG4gIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgbG9nLnRyYWNlKG9wdGlvbnMpO1xuICAgIGNvbnN0IEFsZ29saWFDbGllbnQgPSBBbGdvbGlhKG9wdGlvbnMuYXBwSUQsIG9wdGlvbnMuYXBpS2V5LCB7XG4gICAgICBwcm90b2NvbDogJ2h0dHBzOidcbiAgICB9KVxuICAgIGNvbnN0IEFsZ29saWFJbmRleCA9IEFsZ29saWFDbGllbnQuaW5pdEluZGV4KG9wdGlvbnMuaW5kZXgpO1xuXG5cbiAgICBjb25zdCBhZHZhbmNlZFNlYXJjaCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgQWxnb2xpYUluZGV4LmNsZWFyQ2FjaGUoKVxuICAgICAgQWxnb2xpYUluZGV4LnNlYXJjaChwYXJhbXMsIGZ1bmN0aW9uKGUsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBsb2cudHJhY2UoZSk7XG4gICAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaExpc3RJdGVtQ2FyZHMoY29udGVudC5oaXRzKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZC5yZXNvbHZlKGNvbnRlbnQuaGl0cylcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkLnByb21pc2VcbiAgICB9XG5cbiAgICBjb25zdCBzZWFyY2hDYXJkcyA9IGZ1bmN0aW9uKHVzZXJJRCwgc2VhcmNoVGV4dCwgaGl0c1BlclBhZ2UpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgcXVlcnk6IHNlYXJjaFRleHQsXG4gICAgICAgIGZpbHRlcnM6IHVzZXJJRC5sZW5ndGggPyAndXNlcklEOiAnICsgdXNlcklEIDogJycsXG4gICAgICAgIGhpdHNQZXJQYWdlOiBoaXRzUGVyUGFnZSB8fCBudWxsXG4gICAgICB9O1xuICAgICAgbG9nLnRyYWNlKHBhcmFtcyk7XG4gICAgICBhZHZhbmNlZFNlYXJjaChwYXJhbXMpXG4gICAgICAudGhlbihmdW5jdGlvbihoaXRzKSB7XG4gICAgICAgIGxvZy50cmFjZShoaXRzKTtcbiAgICAgICAgZC5yZXNvbHZlKGhpdHMpXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGQucmVqZWN0KGUpO1xuICAgICAgfSlcbiAgICAgIHJldHVybiBkLnByb21pc2VcbiAgICB9XG5cbiAgICBjb25zdCBmZXRjaExpc3RJdGVtQ2FyZHMgPSBmdW5jdGlvbihjYXJkcykge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW11cbiAgICAgIGNhcmRzLmZvckVhY2goZnVuY3Rpb24oY2FyZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShjYXJkKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGNhcmQuY29udGVudCkpO1xuICAgICAgICBjYXJkID0gY29ycmVjdENhcmQoY2FyZClcbiAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY2FyZC5jb250ZW50KSk7XG4gICAgICAgIGNhcmQuY29udGVudC5saXN0Q2FyZHMgPSBbXVxuICAgICAgICBpZiAoIWNhcmQuY29udGVudC5saXN0SXRlbXMpIGNhcmQuY29udGVudC5saXN0SXRlbXMgPSBbXVxuICAgICAgICBjYXJkLmNvbnRlbnQubGlzdEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgICAgICBjb25zdCBwID0gUS5kZWZlcigpXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChnZXRDYXJkKGtleSkpIC8vIERvIHdlIG5lZWQgdG8gbm90aWZ5IHRoZSBjYXJkIG9yIHByb3ZpZGUgY2FsbGJhY2tzIGV0YyBoZXJlP1xuICAgICAgICAgIC8vIHByb21pc2VzLnB1c2gocC5wcm9taXNlKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGxvZy50cmFjZShwcm9taXNlcyk7XG4gICAgICBRLmFsbFNldHRsZWQocHJvbWlzZXMpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAgICBjb25zb2xlLmxvZyhjYXJkcyk7XG4gICAgICAgIGQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbG9nLnRyYWNlKGUpO1xuICAgICAgICBkLnJlamVjdChlKVxuICAgICAgfSlcbiAgICAgIHJldHVybiBkLnByb21pc2VcbiAgICB9XG5cbiAgICBjb25zdCBnZXRDYXJkID0gZnVuY3Rpb24ob2JqZWN0SUQpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIEFsZ29saWFJbmRleC5nZXRPYmplY3Qob2JqZWN0SUQsIGZ1bmN0aW9uKGUsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBsb2cudHJhY2UoZSk7XG4gICAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkLnJlc29sdmUoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgY29ycmVjdENhcmQgPSBmdW5jdGlvbihjYXJkKSB7XG4gICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShjYXJkLmNvbnRlbnQpKTtcbiAgICAgIGlmICghY2FyZC5jb250ZW50KSBjYXJkLmNvbnRlbnQgPSB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBjYXJkLmRlc2NyaXB0aW9uIHx8IGNhcmQuc2VudGVuY2UgfHwgY2FyZC50ZXh0LFxuICAgICAgICBsaXN0SXRlbXM6IGNhcmQubGlzdEl0ZW1zIHx8IFtdLFxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY2FyZC5jb250ZW50KSk7XG4gICAgICBpZiAoY2FyZC5zZW50ZW5jZSkgZGVsZXRlIGNhcmQuc2VudGVuY2VcbiAgICAgIGlmIChjYXJkLnRleHQpIGRlbGV0ZSBjYXJkLnRleHRcbiAgICAgIGlmIChjYXJkLmRlc2NyaXB0aW9uKSBkZWxldGUgY2FyZC5kZXNjcmlwdGlvblxuICAgICAgaWYgKGNhcmQub2JqZWN0SUQgPT0gXCI2MjQzOTEwMDJcIikgY29uc29sZS5sb2coaGl0KTtcbiAgICAgIHJldHVybiBjYXJkXG4gICAgfVxuXG4gICAgY29uc3QgY29tcG91bmRTZWFyY2ggPSBmdW5jdGlvbih1c2VySUQsIHNlYXJjaFRleHQpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIGNvbnN0IG1heExlbmd0aCA9IDQwMDtcbiAgICAgIGNvbnN0IHNlYXJjaFRleHRBcnJheSA9IFtdO1xuICAgICAgY29uc3QgaGl0c1BlclBhZ2UgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmNlaWwoMTAgLyAoc2VhcmNoVGV4dC5sZW5ndGggLyBtYXhMZW5ndGgpKSwgMyksIDEyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VhcmNoVGV4dC5sZW5ndGg7IGkgKz0gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHNlYXJjaFRleHRBcnJheS5wdXNoKHNlYXJjaFRleHQuc3Vic3RyaW5nKGksIGkrbWF4TGVuZ3RoKSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb21pc2VzID0gc2VhcmNoVGV4dEFycmF5Lm1hcChmdW5jdGlvbih0LCBqKSB7XG4gICAgICAgIHJldHVybiBzZWFyY2hDYXJkcyh1c2VySUQsIHQsIGhpdHNQZXJQYWdlKTtcbiAgICAgIH0pO1xuICAgICAgUS5hbGxTZXR0bGVkKHByb21pc2VzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0cy5tYXAoZnVuY3Rpb24ocikge3JldHVybiByLnZhbHVlfSkpO1xuICAgICAgICByZXN1bHRzID0gcmVtb3ZlRHVwbGljYXRlcyhyZXN1bHRzLCAnb2JqZWN0SUQnKVxuICAgICAgICBsb2cudHJhY2UocmVzdWx0cyk7XG4gICAgICAgIGQucmVzb2x2ZShyZXN1bHRzKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGxvZy50cmFjZShlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbihvcmlnaW5hbEFycmF5LCBvYmpLZXkpIHtcbiAgICAgIHZhciB0cmltbWVkQXJyYXkgPSBbXSwgdmFsdWVzID0gW10sIHZhbHVlO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9yaWdpbmFsQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvcmlnaW5hbEFycmF5W2ldW29iaktleV07XG4gICAgICAgIGlmKHZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICB0cmltbWVkQXJyYXkucHVzaChvcmlnaW5hbEFycmF5W2ldKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmltbWVkQXJyYXk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tQYWdlSGl0ID0gZnVuY3Rpb24ocGFnZURhdGEsIHJlc3VsdHMpIHtcbiAgICAgIC8vTm90IHlldCBhY2NvdW50aW5nIGZvciBjYXBpdGFsc1xuICAgICAgY29uc3QgYm9yaW5nV29yZHMgPSBbXG4gICAgICAgICdmYXZvdXJpdGUnLFxuICAgICAgICAnd29ybGQnLFxuICAgICAgICAnbmFtZScsXG4gICAgICAgICd0aGlzJyxcbiAgICAgICAgJ3BsYW4nLFxuICAgICAgICAnbmVlZCcsXG4gICAgICAgICdiZXN0JyxcbiAgICAgICAgJ2xpa2UnLFxuICAgICAgICAndGhlJyxcbiAgICAgICAgJ2FyZScsXG4gICAgICAgICdpcycsXG4gICAgICAgICdteScsXG4gICAgICAgICdteScsXG4gICAgICBdXG4gICAgICBjb25zdCBoaXRzID0gW107XG4gICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0LCBpKSB7XG4gICAgICAgIGxvZy50cmFjZSgnLS0tJyk7XG4gICAgICAgIGxvZy50cmFjZShpKTtcbiAgICAgICAgdmFyIGNvdW50ID0gW107XG4gICAgICAgIHJlc3VsdC5jb250ZXh0LmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgIGlmIChwYWdlRGF0YS5wYWdlVGV4dC5pbmRleE9mKGMudmFsdWUpID4gLTFcbiAgICAgICAgICAmJiBoaXRzLmluZGV4T2YocmVzdWx0Lm9iamVjdElEKSA9PSAtMVxuICAgICAgICAgICYmIGMudmFsdWUgJiYgYy52YWx1ZS5sZW5ndGggPiAzXG4gICAgICAgICAgJiYgYm9yaW5nV29yZHMuaW5kZXhPZihjLnZhbHVlKSA9PSAtMVxuICAgICAgICAgICYmIGNvdW50LmluZGV4T2YoYy52YWx1ZSkgPT0gLTEpIHtcbiAgICAgICAgICAgIGxvZy50cmFjZShjLnZhbHVlKTtcbiAgICAgICAgICAgIGNvdW50LnB1c2goYy52YWx1ZSk7XG4gICAgICAgICAgICAoYy52YWx1ZS5tYXRjaCgvIC9nKSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY291bnQucHVzaChjLnZhbHVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBpZiAoY291bnQubGVuZ3RoID4gMikge1xuICAgICAgICAgIGxvZy50cmFjZShyZXN1bHQuc2VudGVuY2UpO1xuICAgICAgICAgIGhpdHMucHVzaChyZXN1bHQpXG4gICAgICAgIH1cbiAgICAgICAgbG9nLnRyYWNlKCctLS0nKTtcbiAgICAgIH0pXG5cbiAgICAgIC8vIHJldHVybiBoaXRzO1xuICAgICAgLy9Gb3JjZSBubyBoaXRzXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tQYWdlUmVtaW5kZXIgPSBmdW5jdGlvbih1c2VySUQsIHBhZ2VEYXRhKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBsb2cudHJhY2UocGFnZURhdGEpO1xuICAgICAgY29uc3QgdXJsUm9vdCA9IHBhZ2VEYXRhLmJhc2VVcmwucmVwbGFjZSgnLmNvbScsJycpLnJlcGxhY2UoJy5jby51aycsJycpLnJlcGxhY2UoJy5vcmcnLCcnKVxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBxdWVyeTogJycsXG4gICAgICAgIGZpbHRlcnM6ICd1c2VySUQ6ICcgKyB1c2VySUQgKyAnIEFORCAodHJpZ2dlclVybDogJyArIHVybFJvb3QgKyAnIE9SIHRyaWdnZXJVcmw6ICcgKyB1cmxSb290ICsgJy5jb20gT1IgdHJpZ2dlclVybDogJyArIHVybFJvb3QgKyAnLmNvLnVrIE9SIHRyaWdnZXJVcmw6ICcgKyB1cmxSb290ICsgJy5vcmcgT1IgdHJpZ2dlclVSTDogJyArIHVybFJvb3QgKyAnIE9SIHRyaWdnZXJVUkw6ICcgKyB1cmxSb290ICsgJy5jb20gT1IgdHJpZ2dlclVSTDogJyArIHVybFJvb3QgKyAnLmNvLnVrIE9SIHRyaWdnZXJVUkw6ICcgKyB1cmxSb290ICsgJy5vcmcpJ1xuICAgICAgfTtcbiAgICAgIGxvZy50cmFjZSgncGFyYW1zJyk7XG4gICAgICBsb2cudHJhY2UocGFyYW1zKTtcbiAgICAgIGFkdmFuY2VkU2VhcmNoKHBhcmFtcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlbWluZGVycykge1xuICAgICAgICBsb2cudHJhY2UoJ3JlbWluZGVycycpO1xuICAgICAgICBsb2cudHJhY2UocmVtaW5kZXJzKTtcbiAgICAgICAgZC5yZXNvbHZlKHJlbWluZGVycylcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZ2V0UGFnZVJlc3VsdHMgPSBmdW5jdGlvbih1c2VySUQsIHBhZ2VEYXRhLCBhbGxVc2VyQ2FyZHMpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIC8vIEdldHMgYWxsIHJlc3VsdHNcbiAgICAgIGNvbnN0IHBhZ2VSZXN1bHRzID0ge1xuICAgICAgICBoaXRzOiBbXSxcbiAgICAgICAgcmVtaW5kZXJzOiBbXSxcbiAgICAgICAgcGluZ3M6IFtdLFxuICAgICAgICBtZW1vcmllczogW10sXG4gICAgICB9O1xuICAgICAgbG9nLnRyYWNlKHVzZXJJRCwgcGFnZURhdGEpO1xuICAgICAgY29uc3QgZ21haWxCb3JpbmdQaHJhc2VzID0gW1xuICAgICAgICAnU2tpcCB0byBjb250ZW50JyxcbiAgICAgICAgJ1VzaW5nJyxcbiAgICAgICAgJ3dpdGggc2NyZWVuIHJlYWRlcnMnLFxuICAgICAgICAnU2VhcmNoJyxcbiAgICAgICAgJ01haWwnLFxuICAgICAgICAnQ09NUE9TRScsXG4gICAgICAgICdMYWJlbHMnLFxuICAgICAgICAnSW5ib3gnLFxuICAgICAgICAnU3RhcnJlZCcsXG4gICAgICAgICdTZW50IE1haWwnLFxuICAgICAgICAnRHJhZnRzJyxcbiAgICAgICAgJ01vcmUnLFxuICAgICAgICAnLS0tLS0tLS0tLSBGb3J3YXJkZWQgbWVzc2FnZSAtLS0tLS0tLS0tJyxcbiAgICAgICAgJ0Zyb206ICcsXG4gICAgICAgICdEYXRlOiAnLFxuICAgICAgICAnU3ViamVjdDogJyxcbiAgICAgICAgJ1RvOiAnLFxuICAgICAgICAnQ2xpY2sgaGVyZSB0byBSZXBseSBvciBGb3J3YXJkJyxcbiAgICAgICAgJ0dCJyxcbiAgICAgICAgJ0dCIHVzZWQnLFxuICAgICAgICAnTWFuYWdlJyxcbiAgICAgICAgJ1Byb2dyYW0gUG9saWNpZXMnLFxuICAgICAgICAnUG93ZXJlZCBieSBHb29nbGUnLFxuICAgICAgICAnTGFzdCBhY2NvdW50IGFjdGl2aXR5OicsXG4gICAgICAgICdob3VyIGFnbycsXG4gICAgICAgICdob3VycyBhZ28nLFxuICAgICAgICAnRGV0YWlscycsXG4gICAgICBdXG4gICAgICBnbWFpbEJvcmluZ1BocmFzZXMuZm9yRWFjaChmdW5jdGlvbihwaHJhc2UpIHtcbiAgICAgICAgcGFnZURhdGEucGFnZVRleHQgPSBwYWdlRGF0YS5wYWdlVGV4dC5yZXBsYWNlKHBocmFzZSwgJycpXG4gICAgICB9KVxuICAgICAgY29uc3QgYm9yaW5nV29yZHMgPSBbXG4gICAgICAgIFwiaVwiLFxuICAgICAgICBcImFcIixcbiAgICAgICAgXCJvZlwiLFxuICAgICAgICBcIm1lXCIsXG4gICAgICAgIFwibXlcIixcbiAgICAgICAgXCJpc1wiLFxuICAgICAgICBcImltXCIsXG4gICAgICAgIFwic29cIixcbiAgICAgICAgXCJhbGxcIixcbiAgICAgICAgXCJnZXRcIixcbiAgICAgICAgXCJob3dcIixcbiAgICAgICAgXCJuZXdcIixcbiAgICAgICAgXCJvdXRcIixcbiAgICAgICAgXCJ0aGVcIixcbiAgICAgICAgXCJ1c2VcIixcbiAgICAgICAgXCJiZXN0XCIsXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcIm5leHRcIixcbiAgICAgICAgXCJ0YWtlXCIsXG4gICAgICAgIFwid2hhdFwiLFxuICAgICAgICBcImltYWdlXCIsXG4gICAgICAgIFwic29tZXRoaW5nXCIsXG4gICAgICBdXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFsbFdvcmRzID0gW11cbiAgICAgICAgYWxsVXNlckNhcmRzLmZvckVhY2goZnVuY3Rpb24oY2FyZCkge1xuICAgICAgICAgIHZhciBzY29yZSA9IDBcbiAgICAgICAgICBjYXJkLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbihlbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IFN0cmluZyhlbnRpdHkudmFsdWUpXG4gICAgICAgICAgICBpZiAoYm9yaW5nV29yZHMuaW5kZXhPZih2YWwudG9Mb3dlckNhc2UoKSkgPT0gLTEgJiYgdmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodmFsKSwgXCJnaVwiKTtcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gKHBhZ2VEYXRhLnBhZ2VUZXh0Lm1hdGNoKHJlZykgfHwgW10pLmxlbmd0aCAqIHZhbC5sZW5ndGhcbiAgICAgICAgICAgICAgc2NvcmUgKz0gcG9pbnRzXG4gICAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsV29yZHMuaW5kZXhPZih2YWwpID09IC0xKSBhbGxXb3Jkcy5wdXNoKHZhbClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKHNjb3JlID4gMTAwKSB7XG4gICAgICAgICAgICBwYWdlUmVzdWx0cy5oaXRzLnB1c2goY2FyZClcbiAgICAgICAgICB9IGVsc2UgaWYgKHNjb3JlID4gMCkge1xuICAgICAgICAgICAgcGFnZVJlc3VsdHMubWVtb3JpZXMucHVzaChjYXJkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgbG9nLmRlYnVnKGFsbFdvcmRzKVxuXG4gICAgICAgIHBhZ2VSZXN1bHRzLnJlbWluZGVycyA9IGFsbFVzZXJDYXJkcy5maWx0ZXIoZnVuY3Rpb24oY2FyZCkge1xuICAgICAgICAgIGNvbnN0IHVybFJvb3QgPSBwYWdlRGF0YS5iYXNlVXJsLnJlcGxhY2UoJy5jb20nLCcnKS5yZXBsYWNlKCcuY28udWsnLCcnKS5yZXBsYWNlKCcub3JnJywnJylcbiAgICAgICAgICBsb2cuaW5mbyhjYXJkLnRyaWdnZXJVUkwpXG4gICAgICAgICAgcmV0dXJuIGNhcmQudHJpZ2dlclVSTCAmJiAoY2FyZC50cmlnZ2VyVVJMLmluZGV4T2YodXJsUm9vdCkgPiAtMSB8fCBjYXJkLnRyaWdnZXJVUkwuaW5kZXhPZih1cmxSb290KSA+IC0xKVxuICAgICAgICB9KVxuICAgICAgICBwYWdlUmVzdWx0cy5waW5ncyA9IHBhZ2VSZXN1bHRzLnJlbWluZGVycyAvLy5jb25jYXQocGFnZVJlc3VsdHMuaGl0cylcbiAgICAgICAgcGFnZVJlc3VsdHMucGluZ3MuZm9yRWFjaChmdW5jdGlvbihwaW5nKSB7IHBpbmcuaGlnaGxpZ2h0ID0gdHJ1ZSB9KVxuICAgICAgICAvLyBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHBhZ2VSZXN1bHRzLnBpbmdzLmNvbmNhdChwYWdlUmVzdWx0cy5tZW1vcmllcylcbiAgICAgICAgcGFnZVJlc3VsdHMubWVtb3JpZXMgPSByZW1vdmVEdXBsaWNhdGVzKHBhZ2VSZXN1bHRzLm1lbW9yaWVzLCAnb2JqZWN0SUQnKVxuICAgICAgICBsb2cuZGVidWcocGFnZVJlc3VsdHMpO1xuICAgICAgICBkLnJlc29sdmUocGFnZVJlc3VsdHMpXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbG9nLmVycm9yKGUpXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBvdW5kU2VhcmNoKHVzZXJJRCwgcGFnZURhdGEucGFnZVRleHQpXG4gICAgICAvLyAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAvLyAgIGxvZy50cmFjZSgxKTtcbiAgICAgIC8vICAgbG9nLnRyYWNlKHJlc3VsdHMpO1xuICAgICAgLy8gICBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHJlc3VsdHM7XG4gICAgICAvLyAgIC8vIENoZWNrcyB3aGV0aGVyIGEgcGluZyBpcyByZXF1aXJlZFxuICAgICAgLy8gICBwYWdlUmVzdWx0cy5oaXRzID0gY2hlY2tQYWdlSGl0KHBhZ2VEYXRhLCByZXN1bHRzKTtcbiAgICAgIC8vICAgbG9nLnRyYWNlKDIpO1xuICAgICAgLy8gICBsb2cudHJhY2UocGFnZVJlc3VsdHMuaGl0cyk7XG4gICAgICAvLyAgIHJldHVybiBjaGVja1BhZ2VSZW1pbmRlcih1c2VySUQsIHBhZ2VEYXRhKVxuICAgICAgLy8gfSkudGhlbihmdW5jdGlvbihyZW1pbmRlcnMpIHtcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMucmVtaW5kZXJzID0gcmVtaW5kZXJzO1xuICAgICAgLy8gICBsb2cudHJhY2UoMyk7XG4gICAgICAvLyAgIGxvZy50cmFjZShwYWdlUmVzdWx0cy5yZW1pbmRlcnMpO1xuICAgICAgLy8gICAvLyBSZXR1cm5zIHJlc3VsdHMgcGx1cyBwaW5nXG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLnBpbmdzID0gcGFnZVJlc3VsdHMucmVtaW5kZXJzLmNvbmNhdChwYWdlUmVzdWx0cy5oaXRzKVxuICAgICAgLy8gICBwYWdlUmVzdWx0cy5waW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHBpbmcpIHtcbiAgICAgIC8vICAgICBsb2cudHJhY2UocGluZy5vYmplY3RJRCk7XG4gICAgICAvLyAgICAgcGluZy5oaWdobGlnaHQgPSB0cnVlO1xuICAgICAgLy8gICB9KVxuICAgICAgLy8gICBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHBhZ2VSZXN1bHRzLnBpbmdzLmNvbmNhdChwYWdlUmVzdWx0cy5tZW1vcmllcylcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMubWVtb3JpZXMgPSByZW1vdmVEdXBsaWNhdGVzKHBhZ2VSZXN1bHRzLm1lbW9yaWVzLCAnb2JqZWN0SUQnKVxuICAgICAgLy8gICBsb2cudHJhY2UocGFnZVJlc3VsdHMpO1xuICAgICAgLy8gICBkLnJlc29sdmUocGFnZVJlc3VsdHMpXG4gICAgICAvLyB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAvLyAgIGxvZy50cmFjZShlKTtcbiAgICAgIC8vICAgZC5yZWplY3QoZSlcbiAgICAgIC8vIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgdGhpcy5hZHZhbmNlZFNlYXJjaCA9IGFkdmFuY2VkU2VhcmNoO1xuICAgIHRoaXMuc2VhcmNoQ2FyZHMgPSBzZWFyY2hDYXJkcztcbiAgICB0aGlzLmNvbXBvdW5kU2VhcmNoID0gY29tcG91bmRTZWFyY2g7XG4gICAgdGhpcy5nZXRQYWdlUmVzdWx0cyA9IGdldFBhZ2VSZXN1bHRzO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VhcmNoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL3BsdWdpbnMvZXhwbGFhaW4tc2VhcmNoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWxnb2xpYVNlYXJjaCA9IHJlcXVpcmUoJy4uLy4uL0FsZ29saWFTZWFyY2guanMnKTtcbnZhciBjcmVhdGVBbGdvbGlhc2VhcmNoID0gcmVxdWlyZSgnLi4vY3JlYXRlQWxnb2xpYXNlYXJjaC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFsZ29saWFzZWFyY2goQWxnb2xpYVNlYXJjaCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvYnVpbGRzL2FsZ29saWFzZWFyY2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IEFsZ29saWFTZWFyY2g7XG5cbnZhciBJbmRleCA9IHJlcXVpcmUoJy4vSW5kZXguanMnKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZS5qcycpO1xudmFyIGRlcHJlY2F0ZWRNZXNzYWdlID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkTWVzc2FnZS5qcycpO1xudmFyIEFsZ29saWFTZWFyY2hDb3JlID0gcmVxdWlyZSgnLi9BbGdvbGlhU2VhcmNoQ29yZS5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5mdW5jdGlvbiBBbGdvbGlhU2VhcmNoKCkge1xuICBBbGdvbGlhU2VhcmNoQ29yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0cyhBbGdvbGlhU2VhcmNoLCBBbGdvbGlhU2VhcmNoQ29yZSk7XG5cbi8qXG4gKiBEZWxldGUgYW4gaW5kZXhcbiAqXG4gKiBAcGFyYW0gaW5kZXhOYW1lIHRoZSBuYW1lIG9mIGluZGV4IHRvIGRlbGV0ZVxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSB0YXNrIElEXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRlbGV0ZUluZGV4ID0gZnVuY3Rpb24oaW5kZXhOYW1lLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4TmFtZSksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBNb3ZlIGFuIGV4aXN0aW5nIGluZGV4LlxuICogQHBhcmFtIHNyY0luZGV4TmFtZSB0aGUgbmFtZSBvZiBpbmRleCB0byBjb3B5LlxuICogQHBhcmFtIGRzdEluZGV4TmFtZSB0aGUgbmV3IGluZGV4IG5hbWUgdGhhdCB3aWxsIGNvbnRhaW5zIGEgY29weSBvZlxuICogc3JjSW5kZXhOYW1lIChkZXN0aW5hdGlvbiB3aWxsIGJlIG92ZXJyaXRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0KS5cbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgdGFzayBJRFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5tb3ZlSW5kZXggPSBmdW5jdGlvbihzcmNJbmRleE5hbWUsIGRzdEluZGV4TmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgb3BlcmF0aW9uOiAnbW92ZScsIGRlc3RpbmF0aW9uOiBkc3RJbmRleE5hbWVcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjSW5kZXhOYW1lKSArICcvb3BlcmF0aW9uJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29weSBhbiBleGlzdGluZyBpbmRleC5cbiAqIEBwYXJhbSBzcmNJbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXggdG8gY29weS5cbiAqIEBwYXJhbSBkc3RJbmRleE5hbWUgdGhlIG5ldyBpbmRleCBuYW1lIHRoYXQgd2lsbCBjb250YWlucyBhIGNvcHlcbiAqIG9mIHNyY0luZGV4TmFtZSAoZGVzdGluYXRpb24gd2lsbCBiZSBvdmVycml0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdCkuXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuY29weUluZGV4ID0gZnVuY3Rpb24oc3JjSW5kZXhOYW1lLCBkc3RJbmRleE5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBwb3N0T2JqID0ge1xuICAgIG9wZXJhdGlvbjogJ2NvcHknLCBkZXN0aW5hdGlvbjogZHN0SW5kZXhOYW1lXG4gIH07XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHNyY0luZGV4TmFtZSkgKyAnL29wZXJhdGlvbicsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBsYXN0IGxvZyBlbnRyaWVzLlxuICogQHBhcmFtIG9mZnNldCBTcGVjaWZ5IHRoZSBmaXJzdCBlbnRyeSB0byByZXRyaWV2ZSAoMC1iYXNlZCwgMCBpcyB0aGUgbW9zdCByZWNlbnQgbG9nIGVudHJ5KS5cbiAqIEBwYXJhbSBsZW5ndGggU3BlY2lmeSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyB0byByZXRyaWV2ZSBzdGFydGluZ1xuICogYXQgb2Zmc2V0LiBNYXhpbXVtIGFsbG93ZWQgdmFsdWU6IDEwMDAuXG4gKiBAcGFyYW0gdHlwZSBTcGVjaWZ5IHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIHJldHJpZXZlIHN0YXJ0aW5nXG4gKiBhdCBvZmZzZXQuIE1heGltdW0gYWxsb3dlZCB2YWx1ZTogMTAwMC5cbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgdGFzayBJRFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5nZXRMb2dzID0gZnVuY3Rpb24ob2Zmc2V0LCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKTtcbiAgdmFyIHBhcmFtcyA9IHt9O1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBnZXRMb2dzKHBhcmFtcylcbiAgICBwYXJhbXMgPSBjbG9uZShvZmZzZXQpO1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGdldExvZ3MoW2NiXSlcbiAgICBjYWxsYmFjayA9IG9mZnNldDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBnZXRMb2dzKDEsIFtjYildXG4gICAgY2FsbGJhY2sgPSBsZW5ndGg7XG4gICAgcGFyYW1zLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBnZXRMb2dzKDEsIDIsIFtjYl0pXG4gICAgcGFyYW1zLm9mZnNldCA9IG9mZnNldDtcbiAgICBwYXJhbXMubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5vZmZzZXQgPT09IHVuZGVmaW5lZCkgcGFyYW1zLm9mZnNldCA9IDA7XG4gIGlmIChwYXJhbXMubGVuZ3RoID09PSB1bmRlZmluZWQpIHBhcmFtcy5sZW5ndGggPSAxMDtcblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvbG9ncz8nICsgdGhpcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcywgJycpLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiAqIExpc3QgYWxsIGV4aXN0aW5nIGluZGV4ZXMgKHBhZ2luYXRlZClcbiAqXG4gKiBAcGFyYW0gcGFnZSBUaGUgcGFnZSB0byByZXRyaWV2ZSwgc3RhcnRpbmcgYXQgMC5cbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCBpbmRleCBsaXN0XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmxpc3RJbmRleGVzID0gZnVuY3Rpb24ocGFnZSwgY2FsbGJhY2spIHtcbiAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gIGlmIChwYWdlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHBhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhZ2U7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zID0gJz9wYWdlPScgKyBwYWdlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMnICsgcGFyYW1zLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiAqIEdldCB0aGUgaW5kZXggb2JqZWN0IGluaXRpYWxpemVkXG4gKlxuICogQHBhcmFtIGluZGV4TmFtZSB0aGUgbmFtZSBvZiBpbmRleFxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgd2l0aCBvbmUgYXJndW1lbnQgKHRoZSBJbmRleCBpbnN0YW5jZSlcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuaW5pdEluZGV4ID0gZnVuY3Rpb24oaW5kZXhOYW1lKSB7XG4gIHJldHVybiBuZXcgSW5kZXgodGhpcywgaW5kZXhOYW1lKTtcbn07XG5cbi8qXG4gKiBAZGVwcmVjYXRlZCB1c2UgY2xpZW50Lmxpc3RBcGlLZXlzXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmxpc3RVc2VyS2V5cyA9IGRlcHJlY2F0ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5saXN0QXBpS2V5cyhjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50Lmxpc3RVc2VyS2V5cygpJywgJ2NsaWVudC5saXN0QXBpS2V5cygpJykpO1xuXG4vKlxuICogTGlzdCBhbGwgZXhpc3RpbmcgYXBpIGtleXMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIEFDTHNcbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggYXBpIGtleXMgbGlzdFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5saXN0QXBpS2V5cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9rZXlzJyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gKiBAZGVwcmVjYXRlZCBzZWUgY2xpZW50LmdldEFwaUtleVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5nZXRVc2VyS2V5QUNMID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZ2V0QXBpS2V5KGtleSwgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5nZXRVc2VyS2V5QUNMKCknLCAnY2xpZW50LmdldEFwaUtleSgpJykpO1xuXG4vKlxuICogR2V0IGFuIEFQSSBrZXlcbiAqXG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIHJpZ2h0IEFQSSBrZXlcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZ2V0QXBpS2V5ID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEva2V5cy8nICsga2V5LFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiAqIEBkZXByZWNhdGVkIHNlZSBjbGllbnQuZGVsZXRlQXBpS2V5XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRlbGV0ZVVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5kZWxldGVBcGlLZXkoa2V5LCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmRlbGV0ZVVzZXJLZXkoKScsICdjbGllbnQuZGVsZXRlQXBpS2V5KCknKSk7XG5cbi8qXG4gKiBEZWxldGUgYW4gZXhpc3RpbmcgQVBJIGtleVxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBkYXRlIG9mIGRlbGV0aW9uXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRlbGV0ZUFwaUtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2tleXMvJyArIGtleSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBjbGllbnQuYWRkQXBpS2V5XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmFkZFVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hZGRBcGlLZXkoYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmFkZFVzZXJLZXkoKScsICdjbGllbnQuYWRkQXBpS2V5KCknKSk7XG5cbi8qXG4gKiBBZGQgYSBuZXcgZ2xvYmFsIEFQSSBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2xzIC0gVGhlIGxpc3Qgb2YgQUNMIGZvciB0aGlzIGtleS4gRGVmaW5lZCBieSBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXRcbiAqICAgY2FuIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICogICAgIC0gc2VhcmNoOiBhbGxvdyB0byBzZWFyY2ggKGh0dHBzIGFuZCBodHRwKVxuICogICAgIC0gYWRkT2JqZWN0OiBhbGxvd3MgdG8gYWRkL3VwZGF0ZSBhbiBvYmplY3QgaW4gdGhlIGluZGV4IChodHRwcyBvbmx5KVxuICogICAgIC0gZGVsZXRlT2JqZWN0IDogYWxsb3dzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBvYmplY3QgKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBkZWxldGVJbmRleCA6IGFsbG93cyB0byBkZWxldGUgaW5kZXggY29udGVudCAoaHR0cHMgb25seSlcbiAqICAgICAtIHNldHRpbmdzIDogYWxsb3dzIHRvIGdldCBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAqICAgICAtIGVkaXRTZXR0aW5ncyA6IGFsbG93cyB0byBjaGFuZ2UgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25uYWwgcGFyYW1ldGVycyB0byBzZXQgZm9yIHRoZSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsaWRpdHkgLSBOdW1iZXIgb2Ygc2Vjb25kcyBhZnRlciB3aGljaCB0aGUga2V5IHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkICgwIG1lYW5zIG5vIHRpbWUgbGltaXQgZm9yIHRoaXMga2V5KVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyIC0gTnVtYmVyIG9mIEFQSSBjYWxscyBhbGxvd2VkIGZyb20gYW4gSVAgYWRkcmVzcyBwZXIgaG91clxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnkgLSBOdW1iZXIgb2YgaGl0cyB0aGlzIEFQSSBrZXkgY2FuIHJldHJpZXZlIGluIG9uZSBjYWxsXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuaW5kZXhlcyAtIEFsbG93ZWQgdGFyZ2V0ZWQgaW5kZXhlcyBmb3IgdGhpcyBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIGZvciB5b3VyIGtleVxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJlZmVyZXJzIC0gQSBsaXN0IG9mIGF1dGhvcml6ZWQgcmVmZXJlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucXVlcnlQYXJhbWV0ZXJzIC0gRm9yY2UgdGhlIGtleSB0byB1c2Ugc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBhZGRlZCBBUEkga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiAqIEBleGFtcGxlXG4gKiBjbGllbnQuYWRkVXNlcktleShbJ3NlYXJjaCddLCB7XG4gKiAgIHZhbGlkaXR5OiAzMDAsXG4gKiAgIG1heFF1ZXJpZXNQZXJJUFBlckhvdXI6IDIwMDAsXG4gKiAgIG1heEhpdHNQZXJRdWVyeTogMyxcbiAqICAgaW5kZXhlczogWydmcnVpdHMnXSxcbiAqICAgZGVzY3JpcHRpb246ICdFYXQgdGhyZWUgZnJ1aXRzJyxcbiAqICAgcmVmZXJlcnM6IFsnKi5hbGdvbGlhLmNvbSddLFxuICogICBxdWVyeVBhcmFtZXRlcnM6IHtcbiAqICAgICB0YWdGaWx0ZXJzOiBbJ3B1YmxpYyddLFxuICogICB9XG4gKiB9KVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0FkZEtleXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmFkZEFwaUtleSA9IGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LmFkZEFwaUtleShhcnJheU9mQWNsc1ssIHBhcmFtcywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KGFjbHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgYWNsOiBhY2xzXG4gIH07XG5cbiAgaWYgKHBhcmFtcykge1xuICAgIHBvc3RPYmoudmFsaWRpdHkgPSBwYXJhbXMudmFsaWRpdHk7XG4gICAgcG9zdE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgcG9zdE9iai5tYXhIaXRzUGVyUXVlcnkgPSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5O1xuICAgIHBvc3RPYmouaW5kZXhlcyA9IHBhcmFtcy5pbmRleGVzO1xuICAgIHBvc3RPYmouZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb247XG5cbiAgICBpZiAocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgcG9zdE9iai5xdWVyeVBhcmFtZXRlcnMgPSB0aGlzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycywgJycpO1xuICAgIH1cblxuICAgIHBvc3RPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2tleXMnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGNsaWVudC5hZGRBcGlLZXkoKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYWRkQXBpS2V5KGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5KCknLCAnY2xpZW50LmFkZEFwaUtleSgpJykpO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgY2xpZW50LnVwZGF0ZUFwaUtleSgpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLnVwZGF0ZVVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnVwZGF0ZUFwaUtleShrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC51cGRhdGVVc2VyS2V5KCknLCAnY2xpZW50LnVwZGF0ZUFwaUtleSgpJykpO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBBUEkga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjbHMgLSBUaGUgbGlzdCBvZiBBQ0wgZm9yIHRoaXMga2V5LiBEZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdFxuICogICBjYW4gY29udGFpbnMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKiAgICAgLSBzZWFyY2g6IGFsbG93IHRvIHNlYXJjaCAoaHR0cHMgYW5kIGh0dHApXG4gKiAgICAgLSBhZGRPYmplY3Q6IGFsbG93cyB0byBhZGQvdXBkYXRlIGFuIG9iamVjdCBpbiB0aGUgaW5kZXggKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBkZWxldGVPYmplY3QgOiBhbGxvd3MgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIG9iamVjdCAoaHR0cHMgb25seSlcbiAqICAgICAtIGRlbGV0ZUluZGV4IDogYWxsb3dzIHRvIGRlbGV0ZSBpbmRleCBjb250ZW50IChodHRwcyBvbmx5KVxuICogICAgIC0gc2V0dGluZ3MgOiBhbGxvd3MgdG8gZ2V0IGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICogICAgIC0gZWRpdFNldHRpbmdzIDogYWxsb3dzIHRvIGNoYW5nZSBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbm5hbCBwYXJhbWV0ZXJzIHRvIHNldCBmb3IgdGhlIGtleVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWxpZGl0eSAtIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBrZXkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgKDAgbWVhbnMgbm8gdGltZSBsaW1pdCBmb3IgdGhpcyBrZXkpXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5pbmRleGVzIC0gQWxsb3dlZCB0YXJnZXRlZCBpbmRleGVzIGZvciB0aGlzIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucmVmZXJlcnMgLSBBIGxpc3Qgb2YgYXV0aG9yaXplZCByZWZlcmVyc1xuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIG1vZGlmaWVkIEFQSSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICogQGV4YW1wbGVcbiAqIGNsaWVudC51cGRhdGVBcGlLZXkoJ0FQSUtFWScsIFsnc2VhcmNoJ10sIHtcbiAqICAgdmFsaWRpdHk6IDMwMCxcbiAqICAgbWF4UXVlcmllc1BlcklQUGVySG91cjogMjAwMCxcbiAqICAgbWF4SGl0c1BlclF1ZXJ5OiAzLFxuICogICBpbmRleGVzOiBbJ2ZydWl0cyddLFxuICogICBkZXNjcmlwdGlvbjogJ0VhdCB0aHJlZSBmcnVpdHMnLFxuICogICByZWZlcmVyczogWycqLmFsZ29saWEuY29tJ10sXG4gKiAgIHF1ZXJ5UGFyYW1ldGVyczoge1xuICogICAgIHRhZ0ZpbHRlcnM6IFsncHVibGljJ10sXG4gKiAgIH1cbiAqIH0pXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjVXBkYXRlSW5kZXhLZXl8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS51cGRhdGVBcGlLZXkgPSBmdW5jdGlvbihrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LnVwZGF0ZUFwaUtleShrZXksIGFycmF5T2ZBY2xzWywgcGFyYW1zLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkoYWNscykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IG51bGw7XG4gIH1cblxuICB2YXIgcHV0T2JqID0ge1xuICAgIGFjbDogYWNsc1xuICB9O1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBwdXRPYmoudmFsaWRpdHkgPSBwYXJhbXMudmFsaWRpdHk7XG4gICAgcHV0T2JqLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgPSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91cjtcbiAgICBwdXRPYmoubWF4SGl0c1BlclF1ZXJ5ID0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeTtcbiAgICBwdXRPYmouaW5kZXhlcyA9IHBhcmFtcy5pbmRleGVzO1xuICAgIHB1dE9iai5kZXNjcmlwdGlvbiA9IHBhcmFtcy5kZXNjcmlwdGlvbjtcblxuICAgIGlmIChwYXJhbXMucXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICBwdXRPYmoucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMsICcnKTtcbiAgICB9XG5cbiAgICBwdXRPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEva2V5cy8nICsga2V5LFxuICAgIGJvZHk6IHB1dE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYmF0Y2ggb2Ygc2VhcmNoIHF1ZXJpZXNcbiAqIEBkZXByZWNhdGVkIHVzZSBjbGllbnQuc2VhcmNoKClcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuc3RhcnRRdWVyaWVzQmF0Y2ggPSBkZXByZWNhdGUoZnVuY3Rpb24gc3RhcnRRdWVyaWVzQmF0Y2hEZXByZWNhdGVkKCkge1xuICB0aGlzLl9iYXRjaCA9IFtdO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5zdGFydFF1ZXJpZXNCYXRjaCgpJywgJ2NsaWVudC5zZWFyY2goKScpKTtcblxuLyoqXG4gKiBBZGQgYSBzZWFyY2ggcXVlcnkgaW4gdGhlIGJhdGNoXG4gKiBAZGVwcmVjYXRlZCB1c2UgY2xpZW50LnNlYXJjaCgpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmFkZFF1ZXJ5SW5CYXRjaCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBhZGRRdWVyeUluQmF0Y2hEZXByZWNhdGVkKGluZGV4TmFtZSwgcXVlcnksIGFyZ3MpIHtcbiAgdGhpcy5fYmF0Y2gucHVzaCh7XG4gICAgaW5kZXhOYW1lOiBpbmRleE5hbWUsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHBhcmFtczogYXJnc1xuICB9KTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuYWRkUXVlcnlJbkJhdGNoKCknLCAnY2xpZW50LnNlYXJjaCgpJykpO1xuXG4vKipcbiAqIExhdW5jaCB0aGUgYmF0Y2ggb2YgcXVlcmllcyB1c2luZyBYTUxIdHRwUmVxdWVzdC5cbiAqIEBkZXByZWNhdGVkIHVzZSBjbGllbnQuc2VhcmNoKClcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuc2VuZFF1ZXJpZXNCYXRjaCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBzZW5kUXVlcmllc0JhdGNoRGVwcmVjYXRlZChjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5zZWFyY2godGhpcy5fYmF0Y2gsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuc2VuZFF1ZXJpZXNCYXRjaCgpJywgJ2NsaWVudC5zZWFyY2goKScpKTtcblxuLyoqXG4gKiBQZXJmb3JtIHdyaXRlIG9wZXJhdGlvbnMgYWNjcm9zcyBtdWx0aXBsZSBpbmRleGVzLlxuICpcbiAqIFRvIHJlZHVjZSB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgb24gbmV0d29yayByb3VuZCB0cmlwcyxcbiAqIHlvdSBjYW4gY3JlYXRlLCB1cGRhdGUsIG9yIGRlbGV0ZSBzZXZlcmFsIG9iamVjdHMgaW4gb25lIGNhbGwsXG4gKiB1c2luZyB0aGUgYmF0Y2ggZW5kcG9pbnQgKGFsbCBvcGVyYXRpb25zIGFyZSBkb25lIGluIHRoZSBnaXZlbiBvcmRlcikuXG4gKlxuICogQXZhaWxhYmxlIGFjdGlvbnM6XG4gKiAgIC0gYWRkT2JqZWN0XG4gKiAgIC0gdXBkYXRlT2JqZWN0XG4gKiAgIC0gcGFydGlhbFVwZGF0ZU9iamVjdFxuICogICAtIHBhcnRpYWxVcGRhdGVPYmplY3ROb0NyZWF0ZVxuICogICAtIGRlbGV0ZU9iamVjdFxuICpcbiAqIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNJbmRleGVzXG4gKiBAcGFyYW0gIHtPYmplY3RbXX0gb3BlcmF0aW9ucyBBbiBhcnJheSBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICogQGV4YW1wbGVcbiAqIGNsaWVudC5iYXRjaChbe1xuICogICBhY3Rpb246ICdhZGRPYmplY3QnLFxuICogICBpbmRleE5hbWU6ICdjbGllbnRzJyxcbiAqICAgYm9keToge1xuICogICAgIG5hbWU6ICdCaWxsJ1xuICogICB9XG4gKiB9LCB7XG4gKiAgIGFjdGlvbjogJ3VkcGF0ZU9iamVjdCcsXG4gKiAgIGluZGV4TmFtZTogJ2ZydWl0cycsXG4gKiAgIGJvZHk6IHtcbiAqICAgICBvYmplY3RJRDogJzI5MTM4JyxcbiAqICAgICBuYW1lOiAnYmFuYW5hJ1xuICogICB9XG4gKiB9XSwgY2IpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24ob3BlcmF0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LmJhdGNoKG9wZXJhdGlvbnNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob3BlcmF0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLyovYmF0Y2gnLFxuICAgIGJvZHk6IHtcbiAgICAgIHJlcXVlc3RzOiBvcGVyYXRpb25zXG4gICAgfSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vLyBlbnZpcm9ubWVudCBzcGVjaWZpYyBtZXRob2RzXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kZXN0cm95ID0gbm90SW1wbGVtZW50ZWQ7XG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5lbmFibGVSYXRlTGltaXRGb3J3YXJkID0gbm90SW1wbGVtZW50ZWQ7XG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kaXNhYmxlUmF0ZUxpbWl0Rm9yd2FyZCA9IG5vdEltcGxlbWVudGVkO1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUudXNlU2VjdXJlZEFQSUtleSA9IG5vdEltcGxlbWVudGVkO1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZGlzYWJsZVNlY3VyZWRBUElLZXkgPSBub3RJbXBsZW1lbnRlZDtcbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmdlbmVyYXRlU2VjdXJlZEFwaUtleSA9IG5vdEltcGxlbWVudGVkO1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcbiAgdmFyIG1lc3NhZ2UgPSAnTm90IGltcGxlbWVudGVkIGluIHRoaXMgZW52aXJvbm1lbnQuXFxuJyArXG4gICAgJ0lmIHlvdSBmZWVsIHRoaXMgaXMgYSBtaXN0YWtlLCB3cml0ZSB0byBzdXBwb3J0QGFsZ29saWEuY29tJztcblxuICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihtZXNzYWdlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaC5qcyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgSW5kZXhDb3JlID0gcmVxdWlyZSgnLi9JbmRleENvcmUuanMnKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZS5qcycpO1xudmFyIGRlcHJlY2F0ZWRNZXNzYWdlID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkTWVzc2FnZS5qcycpO1xudmFyIGV4aXRQcm9taXNlID0gcmVxdWlyZSgnLi9leGl0UHJvbWlzZS5qcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbnZhciBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMgPSBkZXByZWNhdGUoXG4gIGZ1bmN0aW9uKCkge30sXG4gIGRlcHJlY2F0ZWRNZXNzYWdlKCdmb3J3YXJkVG9TbGF2ZXMnLCAnZm9yd2FyZFRvUmVwbGljYXMnKVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleDtcblxuZnVuY3Rpb24gSW5kZXgoKSB7XG4gIEluZGV4Q29yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0cyhJbmRleCwgSW5kZXhDb3JlKTtcblxuLypcbiogQWRkIGFuIG9iamVjdCBpbiB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBjb250ZW50IGNvbnRhaW5zIHRoZSBqYXZhc2NyaXB0IG9iamVjdCB0byBhZGQgaW5zaWRlIHRoZSBpbmRleFxuKiBAcGFyYW0gb2JqZWN0SUQgKG9wdGlvbmFsKSBhbiBvYmplY3RJRCB5b3Ugd2FudCB0byBhdHRyaWJ1dGUgdG8gdGhpcyBvYmplY3RcbiogKGlmIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdCB0aGUgb2xkIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0ZSlcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyAzIGVsZW1lbnRzOiBjcmVhdGVBdCwgdGFza0lkIGFuZCBvYmplY3RJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5hZGRPYmplY3QgPSBmdW5jdGlvbihjb250ZW50LCBvYmplY3RJRCwgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2Ygb2JqZWN0SUQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9iamVjdElEO1xuICAgIG9iamVjdElEID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6IG9iamVjdElEICE9PSB1bmRlZmluZWQgP1xuICAgICdQVVQnIDogLy8gdXBkYXRlIG9yIGNyZWF0ZVxuICAgICdQT1NUJywgLy8gY3JlYXRlIChBUEkgZ2VuZXJhdGVzIGFuIG9iamVjdElEKVxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgLy8gY3JlYXRlXG4gICAgKG9iamVjdElEICE9PSB1bmRlZmluZWQgPyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpIDogJycpLCAvLyB1cGRhdGUgb3IgY3JlYXRlXG4gICAgYm9keTogY29udGVudCxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBBZGQgc2V2ZXJhbCBvYmplY3RzXG4qXG4qIEBwYXJhbSBvYmplY3RzIGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdHMgdG8gYWRkXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgdXBkYXRlQXQgYW5kIHRhc2tJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5hZGRPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguYWRkT2JqZWN0cyhhcnJheU9mT2JqZWN0c1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvYmplY3RzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgcG9zdE9iaiA9IHtcbiAgICByZXF1ZXN0czogW11cbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICBhY3Rpb246ICdhZGRPYmplY3QnLFxuICAgICAgYm9keTogb2JqZWN0c1tpXVxuICAgIH07XG4gICAgcG9zdE9iai5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICB9XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIFVwZGF0ZSBwYXJ0aWFsbHkgYW4gb2JqZWN0IChvbmx5IHVwZGF0ZSBhdHRyaWJ1dGVzIHBhc3NlZCBpbiBhcmd1bWVudClcbipcbiogQHBhcmFtIHBhcnRpYWxPYmplY3QgY29udGFpbnMgdGhlIGphdmFzY3JpcHQgYXR0cmlidXRlcyB0byBvdmVycmlkZSwgdGhlXG4qICBvYmplY3QgbXVzdCBjb250YWlucyBhbiBvYmplY3RJRCBhdHRyaWJ1dGVcbiogQHBhcmFtIGNyZWF0ZUlmTm90RXhpc3RzIChvcHRpb25hbCkgaWYgZmFsc2UsIGF2b2lkIGFuIGF1dG9tYXRpYyBjcmVhdGlvbiBvZiB0aGUgb2JqZWN0XG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiovXG5JbmRleC5wcm90b3R5cGUucGFydGlhbFVwZGF0ZU9iamVjdCA9IGZ1bmN0aW9uKHBhcnRpYWxPYmplY3QsIGNyZWF0ZUlmTm90RXhpc3RzLCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgY3JlYXRlSWZOb3RFeGlzdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUlmTm90RXhpc3RzO1xuICAgIGNyZWF0ZUlmTm90RXhpc3RzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHVybCA9ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJ0aWFsT2JqZWN0Lm9iamVjdElEKSArICcvcGFydGlhbCc7XG4gIGlmIChjcmVhdGVJZk5vdEV4aXN0cyA9PT0gZmFsc2UpIHtcbiAgICB1cmwgKz0gJz9jcmVhdGVJZk5vdEV4aXN0cz1mYWxzZSc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdXJsLFxuICAgIGJvZHk6IHBhcnRpYWxPYmplY3QsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogUGFydGlhbGx5IE92ZXJyaWRlIHRoZSBjb250ZW50IG9mIHNldmVyYWwgb2JqZWN0c1xuKlxuKiBAcGFyYW0gb2JqZWN0cyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIHVwZGF0ZSAoZWFjaCBvYmplY3QgbXVzdCBjb250YWlucyBhIG9iamVjdElEIGF0dHJpYnV0ZSlcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4qL1xuSW5kZXgucHJvdG90eXBlLnBhcnRpYWxVcGRhdGVPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0cywgY3JlYXRlSWZOb3RFeGlzdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBjcmVhdGVJZk5vdEV4aXN0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gY3JlYXRlSWZOb3RFeGlzdHM7XG4gICAgY3JlYXRlSWZOb3RFeGlzdHMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXgucGFydGlhbFVwZGF0ZU9iamVjdHMoYXJyYXlPZk9iamVjdHNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob2JqZWN0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IFtdXG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgYWN0aW9uOiBjcmVhdGVJZk5vdEV4aXN0cyA9PT0gdHJ1ZSA/ICdwYXJ0aWFsVXBkYXRlT2JqZWN0JyA6ICdwYXJ0aWFsVXBkYXRlT2JqZWN0Tm9DcmVhdGUnLFxuICAgICAgb2JqZWN0SUQ6IG9iamVjdHNbaV0ub2JqZWN0SUQsXG4gICAgICBib2R5OiBvYmplY3RzW2ldXG4gICAgfTtcbiAgICBwb3N0T2JqLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvYmF0Y2gnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogT3ZlcnJpZGUgdGhlIGNvbnRlbnQgb2Ygb2JqZWN0XG4qXG4qIEBwYXJhbSBvYmplY3QgY29udGFpbnMgdGhlIGphdmFzY3JpcHQgb2JqZWN0IHRvIHNhdmUsIHRoZSBvYmplY3QgbXVzdCBjb250YWlucyBhbiBvYmplY3RJRCBhdHRyaWJ1dGVcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4qL1xuSW5kZXgucHJvdG90eXBlLnNhdmVPYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3Qub2JqZWN0SUQpLFxuICAgIGJvZHk6IG9iamVjdCxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59XG5cbi8qXG4qIE92ZXJyaWRlIHRoZSBjb250ZW50IG9mIHNldmVyYWwgb2JqZWN0c1xuKlxuKiBAcGFyYW0gb2JqZWN0cyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIHVwZGF0ZSAoZWFjaCBvYmplY3QgbXVzdCBjb250YWlucyBhIG9iamVjdElEIGF0dHJpYnV0ZSlcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4qL1xuSW5kZXgucHJvdG90eXBlLnNhdmVPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguc2F2ZU9iamVjdHMoYXJyYXlPZk9iamVjdHNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob2JqZWN0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IFtdXG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgYWN0aW9uOiAndXBkYXRlT2JqZWN0JyxcbiAgICAgIG9iamVjdElEOiBvYmplY3RzW2ldLm9iamVjdElELFxuICAgICAgYm9keTogb2JqZWN0c1tpXVxuICAgIH07XG4gICAgcG9zdE9iai5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICB9XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIERlbGV0ZSBhbiBvYmplY3QgZnJvbSB0aGUgaW5kZXhcbipcbiogQHBhcmFtIG9iamVjdElEIHRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBvYmplY3QgdG8gZGVsZXRlXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0SUQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iamVjdElEICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb2JqZWN0SUQgIT09ICdudW1iZXInKSB7XG4gICAgdmFyIGVyciA9IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdDYW5ub3QgZGVsZXRlIGFuIG9iamVjdCB3aXRob3V0IGFuIG9iamVjdElEJyk7XG4gICAgY2FsbGJhY2sgPSBvYmplY3RJRDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcy5fcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogRGVsZXRlIHNldmVyYWwgb2JqZWN0cyBmcm9tIGFuIGluZGV4XG4qXG4qIEBwYXJhbSBvYmplY3RJRHMgY29udGFpbnMgYW4gYXJyYXkgb2Ygb2JqZWN0SUQgdG8gZGVsZXRlXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlT2JqZWN0cyA9IGZ1bmN0aW9uKG9iamVjdElEcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguZGVsZXRlT2JqZWN0cyhhcnJheU9mT2JqZWN0SURzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9iamVjdElEcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IG1hcChvYmplY3RJRHMsIGZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KG9iamVjdElEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb246ICdkZWxldGVPYmplY3QnLFxuICAgICAgICBvYmplY3RJRDogb2JqZWN0SUQsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBvYmplY3RJRDogb2JqZWN0SURcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICB9O1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIERlbGV0ZSBhbGwgb2JqZWN0cyBtYXRjaGluZyBhIHF1ZXJ5XG4qXG4qIEBwYXJhbSBxdWVyeSB0aGUgcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSBwYXJhbXMgdGhlIG9wdGlvbmFsIHF1ZXJ5IHBhcmFtZXRlcnNcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnRcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlQnlRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKTtcbiAgdmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwLmpzJyk7XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIGNsaWVudCA9IGluZGV4T2JqLmFzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMgPSBjbG9uZShwYXJhbXMpO1xuICB9XG5cbiAgcGFyYW1zLmF0dHJpYnV0ZXNUb1JldHJpZXZlID0gJ29iamVjdElEJztcbiAgcGFyYW1zLmhpdHNQZXJQYWdlID0gMTAwMDtcbiAgcGFyYW1zLmRpc3RpbmN0ID0gZmFsc2U7XG5cbiAgLy8gd2hlbiBkZWxldGluZywgd2Ugc2hvdWxkIG5ldmVyIHVzZSBjYWNoZSB0byBnZXQgdGhlXG4gIC8vIHNlYXJjaCByZXN1bHRzXG4gIHRoaXMuY2xlYXJDYWNoZSgpO1xuXG4gIC8vIHRoZXJlJ3MgYSBwcm9ibGVtIGluIGhvdyB3ZSB1c2UgdGhlIHByb21pc2UgY2hhaW4sXG4gIC8vIHNlZSBob3cgd2FpdFRhc2sgaXMgZG9uZVxuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgLnNlYXJjaChxdWVyeSwgcGFyYW1zKVxuICAudGhlbihzdG9wT3JEZWxldGUpO1xuXG4gIGZ1bmN0aW9uIHN0b3BPckRlbGV0ZShzZWFyY2hDb250ZW50KSB7XG4gICAgLy8gc3RvcCBoZXJlXG4gICAgaWYgKHNlYXJjaENvbnRlbnQubmJIaXRzID09PSAwKSB7XG4gICAgICAvLyByZXR1cm4gaW5kZXhPYmouYXMuX3JlcXVlc3QucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIHNlYXJjaENvbnRlbnQ7XG4gICAgfVxuXG4gICAgLy8gY29udGludWUgYW5kIGRvIGEgcmVjdXJzaXZlIGNhbGxcbiAgICB2YXIgb2JqZWN0SURzID0gbWFwKHNlYXJjaENvbnRlbnQuaGl0cywgZnVuY3Rpb24gZ2V0T2JqZWN0SUQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0Lm9iamVjdElEO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluZGV4T2JqXG4gICAgLmRlbGV0ZU9iamVjdHMob2JqZWN0SURzKVxuICAgIC50aGVuKHdhaXRUYXNrKVxuICAgIC50aGVuKGRvRGVsZXRlQnlRdWVyeSk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0VGFzayhkZWxldGVPYmplY3RzQ29udGVudCkge1xuICAgIHJldHVybiBpbmRleE9iai53YWl0VGFzayhkZWxldGVPYmplY3RzQ29udGVudC50YXNrSUQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9EZWxldGVCeVF1ZXJ5KCkge1xuICAgIHJldHVybiBpbmRleE9iai5kZWxldGVCeVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpO1xuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJvbWlzZS50aGVuKHN1Y2Nlc3MsIGZhaWx1cmUpO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWx1cmUoZXJyKSB7XG4gICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSwgY2xpZW50Ll9zZXRUaW1lb3V0IHx8IHNldFRpbWVvdXQpO1xuICB9XG59O1xuXG4vKlxuKiBCcm93c2UgYWxsIGNvbnRlbnQgZnJvbSBhbiBpbmRleCB1c2luZyBldmVudHMuIEJhc2ljYWxseSB0aGlzIHdpbGwgZG9cbiogLmJyb3dzZSgpIC0+IC5icm93c2VGcm9tIC0+IC5icm93c2VGcm9tIC0+IC4uIHVudGlsIGFsbCB0aGUgcmVzdWx0cyBhcmUgcmV0dXJuZWRcbipcbiogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGZ1bGwgdGV4dCBxdWVyeVxuKiBAcGFyYW0ge09iamVjdH0gW3F1ZXJ5UGFyYW1ldGVyc10gLSBBbnkgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlclxuKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9XG4qIEBleGFtcGxlXG4qIHZhciBicm93c2VyID0gaW5kZXguYnJvd3NlQWxsKCdjb29sIHNvbmdzJywge1xuKiAgIHRhZ0ZpbHRlcnM6ICdwdWJsaWMsY29tbWVudHMnLFxuKiAgIGhpdHNQZXJQYWdlOiA1MDBcbiogfSk7XG4qXG4qIGJyb3dzZXIub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uIHJlc3VsdENhbGxiYWNrKGNvbnRlbnQpIHtcbiogICBjb25zb2xlLmxvZyhjb250ZW50LmhpdHMpO1xuKiB9KTtcbipcbiogLy8gaWYgYW55IGVycm9yIG9jY3VycywgeW91IGdldCBpdFxuKiBicm93c2VyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuKiAgIHRocm93IGVycjtcbiogfSk7XG4qXG4qIC8vIHdoZW4geW91IGhhdmUgYnJvd3NlZCB0aGUgd2hvbGUgaW5kZXgsIHlvdSBnZXQgdGhpcyBldmVudFxuKiBicm93c2VyLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiogICBjb25zb2xlLmxvZygnZmluaXNoZWQnKTtcbiogfSk7XG4qXG4qIC8vIGF0IGFueSBwb2ludCBpZiB5b3Ugd2FudCB0byBzdG9wIHRoZSBicm93c2luZyBwcm9jZXNzLCB5b3UgY2FuIHN0b3AgaXQgbWFudWFsbHlcbiogLy8gb3RoZXJ3aXNlIGl0IHdpbGwgZ28gb24gYW5kIG9uXG4qIGJyb3dzZXIuc3RvcCgpO1xuKlxuKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleC5wcm90b3R5cGUuYnJvd3NlQWxsID0gZnVuY3Rpb24ocXVlcnksIHF1ZXJ5UGFyYW1ldGVycykge1xuICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHF1ZXJ5O1xuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIG1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZS5qcycpO1xuXG4gIHZhciBJbmRleEJyb3dzZXIgPSByZXF1aXJlKCcuL0luZGV4QnJvd3NlcicpO1xuXG4gIHZhciBicm93c2VyID0gbmV3IEluZGV4QnJvd3NlcigpO1xuICB2YXIgY2xpZW50ID0gdGhpcy5hcztcbiAgdmFyIGluZGV4ID0gdGhpcztcbiAgdmFyIHBhcmFtcyA9IGNsaWVudC5fZ2V0U2VhcmNoUGFyYW1zKFxuICAgIG1lcmdlKHt9LCBxdWVyeVBhcmFtZXRlcnMgfHwge30sIHtcbiAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgIH0pLCAnJ1xuICApO1xuXG4gIC8vIHN0YXJ0IGJyb3dzaW5nXG4gIGJyb3dzZUxvb3AoKTtcblxuICBmdW5jdGlvbiBicm93c2VMb29wKGN1cnNvcikge1xuICAgIGlmIChicm93c2VyLl9zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJvZHkgPSB7XG4gICAgICAgIGN1cnNvcjogY3Vyc29yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0ge1xuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGllbnQuX2pzb25SZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4LmluZGV4TmFtZSkgKyAnL2Jyb3dzZScsXG4gICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGNhbGxiYWNrOiBicm93c2VDYWxsYmFja1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnJvd3NlQ2FsbGJhY2soZXJyLCBjb250ZW50KSB7XG4gICAgaWYgKGJyb3dzZXIuX3N0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBicm93c2VyLl9lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyb3dzZXIuX3Jlc3VsdChjb250ZW50KTtcblxuICAgIC8vIG5vIGN1cnNvciBtZWFucyB3ZSBhcmUgZmluaXNoZWQgYnJvd3NpbmdcbiAgICBpZiAoY29udGVudC5jdXJzb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnJvd3Nlci5fZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJvd3NlTG9vcChjb250ZW50LmN1cnNvcik7XG4gIH1cblxuICByZXR1cm4gYnJvd3Nlcjtcbn07XG5cbi8qXG4qIEdldCBhIFR5cGVhaGVhZC5qcyBhZGFwdGVyXG4qIEBwYXJhbSBzZWFyY2hQYXJhbXMgY29udGFpbnMgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycyAoc2VlIHNlYXJjaCBmb3IgZGV0YWlscylcbiovXG5JbmRleC5wcm90b3R5cGUudHRBZGFwdGVyID0gZGVwcmVjYXRlKGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiB0dEFkYXB0ZXIocXVlcnksIHN5bmNDYiwgYXN5bmNDYikge1xuICAgIHZhciBjYjtcblxuICAgIGlmICh0eXBlb2YgYXN5bmNDYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gdHlwZWFoZWFkIDAuMTFcbiAgICAgIGNiID0gYXN5bmNDYjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJlIHR5cGVhaGVhZCAwLjExXG4gICAgICBjYiA9IHN5bmNDYjtcbiAgICB9XG5cbiAgICBzZWxmLnNlYXJjaChxdWVyeSwgcGFyYW1zLCBmdW5jdGlvbiBzZWFyY2hEb25lKGVyciwgY29udGVudCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNiKGNvbnRlbnQuaGl0cyk7XG4gICAgfSk7XG4gIH07XG59LFxuJ3R0QWRhcHRlciBpcyBub3QgbmVjZXNzYXJ5IGFueW1vcmUgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB2ZXJzaW9uLFxcbicgK1xuJ2hhdmUgYSBsb29rIGF0IGF1dG9jb21wbGV0ZS5qcyAoaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYXV0b2NvbXBsZXRlLmpzKScpO1xuXG4vKlxuKiBXYWl0IHRoZSBwdWJsaWNhdGlvbiBvZiBhIHRhc2sgb24gdGhlIHNlcnZlci5cbiogQWxsIHNlcnZlciB0YXNrIGFyZSBhc3luY2hyb25vdXMgYW5kIHlvdSBjYW4gY2hlY2sgd2l0aCB0aGlzIG1ldGhvZCB0aGF0IHRoZSB0YXNrIGlzIHB1Ymxpc2hlZC5cbipcbiogQHBhcmFtIHRhc2tJRCB0aGUgaWQgb2YgdGhlIHRhc2sgcmV0dXJuZWQgYnkgc2VydmVyXG4qIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIHdpdGggd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiByZXN1bHRzXG4qL1xuSW5kZXgucHJvdG90eXBlLndhaXRUYXNrID0gZnVuY3Rpb24odGFza0lELCBjYWxsYmFjaykge1xuICAvLyB3YWl0IG1pbmltdW0gMTAwbXMgYmVmb3JlIHJldHJ5aW5nXG4gIHZhciBiYXNlRGVsYXkgPSAxMDA7XG4gIC8vIHdhaXQgbWF4aW11bSA1cyBiZWZvcmUgcmV0cnlpbmdcbiAgdmFyIG1heERlbGF5ID0gNTAwMDtcbiAgdmFyIGxvb3AgPSAwO1xuXG4gIC8vIHdhaXRUYXNrKCkgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IGZyb20gb3RoZXIgbWV0aG9kcyxcbiAgLy8gaXQncyBhIHJlY3Vyc2l2ZSBtZXRob2QgdXNpbmcgYSB0aW1lb3V0XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciBjbGllbnQgPSBpbmRleE9iai5hcztcblxuICB2YXIgcHJvbWlzZSA9IHJldHJ5TG9vcCgpO1xuXG4gIGZ1bmN0aW9uIHJldHJ5TG9vcCgpIHtcbiAgICByZXR1cm4gY2xpZW50Ll9qc29uUmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy90YXNrLycgKyB0YXNrSURcbiAgICB9KS50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3MoY29udGVudCkge1xuICAgICAgbG9vcCsrO1xuICAgICAgdmFyIGRlbGF5ID0gYmFzZURlbGF5ICogbG9vcCAqIGxvb3A7XG4gICAgICBpZiAoZGVsYXkgPiBtYXhEZWxheSkge1xuICAgICAgICBkZWxheSA9IG1heERlbGF5O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudC5zdGF0dXMgIT09ICdwdWJsaXNoZWQnKSB7XG4gICAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UuZGVsYXkoZGVsYXkpLnRoZW4ocmV0cnlMb29wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NiLCBmYWlsdXJlQ2IpO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3NDYihjb250ZW50KSB7XG4gICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRlbnQpO1xuICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWx1cmVDYihlcnIpIHtcbiAgICBleGl0UHJvbWlzZShmdW5jdGlvbiBleGl0KCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gIH1cbn07XG5cbi8qXG4qIFRoaXMgZnVuY3Rpb24gZGVsZXRlcyB0aGUgaW5kZXggY29udGVudC4gU2V0dGluZ3MgYW5kIGluZGV4IHNwZWNpZmljIEFQSSBrZXlzIGFyZSBrZXB0IHVudG91Y2hlZC5cbipcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2V0dGluZ3Mgb2JqZWN0IG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXgucHJvdG90eXBlLmNsZWFySW5kZXggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9jbGVhcicsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogR2V0IHNldHRpbmdzIG9mIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2V0dGluZ3Mgb2JqZWN0IG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXgucHJvdG90eXBlLmdldFNldHRpbmdzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9zZXR0aW5ncz9nZXRWZXJzaW9uPTInLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLnNlYXJjaFN5bm9ueW1zID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IHt9O1xuICB9IGVsc2UgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zL3NlYXJjaCcsXG4gICAgYm9keTogcGFyYW1zLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLnNhdmVTeW5vbnltID0gZnVuY3Rpb24oc3lub255bSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBpZiAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgIT09IHVuZGVmaW5lZCkgZGVwcmVjYXRlRm9yd2FyZFRvU2xhdmVzKCk7XG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IChvcHRzLmZvcndhcmRUb1NsYXZlcyB8fCBvcHRzLmZvcndhcmRUb1JlcGxpY2FzKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zLycgKyBlbmNvZGVVUklDb21wb25lbnQoc3lub255bS5vYmplY3RJRCkgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgYm9keTogc3lub255bSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZ2V0U3lub255bSA9IGZ1bmN0aW9uKG9iamVjdElELCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlU3lub255bSA9IGZ1bmN0aW9uKG9iamVjdElELCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCkgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmNsZWFyU3lub255bXMgPSBmdW5jdGlvbihvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zL2NsZWFyJyArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuYmF0Y2hTeW5vbnltcyA9IGZ1bmN0aW9uKHN5bm9ueW1zLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zL2JhdGNoJyArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyArXG4gICAgICAnJnJlcGxhY2VFeGlzdGluZ1N5bm9ueW1zPScgKyAob3B0cy5yZXBsYWNlRXhpc3RpbmdTeW5vbnltcyA/ICd0cnVlJyA6ICdmYWxzZScpLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGJvZHk6IHN5bm9ueW1zLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5zZWFyY2hSdWxlcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSB7fTtcbiAgfSBlbHNlIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy9zZWFyY2gnLFxuICAgIGJvZHk6IHBhcmFtcyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5zYXZlUnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gb3B0cy5mb3J3YXJkVG9SZXBsaWNhcyA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQocnVsZS5vYmplY3RJRCkgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgYm9keTogcnVsZSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZ2V0UnVsZSA9IGZ1bmN0aW9uKG9iamVjdElELCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcnVsZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGZ1bmN0aW9uKG9iamVjdElELCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuY2xlYXJSdWxlcyA9IGZ1bmN0aW9uKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gb3B0cy5mb3J3YXJkVG9SZXBsaWNhcyA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy9jbGVhcicgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmJhdGNoUnVsZXMgPSBmdW5jdGlvbihydWxlcywgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSBvcHRzLmZvcndhcmRUb1JlcGxpY2FzID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzL2JhdGNoJyArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyArXG4gICAgICAnJmNsZWFyRXhpc3RpbmdSdWxlcz0nICsgKG9wdHMuY2xlYXJFeGlzdGluZ1J1bGVzID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJyksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgYm9keTogcnVsZXMsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogU2V0IHNldHRpbmdzIGZvciB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBzZXR0aWducyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHRoYXQgY2FuIGNvbnRhaW5zIDpcbiogLSBtaW5Xb3JkU2l6ZWZvcjFUeXBvOiAoaW50ZWdlcikgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gYWNjZXB0IG9uZSB0eXBvIChkZWZhdWx0ID0gMykuXG4qIC0gbWluV29yZFNpemVmb3IyVHlwb3M6IChpbnRlZ2VyKSB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBhY2NlcHQgdHdvIHR5cG9zIChkZWZhdWx0ID0gNykuXG4qIC0gaGl0c1BlclBhZ2U6IChpbnRlZ2VyKSB0aGUgbnVtYmVyIG9mIGhpdHMgcGVyIHBhZ2UgKGRlZmF1bHQgPSAxMCkuXG4qIC0gYXR0cmlidXRlc1RvUmV0cmlldmU6IChhcnJheSBvZiBzdHJpbmdzKSBkZWZhdWx0IGxpc3Qgb2YgYXR0cmlidXRlcyB0byByZXRyaWV2ZSBpbiBvYmplY3RzLlxuKiAgIElmIHNldCB0byBudWxsLCBhbGwgYXR0cmlidXRlcyBhcmUgcmV0cmlldmVkLlxuKiAtIGF0dHJpYnV0ZXNUb0hpZ2hsaWdodDogKGFycmF5IG9mIHN0cmluZ3MpIGRlZmF1bHQgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGhpZ2hsaWdodC5cbiogICBJZiBzZXQgdG8gbnVsbCwgYWxsIGluZGV4ZWQgYXR0cmlidXRlcyBhcmUgaGlnaGxpZ2h0ZWQuXG4qIC0gYXR0cmlidXRlc1RvU25pcHBldCoqOiAoYXJyYXkgb2Ygc3RyaW5ncykgZGVmYXVsdCBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gc25pcHBldCBhbG9uZ3NpZGUgdGhlIG51bWJlclxuKiBvZiB3b3JkcyB0byByZXR1cm4gKHN5bnRheCBpcyBhdHRyaWJ1dGVOYW1lOm5iV29yZHMpLlxuKiAgIEJ5IGRlZmF1bHQgbm8gc25pcHBldCBpcyBjb21wdXRlZC4gSWYgc2V0IHRvIG51bGwsIG5vIHNuaXBwZXQgaXMgY29tcHV0ZWQuXG4qIC0gYXR0cmlidXRlc1RvSW5kZXg6IChhcnJheSBvZiBzdHJpbmdzKSB0aGUgbGlzdCBvZiBmaWVsZHMgeW91IHdhbnQgdG8gaW5kZXguXG4qICAgSWYgc2V0IHRvIG51bGwsIGFsbCB0ZXh0dWFsIGFuZCBudW1lcmljYWwgYXR0cmlidXRlcyBvZiB5b3VyIG9iamVjdHMgYXJlIGluZGV4ZWQsXG4qICAgYnV0IHlvdSBzaG91bGQgdXBkYXRlIGl0IHRvIGdldCBvcHRpbWFsIHJlc3VsdHMuXG4qICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHR3byBpbXBvcnRhbnQgdXNlczpcbiogICAgIC0gTGltaXQgdGhlIGF0dHJpYnV0ZXMgdG8gaW5kZXg6IEZvciBleGFtcGxlIGlmIHlvdSBzdG9yZSBhIGJpbmFyeSBpbWFnZSBpbiBiYXNlNjQsXG4qICAgICB5b3Ugd2FudCB0byBzdG9yZSBpdCBhbmQgYmUgYWJsZSB0b1xuKiAgICAgICByZXRyaWV2ZSBpdCBidXQgeW91IGRvbid0IHdhbnQgdG8gc2VhcmNoIGluIHRoZSBiYXNlNjQgc3RyaW5nLlxuKiAgICAgLSBDb250cm9sIHBhcnQgb2YgdGhlIHJhbmtpbmcqOiAoc2VlIHRoZSByYW5raW5nIHBhcmFtZXRlciBmb3IgZnVsbCBleHBsYW5hdGlvbilcbiogICAgIE1hdGNoZXMgaW4gYXR0cmlidXRlcyBhdCB0aGUgYmVnaW5uaW5nIG9mXG4qICAgICAgIHRoZSBsaXN0IHdpbGwgYmUgY29uc2lkZXJlZCBtb3JlIGltcG9ydGFudCB0aGFuIG1hdGNoZXMgaW4gYXR0cmlidXRlcyBmdXJ0aGVyIGRvd24gdGhlIGxpc3QuXG4qICAgICAgIEluIG9uZSBhdHRyaWJ1dGUsIG1hdGNoaW5nIHRleHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXR0cmlidXRlIHdpbGwgYmVcbiogICAgICAgY29uc2lkZXJlZCBtb3JlIGltcG9ydGFudCB0aGFuIHRleHQgYWZ0ZXIsIHlvdSBjYW4gZGlzYWJsZVxuKiAgICAgICB0aGlzIGJlaGF2aW9yIGlmIHlvdSBhZGQgeW91ciBhdHRyaWJ1dGUgaW5zaWRlIGB1bm9yZGVyZWQoQXR0cmlidXRlTmFtZSlgLFxuKiAgICAgICBmb3IgZXhhbXBsZSBhdHRyaWJ1dGVzVG9JbmRleDogW1widGl0bGVcIiwgXCJ1bm9yZGVyZWQodGV4dClcIl0uXG4qIC0gYXR0cmlidXRlc0ZvckZhY2V0aW5nOiAoYXJyYXkgb2Ygc3RyaW5ncykgVGhlIGxpc3Qgb2YgZmllbGRzIHlvdSB3YW50IHRvIHVzZSBmb3IgZmFjZXRpbmcuXG4qICAgQWxsIHN0cmluZ3MgaW4gdGhlIGF0dHJpYnV0ZSBzZWxlY3RlZCBmb3IgZmFjZXRpbmcgYXJlIGV4dHJhY3RlZCBhbmQgYWRkZWQgYXMgYSBmYWNldC5cbiogICBJZiBzZXQgdG8gbnVsbCwgbm8gYXR0cmlidXRlIGlzIHVzZWQgZm9yIGZhY2V0aW5nLlxuKiAtIGF0dHJpYnV0ZUZvckRpc3RpbmN0OiAoc3RyaW5nKSBUaGUgYXR0cmlidXRlIG5hbWUgdXNlZCBmb3IgdGhlIERpc3RpbmN0IGZlYXR1cmUuXG4qIFRoaXMgZmVhdHVyZSBpcyBzaW1pbGFyIHRvIHRoZSBTUUwgXCJkaXN0aW5jdFwiIGtleXdvcmQ6IHdoZW4gZW5hYmxlZFxuKiAgIGluIHF1ZXJ5IHdpdGggdGhlIGRpc3RpbmN0PTEgcGFyYW1ldGVyLCBhbGwgaGl0cyBjb250YWluaW5nIGEgZHVwbGljYXRlXG4qICAgdmFsdWUgZm9yIHRoaXMgYXR0cmlidXRlIGFyZSByZW1vdmVkIGZyb20gcmVzdWx0cy5cbiogICBGb3IgZXhhbXBsZSwgaWYgdGhlIGNob3NlbiBhdHRyaWJ1dGUgaXMgc2hvd19uYW1lIGFuZCBzZXZlcmFsIGhpdHMgaGF2ZVxuKiAgIHRoZSBzYW1lIHZhbHVlIGZvciBzaG93X25hbWUsIHRoZW4gb25seSB0aGUgYmVzdCBvbmUgaXMga2VwdCBhbmQgb3RoZXJzIGFyZSByZW1vdmVkLlxuKiAtIHJhbmtpbmc6IChhcnJheSBvZiBzdHJpbmdzKSBjb250cm9scyB0aGUgd2F5IHJlc3VsdHMgYXJlIHNvcnRlZC5cbiogICBXZSBoYXZlIHNpeCBhdmFpbGFibGUgY3JpdGVyaWE6XG4qICAgIC0gdHlwbzogc29ydCBhY2NvcmRpbmcgdG8gbnVtYmVyIG9mIHR5cG9zLFxuKiAgICAtIGdlbzogc29ydCBhY2NvcmRpbmcgdG8gZGVjcmVhc3NpbmcgZGlzdGFuY2Ugd2hlbiBwZXJmb3JtaW5nIGEgZ2VvLWxvY2F0aW9uIGJhc2VkIHNlYXJjaCxcbiogICAgLSBwcm94aW1pdHk6IHNvcnQgYWNjb3JkaW5nIHRvIHRoZSBwcm94aW1pdHkgb2YgcXVlcnkgd29yZHMgaW4gaGl0cyxcbiogICAgLSBhdHRyaWJ1dGU6IHNvcnQgYWNjb3JkaW5nIHRvIHRoZSBvcmRlciBvZiBhdHRyaWJ1dGVzIGRlZmluZWQgYnkgYXR0cmlidXRlc1RvSW5kZXgsXG4qICAgIC0gZXhhY3Q6XG4qICAgICAgICAtIGlmIHRoZSB1c2VyIHF1ZXJ5IGNvbnRhaW5zIG9uZSB3b3JkOiBzb3J0IG9iamVjdHMgaGF2aW5nIGFuIGF0dHJpYnV0ZVxuKiAgICAgICAgdGhhdCBpcyBleGFjdGx5IHRoZSBxdWVyeSB3b3JkIGJlZm9yZSBvdGhlcnMuXG4qICAgICAgICAgIEZvciBleGFtcGxlIGlmIHlvdSBzZWFyY2ggZm9yIHRoZSBcIlZcIiBUViBzaG93LCB5b3Ugd2FudCB0byBmaW5kIGl0XG4qICAgICAgICAgIHdpdGggdGhlIFwiVlwiIHF1ZXJ5IGFuZCBhdm9pZCB0byBoYXZlIGFsbCBwb3B1bGFyIFRWXG4qICAgICAgICAgIHNob3cgc3RhcnRpbmcgYnkgdGhlIHYgbGV0dGVyIGJlZm9yZSBpdC5cbiogICAgICAgIC0gaWYgdGhlIHVzZXIgcXVlcnkgY29udGFpbnMgbXVsdGlwbGUgd29yZHM6IHNvcnQgYWNjb3JkaW5nIHRvIHRoZVxuKiAgICAgICAgbnVtYmVyIG9mIHdvcmRzIHRoYXQgbWF0Y2hlZCBleGFjdGx5IChhbmQgbm90IGFzIGEgcHJlZml4KS5cbiogICAgLSBjdXN0b206IHNvcnQgYWNjb3JkaW5nIHRvIGEgdXNlciBkZWZpbmVkIGZvcm11bGEgc2V0IGluICoqY3VzdG9tUmFua2luZyoqIGF0dHJpYnV0ZS5cbiogICBUaGUgc3RhbmRhcmQgb3JkZXIgaXMgW1widHlwb1wiLCBcImdlb1wiLCBcInByb3hpbWl0eVwiLCBcImF0dHJpYnV0ZVwiLCBcImV4YWN0XCIsIFwiY3VzdG9tXCJdXG4qIC0gY3VzdG9tUmFua2luZzogKGFycmF5IG9mIHN0cmluZ3MpIGxldHMgeW91IHNwZWNpZnkgcGFydCBvZiB0aGUgcmFua2luZy5cbiogICBUaGUgc3ludGF4IG9mIHRoaXMgY29uZGl0aW9uIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBhdHRyaWJ1dGVzXG4qICAgcHJlZml4ZWQgYnkgYXNjIChhc2NlbmRpbmcgb3JkZXIpIG9yIGRlc2MgKGRlc2NlbmRpbmcgb3JkZXIpIG9wZXJhdG9yLlxuKiAgIEZvciBleGFtcGxlIGBcImN1c3RvbVJhbmtpbmdcIiA9PiBbXCJkZXNjKHBvcHVsYXRpb24pXCIsIFwiYXNjKG5hbWUpXCJdYFxuKiAtIHF1ZXJ5VHlwZTogU2VsZWN0IGhvdyB0aGUgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkLCBpdCBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWU6XG4qICAgLSBwcmVmaXhBbGw6IGFsbCBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgcHJlZml4ZXMsXG4qICAgLSBwcmVmaXhMYXN0OiBvbmx5IHRoZSBsYXN0IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXggKGRlZmF1bHQgYmVoYXZpb3IpLFxuKiAgIC0gcHJlZml4Tm9uZTogbm8gcXVlcnkgd29yZCBpcyBpbnRlcnByZXRlZCBhcyBhIHByZWZpeC4gVGhpcyBvcHRpb24gaXMgbm90IHJlY29tbWVuZGVkLlxuKiAtIGhpZ2hsaWdodFByZVRhZzogKHN0cmluZykgU3BlY2lmeSB0aGUgc3RyaW5nIHRoYXQgaXMgaW5zZXJ0ZWQgYmVmb3JlXG4qIHRoZSBoaWdobGlnaHRlZCBwYXJ0cyBpbiB0aGUgcXVlcnkgcmVzdWx0IChkZWZhdWx0IHRvIFwiPGVtPlwiKS5cbiogLSBoaWdobGlnaHRQb3N0VGFnOiAoc3RyaW5nKSBTcGVjaWZ5IHRoZSBzdHJpbmcgdGhhdCBpcyBpbnNlcnRlZCBhZnRlclxuKiB0aGUgaGlnaGxpZ2h0ZWQgcGFydHMgaW4gdGhlIHF1ZXJ5IHJlc3VsdCAoZGVmYXVsdCB0byBcIjwvZW0+XCIpLlxuKiAtIG9wdGlvbmFsV29yZHM6IChhcnJheSBvZiBzdHJpbmdzKSBTcGVjaWZ5IGEgbGlzdCBvZiB3b3JkcyB0aGF0IHNob3VsZFxuKiBiZSBjb25zaWRlcmVkIGFzIG9wdGlvbmFsIHdoZW4gZm91bmQgaW4gdGhlIHF1ZXJ5LlxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXgucHJvdG90eXBlLnNldFNldHRpbmdzID0gZnVuY3Rpb24oc2V0dGluZ3MsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL3NldHRpbmdzP2ZvcndhcmRUb1JlcGxpY2FzPSdcbiAgICAgICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgYm9keTogc2V0dGluZ3MsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXgubGlzdEFwaUtleXNcbiAqL1xuSW5kZXgucHJvdG90eXBlLmxpc3RVc2VyS2V5cyA9IGRlcHJlY2F0ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5saXN0QXBpS2V5cyhjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXgubGlzdFVzZXJLZXlzKCknLCAnaW5kZXgubGlzdEFwaUtleXMoKScpKTtcblxuLypcbiogTGlzdCBhbGwgZXhpc3RpbmcgQVBJIGtleXMgdG8gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIEFQSSBrZXlzIGJlbG9uZ2luZyB0byB0aGUgaW5kZXhcbiovXG5JbmRleC5wcm90b3R5cGUubGlzdEFwaUtleXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2tleXMnLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXguZ2V0QXBpS2V5XG4gKi9cbkluZGV4LnByb3RvdHlwZS5nZXRVc2VyS2V5QUNMID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZ2V0QXBpS2V5KGtleSwgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4LmdldFVzZXJLZXlBQ0woKScsICdpbmRleC5nZXRBcGlLZXkoKScpKTtcblxuXG4vKlxuKiBHZXQgYW4gQVBJIGtleSBmcm9tIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGtleVxuKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSByaWdodCBBUEkga2V5XG4qL1xuSW5kZXgucHJvdG90eXBlLmdldEFwaUtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9rZXlzLycgKyBrZXksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBpbmRleC5kZWxldGVBcGlLZXlcbiAqL1xuSW5kZXgucHJvdG90eXBlLmRlbGV0ZVVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5kZWxldGVBcGlLZXkoa2V5LCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXguZGVsZXRlVXNlcktleSgpJywgJ2luZGV4LmRlbGV0ZUFwaUtleSgpJykpO1xuXG4vKlxuKiBEZWxldGUgYW4gZXhpc3RpbmcgQVBJIGtleSBhc3NvY2lhdGVkIHRvIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGtleVxuKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBkZWxldGlvbiBkYXRlXG4qL1xuSW5kZXgucHJvdG90eXBlLmRlbGV0ZUFwaUtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9rZXlzLycgKyBrZXksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXguYWRkQXBpS2V5XG4gKi9cbkluZGV4LnByb3RvdHlwZS5hZGRVc2VyS2V5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYWRkQXBpS2V5KGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4LmFkZFVzZXJLZXkoKScsICdpbmRleC5hZGRBcGlLZXkoKScpKTtcblxuLypcbiogQWRkIGEgbmV3IEFQSSBrZXkgdG8gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2xzIC0gVGhlIGxpc3Qgb2YgQUNMIGZvciB0aGlzIGtleS4gRGVmaW5lZCBieSBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXRcbiogICBjYW4gY29udGFpbnMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4qICAgICAtIHNlYXJjaDogYWxsb3cgdG8gc2VhcmNoIChodHRwcyBhbmQgaHR0cClcbiogICAgIC0gYWRkT2JqZWN0OiBhbGxvd3MgdG8gYWRkL3VwZGF0ZSBhbiBvYmplY3QgaW4gdGhlIGluZGV4IChodHRwcyBvbmx5KVxuKiAgICAgLSBkZWxldGVPYmplY3QgOiBhbGxvd3MgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIG9iamVjdCAoaHR0cHMgb25seSlcbiogICAgIC0gZGVsZXRlSW5kZXggOiBhbGxvd3MgdG8gZGVsZXRlIGluZGV4IGNvbnRlbnQgKGh0dHBzIG9ubHkpXG4qICAgICAtIHNldHRpbmdzIDogYWxsb3dzIHRvIGdldCBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiogICAgIC0gZWRpdFNldHRpbmdzIDogYWxsb3dzIHRvIGNoYW5nZSBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9ubmFsIHBhcmFtZXRlcnMgdG8gc2V0IGZvciB0aGUga2V5XG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsaWRpdHkgLSBOdW1iZXIgb2Ygc2Vjb25kcyBhZnRlciB3aGljaCB0aGUga2V5IHdpbGxcbiogYmUgYXV0b21hdGljYWxseSByZW1vdmVkICgwIG1lYW5zIG5vIHRpbWUgbGltaXQgZm9yIHRoaXMga2V5KVxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5IC0gTnVtYmVyIG9mIGhpdHMgdGhpcyBBUEkga2V5IGNhbiByZXRyaWV2ZSBpbiBvbmUgY2FsbFxuKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBmb3IgeW91ciBrZXlcbiogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJlZmVyZXJzIC0gQSBsaXN0IG9mIGF1dGhvcml6ZWQgcmVmZXJlcnNcbiogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGFkZGVkIEFQSSBrZXlcbiogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4qIEBleGFtcGxlXG4qIGluZGV4LmFkZFVzZXJLZXkoWydzZWFyY2gnXSwge1xuKiAgIHZhbGlkaXR5OiAzMDAsXG4qICAgbWF4UXVlcmllc1BlcklQUGVySG91cjogMjAwMCxcbiogICBtYXhIaXRzUGVyUXVlcnk6IDMsXG4qICAgZGVzY3JpcHRpb246ICdFYXQgdGhyZWUgZnJ1aXRzJyxcbiogICByZWZlcmVyczogWycqLmFsZ29saWEuY29tJ10sXG4qICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4qICAgICB0YWdGaWx0ZXJzOiBbJ3B1YmxpYyddLFxuKiAgIH1cbiogfSlcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0FkZEluZGV4S2V5fEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleC5wcm90b3R5cGUuYWRkQXBpS2V5ID0gZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5hZGRBcGlLZXkoYXJyYXlPZkFjbHNbLCBwYXJhbXMsIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShhY2xzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwb3N0T2JqID0ge1xuICAgIGFjbDogYWNsc1xuICB9O1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBwb3N0T2JqLnZhbGlkaXR5ID0gcGFyYW1zLnZhbGlkaXR5O1xuICAgIHBvc3RPYmoubWF4UXVlcmllc1BlcklQUGVySG91ciA9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyO1xuICAgIHBvc3RPYmoubWF4SGl0c1BlclF1ZXJ5ID0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeTtcbiAgICBwb3N0T2JqLmRlc2NyaXB0aW9uID0gcGFyYW1zLmRlc2NyaXB0aW9uO1xuXG4gICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIHBvc3RPYmoucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5hcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMsICcnKTtcbiAgICB9XG5cbiAgICBwb3N0T2JqLnJlZmVyZXJzID0gcGFyYW1zLnJlZmVyZXJzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9rZXlzJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuKiBAZGVwcmVjYXRlZCB1c2UgaW5kZXguYWRkQXBpS2V5KClcbiovXG5JbmRleC5wcm90b3R5cGUuYWRkVXNlcktleVdpdGhWYWxpZGl0eSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBkZXByZWNhdGVkQWRkVXNlcktleVdpdGhWYWxpZGl0eShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFkZEFwaUtleShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5KCknLCAnaW5kZXguYWRkQXBpS2V5KCknKSk7XG5cbi8qXG4gQGRlcHJlY2F0ZWQgc2VlIGluZGV4LnVwZGF0ZUFwaUtleVxuICovXG5JbmRleC5wcm90b3R5cGUudXBkYXRlVXNlcktleSA9IGRlcHJlY2F0ZShmdW5jdGlvbihrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMudXBkYXRlQXBpS2V5KGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXgudXBkYXRlVXNlcktleSgpJywgJ2luZGV4LnVwZGF0ZUFwaUtleSgpJykpO1xuXG4vKipcbiogVXBkYXRlIGFuIGV4aXN0aW5nIEFQSSBrZXkgb2YgdGhpcyBpbmRleFxuKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB1cGRhdGVcbiogQHBhcmFtIHtzdHJpbmdbXX0gYWNscyAtIFRoZSBsaXN0IG9mIEFDTCBmb3IgdGhpcyBrZXkuIERlZmluZWQgYnkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0XG4qICAgY2FuIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuKiAgICAgLSBzZWFyY2g6IGFsbG93IHRvIHNlYXJjaCAoaHR0cHMgYW5kIGh0dHApXG4qICAgICAtIGFkZE9iamVjdDogYWxsb3dzIHRvIGFkZC91cGRhdGUgYW4gb2JqZWN0IGluIHRoZSBpbmRleCAoaHR0cHMgb25seSlcbiogICAgIC0gZGVsZXRlT2JqZWN0IDogYWxsb3dzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBvYmplY3QgKGh0dHBzIG9ubHkpXG4qICAgICAtIGRlbGV0ZUluZGV4IDogYWxsb3dzIHRvIGRlbGV0ZSBpbmRleCBjb250ZW50IChodHRwcyBvbmx5KVxuKiAgICAgLSBzZXR0aW5ncyA6IGFsbG93cyB0byBnZXQgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4qICAgICAtIGVkaXRTZXR0aW5ncyA6IGFsbG93cyB0byBjaGFuZ2UgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4qIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbm5hbCBwYXJhbWV0ZXJzIHRvIHNldCBmb3IgdGhlIGtleVxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbGlkaXR5IC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGtleSB3aWxsXG4qIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCAoMCBtZWFucyBubyB0aW1lIGxpbWl0IGZvciB0aGlzIGtleSlcbiogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyIC0gTnVtYmVyIG9mIEFQSSBjYWxscyBhbGxvd2VkIGZyb20gYW4gSVAgYWRkcmVzcyBwZXIgaG91clxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4qIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5yZWZlcmVycyAtIEEgbGlzdCBvZiBhdXRob3JpemVkIHJlZmVyZXJzXG4qIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucXVlcnlQYXJhbWV0ZXJzIC0gRm9yY2UgdGhlIGtleSB0byB1c2Ugc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHVzZXIga2V5cyBsaXN0XG4qIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuKiBAZXhhbXBsZVxuKiBpbmRleC51cGRhdGVBcGlLZXkoJ0FQSUtFWScsIFsnc2VhcmNoJ10sIHtcbiogICB2YWxpZGl0eTogMzAwLFxuKiAgIG1heFF1ZXJpZXNQZXJJUFBlckhvdXI6IDIwMDAsXG4qICAgbWF4SGl0c1BlclF1ZXJ5OiAzLFxuKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4qICAgcmVmZXJlcnM6IFsnKi5hbGdvbGlhLmNvbSddLFxuKiAgIHF1ZXJ5UGFyYW1ldGVyczoge1xuKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiogICB9XG4qIH0pXG4qIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNVcGRhdGVJbmRleEtleXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXgucHJvdG90eXBlLnVwZGF0ZUFwaUtleSA9IGZ1bmN0aW9uKGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC51cGRhdGVBcGlLZXkoa2V5LCBhcnJheU9mQWNsc1ssIHBhcmFtcywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KGFjbHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSBudWxsO1xuICB9XG5cbiAgdmFyIHB1dE9iaiA9IHtcbiAgICBhY2w6IGFjbHNcbiAgfTtcblxuICBpZiAocGFyYW1zKSB7XG4gICAgcHV0T2JqLnZhbGlkaXR5ID0gcGFyYW1zLnZhbGlkaXR5O1xuICAgIHB1dE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgcHV0T2JqLm1heEhpdHNQZXJRdWVyeSA9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnk7XG4gICAgcHV0T2JqLmRlc2NyaXB0aW9uID0gcGFyYW1zLmRlc2NyaXB0aW9uO1xuXG4gICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIHB1dE9iai5xdWVyeVBhcmFtZXRlcnMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycywgJycpO1xuICAgIH1cblxuICAgIHB1dE9iai5yZWZlcmVycyA9IHBhcmFtcy5yZWZlcmVycztcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9rZXlzLycgKyBrZXksXG4gICAgYm9keTogcHV0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0luZGV4LmpzIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ2YXIgYnVpbGRTZWFyY2hNZXRob2QgPSByZXF1aXJlKCcuL2J1aWxkU2VhcmNoTWV0aG9kLmpzJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUuanMnKTtcbnZhciBkZXByZWNhdGVkTWVzc2FnZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZE1lc3NhZ2UuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleENvcmU7XG5cbi8qXG4qIEluZGV4IGNsYXNzIGNvbnN0cnVjdG9yLlxuKiBZb3Ugc2hvdWxkIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgYnV0IHVzZSBpbml0SW5kZXgoKSBmdW5jdGlvblxuKi9cbmZ1bmN0aW9uIEluZGV4Q29yZShhbGdvbGlhc2VhcmNoLCBpbmRleE5hbWUpIHtcbiAgdGhpcy5pbmRleE5hbWUgPSBpbmRleE5hbWU7XG4gIHRoaXMuYXMgPSBhbGdvbGlhc2VhcmNoO1xuICB0aGlzLnR5cGVBaGVhZEFyZ3MgPSBudWxsO1xuICB0aGlzLnR5cGVBaGVhZFZhbHVlT3B0aW9uID0gbnVsbDtcblxuICAvLyBtYWtlIHN1cmUgZXZlcnkgaW5kZXggaW5zdGFuY2UgaGFzIGl0J3Mgb3duIGNhY2hlXG4gIHRoaXMuY2FjaGUgPSB7fTtcbn1cblxuLypcbiogQ2xlYXIgYWxsIHF1ZXJpZXMgaW4gY2FjaGVcbiovXG5JbmRleENvcmUucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYWNoZSA9IHt9O1xufTtcblxuLypcbiogU2VhcmNoIGluc2lkZSB0aGUgaW5kZXggdXNpbmcgWE1MSHR0cFJlcXVlc3QgcmVxdWVzdCAoVXNpbmcgYSBQT1NUIHF1ZXJ5IHRvXG4qIG1pbmltaXplIG51bWJlciBvZiBPUFRJT05TIHF1ZXJpZXM6IENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nKS5cbipcbiogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV0gdGhlIGZ1bGwgdGV4dCBxdWVyeVxuKiBAcGFyYW0ge29iamVjdH0gW2FyZ3NdIChvcHRpb25hbCkgaWYgc2V0LCBjb250YWlucyBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzOlxuKiAtIHBhZ2U6IChpbnRlZ2VyKSBQYWdpbmF0aW9uIHBhcmFtZXRlciB1c2VkIHRvIHNlbGVjdCB0aGUgcGFnZSB0byByZXRyaWV2ZS5cbiogICAgICAgICAgICAgICAgICAgUGFnZSBpcyB6ZXJvLWJhc2VkIGFuZCBkZWZhdWx0cyB0byAwLiBUaHVzLFxuKiAgICAgICAgICAgICAgICAgICB0byByZXRyaWV2ZSB0aGUgMTB0aCBwYWdlIHlvdSBuZWVkIHRvIHNldCBwYWdlPTlcbiogLSBoaXRzUGVyUGFnZTogKGludGVnZXIpIFBhZ2luYXRpb24gcGFyYW1ldGVyIHVzZWQgdG8gc2VsZWN0IHRoZSBudW1iZXIgb2YgaGl0cyBwZXIgcGFnZS4gRGVmYXVsdHMgdG8gMjAuXG4qIC0gYXR0cmlidXRlc1RvUmV0cmlldmU6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2Ygb2JqZWN0IGF0dHJpYnV0ZXNcbiogeW91IHdhbnQgdG8gcmV0cmlldmUgKGxldCB5b3UgbWluaW1pemUgdGhlIGFuc3dlciBzaXplKS5cbiogICBBdHRyaWJ1dGVzIGFyZSBzZXBhcmF0ZWQgd2l0aCBhIGNvbW1hIChmb3IgZXhhbXBsZSBcIm5hbWUsYWRkcmVzc1wiKS5cbiogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBbXCJuYW1lXCIsXCJhZGRyZXNzXCJdKS5cbiogICBCeSBkZWZhdWx0LCBhbGwgYXR0cmlidXRlcyBhcmUgcmV0cmlldmVkLiBZb3UgY2FuIGFsc28gdXNlICcqJyB0byByZXRyaWV2ZSBhbGxcbiogICB2YWx1ZXMgd2hlbiBhbiBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSBzZXR0aW5nIGlzIHNwZWNpZmllZCBmb3IgeW91ciBpbmRleC5cbiogLSBhdHRyaWJ1dGVzVG9IaWdobGlnaHQ6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgYXR0cmlidXRlcyB5b3VcbiogICB3YW50IHRvIGhpZ2hsaWdodCBhY2NvcmRpbmcgdG8gdGhlIHF1ZXJ5LlxuKiAgIEF0dHJpYnV0ZXMgYXJlIHNlcGFyYXRlZCBieSBhIGNvbW1hLiBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBbXCJuYW1lXCIsXCJhZGRyZXNzXCJdKS5cbiogICBJZiBhbiBhdHRyaWJ1dGUgaGFzIG5vIG1hdGNoIGZvciB0aGUgcXVlcnksIHRoZSByYXcgdmFsdWUgaXMgcmV0dXJuZWQuXG4qICAgQnkgZGVmYXVsdCBhbGwgaW5kZXhlZCB0ZXh0IGF0dHJpYnV0ZXMgYXJlIGhpZ2hsaWdodGVkLlxuKiAgIFlvdSBjYW4gdXNlIGAqYCBpZiB5b3Ugd2FudCB0byBoaWdobGlnaHQgYWxsIHRleHR1YWwgYXR0cmlidXRlcy5cbiogICBOdW1lcmljYWwgYXR0cmlidXRlcyBhcmUgbm90IGhpZ2hsaWdodGVkLlxuKiAgIEEgbWF0Y2hMZXZlbCBpcyByZXR1cm5lZCBmb3IgZWFjaCBoaWdobGlnaHRlZCBhdHRyaWJ1dGUgYW5kIGNhbiBjb250YWluOlxuKiAgICAgIC0gZnVsbDogaWYgYWxsIHRoZSBxdWVyeSB0ZXJtcyB3ZXJlIGZvdW5kIGluIHRoZSBhdHRyaWJ1dGUsXG4qICAgICAgLSBwYXJ0aWFsOiBpZiBvbmx5IHNvbWUgb2YgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQsXG4qICAgICAgLSBub25lOiBpZiBub25lIG9mIHRoZSBxdWVyeSB0ZXJtcyB3ZXJlIGZvdW5kLlxuKiAtIGF0dHJpYnV0ZXNUb1NuaXBwZXQ6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBzbmlwcGV0IGFsb25nc2lkZVxuKiB0aGUgbnVtYmVyIG9mIHdvcmRzIHRvIHJldHVybiAoc3ludGF4IGlzIGBhdHRyaWJ1dGVOYW1lOm5iV29yZHNgKS5cbiogICAgQXR0cmlidXRlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEgKEV4YW1wbGU6IGF0dHJpYnV0ZXNUb1NuaXBwZXQ9bmFtZToxMCxjb250ZW50OjEwKS5cbiogICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoRXhhbXBsZTogYXR0cmlidXRlc1RvU25pcHBldDogWyduYW1lOjEwJywnY29udGVudDoxMCddKS5cbiogICAgQnkgZGVmYXVsdCBubyBzbmlwcGV0IGlzIGNvbXB1dGVkLlxuKiAtIG1pbldvcmRTaXplZm9yMVR5cG86IHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIGEgcXVlcnkgd29yZCB0byBhY2NlcHQgb25lIHR5cG8gaW4gdGhpcyB3b3JkLlxuKiBEZWZhdWx0cyB0byAzLlxuKiAtIG1pbldvcmRTaXplZm9yMlR5cG9zOiB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBhIHF1ZXJ5IHdvcmRcbiogdG8gYWNjZXB0IHR3byB0eXBvcyBpbiB0aGlzIHdvcmQuIERlZmF1bHRzIHRvIDcuXG4qIC0gZ2V0UmFua2luZ0luZm86IGlmIHNldCB0byAxLCB0aGUgcmVzdWx0IGhpdHMgd2lsbCBjb250YWluIHJhbmtpbmdcbiogaW5mb3JtYXRpb24gaW4gX3JhbmtpbmdJbmZvIGF0dHJpYnV0ZS5cbiogLSBhcm91bmRMYXRMbmc6IHNlYXJjaCBmb3IgZW50cmllcyBhcm91bmQgYSBnaXZlblxuKiBsYXRpdHVkZS9sb25naXR1ZGUgKHNwZWNpZmllZCBhcyB0d28gZmxvYXRzIHNlcGFyYXRlZCBieSBhIGNvbW1hKS5cbiogICBGb3IgZXhhbXBsZSBhcm91bmRMYXRMbmc9NDcuMzE2NjY5LDUuMDE2NjcwKS5cbiogICBZb3UgY2FuIHNwZWNpZnkgdGhlIG1heGltdW0gZGlzdGFuY2UgaW4gbWV0ZXJzIHdpdGggdGhlIGFyb3VuZFJhZGl1cyBwYXJhbWV0ZXIgKGluIG1ldGVycylcbiogICBhbmQgdGhlIHByZWNpc2lvbiBmb3IgcmFua2luZyB3aXRoIGFyb3VuZFByZWNpc2lvblxuKiAgIChmb3IgZXhhbXBsZSBpZiB5b3Ugc2V0IGFyb3VuZFByZWNpc2lvbj0xMDAsIHR3byBvYmplY3RzIHRoYXQgYXJlIGRpc3RhbnQgb2ZcbiogICBsZXNzIHRoYW4gMTAwbSB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgaWRlbnRpY2FsIGZvciBcImdlb1wiIHJhbmtpbmcgcGFyYW1ldGVyKS5cbiogICBBdCBpbmRleGluZywgeW91IHNob3VsZCBzcGVjaWZ5IGdlb2xvYyBvZiBhbiBvYmplY3Qgd2l0aCB0aGUgX2dlb2xvYyBhdHRyaWJ1dGVcbiogICAoaW4gdGhlIGZvcm0ge1wiX2dlb2xvY1wiOntcImxhdFwiOjQ4Ljg1MzQwOSwgXCJsbmdcIjoyLjM0ODgwMH19KVxuKiAtIGluc2lkZUJvdW5kaW5nQm94OiBzZWFyY2ggZW50cmllcyBpbnNpZGUgYSBnaXZlbiBhcmVhIGRlZmluZWQgYnkgdGhlIHR3byBleHRyZW1lIHBvaW50c1xuKiBvZiBhIHJlY3RhbmdsZSAoZGVmaW5lZCBieSA0IGZsb2F0czogcDFMYXQscDFMbmcscDJMYXQscDJMbmcpLlxuKiAgIEZvciBleGFtcGxlIGluc2lkZUJvdW5kaW5nQm94PTQ3LjMxNjUsNC45NjY1LDQ3LjM0MjQsNS4wMjAxKS5cbiogICBBdCBpbmRleGluZywgeW91IHNob3VsZCBzcGVjaWZ5IGdlb2xvYyBvZiBhbiBvYmplY3Qgd2l0aCB0aGUgX2dlb2xvYyBhdHRyaWJ1dGVcbiogICAoaW4gdGhlIGZvcm0ge1wiX2dlb2xvY1wiOntcImxhdFwiOjQ4Ljg1MzQwOSwgXCJsbmdcIjoyLjM0ODgwMH19KVxuKiAtIG51bWVyaWNGaWx0ZXJzOiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIG51bWVyaWMgZmlsdGVycyB5b3Ugd2FudCB0b1xuKiBhcHBseSBzZXBhcmF0ZWQgYnkgYSBjb21tYS5cbiogICBUaGUgc3ludGF4IG9mIG9uZSBmaWx0ZXIgaXMgYGF0dHJpYnV0ZU5hbWVgIGZvbGxvd2VkIGJ5IGBvcGVyYW5kYCBmb2xsb3dlZCBieSBgdmFsdWVgLlxuKiAgIFN1cHBvcnRlZCBvcGVyYW5kcyBhcmUgYDxgLCBgPD1gLCBgPWAsIGA+YCBhbmQgYD49YC5cbiogICBZb3UgY2FuIGhhdmUgbXVsdGlwbGUgY29uZGl0aW9ucyBvbiBvbmUgYXR0cmlidXRlIGxpa2UgZm9yIGV4YW1wbGUgbnVtZXJpY0ZpbHRlcnM9cHJpY2U+MTAwLHByaWNlPDEwMDAuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoZm9yIGV4YW1wbGUgbnVtZXJpY0ZpbHRlcnM6IFtcInByaWNlPjEwMFwiLFwicHJpY2U8MTAwMFwiXSkuXG4qIC0gdGFnRmlsdGVyczogZmlsdGVyIHRoZSBxdWVyeSBieSBhIHNldCBvZiB0YWdzLiBZb3UgY2FuIEFORCB0YWdzIGJ5IHNlcGFyYXRpbmcgdGhlbSBieSBjb21tYXMuXG4qICAgVG8gT1IgdGFncywgeW91IG11c3QgYWRkIHBhcmVudGhlc2VzLiBGb3IgZXhhbXBsZSwgdGFncz10YWcxLCh0YWcyLHRhZzMpIG1lYW5zIHRhZzEgQU5EICh0YWcyIE9SIHRhZzMpLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXksIGZvciBleGFtcGxlIHRhZ0ZpbHRlcnM6IFtcInRhZzFcIixbXCJ0YWcyXCIsXCJ0YWczXCJdXVxuKiAgIG1lYW5zIHRhZzEgQU5EICh0YWcyIE9SIHRhZzMpLlxuKiAgIEF0IGluZGV4aW5nLCB0YWdzIHNob3VsZCBiZSBhZGRlZCBpbiB0aGUgX3RhZ3MqKiBhdHRyaWJ1dGVcbiogICBvZiBvYmplY3RzIChmb3IgZXhhbXBsZSB7XCJfdGFnc1wiOltcInRhZzFcIixcInRhZzJcIl19KS5cbiogLSBmYWNldEZpbHRlcnM6IGZpbHRlciB0aGUgcXVlcnkgYnkgYSBsaXN0IG9mIGZhY2V0cy5cbiogICBGYWNldHMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMgYW5kIGVhY2ggZmFjZXQgaXMgZW5jb2RlZCBhcyBgYXR0cmlidXRlTmFtZTp2YWx1ZWAuXG4qICAgRm9yIGV4YW1wbGU6IGBmYWNldEZpbHRlcnM9Y2F0ZWdvcnk6Qm9vayxhdXRob3I6Sm9obiUyMERvZWAuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoZm9yIGV4YW1wbGUgYFtcImNhdGVnb3J5OkJvb2tcIixcImF1dGhvcjpKb2huJTIwRG9lXCJdYCkuXG4qIC0gZmFjZXRzOiBMaXN0IG9mIG9iamVjdCBhdHRyaWJ1dGVzIHRoYXQgeW91IHdhbnQgdG8gdXNlIGZvciBmYWNldGluZy5cbiogICBDb21tYSBzZXBhcmF0ZWQgbGlzdDogYFwiY2F0ZWdvcnksYXV0aG9yXCJgIG9yIGFycmF5IGBbJ2NhdGVnb3J5JywnYXV0aG9yJ11gXG4qICAgT25seSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIGluICoqYXR0cmlidXRlc0ZvckZhY2V0aW5nKiogaW5kZXggc2V0dGluZ1xuKiAgIGNhbiBiZSB1c2VkIGluIHRoaXMgcGFyYW1ldGVyLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYCpgIHRvIHBlcmZvcm0gZmFjZXRpbmcgb24gYWxsIGF0dHJpYnV0ZXMgc3BlY2lmaWVkIGluICoqYXR0cmlidXRlc0ZvckZhY2V0aW5nKiouXG4qIC0gcXVlcnlUeXBlOiBzZWxlY3QgaG93IHRoZSBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQsIGl0IGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZTpcbiogICAgLSBwcmVmaXhBbGw6IGFsbCBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgcHJlZml4ZXMsXG4qICAgIC0gcHJlZml4TGFzdDogb25seSB0aGUgbGFzdCB3b3JkIGlzIGludGVycHJldGVkIGFzIGEgcHJlZml4IChkZWZhdWx0IGJlaGF2aW9yKSxcbiogICAgLSBwcmVmaXhOb25lOiBubyBxdWVyeSB3b3JkIGlzIGludGVycHJldGVkIGFzIGEgcHJlZml4LiBUaGlzIG9wdGlvbiBpcyBub3QgcmVjb21tZW5kZWQuXG4qIC0gb3B0aW9uYWxXb3JkczogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiB3b3JkcyB0aGF0IHNob3VsZFxuKiBiZSBjb25zaWRlcmVkIGFzIG9wdGlvbmFsIHdoZW4gZm91bmQgaW4gdGhlIHF1ZXJ5LlxuKiAgIENvbW1hIHNlcGFyYXRlZCBhbmQgYXJyYXkgYXJlIGFjY2VwdGVkLlxuKiAtIGRpc3RpbmN0OiBJZiBzZXQgdG8gMSwgZW5hYmxlIHRoZSBkaXN0aW5jdCBmZWF0dXJlIChkaXNhYmxlZCBieSBkZWZhdWx0KVxuKiBpZiB0aGUgYXR0cmlidXRlRm9yRGlzdGluY3QgaW5kZXggc2V0dGluZyBpcyBzZXQuXG4qICAgVGhpcyBmZWF0dXJlIGlzIHNpbWlsYXIgdG8gdGhlIFNRTCBcImRpc3RpbmN0XCIga2V5d29yZDogd2hlbiBlbmFibGVkXG4qICAgaW4gYSBxdWVyeSB3aXRoIHRoZSBkaXN0aW5jdD0xIHBhcmFtZXRlcixcbiogICBhbGwgaGl0cyBjb250YWluaW5nIGEgZHVwbGljYXRlIHZhbHVlIGZvciB0aGUgYXR0cmlidXRlRm9yRGlzdGluY3QgYXR0cmlidXRlIGFyZSByZW1vdmVkIGZyb20gcmVzdWx0cy5cbiogICBGb3IgZXhhbXBsZSwgaWYgdGhlIGNob3NlbiBhdHRyaWJ1dGUgaXMgc2hvd19uYW1lIGFuZCBzZXZlcmFsIGhpdHMgaGF2ZVxuKiAgIHRoZSBzYW1lIHZhbHVlIGZvciBzaG93X25hbWUsIHRoZW4gb25seSB0aGUgYmVzdFxuKiAgIG9uZSBpcyBrZXB0IGFuZCBvdGhlcnMgYXJlIHJlbW92ZWQuXG4qIC0gcmVzdHJpY3RTZWFyY2hhYmxlQXR0cmlidXRlczogTGlzdCBvZiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHVzZSBmb3JcbiogdGV4dHVhbCBzZWFyY2ggKG11c3QgYmUgYSBzdWJzZXQgb2YgdGhlIGF0dHJpYnV0ZXNUb0luZGV4IGluZGV4IHNldHRpbmcpXG4qIGVpdGhlciBjb21tYSBzZXBhcmF0ZWQgb3IgYXMgYW4gYXJyYXlcbiogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpLiBJZiBmYWxzZSwgdGhlIGNvbnRlbnQgY29udGFpbnMgdGhlIGVycm9yLlxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiByZXN1bHRzLlxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuc2VhcmNoID0gYnVpbGRTZWFyY2hNZXRob2QoJ3F1ZXJ5Jyk7XG5cbi8qXG4qIC0tIEJFVEEgLS1cbiogU2VhcmNoIGEgcmVjb3JkIHNpbWlsYXIgdG8gdGhlIHF1ZXJ5IGluc2lkZSB0aGUgaW5kZXggdXNpbmcgWE1MSHR0cFJlcXVlc3QgcmVxdWVzdCAoVXNpbmcgYSBQT1NUIHF1ZXJ5IHRvXG4qIG1pbmltaXplIG51bWJlciBvZiBPUFRJT05TIHF1ZXJpZXM6IENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nKS5cbipcbiogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV0gdGhlIHNpbWlsYXIgcXVlcnlcbiogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAob3B0aW9uYWwpIGlmIHNldCwgY29udGFpbnMgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycy5cbiogICBBbGwgc2VhcmNoIHBhcmFtZXRlcnMgYXJlIHN1cHBvcnRlZCAoc2VlIHNlYXJjaCBmdW5jdGlvbiksIHJlc3RyaWN0U2VhcmNoYWJsZUF0dHJpYnV0ZXMgYW5kIGZhY2V0RmlsdGVyc1xuKiAgIGFyZSB0aGUgdHdvIG1vc3QgdXNlZnVsIHRvIHJlc3RyaWN0IHRoZSBzaW1pbGFyIHJlc3VsdHMgYW5kIGdldCBtb3JlIHJlbGV2YW50IGNvbnRlbnRcbiovXG5JbmRleENvcmUucHJvdG90eXBlLnNpbWlsYXJTZWFyY2ggPSBidWlsZFNlYXJjaE1ldGhvZCgnc2ltaWxhclF1ZXJ5Jyk7XG5cbi8qXG4qIEJyb3dzZSBpbmRleCBjb250ZW50LiBUaGUgcmVzcG9uc2UgY29udGVudCB3aWxsIGhhdmUgYSBgY3Vyc29yYCBwcm9wZXJ0eSB0aGF0IHlvdSBjYW4gdXNlXG4qIHRvIGJyb3dzZSBzdWJzZXF1ZW50IHBhZ2VzIGZvciB0aGlzIHF1ZXJ5LiBVc2UgYGluZGV4LmJyb3dzZUZyb20oY3Vyc29yKWAgd2hlbiB5b3Ugd2FudC5cbipcbiogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGZ1bGwgdGV4dCBxdWVyeVxuKiBAcGFyYW0ge09iamVjdH0gW3F1ZXJ5UGFyYW1ldGVyc10gLSBBbnkgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlclxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGJyb3dzZSByZXN1bHRcbiogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4qIEBleGFtcGxlXG4qIGluZGV4LmJyb3dzZSgnY29vbCBzb25ncycsIHtcbiogICB0YWdGaWx0ZXJzOiAncHVibGljLGNvbW1lbnRzJyxcbiogICBoaXRzUGVyUGFnZTogNTAwXG4qIH0sIGNhbGxiYWNrKTtcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0Jyb3dzZXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5icm93c2UgPSBmdW5jdGlvbihxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzLCBjYWxsYmFjaykge1xuICB2YXIgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlLmpzJyk7XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICB2YXIgcGFnZTtcbiAgdmFyIGhpdHNQZXJQYWdlO1xuXG4gIC8vIHdlIGNoZWNrIHZhcmlhZGljIGNhbGxzIHRoYXQgYXJlIG5vdCB0aGUgb25lIGRlZmluZWRcbiAgLy8gLmJyb3dzZSgpLy5icm93c2UoZm4pXG4gIC8vID0+IHBhZ2UgPSAwXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhZ2UgPSAwO1xuICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgLy8gLmJyb3dzZSgyKS8uYnJvd3NlKDIsIDEwKS8uYnJvd3NlKDIsIGZuKS8uYnJvd3NlKDIsIDEwLCBmbilcbiAgICBwYWdlID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgaGl0c1BlclBhZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGhpdHNQZXJQYWdlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgICBxdWVyeVBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyAuYnJvd3NlKHF1ZXJ5UGFyYW1ldGVycykvLmJyb3dzZShxdWVyeVBhcmFtZXRlcnMsIGNiKVxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcXVlcnlQYXJhbWV0ZXJzID0gYXJndW1lbnRzWzBdO1xuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAuYnJvd3NlKHF1ZXJ5LCBjYilcbiAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICBxdWVyeVBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBvdGhlcndpc2UgaXQncyBhIC5icm93c2UocXVlcnkpLy5icm93c2UocXVlcnksIHF1ZXJ5UGFyYW1ldGVycykvLmJyb3dzZShxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzLCBjYilcblxuICAvLyBnZXQgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlcnMgY29tYmluaW5nIHZhcmlvdXMgcG9zc2libGUgY2FsbHNcbiAgLy8gdG8gLmJyb3dzZSgpO1xuICBxdWVyeVBhcmFtZXRlcnMgPSBtZXJnZSh7fSwgcXVlcnlQYXJhbWV0ZXJzIHx8IHt9LCB7XG4gICAgcGFnZTogcGFnZSxcbiAgICBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UsXG4gICAgcXVlcnk6IHF1ZXJ5XG4gIH0pO1xuXG4gIHZhciBwYXJhbXMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMocXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvYnJvd3NlJyxcbiAgICBib2R5OiB7cGFyYW1zOiBwYXJhbXN9LFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogQ29udGludWUgYnJvd3NpbmcgZnJvbSBhIHByZXZpb3VzIHBvc2l0aW9uIChjdXJzb3IpLCBvYnRhaW5lZCB2aWEgYSBjYWxsIHRvIGAuYnJvd3NlKClgLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgZnVsbCB0ZXh0IHF1ZXJ5XG4qIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbWV0ZXJzXSAtIEFueSBzZWFyY2ggcXVlcnkgcGFyYW1ldGVyXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgYnJvd3NlIHJlc3VsdFxuKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiogQGV4YW1wbGVcbiogaW5kZXguYnJvd3NlRnJvbSgnMTRsa2ZzYWtsMzInLCBjYWxsYmFjayk7XG4qIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNCcm93c2V8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuYnJvd3NlRnJvbSA9IGZ1bmN0aW9uKGN1cnNvciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9icm93c2UnLFxuICAgIGJvZHk6IHtjdXJzb3I6IGN1cnNvcn0sXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBTZWFyY2ggZm9yIGZhY2V0IHZhbHVlc1xuKiBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdC1hcGkvc2VhcmNoI3NlYXJjaC1mb3ItZmFjZXQtdmFsdWVzXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjZXROYW1lIEZhY2V0IG5hbWUsIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZWFyY2ggZm9yIHZhbHVlcyBpbi5cbiogTXVzdCBiZSBkZWNsYXJlZCBhcyBhIGZhY2V0XG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjZXRRdWVyeSBRdWVyeSBmb3IgdGhlIGZhY2V0IHNlYXJjaFxuKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy4qXSBBbnkgc2VhcmNoIHBhcmFtZXRlciBvZiBBbGdvbGlhLFxuKiBzZWUgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2FwaS1jbGllbnQvamF2YXNjcmlwdC9zZWFyY2gjc2VhcmNoLXBhcmFtZXRlcnNcbiogUGFnaW5hdGlvbiBpcyBub3Qgc3VwcG9ydGVkLiBUaGUgcGFnZSBhbmQgaGl0c1BlclBhZ2UgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5zZWFyY2hGb3JGYWNldFZhbHVlcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpO1xuICB2YXIgb21pdCA9IHJlcXVpcmUoJy4vb21pdC5qcycpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LnNlYXJjaEZvckZhY2V0VmFsdWVzKHtmYWNldE5hbWUsIGZhY2V0UXVlcnksIC4uLnBhcmFtc31bLCBjYWxsYmFja10pJztcblxuICBpZiAocGFyYW1zLmZhY2V0TmFtZSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5mYWNldFF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGZhY2V0TmFtZSA9IHBhcmFtcy5mYWNldE5hbWU7XG4gIHZhciBmaWx0ZXJlZFBhcmFtcyA9IG9taXQoY2xvbmUocGFyYW1zKSwgZnVuY3Rpb24oa2V5TmFtZSkge1xuICAgIHJldHVybiBrZXlOYW1lID09PSAnZmFjZXROYW1lJztcbiAgfSk7XG4gIHZhciBzZWFyY2hQYXJhbWV0ZXJzID0gdGhpcy5hcy5fZ2V0U2VhcmNoUGFyYW1zKGZpbHRlcmVkUGFyYW1zLCAnJyk7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgK1xuICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvZmFjZXRzLycgKyBlbmNvZGVVUklDb21wb25lbnQoZmFjZXROYW1lKSArICcvcXVlcnknLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgYm9keToge3BhcmFtczogc2VhcmNoUGFyYW1ldGVyc30sXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXhDb3JlLnByb3RvdHlwZS5zZWFyY2hGYWNldCA9IGRlcHJlY2F0ZShmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnNlYXJjaEZvckZhY2V0VmFsdWVzKHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoXG4gICdpbmRleC5zZWFyY2hGYWNldChwYXJhbXNbLCBjYWxsYmFja10pJyxcbiAgJ2luZGV4LnNlYXJjaEZvckZhY2V0VmFsdWVzKHBhcmFtc1ssIGNhbGxiYWNrXSknXG4pKTtcblxuSW5kZXhDb3JlLnByb3RvdHlwZS5fc2VhcmNoID0gZnVuY3Rpb24ocGFyYW1zLCB1cmwsIGNhbGxiYWNrLCBhZGRpdGlvbmFsVUEpIHtcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6IHVybCB8fCAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcXVlcnknLFxuICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc30sXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBmYWxsYmFjazoge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSksXG4gICAgICBib2R5OiB7cGFyYW1zOiBwYXJhbXN9XG4gICAgfSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgYWRkaXRpb25hbFVBOiBhZGRpdGlvbmFsVUFcbiAgfSk7XG59O1xuXG4vKlxuKiBHZXQgYW4gb2JqZWN0IGZyb20gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gb2JqZWN0SUQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBvYmplY3QgdG8gcmV0cmlldmVcbiogQHBhcmFtIGF0dHJzIChvcHRpb25hbCkgaWYgc2V0LCBjb250YWlucyB0aGUgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIHJldHJpZXZlXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIG9iamVjdCB0byByZXRyaWV2ZSBvciB0aGUgZXJyb3IgbWVzc2FnZSBpZiBhIGZhaWx1cmUgb2NjdXJlZFxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuZ2V0T2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0SUQsIGF0dHJzLCBjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBhdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYXR0cnM7XG4gICAgYXR0cnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgcGFyYW1zID0gJyc7XG4gIGlmIChhdHRycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zID0gJz9hdHRyaWJ1dGVzPSc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcGFyYW1zICs9ICcsJztcbiAgICAgIH1cbiAgICAgIHBhcmFtcyArPSBhdHRyc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpICsgcGFyYW1zLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogR2V0IHNldmVyYWwgb2JqZWN0cyBmcm9tIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIG9iamVjdElEcyB0aGUgYXJyYXkgb2YgdW5pcXVlIGlkZW50aWZpZXIgb2Ygb2JqZWN0cyB0byByZXRyaWV2ZVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuZ2V0T2JqZWN0cyA9IGZ1bmN0aW9uKG9iamVjdElEcywgYXR0cmlidXRlc1RvUmV0cmlldmUsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcblxuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LmdldE9iamVjdHMoYXJyYXlPZk9iamVjdElEc1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvYmplY3RJRHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGF0dHJpYnV0ZXNUb1JldHJpZXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZTtcbiAgICBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBib2R5ID0ge1xuICAgIHJlcXVlc3RzOiBtYXAob2JqZWN0SURzLCBmdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChvYmplY3RJRCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgIGluZGV4TmFtZTogaW5kZXhPYmouaW5kZXhOYW1lLFxuICAgICAgICBvYmplY3RJRDogb2JqZWN0SURcbiAgICAgIH07XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzVG9SZXRyaWV2ZSkge1xuICAgICAgICByZXF1ZXN0LmF0dHJpYnV0ZXNUb1JldHJpZXZlID0gYXR0cmlidXRlc1RvUmV0cmlldmUuam9pbignLCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9KVxuICB9O1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8qL29iamVjdHMnLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgYm9keTogYm9keSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleENvcmUucHJvdG90eXBlLmFzID0gbnVsbDtcbkluZGV4Q29yZS5wcm90b3R5cGUuaW5kZXhOYW1lID0gbnVsbDtcbkluZGV4Q29yZS5wcm90b3R5cGUudHlwZUFoZWFkQXJncyA9IG51bGw7XG5JbmRleENvcmUucHJvdG90eXBlLnR5cGVBaGVhZFZhbHVlT3B0aW9uID0gbnVsbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhDb3JlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBidWlsZFNlYXJjaE1ldGhvZDtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzLmpzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlYXJjaCBtZXRob2QgdG8gYmUgdXNlZCBpbiBjbGllbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlQYXJhbSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIHRoZSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgdXJsXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gdGhlIHNlYXJjaCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gYnVpbGRTZWFyY2hNZXRob2QocXVlcnlQYXJhbSwgdXJsKSB7XG4gIC8qKlxuICAgKiBUaGUgc2VhcmNoIG1ldGhvZC4gUHJlcGFyZXMgdGhlIGRhdGEgYW5kIHNlbmQgdGhlIHF1ZXJ5IHRvIEFsZ29saWEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgc3RyaW5nIHVzZWQgZm9yIHF1ZXJ5IHNlYXJjaFxuICAgKiBAcGFyYW0ge29iamVjdH0gYXJncyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gc2VuZCB3aXRoIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0aGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGNsaWVudCBnZXRzIHRoZSBhbnN3ZXJcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfFByb21pc2V9IElmIHRoZSBjYWxsYmFjayBpcyBub3QgcHJvdmlkZWQgdGhlbiB0aGlzIG1ldGhvZHMgcmV0dXJucyBhIFByb21pc2VcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2gocXVlcnksIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgLy8gd2FybiBWMiB1c2VycyBvbiBob3cgdG8gc2VhcmNoXG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgfHxcbiAgICAgIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIC5zZWFyY2gocXVlcnksIHBhcmFtcywgY2IpXG4gICAgICAvLyAuc2VhcmNoKGNiLCBwYXJhbXMpXG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcignaW5kZXguc2VhcmNoIHVzYWdlIGlzIGluZGV4LnNlYXJjaChxdWVyeSwgcGFyYW1zLCBjYiknKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemluZyB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2FnZSA6IC5zZWFyY2goKSwgLnNlYXJjaChjYilcbiAgICAgIGNhbGxiYWNrID0gcXVlcnk7XG4gICAgICBxdWVyeSA9ICcnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVXNhZ2UgOiAuc2VhcmNoKHF1ZXJ5L2FyZ3MpLCAuc2VhcmNoKHF1ZXJ5LCBjYilcbiAgICAgIGNhbGxiYWNrID0gYXJncztcbiAgICAgIGFyZ3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSAzIGFyZ3VtZW50cyB3aXRoIHZhbHVlc1xuXG4gICAgLy8gVXNhZ2UgOiAuc2VhcmNoKGFyZ3MpIC8vIGNhcmVmdWw6IHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnICYmIHF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICBhcmdzID0gcXVlcnk7XG4gICAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQgfHwgcXVlcnkgPT09IG51bGwpIHsgLy8gLnNlYXJjaCh1bmRlZmluZWQvbnVsbClcbiAgICAgIHF1ZXJ5ID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gICAgaWYgKHF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcyArPSBxdWVyeVBhcmFtICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KTtcbiAgICB9XG5cbiAgICB2YXIgYWRkaXRpb25hbFVBO1xuICAgIGlmIChhcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChhcmdzLmFkZGl0aW9uYWxVQSkge1xuICAgICAgICBhZGRpdGlvbmFsVUEgPSBhcmdzLmFkZGl0aW9uYWxVQTtcbiAgICAgICAgZGVsZXRlIGFyZ3MuYWRkaXRpb25hbFVBO1xuICAgICAgfVxuICAgICAgLy8gYF9nZXRTZWFyY2hQYXJhbXNgIHdpbGwgYXVnbWVudCBwYXJhbXMsIGRvIG5vdCBiZSBmb29sZWQgYnkgdGhlID0gdmVyc3VzICs9IGZyb20gcHJldmlvdXMgaWZcbiAgICAgIHBhcmFtcyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhhcmdzLCBwYXJhbXMpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaChwYXJhbXMsIHVybCwgY2FsbGJhY2ssIGFkZGl0aW9uYWxVQSk7XG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2J1aWxkU2VhcmNoTWV0aG9kLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgaG9zdHMgb3VyIGVycm9yIGRlZmluaXRpb25zXG4vLyBXZSB1c2UgY3VzdG9tIGVycm9yIFwidHlwZXNcIiBzbyB0aGF0IHdlIGNhbiBhY3Qgb24gdGhlbSB3aGVuIHdlIG5lZWQgaXRcbi8vIGUuZy46IGlmIGVycm9yIGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OIHRoZW4uLlxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiBBbGdvbGlhU2VhcmNoRXJyb3IobWVzc2FnZSwgZXh0cmFQcm9wZXJ0aWVzKSB7XG4gIHZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG4gIHZhciBlcnJvciA9IHRoaXM7XG5cbiAgLy8gdHJ5IHRvIGdldCBhIHN0YWNrdHJhY2VcbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnQ2Fubm90IGdldCBhIHN0YWNrdHJhY2UsIGJyb3dzZXIgaXMgdG9vIG9sZCc7XG4gIH1cblxuICB0aGlzLm5hbWUgPSAnQWxnb2xpYVNlYXJjaEVycm9yJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG5cbiAgaWYgKGV4dHJhUHJvcGVydGllcykge1xuICAgIGZvckVhY2goZXh0cmFQcm9wZXJ0aWVzLCBmdW5jdGlvbiBhZGRUb0Vycm9yT2JqZWN0KHZhbHVlLCBrZXkpIHtcbiAgICAgIGVycm9yW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxufVxuXG5pbmhlcml0cyhBbGdvbGlhU2VhcmNoRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXJyb3IobmFtZSwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBBbGdvbGlhU2VhcmNoQ3VzdG9tRXJyb3IoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgLy8gY3VzdG9tIG1lc3NhZ2Ugbm90IHNldCwgdXNlIGRlZmF1bHRcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBhcmdzLnVuc2hpZnQobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgQWxnb2xpYVNlYXJjaEVycm9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHRoaXMubmFtZSA9ICdBbGdvbGlhU2VhcmNoJyArIG5hbWUgKyAnRXJyb3InO1xuICB9XG5cbiAgaW5oZXJpdHMoQWxnb2xpYVNlYXJjaEN1c3RvbUVycm9yLCBBbGdvbGlhU2VhcmNoRXJyb3IpO1xuXG4gIHJldHVybiBBbGdvbGlhU2VhcmNoQ3VzdG9tRXJyb3I7XG59XG5cbi8vIGxhdGUgZXhwb3J0cyB0byBsZXQgdmFyaW91cyBmbiBkZWZzIGFuZCBpbmhlcml0cyB0YWtlIHBsYWNlXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWxnb2xpYVNlYXJjaEVycm9yOiBBbGdvbGlhU2VhcmNoRXJyb3IsXG4gIFVucGFyc2FibGVKU09OOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnVW5wYXJzYWJsZUpTT04nLFxuICAgICdDb3VsZCBub3QgcGFyc2UgdGhlIGluY29taW5nIHJlc3BvbnNlIGFzIEpTT04sIHNlZSBlcnIubW9yZSBmb3IgZGV0YWlscydcbiAgKSxcbiAgUmVxdWVzdFRpbWVvdXQ6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdSZXF1ZXN0VGltZW91dCcsXG4gICAgJ1JlcXVlc3QgdGltZWRvdXQgYmVmb3JlIGdldHRpbmcgYSByZXNwb25zZSdcbiAgKSxcbiAgTmV0d29yazogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ05ldHdvcmsnLFxuICAgICdOZXR3b3JrIGlzc3VlLCBzZWUgZXJyLm1vcmUgZm9yIGRldGFpbHMnXG4gICksXG4gIEpTT05QU2NyaXB0RmFpbDogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ0pTT05QU2NyaXB0RmFpbCcsXG4gICAgJzxzY3JpcHQ+IHdhcyBsb2FkZWQgYnV0IGRpZCBub3QgY2FsbCBvdXIgcHJvdmlkZWQgY2FsbGJhY2snXG4gICksXG4gIEpTT05QU2NyaXB0RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdKU09OUFNjcmlwdEVycm9yJyxcbiAgICAnPHNjcmlwdD4gdW5hYmxlIHRvIGxvYWQgZHVlIHRvIGFuIGBlcnJvcmAgZXZlbnQgb24gaXQnXG4gICksXG4gIFVua25vd246IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdVbmtub3duJyxcbiAgICAnVW5rbm93biBlcnJvciBvY2N1cmVkJ1xuICApXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9lcnJvcnMuanMiLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mb3JlYWNoL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2RlcHJlY2F0ZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVwcmVjYXRlZE1lc3NhZ2UocHJldmlvdXNVc2FnZSwgbmV3VXNhZ2UpIHtcbiAgdmFyIGdpdGh1YkFuY2hvckxpbmsgPSBwcmV2aW91c1VzYWdlLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvW1xcLlxcKFxcKV0vZywgJycpO1xuXG4gIHJldHVybiAnYWxnb2xpYXNlYXJjaDogYCcgKyBwcmV2aW91c1VzYWdlICsgJ2Agd2FzIHJlcGxhY2VkIGJ5IGAnICsgbmV3VXNhZ2UgK1xuICAgICdgLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWphdmFzY3JpcHQvd2lraS9EZXByZWNhdGVkIycgKyBnaXRodWJBbmNob3JMaW5rO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlZE1lc3NhZ2UuanMiLCJ2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZShkZXN0aW5hdGlvbi8qICwgc291cmNlcyAqLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgZm9yZWFjaChzb3VyY2VzLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXlOYW1lIGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXlOYW1lKSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uW2tleU5hbWVdID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc291cmNlW2tleU5hbWVdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW2tleU5hbWVdID0gbWVyZ2Uoe30sIGRlc3RpbmF0aW9uW2tleU5hbWVdLCBzb3VyY2Vba2V5TmFtZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVtrZXlOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25ba2V5TmFtZV0gPSBzb3VyY2Vba2V5TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL21lcmdlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9jbG9uZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb21pdChvYmosIHRlc3QpIHtcbiAgdmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xuICB2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxuICB2YXIgZmlsdGVyZWQgPSB7fTtcblxuICBmb3JlYWNoKGtleXMob2JqKSwgZnVuY3Rpb24gZG9GaWx0ZXIoa2V5TmFtZSkge1xuICAgIGlmICh0ZXN0KGtleU5hbWUpICE9PSB0cnVlKSB7XG4gICAgICBmaWx0ZXJlZFtrZXlOYW1lXSA9IG9ialtrZXlOYW1lXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmaWx0ZXJlZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL29taXQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbnZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xudmFyIGRvbnRFbnVtcyA9IFtcblx0J3RvU3RyaW5nJyxcblx0J3RvTG9jYWxlU3RyaW5nJyxcblx0J3ZhbHVlT2YnLFxuXHQnaGFzT3duUHJvcGVydHknLFxuXHQnaXNQcm90b3R5cGVPZicsXG5cdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdCdjb25zdHJ1Y3Rvcidcbl07XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xufTtcbnZhciBleGNsdWRlZEtleXMgPSB7XG5cdCRjb25zb2xlOiB0cnVlLFxuXHQkZXh0ZXJuYWw6IHRydWUsXG5cdCRmcmFtZTogdHJ1ZSxcblx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0JGZyYW1lczogdHJ1ZSxcblx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdCRwYXJlbnQ6IHRydWUsXG5cdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHQkc2Nyb2xsWDogdHJ1ZSxcblx0JHNjcm9sbFk6IHRydWUsXG5cdCRzZWxmOiB0cnVlLFxuXHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdCR3aW5kb3c6IHRydWVcbn07XG52YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn0oKSk7XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdHZhciB0aGVLZXlzID0gW107XG5cblx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdH1cblxuXHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoZUtleXM7XG59O1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHRyZXR1cm4gKE9iamVjdC5rZXlzKGFyZ3VtZW50cykgfHwgJycpLmxlbmd0aCA9PT0gMjtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdHZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL34vb2JqZWN0LWtleXMvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9+L29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvfi9pc2FycmF5L2luZGV4LmpzIiwidmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgdmFyIG5ld0FyciA9IFtdO1xuICBmb3JlYWNoKGFyciwgZnVuY3Rpb24oaXRlbSwgaXRlbUluZGV4KSB7XG4gICAgbmV3QXJyLnB1c2goZm4oaXRlbSwgaXRlbUluZGV4LCBhcnIpKTtcbiAgfSk7XG4gIHJldHVybiBuZXdBcnI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tYXAuanMiLCIvLyBQYXJzZSBjbG91ZCBkb2VzIG5vdCBzdXBwb3J0cyBzZXRUaW1lb3V0XG4vLyBXZSBkbyBub3Qgc3RvcmUgYSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBpbiB0aGUgY2xpZW50IGV2ZXJ5dGltZVxuLy8gV2Ugb25seSBmYWxsYmFjayB0byBhIGZha2Ugc2V0VGltZW91dCB3aGVuIG5vdCBhdmFpbGFibGVcbi8vIHNldFRpbWVvdXQgY2Fubm90IGJlIG92ZXJyaWRlIGdsb2JhbGx5IHNhZGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4aXRQcm9taXNlKGZuLCBfc2V0VGltZW91dCkge1xuICBfc2V0VGltZW91dChmbiwgMCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9leGl0UHJvbWlzZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBpcyB0aGUgb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBgaW5kZXguYnJvd3NlQWxsKClgIG1ldGhvZFxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4QnJvd3NlcjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbmZ1bmN0aW9uIEluZGV4QnJvd3NlcigpIHtcbn1cblxuaW5oZXJpdHMoSW5kZXhCcm93c2VyLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmRleEJyb3dzZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gIHRoaXMuX2NsZWFuKCk7XG59O1xuXG5JbmRleEJyb3dzZXIucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgdGhpcy5fY2xlYW4oKTtcbn07XG5cbkluZGV4QnJvd3Nlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLl9jbGVhbigpO1xufTtcblxuSW5kZXhCcm93c2VyLnByb3RvdHlwZS5fcmVzdWx0ID0gZnVuY3Rpb24oY29udGVudCkge1xuICB0aGlzLmVtaXQoJ3Jlc3VsdCcsIGNvbnRlbnQpO1xufTtcblxuSW5kZXhCcm93c2VyLnByb3RvdHlwZS5fY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3N0b3AnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3Jlc3VsdCcpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhCcm93c2VyLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9ldmVudHMvZXZlbnRzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBBbGdvbGlhU2VhcmNoQ29yZTtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgZXhpdFByb21pc2UgPSByZXF1aXJlKCcuL2V4aXRQcm9taXNlLmpzJyk7XG52YXIgSW5kZXhDb3JlID0gcmVxdWlyZSgnLi9JbmRleENvcmUuanMnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUuanMnKTtcblxuLy8gV2Ugd2lsbCBhbHdheXMgcHV0IHRoZSBBUEkgS0VZIGluIHRoZSBKU09OIGJvZHkgaW4gY2FzZSBvZiB0b28gbG9uZyBBUEkgS0VZLFxuLy8gdG8gYXZvaWQgcXVlcnkgc3RyaW5nIGJlaW5nIHRvbyBsb25nIGFuZCBmYWlsaW5nIGluIHZhcmlvdXMgY29uZGl0aW9ucyAob3VyIHNlcnZlciBsaW1pdCwgYnJvd3NlciBsaW1pdCxcbi8vIHByb3hpZXMgbGltaXQpXG52YXIgTUFYX0FQSV9LRVlfTEVOR1RIID0gNTAwO1xudmFyIFJFU0VUX0FQUF9EQVRBX1RJTUVSID1cbiAgcHJvY2Vzcy5lbnYuUkVTRVRfQVBQX0RBVEFfVElNRVIgJiYgcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVTRVRfQVBQX0RBVEFfVElNRVIsIDEwKSB8fFxuICA2MCAqIDIgKiAxMDAwOyAvLyBhZnRlciAyIG1pbnV0ZXMgcmVzZXQgdG8gZmlyc3QgaG9zdFxuXG4vKlxuICogQWxnb2xpYSBTZWFyY2ggbGlicmFyeSBpbml0aWFsaXphdGlvblxuICogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFwcGxpY2F0aW9uSUQgLSBZb3VyIGFwcGxpY2F0aW9uSUQsIGZvdW5kIGluIHlvdXIgZGFzaGJvYXJkXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5IC0gWW91ciBBUEkga2V5LCBmb3VuZCBpbiB5b3VyIGRhc2hib2FyZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MjAwMF0gLSBUaGUgcmVxdWVzdCB0aW1lb3V0IHNldCBpbiBtaWxsaXNlY29uZHMsXG4gKiBhbm90aGVyIHJlcXVlc3Qgd2lsbCBiZSBpc3N1ZWQgYWZ0ZXIgdGhpcyB0aW1lb3V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJvdG9jb2w9J2h0dHA6J10gLSBUaGUgcHJvdG9jb2wgdXNlZCB0byBxdWVyeSBBbGdvbGlhIFNlYXJjaCBBUEkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgdG8gJ2h0dHBzOicgdG8gZm9yY2UgdXNpbmcgaHR0cHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHRvIGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sIGluIGJyb3dzZXJzXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gW29wdHMuaG9zdHM9e1xuICogICAgICAgICAgIHJlYWQ6IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLWRzbi5hbGdvbGlhLm5ldCddLmNvbmNhdChbXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTEuYWxnb2xpYW5ldC5jb20nLFxuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0yLmFsZ29saWFuZXQuY29tJyxcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMy5hbGdvbGlhbmV0LmNvbSddXG4gKiAgICAgICAgICAgXSksXG4gKiAgICAgICAgICAgd3JpdGU6IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLmFsZ29saWEubmV0J10uY29uY2F0KFtcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMS5hbGdvbGlhbmV0LmNvbScsXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTIuYWxnb2xpYW5ldC5jb20nLFxuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0zLmFsZ29saWFuZXQuY29tJ11cbiAqICAgICAgICAgICBdKSAtIFRoZSBob3N0cyB0byB1c2UgZm9yIEFsZ29saWEgU2VhcmNoIEFQSS5cbiAqICAgICAgICAgICBJZiB5b3UgcHJvdmlkZSB0aGVtLCB5b3Ugd2lsbCBsZXNzIGJlbmVmaXQgZnJvbSBvdXIgSEEgaW1wbGVtZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gQWxnb2xpYVNlYXJjaENvcmUoYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSB7XG4gIHZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2FsZ29saWFzZWFyY2gnKTtcblxuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcblxuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGFsZ29saWFzZWFyY2goYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSc7XG5cbiAgaWYgKG9wdHMuX2FsbG93RW1wdHlDcmVkZW50aWFscyAhPT0gdHJ1ZSAmJiAhYXBwbGljYXRpb25JRCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBhcHBsaWNhdGlvbiBJRC4gJyArIHVzYWdlKTtcbiAgfVxuXG4gIGlmIChvcHRzLl9hbGxvd0VtcHR5Q3JlZGVudGlhbHMgIT09IHRydWUgJiYgIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBBUEkga2V5LiAnICsgdXNhZ2UpO1xuICB9XG5cbiAgdGhpcy5hcHBsaWNhdGlvbklEID0gYXBwbGljYXRpb25JRDtcbiAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG5cbiAgdGhpcy5ob3N0cyA9IHtcbiAgICByZWFkOiBbXSxcbiAgICB3cml0ZTogW11cbiAgfTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8ICdodHRwczonO1xuICB0aGlzLl90aW1lb3V0cyA9IG9wdHMudGltZW91dHMgfHwge1xuICAgIGNvbm5lY3Q6IDEgKiAxMDAwLCAvLyA1MDBtcyBjb25uZWN0IGlzIEdQUlMgbGF0ZW5jeVxuICAgIHJlYWQ6IDIgKiAxMDAwLFxuICAgIHdyaXRlOiAzMCAqIDEwMDBcbiAgfTtcblxuICAvLyBiYWNrd2FyZCBjb21wYXQsIGlmIG9wdHMudGltZW91dCBpcyBwYXNzZWQsIHdlIHVzZSBpdCB0byBjb25maWd1cmUgYWxsIHRpbWVvdXRzIGxpa2UgYmVmb3JlXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICB0aGlzLl90aW1lb3V0cy5jb25uZWN0ID0gdGhpcy5fdGltZW91dHMucmVhZCA9IHRoaXMuX3RpbWVvdXRzLndyaXRlID0gb3B0cy50aW1lb3V0O1xuICB9XG5cbiAgLy8gd2hpbGUgd2UgYWR2b2NhdGUgZm9yIGNvbG9uLWF0LXRoZS1lbmQgdmFsdWVzOiAnaHR0cDonIGZvciBgb3B0cy5wcm90b2NvbGBcbiAgLy8gd2UgYWxzbyBhY2NlcHQgYGh0dHBgIGFuZCBgaHR0cHNgLiBJdCdzIGEgY29tbW9uIGVycm9yLlxuICBpZiAoIS86JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICBwcm90b2NvbCA9IHByb3RvY29sICsgJzonO1xuICB9XG5cbiAgaWYgKG9wdHMucHJvdG9jb2wgIT09ICdodHRwOicgJiYgb3B0cy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcigncHJvdG9jb2wgbXVzdCBiZSBgaHR0cDpgIG9yIGBodHRwczpgICh3YXMgYCcgKyBvcHRzLnByb3RvY29sICsgJ2ApJyk7XG4gIH1cblxuICB0aGlzLl9jaGVja0FwcElkRGF0YSgpO1xuXG4gIGlmICghb3B0cy5ob3N0cykge1xuICAgIHZhciBkZWZhdWx0SG9zdHMgPSBtYXAodGhpcy5fc2h1ZmZsZVJlc3VsdCwgZnVuY3Rpb24oaG9zdE51bWJlcikge1xuICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uSUQgKyAnLScgKyBob3N0TnVtYmVyICsgJy5hbGdvbGlhbmV0LmNvbSc7XG4gICAgfSk7XG5cbiAgICAvLyBubyBob3N0cyBnaXZlbiwgY29tcHV0ZSBkZWZhdWx0c1xuICAgIHRoaXMuaG9zdHMucmVhZCA9IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLWRzbi5hbGdvbGlhLm5ldCddLmNvbmNhdChkZWZhdWx0SG9zdHMpO1xuICAgIHRoaXMuaG9zdHMud3JpdGUgPSBbdGhpcy5hcHBsaWNhdGlvbklEICsgJy5hbGdvbGlhLm5ldCddLmNvbmNhdChkZWZhdWx0SG9zdHMpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0cy5ob3N0cykpIHtcbiAgICAvLyB3aGVuIHBhc3NpbmcgY3VzdG9tIGhvc3RzLCB3ZSBuZWVkIHRvIGhhdmUgYSBkaWZmZXJlbnQgaG9zdCBpbmRleCBpZiB0aGUgbnVtYmVyXG4gICAgLy8gb2Ygd3JpdGUvcmVhZCBob3N0cyBhcmUgZGlmZmVyZW50LlxuICAgIHRoaXMuaG9zdHMucmVhZCA9IGNsb25lKG9wdHMuaG9zdHMpO1xuICAgIHRoaXMuaG9zdHMud3JpdGUgPSBjbG9uZShvcHRzLmhvc3RzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhvc3RzLnJlYWQgPSBjbG9uZShvcHRzLmhvc3RzLnJlYWQpO1xuICAgIHRoaXMuaG9zdHMud3JpdGUgPSBjbG9uZShvcHRzLmhvc3RzLndyaXRlKTtcbiAgfVxuXG4gIC8vIGFkZCBwcm90b2NvbCBhbmQgbG93ZXJjYXNlIGhvc3RzXG4gIHRoaXMuaG9zdHMucmVhZCA9IG1hcCh0aGlzLmhvc3RzLnJlYWQsIHByZXBhcmVIb3N0KHByb3RvY29sKSk7XG4gIHRoaXMuaG9zdHMud3JpdGUgPSBtYXAodGhpcy5ob3N0cy53cml0ZSwgcHJlcGFyZUhvc3QocHJvdG9jb2wpKTtcblxuICB0aGlzLmV4dHJhSGVhZGVycyA9IHt9O1xuXG4gIC8vIEluIHNvbWUgc2l0dWF0aW9ucyB5b3UgbWlnaHQgd2FudCB0byB3YXJtIHRoZSBjYWNoZVxuICB0aGlzLmNhY2hlID0gb3B0cy5fY2FjaGUgfHwge307XG5cbiAgdGhpcy5fdWEgPSBvcHRzLl91YTtcbiAgdGhpcy5fdXNlQ2FjaGUgPSBvcHRzLl91c2VDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuX2NhY2hlID8gdHJ1ZSA6IG9wdHMuX3VzZUNhY2hlO1xuICB0aGlzLl91c2VGYWxsYmFjayA9IG9wdHMudXNlRmFsbGJhY2sgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnVzZUZhbGxiYWNrO1xuXG4gIHRoaXMuX3NldFRpbWVvdXQgPSBvcHRzLl9zZXRUaW1lb3V0O1xuXG4gIGRlYnVnKCdpbml0IGRvbmUsICVqJywgdGhpcyk7XG59XG5cbi8qXG4gKiBHZXQgdGhlIGluZGV4IG9iamVjdCBpbml0aWFsaXplZFxuICpcbiAqIEBwYXJhbSBpbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXhcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIHdpdGggb25lIGFyZ3VtZW50ICh0aGUgSW5kZXggaW5zdGFuY2UpXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5pbml0SW5kZXggPSBmdW5jdGlvbihpbmRleE5hbWUpIHtcbiAgcmV0dXJuIG5ldyBJbmRleENvcmUodGhpcywgaW5kZXhOYW1lKTtcbn07XG5cbi8qKlxuKiBBZGQgYW4gZXh0cmEgZmllbGQgdG8gdGhlIEhUVFAgcmVxdWVzdFxuKlxuKiBAcGFyYW0gbmFtZSB0aGUgaGVhZGVyIGZpZWxkIG5hbWVcbiogQHBhcmFtIHZhbHVlIHRoZSBoZWFkZXIgZmllbGQgdmFsdWVcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0RXh0cmFIZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLmV4dHJhSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG59O1xuXG4vKipcbiogR2V0IHRoZSB2YWx1ZSBvZiBhbiBleHRyYSBIVFRQIGhlYWRlclxuKlxuKiBAcGFyYW0gbmFtZSB0aGUgaGVhZGVyIGZpZWxkIG5hbWVcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuZ2V0RXh0cmFIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmV4dHJhSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4qIFJlbW92ZSBhbiBleHRyYSBmaWVsZCBmcm9tIHRoZSBIVFRQIHJlcXVlc3RcbipcbiogQHBhcmFtIG5hbWUgdGhlIGhlYWRlciBmaWVsZCBuYW1lXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnVuc2V0RXh0cmFIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLmV4dHJhSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4qIEF1Z21lbnQgc2VudCB4LWFsZ29saWEtYWdlbnQgd2l0aCBtb3JlIGRhdGEsIGVhY2ggYWdlbnQgcGFydFxuKiBpcyBhdXRvbWF0aWNhbGx5IHNlcGFyYXRlZCBmcm9tIHRoZSBvdGhlcnMgYnkgYSBzZW1pY29sb247XG4qXG4qIEBwYXJhbSBhbGdvbGlhQWdlbnQgdGhlIGFnZW50IHRvIGFkZFxuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5hZGRBbGdvbGlhQWdlbnQgPSBmdW5jdGlvbihhbGdvbGlhQWdlbnQpIHtcbiAgaWYgKHRoaXMuX3VhLmluZGV4T2YoJzsnICsgYWxnb2xpYUFnZW50KSA9PT0gLTEpIHtcbiAgICB0aGlzLl91YSArPSAnOycgKyBhbGdvbGlhQWdlbnQ7XG4gIH1cbn07XG5cbi8qXG4gKiBXcmFwcGVyIHRoYXQgdHJ5IGFsbCBob3N0cyB0byBtYXhpbWl6ZSB0aGUgcXVhbGl0eSBvZiBzZXJ2aWNlXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fanNvblJlcXVlc3QgPSBmdW5jdGlvbihpbml0aWFsT3B0cykge1xuICB0aGlzLl9jaGVja0FwcElkRGF0YSgpO1xuXG4gIHZhciByZXF1ZXN0RGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdhbGdvbGlhc2VhcmNoOicgKyBpbml0aWFsT3B0cy51cmwpO1xuXG4gIHZhciBib2R5O1xuICB2YXIgYWRkaXRpb25hbFVBID0gaW5pdGlhbE9wdHMuYWRkaXRpb25hbFVBIHx8ICcnO1xuICB2YXIgY2FjaGUgPSBpbml0aWFsT3B0cy5jYWNoZTtcbiAgdmFyIGNsaWVudCA9IHRoaXM7XG4gIHZhciB0cmllcyA9IDA7XG4gIHZhciB1c2luZ0ZhbGxiYWNrID0gZmFsc2U7XG4gIHZhciBoYXNGYWxsYmFjayA9IGNsaWVudC5fdXNlRmFsbGJhY2sgJiYgY2xpZW50Ll9yZXF1ZXN0LmZhbGxiYWNrICYmIGluaXRpYWxPcHRzLmZhbGxiYWNrO1xuICB2YXIgaGVhZGVycztcblxuICBpZiAoXG4gICAgdGhpcy5hcGlLZXkubGVuZ3RoID4gTUFYX0FQSV9LRVlfTEVOR1RIICYmXG4gICAgaW5pdGlhbE9wdHMuYm9keSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGluaXRpYWxPcHRzLmJvZHkucGFyYW1zICE9PSB1bmRlZmluZWQgfHwgLy8gaW5kZXguc2VhcmNoKClcbiAgICBpbml0aWFsT3B0cy5ib2R5LnJlcXVlc3RzICE9PSB1bmRlZmluZWQpIC8vIGNsaWVudC5zZWFyY2goKVxuICApIHtcbiAgICBpbml0aWFsT3B0cy5ib2R5LmFwaUtleSA9IHRoaXMuYXBpS2V5O1xuICAgIGhlYWRlcnMgPSB0aGlzLl9jb21wdXRlUmVxdWVzdEhlYWRlcnMoYWRkaXRpb25hbFVBLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVycyA9IHRoaXMuX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyhhZGRpdGlvbmFsVUEpO1xuICB9XG5cbiAgaWYgKGluaXRpYWxPcHRzLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGJvZHkgPSBzYWZlSlNPTlN0cmluZ2lmeShpbml0aWFsT3B0cy5ib2R5KTtcbiAgfVxuXG4gIHJlcXVlc3REZWJ1ZygncmVxdWVzdCBzdGFydCcpO1xuICB2YXIgZGVidWdEYXRhID0gW107XG5cbiAgZnVuY3Rpb24gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cykge1xuICAgIGNsaWVudC5fY2hlY2tBcHBJZERhdGEoKTtcblxuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBjYWNoZUlEO1xuXG4gICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUpIHtcbiAgICAgIGNhY2hlSUQgPSBpbml0aWFsT3B0cy51cmw7XG4gICAgfVxuXG4gICAgLy8gYXMgd2Ugc29tZXRpbWUgdXNlIFBPU1QgcmVxdWVzdHMgdG8gcGFzcyBwYXJhbWV0ZXJzIChsaWtlIHF1ZXJ5PSdhYScpLFxuICAgIC8vIHRoZSBjYWNoZUlEIG11c3QgYWxzbyBpbmNsdWRlIHRoZSBib2R5IHRvIGJlIGRpZmZlcmVudCBiZXR3ZWVuIGNhbGxzXG4gICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUgJiYgYm9keSkge1xuICAgICAgY2FjaGVJRCArPSAnX2JvZHlfJyArIHJlcU9wdHMuYm9keTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgY2FjaGUgZXhpc3RlbmNlXG4gICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUgJiYgY2FjaGUgJiYgY2FjaGVbY2FjaGVJRF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERlYnVnKCdzZXJ2aW5nIHJlc3BvbnNlIGZyb20gY2FjaGUnKTtcbiAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UucmVzb2x2ZShKU09OLnBhcnNlKGNhY2hlW2NhY2hlSURdKSk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgcmVhY2hlZCBtYXggdHJpZXNcbiAgICBpZiAodHJpZXMgPj0gY2xpZW50Lmhvc3RzW2luaXRpYWxPcHRzLmhvc3RUeXBlXS5sZW5ndGgpIHtcbiAgICAgIGlmICghaGFzRmFsbGJhY2sgfHwgdXNpbmdGYWxsYmFjaykge1xuICAgICAgICByZXF1ZXN0RGVidWcoJ2NvdWxkIG5vdCBnZXQgYW55IHJlc3BvbnNlJyk7XG4gICAgICAgIC8vIHRoZW4gc3RvcFxuICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdChuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbm5lY3QgdG8gdGhlIEFsZ29saWFTZWFyY2ggQVBJLicgK1xuICAgICAgICAgICcgU2VuZCBhbiBlbWFpbCB0byBzdXBwb3J0QGFsZ29saWEuY29tIHRvIHJlcG9ydCBhbmQgcmVzb2x2ZSB0aGUgaXNzdWUuJyArXG4gICAgICAgICAgJyBBcHBsaWNhdGlvbiBpZCB3YXM6ICcgKyBjbGllbnQuYXBwbGljYXRpb25JRCwge2RlYnVnRGF0YTogZGVidWdEYXRhfVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdERlYnVnKCdzd2l0Y2hpbmcgdG8gZmFsbGJhY2snKTtcblxuICAgICAgLy8gbGV0J3MgdHJ5IHRoZSBmYWxsYmFjayBzdGFydGluZyBmcm9tIGhlcmVcbiAgICAgIHRyaWVzID0gMDtcblxuICAgICAgLy8gbWV0aG9kLCB1cmwgYW5kIGJvZHkgYXJlIGZhbGxiYWNrIGRlcGVuZGVudFxuICAgICAgcmVxT3B0cy5tZXRob2QgPSBpbml0aWFsT3B0cy5mYWxsYmFjay5tZXRob2Q7XG4gICAgICByZXFPcHRzLnVybCA9IGluaXRpYWxPcHRzLmZhbGxiYWNrLnVybDtcbiAgICAgIHJlcU9wdHMuanNvbkJvZHkgPSBpbml0aWFsT3B0cy5mYWxsYmFjay5ib2R5O1xuICAgICAgaWYgKHJlcU9wdHMuanNvbkJvZHkpIHtcbiAgICAgICAgcmVxT3B0cy5ib2R5ID0gc2FmZUpTT05TdHJpbmdpZnkocmVxT3B0cy5qc29uQm9keSk7XG4gICAgICB9XG4gICAgICAvLyByZS1jb21wdXRlIGhlYWRlcnMsIHRoZXkgY291bGQgYmUgb21pdHRpbmcgdGhlIEFQSSBLRVlcbiAgICAgIGhlYWRlcnMgPSBjbGllbnQuX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyhhZGRpdGlvbmFsVUEpO1xuXG4gICAgICByZXFPcHRzLnRpbWVvdXRzID0gY2xpZW50Ll9nZXRUaW1lb3V0c0ZvclJlcXVlc3QoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgY2xpZW50Ll9zZXRIb3N0SW5kZXhCeVR5cGUoMCwgaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgdXNpbmdGYWxsYmFjayA9IHRydWU7IC8vIHRoZSBjdXJyZW50IHJlcXVlc3QgaXMgbm93IHVzaW5nIGZhbGxiYWNrXG4gICAgICByZXR1cm4gZG9SZXF1ZXN0KGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjaywgcmVxT3B0cyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRIb3N0ID0gY2xpZW50Ll9nZXRIb3N0QnlUeXBlKGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcblxuICAgIHZhciB1cmwgPSBjdXJyZW50SG9zdCArIHJlcU9wdHMudXJsO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYm9keTogcmVxT3B0cy5ib2R5LFxuICAgICAganNvbkJvZHk6IHJlcU9wdHMuanNvbkJvZHksXG4gICAgICBtZXRob2Q6IHJlcU9wdHMubWV0aG9kLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIHRpbWVvdXRzOiByZXFPcHRzLnRpbWVvdXRzLFxuICAgICAgZGVidWc6IHJlcXVlc3REZWJ1Z1xuICAgIH07XG5cbiAgICByZXF1ZXN0RGVidWcoJ21ldGhvZDogJXMsIHVybDogJXMsIGhlYWRlcnM6ICVqLCB0aW1lb3V0czogJWQnLFxuICAgICAgb3B0aW9ucy5tZXRob2QsIHVybCwgb3B0aW9ucy5oZWFkZXJzLCBvcHRpb25zLnRpbWVvdXRzKTtcblxuICAgIGlmIChyZXF1ZXN0ZXIgPT09IGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjaykge1xuICAgICAgcmVxdWVzdERlYnVnKCd1c2luZyBmYWxsYmFjaycpO1xuICAgIH1cblxuICAgIC8vIGByZXF1ZXN0ZXJgIGlzIGFueSBvZiB0aGlzLl9yZXF1ZXN0IG9yIHRoaXMuX3JlcXVlc3QuZmFsbGJhY2tcbiAgICAvLyB0aHVzIGl0IG5lZWRzIHRvIGJlIGNhbGxlZCB1c2luZyB0aGUgY2xpZW50IGFzIGNvbnRleHRcbiAgICByZXR1cm4gcmVxdWVzdGVyLmNhbGwoY2xpZW50LCB1cmwsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcywgdHJ5RmFsbGJhY2spO1xuXG4gICAgZnVuY3Rpb24gc3VjY2VzcyhodHRwUmVzcG9uc2UpIHtcbiAgICAgIC8vIGNvbXB1dGUgdGhlIHN0YXR1cyBvZiB0aGUgcmVzcG9uc2UsXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiBpbiBicm93c2VyIG1vZGUsIHVzaW5nIFhEUiBvciBKU09OUCwgd2UgaGF2ZSBubyBzdGF0dXNDb2RlIGF2YWlsYWJsZVxuICAgICAgLy8gU28gd2UgcmVseSBvbiBvdXIgQVBJIHJlc3BvbnNlIGBzdGF0dXNgIHByb3BlcnR5LlxuICAgICAgLy8gQnV0IGB3YWl0VGFza2AgY2FuIHNldCBhIGBzdGF0dXNgIHByb3BlcnR5IHdoaWNoIGlzIG5vdCB0aGUgc3RhdHVzQ29kZSAoaXQncyB0aGUgdGFzayBzdGF0dXMpXG4gICAgICAvLyBTbyB3ZSBjaGVjayBpZiB0aGVyZSdzIGEgYG1lc3NhZ2VgIGFsb25nIGBzdGF0dXNgIGFuZCBpdCBtZWFucyBpdCdzIGFuIGVycm9yXG4gICAgICAvL1xuICAgICAgLy8gVGhhdCdzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgaGF2ZSBhIHJlc3BvbnNlLnN0YXR1cyB0aGF0J3Mgbm90IHRoZSBodHRwIHN0YXR1c0NvZGVcbiAgICAgIHZhciBzdGF0dXMgPSBodHRwUmVzcG9uc2UgJiYgaHR0cFJlc3BvbnNlLmJvZHkgJiYgaHR0cFJlc3BvbnNlLmJvZHkubWVzc2FnZSAmJiBodHRwUmVzcG9uc2UuYm9keS5zdGF0dXMgfHxcblxuICAgICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCB0byBjaGVjayB0aGUgcmVxdWVzdCBzdGF0dXNDb2RlIEFGVEVSIHRoZSBib2R5IGV2ZW50dWFsXG4gICAgICAgIC8vIHN0YXR1c0NvZGUgYmVjYXVzZSBzb21lIGltcGxlbWVudGF0aW9ucyAoalF1ZXJ5IFhEb21haW5SZXF1ZXN0IHRyYW5zcG9ydCkgbWF5XG4gICAgICAgIC8vIHNlbmQgc3RhdHVzQ29kZSAyMDAgd2hpbGUgd2UgaGFkIGFuIGVycm9yXG4gICAgICAgIGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlIHx8XG5cbiAgICAgICAgLy8gV2hlbiBpbiBicm93c2VyIG1vZGUsIHVzaW5nIFhEUiBvciBKU09OUFxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIHN1Y2Nlc3Mgd2hlbiBubyBlcnJvciAobm8gcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLm1lc3NhZ2UpXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIEpTT04ucGFyc2UoKSBlcnJvciB0aGVuIGJvZHkgaXMgbnVsbCBhbmQgaXQgZmFpbHNcbiAgICAgICAgaHR0cFJlc3BvbnNlICYmIGh0dHBSZXNwb25zZS5ib2R5ICYmIDIwMDtcblxuICAgICAgcmVxdWVzdERlYnVnKCdyZWNlaXZlZCByZXNwb25zZTogc3RhdHVzQ29kZTogJXMsIGNvbXB1dGVkIHN0YXR1c0NvZGU6ICVkLCBoZWFkZXJzOiAlaicsXG4gICAgICAgIGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLCBzdGF0dXMsIGh0dHBSZXNwb25zZS5oZWFkZXJzKTtcblxuICAgICAgdmFyIGh0dHBSZXNwb25zZU9rID0gTWF0aC5mbG9vcihzdGF0dXMgLyAxMDApID09PSAyO1xuXG4gICAgICB2YXIgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBkZWJ1Z0RhdGEucHVzaCh7XG4gICAgICAgIGN1cnJlbnRIb3N0OiBjdXJyZW50SG9zdCxcbiAgICAgICAgaGVhZGVyczogcmVtb3ZlQ3JlZGVudGlhbHMoaGVhZGVycyksXG4gICAgICAgIGNvbnRlbnQ6IGJvZHkgfHwgbnVsbCxcbiAgICAgICAgY29udGVudExlbmd0aDogYm9keSAhPT0gdW5kZWZpbmVkID8gYm9keS5sZW5ndGggOiBudWxsLFxuICAgICAgICBtZXRob2Q6IHJlcU9wdHMubWV0aG9kLFxuICAgICAgICB0aW1lb3V0czogcmVxT3B0cy50aW1lb3V0cyxcbiAgICAgICAgdXJsOiByZXFPcHRzLnVybCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaHR0cFJlc3BvbnNlT2spIHtcbiAgICAgICAgaWYgKGNsaWVudC5fdXNlQ2FjaGUgJiYgY2FjaGUpIHtcbiAgICAgICAgICBjYWNoZVtjYWNoZUlEXSA9IGh0dHBSZXNwb25zZS5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmJvZHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG91bGRSZXRyeSA9IE1hdGguZmxvb3Ioc3RhdHVzIC8gMTAwKSAhPT0gNDtcblxuICAgICAgaWYgKHNob3VsZFJldHJ5KSB7XG4gICAgICAgIHRyaWVzICs9IDE7XG4gICAgICAgIHJldHVybiByZXRyeVJlcXVlc3QoKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdERlYnVnKCd1bnJlY292ZXJhYmxlIGVycm9yJyk7XG5cbiAgICAgIC8vIG5vIHN1Y2Nlc3MgYW5kIG5vIHJldHJ5ID0+IGZhaWxcbiAgICAgIHZhciB1bnJlY292ZXJhYmxlRXJyb3IgPSBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihcbiAgICAgICAgaHR0cFJlc3BvbnNlLmJvZHkgJiYgaHR0cFJlc3BvbnNlLmJvZHkubWVzc2FnZSwge2RlYnVnRGF0YTogZGVidWdEYXRhLCBzdGF0dXNDb2RlOiBzdGF0dXN9XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdCh1bnJlY292ZXJhYmxlRXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyeUZhbGxiYWNrKGVycikge1xuICAgICAgLy8gZXJyb3IgY2FzZXM6XG4gICAgICAvLyAgV2hpbGUgbm90IGluIGZhbGxiYWNrIG1vZGU6XG4gICAgICAvLyAgICAtIENPUlMgbm90IHN1cHBvcnRlZFxuICAgICAgLy8gICAgLSBuZXR3b3JrIGVycm9yXG4gICAgICAvLyAgV2hpbGUgaW4gZmFsbGJhY2sgbW9kZTpcbiAgICAgIC8vICAgIC0gdGltZW91dFxuICAgICAgLy8gICAgLSBuZXR3b3JrIGVycm9yXG4gICAgICAvLyAgICAtIGJhZGx5IGZvcm1hdHRlZCBKU09OUCAoc2NyaXB0IGxvYWRlZCwgZGlkIG5vdCBjYWxsIG91ciBjYWxsYmFjaylcbiAgICAgIC8vICBJbiBib3RoIGNhc2VzOlxuICAgICAgLy8gICAgLSB1bmNhdWdodCBleGNlcHRpb24gb2NjdXJzIChUeXBlRXJyb3IpXG4gICAgICByZXF1ZXN0RGVidWcoJ2Vycm9yOiAlcywgc3RhY2s6ICVzJywgZXJyLm1lc3NhZ2UsIGVyci5zdGFjayk7XG5cbiAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGRlYnVnRGF0YS5wdXNoKHtcbiAgICAgICAgY3VycmVudEhvc3Q6IGN1cnJlbnRIb3N0LFxuICAgICAgICBoZWFkZXJzOiByZW1vdmVDcmVkZW50aWFscyhoZWFkZXJzKSxcbiAgICAgICAgY29udGVudDogYm9keSB8fCBudWxsLFxuICAgICAgICBjb250ZW50TGVuZ3RoOiBib2R5ICE9PSB1bmRlZmluZWQgPyBib2R5Lmxlbmd0aCA6IG51bGwsXG4gICAgICAgIG1ldGhvZDogcmVxT3B0cy5tZXRob2QsXG4gICAgICAgIHRpbWVvdXRzOiByZXFPcHRzLnRpbWVvdXRzLFxuICAgICAgICB1cmw6IHJlcU9wdHMudXJsLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogZW5kVGltZSxcbiAgICAgICAgZHVyYXRpb246IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKSkge1xuICAgICAgICBlcnIgPSBuZXcgZXJyb3JzLlVua25vd24oZXJyICYmIGVyci5tZXNzYWdlLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICB0cmllcyArPSAxO1xuXG4gICAgICAvLyBzdG9wIHRoZSByZXF1ZXN0IGltcGxlbWVudGF0aW9uIHdoZW46XG4gICAgICBpZiAoXG4gICAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgdGhpcyBlcnJvcixcbiAgICAgICAgLy8gaXQgY29tZXMgZnJvbSBhIHRocm93IGluIHNvbWUgb3RoZXIgcGllY2Ugb2YgY29kZVxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBlcnJvcnMuVW5rbm93biB8fFxuXG4gICAgICAgIC8vIHNlcnZlciBzZW50IHVucGFyc2FibGUgSlNPTlxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBlcnJvcnMuVW5wYXJzYWJsZUpTT04gfHxcblxuICAgICAgICAvLyBtYXggdHJpZXMgYW5kIGFscmVhZHkgdXNpbmcgZmFsbGJhY2sgb3Igbm8gZmFsbGJhY2tcbiAgICAgICAgdHJpZXMgPj0gY2xpZW50Lmhvc3RzW2luaXRpYWxPcHRzLmhvc3RUeXBlXS5sZW5ndGggJiZcbiAgICAgICAgKHVzaW5nRmFsbGJhY2sgfHwgIWhhc0ZhbGxiYWNrKSkge1xuICAgICAgICAvLyBzdG9wIHJlcXVlc3QgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgY29tbWFuZFxuICAgICAgICBlcnIuZGVidWdEYXRhID0gZGVidWdEYXRhO1xuICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIGEgdGltZW91dCBvY2N1cmVkLCByZXRyeSBieSByYWlzaW5nIHRpbWVvdXRcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBlcnJvcnMuUmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHJldHJ5UmVxdWVzdFdpdGhIaWdoZXJUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRyeVJlcXVlc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXRyeVJlcXVlc3QoKSB7XG4gICAgICByZXF1ZXN0RGVidWcoJ3JldHJ5aW5nIHJlcXVlc3QnKTtcbiAgICAgIGNsaWVudC5faW5jcmVtZW50SG9zdEluZGV4KGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcbiAgICAgIHJldHVybiBkb1JlcXVlc3QocmVxdWVzdGVyLCByZXFPcHRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXRyeVJlcXVlc3RXaXRoSGlnaGVyVGltZW91dCgpIHtcbiAgICAgIHJlcXVlc3REZWJ1ZygncmV0cnlpbmcgcmVxdWVzdCB3aXRoIGhpZ2hlciB0aW1lb3V0Jyk7XG4gICAgICBjbGllbnQuX2luY3JlbWVudEhvc3RJbmRleChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICBjbGllbnQuX2luY3JlbWVudFRpbWVvdXRNdWx0aXBsZXIoKTtcbiAgICAgIHJlcU9wdHMudGltZW91dHMgPSBjbGllbnQuX2dldFRpbWVvdXRzRm9yUmVxdWVzdChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICByZXR1cm4gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb21pc2UgPSBkb1JlcXVlc3QoXG4gICAgY2xpZW50Ll9yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGluaXRpYWxPcHRzLnVybCxcbiAgICAgIG1ldGhvZDogaW5pdGlhbE9wdHMubWV0aG9kLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGpzb25Cb2R5OiBpbml0aWFsT3B0cy5ib2R5LFxuICAgICAgdGltZW91dHM6IGNsaWVudC5fZ2V0VGltZW91dHNGb3JSZXF1ZXN0KGluaXRpYWxPcHRzLmhvc3RUeXBlKVxuICAgIH1cbiAgKTtcblxuICAvLyBlaXRoZXIgd2UgaGF2ZSBhIGNhbGxiYWNrXG4gIC8vIGVpdGhlciB3ZSBhcmUgdXNpbmcgcHJvbWlzZXNcbiAgaWYgKHR5cGVvZiBpbml0aWFsT3B0cy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiBva0NiKGNvbnRlbnQpIHtcbiAgICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBpbml0aWFsT3B0cy5jYWxsYmFjayhudWxsLCBjb250ZW50KTtcbiAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICB9LCBmdW5jdGlvbiBub29rQ2IoZXJyKSB7XG4gICAgICBleGl0UHJvbWlzZShmdW5jdGlvbigpIHtcbiAgICAgICAgaW5pdGlhbE9wdHMuY2FsbGJhY2soZXJyKTtcbiAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLypcbiogVHJhbnNmb3JtIHNlYXJjaCBwYXJhbSBvYmplY3QgaW4gcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSB7b2JqZWN0fSBhcmdzIGFyZ3VtZW50cyB0byBhZGQgdG8gdGhlIGN1cnJlbnQgcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMgY3VycmVudCBxdWVyeSBzdHJpbmdcbiogQHJldHVybiB7c3RyaW5nfSB0aGUgZmluYWwgcXVlcnkgc3RyaW5nXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbihhcmdzLCBwYXJhbXMpIHtcbiAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gYXJncykge1xuICAgIGlmIChrZXkgIT09IG51bGwgJiYgYXJnc1trZXldICE9PSB1bmRlZmluZWQgJiYgYXJncy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBwYXJhbXMgKz0gcGFyYW1zID09PSAnJyA/ICcnIDogJyYnO1xuICAgICAgcGFyYW1zICs9IGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnc1trZXldKSA9PT0gJ1tvYmplY3QgQXJyYXldJyA/IHNhZmVKU09OU3RyaW5naWZ5KGFyZ3Nba2V5XSkgOiBhcmdzW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9jb21wdXRlUmVxdWVzdEhlYWRlcnMgPSBmdW5jdGlvbihhZGRpdGlvbmFsVUEsIHdpdGhBUElLZXkpIHtcbiAgdmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbiAgdmFyIHVhID0gYWRkaXRpb25hbFVBID9cbiAgICB0aGlzLl91YSArICc7JyArIGFkZGl0aW9uYWxVQSA6XG4gICAgdGhpcy5fdWE7XG5cbiAgdmFyIHJlcXVlc3RIZWFkZXJzID0ge1xuICAgICd4LWFsZ29saWEtYWdlbnQnOiB1YSxcbiAgICAneC1hbGdvbGlhLWFwcGxpY2F0aW9uLWlkJzogdGhpcy5hcHBsaWNhdGlvbklEXG4gIH07XG5cbiAgLy8gYnJvd3NlciB3aWxsIGlubGluZSBoZWFkZXJzIGluIHRoZSB1cmwsIG5vZGUuanMgd2lsbCB1c2UgaHR0cCBoZWFkZXJzXG4gIC8vIGJ1dCBpbiBzb21lIHNpdHVhdGlvbnMsIHRoZSBBUEkgS0VZIHdpbGwgYmUgdG9vIGxvbmcgKGJpZyBzZWN1cmVkIEFQSSBrZXlzKVxuICAvLyBzbyBpZiB0aGUgcmVxdWVzdCBpcyBhIFBPU1QgYW5kIHRoZSBLRVkgaXMgdmVyeSBsb25nLCB3ZSB3aWxsIGJlIGFza2VkIHRvIG5vdCBwdXRcbiAgLy8gaXQgaW50byBoZWFkZXJzIGJ1dCBpbiB0aGUgSlNPTiBib2R5XG4gIGlmICh3aXRoQVBJS2V5ICE9PSBmYWxzZSkge1xuICAgIHJlcXVlc3RIZWFkZXJzWyd4LWFsZ29saWEtYXBpLWtleSddID0gdGhpcy5hcGlLZXk7XG4gIH1cblxuICBpZiAodGhpcy51c2VyVG9rZW4pIHtcbiAgICByZXF1ZXN0SGVhZGVyc1sneC1hbGdvbGlhLXVzZXJ0b2tlbiddID0gdGhpcy51c2VyVG9rZW47XG4gIH1cblxuICBpZiAodGhpcy5zZWN1cml0eVRhZ3MpIHtcbiAgICByZXF1ZXN0SGVhZGVyc1sneC1hbGdvbGlhLXRhZ2ZpbHRlcnMnXSA9IHRoaXMuc2VjdXJpdHlUYWdzO1xuICB9XG5cbiAgZm9yRWFjaCh0aGlzLmV4dHJhSGVhZGVycywgZnVuY3Rpb24gYWRkVG9SZXF1ZXN0SGVhZGVycyh2YWx1ZSwga2V5KSB7XG4gICAgcmVxdWVzdEhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gcmVxdWVzdEhlYWRlcnM7XG59O1xuXG4vKipcbiAqIFNlYXJjaCB0aHJvdWdoIG11bHRpcGxlIGluZGljZXMgYXQgdGhlIHNhbWUgdGltZVxuICogQHBhcmFtICB7T2JqZWN0W119ICAgcXVlcmllcyAgQW4gYXJyYXkgb2YgcXVlcmllcyB5b3Ugd2FudCB0byBydW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcmllc1tdLmluZGV4TmFtZSBUaGUgaW5kZXggbmFtZSB5b3Ugd2FudCB0byB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcXVlcmllc1tdLnF1ZXJ5XSBUaGUgcXVlcnkgdG8gaXNzdWUgb24gdGhpcyBpbmRleC4gQ2FuIGFsc28gYmUgcGFzc2VkIGludG8gYHBhcmFtc2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyaWVzW10ucGFyYW1zIEFueSBzZWFyY2ggcGFyYW0gbGlrZSBoaXRzUGVyUGFnZSwgLi5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWRcbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcmllcywgb3B0cywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogY2xpZW50LnNlYXJjaChhcnJheU9mUXVlcmllc1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShxdWVyaWVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBjbGllbnQgPSB0aGlzO1xuXG4gIHZhciBwb3N0T2JqID0ge1xuICAgIHJlcXVlc3RzOiBtYXAocXVlcmllcywgZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3QocXVlcnkpIHtcbiAgICAgIHZhciBwYXJhbXMgPSAnJztcblxuICAgICAgLy8gYWxsb3cgcXVlcnkucXVlcnlcbiAgICAgIC8vIHNvIHdlIGFyZSBtaW1pY2luZyB0aGUgaW5kZXguc2VhcmNoKHF1ZXJ5LCBwYXJhbXMpIG1ldGhvZFxuICAgICAgLy8ge2luZGV4TmFtZTosIHF1ZXJ5OiwgcGFyYW1zOn1cbiAgICAgIGlmIChxdWVyeS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcyArPSAncXVlcnk9JyArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeS5xdWVyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4TmFtZTogcXVlcnkuaW5kZXhOYW1lLFxuICAgICAgICBwYXJhbXM6IGNsaWVudC5fZ2V0U2VhcmNoUGFyYW1zKHF1ZXJ5LnBhcmFtcywgcGFyYW1zKVxuICAgICAgfTtcbiAgICB9KVxuICB9O1xuXG4gIHZhciBKU09OUFBhcmFtcyA9IG1hcChwb3N0T2JqLnJlcXVlc3RzLCBmdW5jdGlvbiBwcmVwYXJlSlNPTlBQYXJhbXMocmVxdWVzdCwgcmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RJZCArICc9JyArXG4gICAgICBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQocmVxdWVzdC5pbmRleE5hbWUpICsgJz8nICtcbiAgICAgICAgcmVxdWVzdC5wYXJhbXNcbiAgICAgICk7XG4gIH0pLmpvaW4oJyYnKTtcblxuICB2YXIgdXJsID0gJy8xL2luZGV4ZXMvKi9xdWVyaWVzJztcblxuICBpZiAob3B0cy5zdHJhdGVneSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJsICs9ICc/c3RyYXRlZ3k9JyArIG9wdHMuc3RyYXRlZ3k7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdXJsLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBmYWxsYmFjazoge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogJy8xL2luZGV4ZXMvKicsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHBhcmFtczogSlNPTlBQYXJhbXNcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBleHRyYSBzZWN1cml0eSB0YWdGaWx0ZXJzIGhlYWRlclxuICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHRhZ3MgVGhlIGxpc3Qgb2YgdGFncyBkZWZpbmluZyB0aGUgY3VycmVudCBzZWN1cml0eSBmaWx0ZXJzXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRTZWN1cml0eVRhZ3MgPSBmdW5jdGlvbih0YWdzKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFncykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICB2YXIgc3RyVGFncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YWdzW2ldKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICB2YXIgb3JlZFRhZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0YWdzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgb3JlZFRhZ3MucHVzaCh0YWdzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJUYWdzLnB1c2goJygnICsgb3JlZFRhZ3Muam9pbignLCcpICsgJyknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0clRhZ3MucHVzaCh0YWdzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGFncyA9IHN0clRhZ3Muam9pbignLCcpO1xuICB9XG5cbiAgdGhpcy5zZWN1cml0eVRhZ3MgPSB0YWdzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGV4dHJhIHVzZXIgdG9rZW4gaGVhZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlclRva2VuIFRoZSB0b2tlbiBpZGVudGlmeWluZyBhIHVuaXEgdXNlciAodXNlZCB0byBhcHBseSByYXRlIGxpbWl0cylcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldFVzZXJUb2tlbiA9IGZ1bmN0aW9uKHVzZXJUb2tlbikge1xuICB0aGlzLnVzZXJUb2tlbiA9IHVzZXJUb2tlbjtcbn07XG5cbi8qKlxuICogQ2xlYXIgYWxsIHF1ZXJpZXMgaW4gY2xpZW50J3MgY2FjaGVcbiAqIEByZXR1cm4gdW5kZWZpbmVkXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2FjaGUgPSB7fTtcbn07XG5cbi8qKlxuKiBTZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYSByZXF1ZXN0IGNhbiB0YWtlIGJlZm9yZSBhdXRvbWF0aWNhbGx5IGJlaW5nIHRlcm1pbmF0ZWQuXG4qIEBkZXByZWNhdGVkXG4qIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0UmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbihtaWxsaXNlY29uZHMpIHtcbiAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgIHRoaXMuX3RpbWVvdXRzLmNvbm5lY3QgPSB0aGlzLl90aW1lb3V0cy5yZWFkID0gdGhpcy5fdGltZW91dHMud3JpdGUgPSBtaWxsaXNlY29uZHM7XG4gIH1cbn07XG5cbi8qKlxuKiBTZXQgdGhlIHRocmVlIGRpZmZlcmVudCAoY29ubmVjdCwgcmVhZCwgd3JpdGUpIHRpbWVvdXRzIHRvIGJlIHVzZWQgd2hlbiByZXF1ZXN0aW5nXG4qIEBwYXJhbSB7T2JqZWN0fSB0aW1lb3V0c1xuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKHRpbWVvdXRzKSB7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGltZW91dHM7XG59O1xuXG4vKipcbiogR2V0IHRoZSB0aHJlZSBkaWZmZXJlbnQgKGNvbm5lY3QsIHJlYWQsIHdyaXRlKSB0aW1lb3V0cyB0byBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZ1xuKiBAcGFyYW0ge09iamVjdH0gdGltZW91dHNcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuZ2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbWVvdXRzO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRBcHBJZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSBzdG9yZS5nZXQodGhpcy5hcHBsaWNhdGlvbklEKTtcbiAgaWYgKGRhdGEgIT09IG51bGwpIHRoaXMuX2NhY2hlQXBwSWREYXRhKGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fc2V0QXBwSWREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBkYXRhLmxhc3RDaGFuZ2UgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB0aGlzLl9jYWNoZUFwcElkRGF0YShkYXRhKTtcbiAgcmV0dXJuIHN0b3JlLnNldCh0aGlzLmFwcGxpY2F0aW9uSUQsIGRhdGEpO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9jaGVja0FwcElkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2dldEFwcElkRGF0YSgpO1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgaWYgKGRhdGEgPT09IG51bGwgfHwgbm93IC0gZGF0YS5sYXN0Q2hhbmdlID4gUkVTRVRfQVBQX0RBVEFfVElNRVIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzZXRJbml0aWFsQXBwSWREYXRhKGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX3Jlc2V0SW5pdGlhbEFwcElkRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG5ld0RhdGEgPSBkYXRhIHx8IHt9O1xuICBuZXdEYXRhLmhvc3RJbmRleGVzID0ge3JlYWQ6IDAsIHdyaXRlOiAwfTtcbiAgbmV3RGF0YS50aW1lb3V0TXVsdGlwbGllciA9IDE7XG4gIG5ld0RhdGEuc2h1ZmZsZVJlc3VsdCA9IG5ld0RhdGEuc2h1ZmZsZVJlc3VsdCB8fCBzaHVmZmxlKFsxLCAyLCAzXSk7XG4gIHJldHVybiB0aGlzLl9zZXRBcHBJZERhdGEobmV3RGF0YSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2NhY2hlQXBwSWREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl9ob3N0SW5kZXhlcyA9IGRhdGEuaG9zdEluZGV4ZXM7XG4gIHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyID0gZGF0YS50aW1lb3V0TXVsdGlwbGllcjtcbiAgdGhpcy5fc2h1ZmZsZVJlc3VsdCA9IGRhdGEuc2h1ZmZsZVJlc3VsdDtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fcGFydGlhbEFwcElkRGF0YVVwZGF0ZSA9IGZ1bmN0aW9uKG5ld0RhdGEpIHtcbiAgdmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG4gIHZhciBjdXJyZW50RGF0YSA9IHRoaXMuX2dldEFwcElkRGF0YSgpO1xuICBmb3JlYWNoKG5ld0RhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBjdXJyZW50RGF0YVtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLl9zZXRBcHBJZERhdGEoY3VycmVudERhdGEpO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRIb3N0QnlUeXBlID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuaG9zdHNbaG9zdFR5cGVdW3RoaXMuX2dldEhvc3RJbmRleEJ5VHlwZShob3N0VHlwZSldO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRUaW1lb3V0TXVsdGlwbGllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGltZW91dE11bHRpcGxpZXI7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldEhvc3RJbmRleEJ5VHlwZSA9IGZ1bmN0aW9uKGhvc3RUeXBlKSB7XG4gIHJldHVybiB0aGlzLl9ob3N0SW5kZXhlc1tob3N0VHlwZV07XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX3NldEhvc3RJbmRleEJ5VHlwZSA9IGZ1bmN0aW9uKGhvc3RJbmRleCwgaG9zdFR5cGUpIHtcbiAgdmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuICB2YXIgbmV3SG9zdEluZGV4ZXMgPSBjbG9uZSh0aGlzLl9ob3N0SW5kZXhlcyk7XG4gIG5ld0hvc3RJbmRleGVzW2hvc3RUeXBlXSA9IGhvc3RJbmRleDtcbiAgdGhpcy5fcGFydGlhbEFwcElkRGF0YVVwZGF0ZSh7aG9zdEluZGV4ZXM6IG5ld0hvc3RJbmRleGVzfSk7XG4gIHJldHVybiBob3N0SW5kZXg7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2luY3JlbWVudEhvc3RJbmRleCA9IGZ1bmN0aW9uKGhvc3RUeXBlKSB7XG4gIHJldHVybiB0aGlzLl9zZXRIb3N0SW5kZXhCeVR5cGUoXG4gICAgKHRoaXMuX2dldEhvc3RJbmRleEJ5VHlwZShob3N0VHlwZSkgKyAxKSAlIHRoaXMuaG9zdHNbaG9zdFR5cGVdLmxlbmd0aCwgaG9zdFR5cGVcbiAgKTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5faW5jcmVtZW50VGltZW91dE11bHRpcGxlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGltZW91dE11bHRpcGxpZXIgPSBNYXRoLm1heCh0aGlzLl90aW1lb3V0TXVsdGlwbGllciArIDEsIDQpO1xuICByZXR1cm4gdGhpcy5fcGFydGlhbEFwcElkRGF0YVVwZGF0ZSh7dGltZW91dE11bHRpcGxpZXI6IHRpbWVvdXRNdWx0aXBsaWVyfSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldFRpbWVvdXRzRm9yUmVxdWVzdCA9IGZ1bmN0aW9uKGhvc3RUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgY29ubmVjdDogdGhpcy5fdGltZW91dHMuY29ubmVjdCAqIHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyLFxuICAgIGNvbXBsZXRlOiB0aGlzLl90aW1lb3V0c1tob3N0VHlwZV0gKiB0aGlzLl90aW1lb3V0TXVsdGlwbGllclxuICB9O1xufTtcblxuZnVuY3Rpb24gcHJlcGFyZUhvc3QocHJvdG9jb2wpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXBhcmUoaG9zdCkge1xuICAgIHJldHVybiBwcm90b2NvbCArICcvLycgKyBob3N0LnRvTG93ZXJDYXNlKCk7XG4gIH07XG59XG5cbi8vIFByb3RvdHlwZS5qcyA8IDEuNywgYSB3aWRlbHkgdXNlZCBsaWJyYXJ5LCBkZWZpbmVzIGEgd2VpcmRcbi8vIEFycmF5LnByb3RvdHlwZS50b0pTT04gZnVuY3Rpb24gdGhhdCB3aWxsIGZhaWwgdG8gc3RyaW5naWZ5IG91ciBjb250ZW50XG4vLyBhcHByb3ByaWF0ZWx5XG4vLyByZWZzOlxuLy8gICAtIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy9wcm90b3R5cGUtY29yZS9FLVNBVnZWX1Y5UVxuLy8gICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zc3RlcGhlbnNvbi9wcm90b3R5cGUvY29tbWl0LzAzOGEyOTg1YTcwNTkzYzFhODZjMjMwZmFkYmRmZTJlNDg5OGE0OGNcbi8vICAgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQ4NDQxLzE0NzA3OVxuZnVuY3Rpb24gc2FmZUpTT05TdHJpbmdpZnkob2JqKSB7XG4gIC8qIGVzbGludCBuby1leHRlbmQtbmF0aXZlOjAgKi9cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLnRvSlNPTiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH1cblxuICB2YXIgdG9KU09OID0gQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbiAgZGVsZXRlIEFycmF5LnByb3RvdHlwZS50b0pTT047XG4gIHZhciBvdXQgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICBBcnJheS5wcm90b3R5cGUudG9KU09OID0gdG9KU09OO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIHRlbXBvcmFyeVZhbHVlO1xuICB2YXIgcmFuZG9tSW5kZXg7XG5cbiAgLy8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cbiAgd2hpbGUgKGN1cnJlbnRJbmRleCAhPT0gMCkge1xuICAgIC8vIFBpY2sgYSByZW1haW5pbmcgZWxlbWVudC4uLlxuICAgIHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KTtcbiAgICBjdXJyZW50SW5kZXggLT0gMTtcblxuICAgIC8vIEFuZCBzd2FwIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICB0ZW1wb3JhcnlWYWx1ZSA9IGFycmF5W2N1cnJlbnRJbmRleF07XG4gICAgYXJyYXlbY3VycmVudEluZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcbiAgICBhcnJheVtyYW5kb21JbmRleF0gPSB0ZW1wb3JhcnlWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ3JlZGVudGlhbHMoaGVhZGVycykge1xuICB2YXIgbmV3SGVhZGVycyA9IHt9O1xuXG4gIGZvciAodmFyIGhlYWRlck5hbWUgaW4gaGVhZGVycykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgaGVhZGVyTmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgaWYgKGhlYWRlck5hbWUgPT09ICd4LWFsZ29saWEtYXBpLWtleScgfHwgaGVhZGVyTmFtZSA9PT0gJ3gtYWxnb2xpYS1hcHBsaWNhdGlvbi1pZCcpIHtcbiAgICAgICAgdmFsdWUgPSAnKipoaWRkZW4gZm9yIHNlY3VyaXR5IHB1cnBvc2VzKionO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgfVxuXG4gICAgICBuZXdIZWFkZXJzW2hlYWRlck5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0hlYWRlcnM7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0FsZ29saWFTZWFyY2hDb3JlLmpzIiwidmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxnb2xpYXNlYXJjaDpzcmMvaG9zdEluZGV4U3RhdGUuanMnKTtcbnZhciBsb2NhbFN0b3JhZ2VOYW1lc3BhY2UgPSAnYWxnb2xpYXNlYXJjaC1jbGllbnQtanMnO1xuXG52YXIgc3RvcmU7XG52YXIgbW9kdWxlU3RvcmUgPSB7XG4gIHN0YXRlOiB7fSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIGRhdGEpIHtcbiAgICB0aGlzLnN0YXRlW2tleV0gPSBkYXRhO1xuICAgIHJldHVybiB0aGlzLnN0YXRlW2tleV07XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVba2V5XSB8fCBudWxsO1xuICB9XG59O1xuXG52YXIgbG9jYWxTdG9yYWdlU3RvcmUgPSB7XG4gIHNldDogZnVuY3Rpb24oa2V5LCBkYXRhKSB7XG4gICAgbW9kdWxlU3RvcmUuc2V0KGtleSwgZGF0YSk7IC8vIGFsd2F5cyByZXBsaWNhdGUgbG9jYWxTdG9yYWdlU3RvcmUgdG8gbW9kdWxlU3RvcmUgaW4gY2FzZSBvZiBmYWlsdXJlXG5cbiAgICB0cnkge1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IEpTT04ucGFyc2UoZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdKTtcbiAgICAgIG5hbWVzcGFjZVtrZXldID0gZGF0YTtcbiAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSA9IEpTT04uc3RyaW5naWZ5KG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gbmFtZXNwYWNlW2tleV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZUZhaWx1cmUoa2V5LCBlKTtcbiAgICB9XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSlba2V5XSB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VGYWlsdXJlKGtleSwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2VGYWlsdXJlKGtleSwgZSkge1xuICBkZWJ1ZygnbG9jYWxTdG9yYWdlIGZhaWxlZCB3aXRoJywgZSk7XG4gIGNsZWFudXAoKTtcbiAgc3RvcmUgPSBtb2R1bGVTdG9yZTtcbiAgcmV0dXJuIHN0b3JlLmdldChrZXkpO1xufVxuXG5zdG9yZSA9IHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgPyBsb2NhbFN0b3JhZ2VTdG9yZSA6IG1vZHVsZVN0b3JlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0OiBnZXRPclNldCxcbiAgc2V0OiBnZXRPclNldCxcbiAgc3VwcG9ydHNMb2NhbFN0b3JhZ2U6IHN1cHBvcnRzTG9jYWxTdG9yYWdlXG59O1xuXG5mdW5jdGlvbiBnZXRPclNldChrZXksIGRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGtleSk7XG4gIH1cblxuICByZXR1cm4gc3RvcmUuc2V0KGtleSwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkge1xuICB0cnkge1xuICAgIGlmICgnbG9jYWxTdG9yYWdlJyBpbiBnbG9iYWwgJiZcbiAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UgIT09IG51bGwpIHtcbiAgICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdKSB7XG4gICAgICAgIC8vIGFjdHVhbCBjcmVhdGlvbiBvZiB0aGUgbmFtZXNwYWNlXG4gICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VOYW1lc3BhY2UsIEpTT04uc3RyaW5naWZ5KHt9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSW4gY2FzZSBvZiBhbnkgZXJyb3Igb24gbG9jYWxTdG9yYWdlLCB3ZSBjbGVhbiBvdXIgb3duIG5hbWVzcGFjZSwgdGhpcyBzaG91bGQgaGFuZGxlXG4vLyBxdW90YSBlcnJvcnMgd2hlbiBhIGxvdCBvZiBrZXlzICsgZGF0YSBhcmUgdXNlZFxuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgdHJ5IHtcbiAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obG9jYWxTdG9yYWdlTmFtZXNwYWNlKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9zdG9yZS5qcyIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9kZWJ1Zy9zcmMvZGVidWcuanMiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21zL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnZ2xvYmFsJyk7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlIHx8IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxuLy8gVGhpcyBpcyB0aGUgc3RhbmRhbG9uZSBicm93c2VyIGJ1aWxkIGVudHJ5IHBvaW50XG4vLyBCcm93c2VyIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBbGdvbGlhIFNlYXJjaCBKYXZhU2NyaXB0IGNsaWVudCxcbi8vIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LCBYRG9tYWluUmVxdWVzdCBhbmQgSlNPTlAgYXMgZmFsbGJhY2tcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlQWxnb2xpYXNlYXJjaChBbGdvbGlhU2VhcmNoLCB1YVN1ZmZpeCkge1xuICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuICB2YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG4gIHZhciBpbmxpbmVIZWFkZXJzID0gcmVxdWlyZSgnLi9pbmxpbmUtaGVhZGVycycpO1xuICB2YXIganNvbnBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9qc29ucC1yZXF1ZXN0Jyk7XG4gIHZhciBwbGFjZXMgPSByZXF1aXJlKCcuLi9wbGFjZXMuanMnKTtcbiAgdWFTdWZmaXggPSB1YVN1ZmZpeCB8fCAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZWJ1ZycpIHtcbiAgICByZXF1aXJlKCdkZWJ1ZycpLmVuYWJsZSgnYWxnb2xpYXNlYXJjaConKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsZ29saWFzZWFyY2goYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSB7XG4gICAgdmFyIGNsb25lRGVlcCA9IHJlcXVpcmUoJy4uL2Nsb25lLmpzJyk7XG5cbiAgICB2YXIgZ2V0RG9jdW1lbnRQcm90b2NvbCA9IHJlcXVpcmUoJy4vZ2V0LWRvY3VtZW50LXByb3RvY29sJyk7XG5cbiAgICBvcHRzID0gY2xvbmVEZWVwKG9wdHMgfHwge30pO1xuXG4gICAgaWYgKG9wdHMucHJvdG9jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0cy5wcm90b2NvbCA9IGdldERvY3VtZW50UHJvdG9jb2woKTtcbiAgICB9XG5cbiAgICBvcHRzLl91YSA9IG9wdHMuX3VhIHx8IGFsZ29saWFzZWFyY2gudWE7XG5cbiAgICByZXR1cm4gbmV3IEFsZ29saWFTZWFyY2hCcm93c2VyKGFwcGxpY2F0aW9uSUQsIGFwaUtleSwgb3B0cyk7XG4gIH1cblxuICBhbGdvbGlhc2VhcmNoLnZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uLmpzJyk7XG4gIGFsZ29saWFzZWFyY2gudWEgPSAnQWxnb2xpYSBmb3IgdmFuaWxsYSBKYXZhU2NyaXB0ICcgKyB1YVN1ZmZpeCArIGFsZ29saWFzZWFyY2gudmVyc2lvbjtcbiAgYWxnb2xpYXNlYXJjaC5pbml0UGxhY2VzID0gcGxhY2VzKGFsZ29saWFzZWFyY2gpO1xuXG4gIC8vIHdlIGV4cG9zZSBpbnRvIHdpbmRvdyBubyBtYXR0ZXIgaG93IHdlIGFyZSB1c2VkLCB0aGlzIHdpbGwgYWxsb3dcbiAgLy8gdXMgdG8gZWFzaWx5IGRlYnVnIGFueSB3ZWJzaXRlIHJ1bm5pbmcgYWxnb2xpYVxuICBnbG9iYWwuX19hbGdvbGlhID0ge1xuICAgIGRlYnVnOiByZXF1aXJlKCdkZWJ1ZycpLFxuICAgIGFsZ29saWFzZWFyY2g6IGFsZ29saWFzZWFyY2hcbiAgfTtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBoYXNYTUxIdHRwUmVxdWVzdDogJ1hNTEh0dHBSZXF1ZXN0JyBpbiBnbG9iYWwsXG4gICAgaGFzWERvbWFpblJlcXVlc3Q6ICdYRG9tYWluUmVxdWVzdCcgaW4gZ2xvYmFsXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaGFzWE1MSHR0cFJlcXVlc3QpIHtcbiAgICBzdXBwb3J0LmNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFsZ29saWFTZWFyY2hCcm93c2VyKCkge1xuICAgIC8vIGNhbGwgQWxnb2xpYVNlYXJjaCBjb25zdHJ1Y3RvclxuICAgIEFsZ29saWFTZWFyY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXRzKEFsZ29saWFTZWFyY2hCcm93c2VyLCBBbGdvbGlhU2VhcmNoKTtcblxuICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiB3cmFwUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIG5vIGNvcnMgb3IgWERvbWFpblJlcXVlc3QsIG5vIHJlcXVlc3RcbiAgICAgIGlmICghc3VwcG9ydC5jb3JzICYmICFzdXBwb3J0Lmhhc1hEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIC8vIHZlcnkgb2xkIGJyb3dzZXIsIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnMuTmV0d29yaygnQ09SUyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVybCA9IGlubGluZUhlYWRlcnModXJsLCBvcHRzLmhlYWRlcnMpO1xuXG4gICAgICB2YXIgYm9keSA9IG9wdHMuYm9keTtcbiAgICAgIHZhciByZXEgPSBzdXBwb3J0LmNvcnMgPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgdmFyIHJlcVRpbWVvdXQ7XG4gICAgICB2YXIgdGltZWRPdXQ7XG4gICAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAgIHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgb3B0cy50aW1lb3V0cy5jb25uZWN0KTtcbiAgICAgIC8vIHdlIHNldCBhbiBlbXB0eSBvbnByb2dyZXNzIGxpc3RlbmVyXG4gICAgICAvLyBzbyB0aGF0IFhEb21haW5SZXF1ZXN0IG9uIElFOSBpcyBub3QgYWJvcnRlZFxuICAgICAgLy8gcmVmczpcbiAgICAgIC8vICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWpzL2lzc3Vlcy83NlxuICAgICAgLy8gIC0gaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9pZS9lbi1VUy8zMGVmM2FkZC03NjdjLTQ0MzYtYjhhOS1mMWNhMTliNDgxMmUvaWU5LXJ0bS14ZG9tYWlucmVxdWVzdC1pc3N1ZWQtcmVxdWVzdHMtbWF5LWFib3J0LWlmLWFsbC1ldmVudC1oYW5kbGVycy1ub3Qtc3BlY2lmaWVkP2ZvcnVtPWlld2ViZGV2ZWxvcG1lbnRcbiAgICAgIHJlcS5vbnByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICAgIGlmICgnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiByZXEpIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvblJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgICByZXEub25sb2FkID0gb25Mb2FkO1xuICAgICAgcmVxLm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICAvLyBkbyBub3QgcmVseSBvbiBkZWZhdWx0IFhIUiBhc3luYyBmbGFnLCBhcyBzb21lIGFuYWx5dGljcyBjb2RlIGxpa2UgaG90amFyXG4gICAgICAvLyBicmVha3MgaXQgYW5kIHNldCBpdCB0byBmYWxzZSBieSBkZWZhdWx0XG4gICAgICBpZiAocmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmVxLm9wZW4ob3B0cy5tZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEub3BlbihvcHRzLm1ldGhvZCwgdXJsKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGVhZGVycyBhcmUgbWVhbnQgdG8gYmUgc2VudCBhZnRlciBvcGVuXG4gICAgICBpZiAoc3VwcG9ydC5jb3JzKSB7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgaWYgKG9wdHMubWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQWNjZXNzX2NvbnRyb2xfQ09SUyNTaW1wbGVfcmVxdWVzdHNcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNlbmQoYm9keSk7XG5cbiAgICAgIC8vIGV2ZW50IG9iamVjdCBub3QgcmVjZWl2ZWQgaW4gSUU4LCBhdCBsZWFzdFxuICAgICAgLy8gYnV0IHdlIGRvIG5vdCB1c2UgaXQsIHN0aWxsIGltcG9ydGFudCB0byBub3RlXG4gICAgICBmdW5jdGlvbiBvbkxvYWQoLyogZXZlbnQgKi8pIHtcbiAgICAgICAgLy8gV2hlbiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRzIHJlcS50aW1lb3V0LCB3ZSBjYW5cbiAgICAgICAgLy8gaGF2ZSBib3RoIGEgbG9hZCBhbmQgdGltZW91dCBldmVudCwgc2luY2UgaGFuZGxlZCBieSBhIGR1bWIgc2V0VGltZW91dFxuICAgICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cbiAgICAgICAgdmFyIG91dDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dCA9IHtcbiAgICAgICAgICAgIGJvZHk6IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlVGV4dCksXG4gICAgICAgICAgICByZXNwb25zZVRleHQ6IHJlcS5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiByZXEuc3RhdHVzLFxuICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3QgZG9lcyBub3QgaGF2ZSBhbnkgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgaGVhZGVyczogcmVxLmdldEFsbFJlc3BvbnNlSGVhZGVycyAmJiByZXEuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwge31cbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgb3V0ID0gbmV3IGVycm9ycy5VbnBhcnNhYmxlSlNPTih7XG4gICAgICAgICAgICBtb3JlOiByZXEucmVzcG9uc2VUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0IGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OKSB7XG4gICAgICAgICAgcmVqZWN0KG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuXG4gICAgICAgIC8vIGVycm9yIGV2ZW50IGlzIHRyaWdlcnJlZCBib3RoIHdpdGggWERSL1hIUiBvbjpcbiAgICAgICAgLy8gICAtIEROUyBlcnJvclxuICAgICAgICAvLyAgIC0gdW5hbGxvd2VkIGNyb3NzIGRvbWFpbiByZXF1ZXN0XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgZXJyb3JzLk5ldHdvcmsoe1xuICAgICAgICAgICAgbW9yZTogZXZlbnRcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnMuUmVxdWVzdFRpbWVvdXQoKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ29ubmVjdCgpIHtcbiAgICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuICAgICAgICByZXFUaW1lb3V0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIG9wdHMudGltZW91dHMuY29tcGxldGUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuICAgICAgICBpZiAoIWNvbm5lY3RlZCkgb25Db25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVhZHlTdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCFjb25uZWN0ZWQgJiYgcmVxLnJlYWR5U3RhdGUgPiAxKSBvbkNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3JlcXVlc3QuZmFsbGJhY2sgPSBmdW5jdGlvbiByZXF1ZXN0RmFsbGJhY2sodXJsLCBvcHRzKSB7XG4gICAgdXJsID0gaW5saW5lSGVhZGVycyh1cmwsIG9wdHMuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gd3JhcEpzb25wUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGpzb25wUmVxdWVzdCh1cmwsIG9wdHMsIGZ1bmN0aW9uIGpzb25wUmVxdWVzdERvbmUoZXJyLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQWxnb2xpYVNlYXJjaEJyb3dzZXIucHJvdG90eXBlLl9wcm9taXNlID0ge1xuICAgIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0UHJvbWlzZSh2YWwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWwpO1xuICAgIH0sXG4gICAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbCk7XG4gICAgfSxcbiAgICBkZWxheTogZnVuY3Rpb24gZGVsYXlQcm9taXNlKG1zKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gcmVzb2x2ZU9uVGltZW91dChyZXNvbHZlLyogLCByZWplY3QqLykge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gYWxnb2xpYXNlYXJjaDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvY3JlYXRlQWxnb2xpYXNlYXJjaC5qcyIsInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9nbG9iYWwvd2luZG93LmpzIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICA0LjEuMVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG52YXIgX2lzQXJyYXkgPSB1bmRlZmluZWQ7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdW5kZWZpbmVkO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdW5kZWZpbmVkO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICh7fSkudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdW5kZWZpbmVkO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gIGlmIChfc3RhdGUpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX2FyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDE2KTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgR0VUX1RIRU5fRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihwcm9taXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBHRVRfVEhFTl9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4kJDEsIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuJCQxLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4kJDEsIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJDEgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlJDEpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkMSA9PT0gR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICBHRVRfVEhFTl9FUlJPUi5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGdldFRoZW4odmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHVuZGVmaW5lZCxcbiAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gRXJyb3JPYmplY3QoKSB7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xufVxuXG52YXIgVFJZX0NBVENIX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgcmV0dXJuIFRSWV9DQVRDSF9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB1bmRlZmluZWQsXG4gICAgICBlcnJvciA9IHVuZGVmaW5lZCxcbiAgICAgIHN1Y2NlZWRlZCA9IHVuZGVmaW5lZCxcbiAgICAgIGZhaWxlZCA9IHVuZGVmaW5lZDtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB2YWx1ZSA9IHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgaWYgKHZhbHVlID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgdmFsdWUuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiBFbnVtZXJhdG9yJDEoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cbiAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgIHZhciBfdGhlbiA9IGdldFRoZW4oZW50cnkpO1xuXG4gICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlJDIpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSQkMShlbnRyeSk7XG4gICAgICB9KSwgaSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsJDEoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IkMSh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZSQxKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5mdW5jdGlvbiBQcm9taXNlJDIocmVzb2x2ZXIpIHtcbiAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlJDIgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICB9XG59XG5cblByb21pc2UkMi5hbGwgPSBhbGwkMTtcblByb21pc2UkMi5yYWNlID0gcmFjZSQxO1xuUHJvbWlzZSQyLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDIucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDIuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMi5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDIuX2FzYXAgPSBhc2FwO1xuXG5Qcm9taXNlJDIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUHJvbWlzZSQyLFxuXG4gIC8qKlxuICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIENoYWluaW5nXG4gICAgLS0tLS0tLS1cbiAgXG4gICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgfSk7XG4gIFxuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgIH0pO1xuICAgIGBgYFxuICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBc3NpbWlsYXRpb25cbiAgICAtLS0tLS0tLS0tLS1cbiAgXG4gICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgU2ltcGxlIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgcmVzdWx0O1xuICBcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgYXV0aG9yLCBib29rcztcbiAgXG4gICAgdHJ5IHtcbiAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICBcbiAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgXG4gICAgfVxuICBcbiAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRBdXRob3IoKS5cbiAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgdGhlblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICB0aGVuOiB0aGVuLFxuXG4gIC8qKlxuICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBcbiAgICBgYGBqc1xuICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgIH1cbiAgXG4gICAgLy8gc3luY2hyb25vdXNcbiAgICB0cnkge1xuICAgICAgZmluZEF1dGhvcigpO1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH1cbiAgXG4gICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBjYXRjaFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gICdjYXRjaCc6IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9XG59O1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsJDEoKSB7XG4gICAgdmFyIGxvY2FsID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgaWYgKFApIHtcbiAgICAgICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMjtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQyLnBvbHlmaWxsID0gcG9seWZpbGwkMTtcblByb21pc2UkMi5Qcm9taXNlID0gUHJvbWlzZSQyO1xuXG5yZXR1cm4gUHJvbWlzZSQyO1xuXG59KSkpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB2ZXJ0eCAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMyA0IDUgNiA3IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlubGluZUhlYWRlcnM7XG5cbnZhciBlbmNvZGUgPSByZXF1aXJlKCdxdWVyeXN0cmluZy1lczMvZW5jb2RlJyk7XG5cbmZ1bmN0aW9uIGlubGluZUhlYWRlcnModXJsLCBoZWFkZXJzKSB7XG4gIGlmICgvXFw/Ly50ZXN0KHVybCkpIHtcbiAgICB1cmwgKz0gJyYnO1xuICB9IGVsc2Uge1xuICAgIHVybCArPSAnPyc7XG4gIH1cblxuICByZXR1cm4gdXJsICsgZW5jb2RlKGhlYWRlcnMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2lubGluZS1oZWFkZXJzLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbnBSZXF1ZXN0O1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbnZhciBKU09OUENvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBqc29ucFJlcXVlc3QodXJsLCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgY2IobmV3IEVycm9yKCdNZXRob2QgJyArIG9wdHMubWV0aG9kICsgJyAnICsgdXJsICsgJyBpcyBub3Qgc3VwcG9ydGVkIGJ5IEpTT05QLicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRzLmRlYnVnKCdKU09OUDogc3RhcnQnKTtcblxuICB2YXIgY2JDYWxsZWQgPSBmYWxzZTtcbiAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG5cbiAgSlNPTlBDb3VudGVyICs9IDE7XG4gIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgY2JOYW1lID0gJ2FsZ29saWFKU09OUF8nICsgSlNPTlBDb3VudGVyO1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gIHdpbmRvd1tjYk5hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJlbW92ZUdsb2JhbHMoKTtcblxuICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgb3B0cy5kZWJ1ZygnSlNPTlA6IExhdGUgYW5zd2VyLCBpZ25vcmluZycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNiQ2FsbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFuKCk7XG5cbiAgICBjYihudWxsLCB7XG4gICAgICBib2R5OiBkYXRhLyogLFxuICAgICAgLy8gV2UgZG8gbm90IHNlbmQgdGhlIHN0YXR1c0NvZGUsIHRoZXJlJ3Mgbm8gc3RhdHVzQ29kZSBpbiBKU09OUCwgaXQgd2lsbCBiZVxuICAgICAgLy8gY29tcHV0ZWQgdXNpbmcgZGF0YS5zdGF0dXMgJiYgZGF0YS5tZXNzYWdlIGxpa2Ugd2l0aCBYRFJcbiAgICAgIHN0YXR1c0NvZGUqL1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIGFkZCBjYWxsYmFjayBieSBoYW5kXG4gIHVybCArPSAnJmNhbGxiYWNrPScgKyBjYk5hbWU7XG5cbiAgLy8gYWRkIGJvZHkgcGFyYW1zIG1hbnVhbGx5XG4gIGlmIChvcHRzLmpzb25Cb2R5ICYmIG9wdHMuanNvbkJvZHkucGFyYW1zKSB7XG4gICAgdXJsICs9ICcmJyArIG9wdHMuanNvbkJvZHkucGFyYW1zO1xuICB9XG5cbiAgdmFyIG9udGltZW91dCA9IHNldFRpbWVvdXQodGltZW91dCwgb3B0cy50aW1lb3V0cy5jb21wbGV0ZSk7XG5cbiAgLy8gc2NyaXB0IG9ucmVhZHlzdGF0ZWNoYW5nZSBuZWVkZWQgb25seSBmb3JcbiAgLy8gPD0gSUU4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvaXNzdWVzLzQ1MjNcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2U7XG4gIHNjcmlwdC5vbmxvYWQgPSBzdWNjZXNzO1xuICBzY3JpcHQub25lcnJvciA9IGVycm9yO1xuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICBmdW5jdGlvbiBzdWNjZXNzKCkge1xuICAgIG9wdHMuZGVidWcoJ0pTT05QOiBzdWNjZXNzJyk7XG5cbiAgICBpZiAoZG9uZSB8fCB0aW1lZE91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgLy8gc2NyaXB0IGxvYWRlZCBidXQgZGlkIG5vdCBjYWxsIHRoZSBmbiA9PiBzY3JpcHQgbG9hZGluZyBlcnJvclxuICAgIGlmICghY2JDYWxsZWQpIHtcbiAgICAgIG9wdHMuZGVidWcoJ0pTT05QOiBGYWlsLiBTY3JpcHQgbG9hZGVkIGJ1dCBkaWQgbm90IGNhbGwgdGhlIGNhbGxiYWNrJyk7XG4gICAgICBjbGVhbigpO1xuICAgICAgY2IobmV3IGVycm9ycy5KU09OUFNjcmlwdEZhaWwoKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHN1Y2Nlc3MoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICBjbGVhclRpbWVvdXQob250aW1lb3V0KTtcbiAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICBzY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlR2xvYmFscygpIHtcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIHdpbmRvd1tjYk5hbWVdO1xuICAgICAgZGVsZXRlIHdpbmRvd1tjYk5hbWUgKyAnX2xvYWRlZCddO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdpbmRvd1tjYk5hbWVdID0gd2luZG93W2NiTmFtZSArICdfbG9hZGVkJ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGltZW91dCgpIHtcbiAgICBvcHRzLmRlYnVnKCdKU09OUDogU2NyaXB0IHRpbWVvdXQnKTtcbiAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgY2xlYW4oKTtcbiAgICBjYihuZXcgZXJyb3JzLlJlcXVlc3RUaW1lb3V0KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgb3B0cy5kZWJ1ZygnSlNPTlA6IFNjcmlwdCBlcnJvcicpO1xuXG4gICAgaWYgKGRvbmUgfHwgdGltZWRPdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbGVhbigpO1xuICAgIGNiKG5ldyBlcnJvcnMuSlNPTlBTY3JpcHRFcnJvcigpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2pzb25wLXJlcXVlc3QuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVBsYWNlc0NsaWVudDtcblxudmFyIGJ1aWxkU2VhcmNoTWV0aG9kID0gcmVxdWlyZSgnLi9idWlsZFNlYXJjaE1ldGhvZC5qcycpO1xuXG5mdW5jdGlvbiBjcmVhdGVQbGFjZXNDbGllbnQoYWxnb2xpYXNlYXJjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gcGxhY2VzKGFwcElELCBhcGlLZXksIG9wdHMpIHtcbiAgICB2YXIgY2xvbmVEZWVwID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpO1xuXG4gICAgb3B0cyA9IG9wdHMgJiYgY2xvbmVEZWVwKG9wdHMpIHx8IHt9O1xuICAgIG9wdHMuaG9zdHMgPSBvcHRzLmhvc3RzIHx8IFtcbiAgICAgICdwbGFjZXMtZHNuLmFsZ29saWEubmV0JyxcbiAgICAgICdwbGFjZXMtMS5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAncGxhY2VzLTIuYWxnb2xpYW5ldC5jb20nLFxuICAgICAgJ3BsYWNlcy0zLmFsZ29saWFuZXQuY29tJ1xuICAgIF07XG5cbiAgICAvLyBhbGxvdyBpbml0UGxhY2VzKCkgbm8gYXJndW1lbnRzID0+IGNvbW11bml0eSByYXRlIGxpbWl0ZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgYXBwSUQgPT09ICdvYmplY3QnIHx8IGFwcElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFwcElEID0gJyc7XG4gICAgICBhcGlLZXkgPSAnJztcbiAgICAgIG9wdHMuX2FsbG93RW1wdHlDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudCA9IGFsZ29saWFzZWFyY2goYXBwSUQsIGFwaUtleSwgb3B0cyk7XG4gICAgdmFyIGluZGV4ID0gY2xpZW50LmluaXRJbmRleCgncGxhY2VzJyk7XG4gICAgaW5kZXguc2VhcmNoID0gYnVpbGRTZWFyY2hNZXRob2QoJ3F1ZXJ5JywgJy8xL3BsYWNlcy9xdWVyeScpO1xuICAgIGluZGV4LmdldE9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdElELCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgdXJsOiAnLzEvcGxhY2VzLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpLFxuICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9wbGFjZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RG9jdW1lbnRQcm90b2NvbDtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRQcm90b2NvbCgpIHtcbiAgdmFyIHByb3RvY29sID0gd2luZG93LmRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sO1xuXG4gIC8vIHdoZW4gaW4gYGZpbGU6YCBtb2RlIChsb2NhbCBodG1sIGZpbGUpLCBkZWZhdWx0IHRvIGBodHRwOmBcbiAgaWYgKHByb3RvY29sICE9PSAnaHR0cDonICYmIHByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgfVxuXG4gIHJldHVybiBwcm90b2NvbDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9nZXQtZG9jdW1lbnQtcHJvdG9jb2wuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzMuMjQuMyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL3ZlcnNpb24uanMiXSwic291cmNlUm9vdCI6IiJ9