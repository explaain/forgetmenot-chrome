/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5);


/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*
	* loglevel - https://github.com/pimterry/loglevel
	*
	* Copyright (c) 2013 Tim Perry
	* Licensed under the MIT license.
	*/
	(function (root, definition) {
	    "use strict";
	
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
	        module.exports = definition();
	    } else {
	        root.log = definition();
	    }
	})(undefined, function () {
	    "use strict";
	
	    // Slightly dubious tricks to cut down minimized file size
	
	    var noop = function noop() {};
	    var undefinedType = "undefined";
	
	    var logMethods = ["trace", "debug", "info", "warn", "error"];
	
	    // Cross-browser bind equivalent that works at least back to IE6
	    function bindMethod(obj, methodName) {
	        var method = obj[methodName];
	        if (typeof method.bind === 'function') {
	            return method.bind(obj);
	        } else {
	            try {
	                return Function.prototype.bind.call(method, obj);
	            } catch (e) {
	                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
	                return function () {
	                    return Function.prototype.apply.apply(method, [obj, arguments]);
	                };
	            }
	        }
	    }
	
	    // Build the best logging method possible for this env
	    // Wherever possible we want to bind, not wrap, to preserve stack traces
	    function realMethod(methodName) {
	        if (methodName === 'debug') {
	            methodName = 'log';
	        }
	
	        if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType) {
	            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
	        } else if (console[methodName] !== undefined) {
	            return bindMethod(console, methodName);
	        } else if (console.log !== undefined) {
	            return bindMethod(console, 'log');
	        } else {
	            return noop;
	        }
	    }
	
	    // These private functions always need `this` to be set properly
	
	    function replaceLoggingMethods(level, loggerName) {
	        /*jshint validthis:true */
	        for (var i = 0; i < logMethods.length; i++) {
	            var methodName = logMethods[i];
	            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
	        }
	
	        // Define log.log as an alias for log.debug
	        this.log = this.debug;
	    }
	
	    // In old IE versions, the console isn't present until you first open it.
	    // We build realMethod() replacements here that regenerate logging methods
	    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
	        return function () {
	            if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== undefinedType) {
	                replaceLoggingMethods.call(this, level, loggerName);
	                this[methodName].apply(this, arguments);
	            }
	        };
	    }
	
	    // By default, we use closely bound real methods wherever possible, and
	    // otherwise we wait for a console to appear, and then try again.
	    function defaultMethodFactory(methodName, level, loggerName) {
	        /*jshint validthis:true */
	        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
	    }
	
	    function Logger(name, defaultLevel, factory) {
	        var self = this;
	        var currentLevel;
	        var storageKey = "loglevel";
	        if (name) {
	            storageKey += ":" + name;
	        }
	
	        function persistLevelIfPossible(levelNum) {
	            var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            // Use localStorage if available
	            try {
	                window.localStorage[storageKey] = levelName;
	                return;
	            } catch (ignore) {}
	
	            // Use session cookie as fallback
	            try {
	                window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
	            } catch (ignore) {}
	        }
	
	        function getPersistedLevel() {
	            var storedLevel;
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            try {
	                storedLevel = window.localStorage[storageKey];
	            } catch (ignore) {}
	
	            // Fallback to cookies if local storage gives us nothing
	            if ((typeof storedLevel === 'undefined' ? 'undefined' : _typeof(storedLevel)) === undefinedType) {
	                try {
	                    var cookie = window.document.cookie;
	                    var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
	                    if (location) {
	                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
	                    }
	                } catch (ignore) {}
	            }
	
	            // If the stored level is not valid, treat it as if nothing was stored.
	            if (self.levels[storedLevel] === undefined) {
	                storedLevel = undefined;
	            }
	
	            return storedLevel;
	        }
	
	        /*
	         *
	         * Public logger API - see https://github.com/pimterry/loglevel for details
	         *
	         */
	
	        self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
	            "ERROR": 4, "SILENT": 5 };
	
	        self.methodFactory = factory || defaultMethodFactory;
	
	        self.getLevel = function () {
	            return currentLevel;
	        };
	
	        self.setLevel = function (level, persist) {
	            if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
	                level = self.levels[level.toUpperCase()];
	            }
	            if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
	                currentLevel = level;
	                if (persist !== false) {
	                    // defaults to true
	                    persistLevelIfPossible(level);
	                }
	                replaceLoggingMethods.call(self, level, name);
	                if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType && level < self.levels.SILENT) {
	                    return "No console available for logging";
	                }
	            } else {
	                throw "log.setLevel() called with invalid level: " + level;
	            }
	        };
	
	        self.setDefaultLevel = function (level) {
	            if (!getPersistedLevel()) {
	                self.setLevel(level, false);
	            }
	        };
	
	        self.enableAll = function (persist) {
	            self.setLevel(self.levels.TRACE, persist);
	        };
	
	        self.disableAll = function (persist) {
	            self.setLevel(self.levels.SILENT, persist);
	        };
	
	        // Initialize with the right level
	        var initialLevel = getPersistedLevel();
	        if (initialLevel == null) {
	            initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
	        }
	        self.setLevel(initialLevel, false);
	    }
	
	    /*
	     *
	     * Top-level API
	     *
	     */
	
	    var defaultLogger = new Logger();
	
	    var _loggersByName = {};
	    defaultLogger.getLogger = function getLogger(name) {
	        if (typeof name !== "string" || name === "") {
	            throw new TypeError("You must supply a name when creating a logger.");
	        }
	
	        var logger = _loggersByName[name];
	        if (!logger) {
	            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
	        }
	        return logger;
	    };
	
	    // Grab the current global log variable in case of overwrite
	    var _log = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType ? window.log : undefined;
	    defaultLogger.noConflict = function () {
	        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType && window.log === defaultLogger) {
	            window.log = _log;
	        }
	
	        return defaultLogger;
	    };
	
	    return defaultLogger;
	});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(6);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _explaainSearch = __webpack_require__(12);
	
	var _explaainSearch2 = _interopRequireDefault(_explaainSearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var UserIDs = {
	  live: {
	    Jeremy: '1627888800569309',
	    Matt: '1455707247850069',
	    Carol: '1459068990878077',
	    Harriet: '1478776232161468',
	    Jonny: '1513554438729753'
	  },
	  staging: {
	    Jeremy: '1366746370089527',
	    Matt: '1528134990563202'
	  },
	  local: {
	    Jeremy: '1300120880110773',
	    Matt: '1428419100528438'
	  },
	  drive: {
	    Jeremy: '104380110279658920175',
	    ACME: '101118387301286232222'
	  }
	};
	
	var UserID = UserIDs.live.ACME;
	var PageResults = {};
	var UserCards = [];
	var LastRefresh = 0;
	
	var algoliaParams = { // Need to send these to app.vue to avoid duplication!
	  appID: 'I2VKMNNAXI',
	  apiKey: '2b8406f84cd4cc507da173032c46ee7b',
	  index: 'ForgetMeNot_Context_Test'
	};
	_vue2.default.use(_explaainSearch2.default, algoliaParams);
	
	chrome.browserAction.onClicked.addListener(function (tab) {
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    chrome.tabs.sendMessage(tabs[0].id, { action: 'toggleDrawer' }, function (res) {
	      _loglevel2.default.info(res);
	    });
	  });
	});
	
	chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
	  try {
	    _loglevel2.default.debug(sender.tab ? "From a content script: " + sender.tab.url : "From the extension", request);
	
	    if (request.action == "getPageResults") {
	      getCurrentPageResults(request.data).then(function (res) {
	        _loglevel2.default.debug(res);
	        sendResponse(res);
	      });
	      return true;
	    }
	    if (request.action == "checkPage") {
	      _loglevel2.default.trace(request.data);
	      checkRefresh().then(function () {
	        return _explaainSearch2.default.getPageResults(UserID, request.data, UserCards);
	      }).then(function (res) {
	        addToPageResults(sender.tab.id, res);
	        PageResults = res;
	        sendResponse(res);
	      }).catch(function (e) {
	        _loglevel2.default.error(e);
	      });
	      return true;
	    }
	    if (request.action == "getUser") {
	      sendResponse(UserID);
	      return true;
	    }
	    if (request.action == "refreshCards") {
	      getAllUserCards();
	      return true;
	    }
	    if (request.event == "popupOpened") {
	      chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	        chrome.tabs.sendMessage(tabs[0].id, { event: 'popupOpened' }, function (response) {});
	      });
	      return true;
	    }
	  } catch (e) {
	    _loglevel2.default.error(e);
	  }
	});
	
	var getCurrentPageResults = function getCurrentPageResults(data) {
	  var d = _q2.default.defer();
	  var tabID;
	  _loglevel2.default.debug(1);
	  checkRefresh().then(getCurrentTab).then(function (tab) {
	    _loglevel2.default.debug(tab.id);
	    tabID = tab.id;
	    _loglevel2.default.debug(PageResults);
	    if (PageResults[tabID]) {
	      d.resolve(PageResults[tabID]);
	    } else {
	      if (!data) data = { tabID: tabID };
	      _loglevel2.default.debug(data);
	      getPageData(data).then(function (res) {
	        _loglevel2.default.debug(res);
	        return _explaainSearch2.default.getPageResults(UserID, res, UserCards);
	      }).then(function (res) {
	        _loglevel2.default.debug(res);
	        addToPageResults(tabID, res);
	        d.resolve(res);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	    }
	  }).catch(function (e) {
	    d.reject(e);
	  });
	  return d.promise;
	};
	
	var getCurrentTab = function getCurrentTab() {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    d.resolve(tabs[0]);
	  });
	  return d.promise;
	};
	
	var getPageData = function getPageData(data) {
	  var d = _q2.default.defer();
	  if (data.pageData) {
	    d.resolve(data.pageData);
	  } else if (data.tabID) {
	    sendMessageToTab(tabID, { action: 'getPageData' }).then(function (res) {
	      d.resolve(res);
	    });
	  } else {
	    d.reject();
	  }
	  return d.promise;
	};
	
	var sendMessageToTab = function sendMessageToTab(tabID, data) {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.sendMessage(tabID, data, function (res) {
	    _loglevel2.default.debug(res);
	    d.resolve(res);
	  });
	  return d.promise;
	};
	
	var addToPageResults = function addToPageResults(tabID, data) {
	  PageResults[tabID] = data;
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    Object.keys(PageResults).forEach(function (pageTabID) {
	      if (tabs.filter(function (tab) {
	        return tab.id == pageTabID;
	      }).length == 0) delete PageResults[pageTabID];
	    });
	    _loglevel2.default.debug(PageResults);
	  });
	};
	
	var checkRefresh = function checkRefresh() {
	  var d = _q2.default.defer();
	  var now = new Date();
	  if (now - LastRefresh > 300000) {
	    getAllUserCards().then(function () {
	      d.resolve();
	    }).catch(function (e) {
	      _loglevel2.default.error(e);
	      d.reject(e);
	    });
	  } else {
	    d.resolve();
	  }
	  return d.promise;
	};
	
	var getAllUserCards = function getAllUserCards() {
	  var d = _q2.default.defer();
	  LastRefresh = new Date();
	  _explaainSearch2.default.searchCards(UserID, '', 1000).then(function (results) {
	    UserCards = results;
	    _loglevel2.default.debug(UserCards);
	    d.resolve();
	  }).catch(function (e) {
	    _loglevel2.default.error(e);
	    d.reject(e);
	  });
	  return d.promise;
	};
	getAllUserCards();

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * Vue.js v2.4.2
	 * (c) 2014-2017 Evan You
	 * Released under the MIT License.
	 */
	/*  */
	
	// these helpers produces better vm code in JS engines due to their
	// explicitness and function inlining
	function isUndef(v) {
	  return v === undefined || v === null;
	}
	
	function isDef(v) {
	  return v !== undefined && v !== null;
	}
	
	function isTrue(v) {
	  return v === true;
	}
	
	function isFalse(v) {
	  return v === false;
	}
	
	/**
	 * Check if value is primitive
	 */
	function isPrimitive(value) {
	  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	}
	
	var _toString = Object.prototype.toString;
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	function isPlainObject(obj) {
	  return _toString.call(obj) === '[object Object]';
	}
	
	function isRegExp(v) {
	  return _toString.call(v) === '[object RegExp]';
	}
	
	/**
	 * Check if val is a valid array index.
	 */
	function isValidArrayIndex(val) {
	  var n = parseFloat(val);
	  return n >= 0 && Math.floor(n) === n && isFinite(val);
	}
	
	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function toString(val) {
	  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
	}
	
	/**
	 * Convert a input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber(val) {
	  var n = parseFloat(val);
	  return isNaN(n) ? val : n;
	}
	
	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap(str, expectsLowerCase) {
	  var map = Object.create(null);
	  var list = str.split(',');
	  for (var i = 0; i < list.length; i++) {
	    map[list[i]] = true;
	  }
	  return expectsLowerCase ? function (val) {
	    return map[val.toLowerCase()];
	  } : function (val) {
	    return map[val];
	  };
	}
	
	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);
	
	/**
	 * Check if a attribute is a reserved attribute.
	 */
	var isReservedAttribute = makeMap('key,ref,slot,is');
	
	/**
	 * Remove an item from an array
	 */
	function remove(arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1);
	    }
	  }
	}
	
	/**
	 * Check whether the object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Create a cached version of a pure function.
	 */
	function cached(fn) {
	  var cache = Object.create(null);
	  return function cachedFn(str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str));
	  };
	}
	
	/**
	 * Camelize a hyphen-delimited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	  return str.replace(camelizeRE, function (_, c) {
	    return c ? c.toUpperCase() : '';
	  });
	});
	
	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1);
	});
	
	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /([^-])([A-Z])/g;
	var hyphenate = cached(function (str) {
	  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
	});
	
	/**
	 * Simple bind, faster than native
	 */
	function bind(fn, ctx) {
	  function boundFn(a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  }
	  // record original fn length
	  boundFn._length = fn.length;
	  return boundFn;
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 */
	function extend(to, _from) {
	  for (var key in _from) {
	    to[key] = _from[key];
	  }
	  return to;
	}
	
	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject(arr) {
	  var res = {};
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i]) {
	      extend(res, arr[i]);
	    }
	  }
	  return res;
	}
	
	/**
	 * Perform no operation.
	 * Stubbing args to make Flow happy without leaving useless transpiled code
	 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
	 */
	function noop(a, b, c) {}
	
	/**
	 * Always return false.
	 */
	var no = function no(a, b, c) {
	  return false;
	};
	
	/**
	 * Return same value
	 */
	var identity = function identity(_) {
	  return _;
	};
	
	/**
	 * Generate a static keys string from compiler modules.
	 */
	function genStaticKeys(modules) {
	  return modules.reduce(function (keys, m) {
	    return keys.concat(m.staticKeys || []);
	  }, []).join(',');
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual(a, b) {
	  if (a === b) {
	    return true;
	  }
	  var isObjectA = isObject(a);
	  var isObjectB = isObject(b);
	  if (isObjectA && isObjectB) {
	    try {
	      var isArrayA = Array.isArray(a);
	      var isArrayB = Array.isArray(b);
	      if (isArrayA && isArrayB) {
	        return a.length === b.length && a.every(function (e, i) {
	          return looseEqual(e, b[i]);
	        });
	      } else if (!isArrayA && !isArrayB) {
	        var keysA = Object.keys(a);
	        var keysB = Object.keys(b);
	        return keysA.length === keysB.length && keysA.every(function (key) {
	          return looseEqual(a[key], b[key]);
	        });
	      } else {
	        /* istanbul ignore next */
	        return false;
	      }
	    } catch (e) {
	      /* istanbul ignore next */
	      return false;
	    }
	  } else if (!isObjectA && !isObjectB) {
	    return String(a) === String(b);
	  } else {
	    return false;
	  }
	}
	
	function looseIndexOf(arr, val) {
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	/**
	 * Ensure a function is called only once.
	 */
	function once(fn) {
	  var called = false;
	  return function () {
	    if (!called) {
	      called = true;
	      fn.apply(this, arguments);
	    }
	  };
	}
	
	var SSR_ATTR = 'data-server-rendered';
	
	var ASSET_TYPES = ['component', 'directive', 'filter'];
	
	var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];
	
	/*  */
	
	var config = {
	  /**
	   * Option merge strategies (used in core/util/options)
	   */
	  optionMergeStrategies: Object.create(null),
	
	  /**
	   * Whether to suppress warnings.
	   */
	  silent: false,
	
	  /**
	   * Show production mode tip message on boot?
	   */
	  productionTip: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to enable devtools
	   */
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to record perf
	   */
	  performance: false,
	
	  /**
	   * Error handler for watcher errors
	   */
	  errorHandler: null,
	
	  /**
	   * Warn handler for watcher warns
	   */
	  warnHandler: null,
	
	  /**
	   * Ignore certain custom elements
	   */
	  ignoredElements: [],
	
	  /**
	   * Custom user key aliases for v-on
	   */
	  keyCodes: Object.create(null),
	
	  /**
	   * Check if a tag is reserved so that it cannot be registered as a
	   * component. This is platform-dependent and may be overwritten.
	   */
	  isReservedTag: no,
	
	  /**
	   * Check if an attribute is reserved so that it cannot be used as a component
	   * prop. This is platform-dependent and may be overwritten.
	   */
	  isReservedAttr: no,
	
	  /**
	   * Check if a tag is an unknown element.
	   * Platform-dependent.
	   */
	  isUnknownElement: no,
	
	  /**
	   * Get the namespace of an element
	   */
	  getTagNamespace: noop,
	
	  /**
	   * Parse the real tag name for the specific platform.
	   */
	  parsePlatformTagName: identity,
	
	  /**
	   * Check if an attribute must be bound using property, e.g. value
	   * Platform-dependent.
	   */
	  mustUseProp: no,
	
	  /**
	   * Exposed for legacy reasons
	   */
	  _lifecycleHooks: LIFECYCLE_HOOKS
	};
	
	/*  */
	
	var emptyObject = Object.freeze({});
	
	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Define a property.
	 */
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Parse simple path.
	 */
	var bailRE = /[^\w.$]/;
	function parsePath(path) {
	  if (bailRE.test(path)) {
	    return;
	  }
	  var segments = path.split('.');
	  return function (obj) {
	    for (var i = 0; i < segments.length; i++) {
	      if (!obj) {
	        return;
	      }
	      obj = obj[segments[i]];
	    }
	    return obj;
	  };
	}
	
	/*  */
	
	var warn = noop;
	var tip = noop;
	var formatComponentName = null; // work around flow check
	
	if (process.env.NODE_ENV !== 'production') {
	  var hasConsole = typeof console !== 'undefined';
	  var classifyRE = /(?:^|[-_])(\w)/g;
	  var classify = function classify(str) {
	    return str.replace(classifyRE, function (c) {
	      return c.toUpperCase();
	    }).replace(/[-_]/g, '');
	  };
	
	  warn = function warn(msg, vm) {
	    var trace = vm ? generateComponentTrace(vm) : '';
	
	    if (config.warnHandler) {
	      config.warnHandler.call(null, msg, vm, trace);
	    } else if (hasConsole && !config.silent) {
	      console.error("[Vue warn]: " + msg + trace);
	    }
	  };
	
	  tip = function tip(msg, vm) {
	    if (hasConsole && !config.silent) {
	      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
	    }
	  };
	
	  formatComponentName = function formatComponentName(vm, includeFile) {
	    if (vm.$root === vm) {
	      return '<Root>';
	    }
	    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;
	
	    var file = vm._isVue && vm.$options.__file;
	    if (!name && file) {
	      var match = file.match(/([^/\\]+)\.vue$/);
	      name = match && match[1];
	    }
	
	    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
	  };
	
	  var repeat = function repeat(str, n) {
	    var res = '';
	    while (n) {
	      if (n % 2 === 1) {
	        res += str;
	      }
	      if (n > 1) {
	        str += str;
	      }
	      n >>= 1;
	    }
	    return res;
	  };
	
	  var generateComponentTrace = function generateComponentTrace(vm) {
	    if (vm._isVue && vm.$parent) {
	      var tree = [];
	      var currentRecursiveSequence = 0;
	      while (vm) {
	        if (tree.length > 0) {
	          var last = tree[tree.length - 1];
	          if (last.constructor === vm.constructor) {
	            currentRecursiveSequence++;
	            vm = vm.$parent;
	            continue;
	          } else if (currentRecursiveSequence > 0) {
	            tree[tree.length - 1] = [last, currentRecursiveSequence];
	            currentRecursiveSequence = 0;
	          }
	        }
	        tree.push(vm);
	        vm = vm.$parent;
	      }
	      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
	        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
	      }).join('\n');
	    } else {
	      return "\n\n(found in " + formatComponentName(vm) + ")";
	    }
	  };
	}
	
	/*  */
	
	function handleError(err, vm, info) {
	  if (config.errorHandler) {
	    config.errorHandler.call(null, err, vm, info);
	  } else {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
	    }
	    /* istanbul ignore else */
	    if (inBrowser && typeof console !== 'undefined') {
	      console.error(err);
	    } else {
	      throw err;
	    }
	  }
	}
	
	/*  */
	/* globals MutationObserver */
	
	// can we use __proto__?
	var hasProto = '__proto__' in {};
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
	var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
	
	// Firefix has a "watch" function on Object.prototype...
	var nativeWatch = {}.watch;
	
	var supportsPassive = false;
	if (inBrowser) {
	  try {
	    var opts = {};
	    Object.defineProperty(opts, 'passive', {
	      get: function get() {
	        /* istanbul ignore next */
	        supportsPassive = true;
	      }
	    }); // https://github.com/facebook/flow/issues/285
	    window.addEventListener('test-passive', null, opts);
	  } catch (e) {}
	}
	
	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function isServerRendering() {
	  if (_isServer === undefined) {
	    /* istanbul ignore if */
	    if (!inBrowser && typeof global !== 'undefined') {
	      // detect presence of vue-server-renderer and avoid
	      // Webpack shimming the process
	      _isServer = global['process'].env.VUE_ENV === 'server';
	    } else {
	      _isServer = false;
	    }
	  }
	  return _isServer;
	};
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	/* istanbul ignore next */
	function isNative(Ctor) {
	  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
	}
	
	var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
	
	/**
	 * Defer a task to execute it asynchronously.
	 */
	var nextTick = function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  // the nextTick behavior leverages the microtask queue, which can be accessed
	  // via either native Promise.then or MutationObserver.
	  // MutationObserver has wider support, however it is seriously bugged in
	  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	  // completely stops working after triggering a few times... so, if native
	  // Promise is available, we will use it:
	  /* istanbul ignore if */
	  if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p = Promise.resolve();
	    var logError = function logError(err) {
	      console.error(err);
	    };
	    timerFunc = function timerFunc() {
	      p.then(nextTickHandler).catch(logError);
	      // in problematic UIWebViews, Promise.then doesn't completely break, but
	      // it can get stuck in a weird state where callbacks are pushed into the
	      // microtask queue but the queue isn't being flushed, until the browser
	      // needs to do some other work, e.g. handle a timer. Therefore we can
	      // "force" the microtask queue to be flushed by adding an empty timer.
	      if (isIOS) {
	        setTimeout(noop);
	      }
	    };
	  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
	  // PhantomJS and iOS 7.x
	  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
	    // use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS IE11, iOS7, Android 4.4
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(String(counter));
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function timerFunc() {
	      counter = (counter + 1) % 2;
	      textNode.data = String(counter);
	    };
	  } else {
	    // fallback to setTimeout
	    /* istanbul ignore next */
	    timerFunc = function timerFunc() {
	      setTimeout(nextTickHandler, 0);
	    };
	  }
	
	  return function queueNextTick(cb, ctx) {
	    var _resolve;
	    callbacks.push(function () {
	      if (cb) {
	        try {
	          cb.call(ctx);
	        } catch (e) {
	          handleError(e, ctx, 'nextTick');
	        }
	      } else if (_resolve) {
	        _resolve(ctx);
	      }
	    });
	    if (!pending) {
	      pending = true;
	      timerFunc();
	    }
	    if (!cb && typeof Promise !== 'undefined') {
	      return new Promise(function (resolve, reject) {
	        _resolve = resolve;
	      });
	    }
	  };
	}();
	
	var _Set;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && isNative(Set)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    function Set() {
	      this.set = Object.create(null);
	    }
	    Set.prototype.has = function has(key) {
	      return this.set[key] === true;
	    };
	    Set.prototype.add = function add(key) {
	      this.set[key] = true;
	    };
	    Set.prototype.clear = function clear() {
	      this.set = Object.create(null);
	    };
	
	    return Set;
	  }();
	}
	
	/*  */
	
	var uid = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 */
	var Dep = function Dep() {
	  this.id = uid++;
	  this.subs = [];
	};
	
	Dep.prototype.addSub = function addSub(sub) {
	  this.subs.push(sub);
	};
	
	Dep.prototype.removeSub = function removeSub(sub) {
	  remove(this.subs, sub);
	};
	
	Dep.prototype.depend = function depend() {
	  if (Dep.target) {
	    Dep.target.addDep(this);
	  }
	};
	
	Dep.prototype.notify = function notify() {
	  // stabilize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	var targetStack = [];
	
	function pushTarget(_target) {
	  if (Dep.target) {
	    targetStack.push(Dep.target);
	  }
	  Dep.target = _target;
	}
	
	function popTarget() {
	  Dep.target = targetStack.pop();
	}
	
	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    var args = [],
	        len = arguments.length;
	    while (len--) {
	      args[len] = arguments[len];
	    }var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) {
	      ob.observeArray(inserted);
	    }
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/*  */
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However when passing down props,
	 * we don't want to force conversion because the value may be a nested value
	 * under a frozen data structure. Converting it would defeat the optimization.
	 */
	var observerState = {
	  shouldConvert: true
	};
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 */
	var Observer = function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  this.vmCount = 0;
	  def(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	};
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 */
	Observer.prototype.walk = function walk(obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0; i < keys.length; i++) {
	    defineReactive$$1(obj, keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 */
	Observer.prototype.observeArray = function observeArray(items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 */
	function protoAugment(target, src, keys) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 */
	/* istanbul ignore next */
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe(value, asRootData) {
	  if (!isObject(value)) {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (asRootData && ob) {
	    ob.vmCount++;
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive$$1(obj, key, val, customSetter, shallow) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = !shallow && observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          dependArray(value);
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      /* eslint-disable no-self-compare */
	      if (newVal === value || newVal !== newVal && value !== value) {
	        return;
	      }
	      /* eslint-enable no-self-compare */
	      if (process.env.NODE_ENV !== 'production' && customSetter) {
	        customSetter();
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = !shallow && observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 */
	function set(target, key, val) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.length = Math.max(target.length, key);
	    target.splice(key, 1, val);
	    return val;
	  }
	  if (hasOwn(target, key)) {
	    target[key] = val;
	    return val;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
	    return val;
	  }
	  if (!ob) {
	    target[key] = val;
	    return val;
	  }
	  defineReactive$$1(ob.value, key, val);
	  ob.dep.notify();
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 */
	function del(target, key) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.splice(key, 1);
	    return;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
	    return;
	  }
	  if (!hasOwn(target, key)) {
	    return;
	  }
	  delete target[key];
	  if (!ob) {
	    return;
	  }
	  ob.dep.notify();
	}
	
	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray(value) {
	  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
	    e = value[i];
	    e && e.__ob__ && e.__ob__.dep.depend();
	    if (Array.isArray(e)) {
	      dependArray(e);
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;
	
	/**
	 * Options with restrictions
	 */
	if (process.env.NODE_ENV !== 'production') {
	  strats.el = strats.propsData = function (parent, child, vm, key) {
	    if (!vm) {
	      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
	    }
	    return defaultStrat(parent, child);
	  };
	}
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData(to, from) {
	  if (!from) {
	    return to;
	  }
	  var key, toVal, fromVal;
	  var keys = Object.keys(from);
	  for (var i = 0; i < keys.length; i++) {
	    key = keys[i];
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	function mergeDataOrFn(parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	}
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    if (childVal && typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	
	      return parentVal;
	    }
	    return mergeDataOrFn.call(this, parentVal, childVal);
	  }
	
	  return mergeDataOrFn(parentVal, childVal, vm);
	};
	
	/**
	 * Hooks and props are merged as arrays.
	 */
	function mergeHook(parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
	}
	
	LIFECYCLE_HOOKS.forEach(function (hook) {
	  strats[hook] = mergeHook;
	});
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, childVal) : res;
	}
	
	ASSET_TYPES.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal) {
	  // work around Firefox's Object.prototype.watch...
	  if (parentVal === nativeWatch) {
	    parentVal = undefined;
	  }
	  if (childVal === nativeWatch) {
	    childVal = undefined;
	  }
	  /* istanbul ignore if */
	  if (!childVal) {
	    return Object.create(parentVal || null);
	  }
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !Array.isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  if (childVal) {
	    extend(ret, childVal);
	  }
	  return ret;
	};
	strats.provide = mergeDataOrFn;
	
	/**
	 * Default strategy.
	 */
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Validate component names
	 */
	function checkComponents(options) {
	  for (var key in options.components) {
	    var lower = key.toLowerCase();
	    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
	      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps(options) {
	  var props = options.props;
	  if (!props) {
	    return;
	  }
	  var res = {};
	  var i, val, name;
	  if (Array.isArray(props)) {
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        name = camelize(val);
	        res[name] = { type: null };
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('props must be strings when using array syntax.');
	      }
	    }
	  } else if (isPlainObject(props)) {
	    for (var key in props) {
	      val = props[key];
	      name = camelize(key);
	      res[name] = isPlainObject(val) ? val : { type: val };
	    }
	  }
	  options.props = res;
	}
	
	/**
	 * Normalize all injections into Object-based format
	 */
	function normalizeInject(options) {
	  var inject = options.inject;
	  if (Array.isArray(inject)) {
	    var normalized = options.inject = {};
	    for (var i = 0; i < inject.length; i++) {
	      normalized[inject[i]] = inject[i];
	    }
	  }
	}
	
	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives(options) {
	  var dirs = options.directives;
	  if (dirs) {
	    for (var key in dirs) {
	      var def = dirs[key];
	      if (typeof def === 'function') {
	        dirs[key] = { bind: def, update: def };
	      }
	    }
	  }
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions(parent, child, vm) {
	  if (process.env.NODE_ENV !== 'production') {
	    checkComponents(child);
	  }
	
	  if (typeof child === 'function') {
	    child = child.options;
	  }
	
	  normalizeProps(child);
	  normalizeInject(child);
	  normalizeDirectives(child);
	  var extendsFrom = child.extends;
	  if (extendsFrom) {
	    parent = mergeOptions(parent, extendsFrom, vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  var options = {};
	  var key;
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  // check local registration variations first
	  if (hasOwn(assets, id)) {
	    return assets[id];
	  }
	  var camelizedId = camelize(id);
	  if (hasOwn(assets, camelizedId)) {
	    return assets[camelizedId];
	  }
	  var PascalCaseId = capitalize(camelizedId);
	  if (hasOwn(assets, PascalCaseId)) {
	    return assets[PascalCaseId];
	  }
	  // fallback to prototype chain
	  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	/*  */
	
	function validateProp(key, propOptions, propsData, vm) {
	  var prop = propOptions[key];
	  var absent = !hasOwn(propsData, key);
	  var value = propsData[key];
	  // handle boolean props
	  if (isType(Boolean, prop.type)) {
	    if (absent && !hasOwn(prop, 'default')) {
	      value = false;
	    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
	      value = true;
	    }
	  }
	  // check default value
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop, key);
	    // since the default value is a fresh copy,
	    // make sure to observe it.
	    var prevShouldConvert = observerState.shouldConvert;
	    observerState.shouldConvert = true;
	    observe(value);
	    observerState.shouldConvert = prevShouldConvert;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    assertProp(prop, key, value, vm, absent);
	  }
	  return value;
	}
	
	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue(vm, prop, key) {
	  // no default, return undefined
	  if (!hasOwn(prop, 'default')) {
	    return undefined;
	  }
	  var def = prop.default;
	  // warn against non-factory defaults for Object & Array
	  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
	    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // the raw prop value was also undefined from previous render,
	  // return previous default value to avoid unnecessary watcher trigger
	  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
	    return vm._props[key];
	  }
	  // call factory function for non-Function types
	  // a value is Function if its prototype is function even across different execution context
	  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp(prop, name, value, vm, absent) {
	  if (prop.required && absent) {
	    warn('Missing required prop: "' + name + '"', vm);
	    return;
	  }
	  if (value == null && !prop.required) {
	    return;
	  }
	  var type = prop.type;
	  var valid = !type || type === true;
	  var expectedTypes = [];
	  if (type) {
	    if (!Array.isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType || '');
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
	    return;
	  }
	  var validator = prop.validator;
	  if (validator) {
	    if (!validator(value)) {
	      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
	    }
	  }
	}
	
	var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
	
	function assertType(value, type) {
	  var valid;
	  var expectedType = getType(type);
	  if (simpleCheckRE.test(expectedType)) {
	    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();
	  } else if (expectedType === 'Object') {
	    valid = isPlainObject(value);
	  } else if (expectedType === 'Array') {
	    valid = Array.isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType(fn) {
	  var match = fn && fn.toString().match(/^\s*function (\w+)/);
	  return match ? match[1] : '';
	}
	
	function isType(type, fn) {
	  if (!Array.isArray(fn)) {
	    return getType(fn) === getType(type);
	  }
	  for (var i = 0, len = fn.length; i < len; i++) {
	    if (getType(fn[i]) === getType(type)) {
	      return true;
	    }
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	/*  */
	
	var mark;
	var measure;
	
	if (process.env.NODE_ENV !== 'production') {
	  var perf = inBrowser && window.performance;
	  /* istanbul ignore if */
	  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
	    mark = function mark(tag) {
	      return perf.mark(tag);
	    };
	    measure = function measure(name, startTag, endTag) {
	      perf.measure(name, startTag, endTag);
	      perf.clearMarks(startTag);
	      perf.clearMarks(endTag);
	      perf.clearMeasures(name);
	    };
	  }
	}
	
	/* not type checking this file because flow doesn't play well with Proxy */
	
	var initProxy;
	
	if (process.env.NODE_ENV !== 'production') {
	  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
	  );
	
	  var warnNonPresent = function warnNonPresent(target, key) {
	    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
	  };
	
	  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);
	
	  if (hasProxy) {
	    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
	    config.keyCodes = new Proxy(config.keyCodes, {
	      set: function set(target, key, value) {
	        if (isBuiltInModifier(key)) {
	          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
	          return false;
	        } else {
	          target[key] = value;
	          return true;
	        }
	      }
	    });
	  }
	
	  var hasHandler = {
	    has: function has(target, key) {
	      var has = key in target;
	      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
	      if (!has && !isAllowed) {
	        warnNonPresent(target, key);
	      }
	      return has || !isAllowed;
	    }
	  };
	
	  var getHandler = {
	    get: function get(target, key) {
	      if (typeof key === 'string' && !(key in target)) {
	        warnNonPresent(target, key);
	      }
	      return target[key];
	    }
	  };
	
	  initProxy = function initProxy(vm) {
	    if (hasProxy) {
	      // determine which proxy handler to use
	      var options = vm.$options;
	      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
	      vm._renderProxy = new Proxy(vm, handlers);
	    } else {
	      vm._renderProxy = vm;
	    }
	  };
	}
	
	/*  */
	
	var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
	  this.tag = tag;
	  this.data = data;
	  this.children = children;
	  this.text = text;
	  this.elm = elm;
	  this.ns = undefined;
	  this.context = context;
	  this.functionalContext = undefined;
	  this.key = data && data.key;
	  this.componentOptions = componentOptions;
	  this.componentInstance = undefined;
	  this.parent = undefined;
	  this.raw = false;
	  this.isStatic = false;
	  this.isRootInsert = true;
	  this.isComment = false;
	  this.isCloned = false;
	  this.isOnce = false;
	  this.asyncFactory = asyncFactory;
	  this.asyncMeta = undefined;
	  this.isAsyncPlaceholder = false;
	};
	
	var prototypeAccessors = { child: {} };
	
	// DEPRECATED: alias for componentInstance for backwards compat.
	/* istanbul ignore next */
	prototypeAccessors.child.get = function () {
	  return this.componentInstance;
	};
	
	Object.defineProperties(VNode.prototype, prototypeAccessors);
	
	var createEmptyVNode = function createEmptyVNode(text) {
	  if (text === void 0) text = '';
	
	  var node = new VNode();
	  node.text = text;
	  node.isComment = true;
	  return node;
	};
	
	function createTextVNode(val) {
	  return new VNode(undefined, undefined, undefined, String(val));
	}
	
	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode(vnode) {
	  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
	  cloned.ns = vnode.ns;
	  cloned.isStatic = vnode.isStatic;
	  cloned.key = vnode.key;
	  cloned.isComment = vnode.isComment;
	  cloned.isCloned = true;
	  return cloned;
	}
	
	function cloneVNodes(vnodes) {
	  var len = vnodes.length;
	  var res = new Array(len);
	  for (var i = 0; i < len; i++) {
	    res[i] = cloneVNode(vnodes[i]);
	  }
	  return res;
	}
	
	/*  */
	
	var normalizeEvent = cached(function (name) {
	  var passive = name.charAt(0) === '&';
	  name = passive ? name.slice(1) : name;
	  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
	  name = once$$1 ? name.slice(1) : name;
	  var capture = name.charAt(0) === '!';
	  name = capture ? name.slice(1) : name;
	  return {
	    name: name,
	    once: once$$1,
	    capture: capture,
	    passive: passive
	  };
	});
	
	function createFnInvoker(fns) {
	  function invoker() {
	    var arguments$1 = arguments;
	
	    var fns = invoker.fns;
	    if (Array.isArray(fns)) {
	      var cloned = fns.slice();
	      for (var i = 0; i < cloned.length; i++) {
	        cloned[i].apply(null, arguments$1);
	      }
	    } else {
	      // return handler return value for single handlers
	      return fns.apply(null, arguments);
	    }
	  }
	  invoker.fns = fns;
	  return invoker;
	}
	
	function updateListeners(on, oldOn, add, remove$$1, vm) {
	  var name, cur, old, event;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    event = normalizeEvent(name);
	    if (isUndef(cur)) {
	      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
	    } else if (isUndef(old)) {
	      if (isUndef(cur.fns)) {
	        cur = on[name] = createFnInvoker(cur);
	      }
	      add(event.name, cur, event.once, event.capture, event.passive);
	    } else if (cur !== old) {
	      old.fns = cur;
	      on[name] = old;
	    }
	  }
	  for (name in oldOn) {
	    if (isUndef(on[name])) {
	      event = normalizeEvent(name);
	      remove$$1(event.name, oldOn[name], event.capture);
	    }
	  }
	}
	
	/*  */
	
	function mergeVNodeHook(def, hookKey, hook) {
	  var invoker;
	  var oldHook = def[hookKey];
	
	  function wrappedHook() {
	    hook.apply(this, arguments);
	    // important: remove merged hook to ensure it's called only once
	    // and prevent memory leak
	    remove(invoker.fns, wrappedHook);
	  }
	
	  if (isUndef(oldHook)) {
	    // no existing hook
	    invoker = createFnInvoker([wrappedHook]);
	  } else {
	    /* istanbul ignore if */
	    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
	      // already a merged invoker
	      invoker = oldHook;
	      invoker.fns.push(wrappedHook);
	    } else {
	      // existing plain hook
	      invoker = createFnInvoker([oldHook, wrappedHook]);
	    }
	  }
	
	  invoker.merged = true;
	  def[hookKey] = invoker;
	}
	
	/*  */
	
	function extractPropsFromVNodeData(data, Ctor, tag) {
	  // we are only extracting raw values here.
	  // validation and default values are handled in the child
	  // component itself.
	  var propOptions = Ctor.options.props;
	  if (isUndef(propOptions)) {
	    return;
	  }
	  var res = {};
	  var attrs = data.attrs;
	  var props = data.props;
	  if (isDef(attrs) || isDef(props)) {
	    for (var key in propOptions) {
	      var altKey = hyphenate(key);
	      if (process.env.NODE_ENV !== 'production') {
	        var keyInLowerCase = key.toLowerCase();
	        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
	          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
	        }
	      }
	      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
	    }
	  }
	  return res;
	}
	
	function checkProp(res, hash, key, altKey, preserve) {
	  if (isDef(hash)) {
	    if (hasOwn(hash, key)) {
	      res[key] = hash[key];
	      if (!preserve) {
	        delete hash[key];
	      }
	      return true;
	    } else if (hasOwn(hash, altKey)) {
	      res[key] = hash[altKey];
	      if (!preserve) {
	        delete hash[altKey];
	      }
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	// The template compiler attempts to minimize the need for normalization by
	// statically analyzing the template at compile time.
	//
	// For plain HTML markup, normalization can be completely skipped because the
	// generated render function is guaranteed to return Array<VNode>. There are
	// two cases where extra normalization is needed:
	
	// 1. When the children contains components - because a functional component
	// may return an Array instead of a single root. In this case, just a simple
	// normalization is needed - if any child is an Array, we flatten the whole
	// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
	// because functional components already normalize their own children.
	function simpleNormalizeChildren(children) {
	  for (var i = 0; i < children.length; i++) {
	    if (Array.isArray(children[i])) {
	      return Array.prototype.concat.apply([], children);
	    }
	  }
	  return children;
	}
	
	// 2. When the children contains constructs that always generated nested Arrays,
	// e.g. <template>, <slot>, v-for, or when the children is provided by user
	// with hand-written render functions / JSX. In such cases a full normalization
	// is needed to cater to all possible types of children values.
	function normalizeChildren(children) {
	  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
	}
	
	function isTextNode(node) {
	  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
	}
	
	function normalizeArrayChildren(children, nestedIndex) {
	  var res = [];
	  var i, c, last;
	  for (i = 0; i < children.length; i++) {
	    c = children[i];
	    if (isUndef(c) || typeof c === 'boolean') {
	      continue;
	    }
	    last = res[res.length - 1];
	    //  nested
	    if (Array.isArray(c)) {
	      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
	    } else if (isPrimitive(c)) {
	      if (isTextNode(last)) {
	        // merge adjacent text nodes
	        // this is necessary for SSR hydration because text nodes are
	        // essentially merged when rendered to HTML strings
	        last.text += String(c);
	      } else if (c !== '') {
	        // convert primitive to vnode
	        res.push(createTextVNode(c));
	      }
	    } else {
	      if (isTextNode(c) && isTextNode(last)) {
	        // merge adjacent text nodes
	        res[res.length - 1] = createTextVNode(last.text + c.text);
	      } else {
	        // default key for nested array children (likely generated by v-for)
	        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
	          c.key = "__vlist" + nestedIndex + "_" + i + "__";
	        }
	        res.push(c);
	      }
	    }
	  }
	  return res;
	}
	
	/*  */
	
	function ensureCtor(comp, base) {
	  if (comp.__esModule && comp.default) {
	    comp = comp.default;
	  }
	  return isObject(comp) ? base.extend(comp) : comp;
	}
	
	function createAsyncPlaceholder(factory, data, context, children, tag) {
	  var node = createEmptyVNode();
	  node.asyncFactory = factory;
	  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
	  return node;
	}
	
	function resolveAsyncComponent(factory, baseCtor, context) {
	  if (isTrue(factory.error) && isDef(factory.errorComp)) {
	    return factory.errorComp;
	  }
	
	  if (isDef(factory.resolved)) {
	    return factory.resolved;
	  }
	
	  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
	    return factory.loadingComp;
	  }
	
	  if (isDef(factory.contexts)) {
	    // already pending
	    factory.contexts.push(context);
	  } else {
	    var contexts = factory.contexts = [context];
	    var sync = true;
	
	    var forceRender = function forceRender() {
	      for (var i = 0, l = contexts.length; i < l; i++) {
	        contexts[i].$forceUpdate();
	      }
	    };
	
	    var resolve = once(function (res) {
	      // cache resolved
	      factory.resolved = ensureCtor(res, baseCtor);
	      // invoke callbacks only if this is not a synchronous resolve
	      // (async resolves are shimmed as synchronous during SSR)
	      if (!sync) {
	        forceRender();
	      }
	    });
	
	    var reject = once(function (reason) {
	      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
	      if (isDef(factory.errorComp)) {
	        factory.error = true;
	        forceRender();
	      }
	    });
	
	    var res = factory(resolve, reject);
	
	    if (isObject(res)) {
	      if (typeof res.then === 'function') {
	        // () => Promise
	        if (isUndef(factory.resolved)) {
	          res.then(resolve, reject);
	        }
	      } else if (isDef(res.component) && typeof res.component.then === 'function') {
	        res.component.then(resolve, reject);
	
	        if (isDef(res.error)) {
	          factory.errorComp = ensureCtor(res.error, baseCtor);
	        }
	
	        if (isDef(res.loading)) {
	          factory.loadingComp = ensureCtor(res.loading, baseCtor);
	          if (res.delay === 0) {
	            factory.loading = true;
	          } else {
	            setTimeout(function () {
	              if (isUndef(factory.resolved) && isUndef(factory.error)) {
	                factory.loading = true;
	                forceRender();
	              }
	            }, res.delay || 200);
	          }
	        }
	
	        if (isDef(res.timeout)) {
	          setTimeout(function () {
	            if (isUndef(factory.resolved)) {
	              reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
	            }
	          }, res.timeout);
	        }
	      }
	    }
	
	    sync = false;
	    // return in case resolved synchronously
	    return factory.loading ? factory.loadingComp : factory.resolved;
	  }
	}
	
	/*  */
	
	function getFirstComponentChild(children) {
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      var c = children[i];
	      if (isDef(c) && isDef(c.componentOptions)) {
	        return c;
	      }
	    }
	  }
	}
	
	/*  */
	
	/*  */
	
	function initEvents(vm) {
	  vm._events = Object.create(null);
	  vm._hasHookEvent = false;
	  // init parent attached events
	  var listeners = vm.$options._parentListeners;
	  if (listeners) {
	    updateComponentListeners(vm, listeners);
	  }
	}
	
	var target;
	
	function add(event, fn, once$$1) {
	  if (once$$1) {
	    target.$once(event, fn);
	  } else {
	    target.$on(event, fn);
	  }
	}
	
	function remove$1(event, fn) {
	  target.$off(event, fn);
	}
	
	function updateComponentListeners(vm, listeners, oldListeners) {
	  target = vm;
	  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
	}
	
	function eventsMixin(Vue) {
	  var hookRE = /^hook:/;
	  Vue.prototype.$on = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    if (Array.isArray(event)) {
	      for (var i = 0, l = event.length; i < l; i++) {
	        this$1.$on(event[i], fn);
	      }
	    } else {
	      (vm._events[event] || (vm._events[event] = [])).push(fn);
	      // optimize hook:event cost by using a boolean flag marked at registration
	      // instead of a hash lookup
	      if (hookRE.test(event)) {
	        vm._hasHookEvent = true;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$once = function (event, fn) {
	    var vm = this;
	    function on() {
	      vm.$off(event, on);
	      fn.apply(vm, arguments);
	    }
	    on.fn = fn;
	    vm.$on(event, on);
	    return vm;
	  };
	
	  Vue.prototype.$off = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    // all
	    if (!arguments.length) {
	      vm._events = Object.create(null);
	      return vm;
	    }
	    // array of events
	    if (Array.isArray(event)) {
	      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
	        this$1.$off(event[i$1], fn);
	      }
	      return vm;
	    }
	    // specific event
	    var cbs = vm._events[event];
	    if (!cbs) {
	      return vm;
	    }
	    if (arguments.length === 1) {
	      vm._events[event] = null;
	      return vm;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$emit = function (event) {
	    var vm = this;
	    if (process.env.NODE_ENV !== 'production') {
	      var lowerCaseEvent = event.toLowerCase();
	      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
	        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
	      }
	    }
	    var cbs = vm._events[event];
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        try {
	          cbs[i].apply(vm, args);
	        } catch (e) {
	          handleError(e, vm, "event handler for \"" + event + "\"");
	        }
	      }
	    }
	    return vm;
	  };
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving raw children VNodes into a slot object.
	 */
	function resolveSlots(children, context) {
	  var slots = {};
	  if (!children) {
	    return slots;
	  }
	  var defaultSlot = [];
	  for (var i = 0, l = children.length; i < l; i++) {
	    var child = children[i];
	    // named slots should only be respected if the vnode was rendered in the
	    // same context.
	    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {
	      var name = child.data.slot;
	      var slot = slots[name] || (slots[name] = []);
	      if (child.tag === 'template') {
	        slot.push.apply(slot, child.children);
	      } else {
	        slot.push(child);
	      }
	    } else {
	      defaultSlot.push(child);
	    }
	  }
	  // ignore whitespace
	  if (!defaultSlot.every(isWhitespace)) {
	    slots.default = defaultSlot;
	  }
	  return slots;
	}
	
	function isWhitespace(node) {
	  return node.isComment || node.text === ' ';
	}
	
	function resolveScopedSlots(fns, // see flow/vnode
	res) {
	  res = res || {};
	  for (var i = 0; i < fns.length; i++) {
	    if (Array.isArray(fns[i])) {
	      resolveScopedSlots(fns[i], res);
	    } else {
	      res[fns[i].key] = fns[i].fn;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var activeInstance = null;
	var isUpdatingChildComponent = false;
	
	function initLifecycle(vm) {
	  var options = vm.$options;
	
	  // locate first non-abstract parent
	  var parent = options.parent;
	  if (parent && !options.abstract) {
	    while (parent.$options.abstract && parent.$parent) {
	      parent = parent.$parent;
	    }
	    parent.$children.push(vm);
	  }
	
	  vm.$parent = parent;
	  vm.$root = parent ? parent.$root : vm;
	
	  vm.$children = [];
	  vm.$refs = {};
	
	  vm._watcher = null;
	  vm._inactive = null;
	  vm._directInactive = false;
	  vm._isMounted = false;
	  vm._isDestroyed = false;
	  vm._isBeingDestroyed = false;
	}
	
	function lifecycleMixin(Vue) {
	  Vue.prototype._update = function (vnode, hydrating) {
	    var vm = this;
	    if (vm._isMounted) {
	      callHook(vm, 'beforeUpdate');
	    }
	    var prevEl = vm.$el;
	    var prevVnode = vm._vnode;
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    vm._vnode = vnode;
	    // Vue.prototype.__patch__ is injected in entry points
	    // based on the rendering backend used.
	    if (!prevVnode) {
	      // initial render
	      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
	      , vm.$options._parentElm, vm.$options._refElm);
	      // no need for the ref nodes after initial patch
	      // this prevents keeping a detached DOM tree in memory (#5851)
	      vm.$options._parentElm = vm.$options._refElm = null;
	    } else {
	      // updates
	      vm.$el = vm.__patch__(prevVnode, vnode);
	    }
	    activeInstance = prevActiveInstance;
	    // update __vue__ reference
	    if (prevEl) {
	      prevEl.__vue__ = null;
	    }
	    if (vm.$el) {
	      vm.$el.__vue__ = vm;
	    }
	    // if parent is an HOC, update its $el as well
	    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	      vm.$parent.$el = vm.$el;
	    }
	    // updated hook is called by the scheduler to ensure that children are
	    // updated in a parent's updated hook.
	  };
	
	  Vue.prototype.$forceUpdate = function () {
	    var vm = this;
	    if (vm._watcher) {
	      vm._watcher.update();
	    }
	  };
	
	  Vue.prototype.$destroy = function () {
	    var vm = this;
	    if (vm._isBeingDestroyed) {
	      return;
	    }
	    callHook(vm, 'beforeDestroy');
	    vm._isBeingDestroyed = true;
	    // remove self from parent
	    var parent = vm.$parent;
	    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	      remove(parent.$children, vm);
	    }
	    // teardown watchers
	    if (vm._watcher) {
	      vm._watcher.teardown();
	    }
	    var i = vm._watchers.length;
	    while (i--) {
	      vm._watchers[i].teardown();
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (vm._data.__ob__) {
	      vm._data.__ob__.vmCount--;
	    }
	    // call the last hook...
	    vm._isDestroyed = true;
	    // invoke destroy hooks on current rendered tree
	    vm.__patch__(vm._vnode, null);
	    // fire destroyed hook
	    callHook(vm, 'destroyed');
	    // turn off all instance listeners.
	    vm.$off();
	    // remove __vue__ reference
	    if (vm.$el) {
	      vm.$el.__vue__ = null;
	    }
	  };
	}
	
	function mountComponent(vm, el, hydrating) {
	  vm.$el = el;
	  if (!vm.$options.render) {
	    vm.$options.render = createEmptyVNode;
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
	        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
	      } else {
	        warn('Failed to mount component: template or render function not defined.', vm);
	      }
	    }
	  }
	  callHook(vm, 'beforeMount');
	
	  var updateComponent;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	    updateComponent = function updateComponent() {
	      var name = vm._name;
	      var id = vm._uid;
	      var startTag = "vue-perf-start:" + id;
	      var endTag = "vue-perf-end:" + id;
	
	      mark(startTag);
	      var vnode = vm._render();
	      mark(endTag);
	      measure(name + " render", startTag, endTag);
	
	      mark(startTag);
	      vm._update(vnode, hydrating);
	      mark(endTag);
	      measure(name + " patch", startTag, endTag);
	    };
	  } else {
	    updateComponent = function updateComponent() {
	      vm._update(vm._render(), hydrating);
	    };
	  }
	
	  vm._watcher = new Watcher(vm, updateComponent, noop);
	  hydrating = false;
	
	  // manually mounted instance, call mounted on self
	  // mounted is called for render-created child components in its inserted hook
	  if (vm.$vnode == null) {
	    vm._isMounted = true;
	    callHook(vm, 'mounted');
	  }
	  return vm;
	}
	
	function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = true;
	  }
	
	  // determine whether component has slot children
	  // we need to do this before overwriting $options._renderChildren
	  var hasChildren = !!(renderChildren || // has new static slots
	  vm.$options._renderChildren || // has old static slots
	  parentVnode.data.scopedSlots || // has new scoped slots
	  vm.$scopedSlots !== emptyObject // has old scoped slots
	  );
	
	  vm.$options._parentVnode = parentVnode;
	  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
	
	  if (vm._vnode) {
	    // update child tree's parent
	    vm._vnode.parent = parentVnode;
	  }
	  vm.$options._renderChildren = renderChildren;
	
	  // update $attrs and $listensers hash
	  // these are also reactive so they may trigger child update if the child
	  // used them during render
	  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
	  vm.$listeners = listeners;
	
	  // update props
	  if (propsData && vm.$options.props) {
	    observerState.shouldConvert = false;
	    var props = vm._props;
	    var propKeys = vm.$options._propKeys || [];
	    for (var i = 0; i < propKeys.length; i++) {
	      var key = propKeys[i];
	      props[key] = validateProp(key, vm.$options.props, propsData, vm);
	    }
	    observerState.shouldConvert = true;
	    // keep a copy of raw propsData
	    vm.$options.propsData = propsData;
	  }
	
	  // update listeners
	  if (listeners) {
	    var oldListeners = vm.$options._parentListeners;
	    vm.$options._parentListeners = listeners;
	    updateComponentListeners(vm, listeners, oldListeners);
	  }
	  // resolve slots + force update if has children
	  if (hasChildren) {
	    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
	    vm.$forceUpdate();
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = false;
	  }
	}
	
	function isInInactiveTree(vm) {
	  while (vm && (vm = vm.$parent)) {
	    if (vm._inactive) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function activateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = false;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  } else if (vm._directInactive) {
	    return;
	  }
	  if (vm._inactive || vm._inactive === null) {
	    vm._inactive = false;
	    for (var i = 0; i < vm.$children.length; i++) {
	      activateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'activated');
	  }
	}
	
	function deactivateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = true;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  }
	  if (!vm._inactive) {
	    vm._inactive = true;
	    for (var i = 0; i < vm.$children.length; i++) {
	      deactivateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'deactivated');
	  }
	}
	
	function callHook(vm, hook) {
	  var handlers = vm.$options[hook];
	  if (handlers) {
	    for (var i = 0, j = handlers.length; i < j; i++) {
	      try {
	        handlers[i].call(vm);
	      } catch (e) {
	        handleError(e, vm, hook + " hook");
	      }
	    }
	  }
	  if (vm._hasHookEvent) {
	    vm.$emit('hook:' + hook);
	  }
	}
	
	/*  */
	
	var MAX_UPDATE_COUNT = 100;
	
	var queue = [];
	var activatedChildren = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;
	
	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState() {
	  index = queue.length = activatedChildren.length = 0;
	  has = {};
	  if (process.env.NODE_ENV !== 'production') {
	    circular = {};
	  }
	  waiting = flushing = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue() {
	  flushing = true;
	  var watcher, id;
	
	  // Sort queue before flush.
	  // This ensures that:
	  // 1. Components are updated from parent to child. (because parent is always
	  //    created before the child)
	  // 2. A component's user watchers are run before its render watcher (because
	  //    user watchers are created before the render watcher)
	  // 3. If a component is destroyed during a parent component's watcher run,
	  //    its watchers can be skipped.
	  queue.sort(function (a, b) {
	    return a.id - b.id;
	  });
	
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (index = 0; index < queue.length; index++) {
	    watcher = queue[index];
	    id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > MAX_UPDATE_COUNT) {
	        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
	        break;
	      }
	    }
	  }
	
	  // keep copies of post queues before resetting state
	  var activatedQueue = activatedChildren.slice();
	  var updatedQueue = queue.slice();
	
	  resetSchedulerState();
	
	  // call component updated and activated hooks
	  callActivatedHooks(activatedQueue);
	  callUpdatedHooks(updatedQueue);
	
	  // devtool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }
	}
	
	function callUpdatedHooks(queue) {
	  var i = queue.length;
	  while (i--) {
	    var watcher = queue[i];
	    var vm = watcher.vm;
	    if (vm._watcher === watcher && vm._isMounted) {
	      callHook(vm, 'updated');
	    }
	  }
	}
	
	/**
	 * Queue a kept-alive component that was activated during patch.
	 * The queue will be processed after the entire tree has been patched.
	 */
	function queueActivatedComponent(vm) {
	  // setting _inactive to false here so that a render function can
	  // rely on checking whether it's in an inactive tree (e.g. router-view)
	  vm._inactive = false;
	  activatedChildren.push(vm);
	}
	
	function callActivatedHooks(queue) {
	  for (var i = 0; i < queue.length; i++) {
	    queue[i]._inactive = true;
	    activateChildComponent(queue[i], true /* true */);
	  }
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    has[id] = true;
	    if (!flushing) {
	      queue.push(watcher);
	    } else {
	      // if already flushing, splice the watcher based on its id
	      // if already past its id, it will be run next immediately.
	      var i = queue.length - 1;
	      while (i > index && queue[i].id > watcher.id) {
	        i--;
	      }
	      queue.splice(i + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushSchedulerQueue);
	    }
	  }
	}
	
	/*  */
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 */
	var Watcher = function Watcher(vm, expOrFn, cb, options) {
	  this.vm = vm;
	  vm._watchers.push(this);
	  // options
	  if (options) {
	    this.deep = !!options.deep;
	    this.user = !!options.user;
	    this.lazy = !!options.lazy;
	    this.sync = !!options.sync;
	  } else {
	    this.deep = this.user = this.lazy = this.sync = false;
	  }
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
	  // parse expression for getter
	  if (typeof expOrFn === 'function') {
	    this.getter = expOrFn;
	  } else {
	    this.getter = parsePath(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
	    }
	  }
	  this.value = this.lazy ? undefined : this.get();
	};
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	Watcher.prototype.get = function get() {
	  pushTarget(this);
	  var value;
	  var vm = this.vm;
	  try {
	    value = this.getter.call(vm, vm);
	  } catch (e) {
	    if (this.user) {
	      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
	    } else {
	      throw e;
	    }
	  } finally {
	    // "touch" every property so they are all tracked as
	    // dependencies for deep watching
	    if (this.deep) {
	      traverse(value);
	    }
	    popTarget();
	    this.cleanupDeps();
	  }
	  return value;
	};
	
	/**
	 * Add a dependency to this directive.
	 */
	Watcher.prototype.addDep = function addDep(dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	Watcher.prototype.cleanupDeps = function cleanupDeps() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this$1.deps[i];
	    if (!this$1.newDepIds.has(dep.id)) {
	      dep.removeSub(this$1);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 */
	Watcher.prototype.update = function update() {
	  /* istanbul ignore else */
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync) {
	    this.run();
	  } else {
	    queueWatcher(this);
	  }
	};
	
	/**
	 * Scheduler job interface.
	 * Will be called by the scheduler.
	 */
	Watcher.prototype.run = function run() {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated.
	    isObject(value) || this.deep) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      if (this.user) {
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	Watcher.prototype.evaluate = function evaluate() {
	  this.value = this.get();
	  this.dirty = false;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	Watcher.prototype.depend = function depend() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    this$1.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subscriber list.
	 */
	Watcher.prototype.teardown = function teardown() {
	  var this$1 = this;
	
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed.
	    if (!this.vm._isBeingDestroyed) {
	      remove(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this$1.deps[i].removeSub(this$1);
	    }
	    this.active = false;
	  }
	};
	
	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	var seenObjects = new _Set();
	function traverse(val) {
	  seenObjects.clear();
	  _traverse(val, seenObjects);
	}
	
	function _traverse(val, seen) {
	  var i, keys;
	  var isA = Array.isArray(val);
	  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
	    return;
	  }
	  if (val.__ob__) {
	    var depId = val.__ob__.dep.id;
	    if (seen.has(depId)) {
	      return;
	    }
	    seen.add(depId);
	  }
	  if (isA) {
	    i = val.length;
	    while (i--) {
	      _traverse(val[i], seen);
	    }
	  } else {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      _traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	/*  */
	
	var sharedPropertyDefinition = {
	  enumerable: true,
	  configurable: true,
	  get: noop,
	  set: noop
	};
	
	function proxy(target, sourceKey, key) {
	  sharedPropertyDefinition.get = function proxyGetter() {
	    return this[sourceKey][key];
	  };
	  sharedPropertyDefinition.set = function proxySetter(val) {
	    this[sourceKey][key] = val;
	  };
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function initState(vm) {
	  vm._watchers = [];
	  var opts = vm.$options;
	  if (opts.props) {
	    initProps(vm, opts.props);
	  }
	  if (opts.methods) {
	    initMethods(vm, opts.methods);
	  }
	  if (opts.data) {
	    initData(vm);
	  } else {
	    observe(vm._data = {}, true /* asRootData */);
	  }
	  if (opts.computed) {
	    initComputed(vm, opts.computed);
	  }
	  if (opts.watch && opts.watch !== nativeWatch) {
	    initWatch(vm, opts.watch);
	  }
	}
	
	function checkOptionType(vm, name) {
	  var option = vm.$options[name];
	  if (!isPlainObject(option)) {
	    warn("component option \"" + name + "\" should be an object.", vm);
	  }
	}
	
	function initProps(vm, propsOptions) {
	  var propsData = vm.$options.propsData || {};
	  var props = vm._props = {};
	  // cache prop keys so that future props updates can iterate using Array
	  // instead of dynamic object key enumeration.
	  var keys = vm.$options._propKeys = [];
	  var isRoot = !vm.$parent;
	  // root instance props should be converted
	  observerState.shouldConvert = isRoot;
	  var loop = function loop(key) {
	    keys.push(key);
	    var value = validateProp(key, propsOptions, propsData, vm);
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
	        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
	      }
	      defineReactive$$1(props, key, value, function () {
	        if (vm.$parent && !isUpdatingChildComponent) {
	          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
	        }
	      });
	    } else {
	      defineReactive$$1(props, key, value);
	    }
	    // static props are already proxied on the component's prototype
	    // during Vue.extend(). We only need to proxy props defined at
	    // instantiation here.
	    if (!(key in vm)) {
	      proxy(vm, "_props", key);
	    }
	  };
	
	  for (var key in propsOptions) {
	    loop(key);
	  }observerState.shouldConvert = true;
	}
	
	function initData(vm) {
	  var data = vm.$options.data;
	  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
	  if (!isPlainObject(data)) {
	    data = {};
	    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var props = vm.$options.props;
	  var methods = vm.$options.methods;
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods && hasOwn(methods, key)) {
	        warn("method \"" + key + "\" has already been defined as a data property.", vm);
	      }
	    }
	    if (props && hasOwn(props, key)) {
	      process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
	    } else if (!isReserved(key)) {
	      proxy(vm, "_data", key);
	    }
	  }
	  // observe data
	  observe(data, true /* asRootData */);
	}
	
	function getData(data, vm) {
	  try {
	    return data.call(vm);
	  } catch (e) {
	    handleError(e, vm, "data()");
	    return {};
	  }
	}
	
	var computedWatcherOptions = { lazy: true };
	
	function initComputed(vm, computed) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');
	  var watchers = vm._computedWatchers = Object.create(null);
	
	  for (var key in computed) {
	    var userDef = computed[key];
	    var getter = typeof userDef === 'function' ? userDef : userDef.get;
	    if (process.env.NODE_ENV !== 'production' && getter == null) {
	      warn("Getter is missing for computed property \"" + key + "\".", vm);
	    }
	    // create internal watcher for the computed property.
	    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
	
	    // component-defined computed properties are already defined on the
	    // component prototype. We only need to define computed properties defined
	    // at instantiation here.
	    if (!(key in vm)) {
	      defineComputed(vm, key, userDef);
	    } else if (process.env.NODE_ENV !== 'production') {
	      if (key in vm.$data) {
	        warn("The computed property \"" + key + "\" is already defined in data.", vm);
	      } else if (vm.$options.props && key in vm.$options.props) {
	        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function defineComputed(target, key, userDef) {
	  if (typeof userDef === 'function') {
	    sharedPropertyDefinition.get = createComputedGetter(key);
	    sharedPropertyDefinition.set = noop;
	  } else {
	    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
	    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
	  }
	  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
	    sharedPropertyDefinition.set = function () {
	      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
	    };
	  }
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function createComputedGetter(key) {
	  return function computedGetter() {
	    var watcher = this._computedWatchers && this._computedWatchers[key];
	    if (watcher) {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    }
	  };
	}
	
	function initMethods(vm, methods) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');
	  var props = vm.$options.props;
	  for (var key in methods) {
	    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods[key] == null) {
	        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
	      }
	      if (props && hasOwn(props, key)) {
	        warn("method \"" + key + "\" has already been defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function initWatch(vm, watch) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');
	  for (var key in watch) {
	    var handler = watch[key];
	    if (Array.isArray(handler)) {
	      for (var i = 0; i < handler.length; i++) {
	        createWatcher(vm, key, handler[i]);
	      }
	    } else {
	      createWatcher(vm, key, handler);
	    }
	  }
	}
	
	function createWatcher(vm, keyOrFn, handler, options) {
	  if (isPlainObject(handler)) {
	    options = handler;
	    handler = handler.handler;
	  }
	  if (typeof handler === 'string') {
	    handler = vm[handler];
	  }
	  return vm.$watch(keyOrFn, handler, options);
	}
	
	function stateMixin(Vue) {
	  // flow somehow has problems with directly declared definition object
	  // when using Object.defineProperty, so we have to procedurally build up
	  // the object here.
	  var dataDef = {};
	  dataDef.get = function () {
	    return this._data;
	  };
	  var propsDef = {};
	  propsDef.get = function () {
	    return this._props;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    dataDef.set = function (newData) {
	      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
	    };
	    propsDef.set = function () {
	      warn("$props is readonly.", this);
	    };
	  }
	  Object.defineProperty(Vue.prototype, '$data', dataDef);
	  Object.defineProperty(Vue.prototype, '$props', propsDef);
	
	  Vue.prototype.$set = set;
	  Vue.prototype.$delete = del;
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    if (isPlainObject(cb)) {
	      return createWatcher(vm, expOrFn, cb, options);
	    }
	    options = options || {};
	    options.user = true;
	    var watcher = new Watcher(vm, expOrFn, cb, options);
	    if (options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	}
	
	/*  */
	
	function initProvide(vm) {
	  var provide = vm.$options.provide;
	  if (provide) {
	    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
	  }
	}
	
	function initInjections(vm) {
	  var result = resolveInject(vm.$options.inject, vm);
	  if (result) {
	    observerState.shouldConvert = false;
	    Object.keys(result).forEach(function (key) {
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        defineReactive$$1(vm, key, result[key], function () {
	          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
	        });
	      } else {
	        defineReactive$$1(vm, key, result[key]);
	      }
	    });
	    observerState.shouldConvert = true;
	  }
	}
	
	function resolveInject(inject, vm) {
	  if (inject) {
	    // inject is :any because flow is not smart enough to figure out cached
	    var result = Object.create(null);
	    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
	
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var provideKey = inject[key];
	      var source = vm;
	      while (source) {
	        if (source._provided && provideKey in source._provided) {
	          result[key] = source._provided[provideKey];
	          break;
	        }
	        source = source.$parent;
	      }
	      if (process.env.NODE_ENV !== 'production' && !source) {
	        warn("Injection \"" + key + "\" not found", vm);
	      }
	    }
	    return result;
	  }
	}
	
	/*  */
	
	function createFunctionalComponent(Ctor, propsData, data, context, children) {
	  var props = {};
	  var propOptions = Ctor.options.props;
	  if (isDef(propOptions)) {
	    for (var key in propOptions) {
	      props[key] = validateProp(key, propOptions, propsData || {});
	    }
	  } else {
	    if (isDef(data.attrs)) {
	      mergeProps(props, data.attrs);
	    }
	    if (isDef(data.props)) {
	      mergeProps(props, data.props);
	    }
	  }
	  // ensure the createElement function in functional components
	  // gets a unique context - this is necessary for correct named slot check
	  var _context = Object.create(context);
	  var h = function h(a, b, c, d) {
	    return createElement(_context, a, b, c, d, true);
	  };
	  var vnode = Ctor.options.render.call(null, h, {
	    data: data,
	    props: props,
	    children: children,
	    parent: context,
	    listeners: data.on || {},
	    injections: resolveInject(Ctor.options.inject, context),
	    slots: function slots() {
	      return resolveSlots(children, context);
	    }
	  });
	  if (vnode instanceof VNode) {
	    vnode.functionalContext = context;
	    vnode.functionalOptions = Ctor.options;
	    if (data.slot) {
	      (vnode.data || (vnode.data = {})).slot = data.slot;
	    }
	  }
	  return vnode;
	}
	
	function mergeProps(to, from) {
	  for (var key in from) {
	    to[camelize(key)] = from[key];
	  }
	}
	
	/*  */
	
	// hooks to be invoked on component VNodes during patch
	var componentVNodeHooks = {
	  init: function init(vnode, hydrating, parentElm, refElm) {
	    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
	      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
	      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	    } else if (vnode.data.keepAlive) {
	      // kept-alive components, treat as a patch
	      var mountedNode = vnode; // work around flow
	      componentVNodeHooks.prepatch(mountedNode, mountedNode);
	    }
	  },
	
	  prepatch: function prepatch(oldVnode, vnode) {
	    var options = vnode.componentOptions;
	    var child = vnode.componentInstance = oldVnode.componentInstance;
	    updateChildComponent(child, options.propsData, // updated props
	    options.listeners, // updated listeners
	    vnode, // new parent vnode
	    options.children // new children
	    );
	  },
	
	  insert: function insert(vnode) {
	    var context = vnode.context;
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isMounted) {
	      componentInstance._isMounted = true;
	      callHook(componentInstance, 'mounted');
	    }
	    if (vnode.data.keepAlive) {
	      if (context._isMounted) {
	        // vue-router#1212
	        // During updates, a kept-alive component's child components may
	        // change, so directly walking the tree here may call activated hooks
	        // on incorrect children. Instead we push them into a queue which will
	        // be processed after the whole patch process ended.
	        queueActivatedComponent(componentInstance);
	      } else {
	        activateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  },
	
	  destroy: function destroy(vnode) {
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isDestroyed) {
	      if (!vnode.data.keepAlive) {
	        componentInstance.$destroy();
	      } else {
	        deactivateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  }
	};
	
	var hooksToMerge = Object.keys(componentVNodeHooks);
	
	function createComponent(Ctor, data, context, children, tag) {
	  if (isUndef(Ctor)) {
	    return;
	  }
	
	  var baseCtor = context.$options._base;
	
	  // plain options object: turn it into a constructor
	  if (isObject(Ctor)) {
	    Ctor = baseCtor.extend(Ctor);
	  }
	
	  // if at this stage it's not a constructor or an async component factory,
	  // reject.
	  if (typeof Ctor !== 'function') {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Invalid Component definition: " + String(Ctor), context);
	    }
	    return;
	  }
	
	  // async component
	  var asyncFactory;
	  if (isUndef(Ctor.cid)) {
	    asyncFactory = Ctor;
	    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
	    if (Ctor === undefined) {
	      // return a placeholder node for async component, which is rendered
	      // as a comment node but preserves all the raw information for the node.
	      // the information will be used for async server-rendering and hydration.
	      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
	    }
	  }
	
	  data = data || {};
	
	  // resolve constructor options in case global mixins are applied after
	  // component constructor creation
	  resolveConstructorOptions(Ctor);
	
	  // transform component v-model data into props & events
	  if (isDef(data.model)) {
	    transformModel(Ctor.options, data);
	  }
	
	  // extract props
	  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
	
	  // functional component
	  if (isTrue(Ctor.options.functional)) {
	    return createFunctionalComponent(Ctor, propsData, data, context, children);
	  }
	
	  // extract listeners, since these needs to be treated as
	  // child component listeners instead of DOM listeners
	  var listeners = data.on;
	  // replace with listeners with .native modifier
	  // so it gets processed during parent component patch.
	  data.on = data.nativeOn;
	
	  if (isTrue(Ctor.options.abstract)) {
	    // abstract components do not keep anything
	    // other than props & listeners & slot
	
	    // work around flow
	    var slot = data.slot;
	    data = {};
	    if (slot) {
	      data.slot = slot;
	    }
	  }
	
	  // merge component management hooks onto the placeholder node
	  mergeHooks(data);
	
	  // return a placeholder vnode
	  var name = Ctor.options.name || tag;
	  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
	  return vnode;
	}
	
	function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
	parent, // activeInstance in lifecycle state
	parentElm, refElm) {
	  var vnodeComponentOptions = vnode.componentOptions;
	  var options = {
	    _isComponent: true,
	    parent: parent,
	    propsData: vnodeComponentOptions.propsData,
	    _componentTag: vnodeComponentOptions.tag,
	    _parentVnode: vnode,
	    _parentListeners: vnodeComponentOptions.listeners,
	    _renderChildren: vnodeComponentOptions.children,
	    _parentElm: parentElm || null,
	    _refElm: refElm || null
	  };
	  // check inline-template render functions
	  var inlineTemplate = vnode.data.inlineTemplate;
	  if (isDef(inlineTemplate)) {
	    options.render = inlineTemplate.render;
	    options.staticRenderFns = inlineTemplate.staticRenderFns;
	  }
	  return new vnodeComponentOptions.Ctor(options);
	}
	
	function mergeHooks(data) {
	  if (!data.hook) {
	    data.hook = {};
	  }
	  for (var i = 0; i < hooksToMerge.length; i++) {
	    var key = hooksToMerge[i];
	    var fromParent = data.hook[key];
	    var ours = componentVNodeHooks[key];
	    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
	  }
	}
	
	function mergeHook$1(one, two) {
	  return function (a, b, c, d) {
	    one(a, b, c, d);
	    two(a, b, c, d);
	  };
	}
	
	// transform component v-model info (value and callback) into
	// prop and event handler respectively.
	function transformModel(options, data) {
	  var prop = options.model && options.model.prop || 'value';
	  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
	  var on = data.on || (data.on = {});
	  if (isDef(on[event])) {
	    on[event] = [data.model.callback].concat(on[event]);
	  } else {
	    on[event] = data.model.callback;
	  }
	}
	
	/*  */
	
	var SIMPLE_NORMALIZE = 1;
	var ALWAYS_NORMALIZE = 2;
	
	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
	  if (Array.isArray(data) || isPrimitive(data)) {
	    normalizationType = children;
	    children = data;
	    data = undefined;
	  }
	  if (isTrue(alwaysNormalize)) {
	    normalizationType = ALWAYS_NORMALIZE;
	  }
	  return _createElement(context, tag, data, children, normalizationType);
	}
	
	function _createElement(context, tag, data, children, normalizationType) {
	  if (isDef(data) && isDef(data.__ob__)) {
	    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
	    return createEmptyVNode();
	  }
	  // object syntax in v-bind
	  if (isDef(data) && isDef(data.is)) {
	    tag = data.is;
	  }
	  if (!tag) {
	    // in case of component :is set to falsy value
	    return createEmptyVNode();
	  }
	  // warn against non-primitive key
	  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
	    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
	  }
	  // support single function children as default scoped slot
	  if (Array.isArray(children) && typeof children[0] === 'function') {
	    data = data || {};
	    data.scopedSlots = { default: children[0] };
	    children.length = 0;
	  }
	  if (normalizationType === ALWAYS_NORMALIZE) {
	    children = normalizeChildren(children);
	  } else if (normalizationType === SIMPLE_NORMALIZE) {
	    children = simpleNormalizeChildren(children);
	  }
	  var vnode, ns;
	  if (typeof tag === 'string') {
	    var Ctor;
	    ns = config.getTagNamespace(tag);
	    if (config.isReservedTag(tag)) {
	      // platform built-in elements
	      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
	    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
	      // component
	      vnode = createComponent(Ctor, data, context, children, tag);
	    } else {
	      // unknown or unlisted namespaced elements
	      // check at runtime because it may get assigned a namespace when its
	      // parent normalizes children
	      vnode = new VNode(tag, data, children, undefined, undefined, context);
	    }
	  } else {
	    // direct component options / constructor
	    vnode = createComponent(tag, data, context, children);
	  }
	  if (isDef(vnode)) {
	    if (ns) {
	      applyNS(vnode, ns);
	    }
	    return vnode;
	  } else {
	    return createEmptyVNode();
	  }
	}
	
	function applyNS(vnode, ns) {
	  vnode.ns = ns;
	  if (vnode.tag === 'foreignObject') {
	    // use default namespace inside foreignObject
	    return;
	  }
	  if (isDef(vnode.children)) {
	    for (var i = 0, l = vnode.children.length; i < l; i++) {
	      var child = vnode.children[i];
	      if (isDef(child.tag) && isUndef(child.ns)) {
	        applyNS(child, ns);
	      }
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering v-for lists.
	 */
	function renderList(val, render) {
	  var ret, i, l, keys, key;
	  if (Array.isArray(val) || typeof val === 'string') {
	    ret = new Array(val.length);
	    for (i = 0, l = val.length; i < l; i++) {
	      ret[i] = render(val[i], i);
	    }
	  } else if (typeof val === 'number') {
	    ret = new Array(val);
	    for (i = 0; i < val; i++) {
	      ret[i] = render(i + 1, i);
	    }
	  } else if (isObject(val)) {
	    keys = Object.keys(val);
	    ret = new Array(keys.length);
	    for (i = 0, l = keys.length; i < l; i++) {
	      key = keys[i];
	      ret[i] = render(val[key], key, i);
	    }
	  }
	  if (isDef(ret)) {
	    ret._isVList = true;
	  }
	  return ret;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering <slot>
	 */
	function renderSlot(name, fallback, props, bindObject) {
	  var scopedSlotFn = this.$scopedSlots[name];
	  if (scopedSlotFn) {
	    // scoped slot
	    props = props || {};
	    if (bindObject) {
	      props = extend(extend({}, bindObject), props);
	    }
	    return scopedSlotFn(props) || fallback;
	  } else {
	    var slotNodes = this.$slots[name];
	    // warn duplicate slot usage
	    if (slotNodes && process.env.NODE_ENV !== 'production') {
	      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
	      slotNodes._rendered = true;
	    }
	    return slotNodes || fallback;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving filters
	 */
	function resolveFilter(id) {
	  return resolveAsset(this.$options, 'filters', id, true) || identity;
	}
	
	/*  */
	
	/**
	 * Runtime helper for checking keyCodes from config.
	 */
	function checkKeyCodes(eventKeyCode, key, builtInAlias) {
	  var keyCodes = config.keyCodes[key] || builtInAlias;
	  if (Array.isArray(keyCodes)) {
	    return keyCodes.indexOf(eventKeyCode) === -1;
	  } else {
	    return keyCodes !== eventKeyCode;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for merging v-bind="object" into a VNode's data.
	 */
	function bindObjectProps(data, tag, value, asProp, isSync) {
	  if (value) {
	    if (!isObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
	    } else {
	      if (Array.isArray(value)) {
	        value = toObject(value);
	      }
	      var hash;
	      var loop = function loop(key) {
	        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
	          hash = data;
	        } else {
	          var type = data.attrs && data.attrs.type;
	          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
	        }
	        if (!(key in hash)) {
	          hash[key] = value[key];
	
	          if (isSync) {
	            var on = data.on || (data.on = {});
	            on["update:" + key] = function ($event) {
	              value[key] = $event;
	            };
	          }
	        }
	      };
	
	      for (var key in value) {
	        loop(key);
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering static trees.
	 */
	function renderStatic(index, isInFor) {
	  var tree = this._staticTrees[index];
	  // if has already-rendered static tree and not inside v-for,
	  // we can reuse the same tree by doing a shallow clone.
	  if (tree && !isInFor) {
	    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
	  }
	  // otherwise, render a fresh tree.
	  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
	  markStatic(tree, "__static__" + index, false);
	  return tree;
	}
	
	/**
	 * Runtime helper for v-once.
	 * Effectively it means marking the node as static with a unique key.
	 */
	function markOnce(tree, index, key) {
	  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
	  return tree;
	}
	
	function markStatic(tree, key, isOnce) {
	  if (Array.isArray(tree)) {
	    for (var i = 0; i < tree.length; i++) {
	      if (tree[i] && typeof tree[i] !== 'string') {
	        markStaticNode(tree[i], key + "_" + i, isOnce);
	      }
	    }
	  } else {
	    markStaticNode(tree, key, isOnce);
	  }
	}
	
	function markStaticNode(node, key, isOnce) {
	  node.isStatic = true;
	  node.key = key;
	  node.isOnce = isOnce;
	}
	
	/*  */
	
	function bindObjectListeners(data, value) {
	  if (value) {
	    if (!isPlainObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
	    } else {
	      var on = data.on = data.on ? extend({}, data.on) : {};
	      for (var key in value) {
	        var existing = on[key];
	        var ours = value[key];
	        on[key] = existing ? [].concat(ours, existing) : ours;
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	function initRender(vm) {
	  vm._vnode = null; // the root of the child tree
	  vm._staticTrees = null;
	  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
	  var renderContext = parentVnode && parentVnode.context;
	  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
	  vm.$scopedSlots = emptyObject;
	  // bind the createElement fn to this instance
	  // so that we get proper render context inside it.
	  // args order: tag, data, children, normalizationType, alwaysNormalize
	  // internal version is used by render functions compiled from templates
	  vm._c = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, false);
	  };
	  // normalization is always applied for the public version, used in
	  // user-written render functions.
	  vm.$createElement = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, true);
	  };
	
	  // $attrs & $listeners are exposed for easier HOC creation.
	  // they need to be reactive so that HOCs using them are always updated
	  var parentData = parentVnode && parentVnode.data;
	  /* istanbul ignore else */
	  if (process.env.NODE_ENV !== 'production') {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
	      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
	    }, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
	      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
	    }, true);
	  } else {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);
	  }
	}
	
	function renderMixin(Vue) {
	  Vue.prototype.$nextTick = function (fn) {
	    return nextTick(fn, this);
	  };
	
	  Vue.prototype._render = function () {
	    var vm = this;
	    var ref = vm.$options;
	    var render = ref.render;
	    var staticRenderFns = ref.staticRenderFns;
	    var _parentVnode = ref._parentVnode;
	
	    if (vm._isMounted) {
	      // clone slot nodes on re-renders
	      for (var key in vm.$slots) {
	        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
	      }
	    }
	
	    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;
	
	    if (staticRenderFns && !vm._staticTrees) {
	      vm._staticTrees = [];
	    }
	    // set parent vnode. this allows render functions to have access
	    // to the data on the placeholder node.
	    vm.$vnode = _parentVnode;
	    // render self
	    var vnode;
	    try {
	      vnode = render.call(vm._renderProxy, vm.$createElement);
	    } catch (e) {
	      handleError(e, vm, "render function");
	      // return error render result,
	      // or previous vnode to prevent render error causing blank component
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
	      } else {
	        vnode = vm._vnode;
	      }
	    }
	    // return empty vnode in case the render function errored out
	    if (!(vnode instanceof VNode)) {
	      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
	        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
	      }
	      vnode = createEmptyVNode();
	    }
	    // set parent
	    vnode.parent = _parentVnode;
	    return vnode;
	  };
	
	  // internal render helpers.
	  // these are exposed on the instance prototype to reduce generated render
	  // code size.
	  Vue.prototype._o = markOnce;
	  Vue.prototype._n = toNumber;
	  Vue.prototype._s = toString;
	  Vue.prototype._l = renderList;
	  Vue.prototype._t = renderSlot;
	  Vue.prototype._q = looseEqual;
	  Vue.prototype._i = looseIndexOf;
	  Vue.prototype._m = renderStatic;
	  Vue.prototype._f = resolveFilter;
	  Vue.prototype._k = checkKeyCodes;
	  Vue.prototype._b = bindObjectProps;
	  Vue.prototype._v = createTextVNode;
	  Vue.prototype._e = createEmptyVNode;
	  Vue.prototype._u = resolveScopedSlots;
	  Vue.prototype._g = bindObjectListeners;
	}
	
	/*  */
	
	var uid$1 = 0;
	
	function initMixin(Vue) {
	  Vue.prototype._init = function (options) {
	    var vm = this;
	    // a uid
	    vm._uid = uid$1++;
	
	    var startTag, endTag;
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      startTag = "vue-perf-init:" + vm._uid;
	      endTag = "vue-perf-end:" + vm._uid;
	      mark(startTag);
	    }
	
	    // a flag to avoid this being observed
	    vm._isVue = true;
	    // merge options
	    if (options && options._isComponent) {
	      // optimize internal component instantiation
	      // since dynamic options merging is pretty slow, and none of the
	      // internal component options needs special treatment.
	      initInternalComponent(vm, options);
	    } else {
	      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
	    }
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      initProxy(vm);
	    } else {
	      vm._renderProxy = vm;
	    }
	    // expose real self
	    vm._self = vm;
	    initLifecycle(vm);
	    initEvents(vm);
	    initRender(vm);
	    callHook(vm, 'beforeCreate');
	    initInjections(vm); // resolve injections before data/props
	    initState(vm);
	    initProvide(vm); // resolve provide after data/props
	    callHook(vm, 'created');
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      vm._name = formatComponentName(vm, false);
	      mark(endTag);
	      measure(vm._name + " init", startTag, endTag);
	    }
	
	    if (vm.$options.el) {
	      vm.$mount(vm.$options.el);
	    }
	  };
	}
	
	function initInternalComponent(vm, options) {
	  var opts = vm.$options = Object.create(vm.constructor.options);
	  // doing this because it's faster than dynamic enumeration.
	  opts.parent = options.parent;
	  opts.propsData = options.propsData;
	  opts._parentVnode = options._parentVnode;
	  opts._parentListeners = options._parentListeners;
	  opts._renderChildren = options._renderChildren;
	  opts._componentTag = options._componentTag;
	  opts._parentElm = options._parentElm;
	  opts._refElm = options._refElm;
	  if (options.render) {
	    opts.render = options.render;
	    opts.staticRenderFns = options.staticRenderFns;
	  }
	}
	
	function resolveConstructorOptions(Ctor) {
	  var options = Ctor.options;
	  if (Ctor.super) {
	    var superOptions = resolveConstructorOptions(Ctor.super);
	    var cachedSuperOptions = Ctor.superOptions;
	    if (superOptions !== cachedSuperOptions) {
	      // super option changed,
	      // need to resolve new options.
	      Ctor.superOptions = superOptions;
	      // check if there are any late-modified/attached options (#4976)
	      var modifiedOptions = resolveModifiedOptions(Ctor);
	      // update base extend options
	      if (modifiedOptions) {
	        extend(Ctor.extendOptions, modifiedOptions);
	      }
	      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
	      if (options.name) {
	        options.components[options.name] = Ctor;
	      }
	    }
	  }
	  return options;
	}
	
	function resolveModifiedOptions(Ctor) {
	  var modified;
	  var latest = Ctor.options;
	  var extended = Ctor.extendOptions;
	  var sealed = Ctor.sealedOptions;
	  for (var key in latest) {
	    if (latest[key] !== sealed[key]) {
	      if (!modified) {
	        modified = {};
	      }
	      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
	    }
	  }
	  return modified;
	}
	
	function dedupe(latest, extended, sealed) {
	  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
	  // between merges
	  if (Array.isArray(latest)) {
	    var res = [];
	    sealed = Array.isArray(sealed) ? sealed : [sealed];
	    extended = Array.isArray(extended) ? extended : [extended];
	    for (var i = 0; i < latest.length; i++) {
	      // push original options and not sealed options to exclude duplicated options
	      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
	        res.push(latest[i]);
	      }
	    }
	    return res;
	  } else {
	    return latest;
	  }
	}
	
	function Vue$3(options) {
	  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
	    warn('Vue is a constructor and should be called with the `new` keyword');
	  }
	  this._init(options);
	}
	
	initMixin(Vue$3);
	stateMixin(Vue$3);
	eventsMixin(Vue$3);
	lifecycleMixin(Vue$3);
	renderMixin(Vue$3);
	
	/*  */
	
	function initUse(Vue) {
	  Vue.use = function (plugin) {
	    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
	    if (installedPlugins.indexOf(plugin) > -1) {
	      return this;
	    }
	
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else if (typeof plugin === 'function') {
	      plugin.apply(null, args);
	    }
	    installedPlugins.push(plugin);
	    return this;
	  };
	}
	
	/*  */
	
	function initMixin$1(Vue) {
	  Vue.mixin = function (mixin) {
	    this.options = mergeOptions(this.options, mixin);
	    return this;
	  };
	}
	
	/*  */
	
	function initExtend(Vue) {
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   */
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var SuperId = Super.cid;
	    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
	    if (cachedCtors[SuperId]) {
	      return cachedCtors[SuperId];
	    }
	
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
	      }
	    }
	
	    var Sub = function VueComponent(options) {
	      this._init(options);
	    };
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	
	    // For props and computed properties, we define the proxy getters on
	    // the Vue instances at extension time, on the extended prototype. This
	    // avoids Object.defineProperty calls for each instance created.
	    if (Sub.options.props) {
	      initProps$1(Sub);
	    }
	    if (Sub.options.computed) {
	      initComputed$1(Sub);
	    }
	
	    // allow further extension/mixin/plugin usage
	    Sub.extend = Super.extend;
	    Sub.mixin = Super.mixin;
	    Sub.use = Super.use;
	
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    ASSET_TYPES.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	
	    // keep a reference to the super options at extension time.
	    // later at instantiation we can check if Super's options have
	    // been updated.
	    Sub.superOptions = Super.options;
	    Sub.extendOptions = extendOptions;
	    Sub.sealedOptions = extend({}, Sub.options);
	
	    // cache constructor
	    cachedCtors[SuperId] = Sub;
	    return Sub;
	  };
	}
	
	function initProps$1(Comp) {
	  var props = Comp.options.props;
	  for (var key in props) {
	    proxy(Comp.prototype, "_props", key);
	  }
	}
	
	function initComputed$1(Comp) {
	  var computed = Comp.options.computed;
	  for (var key in computed) {
	    defineComputed(Comp.prototype, key, computed[key]);
	  }
	}
	
	/*  */
	
	function initAssetRegisters(Vue) {
	  /**
	   * Create asset registration methods.
	   */
	  ASSET_TYPES.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && config.isReservedTag(id)) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = definition.name || id;
	          definition = this.options._base.extend(definition);
	        }
	        if (type === 'directive' && typeof definition === 'function') {
	          definition = { bind: definition, update: definition };
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	}
	
	/*  */
	
	var patternTypes = [String, RegExp, Array];
	
	function getComponentName(opts) {
	  return opts && (opts.Ctor.options.name || opts.tag);
	}
	
	function matches(pattern, name) {
	  if (Array.isArray(pattern)) {
	    return pattern.indexOf(name) > -1;
	  } else if (typeof pattern === 'string') {
	    return pattern.split(',').indexOf(name) > -1;
	  } else if (isRegExp(pattern)) {
	    return pattern.test(name);
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	function pruneCache(cache, current, filter) {
	  for (var key in cache) {
	    var cachedNode = cache[key];
	    if (cachedNode) {
	      var name = getComponentName(cachedNode.componentOptions);
	      if (name && !filter(name)) {
	        if (cachedNode !== current) {
	          pruneCacheEntry(cachedNode);
	        }
	        cache[key] = null;
	      }
	    }
	  }
	}
	
	function pruneCacheEntry(vnode) {
	  if (vnode) {
	    vnode.componentInstance.$destroy();
	  }
	}
	
	var KeepAlive = {
	  name: 'keep-alive',
	  abstract: true,
	
	  props: {
	    include: patternTypes,
	    exclude: patternTypes
	  },
	
	  created: function created() {
	    this.cache = Object.create(null);
	  },
	
	  destroyed: function destroyed() {
	    var this$1 = this;
	
	    for (var key in this$1.cache) {
	      pruneCacheEntry(this$1.cache[key]);
	    }
	  },
	
	  watch: {
	    include: function include(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return matches(val, name);
	      });
	    },
	    exclude: function exclude(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return !matches(val, name);
	      });
	    }
	  },
	
	  render: function render() {
	    var vnode = getFirstComponentChild(this.$slots.default);
	    var componentOptions = vnode && vnode.componentOptions;
	    if (componentOptions) {
	      // check pattern
	      var name = getComponentName(componentOptions);
	      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
	        return vnode;
	      }
	      var key = vnode.key == null
	      // same constructor may get registered as different local components
	      // so cid alone is not enough (#3269)
	      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
	      if (this.cache[key]) {
	        vnode.componentInstance = this.cache[key].componentInstance;
	      } else {
	        this.cache[key] = vnode;
	      }
	      vnode.data.keepAlive = true;
	    }
	    return vnode;
	  }
	};
	
	var builtInComponents = {
	  KeepAlive: KeepAlive
	};
	
	/*  */
	
	function initGlobalAPI(Vue) {
	  // config
	  var configDef = {};
	  configDef.get = function () {
	    return config;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    configDef.set = function () {
	      warn('Do not replace the Vue.config object, set individual fields instead.');
	    };
	  }
	  Object.defineProperty(Vue, 'config', configDef);
	
	  // exposed util methods.
	  // NOTE: these are not considered part of the public API - avoid relying on
	  // them unless you are aware of the risk.
	  Vue.util = {
	    warn: warn,
	    extend: extend,
	    mergeOptions: mergeOptions,
	    defineReactive: defineReactive$$1
	  };
	
	  Vue.set = set;
	  Vue.delete = del;
	  Vue.nextTick = nextTick;
	
	  Vue.options = Object.create(null);
	  ASSET_TYPES.forEach(function (type) {
	    Vue.options[type + 's'] = Object.create(null);
	  });
	
	  // this is used to identify the "base" constructor to extend all plain-object
	  // components with in Weex's multi-instance scenarios.
	  Vue.options._base = Vue;
	
	  extend(Vue.options.components, builtInComponents);
	
	  initUse(Vue);
	  initMixin$1(Vue);
	  initExtend(Vue);
	  initAssetRegisters(Vue);
	}
	
	initGlobalAPI(Vue$3);
	
	Object.defineProperty(Vue$3.prototype, '$isServer', {
	  get: isServerRendering
	});
	
	Object.defineProperty(Vue$3.prototype, '$ssrContext', {
	  get: function get() {
	    /* istanbul ignore next */
	    return this.$vnode && this.$vnode.ssrContext;
	  }
	});
	
	Vue$3.version = '2.4.2';
	
	/*  */
	
	// these are reserved for web because they are directly compiled away
	// during template compilation
	var isReservedAttr = makeMap('style,class');
	
	// attributes that should be using props for binding
	var acceptValue = makeMap('input,textarea,option,select');
	var mustUseProp = function mustUseProp(tag, type, attr) {
	  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
	};
	
	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
	
	var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
	
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	
	var isXlink = function isXlink(name) {
	  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
	};
	
	var getXlinkProp = function getXlinkProp(name) {
	  return isXlink(name) ? name.slice(6, name.length) : '';
	};
	
	var isFalsyAttrValue = function isFalsyAttrValue(val) {
	  return val == null || val === false;
	};
	
	/*  */
	
	function genClassForVnode(vnode) {
	  var data = vnode.data;
	  var parentNode = vnode;
	  var childNode = vnode;
	  while (isDef(childNode.componentInstance)) {
	    childNode = childNode.componentInstance._vnode;
	    if (childNode.data) {
	      data = mergeClassData(childNode.data, data);
	    }
	  }
	  while (isDef(parentNode = parentNode.parent)) {
	    if (parentNode.data) {
	      data = mergeClassData(data, parentNode.data);
	    }
	  }
	  return renderClass(data.staticClass, data.class);
	}
	
	function mergeClassData(child, parent) {
	  return {
	    staticClass: concat(child.staticClass, parent.staticClass),
	    class: isDef(child.class) ? [child.class, parent.class] : parent.class
	  };
	}
	
	function renderClass(staticClass, dynamicClass) {
	  if (isDef(staticClass) || isDef(dynamicClass)) {
	    return concat(staticClass, stringifyClass(dynamicClass));
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function concat(a, b) {
	  return a ? b ? a + ' ' + b : a : b || '';
	}
	
	function stringifyClass(value) {
	  if (Array.isArray(value)) {
	    return stringifyArray(value);
	  }
	  if (isObject(value)) {
	    return stringifyObject(value);
	  }
	  if (typeof value === 'string') {
	    return value;
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function stringifyArray(value) {
	  var res = '';
	  var stringified;
	  for (var i = 0, l = value.length; i < l; i++) {
	    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
	      if (res) {
	        res += ' ';
	      }
	      res += stringified;
	    }
	  }
	  return res;
	}
	
	function stringifyObject(value) {
	  var res = '';
	  for (var key in value) {
	    if (value[key]) {
	      if (res) {
	        res += ' ';
	      }
	      res += key;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var namespaceMap = {
	  svg: 'http://www.w3.org/2000/svg',
	  math: 'http://www.w3.org/1998/Math/MathML'
	};
	
	var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');
	
	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
	
	var isPreTag = function isPreTag(tag) {
	  return tag === 'pre';
	};
	
	var isReservedTag = function isReservedTag(tag) {
	  return isHTMLTag(tag) || isSVG(tag);
	};
	
	function getTagNamespace(tag) {
	  if (isSVG(tag)) {
	    return 'svg';
	  }
	  // basic support for MathML
	  // note it doesn't support other MathML elements being component roots
	  if (tag === 'math') {
	    return 'math';
	  }
	}
	
	var unknownElementCache = Object.create(null);
	function isUnknownElement(tag) {
	  /* istanbul ignore if */
	  if (!inBrowser) {
	    return true;
	  }
	  if (isReservedTag(tag)) {
	    return false;
	  }
	  tag = tag.toLowerCase();
	  /* istanbul ignore if */
	  if (unknownElementCache[tag] != null) {
	    return unknownElementCache[tag];
	  }
	  var el = document.createElement(tag);
	  if (tag.indexOf('-') > -1) {
	    // http://stackoverflow.com/a/28210364/1070244
	    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	  } else {
	    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
	  }
	}
	
	/*  */
	
	/**
	 * Query an element selector if it's not an element already.
	 */
	function query(el) {
	  if (typeof el === 'string') {
	    var selected = document.querySelector(el);
	    if (!selected) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
	      return document.createElement('div');
	    }
	    return selected;
	  } else {
	    return el;
	  }
	}
	
	/*  */
	
	function createElement$1(tagName, vnode) {
	  var elm = document.createElement(tagName);
	  if (tagName !== 'select') {
	    return elm;
	  }
	  // false or null will remove the attribute but undefined will not
	  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
	    elm.setAttribute('multiple', 'multiple');
	  }
	  return elm;
	}
	
	function createElementNS(namespace, tagName) {
	  return document.createElementNS(namespaceMap[namespace], tagName);
	}
	
	function createTextNode(text) {
	  return document.createTextNode(text);
	}
	
	function createComment(text) {
	  return document.createComment(text);
	}
	
	function insertBefore(parentNode, newNode, referenceNode) {
	  parentNode.insertBefore(newNode, referenceNode);
	}
	
	function removeChild(node, child) {
	  node.removeChild(child);
	}
	
	function appendChild(node, child) {
	  node.appendChild(child);
	}
	
	function parentNode(node) {
	  return node.parentNode;
	}
	
	function nextSibling(node) {
	  return node.nextSibling;
	}
	
	function tagName(node) {
	  return node.tagName;
	}
	
	function setTextContent(node, text) {
	  node.textContent = text;
	}
	
	function setAttribute(node, key, val) {
	  node.setAttribute(key, val);
	}
	
	var nodeOps = Object.freeze({
	  createElement: createElement$1,
	  createElementNS: createElementNS,
	  createTextNode: createTextNode,
	  createComment: createComment,
	  insertBefore: insertBefore,
	  removeChild: removeChild,
	  appendChild: appendChild,
	  parentNode: parentNode,
	  nextSibling: nextSibling,
	  tagName: tagName,
	  setTextContent: setTextContent,
	  setAttribute: setAttribute
	});
	
	/*  */
	
	var ref = {
	  create: function create(_, vnode) {
	    registerRef(vnode);
	  },
	  update: function update(oldVnode, vnode) {
	    if (oldVnode.data.ref !== vnode.data.ref) {
	      registerRef(oldVnode, true);
	      registerRef(vnode);
	    }
	  },
	  destroy: function destroy(vnode) {
	    registerRef(vnode, true);
	  }
	};
	
	function registerRef(vnode, isRemoval) {
	  var key = vnode.data.ref;
	  if (!key) {
	    return;
	  }
	
	  var vm = vnode.context;
	  var ref = vnode.componentInstance || vnode.elm;
	  var refs = vm.$refs;
	  if (isRemoval) {
	    if (Array.isArray(refs[key])) {
	      remove(refs[key], ref);
	    } else if (refs[key] === ref) {
	      refs[key] = undefined;
	    }
	  } else {
	    if (vnode.data.refInFor) {
	      if (!Array.isArray(refs[key])) {
	        refs[key] = [ref];
	      } else if (refs[key].indexOf(ref) < 0) {
	        // $flow-disable-line
	        refs[key].push(ref);
	      }
	    } else {
	      refs[key] = ref;
	    }
	  }
	}
	
	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *
	
	/*
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */
	
	var emptyNode = new VNode('', {}, []);
	
	var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
	
	function sameVnode(a, b) {
	  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
	}
	
	// Some browsers do not support dynamically changing type for <input>
	// so they need to be treated as different nodes
	function sameInputType(a, b) {
	  if (a.tag !== 'input') {
	    return true;
	  }
	  var i;
	  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
	  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
	  return typeA === typeB;
	}
	
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, key;
	  var map = {};
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) {
	      map[key] = i;
	    }
	  }
	  return map;
	}
	
	function createPatchFunction(backend) {
	  var i, j;
	  var cbs = {};
	
	  var modules = backend.modules;
	  var nodeOps = backend.nodeOps;
	
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (isDef(modules[j][hooks[i]])) {
	        cbs[hooks[i]].push(modules[j][hooks[i]]);
	      }
	    }
	  }
	
	  function emptyNodeAt(elm) {
	    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
	  }
	
	  function createRmCb(childElm, listeners) {
	    function remove$$1() {
	      if (--remove$$1.listeners === 0) {
	        removeNode(childElm);
	      }
	    }
	    remove$$1.listeners = listeners;
	    return remove$$1;
	  }
	
	  function removeNode(el) {
	    var parent = nodeOps.parentNode(el);
	    // element may have already been removed due to v-html / v-text
	    if (isDef(parent)) {
	      nodeOps.removeChild(parent, el);
	    }
	  }
	
	  var inPre = 0;
	  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
	    vnode.isRootInsert = !nested; // for transition enter check
	    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	      return;
	    }
	
	    var data = vnode.data;
	    var children = vnode.children;
	    var tag = vnode.tag;
	    if (isDef(tag)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (data && data.pre) {
	          inPre++;
	        }
	        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
	        }
	      }
	      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
	      setScope(vnode);
	
	      /* istanbul ignore if */
	      {
	        createChildren(vnode, children, insertedVnodeQueue);
	        if (isDef(data)) {
	          invokeCreateHooks(vnode, insertedVnodeQueue);
	        }
	        insert(parentElm, vnode.elm, refElm);
	      }
	
	      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
	        inPre--;
	      }
	    } else if (isTrue(vnode.isComment)) {
	      vnode.elm = nodeOps.createComment(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    } else {
	      vnode.elm = nodeOps.createTextNode(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    }
	  }
	
	  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i = vnode.data;
	    if (isDef(i)) {
	      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
	      if (isDef(i = i.hook) && isDef(i = i.init)) {
	        i(vnode, false /* hydrating */, parentElm, refElm);
	      }
	      // after calling the init hook, if the vnode is a child component
	      // it should've created a child instance and mounted it. the child
	      // component also has set the placeholder vnode's elm.
	      // in that case we can just return the element and be done.
	      if (isDef(vnode.componentInstance)) {
	        initComponent(vnode, insertedVnodeQueue);
	        if (isTrue(isReactivated)) {
	          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
	        }
	        return true;
	      }
	    }
	  }
	
	  function initComponent(vnode, insertedVnodeQueue) {
	    if (isDef(vnode.data.pendingInsert)) {
	      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	      vnode.data.pendingInsert = null;
	    }
	    vnode.elm = vnode.componentInstance.$el;
	    if (isPatchable(vnode)) {
	      invokeCreateHooks(vnode, insertedVnodeQueue);
	      setScope(vnode);
	    } else {
	      // empty component root.
	      // skip all element-related modules except for ref (#3455)
	      registerRef(vnode);
	      // make sure to invoke the insert hook
	      insertedVnodeQueue.push(vnode);
	    }
	  }
	
	  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i;
	    // hack for #4339: a reactivated component with inner transition
	    // does not trigger because the inner node's created hooks are not called
	    // again. It's not ideal to involve module-specific logic in here but
	    // there doesn't seem to be a better way to do it.
	    var innerNode = vnode;
	    while (innerNode.componentInstance) {
	      innerNode = innerNode.componentInstance._vnode;
	      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
	        for (i = 0; i < cbs.activate.length; ++i) {
	          cbs.activate[i](emptyNode, innerNode);
	        }
	        insertedVnodeQueue.push(innerNode);
	        break;
	      }
	    }
	    // unlike a newly created component,
	    // a reactivated keep-alive component doesn't insert itself
	    insert(parentElm, vnode.elm, refElm);
	  }
	
	  function insert(parent, elm, ref$$1) {
	    if (isDef(parent)) {
	      if (isDef(ref$$1)) {
	        if (ref$$1.parentNode === parent) {
	          nodeOps.insertBefore(parent, elm, ref$$1);
	        }
	      } else {
	        nodeOps.appendChild(parent, elm);
	      }
	    }
	  }
	
	  function createChildren(vnode, children, insertedVnodeQueue) {
	    if (Array.isArray(children)) {
	      for (var i = 0; i < children.length; ++i) {
	        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
	      }
	    } else if (isPrimitive(vnode.text)) {
	      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
	    }
	  }
	
	  function isPatchable(vnode) {
	    while (vnode.componentInstance) {
	      vnode = vnode.componentInstance._vnode;
	    }
	    return isDef(vnode.tag);
	  }
	
	  function invokeCreateHooks(vnode, insertedVnodeQueue) {
	    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
	      cbs.create[i$1](emptyNode, vnode);
	    }
	    i = vnode.data.hook; // Reuse variable
	    if (isDef(i)) {
	      if (isDef(i.create)) {
	        i.create(emptyNode, vnode);
	      }
	      if (isDef(i.insert)) {
	        insertedVnodeQueue.push(vnode);
	      }
	    }
	  }
	
	  // set scope id attribute for scoped CSS.
	  // this is implemented as a special case to avoid the overhead
	  // of going through the normal attribute patching process.
	  function setScope(vnode) {
	    var i;
	    var ancestor = vnode;
	    while (ancestor) {
	      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
	        nodeOps.setAttribute(vnode.elm, i, '');
	      }
	      ancestor = ancestor.parent;
	    }
	    // for slot content they should also get the scopeId from the host instance.
	    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	  }
	
	  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
	    }
	  }
	
	  function invokeDestroyHook(vnode) {
	    var i, j;
	    var data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
	        i(vnode);
	      }
	      for (i = 0; i < cbs.destroy.length; ++i) {
	        cbs.destroy[i](vnode);
	      }
	    }
	    if (isDef(i = vnode.children)) {
	      for (j = 0; j < vnode.children.length; ++j) {
	        invokeDestroyHook(vnode.children[j]);
	      }
	    }
	  }
	
	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.tag)) {
	          removeAndInvokeRemoveHook(ch);
	          invokeDestroyHook(ch);
	        } else {
	          // Text node
	          removeNode(ch.elm);
	        }
	      }
	    }
	  }
	
	  function removeAndInvokeRemoveHook(vnode, rm) {
	    if (isDef(rm) || isDef(vnode.data)) {
	      var i;
	      var listeners = cbs.remove.length + 1;
	      if (isDef(rm)) {
	        // we have a recursively passed down rm callback
	        // increase the listeners count
	        rm.listeners += listeners;
	      } else {
	        // directly removing
	        rm = createRmCb(vnode.elm, listeners);
	      }
	      // recursively invoke hooks on child component root node
	      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
	        removeAndInvokeRemoveHook(i, rm);
	      }
	      for (i = 0; i < cbs.remove.length; ++i) {
	        cbs.remove[i](vnode, rm);
	      }
	      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
	        i(vnode, rm);
	      } else {
	        rm();
	      }
	    } else {
	      removeNode(vnode.elm);
	    }
	  }
	
	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	    var oldStartIdx = 0;
	    var newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, refElm;
	
	    // removeOnly is a special flag used only by <transition-group>
	    // to ensure removed elements stay in correct relative positions
	    // during leaving transitions
	    var canMove = !removeOnly;
	
	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) {
	        // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) {
	        // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) {
	          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        }
	        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
	        if (isUndef(idxInOld)) {
	          // New element
	          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
	            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
	          }
	          if (sameVnode(elmToMove, newStartVnode)) {
	            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	            oldCh[idxInOld] = undefined;
	            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          } else {
	            // same key but different element. treat as new element
	            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          }
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }
	
	  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
	    if (oldVnode === vnode) {
	      return;
	    }
	
	    var elm = vnode.elm = oldVnode.elm;
	
	    if (isTrue(oldVnode.isAsyncPlaceholder)) {
	      if (isDef(vnode.asyncFactory.resolved)) {
	        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
	      } else {
	        vnode.isAsyncPlaceholder = true;
	      }
	      return;
	    }
	
	    // reuse element for static trees.
	    // note we only do this if the vnode is cloned -
	    // if the new node is not cloned it means the render functions have been
	    // reset by the hot-reload-api and we need to do a proper re-render.
	    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
	      vnode.componentInstance = oldVnode.componentInstance;
	      return;
	    }
	
	    var i;
	    var data = vnode.data;
	    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
	      i(oldVnode, vnode);
	    }
	
	    var oldCh = oldVnode.children;
	    var ch = vnode.children;
	    if (isDef(data) && isPatchable(vnode)) {
	      for (i = 0; i < cbs.update.length; ++i) {
	        cbs.update[i](oldVnode, vnode);
	      }
	      if (isDef(i = data.hook) && isDef(i = i.update)) {
	        i(oldVnode, vnode);
	      }
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) {
	          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
	        }
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) {
	          nodeOps.setTextContent(elm, '');
	        }
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        nodeOps.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      nodeOps.setTextContent(elm, vnode.text);
	    }
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
	        i(oldVnode, vnode);
	      }
	    }
	  }
	
	  function invokeInsertHook(vnode, queue, initial) {
	    // delay insert hooks for component root nodes, invoke them after the
	    // element is really inserted
	    if (isTrue(initial) && isDef(vnode.parent)) {
	      vnode.parent.data.pendingInsert = queue;
	    } else {
	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].data.hook.insert(queue[i]);
	      }
	    }
	  }
	
	  var bailed = false;
	  // list of modules that can skip create hook during hydration because they
	  // are already rendered on the client or has no need for initialization
	  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
	
	  // Note: this is a browser-only function so we can assume elms are DOM nodes.
	  function hydrate(elm, vnode, insertedVnodeQueue) {
	    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
	      vnode.elm = elm;
	      vnode.isAsyncPlaceholder = true;
	      return true;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (!assertNodeMatch(elm, vnode)) {
	        return false;
	      }
	    }
	    vnode.elm = elm;
	    var tag = vnode.tag;
	    var data = vnode.data;
	    var children = vnode.children;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) {
	        i(vnode, true /* hydrating */);
	      }
	      if (isDef(i = vnode.componentInstance)) {
	        // child component. it should have hydrated its own tree.
	        initComponent(vnode, insertedVnodeQueue);
	        return true;
	      }
	    }
	    if (isDef(tag)) {
	      if (isDef(children)) {
	        // empty element, allow client to pick up and populate children
	        if (!elm.hasChildNodes()) {
	          createChildren(vnode, children, insertedVnodeQueue);
	        } else {
	          var childrenMatch = true;
	          var childNode = elm.firstChild;
	          for (var i$1 = 0; i$1 < children.length; i$1++) {
	            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
	              childrenMatch = false;
	              break;
	            }
	            childNode = childNode.nextSibling;
	          }
	          // if childNode is not null, it means the actual childNodes list is
	          // longer than the virtual children list.
	          if (!childrenMatch || childNode) {
	            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
	              bailed = true;
	              console.warn('Parent: ', elm);
	              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
	            }
	            return false;
	          }
	        }
	      }
	      if (isDef(data)) {
	        for (var key in data) {
	          if (!isRenderedModule(key)) {
	            invokeCreateHooks(vnode, insertedVnodeQueue);
	            break;
	          }
	        }
	      }
	    } else if (elm.data !== vnode.text) {
	      elm.data = vnode.text;
	    }
	    return true;
	  }
	
	  function assertNodeMatch(node, vnode) {
	    if (isDef(vnode.tag)) {
	      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
	    } else {
	      return node.nodeType === (vnode.isComment ? 8 : 3);
	    }
	  }
	
	  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
	    if (isUndef(vnode)) {
	      if (isDef(oldVnode)) {
	        invokeDestroyHook(oldVnode);
	      }
	      return;
	    }
	
	    var isInitialPatch = false;
	    var insertedVnodeQueue = [];
	
	    if (isUndef(oldVnode)) {
	      // empty mount (likely as component), create new root element
	      isInitialPatch = true;
	      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
	    } else {
	      var isRealElement = isDef(oldVnode.nodeType);
	      if (!isRealElement && sameVnode(oldVnode, vnode)) {
	        // patch existing root node
	        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
	      } else {
	        if (isRealElement) {
	          // mounting to a real element
	          // check if this is server-rendered content and if we can perform
	          // a successful hydration.
	          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
	            oldVnode.removeAttribute(SSR_ATTR);
	            hydrating = true;
	          }
	          if (isTrue(hydrating)) {
	            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	              invokeInsertHook(vnode, insertedVnodeQueue, true);
	              return oldVnode;
	            } else if (process.env.NODE_ENV !== 'production') {
	              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
	            }
	          }
	          // either not server-rendered, or hydration failed.
	          // create an empty node and replace it
	          oldVnode = emptyNodeAt(oldVnode);
	        }
	        // replacing existing element
	        var oldElm = oldVnode.elm;
	        var parentElm$1 = nodeOps.parentNode(oldElm);
	        createElm(vnode, insertedVnodeQueue,
	        // extremely rare edge case: do not insert if old element is in a
	        // leaving transition. Only happens when combining transition +
	        // keep-alive + HOCs. (#4590)
	        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));
	
	        if (isDef(vnode.parent)) {
	          // component root element replaced.
	          // update parent placeholder node element, recursively
	          var ancestor = vnode.parent;
	          while (ancestor) {
	            ancestor.elm = vnode.elm;
	            ancestor = ancestor.parent;
	          }
	          if (isPatchable(vnode)) {
	            for (var i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode.parent);
	            }
	          }
	        }
	
	        if (isDef(parentElm$1)) {
	          removeVnodes(parentElm$1, [oldVnode], 0, 0);
	        } else if (isDef(oldVnode.tag)) {
	          invokeDestroyHook(oldVnode);
	        }
	      }
	    }
	
	    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	    return vnode.elm;
	  };
	}
	
	/*  */
	
	var directives = {
	  create: updateDirectives,
	  update: updateDirectives,
	  destroy: function unbindDirectives(vnode) {
	    updateDirectives(vnode, emptyNode);
	  }
	};
	
	function updateDirectives(oldVnode, vnode) {
	  if (oldVnode.data.directives || vnode.data.directives) {
	    _update(oldVnode, vnode);
	  }
	}
	
	function _update(oldVnode, vnode) {
	  var isCreate = oldVnode === emptyNode;
	  var isDestroy = vnode === emptyNode;
	  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
	  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
	
	  var dirsWithInsert = [];
	  var dirsWithPostpatch = [];
	
	  var key, oldDir, dir;
	  for (key in newDirs) {
	    oldDir = oldDirs[key];
	    dir = newDirs[key];
	    if (!oldDir) {
	      // new directive, bind
	      callHook$1(dir, 'bind', vnode, oldVnode);
	      if (dir.def && dir.def.inserted) {
	        dirsWithInsert.push(dir);
	      }
	    } else {
	      // existing directive, update
	      dir.oldValue = oldDir.value;
	      callHook$1(dir, 'update', vnode, oldVnode);
	      if (dir.def && dir.def.componentUpdated) {
	        dirsWithPostpatch.push(dir);
	      }
	    }
	  }
	
	  if (dirsWithInsert.length) {
	    var callInsert = function callInsert() {
	      for (var i = 0; i < dirsWithInsert.length; i++) {
	        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
	      }
	    };
	    if (isCreate) {
	      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
	    } else {
	      callInsert();
	    }
	  }
	
	  if (dirsWithPostpatch.length) {
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
	      for (var i = 0; i < dirsWithPostpatch.length; i++) {
	        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
	      }
	    });
	  }
	
	  if (!isCreate) {
	    for (key in oldDirs) {
	      if (!newDirs[key]) {
	        // no longer present, unbind
	        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
	      }
	    }
	  }
	}
	
	var emptyModifiers = Object.create(null);
	
	function normalizeDirectives$1(dirs, vm) {
	  var res = Object.create(null);
	  if (!dirs) {
	    return res;
	  }
	  var i, dir;
	  for (i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (!dir.modifiers) {
	      dir.modifiers = emptyModifiers;
	    }
	    res[getRawDirName(dir)] = dir;
	    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
	  }
	  return res;
	}
	
	function getRawDirName(dir) {
	  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
	}
	
	function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
	  var fn = dir.def && dir.def[hook];
	  if (fn) {
	    try {
	      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
	    } catch (e) {
	      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
	    }
	  }
	}
	
	var baseModules = [ref, directives];
	
	/*  */
	
	function updateAttrs(oldVnode, vnode) {
	  var opts = vnode.componentOptions;
	  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
	    return;
	  }
	  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
	    return;
	  }
	  var key, cur, old;
	  var elm = vnode.elm;
	  var oldAttrs = oldVnode.data.attrs || {};
	  var attrs = vnode.data.attrs || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(attrs.__ob__)) {
	    attrs = vnode.data.attrs = extend({}, attrs);
	  }
	
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      setAttr(elm, key, cur);
	    }
	  }
	  // #4391: in IE9, setting type can reset value for input[type=radio]
	  /* istanbul ignore if */
	  if (isIE9 && attrs.value !== oldAttrs.value) {
	    setAttr(elm, 'value', attrs.value);
	  }
	  for (key in oldAttrs) {
	    if (isUndef(attrs[key])) {
	      if (isXlink(key)) {
	        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	      } else if (!isEnumeratedAttr(key)) {
	        elm.removeAttribute(key);
	      }
	    }
	  }
	}
	
	function setAttr(el, key, value) {
	  if (isBooleanAttr(key)) {
	    // set attribute for blank value
	    // e.g. <option disabled>Select one</option>
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, key);
	    }
	  } else if (isEnumeratedAttr(key)) {
	    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
	  } else if (isXlink(key)) {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, value);
	    }
	  }
	}
	
	var attrs = {
	  create: updateAttrs,
	  update: updateAttrs
	};
	
	/*  */
	
	function updateClass(oldVnode, vnode) {
	  var el = vnode.elm;
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
	    return;
	  }
	
	  var cls = genClassForVnode(vnode);
	
	  // handle transition classes
	  var transitionClass = el._transitionClasses;
	  if (isDef(transitionClass)) {
	    cls = concat(cls, stringifyClass(transitionClass));
	  }
	
	  // set the class
	  if (cls !== el._prevClass) {
	    el.setAttribute('class', cls);
	    el._prevClass = cls;
	  }
	}
	
	var klass = {
	  create: updateClass,
	  update: updateClass
	};
	
	/*  */
	
	var validDivisionCharRE = /[\w).+\-_$\]]/;
	
	function parseFilters(exp) {
	  var inSingle = false;
	  var inDouble = false;
	  var inTemplateString = false;
	  var inRegex = false;
	  var curly = 0;
	  var square = 0;
	  var paren = 0;
	  var lastFilterIndex = 0;
	  var c, prev, i, expression, filters;
	
	  for (i = 0; i < exp.length; i++) {
	    prev = c;
	    c = exp.charCodeAt(i);
	    if (inSingle) {
	      if (c === 0x27 && prev !== 0x5C) {
	        inSingle = false;
	      }
	    } else if (inDouble) {
	      if (c === 0x22 && prev !== 0x5C) {
	        inDouble = false;
	      }
	    } else if (inTemplateString) {
	      if (c === 0x60 && prev !== 0x5C) {
	        inTemplateString = false;
	      }
	    } else if (inRegex) {
	      if (c === 0x2f && prev !== 0x5C) {
	        inRegex = false;
	      }
	    } else if (c === 0x7C && // pipe
	    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
	      if (expression === undefined) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        expression = exp.slice(0, i).trim();
	      } else {
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x60:
	          inTemplateString = true;break; // `
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	      if (c === 0x2f) {
	        // /
	        var j = i - 1;
	        var p = void 0;
	        // find first non-whitespace prev char
	        for (; j >= 0; j--) {
	          p = exp.charAt(j);
	          if (p !== ' ') {
	            break;
	          }
	        }
	        if (!p || !validDivisionCharRE.test(p)) {
	          inRegex = true;
	        }
	      }
	    }
	  }
	
	  if (expression === undefined) {
	    expression = exp.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  function pushFilter() {
	    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
	    lastFilterIndex = i + 1;
	  }
	
	  if (filters) {
	    for (i = 0; i < filters.length; i++) {
	      expression = wrapFilter(expression, filters[i]);
	    }
	  }
	
	  return expression;
	}
	
	function wrapFilter(exp, filter) {
	  var i = filter.indexOf('(');
	  if (i < 0) {
	    // _f: resolveFilter
	    return "_f(\"" + filter + "\")(" + exp + ")";
	  } else {
	    var name = filter.slice(0, i);
	    var args = filter.slice(i + 1);
	    return "_f(\"" + name + "\")(" + exp + "," + args;
	  }
	}
	
	/*  */
	
	function baseWarn(msg) {
	  console.error("[Vue compiler]: " + msg);
	}
	
	function pluckModuleFunction(modules, key) {
	  return modules ? modules.map(function (m) {
	    return m[key];
	  }).filter(function (_) {
	    return _;
	  }) : [];
	}
	
	function addProp(el, name, value) {
	  (el.props || (el.props = [])).push({ name: name, value: value });
	}
	
	function addAttr(el, name, value) {
	  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
	}
	
	function addDirective(el, name, rawName, value, arg, modifiers) {
	  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
	}
	
	function addHandler(el, name, value, modifiers, important, warn) {
	  // warn prevent and passive modifier
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {
	    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
	  }
	  // check capture modifier
	  if (modifiers && modifiers.capture) {
	    delete modifiers.capture;
	    name = '!' + name; // mark the event as captured
	  }
	  if (modifiers && modifiers.once) {
	    delete modifiers.once;
	    name = '~' + name; // mark the event as once
	  }
	  /* istanbul ignore if */
	  if (modifiers && modifiers.passive) {
	    delete modifiers.passive;
	    name = '&' + name; // mark the event as passive
	  }
	  var events;
	  if (modifiers && modifiers.native) {
	    delete modifiers.native;
	    events = el.nativeEvents || (el.nativeEvents = {});
	  } else {
	    events = el.events || (el.events = {});
	  }
	  var newHandler = { value: value, modifiers: modifiers };
	  var handlers = events[name];
	  /* istanbul ignore if */
	  if (Array.isArray(handlers)) {
	    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
	  } else if (handlers) {
	    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
	  } else {
	    events[name] = newHandler;
	  }
	}
	
	function getBindingAttr(el, name, getStatic) {
	  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
	  if (dynamicValue != null) {
	    return parseFilters(dynamicValue);
	  } else if (getStatic !== false) {
	    var staticValue = getAndRemoveAttr(el, name);
	    if (staticValue != null) {
	      return JSON.stringify(staticValue);
	    }
	  }
	}
	
	function getAndRemoveAttr(el, name) {
	  var val;
	  if ((val = el.attrsMap[name]) != null) {
	    var list = el.attrsList;
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (list[i].name === name) {
	        list.splice(i, 1);
	        break;
	      }
	    }
	  }
	  return val;
	}
	
	/*  */
	
	/**
	 * Cross-platform code generation for component v-model
	 */
	function genComponentModel(el, value, modifiers) {
	  var ref = modifiers || {};
	  var number = ref.number;
	  var trim = ref.trim;
	
	  var baseValueExpression = '$$v';
	  var valueExpression = baseValueExpression;
	  if (trim) {
	    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	  var assignment = genAssignmentCode(value, valueExpression);
	
	  el.model = {
	    value: "(" + value + ")",
	    expression: "\"" + value + "\"",
	    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
	  };
	}
	
	/**
	 * Cross-platform codegen helper for generating v-model value assignment code.
	 */
	function genAssignmentCode(value, assignment) {
	  var modelRs = parseModel(value);
	  if (modelRs.idx === null) {
	    return value + "=" + assignment;
	  } else {
	    return "$set(" + modelRs.exp + ", " + modelRs.idx + ", " + assignment + ")";
	  }
	}
	
	/**
	 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
	 *
	 * for loop possible cases:
	 *
	 * - test
	 * - test[idx]
	 * - test[test1[idx]]
	 * - test["a"][idx]
	 * - xxx.test[a[a].test1[idx]]
	 * - test.xxx.a["asa"][test1[idx]]
	 *
	 */
	
	var len;
	var str;
	var chr;
	var index$1;
	var expressionPos;
	var expressionEndPos;
	
	function parseModel(val) {
	  str = val;
	  len = str.length;
	  index$1 = expressionPos = expressionEndPos = 0;
	
	  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
	    return {
	      exp: val,
	      idx: null
	    };
	  }
	
	  while (!eof()) {
	    chr = next();
	    /* istanbul ignore if */
	    if (isStringStart(chr)) {
	      parseString(chr);
	    } else if (chr === 0x5B) {
	      parseBracket(chr);
	    }
	  }
	
	  return {
	    exp: val.substring(0, expressionPos),
	    idx: val.substring(expressionPos + 1, expressionEndPos)
	  };
	}
	
	function next() {
	  return str.charCodeAt(++index$1);
	}
	
	function eof() {
	  return index$1 >= len;
	}
	
	function isStringStart(chr) {
	  return chr === 0x22 || chr === 0x27;
	}
	
	function parseBracket(chr) {
	  var inBracket = 1;
	  expressionPos = index$1;
	  while (!eof()) {
	    chr = next();
	    if (isStringStart(chr)) {
	      parseString(chr);
	      continue;
	    }
	    if (chr === 0x5B) {
	      inBracket++;
	    }
	    if (chr === 0x5D) {
	      inBracket--;
	    }
	    if (inBracket === 0) {
	      expressionEndPos = index$1;
	      break;
	    }
	  }
	}
	
	function parseString(chr) {
	  var stringQuote = chr;
	  while (!eof()) {
	    chr = next();
	    if (chr === stringQuote) {
	      break;
	    }
	  }
	}
	
	/*  */
	
	var warn$1;
	
	// in some cases, the event used has to be determined at runtime
	// so we used some reserved tokens during compile.
	var RANGE_TOKEN = '__r';
	var CHECKBOX_RADIO_TOKEN = '__c';
	
	function model(el, dir, _warn) {
	  warn$1 = _warn;
	  var value = dir.value;
	  var modifiers = dir.modifiers;
	  var tag = el.tag;
	  var type = el.attrsMap.type;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
	    if (tag === 'input' && dynamicType) {
	      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
	    }
	    // inputs with type="file" are read only and setting the input's
	    // value will throw an error.
	    if (tag === 'input' && type === 'file') {
	      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
	    }
	  }
	
	  if (el.component) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (tag === 'select') {
	    genSelect(el, value, modifiers);
	  } else if (tag === 'input' && type === 'checkbox') {
	    genCheckboxModel(el, value, modifiers);
	  } else if (tag === 'input' && type === 'radio') {
	    genRadioModel(el, value, modifiers);
	  } else if (tag === 'input' || tag === 'textarea') {
	    genDefaultModel(el, value, modifiers);
	  } else if (!config.isReservedTag(tag)) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
	  }
	
	  // ensure runtime directive metadata
	  return true;
	}
	
	function genCheckboxModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
	  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
	  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
	  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
	}
	
	function genRadioModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
	  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
	  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
	}
	
	function genSelect(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
	
	  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
	  var code = "var $$selectedVal = " + selectedVal + ";";
	  code = code + " " + genAssignmentCode(value, assignment);
	  addHandler(el, 'change', code, null, true);
	}
	
	function genDefaultModel(el, value, modifiers) {
	  var type = el.attrsMap.type;
	  var ref = modifiers || {};
	  var lazy = ref.lazy;
	  var number = ref.number;
	  var trim = ref.trim;
	  var needCompositionGuard = !lazy && type !== 'range';
	  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
	
	  var valueExpression = '$event.target.value';
	  if (trim) {
	    valueExpression = "$event.target.value.trim()";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	
	  var code = genAssignmentCode(value, valueExpression);
	  if (needCompositionGuard) {
	    code = "if($event.target.composing)return;" + code;
	  }
	
	  addProp(el, 'value', "(" + value + ")");
	  addHandler(el, event, code, null, true);
	  if (trim || number) {
	    addHandler(el, 'blur', '$forceUpdate()');
	  }
	}
	
	/*  */
	
	// normalize v-model event tokens that can only be determined at runtime.
	// it's important to place the event as the first in the array because
	// the whole point is ensuring the v-model callback gets called before
	// user-attached handlers.
	function normalizeEvents(on) {
	  var event;
	  /* istanbul ignore if */
	  if (isDef(on[RANGE_TOKEN])) {
	    // IE input[type=range] only supports `change` event
	    event = isIE ? 'change' : 'input';
	    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
	    delete on[RANGE_TOKEN];
	  }
	  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
	    // Chrome fires microtasks in between click/change, leads to #4521
	    event = isChrome ? 'click' : 'change';
	    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
	    delete on[CHECKBOX_RADIO_TOKEN];
	  }
	}
	
	var target$1;
	
	function add$1(event, _handler, once$$1, capture, passive) {
	  if (once$$1) {
	    var oldHandler = _handler;
	    var _target = target$1; // save current target element in closure
	    _handler = function handler(ev) {
	      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
	      if (res !== null) {
	        remove$2(event, _handler, capture, _target);
	      }
	    };
	  }
	  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);
	}
	
	function remove$2(event, handler, capture, _target) {
	  (_target || target$1).removeEventListener(event, handler, capture);
	}
	
	function updateDOMListeners(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
	    return;
	  }
	  var on = vnode.data.on || {};
	  var oldOn = oldVnode.data.on || {};
	  target$1 = vnode.elm;
	  normalizeEvents(on);
	  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
	}
	
	var events = {
	  create: updateDOMListeners,
	  update: updateDOMListeners
	};
	
	/*  */
	
	function updateDOMProps(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
	    return;
	  }
	  var key, cur;
	  var elm = vnode.elm;
	  var oldProps = oldVnode.data.domProps || {};
	  var props = vnode.data.domProps || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(props.__ob__)) {
	    props = vnode.data.domProps = extend({}, props);
	  }
	
	  for (key in oldProps) {
	    if (isUndef(props[key])) {
	      elm[key] = '';
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    // ignore children if the node has textContent or innerHTML,
	    // as these will throw away existing DOM nodes and cause removal errors
	    // on subsequent patches (#3360)
	    if (key === 'textContent' || key === 'innerHTML') {
	      if (vnode.children) {
	        vnode.children.length = 0;
	      }
	      if (cur === oldProps[key]) {
	        continue;
	      }
	    }
	
	    if (key === 'value') {
	      // store value as _value as well since
	      // non-string values will be stringified
	      elm._value = cur;
	      // avoid resetting cursor position when value is the same
	      var strCur = isUndef(cur) ? '' : String(cur);
	      if (shouldUpdateValue(elm, vnode, strCur)) {
	        elm.value = strCur;
	      }
	    } else {
	      elm[key] = cur;
	    }
	  }
	}
	
	// check platforms/web/util/attrs.js acceptValue
	
	
	function shouldUpdateValue(elm, vnode, checkVal) {
	  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
	}
	
	function isDirty(elm, checkVal) {
	  // return true when textbox (.number and .trim) loses focus and its value is
	  // not equal to the updated value
	  var notInFocus = true;
	  // #6157
	  // work around IE bug when accessing document.activeElement in an iframe
	  try {
	    notInFocus = document.activeElement !== elm;
	  } catch (e) {}
	  return notInFocus && elm.value !== checkVal;
	}
	
	function isInputChanged(elm, newVal) {
	  var value = elm.value;
	  var modifiers = elm._vModifiers; // injected by v-model runtime
	  if (isDef(modifiers) && modifiers.number) {
	    return toNumber(value) !== toNumber(newVal);
	  }
	  if (isDef(modifiers) && modifiers.trim) {
	    return value.trim() !== newVal.trim();
	  }
	  return value !== newVal;
	}
	
	var domProps = {
	  create: updateDOMProps,
	  update: updateDOMProps
	};
	
	/*  */
	
	var parseStyleText = cached(function (cssText) {
	  var res = {};
	  var listDelimiter = /;(?![^(]*\))/g;
	  var propertyDelimiter = /:(.+)/;
	  cssText.split(listDelimiter).forEach(function (item) {
	    if (item) {
	      var tmp = item.split(propertyDelimiter);
	      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
	    }
	  });
	  return res;
	});
	
	// merge static and dynamic style data on the same vnode
	function normalizeStyleData(data) {
	  var style = normalizeStyleBinding(data.style);
	  // static style is pre-processed into an object during compilation
	  // and is always a fresh object, so it's safe to merge into it
	  return data.staticStyle ? extend(data.staticStyle, style) : style;
	}
	
	// normalize possible array / string values into Object
	function normalizeStyleBinding(bindingStyle) {
	  if (Array.isArray(bindingStyle)) {
	    return toObject(bindingStyle);
	  }
	  if (typeof bindingStyle === 'string') {
	    return parseStyleText(bindingStyle);
	  }
	  return bindingStyle;
	}
	
	/**
	 * parent component style should be after child's
	 * so that parent component's style could override it
	 */
	function getStyle(vnode, checkChild) {
	  var res = {};
	  var styleData;
	
	  if (checkChild) {
	    var childNode = vnode;
	    while (childNode.componentInstance) {
	      childNode = childNode.componentInstance._vnode;
	      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
	        extend(res, styleData);
	      }
	    }
	  }
	
	  if (styleData = normalizeStyleData(vnode.data)) {
	    extend(res, styleData);
	  }
	
	  var parentNode = vnode;
	  while (parentNode = parentNode.parent) {
	    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
	      extend(res, styleData);
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var cssVarRE = /^--/;
	var importantRE = /\s*!important$/;
	var setProp = function setProp(el, name, val) {
	  /* istanbul ignore if */
	  if (cssVarRE.test(name)) {
	    el.style.setProperty(name, val);
	  } else if (importantRE.test(val)) {
	    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
	  } else {
	    var normalizedName = normalize(name);
	    if (Array.isArray(val)) {
	      // Support values array created by autoprefixer, e.g.
	      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
	      // Set them one by one, and the browser will only set those it can recognize
	      for (var i = 0, len = val.length; i < len; i++) {
	        el.style[normalizedName] = val[i];
	      }
	    } else {
	      el.style[normalizedName] = val;
	    }
	  }
	};
	
	var vendorNames = ['Webkit', 'Moz', 'ms'];
	
	var emptyStyle;
	var normalize = cached(function (prop) {
	  emptyStyle = emptyStyle || document.createElement('div').style;
	  prop = camelize(prop);
	  if (prop !== 'filter' && prop in emptyStyle) {
	    return prop;
	  }
	  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
	  for (var i = 0; i < vendorNames.length; i++) {
	    var name = vendorNames[i] + capName;
	    if (name in emptyStyle) {
	      return name;
	    }
	  }
	});
	
	function updateStyle(oldVnode, vnode) {
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	
	  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
	    return;
	  }
	
	  var cur, name;
	  var el = vnode.elm;
	  var oldStaticStyle = oldData.staticStyle;
	  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
	
	  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
	  var oldStyle = oldStaticStyle || oldStyleBinding;
	
	  var style = normalizeStyleBinding(vnode.data.style) || {};
	
	  // store normalized style under a different key for next diff
	  // make sure to clone it if it's reactive, since the user likley wants
	  // to mutate it.
	  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
	
	  var newStyle = getStyle(vnode, true);
	
	  for (name in oldStyle) {
	    if (isUndef(newStyle[name])) {
	      setProp(el, name, '');
	    }
	  }
	  for (name in newStyle) {
	    cur = newStyle[name];
	    if (cur !== oldStyle[name]) {
	      // ie9 setting to null has no effect, must use empty string
	      setProp(el, name, cur == null ? '' : cur);
	    }
	  }
	}
	
	var style = {
	  create: updateStyle,
	  update: updateStyle
	};
	
	/*  */
	
	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.add(c);
	      });
	    } else {
	      el.classList.add(cls);
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.remove(c);
	      });
	    } else {
	      el.classList.remove(cls);
	    }
	    if (!el.classList.length) {
	      el.removeAttribute('class');
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    cur = cur.trim();
	    if (cur) {
	      el.setAttribute('class', cur);
	    } else {
	      el.removeAttribute('class');
	    }
	  }
	}
	
	/*  */
	
	function resolveTransition(def$$1) {
	  if (!def$$1) {
	    return;
	  }
	  /* istanbul ignore else */
	  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
	    var res = {};
	    if (def$$1.css !== false) {
	      extend(res, autoCssTransition(def$$1.name || 'v'));
	    }
	    extend(res, def$$1);
	    return res;
	  } else if (typeof def$$1 === 'string') {
	    return autoCssTransition(def$$1);
	  }
	}
	
	var autoCssTransition = cached(function (name) {
	  return {
	    enterClass: name + "-enter",
	    enterToClass: name + "-enter-to",
	    enterActiveClass: name + "-enter-active",
	    leaveClass: name + "-leave",
	    leaveToClass: name + "-leave-to",
	    leaveActiveClass: name + "-leave-active"
	  };
	});
	
	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';
	
	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	  /* istanbul ignore if */
	  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
	    transitionProp = 'WebkitTransition';
	    transitionEndEvent = 'webkitTransitionEnd';
	  }
	  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
	    animationProp = 'WebkitAnimation';
	    animationEndEvent = 'webkitAnimationEnd';
	  }
	}
	
	// binding to window is necessary to make hot reload work in IE in strict mode
	var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;
	
	function nextFrame(fn) {
	  raf(function () {
	    raf(fn);
	  });
	}
	
	function addTransitionClass(el, cls) {
	  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
	  if (transitionClasses.indexOf(cls) < 0) {
	    transitionClasses.push(cls);
	    addClass(el, cls);
	  }
	}
	
	function removeTransitionClass(el, cls) {
	  if (el._transitionClasses) {
	    remove(el._transitionClasses, cls);
	  }
	  removeClass(el, cls);
	}
	
	function whenTransitionEnds(el, expectedType, cb) {
	  var ref = getTransitionInfo(el, expectedType);
	  var type = ref.type;
	  var timeout = ref.timeout;
	  var propCount = ref.propCount;
	  if (!type) {
	    return cb();
	  }
	  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	  var ended = 0;
	  var end = function end() {
	    el.removeEventListener(event, onEnd);
	    cb();
	  };
	  var onEnd = function onEnd(e) {
	    if (e.target === el) {
	      if (++ended >= propCount) {
	        end();
	      }
	    }
	  };
	  setTimeout(function () {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(event, onEnd);
	}
	
	var transformRE = /\b(transform|all)(,|$)/;
	
	function getTransitionInfo(el, expectedType) {
	  var styles = window.getComputedStyle(el);
	  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
	  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
	  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	  var animationDelays = styles[animationProp + 'Delay'].split(', ');
	  var animationDurations = styles[animationProp + 'Duration'].split(', ');
	  var animationTimeout = getTimeout(animationDelays, animationDurations);
	
	  var type;
	  var timeout = 0;
	  var propCount = 0;
	  /* istanbul ignore if */
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
	    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
	  }
	  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
	  return {
	    type: type,
	    timeout: timeout,
	    propCount: propCount,
	    hasTransform: hasTransform
	  };
	}
	
	function getTimeout(delays, durations) {
	  /* istanbul ignore next */
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }
	
	  return Math.max.apply(null, durations.map(function (d, i) {
	    return toMs(d) + toMs(delays[i]);
	  }));
	}
	
	function toMs(s) {
	  return Number(s.slice(0, -1)) * 1000;
	}
	
	/*  */
	
	function enter(vnode, toggleDisplay) {
	  var el = vnode.elm;
	
	  // call leave callback now
	  if (isDef(el._leaveCb)) {
	    el._leaveCb.cancelled = true;
	    el._leaveCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return;
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._enterCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var enterClass = data.enterClass;
	  var enterToClass = data.enterToClass;
	  var enterActiveClass = data.enterActiveClass;
	  var appearClass = data.appearClass;
	  var appearToClass = data.appearToClass;
	  var appearActiveClass = data.appearActiveClass;
	  var beforeEnter = data.beforeEnter;
	  var enter = data.enter;
	  var afterEnter = data.afterEnter;
	  var enterCancelled = data.enterCancelled;
	  var beforeAppear = data.beforeAppear;
	  var appear = data.appear;
	  var afterAppear = data.afterAppear;
	  var appearCancelled = data.appearCancelled;
	  var duration = data.duration;
	
	  // activeInstance will always be the <transition> component managing this
	  // transition. One edge case to check is when the <transition> is placed
	  // as the root node of a child component. In that case we need to check
	  // <transition>'s parent for appear check.
	  var context = activeInstance;
	  var transitionNode = activeInstance.$vnode;
	  while (transitionNode && transitionNode.parent) {
	    transitionNode = transitionNode.parent;
	    context = transitionNode.context;
	  }
	
	  var isAppear = !context._isMounted || !vnode.isRootInsert;
	
	  if (isAppear && !appear && appear !== '') {
	    return;
	  }
	
	  var startClass = isAppear && appearClass ? appearClass : enterClass;
	  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
	  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
	
	  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
	  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
	  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
	  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
	
	  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
	
	  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
	    checkDuration(explicitEnterDuration, 'enter', vnode);
	  }
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(enterHook);
	
	  var cb = el._enterCb = once(function () {
	    if (expectsCSS) {
	      removeTransitionClass(el, toClass);
	      removeTransitionClass(el, activeClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, startClass);
	      }
	      enterCancelledHook && enterCancelledHook(el);
	    } else {
	      afterEnterHook && afterEnterHook(el);
	    }
	    el._enterCb = null;
	  });
	
	  if (!vnode.data.show) {
	    // remove pending leave element on enter by injecting an insert hook
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
	      var parent = el.parentNode;
	      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
	        pendingNode.elm._leaveCb();
	      }
	      enterHook && enterHook(el, cb);
	    });
	  }
	
	  // start enter transition
	  beforeEnterHook && beforeEnterHook(el);
	  if (expectsCSS) {
	    addTransitionClass(el, startClass);
	    addTransitionClass(el, activeClass);
	    nextFrame(function () {
	      addTransitionClass(el, toClass);
	      removeTransitionClass(el, startClass);
	      if (!cb.cancelled && !userWantsControl) {
	        if (isValidDuration(explicitEnterDuration)) {
	          setTimeout(cb, explicitEnterDuration);
	        } else {
	          whenTransitionEnds(el, type, cb);
	        }
	      }
	    });
	  }
	
	  if (vnode.data.show) {
	    toggleDisplay && toggleDisplay();
	    enterHook && enterHook(el, cb);
	  }
	
	  if (!expectsCSS && !userWantsControl) {
	    cb();
	  }
	}
	
	function leave(vnode, rm) {
	  var el = vnode.elm;
	
	  // call enter callback now
	  if (isDef(el._enterCb)) {
	    el._enterCb.cancelled = true;
	    el._enterCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return rm();
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._leaveCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var leaveClass = data.leaveClass;
	  var leaveToClass = data.leaveToClass;
	  var leaveActiveClass = data.leaveActiveClass;
	  var beforeLeave = data.beforeLeave;
	  var leave = data.leave;
	  var afterLeave = data.afterLeave;
	  var leaveCancelled = data.leaveCancelled;
	  var delayLeave = data.delayLeave;
	  var duration = data.duration;
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(leave);
	
	  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
	
	  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
	    checkDuration(explicitLeaveDuration, 'leave', vnode);
	  }
	
	  var cb = el._leaveCb = once(function () {
	    if (el.parentNode && el.parentNode._pending) {
	      el.parentNode._pending[vnode.key] = null;
	    }
	    if (expectsCSS) {
	      removeTransitionClass(el, leaveToClass);
	      removeTransitionClass(el, leaveActiveClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, leaveClass);
	      }
	      leaveCancelled && leaveCancelled(el);
	    } else {
	      rm();
	      afterLeave && afterLeave(el);
	    }
	    el._leaveCb = null;
	  });
	
	  if (delayLeave) {
	    delayLeave(performLeave);
	  } else {
	    performLeave();
	  }
	
	  function performLeave() {
	    // the delayed leave may have already been cancelled
	    if (cb.cancelled) {
	      return;
	    }
	    // record leaving element
	    if (!vnode.data.show) {
	      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
	    }
	    beforeLeave && beforeLeave(el);
	    if (expectsCSS) {
	      addTransitionClass(el, leaveClass);
	      addTransitionClass(el, leaveActiveClass);
	      nextFrame(function () {
	        addTransitionClass(el, leaveToClass);
	        removeTransitionClass(el, leaveClass);
	        if (!cb.cancelled && !userWantsControl) {
	          if (isValidDuration(explicitLeaveDuration)) {
	            setTimeout(cb, explicitLeaveDuration);
	          } else {
	            whenTransitionEnds(el, type, cb);
	          }
	        }
	      });
	    }
	    leave && leave(el, cb);
	    if (!expectsCSS && !userWantsControl) {
	      cb();
	    }
	  }
	}
	
	// only used in dev mode
	function checkDuration(val, name, vnode) {
	  if (typeof val !== 'number') {
	    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
	  } else if (isNaN(val)) {
	    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
	  }
	}
	
	function isValidDuration(val) {
	  return typeof val === 'number' && !isNaN(val);
	}
	
	/**
	 * Normalize a transition hook's argument length. The hook may be:
	 * - a merged hook (invoker) with the original in .fns
	 * - a wrapped component method (check ._length)
	 * - a plain function (.length)
	 */
	function getHookArgumentsLength(fn) {
	  if (isUndef(fn)) {
	    return false;
	  }
	  var invokerFns = fn.fns;
	  if (isDef(invokerFns)) {
	    // invoker
	    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
	  } else {
	    return (fn._length || fn.length) > 1;
	  }
	}
	
	function _enter(_, vnode) {
	  if (vnode.data.show !== true) {
	    enter(vnode);
	  }
	}
	
	var transition = inBrowser ? {
	  create: _enter,
	  activate: _enter,
	  remove: function remove$$1(vnode, rm) {
	    /* istanbul ignore else */
	    if (vnode.data.show !== true) {
	      leave(vnode, rm);
	    } else {
	      rm();
	    }
	  }
	} : {};
	
	var platformModules = [attrs, klass, events, domProps, style, transition];
	
	/*  */
	
	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);
	
	var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
	
	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */
	
	var isTextInputType = makeMap('text,number,password,search,email,tel,url');
	
	/* istanbul ignore if */
	if (isIE9) {
	  // http://www.matts411.com/post/internet-explorer-9-oninput/
	  document.addEventListener('selectionchange', function () {
	    var el = document.activeElement;
	    if (el && el.vmodel) {
	      trigger(el, 'input');
	    }
	  });
	}
	
	var model$1 = {
	  inserted: function inserted(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      var cb = function cb() {
	        setSelected(el, binding, vnode.context);
	      };
	      cb();
	      /* istanbul ignore if */
	      if (isIE || isEdge) {
	        setTimeout(cb, 0);
	      }
	      el._vOptions = [].map.call(el.options, getValue);
	    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
	      el._vModifiers = binding.modifiers;
	      if (!binding.modifiers.lazy) {
	        // Safari < 10.2 & UIWebView doesn't fire compositionend when
	        // switching focus before confirming composition choice
	        // this also fixes the issue where some browsers e.g. iOS Chrome
	        // fires "change" instead of "input" on autocomplete.
	        el.addEventListener('change', onCompositionEnd);
	        if (!isAndroid) {
	          el.addEventListener('compositionstart', onCompositionStart);
	          el.addEventListener('compositionend', onCompositionEnd);
	        }
	        /* istanbul ignore if */
	        if (isIE9) {
	          el.vmodel = true;
	        }
	      }
	    }
	  },
	  componentUpdated: function componentUpdated(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      setSelected(el, binding, vnode.context);
	      // in case the options rendered by v-for have changed,
	      // it's possible that the value is out-of-sync with the rendered options.
	      // detect such cases and filter out values that no longer has a matching
	      // option in the DOM.
	      var prevOptions = el._vOptions;
	      var curOptions = el._vOptions = [].map.call(el.options, getValue);
	      if (curOptions.some(function (o, i) {
	        return !looseEqual(o, prevOptions[i]);
	      })) {
	        trigger(el, 'change');
	      }
	    }
	  }
	};
	
	function setSelected(el, binding, vm) {
	  var value = binding.value;
	  var isMultiple = el.multiple;
	  if (isMultiple && !Array.isArray(value)) {
	    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
	    return;
	  }
	  var selected, option;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    option = el.options[i];
	    if (isMultiple) {
	      selected = looseIndexOf(value, getValue(option)) > -1;
	      if (option.selected !== selected) {
	        option.selected = selected;
	      }
	    } else {
	      if (looseEqual(getValue(option), value)) {
	        if (el.selectedIndex !== i) {
	          el.selectedIndex = i;
	        }
	        return;
	      }
	    }
	  }
	  if (!isMultiple) {
	    el.selectedIndex = -1;
	  }
	}
	
	function getValue(option) {
	  return '_value' in option ? option._value : option.value;
	}
	
	function onCompositionStart(e) {
	  e.target.composing = true;
	}
	
	function onCompositionEnd(e) {
	  // prevent triggering an input event for no reason
	  if (!e.target.composing) {
	    return;
	  }
	  e.target.composing = false;
	  trigger(e.target, 'input');
	}
	
	function trigger(el, type) {
	  var e = document.createEvent('HTMLEvents');
	  e.initEvent(type, true, true);
	  el.dispatchEvent(e);
	}
	
	/*  */
	
	// recursively search for possible transition defined inside the component root
	function locateNode(vnode) {
	  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
	}
	
	var show = {
	  bind: function bind(el, ref, vnode) {
	    var value = ref.value;
	
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
	    if (value && transition$$1) {
	      vnode.data.show = true;
	      enter(vnode, function () {
	        el.style.display = originalDisplay;
	      });
	    } else {
	      el.style.display = value ? originalDisplay : 'none';
	    }
	  },
	
	  update: function update(el, ref, vnode) {
	    var value = ref.value;
	    var oldValue = ref.oldValue;
	
	    /* istanbul ignore if */
	    if (value === oldValue) {
	      return;
	    }
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    if (transition$$1) {
	      vnode.data.show = true;
	      if (value) {
	        enter(vnode, function () {
	          el.style.display = el.__vOriginalDisplay;
	        });
	      } else {
	        leave(vnode, function () {
	          el.style.display = 'none';
	        });
	      }
	    } else {
	      el.style.display = value ? el.__vOriginalDisplay : 'none';
	    }
	  },
	
	  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
	    if (!isDestroy) {
	      el.style.display = el.__vOriginalDisplay;
	    }
	  }
	};
	
	var platformDirectives = {
	  model: model$1,
	  show: show
	};
	
	/*  */
	
	// Provides transition support for a single element/component.
	// supports transition mode (out-in / in-out)
	
	var transitionProps = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  duration: [Number, String, Object]
	};
	
	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild(vnode) {
	  var compOptions = vnode && vnode.componentOptions;
	  if (compOptions && compOptions.Ctor.options.abstract) {
	    return getRealChild(getFirstComponentChild(compOptions.children));
	  } else {
	    return vnode;
	  }
	}
	
	function extractTransitionData(comp) {
	  var data = {};
	  var options = comp.$options;
	  // props
	  for (var key in options.propsData) {
	    data[key] = comp[key];
	  }
	  // events.
	  // extract listeners and pass them directly to the transition methods
	  var listeners = options._parentListeners;
	  for (var key$1 in listeners) {
	    data[camelize(key$1)] = listeners[key$1];
	  }
	  return data;
	}
	
	function placeholder(h, rawChild) {
	  if (/\d-keep-alive$/.test(rawChild.tag)) {
	    return h('keep-alive', {
	      props: rawChild.componentOptions.propsData
	    });
	  }
	}
	
	function hasParentTransition(vnode) {
	  while (vnode = vnode.parent) {
	    if (vnode.data.transition) {
	      return true;
	    }
	  }
	}
	
	function isSameChild(child, oldChild) {
	  return oldChild.key === child.key && oldChild.tag === child.tag;
	}
	
	function isAsyncPlaceholder(node) {
	  return node.isComment && node.asyncFactory;
	}
	
	var Transition = {
	  name: 'transition',
	  props: transitionProps,
	  abstract: true,
	
	  render: function render(h) {
	    var this$1 = this;
	
	    var children = this.$options._renderChildren;
	    if (!children) {
	      return;
	    }
	
	    // filter out text nodes (possible whitespaces)
	    children = children.filter(function (c) {
	      return c.tag || isAsyncPlaceholder(c);
	    });
	    /* istanbul ignore if */
	    if (!children.length) {
	      return;
	    }
	
	    // warn multiple elements
	    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
	      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
	    }
	
	    var mode = this.mode;
	
	    // warn invalid mode
	    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
	      warn('invalid <transition> mode: ' + mode, this.$parent);
	    }
	
	    var rawChild = children[0];
	
	    // if this is a component root node and the component's
	    // parent container node also has transition, skip.
	    if (hasParentTransition(this.$vnode)) {
	      return rawChild;
	    }
	
	    // apply transition data to child
	    // use getRealChild() to ignore abstract components e.g. keep-alive
	    var child = getRealChild(rawChild);
	    /* istanbul ignore if */
	    if (!child) {
	      return rawChild;
	    }
	
	    if (this._leaving) {
	      return placeholder(h, rawChild);
	    }
	
	    // ensure a key that is unique to the vnode type and to this transition
	    // component instance. This key will be used to remove pending leaving nodes
	    // during entering.
	    var id = "__transition-" + this._uid + "-";
	    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
	
	    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
	    var oldRawChild = this._vnode;
	    var oldChild = getRealChild(oldRawChild);
	
	    // mark v-show
	    // so that the transition module can hand over the control to the directive
	    if (child.data.directives && child.data.directives.some(function (d) {
	      return d.name === 'show';
	    })) {
	      child.data.show = true;
	    }
	
	    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
	      // replace old child transition data with fresh one
	      // important for dynamic transitions!
	      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
	      // handle transition mode
	      if (mode === 'out-in') {
	        // return placeholder node and queue update when leave finishes
	        this._leaving = true;
	        mergeVNodeHook(oldData, 'afterLeave', function () {
	          this$1._leaving = false;
	          this$1.$forceUpdate();
	        });
	        return placeholder(h, rawChild);
	      } else if (mode === 'in-out') {
	        if (isAsyncPlaceholder(child)) {
	          return oldRawChild;
	        }
	        var delayedLeave;
	        var performLeave = function performLeave() {
	          delayedLeave();
	        };
	        mergeVNodeHook(data, 'afterEnter', performLeave);
	        mergeVNodeHook(data, 'enterCancelled', performLeave);
	        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	          delayedLeave = leave;
	        });
	      }
	    }
	
	    return rawChild;
	  }
	};
	
	/*  */
	
	// Provides transition support for list items.
	// supports move transitions using the FLIP technique.
	
	// Because the vdom's children update algorithm is "unstable" - i.e.
	// it doesn't guarantee the relative positioning of removed elements,
	// we force transition-group to update its children into two passes:
	// in the first pass, we remove all nodes that need to be removed,
	// triggering their leaving transition; in the second pass, we insert/move
	// into the final desired state. This way in the second pass removed
	// nodes will remain where they should be.
	
	var props = extend({
	  tag: String,
	  moveClass: String
	}, transitionProps);
	
	delete props.mode;
	
	var TransitionGroup = {
	  props: props,
	
	  render: function render(h) {
	    var tag = this.tag || this.$vnode.data.tag || 'span';
	    var map = Object.create(null);
	    var prevChildren = this.prevChildren = this.children;
	    var rawChildren = this.$slots.default || [];
	    var children = this.children = [];
	    var transitionData = extractTransitionData(this);
	
	    for (var i = 0; i < rawChildren.length; i++) {
	      var c = rawChildren[i];
	      if (c.tag) {
	        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	          children.push(c);
	          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
	        } else if (process.env.NODE_ENV !== 'production') {
	          var opts = c.componentOptions;
	          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
	          warn("<transition-group> children must be keyed: <" + name + ">");
	        }
	      }
	    }
	
	    if (prevChildren) {
	      var kept = [];
	      var removed = [];
	      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
	        var c$1 = prevChildren[i$1];
	        c$1.data.transition = transitionData;
	        c$1.data.pos = c$1.elm.getBoundingClientRect();
	        if (map[c$1.key]) {
	          kept.push(c$1);
	        } else {
	          removed.push(c$1);
	        }
	      }
	      this.kept = h(tag, null, kept);
	      this.removed = removed;
	    }
	
	    return h(tag, null, children);
	  },
	
	  beforeUpdate: function beforeUpdate() {
	    // force removing pass
	    this.__patch__(this._vnode, this.kept, false, // hydrating
	    true // removeOnly (!important, avoids unnecessary moves)
	    );
	    this._vnode = this.kept;
	  },
	
	  updated: function updated() {
	    var children = this.prevChildren;
	    var moveClass = this.moveClass || (this.name || 'v') + '-move';
	    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	      return;
	    }
	
	    // we divide the work into three loops to avoid mixing DOM reads and writes
	    // in each iteration - which helps prevent layout thrashing.
	    children.forEach(callPendingCbs);
	    children.forEach(recordPosition);
	    children.forEach(applyTranslation);
	
	    // force reflow to put everything in position
	    var body = document.body;
	    var f = body.offsetHeight; // eslint-disable-line
	
	    children.forEach(function (c) {
	      if (c.data.moved) {
	        var el = c.elm;
	        var s = el.style;
	        addTransitionClass(el, moveClass);
	        s.transform = s.WebkitTransform = s.transitionDuration = '';
	        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
	          if (!e || /transform$/.test(e.propertyName)) {
	            el.removeEventListener(transitionEndEvent, cb);
	            el._moveCb = null;
	            removeTransitionClass(el, moveClass);
	          }
	        });
	      }
	    });
	  },
	
	  methods: {
	    hasMove: function hasMove(el, moveClass) {
	      /* istanbul ignore if */
	      if (!hasTransition) {
	        return false;
	      }
	      /* istanbul ignore if */
	      if (this._hasMove) {
	        return this._hasMove;
	      }
	      // Detect whether an element with the move class applied has
	      // CSS transitions. Since the element may be inside an entering
	      // transition at this very moment, we make a clone of it and remove
	      // all other transition classes applied to ensure only the move class
	      // is applied.
	      var clone = el.cloneNode();
	      if (el._transitionClasses) {
	        el._transitionClasses.forEach(function (cls) {
	          removeClass(clone, cls);
	        });
	      }
	      addClass(clone, moveClass);
	      clone.style.display = 'none';
	      this.$el.appendChild(clone);
	      var info = getTransitionInfo(clone);
	      this.$el.removeChild(clone);
	      return this._hasMove = info.hasTransform;
	    }
	  }
	};
	
	function callPendingCbs(c) {
	  /* istanbul ignore if */
	  if (c.elm._moveCb) {
	    c.elm._moveCb();
	  }
	  /* istanbul ignore if */
	  if (c.elm._enterCb) {
	    c.elm._enterCb();
	  }
	}
	
	function recordPosition(c) {
	  c.data.newPos = c.elm.getBoundingClientRect();
	}
	
	function applyTranslation(c) {
	  var oldPos = c.data.pos;
	  var newPos = c.data.newPos;
	  var dx = oldPos.left - newPos.left;
	  var dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    c.data.moved = true;
	    var s = c.elm.style;
	    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
	    s.transitionDuration = '0s';
	  }
	}
	
	var platformComponents = {
	  Transition: Transition,
	  TransitionGroup: TransitionGroup
	};
	
	/*  */
	
	// install platform specific utils
	Vue$3.config.mustUseProp = mustUseProp;
	Vue$3.config.isReservedTag = isReservedTag;
	Vue$3.config.isReservedAttr = isReservedAttr;
	Vue$3.config.getTagNamespace = getTagNamespace;
	Vue$3.config.isUnknownElement = isUnknownElement;
	
	// install platform runtime directives & components
	extend(Vue$3.options.directives, platformDirectives);
	extend(Vue$3.options.components, platformComponents);
	
	// install platform patch function
	Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
	
	// public mount method
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && inBrowser ? query(el) : undefined;
	  return mountComponent(this, el, hydrating);
	};
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue$3);
	    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
	      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
	    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
	  }
	}, 0);
	
	/*  */
	
	// check whether current browser encodes a char inside attribute values
	function shouldDecode(content, encoded) {
	  var div = document.createElement('div');
	  div.innerHTML = "<div a=\"" + content + "\"/>";
	  return div.innerHTML.indexOf(encoded) > 0;
	}
	
	// #3663
	// IE encodes newlines inside attribute values while other browsers don't
	var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;
	
	/*  */
	
	var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	
	var buildRegex = cached(function (delimiters) {
	  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
	  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
	  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
	});
	
	function parseText(text, delimiters) {
	  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
	  if (!tagRE.test(text)) {
	    return;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index;
	  while (match = tagRE.exec(text)) {
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
	    }
	    // tag token
	    var exp = parseFilters(match[1].trim());
	    tokens.push("_s(" + exp + ")");
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push(JSON.stringify(text.slice(lastIndex)));
	  }
	  return tokens.join('+');
	}
	
	/*  */
	
	function transformNode(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticClass = getAndRemoveAttr(el, 'class');
	  if (process.env.NODE_ENV !== 'production' && staticClass) {
	    var expression = parseText(staticClass, options.delimiters);
	    if (expression) {
	      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
	    }
	  }
	  if (staticClass) {
	    el.staticClass = JSON.stringify(staticClass);
	  }
	  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
	  if (classBinding) {
	    el.classBinding = classBinding;
	  }
	}
	
	function genData(el) {
	  var data = '';
	  if (el.staticClass) {
	    data += "staticClass:" + el.staticClass + ",";
	  }
	  if (el.classBinding) {
	    data += "class:" + el.classBinding + ",";
	  }
	  return data;
	}
	
	var klass$1 = {
	  staticKeys: ['staticClass'],
	  transformNode: transformNode,
	  genData: genData
	};
	
	/*  */
	
	function transformNode$1(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticStyle = getAndRemoveAttr(el, 'style');
	  if (staticStyle) {
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      var expression = parseText(staticStyle, options.delimiters);
	      if (expression) {
	        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
	      }
	    }
	    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
	  }
	
	  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
	  if (styleBinding) {
	    el.styleBinding = styleBinding;
	  }
	}
	
	function genData$1(el) {
	  var data = '';
	  if (el.staticStyle) {
	    data += "staticStyle:" + el.staticStyle + ",";
	  }
	  if (el.styleBinding) {
	    data += "style:(" + el.styleBinding + "),";
	  }
	  return data;
	}
	
	var style$1 = {
	  staticKeys: ['staticStyle'],
	  transformNode: transformNode$1,
	  genData: genData$1
	};
	
	var modules$1 = [klass$1, style$1];
	
	/*  */
	
	function text(el, dir) {
	  if (dir.value) {
	    addProp(el, 'textContent', "_s(" + dir.value + ")");
	  }
	}
	
	/*  */
	
	function html(el, dir) {
	  if (dir.value) {
	    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
	  }
	}
	
	var directives$1 = {
	  model: model,
	  text: text,
	  html: html
	};
	
	/*  */
	
	var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');
	
	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
	
	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
	
	/*  */
	
	var baseOptions = {
	  expectHTML: true,
	  modules: modules$1,
	  directives: directives$1,
	  isPreTag: isPreTag,
	  isUnaryTag: isUnaryTag,
	  mustUseProp: mustUseProp,
	  canBeLeftOpenTag: canBeLeftOpenTag,
	  isReservedTag: isReservedTag,
	  getTagNamespace: getTagNamespace,
	  staticKeys: genStaticKeys(modules$1)
	};
	
	/*  */
	
	var decoder;
	
	var he = {
	  decode: function decode(html) {
	    decoder = decoder || document.createElement('div');
	    decoder.innerHTML = html;
	    return decoder.textContent;
	  }
	};
	
	/**
	 * Not type-checking this file because it's mostly vendor code.
	 */
	
	/*!
	 * HTML Parser By John Resig (ejohn.org)
	 * Modified by Juriy "kangax" Zaytsev
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 */
	
	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/;
	var singleAttrAssign = /(?:=)/;
	var singleAttrValues = [
	// attr value double quotes
	/"([^"]*)"+/.source,
	// attr value, single quotes
	/'([^']*)'+/.source,
	// attr value, no quotes
	/([^\s"'=<>`]+)/.source];
	var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');
	
	// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	// but for Vue templates we can enforce a simple charset
	var ncname = '[a-zA-Z_][\\w\\-\\.]*';
	var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
	var startTagOpen = new RegExp('^<' + qnameCapture);
	var startTagClose = /^\s*(\/?)>/;
	var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
	var doctype = /^<!DOCTYPE [^>]+>/i;
	var comment = /^<!--/;
	var conditionalComment = /^<!\[/;
	
	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function (m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});
	
	// Special Elements (can contain anything)
	var isPlainTextElement = makeMap('script,style,textarea', true);
	var reCache = {};
	
	var decodingMap = {
	  '&lt;': '<',
	  '&gt;': '>',
	  '&quot;': '"',
	  '&amp;': '&',
	  '&#10;': '\n'
	};
	var encodedAttr = /&(?:lt|gt|quot|amp);/g;
	var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;
	
	// #5992
	var isIgnoreNewlineTag = makeMap('pre,textarea', true);
	var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
	  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
	};
	
	function decodeAttr(value, shouldDecodeNewlines) {
	  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
	  return value.replace(re, function (match) {
	    return decodingMap[match];
	  });
	}
	
	function parseHTML(html, options) {
	  var stack = [];
	  var expectHTML = options.expectHTML;
	  var isUnaryTag$$1 = options.isUnaryTag || no;
	  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
	  var index = 0;
	  var last, lastTag;
	  while (html) {
	    last = html;
	    // Make sure we're not in a plaintext content element like script/style
	    if (!lastTag || !isPlainTextElement(lastTag)) {
	      var textEnd = html.indexOf('<');
	      if (textEnd === 0) {
	        // Comment:
	        if (comment.test(html)) {
	          var commentEnd = html.indexOf('-->');
	
	          if (commentEnd >= 0) {
	            if (options.shouldKeepComment) {
	              options.comment(html.substring(4, commentEnd));
	            }
	            advance(commentEnd + 3);
	            continue;
	          }
	        }
	
	        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	        if (conditionalComment.test(html)) {
	          var conditionalEnd = html.indexOf(']>');
	
	          if (conditionalEnd >= 0) {
	            advance(conditionalEnd + 2);
	            continue;
	          }
	        }
	
	        // Doctype:
	        var doctypeMatch = html.match(doctype);
	        if (doctypeMatch) {
	          advance(doctypeMatch[0].length);
	          continue;
	        }
	
	        // End tag:
	        var endTagMatch = html.match(endTag);
	        if (endTagMatch) {
	          var curIndex = index;
	          advance(endTagMatch[0].length);
	          parseEndTag(endTagMatch[1], curIndex, index);
	          continue;
	        }
	
	        // Start tag:
	        var startTagMatch = parseStartTag();
	        if (startTagMatch) {
	          handleStartTag(startTagMatch);
	          if (shouldIgnoreFirstNewline(lastTag, html)) {
	            advance(1);
	          }
	          continue;
	        }
	      }
	
	      var text = void 0,
	          rest = void 0,
	          next = void 0;
	      if (textEnd >= 0) {
	        rest = html.slice(textEnd);
	        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
	          // < in plain text, be forgiving and treat it as text
	          next = rest.indexOf('<', 1);
	          if (next < 0) {
	            break;
	          }
	          textEnd += next;
	          rest = html.slice(textEnd);
	        }
	        text = html.substring(0, textEnd);
	        advance(textEnd);
	      }
	
	      if (textEnd < 0) {
	        text = html;
	        html = '';
	      }
	
	      if (options.chars && text) {
	        options.chars(text);
	      }
	    } else {
	      var endTagLength = 0;
	      var stackedTag = lastTag.toLowerCase();
	      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
	      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
	        endTagLength = endTag.length;
	        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
	          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	        }
	        if (shouldIgnoreFirstNewline(stackedTag, text)) {
	          text = text.slice(1);
	        }
	        if (options.chars) {
	          options.chars(text);
	        }
	        return '';
	      });
	      index += html.length - rest$1.length;
	      html = rest$1;
	      parseEndTag(stackedTag, index - endTagLength, index);
	    }
	
	    if (html === last) {
	      options.chars && options.chars(html);
	      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
	        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
	      }
	      break;
	    }
	  }
	
	  // Clean up any remaining tags
	  parseEndTag();
	
	  function advance(n) {
	    index += n;
	    html = html.substring(n);
	  }
	
	  function parseStartTag() {
	    var start = html.match(startTagOpen);
	    if (start) {
	      var match = {
	        tagName: start[1],
	        attrs: [],
	        start: index
	      };
	      advance(start[0].length);
	      var end, attr;
	      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
	        advance(attr[0].length);
	        match.attrs.push(attr);
	      }
	      if (end) {
	        match.unarySlash = end[1];
	        advance(end[0].length);
	        match.end = index;
	        return match;
	      }
	    }
	  }
	
	  function handleStartTag(match) {
	    var tagName = match.tagName;
	    var unarySlash = match.unarySlash;
	
	    if (expectHTML) {
	      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
	        parseEndTag(lastTag);
	      }
	      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
	        parseEndTag(tagName);
	      }
	    }
	
	    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
	
	    var l = match.attrs.length;
	    var attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      var args = match.attrs[i];
	      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	        if (args[3] === '') {
	          delete args[3];
	        }
	        if (args[4] === '') {
	          delete args[4];
	        }
	        if (args[5] === '') {
	          delete args[5];
	        }
	      }
	      var value = args[3] || args[4] || args[5] || '';
	      attrs[i] = {
	        name: args[1],
	        value: decodeAttr(value, options.shouldDecodeNewlines)
	      };
	    }
	
	    if (!unary) {
	      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
	      lastTag = tagName;
	    }
	
	    if (options.start) {
	      options.start(tagName, attrs, unary, match.start, match.end);
	    }
	  }
	
	  function parseEndTag(tagName, start, end) {
	    var pos, lowerCasedTagName;
	    if (start == null) {
	      start = index;
	    }
	    if (end == null) {
	      end = index;
	    }
	
	    if (tagName) {
	      lowerCasedTagName = tagName.toLowerCase();
	    }
	
	    // Find the closest opened tag of the same type
	    if (tagName) {
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
	          break;
	        }
	      }
	    } else {
	      // If no tag name is provided, clean shop
	      pos = 0;
	    }
	
	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (var i = stack.length - 1; i >= pos; i--) {
	        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
	          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
	        }
	        if (options.end) {
	          options.end(stack[i].tag, start, end);
	        }
	      }
	
	      // Remove the open elements from the stack
	      stack.length = pos;
	      lastTag = pos && stack[pos - 1].tag;
	    } else if (lowerCasedTagName === 'br') {
	      if (options.start) {
	        options.start(tagName, [], true, start, end);
	      }
	    } else if (lowerCasedTagName === 'p') {
	      if (options.start) {
	        options.start(tagName, [], false, start, end);
	      }
	      if (options.end) {
	        options.end(tagName, start, end);
	      }
	    }
	  }
	}
	
	/*  */
	
	var onRE = /^@|^v-on:/;
	var dirRE = /^v-|^@|^:/;
	var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
	var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
	
	var argRE = /:(.*)$/;
	var bindRE = /^:|^v-bind:/;
	var modifierRE = /\.[^.]+/g;
	
	var decodeHTMLCached = cached(he.decode);
	
	// configurable state
	var warn$2;
	var delimiters;
	var transforms;
	var preTransforms;
	var postTransforms;
	var platformIsPreTag;
	var platformMustUseProp;
	var platformGetTagNamespace;
	
	/**
	 * Convert HTML string to AST.
	 */
	function parse(template, options) {
	  warn$2 = options.warn || baseWarn;
	
	  platformIsPreTag = options.isPreTag || no;
	  platformMustUseProp = options.mustUseProp || no;
	  platformGetTagNamespace = options.getTagNamespace || no;
	
	  transforms = pluckModuleFunction(options.modules, 'transformNode');
	  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
	  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
	
	  delimiters = options.delimiters;
	
	  var stack = [];
	  var preserveWhitespace = options.preserveWhitespace !== false;
	  var root;
	  var currentParent;
	  var inVPre = false;
	  var inPre = false;
	  var warned = false;
	
	  function warnOnce(msg) {
	    if (!warned) {
	      warned = true;
	      warn$2(msg);
	    }
	  }
	
	  function endPre(element) {
	    // check pre state
	    if (element.pre) {
	      inVPre = false;
	    }
	    if (platformIsPreTag(element.tag)) {
	      inPre = false;
	    }
	  }
	
	  parseHTML(template, {
	    warn: warn$2,
	    expectHTML: options.expectHTML,
	    isUnaryTag: options.isUnaryTag,
	    canBeLeftOpenTag: options.canBeLeftOpenTag,
	    shouldDecodeNewlines: options.shouldDecodeNewlines,
	    shouldKeepComment: options.comments,
	    start: function start(tag, attrs, unary) {
	      // check namespace.
	      // inherit parent ns if there is one
	      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);
	
	      // handle IE svg bug
	      /* istanbul ignore if */
	      if (isIE && ns === 'svg') {
	        attrs = guardIESVGBug(attrs);
	      }
	
	      var element = {
	        type: 1,
	        tag: tag,
	        attrsList: attrs,
	        attrsMap: makeAttrsMap(attrs),
	        parent: currentParent,
	        children: []
	      };
	      if (ns) {
	        element.ns = ns;
	      }
	
	      if (isForbiddenTag(element) && !isServerRendering()) {
	        element.forbidden = true;
	        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
	      }
	
	      // apply pre-transforms
	      for (var i = 0; i < preTransforms.length; i++) {
	        preTransforms[i](element, options);
	      }
	
	      if (!inVPre) {
	        processPre(element);
	        if (element.pre) {
	          inVPre = true;
	        }
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = true;
	      }
	      if (inVPre) {
	        processRawAttrs(element);
	      } else {
	        processFor(element);
	        processIf(element);
	        processOnce(element);
	        processKey(element);
	
	        // determine whether this is a plain element after
	        // removing structural attributes
	        element.plain = !element.key && !attrs.length;
	
	        processRef(element);
	        processSlot(element);
	        processComponent(element);
	        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
	          transforms[i$1](element, options);
	        }
	        processAttrs(element);
	      }
	
	      function checkRootConstraints(el) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (el.tag === 'slot' || el.tag === 'template') {
	            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
	          }
	          if (el.attrsMap.hasOwnProperty('v-for')) {
	            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
	          }
	        }
	      }
	
	      // tree management
	      if (!root) {
	        root = element;
	        checkRootConstraints(root);
	      } else if (!stack.length) {
	        // allow root elements with v-if, v-else-if and v-else
	        if (root.if && (element.elseif || element.else)) {
	          checkRootConstraints(element);
	          addIfCondition(root, {
	            exp: element.elseif,
	            block: element
	          });
	        } else if (process.env.NODE_ENV !== 'production') {
	          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
	        }
	      }
	      if (currentParent && !element.forbidden) {
	        if (element.elseif || element.else) {
	          processIfConditions(element, currentParent);
	        } else if (element.slotScope) {
	          // scoped slot
	          currentParent.plain = false;
	          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	        } else {
	          currentParent.children.push(element);
	          element.parent = currentParent;
	        }
	      }
	      if (!unary) {
	        currentParent = element;
	        stack.push(element);
	      } else {
	        endPre(element);
	      }
	      // apply post-transforms
	      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
	        postTransforms[i$2](element, options);
	      }
	    },
	
	    end: function end() {
	      // remove trailing whitespace
	      var element = stack[stack.length - 1];
	      var lastNode = element.children[element.children.length - 1];
	      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
	        element.children.pop();
	      }
	      // pop stack
	      stack.length -= 1;
	      currentParent = stack[stack.length - 1];
	      endPre(element);
	    },
	
	    chars: function chars(text) {
	      if (!currentParent) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (text === template) {
	            warnOnce('Component template requires a root element, rather than just text.');
	          } else if (text = text.trim()) {
	            warnOnce("text \"" + text + "\" outside root element will be ignored.");
	          }
	        }
	        return;
	      }
	      // IE textarea placeholder bug
	      /* istanbul ignore if */
	      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
	        return;
	      }
	      var children = currentParent.children;
	      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
	      // only preserve whitespace if its not right after a starting tag
	      : preserveWhitespace && children.length ? ' ' : '';
	      if (text) {
	        var expression;
	        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
	          children.push({
	            type: 2,
	            expression: expression,
	            text: text
	          });
	        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
	          children.push({
	            type: 3,
	            text: text
	          });
	        }
	      }
	    },
	    comment: function comment(text) {
	      currentParent.children.push({
	        type: 3,
	        text: text,
	        isComment: true
	      });
	    }
	  });
	  return root;
	}
	
	function processPre(el) {
	  if (getAndRemoveAttr(el, 'v-pre') != null) {
	    el.pre = true;
	  }
	}
	
	function processRawAttrs(el) {
	  var l = el.attrsList.length;
	  if (l) {
	    var attrs = el.attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      attrs[i] = {
	        name: el.attrsList[i].name,
	        value: JSON.stringify(el.attrsList[i].value)
	      };
	    }
	  } else if (!el.pre) {
	    // non root node in pre blocks with no attributes
	    el.plain = true;
	  }
	}
	
	function processKey(el) {
	  var exp = getBindingAttr(el, 'key');
	  if (exp) {
	    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
	      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
	    }
	    el.key = exp;
	  }
	}
	
	function processRef(el) {
	  var ref = getBindingAttr(el, 'ref');
	  if (ref) {
	    el.ref = ref;
	    el.refInFor = checkInFor(el);
	  }
	}
	
	function processFor(el) {
	  var exp;
	  if (exp = getAndRemoveAttr(el, 'v-for')) {
	    var inMatch = exp.match(forAliasRE);
	    if (!inMatch) {
	      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
	      return;
	    }
	    el.for = inMatch[2].trim();
	    var alias = inMatch[1].trim();
	    var iteratorMatch = alias.match(forIteratorRE);
	    if (iteratorMatch) {
	      el.alias = iteratorMatch[1].trim();
	      el.iterator1 = iteratorMatch[2].trim();
	      if (iteratorMatch[3]) {
	        el.iterator2 = iteratorMatch[3].trim();
	      }
	    } else {
	      el.alias = alias;
	    }
	  }
	}
	
	function processIf(el) {
	  var exp = getAndRemoveAttr(el, 'v-if');
	  if (exp) {
	    el.if = exp;
	    addIfCondition(el, {
	      exp: exp,
	      block: el
	    });
	  } else {
	    if (getAndRemoveAttr(el, 'v-else') != null) {
	      el.else = true;
	    }
	    var elseif = getAndRemoveAttr(el, 'v-else-if');
	    if (elseif) {
	      el.elseif = elseif;
	    }
	  }
	}
	
	function processIfConditions(el, parent) {
	  var prev = findPrevElement(parent.children);
	  if (prev && prev.if) {
	    addIfCondition(prev, {
	      exp: el.elseif,
	      block: el
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
	  }
	}
	
	function findPrevElement(children) {
	  var i = children.length;
	  while (i--) {
	    if (children[i].type === 1) {
	      return children[i];
	    } else {
	      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
	        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
	      }
	      children.pop();
	    }
	  }
	}
	
	function addIfCondition(el, condition) {
	  if (!el.ifConditions) {
	    el.ifConditions = [];
	  }
	  el.ifConditions.push(condition);
	}
	
	function processOnce(el) {
	  var once$$1 = getAndRemoveAttr(el, 'v-once');
	  if (once$$1 != null) {
	    el.once = true;
	  }
	}
	
	function processSlot(el) {
	  if (el.tag === 'slot') {
	    el.slotName = getBindingAttr(el, 'name');
	    if (process.env.NODE_ENV !== 'production' && el.key) {
	      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
	    }
	  } else {
	    var slotTarget = getBindingAttr(el, 'slot');
	    if (slotTarget) {
	      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
	    }
	    if (el.tag === 'template') {
	      el.slotScope = getAndRemoveAttr(el, 'scope');
	    }
	  }
	}
	
	function processComponent(el) {
	  var binding;
	  if (binding = getBindingAttr(el, 'is')) {
	    el.component = binding;
	  }
	  if (getAndRemoveAttr(el, 'inline-template') != null) {
	    el.inlineTemplate = true;
	  }
	}
	
	function processAttrs(el) {
	  var list = el.attrsList;
	  var i, l, name, rawName, value, modifiers, isProp;
	  for (i = 0, l = list.length; i < l; i++) {
	    name = rawName = list[i].name;
	    value = list[i].value;
	    if (dirRE.test(name)) {
	      // mark element as dynamic
	      el.hasBindings = true;
	      // modifiers
	      modifiers = parseModifiers(name);
	      if (modifiers) {
	        name = name.replace(modifierRE, '');
	      }
	      if (bindRE.test(name)) {
	        // v-bind
	        name = name.replace(bindRE, '');
	        value = parseFilters(value);
	        isProp = false;
	        if (modifiers) {
	          if (modifiers.prop) {
	            isProp = true;
	            name = camelize(name);
	            if (name === 'innerHtml') {
	              name = 'innerHTML';
	            }
	          }
	          if (modifiers.camel) {
	            name = camelize(name);
	          }
	          if (modifiers.sync) {
	            addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
	          }
	        }
	        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
	          addProp(el, name, value);
	        } else {
	          addAttr(el, name, value);
	        }
	      } else if (onRE.test(name)) {
	        // v-on
	        name = name.replace(onRE, '');
	        addHandler(el, name, value, modifiers, false, warn$2);
	      } else {
	        // normal directives
	        name = name.replace(dirRE, '');
	        // parse arg
	        var argMatch = name.match(argRE);
	        var arg = argMatch && argMatch[1];
	        if (arg) {
	          name = name.slice(0, -(arg.length + 1));
	        }
	        addDirective(el, name, rawName, value, arg, modifiers);
	        if (process.env.NODE_ENV !== 'production' && name === 'model') {
	          checkForAliasModel(el, value);
	        }
	      }
	    } else {
	      // literal attribute
	      if (process.env.NODE_ENV !== 'production') {
	        var expression = parseText(value, delimiters);
	        if (expression) {
	          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
	        }
	      }
	      addAttr(el, name, JSON.stringify(value));
	    }
	  }
	}
	
	function checkInFor(el) {
	  var parent = el;
	  while (parent) {
	    if (parent.for !== undefined) {
	      return true;
	    }
	    parent = parent.parent;
	  }
	  return false;
	}
	
	function parseModifiers(name) {
	  var match = name.match(modifierRE);
	  if (match) {
	    var ret = {};
	    match.forEach(function (m) {
	      ret[m.slice(1)] = true;
	    });
	    return ret;
	  }
	}
	
	function makeAttrsMap(attrs) {
	  var map = {};
	  for (var i = 0, l = attrs.length; i < l; i++) {
	    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
	      warn$2('duplicate attribute: ' + attrs[i].name);
	    }
	    map[attrs[i].name] = attrs[i].value;
	  }
	  return map;
	}
	
	// for script (e.g. type="x/template") or style, do not decode content
	function isTextTag(el) {
	  return el.tag === 'script' || el.tag === 'style';
	}
	
	function isForbiddenTag(el) {
	  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
	}
	
	var ieNSBug = /^xmlns:NS\d+/;
	var ieNSPrefix = /^NS\d+:/;
	
	/* istanbul ignore next */
	function guardIESVGBug(attrs) {
	  var res = [];
	  for (var i = 0; i < attrs.length; i++) {
	    var attr = attrs[i];
	    if (!ieNSBug.test(attr.name)) {
	      attr.name = attr.name.replace(ieNSPrefix, '');
	      res.push(attr);
	    }
	  }
	  return res;
	}
	
	function checkForAliasModel(el, value) {
	  var _el = el;
	  while (_el) {
	    if (_el.for && _el.alias === value) {
	      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
	    }
	    _el = _el.parent;
	  }
	}
	
	/*  */
	
	var isStaticKey;
	var isPlatformReservedTag;
	
	var genStaticKeysCached = cached(genStaticKeys$1);
	
	/**
	 * Goal of the optimizer: walk the generated template AST tree
	 * and detect sub-trees that are purely static, i.e. parts of
	 * the DOM that never needs to change.
	 *
	 * Once we detect these sub-trees, we can:
	 *
	 * 1. Hoist them into constants, so that we no longer need to
	 *    create fresh nodes for them on each re-render;
	 * 2. Completely skip them in the patching process.
	 */
	function optimize(root, options) {
	  if (!root) {
	    return;
	  }
	  isStaticKey = genStaticKeysCached(options.staticKeys || '');
	  isPlatformReservedTag = options.isReservedTag || no;
	  // first pass: mark all non-static nodes.
	  markStatic$1(root);
	  // second pass: mark static roots.
	  markStaticRoots(root, false);
	}
	
	function genStaticKeys$1(keys) {
	  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
	}
	
	function markStatic$1(node) {
	  node.static = isStatic(node);
	  if (node.type === 1) {
	    // do not make component slot content static. this avoids
	    // 1. components not able to mutate slot nodes
	    // 2. static slot content fails for hot-reloading
	    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
	      return;
	    }
	    for (var i = 0, l = node.children.length; i < l; i++) {
	      var child = node.children[i];
	      markStatic$1(child);
	      if (!child.static) {
	        node.static = false;
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        var block = node.ifConditions[i$1].block;
	        markStatic$1(block);
	        if (!block.static) {
	          node.static = false;
	        }
	      }
	    }
	  }
	}
	
	function markStaticRoots(node, isInFor) {
	  if (node.type === 1) {
	    if (node.static || node.once) {
	      node.staticInFor = isInFor;
	    }
	    // For a node to qualify as a static root, it should have children that
	    // are not just static text. Otherwise the cost of hoisting out will
	    // outweigh the benefits and it's better off to just always render it fresh.
	    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
	      node.staticRoot = true;
	      return;
	    } else {
	      node.staticRoot = false;
	    }
	    if (node.children) {
	      for (var i = 0, l = node.children.length; i < l; i++) {
	        markStaticRoots(node.children[i], isInFor || !!node.for);
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        markStaticRoots(node.ifConditions[i$1].block, isInFor);
	      }
	    }
	  }
	}
	
	function isStatic(node) {
	  if (node.type === 2) {
	    // expression
	    return false;
	  }
	  if (node.type === 3) {
	    // text
	    return true;
	  }
	  return !!(node.pre || !node.hasBindings && // no dynamic bindings
	  !node.if && !node.for && // not v-if or v-for or v-else
	  !isBuiltInTag(node.tag) && // not a built-in
	  isPlatformReservedTag(node.tag) && // not a component
	  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
	}
	
	function isDirectChildOfTemplateFor(node) {
	  while (node.parent) {
	    node = node.parent;
	    if (node.tag !== 'template') {
	      return false;
	    }
	    if (node.for) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
	var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  'delete': [8, 46]
	};
	
	// #4868: modifiers that prevent the execution of the listener
	// need to explicitly return null so that we can determine whether to remove
	// the listener for .once
	var genGuard = function genGuard(condition) {
	  return "if(" + condition + ")return null;";
	};
	
	var modifierCode = {
	  stop: '$event.stopPropagation();',
	  prevent: '$event.preventDefault();',
	  self: genGuard("$event.target !== $event.currentTarget"),
	  ctrl: genGuard("!$event.ctrlKey"),
	  shift: genGuard("!$event.shiftKey"),
	  alt: genGuard("!$event.altKey"),
	  meta: genGuard("!$event.metaKey"),
	  left: genGuard("'button' in $event && $event.button !== 0"),
	  middle: genGuard("'button' in $event && $event.button !== 1"),
	  right: genGuard("'button' in $event && $event.button !== 2")
	};
	
	function genHandlers(events, isNative, warn) {
	  var res = isNative ? 'nativeOn:{' : 'on:{';
	  for (var name in events) {
	    var handler = events[name];
	    // #5330: warn click.right, since right clicks do not actually fire click events.
	    if (process.env.NODE_ENV !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {
	      warn("Use \"contextmenu\" instead of \"click.right\" since right clicks " + "do not actually fire \"click\" events.");
	    }
	    res += "\"" + name + "\":" + genHandler(name, handler) + ",";
	  }
	  return res.slice(0, -1) + '}';
	}
	
	function genHandler(name, handler) {
	  if (!handler) {
	    return 'function(){}';
	  }
	
	  if (Array.isArray(handler)) {
	    return "[" + handler.map(function (handler) {
	      return genHandler(name, handler);
	    }).join(',') + "]";
	  }
	
	  var isMethodPath = simplePathRE.test(handler.value);
	  var isFunctionExpression = fnExpRE.test(handler.value);
	
	  if (!handler.modifiers) {
	    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
	  } else {
	    var code = '';
	    var genModifierCode = '';
	    var keys = [];
	    for (var key in handler.modifiers) {
	      if (modifierCode[key]) {
	        genModifierCode += modifierCode[key];
	        // left/right
	        if (keyCodes[key]) {
	          keys.push(key);
	        }
	      } else {
	        keys.push(key);
	      }
	    }
	    if (keys.length) {
	      code += genKeyFilter(keys);
	    }
	    // Make sure modifiers like prevent and stop get executed after key filtering
	    if (genModifierCode) {
	      code += genModifierCode;
	    }
	    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
	    return "function($event){" + code + handlerCode + "}";
	  }
	}
	
	function genKeyFilter(keys) {
	  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
	}
	
	function genFilterCode(key) {
	  var keyVal = parseInt(key, 10);
	  if (keyVal) {
	    return "$event.keyCode!==" + keyVal;
	  }
	  var alias = keyCodes[key];
	  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
	}
	
	/*  */
	
	function on(el, dir) {
	  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {
	    warn("v-on without argument does not support modifiers.");
	  }
	  el.wrapListeners = function (code) {
	    return "_g(" + code + "," + dir.value + ")";
	  };
	}
	
	/*  */
	
	function bind$1(el, dir) {
	  el.wrapData = function (code) {
	    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
	  };
	}
	
	/*  */
	
	var baseDirectives = {
	  on: on,
	  bind: bind$1,
	  cloak: noop
	};
	
	/*  */
	
	var CodegenState = function CodegenState(options) {
	  this.options = options;
	  this.warn = options.warn || baseWarn;
	  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
	  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
	  this.directives = extend(extend({}, baseDirectives), options.directives);
	  var isReservedTag = options.isReservedTag || no;
	  this.maybeComponent = function (el) {
	    return !isReservedTag(el.tag);
	  };
	  this.onceId = 0;
	  this.staticRenderFns = [];
	};
	
	function generate(ast, options) {
	  var state = new CodegenState(options);
	  var code = ast ? genElement(ast, state) : '_c("div")';
	  return {
	    render: "with(this){return " + code + "}",
	    staticRenderFns: state.staticRenderFns
	  };
	}
	
	function genElement(el, state) {
	  if (el.staticRoot && !el.staticProcessed) {
	    return genStatic(el, state);
	  } else if (el.once && !el.onceProcessed) {
	    return genOnce(el, state);
	  } else if (el.for && !el.forProcessed) {
	    return genFor(el, state);
	  } else if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.tag === 'template' && !el.slotTarget) {
	    return genChildren(el, state) || 'void 0';
	  } else if (el.tag === 'slot') {
	    return genSlot(el, state);
	  } else {
	    // component or element
	    var code;
	    if (el.component) {
	      code = genComponent(el.component, el, state);
	    } else {
	      var data = el.plain ? undefined : genData$2(el, state);
	
	      var children = el.inlineTemplate ? null : genChildren(el, state, true);
	      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
	    }
	    // module transforms
	    for (var i = 0; i < state.transforms.length; i++) {
	      code = state.transforms[i](el, code);
	    }
	    return code;
	  }
	}
	
	// hoist static sub-trees out
	function genStatic(el, state) {
	  el.staticProcessed = true;
	  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
	  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
	}
	
	// v-once
	function genOnce(el, state) {
	  el.onceProcessed = true;
	  if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.staticInFor) {
	    var key = '';
	    var parent = el.parent;
	    while (parent) {
	      if (parent.for) {
	        key = parent.key;
	        break;
	      }
	      parent = parent.parent;
	    }
	    if (!key) {
	      process.env.NODE_ENV !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
	      return genElement(el, state);
	    }
	    return "_o(" + genElement(el, state) + "," + state.onceId++ + (key ? "," + key : "") + ")";
	  } else {
	    return genStatic(el, state);
	  }
	}
	
	function genIf(el, state, altGen, altEmpty) {
	  el.ifProcessed = true; // avoid recursion
	  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
	}
	
	function genIfConditions(conditions, state, altGen, altEmpty) {
	  if (!conditions.length) {
	    return altEmpty || '_e()';
	  }
	
	  var condition = conditions.shift();
	  if (condition.exp) {
	    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
	  } else {
	    return "" + genTernaryExp(condition.block);
	  }
	
	  // v-if with v-once should generate code like (a)?_m(0):_m(1)
	  function genTernaryExp(el) {
	    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
	  }
	}
	
	function genFor(el, state, altGen, altHelper) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	
	  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
	    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
	    );
	  }
	
	  el.forProcessed = true; // avoid recursion
	  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
	}
	
	function genData$2(el, state) {
	  var data = '{';
	
	  // directives first.
	  // directives may mutate the el's other properties before they are generated.
	  var dirs = genDirectives(el, state);
	  if (dirs) {
	    data += dirs + ',';
	  }
	
	  // key
	  if (el.key) {
	    data += "key:" + el.key + ",";
	  }
	  // ref
	  if (el.ref) {
	    data += "ref:" + el.ref + ",";
	  }
	  if (el.refInFor) {
	    data += "refInFor:true,";
	  }
	  // pre
	  if (el.pre) {
	    data += "pre:true,";
	  }
	  // record original tag name for components using "is" attribute
	  if (el.component) {
	    data += "tag:\"" + el.tag + "\",";
	  }
	  // module data generation functions
	  for (var i = 0; i < state.dataGenFns.length; i++) {
	    data += state.dataGenFns[i](el);
	  }
	  // attributes
	  if (el.attrs) {
	    data += "attrs:{" + genProps(el.attrs) + "},";
	  }
	  // DOM props
	  if (el.props) {
	    data += "domProps:{" + genProps(el.props) + "},";
	  }
	  // event handlers
	  if (el.events) {
	    data += genHandlers(el.events, false, state.warn) + ",";
	  }
	  if (el.nativeEvents) {
	    data += genHandlers(el.nativeEvents, true, state.warn) + ",";
	  }
	  // slot target
	  if (el.slotTarget) {
	    data += "slot:" + el.slotTarget + ",";
	  }
	  // scoped slots
	  if (el.scopedSlots) {
	    data += genScopedSlots(el.scopedSlots, state) + ",";
	  }
	  // component v-model
	  if (el.model) {
	    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
	  }
	  // inline-template
	  if (el.inlineTemplate) {
	    var inlineTemplate = genInlineTemplate(el, state);
	    if (inlineTemplate) {
	      data += inlineTemplate + ",";
	    }
	  }
	  data = data.replace(/,$/, '') + '}';
	  // v-bind data wrap
	  if (el.wrapData) {
	    data = el.wrapData(data);
	  }
	  // v-on data wrap
	  if (el.wrapListeners) {
	    data = el.wrapListeners(data);
	  }
	  return data;
	}
	
	function genDirectives(el, state) {
	  var dirs = el.directives;
	  if (!dirs) {
	    return;
	  }
	  var res = 'directives:[';
	  var hasRuntime = false;
	  var i, l, dir, needRuntime;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    dir = dirs[i];
	    needRuntime = true;
	    var gen = state.directives[dir.name];
	    if (gen) {
	      // compile-time directive that manipulates AST.
	      // returns true if it also needs a runtime counterpart.
	      needRuntime = !!gen(el, dir, state.warn);
	    }
	    if (needRuntime) {
	      hasRuntime = true;
	      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
	    }
	  }
	  if (hasRuntime) {
	    return res.slice(0, -1) + ']';
	  }
	}
	
	function genInlineTemplate(el, state) {
	  var ast = el.children[0];
	  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
	    state.warn('Inline-template components must have exactly one child element.');
	  }
	  if (ast.type === 1) {
	    var inlineRenderFns = generate(ast, state.options);
	    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
	      return "function(){" + code + "}";
	    }).join(',') + "]}";
	  }
	}
	
	function genScopedSlots(slots, state) {
	  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
	    return genScopedSlot(key, slots[key], state);
	  }).join(',') + "])";
	}
	
	function genScopedSlot(key, el, state) {
	  if (el.for && !el.forProcessed) {
	    return genForScopedSlot(key, el, state);
	  }
	  return "{key:" + key + ",fn:function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + "}}";
	}
	
	function genForScopedSlot(key, el, state) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	  el.forProcessed = true; // avoid recursion
	  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
	}
	
	function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
	  var children = el.children;
	  if (children.length) {
	    var el$1 = children[0];
	    // optimize single v-for
	    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
	      return (altGenElement || genElement)(el$1, state);
	    }
	    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
	    var gen = altGenNode || genNode;
	    return "[" + children.map(function (c) {
	      return gen(c, state);
	    }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
	  }
	}
	
	// determine the normalization needed for the children array.
	// 0: no normalization needed
	// 1: simple normalization needed (possible 1-level deep nested array)
	// 2: full normalization needed
	function getNormalizationType(children, maybeComponent) {
	  var res = 0;
	  for (var i = 0; i < children.length; i++) {
	    var el = children[i];
	    if (el.type !== 1) {
	      continue;
	    }
	    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return needsNormalization(c.block);
	    })) {
	      res = 2;
	      break;
	    }
	    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return maybeComponent(c.block);
	    })) {
	      res = 1;
	    }
	  }
	  return res;
	}
	
	function needsNormalization(el) {
	  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
	}
	
	function genNode(node, state) {
	  if (node.type === 1) {
	    return genElement(node, state);
	  }if (node.type === 3 && node.isComment) {
	    return genComment(node);
	  } else {
	    return genText(node);
	  }
	}
	
	function genText(text) {
	  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
	  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
	}
	
	function genComment(comment) {
	  return "_e(" + JSON.stringify(comment.text) + ")";
	}
	
	function genSlot(el, state) {
	  var slotName = el.slotName || '"default"';
	  var children = genChildren(el, state);
	  var res = "_t(" + slotName + (children ? "," + children : '');
	  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
	    return camelize(a.name) + ":" + a.value;
	  }).join(',') + "}";
	  var bind$$1 = el.attrsMap['v-bind'];
	  if ((attrs || bind$$1) && !children) {
	    res += ",null";
	  }
	  if (attrs) {
	    res += "," + attrs;
	  }
	  if (bind$$1) {
	    res += (attrs ? '' : ',null') + "," + bind$$1;
	  }
	  return res + ')';
	}
	
	// componentName is el.component, take it as argument to shun flow's pessimistic refinement
	function genComponent(componentName, el, state) {
	  var children = el.inlineTemplate ? null : genChildren(el, state, true);
	  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
	}
	
	function genProps(props) {
	  var res = '';
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
	  }
	  return res.slice(0, -1);
	}
	
	// #3895, #4268
	function transformSpecialNewlines(text) {
	  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
	}
	
	/*  */
	
	// these keywords should not appear inside expressions, but operators like
	// typeof, instanceof and in are allowed
	var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');
	
	// these unary operators should not be used as property/method names
	var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');
	
	// check valid identifier for v-for
	var identRE = /[A-Za-z_$][\w$]*/;
	
	// strip strings in expressions
	var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
	
	// detect problematic expressions in a template
	function detectErrors(ast) {
	  var errors = [];
	  if (ast) {
	    checkNode(ast, errors);
	  }
	  return errors;
	}
	
	function checkNode(node, errors) {
	  if (node.type === 1) {
	    for (var name in node.attrsMap) {
	      if (dirRE.test(name)) {
	        var value = node.attrsMap[name];
	        if (value) {
	          if (name === 'v-for') {
	            checkFor(node, "v-for=\"" + value + "\"", errors);
	          } else if (onRE.test(name)) {
	            checkEvent(value, name + "=\"" + value + "\"", errors);
	          } else {
	            checkExpression(value, name + "=\"" + value + "\"", errors);
	          }
	        }
	      }
	    }
	    if (node.children) {
	      for (var i = 0; i < node.children.length; i++) {
	        checkNode(node.children[i], errors);
	      }
	    }
	  } else if (node.type === 2) {
	    checkExpression(node.expression, node.text, errors);
	  }
	}
	
	function checkEvent(exp, text, errors) {
	  var stipped = exp.replace(stripStringRE, '');
	  var keywordMatch = stipped.match(unaryOperatorsRE);
	  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
	    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	  }
	  checkExpression(exp, text, errors);
	}
	
	function checkFor(node, text, errors) {
	  checkExpression(node.for || '', text, errors);
	  checkIdentifier(node.alias, 'v-for alias', text, errors);
	  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
	  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
	}
	
	function checkIdentifier(ident, type, text, errors) {
	  if (typeof ident === 'string' && !identRE.test(ident)) {
	    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
	  }
	}
	
	function checkExpression(exp, text, errors) {
	  try {
	    new Function("return " + exp);
	  } catch (e) {
	    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
	    if (keywordMatch) {
	      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	    } else {
	      errors.push("invalid expression: " + text.trim());
	    }
	  }
	}
	
	/*  */
	
	function createFunction(code, errors) {
	  try {
	    return new Function(code);
	  } catch (err) {
	    errors.push({ err: err, code: code });
	    return noop;
	  }
	}
	
	function createCompileToFunctionFn(compile) {
	  var cache = Object.create(null);
	
	  return function compileToFunctions(template, options, vm) {
	    options = options || {};
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      // detect possible CSP restriction
	      try {
	        new Function('return 1');
	      } catch (e) {
	        if (e.toString().match(/unsafe-eval|CSP/)) {
	          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
	        }
	      }
	    }
	
	    // check cache
	    var key = options.delimiters ? String(options.delimiters) + template : template;
	    if (cache[key]) {
	      return cache[key];
	    }
	
	    // compile
	    var compiled = compile(template, options);
	
	    // check compilation errors/tips
	    if (process.env.NODE_ENV !== 'production') {
	      if (compiled.errors && compiled.errors.length) {
	        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
	          return "- " + e;
	        }).join('\n') + '\n', vm);
	      }
	      if (compiled.tips && compiled.tips.length) {
	        compiled.tips.forEach(function (msg) {
	          return tip(msg, vm);
	        });
	      }
	    }
	
	    // turn code into functions
	    var res = {};
	    var fnGenErrors = [];
	    res.render = createFunction(compiled.render, fnGenErrors);
	    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
	      return createFunction(code, fnGenErrors);
	    });
	
	    // check function generation errors.
	    // this should only happen if there is a bug in the compiler itself.
	    // mostly for codegen development use
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
	        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
	          var err = ref.err;
	          var code = ref.code;
	
	          return err.toString() + " in\n\n" + code + "\n";
	        }).join('\n'), vm);
	      }
	    }
	
	    return cache[key] = res;
	  };
	}
	
	/*  */
	
	function createCompilerCreator(baseCompile) {
	  return function createCompiler(baseOptions) {
	    function compile(template, options) {
	      var finalOptions = Object.create(baseOptions);
	      var errors = [];
	      var tips = [];
	      finalOptions.warn = function (msg, tip) {
	        (tip ? tips : errors).push(msg);
	      };
	
	      if (options) {
	        // merge custom modules
	        if (options.modules) {
	          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
	        }
	        // merge custom directives
	        if (options.directives) {
	          finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
	        }
	        // copy other options
	        for (var key in options) {
	          if (key !== 'modules' && key !== 'directives') {
	            finalOptions[key] = options[key];
	          }
	        }
	      }
	
	      var compiled = baseCompile(template, finalOptions);
	      if (process.env.NODE_ENV !== 'production') {
	        errors.push.apply(errors, detectErrors(compiled.ast));
	      }
	      compiled.errors = errors;
	      compiled.tips = tips;
	      return compiled;
	    }
	
	    return {
	      compile: compile,
	      compileToFunctions: createCompileToFunctionFn(compile)
	    };
	  };
	}
	
	/*  */
	
	// `createCompilerCreator` allows creating compilers that use alternative
	// parser/optimizer/codegen, e.g the SSR optimizing compiler.
	// Here we just export a default compiler using the default parts.
	var createCompiler = createCompilerCreator(function baseCompile(template, options) {
	  var ast = parse(template.trim(), options);
	  optimize(ast, options);
	  var code = generate(ast, options);
	  return {
	    ast: ast,
	    render: code.render,
	    staticRenderFns: code.staticRenderFns
	  };
	});
	
	/*  */
	
	var ref$1 = createCompiler(baseOptions);
	var compileToFunctions = ref$1.compileToFunctions;
	
	/*  */
	
	var idToTemplate = cached(function (id) {
	  var el = query(id);
	  return el && el.innerHTML;
	});
	
	var mount = Vue$3.prototype.$mount;
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && query(el);
	
	  /* istanbul ignore if */
	  if (el === document.body || el === document.documentElement) {
	    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
	    return this;
	  }
	
	  var options = this.$options;
	  // resolve template/el and convert to render function
	  if (!options.render) {
	    var template = options.template;
	    if (template) {
	      if (typeof template === 'string') {
	        if (template.charAt(0) === '#') {
	          template = idToTemplate(template);
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !template) {
	            warn("Template element not found or is empty: " + options.template, this);
	          }
	        }
	      } else if (template.nodeType) {
	        template = template.innerHTML;
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          warn('invalid template option:' + template, this);
	        }
	        return this;
	      }
	    } else if (el) {
	      template = getOuterHTML(el);
	    }
	    if (template) {
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile');
	      }
	
	      var ref = compileToFunctions(template, {
	        shouldDecodeNewlines: shouldDecodeNewlines,
	        delimiters: options.delimiters,
	        comments: options.comments
	      }, this);
	      var render = ref.render;
	      var staticRenderFns = ref.staticRenderFns;
	      options.render = render;
	      options.staticRenderFns = staticRenderFns;
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile end');
	        measure(this._name + " compile", 'compile', 'compile end');
	      }
	    }
	  }
	  return mount.call(this, el, hydrating);
	};
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 */
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	Vue$3.compile = compileToFunctions;
	
	exports.default = Vue$3;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) {
	    return [];
	};
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, module) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
	 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	
	(function (definition) {
	    "use strict";
	
	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.
	
	    // Montage Require
	
	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);
	
	        // CommonJS
	    } else if (( false ? "undefined" : _typeof(exports)) === "object" && ( false ? "undefined" : _typeof(module)) === "object") {
	        module.exports = definition();
	
	        // RequireJS
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	        // SES (Secure EcmaScript)
	    } else if (typeof ses !== "undefined") {
	        if (!ses.ok()) {
	            return;
	        } else {
	            ses.makeQ = definition;
	        }
	
	        // <script>
	    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
	        // Prefer window over self for add-on scripts. Use self for
	        // non-windowed contexts.
	        var global = typeof window !== "undefined" ? window : self;
	
	        // Get the `window` object, save the previous Q global
	        // and initialize Q as a global.
	        var previousQ = global.Q;
	        global.Q = definition();
	
	        // Add a noConflict function so Q can be removed from the
	        // global namespace.
	        global.Q.noConflict = function () {
	            global.Q = previousQ;
	            return this;
	        };
	    } else {
	        throw new Error("This environment was not anticipated by Q. Please file a bug.");
	    }
	})(function () {
	    "use strict";
	
	    var hasStacks = false;
	    try {
	        throw new Error();
	    } catch (e) {
	        hasStacks = !!e.stack;
	    }
	
	    // All code after this point will be filtered from stack traces reported
	    // by Q.
	    var qStartingLine = captureLine();
	    var qFileName;
	
	    // shims
	
	    // used for fallback in "allResolved"
	    var noop = function noop() {};
	
	    // Use the fastest possible means to execute a task in a future turn
	    // of the event loop.
	    var nextTick = function () {
	        // linked list of tasks (single, with head node)
	        var head = { task: void 0, next: null };
	        var tail = head;
	        var flushing = false;
	        var requestTick = void 0;
	        var isNodeJS = false;
	        // queue for late tasks, used by unhandled rejection tracking
	        var laterQueue = [];
	
	        function flush() {
	            /* jshint loopfunc: true */
	            var task, domain;
	
	            while (head.next) {
	                head = head.next;
	                task = head.task;
	                head.task = void 0;
	                domain = head.domain;
	
	                if (domain) {
	                    head.domain = void 0;
	                    domain.enter();
	                }
	                runSingle(task, domain);
	            }
	            while (laterQueue.length) {
	                task = laterQueue.pop();
	                runSingle(task);
	            }
	            flushing = false;
	        }
	        // runs a single function in the async queue
	        function runSingle(task, domain) {
	            try {
	                task();
	            } catch (e) {
	                if (isNodeJS) {
	                    // In node, uncaught exceptions are considered fatal errors.
	                    // Re-throw them synchronously to interrupt flushing!
	
	                    // Ensure continuation if the uncaught exception is suppressed
	                    // listening "uncaughtException" events (as domains does).
	                    // Continue in next event to avoid tick recursion.
	                    if (domain) {
	                        domain.exit();
	                    }
	                    setTimeout(flush, 0);
	                    if (domain) {
	                        domain.enter();
	                    }
	
	                    throw e;
	                } else {
	                    // In browsers, uncaught exceptions are not fatal.
	                    // Re-throw them asynchronously to avoid slow-downs.
	                    setTimeout(function () {
	                        throw e;
	                    }, 0);
	                }
	            }
	
	            if (domain) {
	                domain.exit();
	            }
	        }
	
	        nextTick = function nextTick(task) {
	            tail = tail.next = {
	                task: task,
	                domain: isNodeJS && process.domain,
	                next: null
	            };
	
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.toString() === "[object process]" && process.nextTick) {
	            // Ensure Q is in a real Node environment, with a `process.nextTick`.
	            // To see through fake Node environments:
	            // * Mocha test runner - exposes a `process` global without a `nextTick`
	            // * Browserify - exposes a `process.nexTick` function that uses
	            //   `setTimeout`. In this case `setImmediate` is preferred because
	            //    it is faster. Browserify's `process.toString()` yields
	            //   "[object Object]", while in a real Node environment
	            //   `process.toString()` yields "[object process]".
	            isNodeJS = true;
	
	            requestTick = function requestTick() {
	                process.nextTick(flush);
	            };
	        } else if (typeof setImmediate === "function") {
	            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	            if (typeof window !== "undefined") {
	                requestTick = setImmediate.bind(window, flush);
	            } else {
	                requestTick = function requestTick() {
	                    setImmediate(flush);
	                };
	            }
	        } else if (typeof MessageChannel !== "undefined") {
	            // modern browsers
	            // http://www.nonblocking.io/2011/06/windownexttick.html
	            var channel = new MessageChannel();
	            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	            // working message ports the first time a page loads.
	            channel.port1.onmessage = function () {
	                requestTick = requestPortTick;
	                channel.port1.onmessage = flush;
	                flush();
	            };
	            var requestPortTick = function requestPortTick() {
	                // Opera requires us to provide a message payload, regardless of
	                // whether we use it.
	                channel.port2.postMessage(0);
	            };
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	                requestPortTick();
	            };
	        } else {
	            // old browsers
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	            };
	        }
	        // runs a task after all other tasks have been run
	        // this is useful for unhandled rejection tracking that needs to happen
	        // after all `then`d tasks have been run.
	        nextTick.runAfter = function (task) {
	            laterQueue.push(task);
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	        return nextTick;
	    }();
	
	    // Attempt to make generics safe in the face of downstream
	    // modifications.
	    // There is no situation where this is necessary.
	    // If you need a security guarantee, these primordials need to be
	    // deeply frozen anyway, and if you don’t need a security guarantee,
	    // this is just plain paranoid.
	    // However, this **might** have the nice side-effect of reducing the size of
	    // the minified code by reducing x.call() to merely x()
	    // See Mark Miller’s explanation of what this does.
	    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	    var call = Function.call;
	    function uncurryThis(f) {
	        return function () {
	            return call.apply(f, arguments);
	        };
	    }
	    // This is equivalent, but slower:
	    // uncurryThis = Function_bind.bind(Function_bind.call);
	    // http://jsperf.com/uncurrythis
	
	    var array_slice = uncurryThis(Array.prototype.slice);
	
	    var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    });
	
	    var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    });
	
	    var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    });
	
	    var object_create = Object.create || function (prototype) {
	        function Type() {}
	        Type.prototype = prototype;
	        return new Type();
	    };
	
	    var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
	        obj[prop] = descriptor.value;
	        return obj;
	    };
	
	    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
	
	    var object_keys = Object.keys || function (object) {
	        var keys = [];
	        for (var key in object) {
	            if (object_hasOwnProperty(object, key)) {
	                keys.push(key);
	            }
	        }
	        return keys;
	    };
	
	    var object_toString = uncurryThis(Object.prototype.toString);
	
	    function isObject(value) {
	        return value === Object(value);
	    }
	
	    // generator related shims
	
	    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	    function isStopIteration(exception) {
	        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
	    }
	
	    // FIXME: Remove this helper and Q.return once ES6 generators are in
	    // SpiderMonkey.
	    var QReturnValue;
	    if (typeof ReturnValue !== "undefined") {
	        QReturnValue = ReturnValue;
	    } else {
	        QReturnValue = function QReturnValue(value) {
	            this.value = value;
	        };
	    }
	
	    // long stack traces
	
	    var STACK_JUMP_SEPARATOR = "From previous event:";
	
	    function makeStackTraceLong(error, promise) {
	        // If possible, transform the error stack trace by removing Node and Q
	        // cruft, then concatenating with the stack trace of `promise`. See #57.
	        if (hasStacks && promise.stack && (typeof error === "undefined" ? "undefined" : _typeof(error)) === "object" && error !== null && error.stack) {
	            var stacks = [];
	            for (var p = promise; !!p; p = p.source) {
	                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
	                    object_defineProperty(error, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
	                    stacks.unshift(p.stack);
	                }
	            }
	            stacks.unshift(error.stack);
	
	            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	            var stack = filterStackString(concatedStacks);
	            object_defineProperty(error, "stack", { value: stack, configurable: true });
	        }
	    }
	
	    function filterStackString(stackString) {
	        var lines = stackString.split("\n");
	        var desiredLines = [];
	        for (var i = 0; i < lines.length; ++i) {
	            var line = lines[i];
	
	            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	                desiredLines.push(line);
	            }
	        }
	        return desiredLines.join("\n");
	    }
	
	    function isNodeFrame(stackLine) {
	        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
	    }
	
	    function getFileNameAndLineNumber(stackLine) {
	        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	        // In IE10 function name can have spaces ("Anonymous function") O_o
	        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	        if (attempt1) {
	            return [attempt1[1], Number(attempt1[2])];
	        }
	
	        // Anonymous functions: "at filename:lineNumber:columnNumber"
	        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	        if (attempt2) {
	            return [attempt2[1], Number(attempt2[2])];
	        }
	
	        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	        if (attempt3) {
	            return [attempt3[1], Number(attempt3[2])];
	        }
	    }
	
	    function isInternalFrame(stackLine) {
	        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
	
	        if (!fileNameAndLineNumber) {
	            return false;
	        }
	
	        var fileName = fileNameAndLineNumber[0];
	        var lineNumber = fileNameAndLineNumber[1];
	
	        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
	    }
	
	    // discover own file name and line number range for filtering stack
	    // traces
	    function captureLine() {
	        if (!hasStacks) {
	            return;
	        }
	
	        try {
	            throw new Error();
	        } catch (e) {
	            var lines = e.stack.split("\n");
	            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	            if (!fileNameAndLineNumber) {
	                return;
	            }
	
	            qFileName = fileNameAndLineNumber[0];
	            return fileNameAndLineNumber[1];
	        }
	    }
	
	    function deprecate(callback, name, alternative) {
	        return function () {
	            if (typeof console !== "undefined" && typeof console.warn === "function") {
	                console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
	            }
	            return callback.apply(callback, arguments);
	        };
	    }
	
	    // end of shims
	    // beginning of real work
	
	    /**
	     * Constructs a promise for an immediate reference, passes promises through, or
	     * coerces promises from different systems.
	     * @param value immediate reference or promise
	     */
	    function Q(value) {
	        // If the object is already a Promise, return it directly.  This enables
	        // the resolve function to both be used to created references from objects,
	        // but to tolerably coerce non-promises to promises.
	        if (value instanceof Promise) {
	            return value;
	        }
	
	        // assimilate thenables
	        if (isPromiseAlike(value)) {
	            return coerce(value);
	        } else {
	            return fulfill(value);
	        }
	    }
	    Q.resolve = Q;
	
	    /**
	     * Performs a task in a future turn of the event loop.
	     * @param {Function} task
	     */
	    Q.nextTick = nextTick;
	
	    /**
	     * Controls whether or not long stack traces will be on
	     */
	    Q.longStackSupport = false;
	
	    /**
	     * The counter is used to determine the stopping point for building
	     * long stack traces. In makeStackTraceLong we walk backwards through
	     * the linked list of promises, only stacks which were created before
	     * the rejection are concatenated.
	     */
	    var longStackCounter = 1;
	
	    // enable long stacks if Q_DEBUG is set
	    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.env && process.env.Q_DEBUG) {
	        Q.longStackSupport = true;
	    }
	
	    /**
	     * Constructs a {promise, resolve, reject} object.
	     *
	     * `resolve` is a callback to invoke with a more resolved value for the
	     * promise. To fulfill the promise, invoke `resolve` with any value that is
	     * not a thenable. To reject the promise, invoke `resolve` with a rejected
	     * thenable, or invoke `reject` with the reason directly. To resolve the
	     * promise to another thenable, thus putting it in the same state, invoke
	     * `resolve` with that other thenable.
	     */
	    Q.defer = defer;
	    function defer() {
	        // if "messages" is an "Array", that indicates that the promise has not yet
	        // been resolved.  If it is "undefined", it has been resolved.  Each
	        // element of the messages array is itself an array of complete arguments to
	        // forward to the resolved promise.  We coerce the resolution value to a
	        // promise using the `resolve` function because it handles both fully
	        // non-thenable values and other thenables gracefully.
	        var messages = [],
	            progressListeners = [],
	            resolvedPromise;
	
	        var deferred = object_create(defer.prototype);
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, operands) {
	            var args = array_slice(arguments);
	            if (messages) {
	                messages.push(args);
	                if (op === "when" && operands[1]) {
	                    // progress operand
	                    progressListeners.push(operands[1]);
	                }
	            } else {
	                Q.nextTick(function () {
	                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	                });
	            }
	        };
	
	        // XXX deprecated
	        promise.valueOf = function () {
	            if (messages) {
	                return promise;
	            }
	            var nearerValue = nearer(resolvedPromise);
	            if (isPromise(nearerValue)) {
	                resolvedPromise = nearerValue; // shorten chain
	            }
	            return nearerValue;
	        };
	
	        promise.inspect = function () {
	            if (!resolvedPromise) {
	                return { state: "pending" };
	            }
	            return resolvedPromise.inspect();
	        };
	
	        if (Q.longStackSupport && hasStacks) {
	            try {
	                throw new Error();
	            } catch (e) {
	                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	                // accessor around; that causes memory leaks as per GH-111. Just
	                // reify the stack trace as a string ASAP.
	                //
	                // At the same time, cut off the first line; it's always just
	                // "[object Promise]\n", as per the `toString`.
	                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	                promise.stackCounter = longStackCounter++;
	            }
	        }
	
	        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	        // consolidating them into `become`, since otherwise we'd create new
	        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
	
	        function become(newPromise) {
	            resolvedPromise = newPromise;
	
	            if (Q.longStackSupport && hasStacks) {
	                // Only hold a reference to the new promise if long stacks
	                // are enabled to reduce memory usage
	                promise.source = newPromise;
	            }
	
	            array_reduce(messages, function (undefined, message) {
	                Q.nextTick(function () {
	                    newPromise.promiseDispatch.apply(newPromise, message);
	                });
	            }, void 0);
	
	            messages = void 0;
	            progressListeners = void 0;
	        }
	
	        deferred.promise = promise;
	        deferred.resolve = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(Q(value));
	        };
	
	        deferred.fulfill = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(fulfill(value));
	        };
	        deferred.reject = function (reason) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(reject(reason));
	        };
	        deferred.notify = function (progress) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            array_reduce(progressListeners, function (undefined, progressListener) {
	                Q.nextTick(function () {
	                    progressListener(progress);
	                });
	            }, void 0);
	        };
	
	        return deferred;
	    }
	
	    /**
	     * Creates a Node-style callback that will resolve or reject the deferred
	     * promise.
	     * @returns a nodeback
	     */
	    defer.prototype.makeNodeResolver = function () {
	        var self = this;
	        return function (error, value) {
	            if (error) {
	                self.reject(error);
	            } else if (arguments.length > 2) {
	                self.resolve(array_slice(arguments, 1));
	            } else {
	                self.resolve(value);
	            }
	        };
	    };
	
	    /**
	     * @param resolver {Function} a function that returns nothing and accepts
	     * the resolve, reject, and notify functions for a deferred.
	     * @returns a promise that may be resolved with the given resolve and reject
	     * functions, or rejected by a thrown exception in resolver
	     */
	    Q.Promise = promise; // ES6
	    Q.promise = promise;
	    function promise(resolver) {
	        if (typeof resolver !== "function") {
	            throw new TypeError("resolver must be a function.");
	        }
	        var deferred = defer();
	        try {
	            resolver(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (reason) {
	            deferred.reject(reason);
	        }
	        return deferred.promise;
	    }
	
	    promise.race = race; // ES6
	    promise.all = all; // ES6
	    promise.reject = reject; // ES6
	    promise.resolve = Q; // ES6
	
	    // XXX experimental.  This method is a way to denote that a local value is
	    // serializable and should be immediately dispatched to a remote upon request,
	    // instead of passing a reference.
	    Q.passByCopy = function (object) {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return object;
	    };
	
	    Promise.prototype.passByCopy = function () {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return this;
	    };
	
	    /**
	     * If two promises eventually fulfill to the same value, promises that value,
	     * but otherwise rejects.
	     * @param x {Any*}
	     * @param y {Any*}
	     * @returns {Any*} a promise for x and y if they are the same, but a rejection
	     * otherwise.
	     *
	     */
	    Q.join = function (x, y) {
	        return Q(x).join(y);
	    };
	
	    Promise.prototype.join = function (that) {
	        return Q([this, that]).spread(function (x, y) {
	            if (x === y) {
	                // TODO: "===" should be Object.is or equiv
	                return x;
	            } else {
	                throw new Error("Q can't join: not the same: " + x + " " + y);
	            }
	        });
	    };
	
	    /**
	     * Returns a promise for the first of an array of promises to become settled.
	     * @param answers {Array[Any*]} promises to race
	     * @returns {Any*} the first promise to be settled
	     */
	    Q.race = race;
	    function race(answerPs) {
	        return promise(function (resolve, reject) {
	            // Switch to this once we can assume at least ES5
	            // answerPs.forEach(function (answerP) {
	            //     Q(answerP).then(resolve, reject);
	            // });
	            // Use this in the meantime
	            for (var i = 0, len = answerPs.length; i < len; i++) {
	                Q(answerPs[i]).then(resolve, reject);
	            }
	        });
	    }
	
	    Promise.prototype.race = function () {
	        return this.then(Q.race);
	    };
	
	    /**
	     * Constructs a Promise with a promise descriptor object and optional fallback
	     * function.  The descriptor contains methods like when(rejected), get(name),
	     * set(name, value), post(name, args), and delete(name), which all
	     * return either a value, a promise for a value, or a rejection.  The fallback
	     * accepts the operation name, a resolver, and any further arguments that would
	     * have been forwarded to the appropriate method above had a method been
	     * provided with the proper name.  The API makes no guarantees about the nature
	     * of the returned object, apart from that it is usable whereever promises are
	     * bought and sold.
	     */
	    Q.makePromise = Promise;
	    function Promise(descriptor, fallback, inspect) {
	        if (fallback === void 0) {
	            fallback = function fallback(op) {
	                return reject(new Error("Promise does not support operation: " + op));
	            };
	        }
	        if (inspect === void 0) {
	            inspect = function inspect() {
	                return { state: "unknown" };
	            };
	        }
	
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, args) {
	            var result;
	            try {
	                if (descriptor[op]) {
	                    result = descriptor[op].apply(promise, args);
	                } else {
	                    result = fallback.call(promise, op, args);
	                }
	            } catch (exception) {
	                result = reject(exception);
	            }
	            if (resolve) {
	                resolve(result);
	            }
	        };
	
	        promise.inspect = inspect;
	
	        // XXX deprecated `valueOf` and `exception` support
	        if (inspect) {
	            var inspected = inspect();
	            if (inspected.state === "rejected") {
	                promise.exception = inspected.reason;
	            }
	
	            promise.valueOf = function () {
	                var inspected = inspect();
	                if (inspected.state === "pending" || inspected.state === "rejected") {
	                    return promise;
	                }
	                return inspected.value;
	            };
	        }
	
	        return promise;
	    }
	
	    Promise.prototype.toString = function () {
	        return "[object Promise]";
	    };
	
	    Promise.prototype.then = function (fulfilled, rejected, progressed) {
	        var self = this;
	        var deferred = defer();
	        var done = false; // ensure the untrusted promise makes at most a
	        // single call to one of the callbacks
	
	        function _fulfilled(value) {
	            try {
	                return typeof fulfilled === "function" ? fulfilled(value) : value;
	            } catch (exception) {
	                return reject(exception);
	            }
	        }
	
	        function _rejected(exception) {
	            if (typeof rejected === "function") {
	                makeStackTraceLong(exception, self);
	                try {
	                    return rejected(exception);
	                } catch (newException) {
	                    return reject(newException);
	                }
	            }
	            return reject(exception);
	        }
	
	        function _progressed(value) {
	            return typeof progressed === "function" ? progressed(value) : value;
	        }
	
	        Q.nextTick(function () {
	            self.promiseDispatch(function (value) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_fulfilled(value));
	            }, "when", [function (exception) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_rejected(exception));
	            }]);
	        });
	
	        // Progress propagator need to be attached in the current tick.
	        self.promiseDispatch(void 0, "when", [void 0, function (value) {
	            var newValue;
	            var threw = false;
	            try {
	                newValue = _progressed(value);
	            } catch (e) {
	                threw = true;
	                if (Q.onerror) {
	                    Q.onerror(e);
	                } else {
	                    throw e;
	                }
	            }
	
	            if (!threw) {
	                deferred.notify(newValue);
	            }
	        }]);
	
	        return deferred.promise;
	    };
	
	    Q.tap = function (promise, callback) {
	        return Q(promise).tap(callback);
	    };
	
	    /**
	     * Works almost like "finally", but not called for rejections.
	     * Original resolution value is passed through callback unaffected.
	     * Callback may return a promise that will be awaited for.
	     * @param {Function} callback
	     * @returns {Q.Promise}
	     * @example
	     * doSomething()
	     *   .then(...)
	     *   .tap(console.log)
	     *   .then(...);
	     */
	    Promise.prototype.tap = function (callback) {
	        callback = Q(callback);
	
	        return this.then(function (value) {
	            return callback.fcall(value).thenResolve(value);
	        });
	    };
	
	    /**
	     * Registers an observer on a promise.
	     *
	     * Guarantees:
	     *
	     * 1. that fulfilled and rejected will be called only once.
	     * 2. that either the fulfilled callback or the rejected callback will be
	     *    called, but not both.
	     * 3. that fulfilled and rejected will not be called in this turn.
	     *
	     * @param value      promise or immediate reference to observe
	     * @param fulfilled  function to be called with the fulfilled value
	     * @param rejected   function to be called with the rejection exception
	     * @param progressed function to be called on any progress notifications
	     * @return promise for the return value from the invoked callback
	     */
	    Q.when = when;
	    function when(value, fulfilled, rejected, progressed) {
	        return Q(value).then(fulfilled, rejected, progressed);
	    }
	
	    Promise.prototype.thenResolve = function (value) {
	        return this.then(function () {
	            return value;
	        });
	    };
	
	    Q.thenResolve = function (promise, value) {
	        return Q(promise).thenResolve(value);
	    };
	
	    Promise.prototype.thenReject = function (reason) {
	        return this.then(function () {
	            throw reason;
	        });
	    };
	
	    Q.thenReject = function (promise, reason) {
	        return Q(promise).thenReject(reason);
	    };
	
	    /**
	     * If an object is not a promise, it is as "near" as possible.
	     * If a promise is rejected, it is as "near" as possible too.
	     * If it’s a fulfilled promise, the fulfillment value is nearer.
	     * If it’s a deferred promise and the deferred has been resolved, the
	     * resolution is "nearer".
	     * @param object
	     * @returns most resolved (nearest) form of the object
	     */
	
	    // XXX should we re-do this?
	    Q.nearer = nearer;
	    function nearer(value) {
	        if (isPromise(value)) {
	            var inspected = value.inspect();
	            if (inspected.state === "fulfilled") {
	                return inspected.value;
	            }
	        }
	        return value;
	    }
	
	    /**
	     * @returns whether the given object is a promise.
	     * Otherwise it is a fulfilled value.
	     */
	    Q.isPromise = isPromise;
	    function isPromise(object) {
	        return object instanceof Promise;
	    }
	
	    Q.isPromiseAlike = isPromiseAlike;
	    function isPromiseAlike(object) {
	        return isObject(object) && typeof object.then === "function";
	    }
	
	    /**
	     * @returns whether the given object is a pending promise, meaning not
	     * fulfilled or rejected.
	     */
	    Q.isPending = isPending;
	    function isPending(object) {
	        return isPromise(object) && object.inspect().state === "pending";
	    }
	
	    Promise.prototype.isPending = function () {
	        return this.inspect().state === "pending";
	    };
	
	    /**
	     * @returns whether the given object is a value or fulfilled
	     * promise.
	     */
	    Q.isFulfilled = isFulfilled;
	    function isFulfilled(object) {
	        return !isPromise(object) || object.inspect().state === "fulfilled";
	    }
	
	    Promise.prototype.isFulfilled = function () {
	        return this.inspect().state === "fulfilled";
	    };
	
	    /**
	     * @returns whether the given object is a rejected promise.
	     */
	    Q.isRejected = isRejected;
	    function isRejected(object) {
	        return isPromise(object) && object.inspect().state === "rejected";
	    }
	
	    Promise.prototype.isRejected = function () {
	        return this.inspect().state === "rejected";
	    };
	
	    //// BEGIN UNHANDLED REJECTION TRACKING
	
	    // This promise library consumes exceptions thrown in handlers so they can be
	    // handled by a subsequent promise.  The exceptions get added to this array when
	    // they are created, and removed when they are handled.  Note that in ES6 or
	    // shimmed environments, this would naturally be a `Set`.
	    var unhandledReasons = [];
	    var unhandledRejections = [];
	    var reportedUnhandledRejections = [];
	    var trackUnhandledRejections = true;
	
	    function resetUnhandledRejections() {
	        unhandledReasons.length = 0;
	        unhandledRejections.length = 0;
	
	        if (!trackUnhandledRejections) {
	            trackUnhandledRejections = true;
	        }
	    }
	
	    function trackRejection(promise, reason) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	            Q.nextTick.runAfter(function () {
	                if (array_indexOf(unhandledRejections, promise) !== -1) {
	                    process.emit("unhandledRejection", reason, promise);
	                    reportedUnhandledRejections.push(promise);
	                }
	            });
	        }
	
	        unhandledRejections.push(promise);
	        if (reason && typeof reason.stack !== "undefined") {
	            unhandledReasons.push(reason.stack);
	        } else {
	            unhandledReasons.push("(no stack) " + reason);
	        }
	    }
	
	    function untrackRejection(promise) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	
	        var at = array_indexOf(unhandledRejections, promise);
	        if (at !== -1) {
	            if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	                Q.nextTick.runAfter(function () {
	                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
	                    if (atReport !== -1) {
	                        process.emit("rejectionHandled", unhandledReasons[at], promise);
	                        reportedUnhandledRejections.splice(atReport, 1);
	                    }
	                });
	            }
	            unhandledRejections.splice(at, 1);
	            unhandledReasons.splice(at, 1);
	        }
	    }
	
	    Q.resetUnhandledRejections = resetUnhandledRejections;
	
	    Q.getUnhandledReasons = function () {
	        // Make a copy so that consumers can't interfere with our internal state.
	        return unhandledReasons.slice();
	    };
	
	    Q.stopUnhandledRejectionTracking = function () {
	        resetUnhandledRejections();
	        trackUnhandledRejections = false;
	    };
	
	    resetUnhandledRejections();
	
	    //// END UNHANDLED REJECTION TRACKING
	
	    /**
	     * Constructs a rejected promise.
	     * @param reason value describing the failure
	     */
	    Q.reject = reject;
	    function reject(reason) {
	        var rejection = Promise({
	            "when": function when(rejected) {
	                // note that the error has been handled
	                if (rejected) {
	                    untrackRejection(this);
	                }
	                return rejected ? rejected(reason) : this;
	            }
	        }, function fallback() {
	            return this;
	        }, function inspect() {
	            return { state: "rejected", reason: reason };
	        });
	
	        // Note that the reason has not been handled.
	        trackRejection(rejection, reason);
	
	        return rejection;
	    }
	
	    /**
	     * Constructs a fulfilled promise for an immediate reference.
	     * @param value immediate reference
	     */
	    Q.fulfill = fulfill;
	    function fulfill(value) {
	        return Promise({
	            "when": function when() {
	                return value;
	            },
	            "get": function get(name) {
	                return value[name];
	            },
	            "set": function set(name, rhs) {
	                value[name] = rhs;
	            },
	            "delete": function _delete(name) {
	                delete value[name];
	            },
	            "post": function post(name, args) {
	                // Mark Miller proposes that post with no name should apply a
	                // promised function.
	                if (name === null || name === void 0) {
	                    return value.apply(void 0, args);
	                } else {
	                    return value[name].apply(value, args);
	                }
	            },
	            "apply": function apply(thisp, args) {
	                return value.apply(thisp, args);
	            },
	            "keys": function keys() {
	                return object_keys(value);
	            }
	        }, void 0, function inspect() {
	            return { state: "fulfilled", value: value };
	        });
	    }
	
	    /**
	     * Converts thenables to Q promises.
	     * @param promise thenable promise
	     * @returns a Q promise
	     */
	    function coerce(promise) {
	        var deferred = defer();
	        Q.nextTick(function () {
	            try {
	                promise.then(deferred.resolve, deferred.reject, deferred.notify);
	            } catch (exception) {
	                deferred.reject(exception);
	            }
	        });
	        return deferred.promise;
	    }
	
	    /**
	     * Annotates an object such that it will never be
	     * transferred away from this process over any promise
	     * communication channel.
	     * @param object
	     * @returns promise a wrapping of that object that
	     * additionally responds to the "isDef" message
	     * without a rejection.
	     */
	    Q.master = master;
	    function master(object) {
	        return Promise({
	            "isDef": function isDef() {}
	        }, function fallback(op, args) {
	            return dispatch(object, op, args);
	        }, function () {
	            return Q(object).inspect();
	        });
	    }
	
	    /**
	     * Spreads the values of a promised array of arguments into the
	     * fulfillment callback.
	     * @param fulfilled callback that receives variadic arguments from the
	     * promised array
	     * @param rejected callback that receives the exception if the promise
	     * is rejected.
	     * @returns a promise for the return value or thrown exception of
	     * either callback.
	     */
	    Q.spread = spread;
	    function spread(value, fulfilled, rejected) {
	        return Q(value).spread(fulfilled, rejected);
	    }
	
	    Promise.prototype.spread = function (fulfilled, rejected) {
	        return this.all().then(function (array) {
	            return fulfilled.apply(void 0, array);
	        }, rejected);
	    };
	
	    /**
	     * The async function is a decorator for generator functions, turning
	     * them into asynchronous generators.  Although generators are only part
	     * of the newest ECMAScript 6 drafts, this code does not cause syntax
	     * errors in older engines.  This code should continue to work and will
	     * in fact improve over time as the language improves.
	     *
	     * ES6 generators are currently part of V8 version 3.19 with the
	     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	     * for longer, but under an older Python-inspired form.  This function
	     * works on both kinds of generators.
	     *
	     * Decorates a generator function such that:
	     *  - it may yield promises
	     *  - execution will continue when that promise is fulfilled
	     *  - the value of the yield expression will be the fulfilled value
	     *  - it returns a promise for the return value (when the generator
	     *    stops iterating)
	     *  - the decorated function returns a promise for the return value
	     *    of the generator or the first rejected promise among those
	     *    yielded.
	     *  - if an error is thrown in the generator, it propagates through
	     *    every following yield until it is caught, or until it escapes
	     *    the generator function altogether, and is translated into a
	     *    rejection for the promise returned by the decorated generator.
	     */
	    Q.async = async;
	    function async(makeGenerator) {
	        return function () {
	            // when verb is "send", arg is a value
	            // when verb is "throw", arg is an exception
	            function continuer(verb, arg) {
	                var result;
	
	                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	                // engine that has a deployed base of browsers that support generators.
	                // However, SM's generators use the Python-inspired semantics of
	                // outdated ES6 drafts.  We would like to support ES6, but we'd also
	                // like to make it possible to use generators in deployed browsers, so
	                // we also support Python-style generators.  At some point we can remove
	                // this block.
	
	                if (typeof StopIteration === "undefined") {
	                    // ES6 Generators
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        return reject(exception);
	                    }
	                    if (result.done) {
	                        return Q(result.value);
	                    } else {
	                        return when(result.value, callback, errback);
	                    }
	                } else {
	                    // SpiderMonkey Generators
	                    // FIXME: Remove this case when SM does ES6 generators.
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        if (isStopIteration(exception)) {
	                            return Q(exception.value);
	                        } else {
	                            return reject(exception);
	                        }
	                    }
	                    return when(result, callback, errback);
	                }
	            }
	            var generator = makeGenerator.apply(this, arguments);
	            var callback = continuer.bind(continuer, "next");
	            var errback = continuer.bind(continuer, "throw");
	            return callback();
	        };
	    }
	
	    /**
	     * The spawn function is a small wrapper around async that immediately
	     * calls the generator and also ends the promise chain, so that any
	     * unhandled errors are thrown instead of forwarded to the error
	     * handler. This is useful because it's extremely common to run
	     * generators at the top-level to work with libraries.
	     */
	    Q.spawn = spawn;
	    function spawn(makeGenerator) {
	        Q.done(Q.async(makeGenerator)());
	    }
	
	    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	    /**
	     * Throws a ReturnValue exception to stop an asynchronous generator.
	     *
	     * This interface is a stop-gap measure to support generator return
	     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	     * generators like Chromium 29, just use "return" in your generator
	     * functions.
	     *
	     * @param value the return value for the surrounding generator
	     * @throws ReturnValue exception with the value.
	     * @example
	     * // ES6 style
	     * Q.async(function* () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      return foo + bar;
	     * })
	     * // Older SpiderMonkey style
	     * Q.async(function () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      Q.return(foo + bar);
	     * })
	     */
	    Q["return"] = _return;
	    function _return(value) {
	        throw new QReturnValue(value);
	    }
	
	    /**
	     * The promised function decorator ensures that any promise arguments
	     * are settled and passed as values (`this` is also settled and passed
	     * as a value).  It will also ensure that the result of a function is
	     * always a promise.
	     *
	     * @example
	     * var add = Q.promised(function (a, b) {
	     *     return a + b;
	     * });
	     * add(Q(a), Q(B));
	     *
	     * @param {function} callback The function to decorate
	     * @returns {function} a function that has been decorated.
	     */
	    Q.promised = promised;
	    function promised(callback) {
	        return function () {
	            return spread([this, all(arguments)], function (self, args) {
	                return callback.apply(self, args);
	            });
	        };
	    }
	
	    /**
	     * sends a message to a value in a future turn
	     * @param object* the recipient
	     * @param op the name of the message operation, e.g., "when",
	     * @param args further arguments to be forwarded to the operation
	     * @returns result {Promise} a promise for the result of the operation
	     */
	    Q.dispatch = dispatch;
	    function dispatch(object, op, args) {
	        return Q(object).dispatch(op, args);
	    }
	
	    Promise.prototype.dispatch = function (op, args) {
	        var self = this;
	        var deferred = defer();
	        Q.nextTick(function () {
	            self.promiseDispatch(deferred.resolve, op, args);
	        });
	        return deferred.promise;
	    };
	
	    /**
	     * Gets the value of a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to get
	     * @return promise for the property value
	     */
	    Q.get = function (object, key) {
	        return Q(object).dispatch("get", [key]);
	    };
	
	    Promise.prototype.get = function (key) {
	        return this.dispatch("get", [key]);
	    };
	
	    /**
	     * Sets the value of a property in a future turn.
	     * @param object    promise or immediate reference for object object
	     * @param name      name of property to set
	     * @param value     new value of property
	     * @return promise for the return value
	     */
	    Q.set = function (object, key, value) {
	        return Q(object).dispatch("set", [key, value]);
	    };
	
	    Promise.prototype.set = function (key, value) {
	        return this.dispatch("set", [key, value]);
	    };
	
	    /**
	     * Deletes a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to delete
	     * @return promise for the return value
	     */
	    Q.del = // XXX legacy
	    Q["delete"] = function (object, key) {
	        return Q(object).dispatch("delete", [key]);
	    };
	
	    Promise.prototype.del = // XXX legacy
	    Promise.prototype["delete"] = function (key) {
	        return this.dispatch("delete", [key]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param value     a value to post, typically an array of
	     *                  invocation arguments for promises that
	     *                  are ultimately backed with `resolve` values,
	     *                  as opposed to those backed with URLs
	     *                  wherein the posted value can be any
	     *                  JSON serializable object.
	     * @return promise for the return value
	     */
	    // bound locally because it is used by other methods
	    Q.mapply = // XXX As proposed by "Redsandro"
	    Q.post = function (object, name, args) {
	        return Q(object).dispatch("post", [name, args]);
	    };
	
	    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.post = function (name, args) {
	        return this.dispatch("post", [name, args]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param ...args   array of invocation arguments
	     * @return promise for the return value
	     */
	    Q.send = // XXX Mark Miller's proposed parlance
	    Q.mcall = // XXX As proposed by "Redsandro"
	    Q.invoke = function (object, name /*...args*/) {
	        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	    };
	
	    Promise.prototype.send = // XXX Mark Miller's proposed parlance
	    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	    Promise.prototype.invoke = function (name /*...args*/) {
	        return this.dispatch("post", [name, array_slice(arguments, 1)]);
	    };
	
	    /**
	     * Applies the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param args      array of application arguments
	     */
	    Q.fapply = function (object, args) {
	        return Q(object).dispatch("apply", [void 0, args]);
	    };
	
	    Promise.prototype.fapply = function (args) {
	        return this.dispatch("apply", [void 0, args]);
	    };
	
	    /**
	     * Calls the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q["try"] = Q.fcall = function (object /* ...args*/) {
	        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	    };
	
	    Promise.prototype.fcall = function () /*...args*/{
	        return this.dispatch("apply", [void 0, array_slice(arguments)]);
	    };
	
	    /**
	     * Binds the promised function, transforming return values into a fulfilled
	     * promise and thrown errors into a rejected one.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q.fbind = function (object /*...args*/) {
	        var promise = Q(object);
	        var args = array_slice(arguments, 1);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	    Promise.prototype.fbind = function () /*...args*/{
	        var promise = this;
	        var args = array_slice(arguments);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	
	    /**
	     * Requests the names of the owned properties of a promised
	     * object in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @return promise for the keys of the eventually settled object
	     */
	    Q.keys = function (object) {
	        return Q(object).dispatch("keys", []);
	    };
	
	    Promise.prototype.keys = function () {
	        return this.dispatch("keys", []);
	    };
	
	    /**
	     * Turns an array of promises into a promise for an array.  If any of
	     * the promises gets rejected, the whole array is rejected immediately.
	     * @param {Array*} an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns a promise for an array of the corresponding values
	     */
	    // By Mark Miller
	    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	    Q.all = all;
	    function all(promises) {
	        return when(promises, function (promises) {
	            var pendingCount = 0;
	            var deferred = defer();
	            array_reduce(promises, function (undefined, promise, index) {
	                var snapshot;
	                if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
	                    promises[index] = snapshot.value;
	                } else {
	                    ++pendingCount;
	                    when(promise, function (value) {
	                        promises[index] = value;
	                        if (--pendingCount === 0) {
	                            deferred.resolve(promises);
	                        }
	                    }, deferred.reject, function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    });
	                }
	            }, void 0);
	            if (pendingCount === 0) {
	                deferred.resolve(promises);
	            }
	            return deferred.promise;
	        });
	    }
	
	    Promise.prototype.all = function () {
	        return all(this);
	    };
	
	    /**
	     * Returns the first resolved promise of an array. Prior rejected promises are
	     * ignored.  Rejects only if all promises are rejected.
	     * @param {Array*} an array containing values or promises for values
	     * @returns a promise fulfilled with the value of the first resolved promise,
	     * or a rejected promise if all promises are rejected.
	     */
	    Q.any = any;
	
	    function any(promises) {
	        if (promises.length === 0) {
	            return Q.resolve();
	        }
	
	        var deferred = Q.defer();
	        var pendingCount = 0;
	        array_reduce(promises, function (prev, current, index) {
	            var promise = promises[index];
	
	            pendingCount++;
	
	            when(promise, onFulfilled, onRejected, onProgress);
	            function onFulfilled(result) {
	                deferred.resolve(result);
	            }
	            function onRejected(err) {
	                pendingCount--;
	                if (pendingCount === 0) {
	                    err.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + err.message;
	                    deferred.reject(err);
	                }
	            }
	            function onProgress(progress) {
	                deferred.notify({
	                    index: index,
	                    value: progress
	                });
	            }
	        }, undefined);
	
	        return deferred.promise;
	    }
	
	    Promise.prototype.any = function () {
	        return any(this);
	    };
	
	    /**
	     * Waits for all promises to be settled, either fulfilled or
	     * rejected.  This is distinct from `all` since that would stop
	     * waiting at the first rejection.  The promise returned by
	     * `allResolved` will never be rejected.
	     * @param promises a promise for an array (or an array) of promises
	     * (or values)
	     * @return a promise for an array of promises
	     */
	    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	    function allResolved(promises) {
	        return when(promises, function (promises) {
	            promises = array_map(promises, Q);
	            return when(all(array_map(promises, function (promise) {
	                return when(promise, noop, noop);
	            })), function () {
	                return promises;
	            });
	        });
	    }
	
	    Promise.prototype.allResolved = function () {
	        return allResolved(this);
	    };
	
	    /**
	     * @see Promise#allSettled
	     */
	    Q.allSettled = allSettled;
	    function allSettled(promises) {
	        return Q(promises).allSettled();
	    }
	
	    /**
	     * Turns an array of promises into a promise for an array of their states (as
	     * returned by `inspect`) when they have all settled.
	     * @param {Array[Any*]} values an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns {Array[State]} an array of states for the respective values.
	     */
	    Promise.prototype.allSettled = function () {
	        return this.then(function (promises) {
	            return all(array_map(promises, function (promise) {
	                promise = Q(promise);
	                function regardless() {
	                    return promise.inspect();
	                }
	                return promise.then(regardless, regardless);
	            }));
	        });
	    };
	
	    /**
	     * Captures the failure of a promise, giving an oportunity to recover
	     * with a callback.  If the given promise is fulfilled, the returned
	     * promise is fulfilled.
	     * @param {Any*} promise for something
	     * @param {Function} callback to fulfill the returned promise if the
	     * given promise is rejected
	     * @returns a promise for the return value of the callback
	     */
	    Q.fail = // XXX legacy
	    Q["catch"] = function (object, rejected) {
	        return Q(object).then(void 0, rejected);
	    };
	
	    Promise.prototype.fail = // XXX legacy
	    Promise.prototype["catch"] = function (rejected) {
	        return this.then(void 0, rejected);
	    };
	
	    /**
	     * Attaches a listener that can respond to progress notifications from a
	     * promise's originating deferred. This listener receives the exact arguments
	     * passed to ``deferred.notify``.
	     * @param {Any*} promise for something
	     * @param {Function} callback to receive any progress notifications
	     * @returns the given promise, unchanged
	     */
	    Q.progress = progress;
	    function progress(object, progressed) {
	        return Q(object).then(void 0, void 0, progressed);
	    }
	
	    Promise.prototype.progress = function (progressed) {
	        return this.then(void 0, void 0, progressed);
	    };
	
	    /**
	     * Provides an opportunity to observe the settling of a promise,
	     * regardless of whether the promise is fulfilled or rejected.  Forwards
	     * the resolution to the returned promise when the callback is done.
	     * The callback can return a promise to defer completion.
	     * @param {Any*} promise
	     * @param {Function} callback to observe the resolution of the given
	     * promise, takes no arguments.
	     * @returns a promise for the resolution of the given promise when
	     * ``fin`` is done.
	     */
	    Q.fin = // XXX legacy
	    Q["finally"] = function (object, callback) {
	        return Q(object)["finally"](callback);
	    };
	
	    Promise.prototype.fin = // XXX legacy
	    Promise.prototype["finally"] = function (callback) {
	        if (!callback || typeof callback.apply !== "function") {
	            throw new Error("Q can't apply finally callback");
	        }
	        callback = Q(callback);
	        return this.then(function (value) {
	            return callback.fcall().then(function () {
	                return value;
	            });
	        }, function (reason) {
	            // TODO attempt to recycle the rejection with "this".
	            return callback.fcall().then(function () {
	                throw reason;
	            });
	        });
	    };
	
	    /**
	     * Terminates a chain of promises, forcing rejections to be
	     * thrown as exceptions.
	     * @param {Any*} promise at the end of a chain of promises
	     * @returns nothing
	     */
	    Q.done = function (object, fulfilled, rejected, progress) {
	        return Q(object).done(fulfilled, rejected, progress);
	    };
	
	    Promise.prototype.done = function (fulfilled, rejected, progress) {
	        var onUnhandledError = function onUnhandledError(error) {
	            // forward to a future turn so that ``when``
	            // does not catch it and turn it into a rejection.
	            Q.nextTick(function () {
	                makeStackTraceLong(error, promise);
	                if (Q.onerror) {
	                    Q.onerror(error);
	                } else {
	                    throw error;
	                }
	            });
	        };
	
	        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.domain) {
	            onUnhandledError = process.domain.bind(onUnhandledError);
	        }
	
	        promise.then(void 0, onUnhandledError);
	    };
	
	    /**
	     * Causes a promise to be rejected if it does not get fulfilled before
	     * some milliseconds time out.
	     * @param {Any*} promise
	     * @param {Number} milliseconds timeout
	     * @param {Any*} custom error message or Error object (optional)
	     * @returns a promise for the resolution of the given promise if it is
	     * fulfilled before the timeout, otherwise rejected.
	     */
	    Q.timeout = function (object, ms, error) {
	        return Q(object).timeout(ms, error);
	    };
	
	    Promise.prototype.timeout = function (ms, error) {
	        var deferred = defer();
	        var timeoutId = setTimeout(function () {
	            if (!error || "string" === typeof error) {
	                error = new Error(error || "Timed out after " + ms + " ms");
	                error.code = "ETIMEDOUT";
	            }
	            deferred.reject(error);
	        }, ms);
	
	        this.then(function (value) {
	            clearTimeout(timeoutId);
	            deferred.resolve(value);
	        }, function (exception) {
	            clearTimeout(timeoutId);
	            deferred.reject(exception);
	        }, deferred.notify);
	
	        return deferred.promise;
	    };
	
	    /**
	     * Returns a promise for the given value (or promised value), some
	     * milliseconds after it resolved. Passes rejections immediately.
	     * @param {Any*} promise
	     * @param {Number} milliseconds
	     * @returns a promise for the resolution of the given promise after milliseconds
	     * time has elapsed since the resolution of the given promise.
	     * If the given promise rejects, that is passed immediately.
	     */
	    Q.delay = function (object, timeout) {
	        if (timeout === void 0) {
	            timeout = object;
	            object = void 0;
	        }
	        return Q(object).delay(timeout);
	    };
	
	    Promise.prototype.delay = function (timeout) {
	        return this.then(function (value) {
	            var deferred = defer();
	            setTimeout(function () {
	                deferred.resolve(value);
	            }, timeout);
	            return deferred.promise;
	        });
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided as an array, and returns a promise.
	     *
	     *      Q.nfapply(FS.readFile, [__filename])
	     *      .then(function (content) {
	     *      })
	     *
	     */
	    Q.nfapply = function (callback, args) {
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfapply = function (args) {
	        var deferred = defer();
	        var nodeArgs = array_slice(args);
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided individually, and returns a promise.
	     * @example
	     * Q.nfcall(FS.readFile, __filename)
	     * .then(function (content) {
	     * })
	     *
	     */
	    Q.nfcall = function (callback /*...args*/) {
	        var args = array_slice(arguments, 1);
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfcall = function () /*...args*/{
	        var nodeArgs = array_slice(arguments);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Wraps a NodeJS continuation passing function and returns an equivalent
	     * version that returns a promise.
	     * @example
	     * Q.nfbind(FS.readFile, __filename)("utf-8")
	     * .then(console.log)
	     * .done()
	     */
	    Q.nfbind = Q.denodeify = function (callback /*...args*/) {
	        if (callback === undefined) {
	            throw new Error("Q can't wrap an undefined function");
	        }
	        var baseArgs = array_slice(arguments, 1);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            Q(callback).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nfbind = Promise.prototype.denodeify = function () /*...args*/{
	        var args = array_slice(arguments);
	        args.unshift(this);
	        return Q.denodeify.apply(void 0, args);
	    };
	
	    Q.nbind = function (callback, thisp /*...args*/) {
	        var baseArgs = array_slice(arguments, 2);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            function bound() {
	                return callback.apply(thisp, arguments);
	            }
	            Q(bound).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nbind = function () /*thisp, ...args*/{
	        var args = array_slice(arguments, 0);
	        args.unshift(this);
	        return Q.nbind.apply(void 0, args);
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback with a given array of arguments, plus a provided callback.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param {Array} args arguments to pass to the method; the callback
	     * will be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nmapply = // XXX As proposed by "Redsandro"
	    Q.npost = function (object, name, args) {
	        return Q(object).npost(name, args);
	    };
	
	    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.npost = function (name, args) {
	        var nodeArgs = array_slice(args || []);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback, forwarding the given variadic arguments, plus a provided
	     * callback argument.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param ...args arguments to pass to the method; the callback will
	     * be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nsend = // XXX Based on Mark Miller's proposed "send"
	    Q.nmcall = // XXX Based on "Redsandro's" proposal
	    Q.ninvoke = function (object, name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 2);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	    Promise.prototype.ninvoke = function (name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 1);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * If a function would like to support both Node continuation-passing-style and
	     * promise-returning-style, it can end its internal promise chain with
	     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	     * elects to use a nodeback, the result will be sent there.  If they do not
	     * pass a nodeback, they will receive the result promise.
	     * @param object a result (or a promise for a result)
	     * @param {Function} nodeback a Node.js-style callback
	     * @returns either the promise or nothing
	     */
	    Q.nodeify = nodeify;
	    function nodeify(object, nodeback) {
	        return Q(object).nodeify(nodeback);
	    }
	
	    Promise.prototype.nodeify = function (nodeback) {
	        if (nodeback) {
	            this.then(function (value) {
	                Q.nextTick(function () {
	                    nodeback(null, value);
	                });
	            }, function (error) {
	                Q.nextTick(function () {
	                    nodeback(error);
	                });
	            });
	        } else {
	            return this;
	        }
	    };
	
	    Q.noConflict = function () {
	        throw new Error("Q.noConflict only works when Q is used as a global");
	    };
	
	    // All code before this point will be filtered from stack traces.
	    var qEndingLine = captureLine();
	
	    return Q;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(9).setImmediate, __webpack_require__(11)(module)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function () {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function () {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout = exports.clearInterval = function (timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function () {};
	Timeout.prototype.close = function () {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function (item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function (item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function (item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout) item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(10);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	
	(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	        // Callback can either be a function or a string
	        if (typeof callback !== "function") {
	            callback = new Function("" + callback);
	        }
	        // Copy function arguments
	        var args = new Array(arguments.length - 1);
	        for (var i = 0; i < args.length; i++) {
	            args[i] = arguments[i + 1];
	        }
	        // Store and register the task
	        var task = { callback: callback, args: args };
	        tasksByHandle[nextHandle] = task;
	        registerImmediate(nextHandle);
	        return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	            case 0:
	                callback();
	                break;
	            case 1:
	                callback(args[0]);
	                break;
	            case 2:
	                callback(args[0], args[1]);
	                break;
	            case 3:
	                callback(args[0], args[1], args[2]);
	                break;
	            default:
	                callback.apply(undefined, args);
	                break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            process.nextTick(function () {
	                runIfPresent(handle);
	            });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function () {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function onGlobalMessage(event) {
	            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function registerImmediate(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function registerImmediate(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function registerImmediate(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _algoliasearch = __webpack_require__(13);
	
	var _algoliasearch2 = _interopRequireDefault(_algoliasearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var escapeRegExp = function escapeRegExp(str) {
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	};
	
	var Search = {
	  install: function install(Vue, options) {
	    _loglevel2.default.trace(options);
	    var AlgoliaClient = (0, _algoliasearch2.default)(options.appID, options.apiKey, {
	      protocol: 'https:'
	    });
	    var AlgoliaIndex = AlgoliaClient.initIndex(options.index);
	
	    var advancedSearch = function advancedSearch(params) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.clearCache();
	      AlgoliaIndex.search(params, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          fetchListItemCards(content.hits).then(function () {
	            content.hits.forEach(function (hit) {
	              if (!hit.description) hit.description = hit.sentence || hit.text;
	              delete hit.sentence;
	              delete hit.text;
	            });
	            d.resolve(content.hits);
	          });
	        }
	      });
	      return d.promise;
	    };
	
	    var searchCards = function searchCards(userID, searchText, hitsPerPage) {
	      var d = _q2.default.defer();
	      var params = {
	        query: searchText,
	        filters: userID.length ? 'userID: ' + userID : '',
	        hitsPerPage: hitsPerPage || null
	      };
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (hits) {
	        _loglevel2.default.trace(hits);
	        d.resolve(hits);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var fetchListItemCards = function fetchListItemCards(cards) {
	      var d = _q2.default.defer();
	      var self = this;
	      var promises = [];
	      cards.forEach(function (card) {
	        card.listCards = [];
	        if (card.listItems) {
	          card.listItems.forEach(function (key) {
	            console.log(key);
	            var p = _q2.default.defer();
	            getCard(key); // Do we need to notify the card or provide callbacks etc here?
	            // promises.push(p.promise)
	          });
	        }
	      });
	      _loglevel2.default.trace(promises);
	      _q2.default.allSettled(promises).then(function (results) {
	        console.log(results);
	        console.log(cards);
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getCard = function getCard(objectID) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.getObject(objectID, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          d.resolve(content);
	        }
	      });
	      return d.promise;
	    };
	
	    var compoundSearch = function compoundSearch(userID, searchText) {
	      var d = _q2.default.defer();
	      var maxLength = 400;
	      var searchTextArray = [];
	      var hitsPerPage = Math.min(Math.max(Math.ceil(10 / (searchText.length / maxLength)), 3), 12);
	      for (var i = 0; i < searchText.length; i += maxLength) {
	        searchTextArray.push(searchText.substring(i, i + maxLength));
	      }
	      var promises = searchTextArray.map(function (t, j) {
	        return searchCards(userID, t, hitsPerPage);
	      });
	      _q2.default.allSettled(promises).then(function (results) {
	        var results = [].concat.apply([], results.map(function (r) {
	          return r.value;
	        }));
	        results = removeDuplicates(results, 'objectID');
	        _loglevel2.default.trace(results);
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	      });
	      return d.promise;
	    };
	
	    var removeDuplicates = function removeDuplicates(originalArray, objKey) {
	      var trimmedArray = [],
	          values = [],
	          value;
	      for (var i = 0; i < originalArray.length; i++) {
	        value = originalArray[i][objKey];
	        if (values.indexOf(value) === -1) {
	          trimmedArray.push(originalArray[i]);
	          values.push(value);
	        }
	      }
	      return trimmedArray;
	    };
	
	    var checkPageHit = function checkPageHit(pageData, results) {
	      //Not yet accounting for capitals
	      var boringWords = ['favourite', 'world', 'name', 'this', 'plan', 'need', 'best', 'like', 'the', 'are', 'is', 'my', 'my'];
	      var hits = [];
	      results.forEach(function (result, i) {
	        _loglevel2.default.trace('---');
	        _loglevel2.default.trace(i);
	        var count = [];
	        result.context.forEach(function (c) {
	          if (pageData.pageText.indexOf(c.value) > -1 && hits.indexOf(result.objectID) == -1 && c.value && c.value.length > 3 && boringWords.indexOf(c.value) == -1 && count.indexOf(c.value) == -1) {
	            _loglevel2.default.trace(c.value);
	            count.push(c.value);
	            (c.value.match(/ /g) || []).forEach(function () {
	              count.push(c.value);
	            });
	          }
	        });
	        if (count.length > 2) {
	          _loglevel2.default.trace(result.sentence);
	          hits.push(result);
	        }
	        _loglevel2.default.trace('---');
	      });
	
	      // return hits;
	      //Force no hits
	      return [];
	    };
	
	    var checkPageReminder = function checkPageReminder(userID, pageData) {
	      var d = _q2.default.defer();
	      _loglevel2.default.trace(pageData);
	      var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	      var params = {
	        query: '',
	        filters: 'userID: ' + userID + ' AND (triggerUrl: ' + urlRoot + ' OR triggerUrl: ' + urlRoot + '.com OR triggerUrl: ' + urlRoot + '.co.uk OR triggerUrl: ' + urlRoot + '.org OR triggerURL: ' + urlRoot + ' OR triggerURL: ' + urlRoot + '.com OR triggerURL: ' + urlRoot + '.co.uk OR triggerURL: ' + urlRoot + '.org)'
	      };
	      _loglevel2.default.trace('params');
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (reminders) {
	        _loglevel2.default.trace('reminders');
	        _loglevel2.default.trace(reminders);
	        d.resolve(reminders);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getPageResults = function getPageResults(userID, pageData, allUserCards) {
	      var d = _q2.default.defer();
	      // Gets all results
	      var pageResults = {
	        hits: [],
	        reminders: [],
	        pings: [],
	        memories: []
	      };
	      _loglevel2.default.trace(userID, pageData);
	      var gmailBoringPhrases = ['Skip to content', 'Using', 'with screen readers', 'Search', 'Mail', 'COMPOSE', 'Labels', 'Inbox', 'Starred', 'Sent Mail', 'Drafts', 'More', '---------- Forwarded message ----------', 'From: ', 'Date: ', 'Subject: ', 'To: ', 'Click here to Reply or Forward', 'GB', 'GB used', 'Manage', 'Program Policies', 'Powered by Google', 'Last account activity:', 'hour ago', 'hours ago', 'Details'];
	      gmailBoringPhrases.forEach(function (phrase) {
	        pageData.pageText = pageData.pageText.replace(phrase, '');
	      });
	      var boringWords = ["i", "a", "of", "me", "my", "is", "im", "so", "all", "get", "how", "new", "out", "the", "use", "best", "name", "next", "take", "what", "image", "something"];
	
	      try {
	        var allWords = [];
	        allUserCards.forEach(function (card) {
	          var score = 0;
	          card.context.forEach(function (entity) {
	            var val = String(entity.value);
	            if (boringWords.indexOf(val.toLowerCase()) == -1 && val.length > 1) {
	              var reg = new RegExp(escapeRegExp(val), "gi");
	              var points = (pageData.pageText.match(reg) || []).length * val.length;
	              score += points;
	              if (points) {
	                if (allWords.indexOf(val) == -1) allWords.push(val);
	              }
	            }
	          });
	          if (score > 100) {
	            pageResults.hits.push(card);
	          } else if (score > 0) {
	            pageResults.memories.push(card);
	          }
	        });
	        _loglevel2.default.debug(allWords);
	
	        pageResults.reminders = allUserCards.filter(function (card) {
	          var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	          _loglevel2.default.info(card.triggerURL);
	          return card.triggerURL && (card.triggerURL.indexOf(urlRoot) > -1 || card.triggerURL.indexOf(urlRoot) > -1);
	        });
	        pageResults.pings = pageResults.reminders; //.concat(pageResults.hits)
	        pageResults.pings.forEach(function (ping) {
	          ping.highlight = true;
	        });
	        // pageResults.memories = pageResults.pings.concat(pageResults.memories)
	        pageResults.memories = removeDuplicates(pageResults.memories, 'objectID');
	        _loglevel2.default.debug(pageResults);
	        d.resolve(pageResults);
	      } catch (e) {
	        _loglevel2.default.error(e);
	      }
	
	      // compoundSearch(userID, pageData.pageText)
	      // .then(function(results) {
	      //   log.trace(1);
	      //   log.trace(results);
	      //   pageResults.memories = results;
	      //   // Checks whether a ping is required
	      //   pageResults.hits = checkPageHit(pageData, results);
	      //   log.trace(2);
	      //   log.trace(pageResults.hits);
	      //   return checkPageReminder(userID, pageData)
	      // }).then(function(reminders) {
	      //   pageResults.reminders = reminders;
	      //   log.trace(3);
	      //   log.trace(pageResults.reminders);
	      //   // Returns results plus ping
	      //   pageResults.pings = pageResults.reminders.concat(pageResults.hits)
	      //   pageResults.pings.forEach(function(ping) {
	      //     log.trace(ping.objectID);
	      //     ping.highlight = true;
	      //   })
	      //   pageResults.memories = pageResults.pings.concat(pageResults.memories)
	      //   pageResults.memories = removeDuplicates(pageResults.memories, 'objectID')
	      //   log.trace(pageResults);
	      //   d.resolve(pageResults)
	      // }).catch(function(e) {
	      //   log.trace(e);
	      //   d.reject(e)
	      // })
	      return d.promise;
	    };
	
	    this.advancedSearch = advancedSearch;
	    this.searchCards = searchCards;
	    this.compoundSearch = compoundSearch;
	    this.getPageResults = getPageResults;
	  }
	};
	
	exports.default = Search;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var AlgoliaSearch = __webpack_require__(14);
	var createAlgoliasearch = __webpack_require__(38);
	
	module.exports = createAlgoliasearch(AlgoliaSearch);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = AlgoliaSearch;
	
	var Index = __webpack_require__(15);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var AlgoliaSearchCore = __webpack_require__(33);
	var inherits = __webpack_require__(16);
	var errors = __webpack_require__(19);
	
	function AlgoliaSearch() {
	  AlgoliaSearchCore.apply(this, arguments);
	}
	
	inherits(AlgoliaSearch, AlgoliaSearchCore);
	
	/*
	 * Delete an index
	 *
	 * @param indexName the name of index to delete
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.deleteIndex = function (indexName, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexName),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Move an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy of
	 * srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.moveIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'move', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Copy an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy
	 * of srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.copyIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'copy', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Return last log entries.
	 * @param offset Specify the first entry to retrieve (0-based, 0 is the most recent log entry).
	 * @param length Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param type Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.getLogs = function (offset, length, callback) {
	  var clone = __webpack_require__(24);
	  var params = {};
	  if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) === 'object') {
	    // getLogs(params)
	    params = clone(offset);
	    callback = length;
	  } else if (arguments.length === 0 || typeof offset === 'function') {
	    // getLogs([cb])
	    callback = offset;
	  } else if (arguments.length === 1 || typeof length === 'function') {
	    // getLogs(1, [cb)]
	    callback = length;
	    params.offset = offset;
	  } else {
	    // getLogs(1, 2, [cb])
	    params.offset = offset;
	    params.length = length;
	  }
	
	  if (params.offset === undefined) params.offset = 0;
	  if (params.length === undefined) params.length = 10;
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/logs?' + this._getSearchParams(params, ''),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * List all existing indexes (paginated)
	 *
	 * @param page The page to retrieve, starting at 0.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with index list
	 */
	AlgoliaSearch.prototype.listIndexes = function (page, callback) {
	  var params = '';
	
	  if (page === undefined || typeof page === 'function') {
	    callback = page;
	  } else {
	    params = '?page=' + page;
	  }
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes' + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearch.prototype.initIndex = function (indexName) {
	  return new Index(this, indexName);
	};
	
	/*
	 * @deprecated use client.listApiKeys
	 */
	AlgoliaSearch.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('client.listUserKeys()', 'client.listApiKeys()'));
	
	/*
	 * List all existing api keys with their associated ACLs
	 *
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with api keys list
	 */
	AlgoliaSearch.prototype.listApiKeys = function (callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.getApiKey
	 */
	AlgoliaSearch.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('client.getUserKeyACL()', 'client.getApiKey()'));
	
	/*
	 * Get an API key
	 *
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the right API key
	 */
	AlgoliaSearch.prototype.getApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.deleteApiKey
	 */
	AlgoliaSearch.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('client.deleteUserKey()', 'client.deleteApiKey()'));
	
	/*
	 * Delete an existing API key
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the date of deletion
	 */
	AlgoliaSearch.prototype.deleteApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see client.addApiKey
	 */
	AlgoliaSearch.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKey()', 'client.addApiKey()'));
	
	/*
	 * Add a new global API key
	 *
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the added API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.addUserKey(['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#AddKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.indexes = params.indexes;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * @deprecated Please use client.addApiKey()
	 */
	AlgoliaSearch.prototype.addUserKeyWithValidity = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKeyWithValidity()', 'client.addApiKey()'));
	
	/**
	 * @deprecated Please use client.updateApiKey()
	 */
	AlgoliaSearch.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('client.updateUserKey()', 'client.updateApiKey()'));
	
	/**
	 * Update an existing API key
	 * @param {string} key - The key to update
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the modified API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.updateApiKey('APIKEY', ['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.indexes = params.indexes;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'PUT',
	    url: '/1/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Initialize a new batch of search queries
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.startQueriesBatch = deprecate(function startQueriesBatchDeprecated() {
	  this._batch = [];
	}, deprecatedMessage('client.startQueriesBatch()', 'client.search()'));
	
	/**
	 * Add a search query in the batch
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.addQueryInBatch = deprecate(function addQueryInBatchDeprecated(indexName, query, args) {
	  this._batch.push({
	    indexName: indexName,
	    query: query,
	    params: args
	  });
	}, deprecatedMessage('client.addQueryInBatch()', 'client.search()'));
	
	/**
	 * Launch the batch of queries using XMLHttpRequest.
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.sendQueriesBatch = deprecate(function sendQueriesBatchDeprecated(callback) {
	  return this.search(this._batch, callback);
	}, deprecatedMessage('client.sendQueriesBatch()', 'client.search()'));
	
	/**
	 * Perform write operations accross multiple indexes.
	 *
	 * To reduce the amount of time spent on network round trips,
	 * you can create, update, or delete several objects in one call,
	 * using the batch endpoint (all operations are done in the given order).
	 *
	 * Available actions:
	 *   - addObject
	 *   - updateObject
	 *   - partialUpdateObject
	 *   - partialUpdateObjectNoCreate
	 *   - deleteObject
	 *
	 * https://www.algolia.com/doc/rest_api#Indexes
	 * @param  {Object[]} operations An array of operations to perform
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.batch([{
	 *   action: 'addObject',
	 *   indexName: 'clients',
	 *   body: {
	 *     name: 'Bill'
	 *   }
	 * }, {
	 *   action: 'udpateObject',
	 *   indexName: 'fruits',
	 *   body: {
	 *     objectID: '29138',
	 *     name: 'banana'
	 *   }
	 * }], cb)
	 */
	AlgoliaSearch.prototype.batch = function (operations, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.batch(operations[, callback])';
	
	  if (!isArray(operations)) {
	    throw new Error(usage);
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/batch',
	    body: {
	      requests: operations
	    },
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	// environment specific methods
	AlgoliaSearch.prototype.destroy = notImplemented;
	AlgoliaSearch.prototype.enableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.disableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.useSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.disableSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.generateSecuredApiKey = notImplemented;
	
	function notImplemented() {
	  var message = 'Not implemented in this environment.\n' + 'If you feel this is a mistake, write to support@algolia.com';
	
	  throw new errors.AlgoliaSearchError(message);
	}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var inherits = __webpack_require__(16);
	var IndexCore = __webpack_require__(17);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var exitPromise = __webpack_require__(30);
	var errors = __webpack_require__(19);
	
	var deprecateForwardToSlaves = deprecate(function () {}, deprecatedMessage('forwardToSlaves', 'forwardToReplicas'));
	
	module.exports = Index;
	
	function Index() {
	  IndexCore.apply(this, arguments);
	}
	
	inherits(Index, IndexCore);
	
	/*
	* Add an object in this index
	*
	* @param content contains the javascript object to add inside the index
	* @param objectID (optional) an objectID you want to attribute to this object
	* (if the attribute already exist the old object will be overwrite)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.addObject = function (content, objectID, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof objectID === 'function') {
	    callback = objectID;
	    objectID = undefined;
	  }
	
	  return this.as._jsonRequest({
	    method: objectID !== undefined ? 'PUT' : // update or create
	    'POST', // create (API generates an objectID)
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + ( // create
	    objectID !== undefined ? '/' + encodeURIComponent(objectID) : ''), // update or create
	    body: content,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Add several objects
	*
	* @param objects contains an array of objects to add
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.addObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'addObject',
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Update partially an object (only update attributes passed in argument)
	*
	* @param partialObject contains the javascript attributes to override, the
	*  object must contains an objectID attribute
	* @param createIfNotExists (optional) if false, avoid an automatic creation of the object
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.partialUpdateObject = function (partialObject, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = undefined;
	  }
	
	  var indexObj = this;
	  var url = '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(partialObject.objectID) + '/partial';
	  if (createIfNotExists === false) {
	    url += '?createIfNotExists=false';
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: url,
	    body: partialObject,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Partially Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.partialUpdateObjects = function (objects, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = true;
	  }
	
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.partialUpdateObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: createIfNotExists === true ? 'partialUpdateObject' : 'partialUpdateObjectNoCreate',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of object
	*
	* @param object contains the javascript object to save, the object must contains an objectID attribute
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObject = function (object, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(object.objectID),
	    body: object,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.saveObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'updateObject',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete an object from the index
	*
	* @param objectID the unique identifier of object to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObject = function (objectID, callback) {
	  if (typeof objectID === 'function' || typeof objectID !== 'string' && typeof objectID !== 'number') {
	    var err = new errors.AlgoliaSearchError('Cannot delete an object without an objectID');
	    callback = objectID;
	    if (typeof callback === 'function') {
	      return callback(err);
	    }
	
	    return this.as._promise.reject(err);
	  }
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete several objects from an index
	*
	* @param objectIDs contains an array of objectID to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObjects = function (objectIDs, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.deleteObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      return {
	        action: 'deleteObject',
	        objectID: objectID,
	        body: {
	          objectID: objectID
	        }
	      };
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete all objects matching a query
	*
	* @param query the query string
	* @param params the optional query parameters
	* @param callback (optional) the result callback called with one argument
	*  error: null or Error('message')
	*/
	Index.prototype.deleteByQuery = function (query, params, callback) {
	  var clone = __webpack_require__(24);
	  var map = __webpack_require__(29);
	
	  var indexObj = this;
	  var client = indexObj.as;
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else {
	    params = clone(params);
	  }
	
	  params.attributesToRetrieve = 'objectID';
	  params.hitsPerPage = 1000;
	  params.distinct = false;
	
	  // when deleting, we should never use cache to get the
	  // search results
	  this.clearCache();
	
	  // there's a problem in how we use the promise chain,
	  // see how waitTask is done
	  var promise = this.search(query, params).then(stopOrDelete);
	
	  function stopOrDelete(searchContent) {
	    // stop here
	    if (searchContent.nbHits === 0) {
	      // return indexObj.as._request.resolve();
	      return searchContent;
	    }
	
	    // continue and do a recursive call
	    var objectIDs = map(searchContent.hits, function getObjectID(object) {
	      return object.objectID;
	    });
	
	    return indexObj.deleteObjects(objectIDs).then(waitTask).then(doDeleteByQuery);
	  }
	
	  function waitTask(deleteObjectsContent) {
	    return indexObj.waitTask(deleteObjectsContent.taskID);
	  }
	
	  function doDeleteByQuery() {
	    return indexObj.deleteByQuery(query, params);
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(success, failure);
	
	  function success() {
	    exitPromise(function exit() {
	      callback(null);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failure(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* Browse all content from an index using events. Basically this will do
	* .browse() -> .browseFrom -> .browseFrom -> .. until all the results are returned
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @return {EventEmitter}
	* @example
	* var browser = index.browseAll('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* });
	*
	* browser.on('result', function resultCallback(content) {
	*   console.log(content.hits);
	* });
	*
	* // if any error occurs, you get it
	* browser.on('error', function(err) {
	*   throw err;
	* });
	*
	* // when you have browsed the whole index, you get this event
	* browser.on('end', function() {
	*   console.log('finished');
	* });
	*
	* // at any point if you want to stop the browsing process, you can stop it manually
	* // otherwise it will go on and on
	* browser.stop();
	*
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	Index.prototype.browseAll = function (query, queryParameters) {
	  if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
	    queryParameters = query;
	    query = undefined;
	  }
	
	  var merge = __webpack_require__(23);
	
	  var IndexBrowser = __webpack_require__(31);
	
	  var browser = new IndexBrowser();
	  var client = this.as;
	  var index = this;
	  var params = client._getSearchParams(merge({}, queryParameters || {}, {
	    query: query
	  }), '');
	
	  // start browsing
	  browseLoop();
	
	  function browseLoop(cursor) {
	    if (browser._stopped) {
	      return;
	    }
	
	    var body;
	
	    if (cursor !== undefined) {
	      body = {
	        cursor: cursor
	      };
	    } else {
	      body = {
	        params: params
	      };
	    }
	
	    client._jsonRequest({
	      method: 'POST',
	      url: '/1/indexes/' + encodeURIComponent(index.indexName) + '/browse',
	      hostType: 'read',
	      body: body,
	      callback: browseCallback
	    });
	  }
	
	  function browseCallback(err, content) {
	    if (browser._stopped) {
	      return;
	    }
	
	    if (err) {
	      browser._error(err);
	      return;
	    }
	
	    browser._result(content);
	
	    // no cursor means we are finished browsing
	    if (content.cursor === undefined) {
	      browser._end();
	      return;
	    }
	
	    browseLoop(content.cursor);
	  }
	
	  return browser;
	};
	
	/*
	* Get a Typeahead.js adapter
	* @param searchParams contains an object with query parameters (see search for details)
	*/
	Index.prototype.ttAdapter = deprecate(function (params) {
	  var self = this;
	  return function ttAdapter(query, syncCb, asyncCb) {
	    var cb;
	
	    if (typeof asyncCb === 'function') {
	      // typeahead 0.11
	      cb = asyncCb;
	    } else {
	      // pre typeahead 0.11
	      cb = syncCb;
	    }
	
	    self.search(query, params, function searchDone(err, content) {
	      if (err) {
	        cb(err);
	        return;
	      }
	
	      cb(content.hits);
	    });
	  };
	}, 'ttAdapter is not necessary anymore and will be removed in the next version,\n' + 'have a look at autocomplete.js (https://github.com/algolia/autocomplete.js)');
	
	/*
	* Wait the publication of a task on the server.
	* All server task are asynchronous and you can check with this method that the task is published.
	*
	* @param taskID the id of the task returned by server
	* @param callback the result callback with with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains the list of results
	*/
	Index.prototype.waitTask = function (taskID, callback) {
	  // wait minimum 100ms before retrying
	  var baseDelay = 100;
	  // wait maximum 5s before retrying
	  var maxDelay = 5000;
	  var loop = 0;
	
	  // waitTask() must be handled differently from other methods,
	  // it's a recursive method using a timeout
	  var indexObj = this;
	  var client = indexObj.as;
	
	  var promise = retryLoop();
	
	  function retryLoop() {
	    return client._jsonRequest({
	      method: 'GET',
	      hostType: 'read',
	      url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/task/' + taskID
	    }).then(function success(content) {
	      loop++;
	      var delay = baseDelay * loop * loop;
	      if (delay > maxDelay) {
	        delay = maxDelay;
	      }
	
	      if (content.status !== 'published') {
	        return client._promise.delay(delay).then(retryLoop);
	      }
	
	      return content;
	    });
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(successCb, failureCb);
	
	  function successCb(content) {
	    exitPromise(function exit() {
	      callback(null, content);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failureCb(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* This function deletes the index content. Settings and index specific API keys are kept untouched.
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.clearIndex = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/clear',
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Get settings of this index
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.getSettings = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?getVersion=2',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.searchSynonyms = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveSynonym = function (synonym, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(synonym.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: synonym,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getSynonym = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteSynonym = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearSynonyms = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchSynonyms = function (synonyms, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/batch' + '?forwardToReplicas=' + forwardToReplicas + '&replaceExistingSynonyms=' + (opts.replaceExistingSynonyms ? 'true' : 'false'),
	    hostType: 'write',
	    body: synonyms,
	    callback: callback
	  });
	};
	
	Index.prototype.searchRules = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveRule = function (rule, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(rule.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: rule,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getRule = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteRule = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearRules = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchRules = function (rules, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/batch' + '?forwardToReplicas=' + forwardToReplicas + '&clearExistingRules=' + (opts.clearExistingRules === true ? 'true' : 'false'),
	    hostType: 'write',
	    body: rules,
	    callback: callback
	  });
	};
	
	/*
	* Set settings for this index
	*
	* @param settigns the settings object that can contains :
	* - minWordSizefor1Typo: (integer) the minimum number of characters to accept one typo (default = 3).
	* - minWordSizefor2Typos: (integer) the minimum number of characters to accept two typos (default = 7).
	* - hitsPerPage: (integer) the number of hits per page (default = 10).
	* - attributesToRetrieve: (array of strings) default list of attributes to retrieve in objects.
	*   If set to null, all attributes are retrieved.
	* - attributesToHighlight: (array of strings) default list of attributes to highlight.
	*   If set to null, all indexed attributes are highlighted.
	* - attributesToSnippet**: (array of strings) default list of attributes to snippet alongside the number
	* of words to return (syntax is attributeName:nbWords).
	*   By default no snippet is computed. If set to null, no snippet is computed.
	* - attributesToIndex: (array of strings) the list of fields you want to index.
	*   If set to null, all textual and numerical attributes of your objects are indexed,
	*   but you should update it to get optimal results.
	*   This parameter has two important uses:
	*     - Limit the attributes to index: For example if you store a binary image in base64,
	*     you want to store it and be able to
	*       retrieve it but you don't want to search in the base64 string.
	*     - Control part of the ranking*: (see the ranking parameter for full explanation)
	*     Matches in attributes at the beginning of
	*       the list will be considered more important than matches in attributes further down the list.
	*       In one attribute, matching text at the beginning of the attribute will be
	*       considered more important than text after, you can disable
	*       this behavior if you add your attribute inside `unordered(AttributeName)`,
	*       for example attributesToIndex: ["title", "unordered(text)"].
	* - attributesForFaceting: (array of strings) The list of fields you want to use for faceting.
	*   All strings in the attribute selected for faceting are extracted and added as a facet.
	*   If set to null, no attribute is used for faceting.
	* - attributeForDistinct: (string) The attribute name used for the Distinct feature.
	* This feature is similar to the SQL "distinct" keyword: when enabled
	*   in query with the distinct=1 parameter, all hits containing a duplicate
	*   value for this attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best one is kept and others are removed.
	* - ranking: (array of strings) controls the way results are sorted.
	*   We have six available criteria:
	*    - typo: sort according to number of typos,
	*    - geo: sort according to decreassing distance when performing a geo-location based search,
	*    - proximity: sort according to the proximity of query words in hits,
	*    - attribute: sort according to the order of attributes defined by attributesToIndex,
	*    - exact:
	*        - if the user query contains one word: sort objects having an attribute
	*        that is exactly the query word before others.
	*          For example if you search for the "V" TV show, you want to find it
	*          with the "V" query and avoid to have all popular TV
	*          show starting by the v letter before it.
	*        - if the user query contains multiple words: sort according to the
	*        number of words that matched exactly (and not as a prefix).
	*    - custom: sort according to a user defined formula set in **customRanking** attribute.
	*   The standard order is ["typo", "geo", "proximity", "attribute", "exact", "custom"]
	* - customRanking: (array of strings) lets you specify part of the ranking.
	*   The syntax of this condition is an array of strings containing attributes
	*   prefixed by asc (ascending order) or desc (descending order) operator.
	*   For example `"customRanking" => ["desc(population)", "asc(name)"]`
	* - queryType: Select how the query words are interpreted, it can be one of the following value:
	*   - prefixAll: all query words are interpreted as prefixes,
	*   - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*   - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - highlightPreTag: (string) Specify the string that is inserted before
	* the highlighted parts in the query result (default to "<em>").
	* - highlightPostTag: (string) Specify the string that is inserted after
	* the highlighted parts in the query result (default to "</em>").
	* - optionalWords: (array of strings) Specify a list of words that should
	* be considered as optional when found in the query.
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer or the error message if a failure occured
	*/
	Index.prototype.setSettings = function (settings, opts, callback) {
	  if (arguments.length === 1 || typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    body: settings,
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.listApiKeys
	 */
	Index.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('index.listUserKeys()', 'index.listApiKeys()'));
	
	/*
	* List all existing API keys to this index
	*
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with API keys belonging to the index
	*/
	Index.prototype.listApiKeys = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.getApiKey
	 */
	Index.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('index.getUserKeyACL()', 'index.getApiKey()'));
	
	/*
	* Get an API key from this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the right API key
	*/
	Index.prototype.getApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.deleteApiKey
	 */
	Index.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('index.deleteUserKey()', 'index.deleteApiKey()'));
	
	/*
	* Delete an existing API key associated to this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the deletion date
	*/
	Index.prototype.deleteApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.addApiKey
	 */
	Index.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKey()', 'index.addApiKey()'));
	
	/*
	* Add a new API key to this index
	*
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the added API key
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.addUserKey(['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#AddIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	* @deprecated use index.addApiKey()
	*/
	Index.prototype.addUserKeyWithValidity = deprecate(function deprecatedAddUserKeyWithValidity(acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKeyWithValidity()', 'index.addApiKey()'));
	
	/*
	 @deprecated see index.updateApiKey
	 */
	Index.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('index.updateUserKey()', 'index.updateApiKey()'));
	
	/**
	* Update an existing API key of this index
	* @param {string} key - The key to update
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with user keys list
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.updateApiKey('APIKEY', ['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';
	
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var buildSearchMethod = __webpack_require__(18);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	
	module.exports = IndexCore;
	
	/*
	* Index class constructor.
	* You should not use this method directly but use initIndex() function
	*/
	function IndexCore(algoliasearch, indexName) {
	  this.indexName = indexName;
	  this.as = algoliasearch;
	  this.typeAheadArgs = null;
	  this.typeAheadValueOption = null;
	
	  // make sure every index instance has it's own cache
	  this.cache = {};
	}
	
	/*
	* Clear all queries in cache
	*/
	IndexCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/*
	* Search inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the full text query
	* @param {object} [args] (optional) if set, contains an object with query parameters:
	* - page: (integer) Pagination parameter used to select the page to retrieve.
	*                   Page is zero-based and defaults to 0. Thus,
	*                   to retrieve the 10th page you need to set page=9
	* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.
	* - attributesToRetrieve: a string that contains the list of object attributes
	* you want to retrieve (let you minimize the answer size).
	*   Attributes are separated with a comma (for example "name,address").
	*   You can also use an array (for example ["name","address"]).
	*   By default, all attributes are retrieved. You can also use '*' to retrieve all
	*   values when an attributesToRetrieve setting is specified for your index.
	* - attributesToHighlight: a string that contains the list of attributes you
	*   want to highlight according to the query.
	*   Attributes are separated by a comma. You can also use an array (for example ["name","address"]).
	*   If an attribute has no match for the query, the raw value is returned.
	*   By default all indexed text attributes are highlighted.
	*   You can use `*` if you want to highlight all textual attributes.
	*   Numerical attributes are not highlighted.
	*   A matchLevel is returned for each highlighted attribute and can contain:
	*      - full: if all the query terms were found in the attribute,
	*      - partial: if only some of the query terms were found,
	*      - none: if none of the query terms were found.
	* - attributesToSnippet: a string that contains the list of attributes to snippet alongside
	* the number of words to return (syntax is `attributeName:nbWords`).
	*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).
	*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).
	*    By default no snippet is computed.
	* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.
	* Defaults to 3.
	* - minWordSizefor2Typos: the minimum number of characters in a query word
	* to accept two typos in this word. Defaults to 7.
	* - getRankingInfo: if set to 1, the result hits will contain ranking
	* information in _rankingInfo attribute.
	* - aroundLatLng: search for entries around a given
	* latitude/longitude (specified as two floats separated by a comma).
	*   For example aroundLatLng=47.316669,5.016670).
	*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)
	*   and the precision for ranking with aroundPrecision
	*   (for example if you set aroundPrecision=100, two objects that are distant of
	*   less than 100m will be considered as identical for "geo" ranking parameter).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - insideBoundingBox: search entries inside a given area defined by the two extreme points
	* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).
	*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - numericFilters: a string that contains the list of numeric filters you want to
	* apply separated by a comma.
	*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.
	*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.
	*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.
	*   You can also use an array (for example numericFilters: ["price>100","price<1000"]).
	* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.
	*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).
	*   You can also use an array, for example tagFilters: ["tag1",["tag2","tag3"]]
	*   means tag1 AND (tag2 OR tag3).
	*   At indexing, tags should be added in the _tags** attribute
	*   of objects (for example {"_tags":["tag1","tag2"]}).
	* - facetFilters: filter the query by a list of facets.
	*   Facets are separated by commas and each facet is encoded as `attributeName:value`.
	*   For example: `facetFilters=category:Book,author:John%20Doe`.
	*   You can also use an array (for example `["category:Book","author:John%20Doe"]`).
	* - facets: List of object attributes that you want to use for faceting.
	*   Comma separated list: `"category,author"` or array `['category','author']`
	*   Only attributes that have been added in **attributesForFaceting** index setting
	*   can be used in this parameter.
	*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.
	* - queryType: select how the query words are interpreted, it can be one of the following value:
	*    - prefixAll: all query words are interpreted as prefixes,
	*    - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - optionalWords: a string that contains the list of words that should
	* be considered as optional when found in the query.
	*   Comma separated and array are accepted.
	* - distinct: If set to 1, enable the distinct feature (disabled by default)
	* if the attributeForDistinct index setting is set.
	*   This feature is similar to the SQL "distinct" keyword: when enabled
	*   in a query with the distinct=1 parameter,
	*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best
	*   one is kept and others are removed.
	* - restrictSearchableAttributes: List of attributes you want to use for
	* textual search (must be a subset of the attributesToIndex index setting)
	* either comma separated or as an array
	* @param {function} [callback] the result callback called with two arguments:
	*  error: null or Error('message'). If false, the content contains the error.
	*  content: the server answer that contains the list of results.
	*/
	IndexCore.prototype.search = buildSearchMethod('query');
	
	/*
	* -- BETA --
	* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the similar query
	* @param {object} [args] (optional) if set, contains an object with query parameters.
	*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters
	*   are the two most useful to restrict the similar results and get more relevant content
	*/
	IndexCore.prototype.similarSearch = buildSearchMethod('similarQuery');
	
	/*
	* Browse index content. The response content will have a `cursor` property that you can use
	* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browse('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* }, callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browse = function (query, queryParameters, callback) {
	  var merge = __webpack_require__(23);
	
	  var indexObj = this;
	
	  var page;
	  var hitsPerPage;
	
	  // we check variadic calls that are not the one defined
	  // .browse()/.browse(fn)
	  // => page = 0
	  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {
	    page = 0;
	    callback = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'number') {
	    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)
	    page = arguments[0];
	    if (typeof arguments[1] === 'number') {
	      hitsPerPage = arguments[1];
	    } else if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	      hitsPerPage = undefined;
	    }
	    query = undefined;
	    queryParameters = undefined;
	  } else if (_typeof(arguments[0]) === 'object') {
	    // .browse(queryParameters)/.browse(queryParameters, cb)
	    if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	    }
	    queryParameters = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {
	    // .browse(query, cb)
	    callback = arguments[1];
	    queryParameters = undefined;
	  }
	
	  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)
	
	  // get search query parameters combining various possible calls
	  // to .browse();
	  queryParameters = merge({}, queryParameters || {}, {
	    page: page,
	    hitsPerPage: hitsPerPage,
	    query: query
	  });
	
	  var params = this.as._getSearchParams(queryParameters, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',
	    body: { params: params },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browseFrom('14lkfsakl32', callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browseFrom = function (cursor, callback) {
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',
	    body: { cursor: cursor },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Search for facet values
	* https://www.algolia.com/doc/rest-api/search#search-for-facet-values
	*
	* @param {string} params.facetName Facet name, name of the attribute to search for values in.
	* Must be declared as a facet
	* @param {string} params.facetQuery Query for the facet search
	* @param {string} [params.*] Any search parameter of Algolia,
	* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters
	* Pagination is not supported. The page and hitsPerPage parameters will be ignored.
	* @param callback (optional)
	*/
	IndexCore.prototype.searchForFacetValues = function (params, callback) {
	  var clone = __webpack_require__(24);
	  var omit = __webpack_require__(25);
	  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';
	
	  if (params.facetName === undefined || params.facetQuery === undefined) {
	    throw new Error(usage);
	  }
	
	  var facetName = params.facetName;
	  var filteredParams = omit(clone(params), function (keyName) {
	    return keyName === 'facetName';
	  });
	  var searchParameters = this.as._getSearchParams(filteredParams, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',
	    hostType: 'read',
	    body: { params: searchParameters },
	    callback: callback
	  });
	};
	
	IndexCore.prototype.searchFacet = deprecate(function (params, callback) {
	  return this.searchForFacetValues(params, callback);
	}, deprecatedMessage('index.searchFacet(params[, callback])', 'index.searchForFacetValues(params[, callback])'));
	
	IndexCore.prototype._search = function (params, url, callback, additionalUA) {
	  return this.as._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',
	    body: { params: params },
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/' + encodeURIComponent(this.indexName),
	      body: { params: params }
	    },
	    callback: callback,
	    additionalUA: additionalUA
	  });
	};
	
	/*
	* Get an object from this index
	*
	* @param objectID the unique identifier of the object to retrieve
	* @param attrs (optional) if set, contains the array of attribute names to retrieve
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the object to retrieve or the error message if a failure occured
	*/
	IndexCore.prototype.getObject = function (objectID, attrs, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attrs === 'function') {
	    callback = attrs;
	    attrs = undefined;
	  }
	
	  var params = '';
	  if (attrs !== undefined) {
	    params = '?attributes=';
	    for (var i = 0; i < attrs.length; ++i) {
	      if (i !== 0) {
	        params += ',';
	      }
	      params += attrs[i];
	    }
	  }
	
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Get several objects from this index
	*
	* @param objectIDs the array of unique identifier of objects to retrieve
	*/
	IndexCore.prototype.getObjects = function (objectIDs, attributesToRetrieve, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {
	    callback = attributesToRetrieve;
	    attributesToRetrieve = undefined;
	  }
	
	  var body = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      var request = {
	        indexName: indexObj.indexName,
	        objectID: objectID
	      };
	
	      if (attributesToRetrieve) {
	        request.attributesToRetrieve = attributesToRetrieve.join(',');
	      }
	
	      return request;
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/objects',
	    hostType: 'read',
	    body: body,
	    callback: callback
	  });
	};
	
	IndexCore.prototype.as = null;
	IndexCore.prototype.indexName = null;
	IndexCore.prototype.typeAheadArgs = null;
	IndexCore.prototype.typeAheadValueOption = null;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = buildSearchMethod;
	
	var errors = __webpack_require__(19);
	
	/**
	 * Creates a search method to be used in clients
	 * @param {string} queryParam the name of the attribute used for the query
	 * @param {string} url the url
	 * @return {function} the search method
	 */
	function buildSearchMethod(queryParam, url) {
	  /**
	   * The search method. Prepares the data and send the query to Algolia.
	   * @param {string} query the string used for query search
	   * @param {object} args additional parameters to send with the search
	   * @param {function} [callback] the callback to be called with the client gets the answer
	   * @return {undefined|Promise} If the callback is not provided then this methods returns a Promise
	   */
	  return function search(query, args, callback) {
	    // warn V2 users on how to search
	    if (typeof query === 'function' && (typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' || (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) === 'object') {
	      // .search(query, params, cb)
	      // .search(cb, params)
	      throw new errors.AlgoliaSearchError('index.search usage is index.search(query, params, cb)');
	    }
	
	    // Normalizing the function signature
	    if (arguments.length === 0 || typeof query === 'function') {
	      // Usage : .search(), .search(cb)
	      callback = query;
	      query = '';
	    } else if (arguments.length === 1 || typeof args === 'function') {
	      // Usage : .search(query/args), .search(query, cb)
	      callback = args;
	      args = undefined;
	    }
	    // At this point we have 3 arguments with values
	
	    // Usage : .search(args) // careful: typeof null === 'object'
	    if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object' && query !== null) {
	      args = query;
	      query = undefined;
	    } else if (query === undefined || query === null) {
	      // .search(undefined/null)
	      query = '';
	    }
	
	    var params = '';
	
	    if (query !== undefined) {
	      params += queryParam + '=' + encodeURIComponent(query);
	    }
	
	    var additionalUA;
	    if (args !== undefined) {
	      if (args.additionalUA) {
	        additionalUA = args.additionalUA;
	        delete args.additionalUA;
	      }
	      // `_getSearchParams` will augment params, do not be fooled by the = versus += from previous if
	      params = this.as._getSearchParams(args, params);
	    }
	
	    return this._search(params, url, callback, additionalUA);
	  };
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This file hosts our error definitions
	// We use custom error "types" so that we can act on them when we need it
	// e.g.: if error instanceof errors.UnparsableJSON then..
	
	var inherits = __webpack_require__(16);
	
	function AlgoliaSearchError(message, extraProperties) {
	  var forEach = __webpack_require__(20);
	
	  var error = this;
	
	  // try to get a stacktrace
	  if (typeof Error.captureStackTrace === 'function') {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    error.stack = new Error().stack || 'Cannot get a stacktrace, browser is too old';
	  }
	
	  this.name = 'AlgoliaSearchError';
	  this.message = message || 'Unknown error';
	
	  if (extraProperties) {
	    forEach(extraProperties, function addToErrorObject(value, key) {
	      error[key] = value;
	    });
	  }
	}
	
	inherits(AlgoliaSearchError, Error);
	
	function createCustomError(name, message) {
	  function AlgoliaSearchCustomError() {
	    var args = Array.prototype.slice.call(arguments, 0);
	
	    // custom message not set, use default
	    if (typeof args[0] !== 'string') {
	      args.unshift(message);
	    }
	
	    AlgoliaSearchError.apply(this, args);
	    this.name = 'AlgoliaSearch' + name + 'Error';
	  }
	
	  inherits(AlgoliaSearchCustomError, AlgoliaSearchError);
	
	  return AlgoliaSearchCustomError;
	}
	
	// late exports to let various fn defs and inherits take place
	module.exports = {
	  AlgoliaSearchError: AlgoliaSearchError,
	  UnparsableJSON: createCustomError('UnparsableJSON', 'Could not parse the incoming response as JSON, see err.more for details'),
	  RequestTimeout: createCustomError('RequestTimeout', 'Request timedout before getting a response'),
	  Network: createCustomError('Network', 'Network issue, see err.more for details'),
	  JSONPScriptFail: createCustomError('JSONPScriptFail', '<script> was loaded but did not call our provided callback'),
	  JSONPScriptError: createCustomError('JSONPScriptError', '<script> unable to load due to an `error` event on it'),
	  Unknown: createCustomError('Unknown', 'Unknown error occured')
	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = function forEach(obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function deprecate(fn, message) {
	  var warned = false;
	
	  function deprecated() {
	    if (!warned) {
	      /* eslint no-console:0 */
	      console.warn(message);
	      warned = true;
	    }
	
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function deprecatedMessage(previousUsage, newUsage) {
	  var githubAnchorLink = previousUsage.toLowerCase().replace(/[\.\(\)]/g, '');
	
	  return 'algoliasearch: `' + previousUsage + '` was replaced by `' + newUsage + '`. Please see https://github.com/algolia/algoliasearch-client-javascript/wiki/Deprecated#' + githubAnchorLink;
	};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var foreach = __webpack_require__(20);
	
	module.exports = function merge(destination /* , sources */) {
	  var sources = Array.prototype.slice.call(arguments);
	
	  foreach(sources, function (source) {
	    for (var keyName in source) {
	      if (source.hasOwnProperty(keyName)) {
	        if (_typeof(destination[keyName]) === 'object' && _typeof(source[keyName]) === 'object') {
	          destination[keyName] = merge({}, destination[keyName], source[keyName]);
	        } else if (source[keyName] !== undefined) {
	          destination[keyName] = source[keyName];
	        }
	      }
	    }
	  });
	
	  return destination;
	};

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function clone(obj) {
	  return JSON.parse(JSON.stringify(obj));
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = function omit(obj, test) {
	  var keys = __webpack_require__(26);
	  var foreach = __webpack_require__(20);
	
	  var filtered = {};
	
	  foreach(keys(obj), function doFilter(keyName) {
	    if (test(keyName) !== true) {
	      filtered[keyName] = obj[keyName];
	    }
	  });
	
	  return filtered;
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// modified from https://github.com/es-shims/es5-shim
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(27);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
	var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = function () {
		/* global window */
		if (typeof window === 'undefined') {
			return false;
		}
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}();
	var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};
	
	var keysShim = function keys(object) {
		var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];
	
		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}
	
		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}
	
		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}
	
		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	
			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
	
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2);
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};
	
	module.exports = keysShim;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toStr = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	'use strict';
	
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var foreach = __webpack_require__(20);
	
	module.exports = function map(arr, fn) {
	  var newArr = [];
	  foreach(arr, function (item, itemIndex) {
	    newArr.push(fn(item, itemIndex, arr));
	  });
	  return newArr;
	};

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	"use strict";
	
	// Parse cloud does not supports setTimeout
	// We do not store a setTimeout reference in the client everytime
	// We only fallback to a fake setTimeout when not available
	// setTimeout cannot be override globally sadly
	module.exports = function exitPromise(fn, _setTimeout) {
	  _setTimeout(fn, 0);
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This is the object returned by the `index.browseAll()` method
	
	module.exports = IndexBrowser;
	
	var inherits = __webpack_require__(16);
	var EventEmitter = __webpack_require__(32).EventEmitter;
	
	function IndexBrowser() {}
	
	inherits(IndexBrowser, EventEmitter);
	
	IndexBrowser.prototype.stop = function () {
	  this._stopped = true;
	  this._clean();
	};
	
	IndexBrowser.prototype._end = function () {
	  this.emit('end');
	  this._clean();
	};
	
	IndexBrowser.prototype._error = function (err) {
	  this.emit('error', err);
	  this._clean();
	};
	
	IndexBrowser.prototype._result = function (content) {
	  this.emit('result', content);
	};
	
	IndexBrowser.prototype._clean = function () {
	  this.removeAllListeners('stop');
	  this.removeAllListeners('end');
	  this.removeAllListeners('error');
	  this.removeAllListeners('result');
	};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function (type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events) this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler)) return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function (type, listener) {
	  var m;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events) this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function (type, listener) {
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function (type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type]) return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener || isFunction(list.listener) && list.listener === listener) {
	    delete this._events[type];
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0) return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function (type) {
	  var key, listeners;
	
	  if (!this._events) return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length) {
	      this.removeListener(type, listeners[listeners.length - 1]);
	    }
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function (type) {
	  var ret;
	  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function (type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function (emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = AlgoliaSearchCore;
	
	var errors = __webpack_require__(19);
	var exitPromise = __webpack_require__(30);
	var IndexCore = __webpack_require__(17);
	var store = __webpack_require__(34);
	
	// We will always put the API KEY in the JSON body in case of too long API KEY,
	// to avoid query string being too long and failing in various conditions (our server limit, browser limit,
	// proxies limit)
	var MAX_API_KEY_LENGTH = 500;
	var RESET_APP_DATA_TIMER = process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) || 60 * 2 * 1000; // after 2 minutes reset to first host
	
	/*
	 * Algolia Search library initialization
	 * https://www.algolia.com/
	 *
	 * @param {string} applicationID - Your applicationID, found in your dashboard
	 * @param {string} apiKey - Your API key, found in your dashboard
	 * @param {Object} [opts]
	 * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,
	 * another request will be issued after this timeout
	 * @param {string} [opts.protocol='http:'] - The protocol used to query Algolia Search API.
	 *                                        Set to 'https:' to force using https.
	 *                                        Default to document.location.protocol in browsers
	 * @param {Object|Array} [opts.hosts={
	 *           read: [this.applicationID + '-dsn.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]),
	 *           write: [this.applicationID + '.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]) - The hosts to use for Algolia Search API.
	 *           If you provide them, you will less benefit from our HA implementation
	 */
	function AlgoliaSearchCore(applicationID, apiKey, opts) {
	  var debug = __webpack_require__(35)('algoliasearch');
	
	  var clone = __webpack_require__(24);
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';
	
	  if (opts._allowEmptyCredentials !== true && !applicationID) {
	    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);
	  }
	
	  if (opts._allowEmptyCredentials !== true && !apiKey) {
	    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);
	  }
	
	  this.applicationID = applicationID;
	  this.apiKey = apiKey;
	
	  this.hosts = {
	    read: [],
	    write: []
	  };
	
	  opts = opts || {};
	
	  var protocol = opts.protocol || 'https:';
	  this._timeouts = opts.timeouts || {
	    connect: 1 * 1000, // 500ms connect is GPRS latency
	    read: 2 * 1000,
	    write: 30 * 1000
	  };
	
	  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before
	  if (opts.timeout) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;
	  }
	
	  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`
	  // we also accept `http` and `https`. It's a common error.
	  if (!/:$/.test(protocol)) {
	    protocol = protocol + ':';
	  }
	
	  if (opts.protocol !== 'http:' && opts.protocol !== 'https:') {
	    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');
	  }
	
	  this._checkAppIdData();
	
	  if (!opts.hosts) {
	    var defaultHosts = map(this._shuffleResult, function (hostNumber) {
	      return applicationID + '-' + hostNumber + '.algolianet.com';
	    });
	
	    // no hosts given, compute defaults
	    this.hosts.read = [this.applicationID + '-dsn.algolia.net'].concat(defaultHosts);
	    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);
	  } else if (isArray(opts.hosts)) {
	    // when passing custom hosts, we need to have a different host index if the number
	    // of write/read hosts are different.
	    this.hosts.read = clone(opts.hosts);
	    this.hosts.write = clone(opts.hosts);
	  } else {
	    this.hosts.read = clone(opts.hosts.read);
	    this.hosts.write = clone(opts.hosts.write);
	  }
	
	  // add protocol and lowercase hosts
	  this.hosts.read = map(this.hosts.read, prepareHost(protocol));
	  this.hosts.write = map(this.hosts.write, prepareHost(protocol));
	
	  this.extraHeaders = {};
	
	  // In some situations you might want to warm the cache
	  this.cache = opts._cache || {};
	
	  this._ua = opts._ua;
	  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;
	  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;
	
	  this._setTimeout = opts._setTimeout;
	
	  debug('init done, %j', this);
	}
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearchCore.prototype.initIndex = function (indexName) {
	  return new IndexCore(this, indexName);
	};
	
	/**
	* Add an extra field to the HTTP request
	*
	* @param name the header field name
	* @param value the header field value
	*/
	AlgoliaSearchCore.prototype.setExtraHeader = function (name, value) {
	  this.extraHeaders[name.toLowerCase()] = value;
	};
	
	/**
	* Get the value of an extra HTTP header
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.getExtraHeader = function (name) {
	  return this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Remove an extra field from the HTTP request
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.unsetExtraHeader = function (name) {
	  delete this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Augment sent x-algolia-agent with more data, each agent part
	* is automatically separated from the others by a semicolon;
	*
	* @param algoliaAgent the agent to add
	*/
	AlgoliaSearchCore.prototype.addAlgoliaAgent = function (algoliaAgent) {
	  if (this._ua.indexOf(';' + algoliaAgent) === -1) {
	    this._ua += ';' + algoliaAgent;
	  }
	};
	
	/*
	 * Wrapper that try all hosts to maximize the quality of service
	 */
	AlgoliaSearchCore.prototype._jsonRequest = function (initialOpts) {
	  this._checkAppIdData();
	
	  var requestDebug = __webpack_require__(35)('algoliasearch:' + initialOpts.url);
	
	  var body;
	  var additionalUA = initialOpts.additionalUA || '';
	  var cache = initialOpts.cache;
	  var client = this;
	  var tries = 0;
	  var usingFallback = false;
	  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;
	  var headers;
	
	  if (this.apiKey.length > MAX_API_KEY_LENGTH && initialOpts.body !== undefined && (initialOpts.body.params !== undefined || // index.search()
	  initialOpts.body.requests !== undefined) // client.search()
	  ) {
	      initialOpts.body.apiKey = this.apiKey;
	      headers = this._computeRequestHeaders(additionalUA, false);
	    } else {
	    headers = this._computeRequestHeaders(additionalUA);
	  }
	
	  if (initialOpts.body !== undefined) {
	    body = safeJSONStringify(initialOpts.body);
	  }
	
	  requestDebug('request start');
	  var debugData = [];
	
	  function doRequest(requester, reqOpts) {
	    client._checkAppIdData();
	
	    var startTime = new Date();
	    var cacheID;
	
	    if (client._useCache) {
	      cacheID = initialOpts.url;
	    }
	
	    // as we sometime use POST requests to pass parameters (like query='aa'),
	    // the cacheID must also include the body to be different between calls
	    if (client._useCache && body) {
	      cacheID += '_body_' + reqOpts.body;
	    }
	
	    // handle cache existence
	    if (client._useCache && cache && cache[cacheID] !== undefined) {
	      requestDebug('serving response from cache');
	      return client._promise.resolve(JSON.parse(cache[cacheID]));
	    }
	
	    // if we reached max tries
	    if (tries >= client.hosts[initialOpts.hostType].length) {
	      if (!hasFallback || usingFallback) {
	        requestDebug('could not get any response');
	        // then stop
	        return client._promise.reject(new errors.AlgoliaSearchError('Cannot connect to the AlgoliaSearch API.' + ' Send an email to support@algolia.com to report and resolve the issue.' + ' Application id was: ' + client.applicationID, { debugData: debugData }));
	      }
	
	      requestDebug('switching to fallback');
	
	      // let's try the fallback starting from here
	      tries = 0;
	
	      // method, url and body are fallback dependent
	      reqOpts.method = initialOpts.fallback.method;
	      reqOpts.url = initialOpts.fallback.url;
	      reqOpts.jsonBody = initialOpts.fallback.body;
	      if (reqOpts.jsonBody) {
	        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);
	      }
	      // re-compute headers, they could be omitting the API KEY
	      headers = client._computeRequestHeaders(additionalUA);
	
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      client._setHostIndexByType(0, initialOpts.hostType);
	      usingFallback = true; // the current request is now using fallback
	      return doRequest(client._request.fallback, reqOpts);
	    }
	
	    var currentHost = client._getHostByType(initialOpts.hostType);
	
	    var url = currentHost + reqOpts.url;
	    var options = {
	      body: reqOpts.body,
	      jsonBody: reqOpts.jsonBody,
	      method: reqOpts.method,
	      headers: headers,
	      timeouts: reqOpts.timeouts,
	      debug: requestDebug
	    };
	
	    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d', options.method, url, options.headers, options.timeouts);
	
	    if (requester === client._request.fallback) {
	      requestDebug('using fallback');
	    }
	
	    // `requester` is any of this._request or this._request.fallback
	    // thus it needs to be called using the client as context
	    return requester.call(client, url, options).then(success, tryFallback);
	
	    function success(httpResponse) {
	      // compute the status of the response,
	      //
	      // When in browser mode, using XDR or JSONP, we have no statusCode available
	      // So we rely on our API response `status` property.
	      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)
	      // So we check if there's a `message` along `status` and it means it's an error
	      //
	      // That's the only case where we have a response.status that's not the http statusCode
	      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||
	
	      // this is important to check the request statusCode AFTER the body eventual
	      // statusCode because some implementations (jQuery XDomainRequest transport) may
	      // send statusCode 200 while we had an error
	      httpResponse.statusCode ||
	
	      // When in browser mode, using XDR or JSONP
	      // we default to success when no error (no response.status && response.message)
	      // If there was a JSON.parse() error then body is null and it fails
	      httpResponse && httpResponse.body && 200;
	
	      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j', httpResponse.statusCode, status, httpResponse.headers);
	
	      var httpResponseOk = Math.floor(status / 100) === 2;
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime,
	        statusCode: status
	      });
	
	      if (httpResponseOk) {
	        if (client._useCache && cache) {
	          cache[cacheID] = httpResponse.responseText;
	        }
	
	        return httpResponse.body;
	      }
	
	      var shouldRetry = Math.floor(status / 100) !== 4;
	
	      if (shouldRetry) {
	        tries += 1;
	        return retryRequest();
	      }
	
	      requestDebug('unrecoverable error');
	
	      // no success and no retry => fail
	      var unrecoverableError = new errors.AlgoliaSearchError(httpResponse.body && httpResponse.body.message, { debugData: debugData, statusCode: status });
	
	      return client._promise.reject(unrecoverableError);
	    }
	
	    function tryFallback(err) {
	      // error cases:
	      //  While not in fallback mode:
	      //    - CORS not supported
	      //    - network error
	      //  While in fallback mode:
	      //    - timeout
	      //    - network error
	      //    - badly formatted JSONP (script loaded, did not call our callback)
	      //  In both cases:
	      //    - uncaught exception occurs (TypeError)
	      requestDebug('error: %s, stack: %s', err.message, err.stack);
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime
	      });
	
	      if (!(err instanceof errors.AlgoliaSearchError)) {
	        err = new errors.Unknown(err && err.message, err);
	      }
	
	      tries += 1;
	
	      // stop the request implementation when:
	      if (
	      // we did not generate this error,
	      // it comes from a throw in some other piece of code
	      err instanceof errors.Unknown ||
	
	      // server sent unparsable JSON
	      err instanceof errors.UnparsableJSON ||
	
	      // max tries and already using fallback or no fallback
	      tries >= client.hosts[initialOpts.hostType].length && (usingFallback || !hasFallback)) {
	        // stop request implementation for this command
	        err.debugData = debugData;
	        return client._promise.reject(err);
	      }
	
	      // When a timeout occured, retry by raising timeout
	      if (err instanceof errors.RequestTimeout) {
	        return retryRequestWithHigherTimeout();
	      }
	
	      return retryRequest();
	    }
	
	    function retryRequest() {
	      requestDebug('retrying request');
	      client._incrementHostIndex(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	
	    function retryRequestWithHigherTimeout() {
	      requestDebug('retrying request with higher timeout');
	      client._incrementHostIndex(initialOpts.hostType);
	      client._incrementTimeoutMultipler();
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	  }
	
	  var promise = doRequest(client._request, {
	    url: initialOpts.url,
	    method: initialOpts.method,
	    body: body,
	    jsonBody: initialOpts.body,
	    timeouts: client._getTimeoutsForRequest(initialOpts.hostType)
	  });
	
	  // either we have a callback
	  // either we are using promises
	  if (typeof initialOpts.callback === 'function') {
	    promise.then(function okCb(content) {
	      exitPromise(function () {
	        initialOpts.callback(null, content);
	      }, client._setTimeout || setTimeout);
	    }, function nookCb(err) {
	      exitPromise(function () {
	        initialOpts.callback(err);
	      }, client._setTimeout || setTimeout);
	    });
	  } else {
	    return promise;
	  }
	};
	
	/*
	* Transform search param object in query string
	* @param {object} args arguments to add to the current query string
	* @param {string} params current query string
	* @return {string} the final query string
	*/
	AlgoliaSearchCore.prototype._getSearchParams = function (args, params) {
	  if (args === undefined || args === null) {
	    return params;
	  }
	  for (var key in args) {
	    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {
	      params += params === '' ? '' : '&';
	      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);
	    }
	  }
	  return params;
	};
	
	AlgoliaSearchCore.prototype._computeRequestHeaders = function (additionalUA, withAPIKey) {
	  var forEach = __webpack_require__(20);
	
	  var ua = additionalUA ? this._ua + ';' + additionalUA : this._ua;
	
	  var requestHeaders = {
	    'x-algolia-agent': ua,
	    'x-algolia-application-id': this.applicationID
	  };
	
	  // browser will inline headers in the url, node.js will use http headers
	  // but in some situations, the API KEY will be too long (big secured API keys)
	  // so if the request is a POST and the KEY is very long, we will be asked to not put
	  // it into headers but in the JSON body
	  if (withAPIKey !== false) {
	    requestHeaders['x-algolia-api-key'] = this.apiKey;
	  }
	
	  if (this.userToken) {
	    requestHeaders['x-algolia-usertoken'] = this.userToken;
	  }
	
	  if (this.securityTags) {
	    requestHeaders['x-algolia-tagfilters'] = this.securityTags;
	  }
	
	  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {
	    requestHeaders[key] = value;
	  });
	
	  return requestHeaders;
	};
	
	/**
	 * Search through multiple indices at the same time
	 * @param  {Object[]}   queries  An array of queries you want to run.
	 * @param {string} queries[].indexName The index name you want to target
	 * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`
	 * @param {Object} queries[].params Any search param like hitsPerPage, ..
	 * @param  {Function} callback Callback to be called
	 * @return {Promise|undefined} Returns a promise if no callback given
	 */
	AlgoliaSearchCore.prototype.search = function (queries, opts, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: client.search(arrayOfQueries[, callback])';
	
	  if (!isArray(queries)) {
	    throw new Error(usage);
	  }
	
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var client = this;
	
	  var postObj = {
	    requests: map(queries, function prepareRequest(query) {
	      var params = '';
	
	      // allow query.query
	      // so we are mimicing the index.search(query, params) method
	      // {indexName:, query:, params:}
	      if (query.query !== undefined) {
	        params += 'query=' + encodeURIComponent(query.query);
	      }
	
	      return {
	        indexName: query.indexName,
	        params: client._getSearchParams(query.params, params)
	      };
	    })
	  };
	
	  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {
	    return requestId + '=' + encodeURIComponent('/1/indexes/' + encodeURIComponent(request.indexName) + '?' + request.params);
	  }).join('&');
	
	  var url = '/1/indexes/*/queries';
	
	  if (opts.strategy !== undefined) {
	    url += '?strategy=' + opts.strategy;
	  }
	
	  return this._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url,
	    body: postObj,
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/*',
	      body: {
	        params: JSONPParams
	      }
	    },
	    callback: callback
	  });
	};
	
	/**
	 * Set the extra security tagFilters header
	 * @param {string|array} tags The list of tags defining the current security filters
	 */
	AlgoliaSearchCore.prototype.setSecurityTags = function (tags) {
	  if (Object.prototype.toString.call(tags) === '[object Array]') {
	    var strTags = [];
	    for (var i = 0; i < tags.length; ++i) {
	      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {
	        var oredTags = [];
	        for (var j = 0; j < tags[i].length; ++j) {
	          oredTags.push(tags[i][j]);
	        }
	        strTags.push('(' + oredTags.join(',') + ')');
	      } else {
	        strTags.push(tags[i]);
	      }
	    }
	    tags = strTags.join(',');
	  }
	
	  this.securityTags = tags;
	};
	
	/**
	 * Set the extra user token header
	 * @param {string} userToken The token identifying a uniq user (used to apply rate limits)
	 */
	AlgoliaSearchCore.prototype.setUserToken = function (userToken) {
	  this.userToken = userToken;
	};
	
	/**
	 * Clear all queries in client's cache
	 * @return undefined
	 */
	AlgoliaSearchCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/**
	* Set the number of milliseconds a request can take before automatically being terminated.
	* @deprecated
	* @param {Number} milliseconds
	*/
	AlgoliaSearchCore.prototype.setRequestTimeout = function (milliseconds) {
	  if (milliseconds) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;
	  }
	};
	
	/**
	* Set the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.setTimeouts = function (timeouts) {
	  this._timeouts = timeouts;
	};
	
	/**
	* Get the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.getTimeouts = function () {
	  return this._timeouts;
	};
	
	AlgoliaSearchCore.prototype._getAppIdData = function () {
	  var data = store.get(this.applicationID);
	  if (data !== null) this._cacheAppIdData(data);
	  return data;
	};
	
	AlgoliaSearchCore.prototype._setAppIdData = function (data) {
	  data.lastChange = new Date().getTime();
	  this._cacheAppIdData(data);
	  return store.set(this.applicationID, data);
	};
	
	AlgoliaSearchCore.prototype._checkAppIdData = function () {
	  var data = this._getAppIdData();
	  var now = new Date().getTime();
	  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {
	    return this._resetInitialAppIdData(data);
	  }
	
	  return data;
	};
	
	AlgoliaSearchCore.prototype._resetInitialAppIdData = function (data) {
	  var newData = data || {};
	  newData.hostIndexes = { read: 0, write: 0 };
	  newData.timeoutMultiplier = 1;
	  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);
	  return this._setAppIdData(newData);
	};
	
	AlgoliaSearchCore.prototype._cacheAppIdData = function (data) {
	  this._hostIndexes = data.hostIndexes;
	  this._timeoutMultiplier = data.timeoutMultiplier;
	  this._shuffleResult = data.shuffleResult;
	};
	
	AlgoliaSearchCore.prototype._partialAppIdDataUpdate = function (newData) {
	  var foreach = __webpack_require__(20);
	  var currentData = this._getAppIdData();
	  foreach(newData, function (value, key) {
	    currentData[key] = value;
	  });
	
	  return this._setAppIdData(currentData);
	};
	
	AlgoliaSearchCore.prototype._getHostByType = function (hostType) {
	  return this.hosts[hostType][this._getHostIndexByType(hostType)];
	};
	
	AlgoliaSearchCore.prototype._getTimeoutMultiplier = function () {
	  return this._timeoutMultiplier;
	};
	
	AlgoliaSearchCore.prototype._getHostIndexByType = function (hostType) {
	  return this._hostIndexes[hostType];
	};
	
	AlgoliaSearchCore.prototype._setHostIndexByType = function (hostIndex, hostType) {
	  var clone = __webpack_require__(24);
	  var newHostIndexes = clone(this._hostIndexes);
	  newHostIndexes[hostType] = hostIndex;
	  this._partialAppIdDataUpdate({ hostIndexes: newHostIndexes });
	  return hostIndex;
	};
	
	AlgoliaSearchCore.prototype._incrementHostIndex = function (hostType) {
	  return this._setHostIndexByType((this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType);
	};
	
	AlgoliaSearchCore.prototype._incrementTimeoutMultipler = function () {
	  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);
	  return this._partialAppIdDataUpdate({ timeoutMultiplier: timeoutMultiplier });
	};
	
	AlgoliaSearchCore.prototype._getTimeoutsForRequest = function (hostType) {
	  return {
	    connect: this._timeouts.connect * this._timeoutMultiplier,
	    complete: this._timeouts[hostType] * this._timeoutMultiplier
	  };
	};
	
	function prepareHost(protocol) {
	  return function prepare(host) {
	    return protocol + '//' + host.toLowerCase();
	  };
	}
	
	// Prototype.js < 1.7, a widely used library, defines a weird
	// Array.prototype.toJSON function that will fail to stringify our content
	// appropriately
	// refs:
	//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q
	//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c
	//   - http://stackoverflow.com/a/3148441/147079
	function safeJSONStringify(obj) {
	  /* eslint no-extend-native:0 */
	
	  if (Array.prototype.toJSON === undefined) {
	    return JSON.stringify(obj);
	  }
	
	  var toJSON = Array.prototype.toJSON;
	  delete Array.prototype.toJSON;
	  var out = JSON.stringify(obj);
	  Array.prototype.toJSON = toJSON;
	
	  return out;
	}
	
	function shuffle(array) {
	  var currentIndex = array.length;
	  var temporaryValue;
	  var randomIndex;
	
	  // While there remain elements to shuffle...
	  while (currentIndex !== 0) {
	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex -= 1;
	
	    // And swap it with the current element.
	    temporaryValue = array[currentIndex];
	    array[currentIndex] = array[randomIndex];
	    array[randomIndex] = temporaryValue;
	  }
	
	  return array;
	}
	
	function removeCredentials(headers) {
	  var newHeaders = {};
	
	  for (var headerName in headers) {
	    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {
	      var value;
	
	      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {
	        value = '**hidden for security purposes**';
	      } else {
	        value = headers[headerName];
	      }
	
	      newHeaders[headerName] = value;
	    }
	  }
	
	  return newHeaders;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var debug = __webpack_require__(35)('algoliasearch:src/hostIndexState.js');
	var localStorageNamespace = 'algoliasearch-client-js';
	
	var store;
	var moduleStore = {
	  state: {},
	  set: function set(key, data) {
	    this.state[key] = data;
	    return this.state[key];
	  },
	  get: function get(key) {
	    return this.state[key] || null;
	  }
	};
	
	var localStorageStore = {
	  set: function set(key, data) {
	    moduleStore.set(key, data); // always replicate localStorageStore to moduleStore in case of failure
	
	    try {
	      var namespace = JSON.parse(global.localStorage[localStorageNamespace]);
	      namespace[key] = data;
	      global.localStorage[localStorageNamespace] = JSON.stringify(namespace);
	      return namespace[key];
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  },
	  get: function get(key) {
	    try {
	      return JSON.parse(global.localStorage[localStorageNamespace])[key] || null;
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  }
	};
	
	function localStorageFailure(key, e) {
	  debug('localStorage failed with', e);
	  cleanup();
	  store = moduleStore;
	  return store.get(key);
	}
	
	store = supportsLocalStorage() ? localStorageStore : moduleStore;
	
	module.exports = {
	  get: getOrSet,
	  set: getOrSet,
	  supportsLocalStorage: supportsLocalStorage
	};
	
	function getOrSet(key, data) {
	  if (arguments.length === 1) {
	    return store.get(key);
	  }
	
	  return store.set(key, data);
	}
	
	function supportsLocalStorage() {
	  try {
	    if ('localStorage' in global && global.localStorage !== null) {
	      if (!global.localStorage[localStorageNamespace]) {
	        // actual creation of the namespace
	        global.localStorage.setItem(localStorageNamespace, JSON.stringify({}));
	      }
	      return true;
	    }
	
	    return false;
	  } catch (_) {
	    return false;
	  }
	}
	
	// In case of any error on localStorage, we clean our own namespace, this should handle
	// quota errors when a lot of keys + data are used
	function cleanup() {
	  try {
	    global.localStorage.removeItem(localStorageNamespace);
	  } catch (_) {
	    // nothing to do
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(36);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
	  // double check webkit in userAgent just in case we are in a worker
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(37);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0,
	      i;
	
	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var global = __webpack_require__(39);
	var Promise = global.Promise || __webpack_require__(40).Promise;
	
	// This is the standalone browser build entry point
	// Browser implementation of the Algolia Search JavaScript client,
	// using XMLHttpRequest, XDomainRequest and JSONP as fallback
	module.exports = function createAlgoliasearch(AlgoliaSearch, uaSuffix) {
	  var inherits = __webpack_require__(16);
	  var errors = __webpack_require__(19);
	  var inlineHeaders = __webpack_require__(42);
	  var jsonpRequest = __webpack_require__(44);
	  var places = __webpack_require__(45);
	  uaSuffix = uaSuffix || '';
	
	  if (process.env.NODE_ENV === 'debug') {
	    __webpack_require__(35).enable('algoliasearch*');
	  }
	
	  function algoliasearch(applicationID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    var getDocumentProtocol = __webpack_require__(46);
	
	    opts = cloneDeep(opts || {});
	
	    if (opts.protocol === undefined) {
	      opts.protocol = getDocumentProtocol();
	    }
	
	    opts._ua = opts._ua || algoliasearch.ua;
	
	    return new AlgoliaSearchBrowser(applicationID, apiKey, opts);
	  }
	
	  algoliasearch.version = __webpack_require__(47);
	  algoliasearch.ua = 'Algolia for vanilla JavaScript ' + uaSuffix + algoliasearch.version;
	  algoliasearch.initPlaces = places(algoliasearch);
	
	  // we expose into window no matter how we are used, this will allow
	  // us to easily debug any website running algolia
	  global.__algolia = {
	    debug: __webpack_require__(35),
	    algoliasearch: algoliasearch
	  };
	
	  var support = {
	    hasXMLHttpRequest: 'XMLHttpRequest' in global,
	    hasXDomainRequest: 'XDomainRequest' in global
	  };
	
	  if (support.hasXMLHttpRequest) {
	    support.cors = 'withCredentials' in new XMLHttpRequest();
	  }
	
	  function AlgoliaSearchBrowser() {
	    // call AlgoliaSearch constructor
	    AlgoliaSearch.apply(this, arguments);
	  }
	
	  inherits(AlgoliaSearchBrowser, AlgoliaSearch);
	
	  AlgoliaSearchBrowser.prototype._request = function request(url, opts) {
	    return new Promise(function wrapRequest(resolve, reject) {
	      // no cors or XDomainRequest, no request
	      if (!support.cors && !support.hasXDomainRequest) {
	        // very old browser, not supported
	        reject(new errors.Network('CORS not supported'));
	        return;
	      }
	
	      url = inlineHeaders(url, opts.headers);
	
	      var body = opts.body;
	      var req = support.cors ? new XMLHttpRequest() : new XDomainRequest();
	      var reqTimeout;
	      var timedOut;
	      var connected = false;
	
	      reqTimeout = setTimeout(onTimeout, opts.timeouts.connect);
	      // we set an empty onprogress listener
	      // so that XDomainRequest on IE9 is not aborted
	      // refs:
	      //  - https://github.com/algolia/algoliasearch-client-js/issues/76
	      //  - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
	      req.onprogress = onProgress;
	      if ('onreadystatechange' in req) req.onreadystatechange = onReadyStateChange;
	      req.onload = onLoad;
	      req.onerror = onError;
	
	      // do not rely on default XHR async flag, as some analytics code like hotjar
	      // breaks it and set it to false by default
	      if (req instanceof XMLHttpRequest) {
	        req.open(opts.method, url, true);
	      } else {
	        req.open(opts.method, url);
	      }
	
	      // headers are meant to be sent after open
	      if (support.cors) {
	        if (body) {
	          if (opts.method === 'POST') {
	            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests
	            req.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
	          } else {
	            req.setRequestHeader('content-type', 'application/json');
	          }
	        }
	        req.setRequestHeader('accept', 'application/json');
	      }
	
	      req.send(body);
	
	      // event object not received in IE8, at least
	      // but we do not use it, still important to note
	      function onLoad() /* event */{
	        // When browser does not supports req.timeout, we can
	        // have both a load and timeout event, since handled by a dumb setTimeout
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        var out;
	
	        try {
	          out = {
	            body: JSON.parse(req.responseText),
	            responseText: req.responseText,
	            statusCode: req.status,
	            // XDomainRequest does not have any response headers
	            headers: req.getAllResponseHeaders && req.getAllResponseHeaders() || {}
	          };
	        } catch (e) {
	          out = new errors.UnparsableJSON({
	            more: req.responseText
	          });
	        }
	
	        if (out instanceof errors.UnparsableJSON) {
	          reject(out);
	        } else {
	          resolve(out);
	        }
	      }
	
	      function onError(event) {
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        // error event is trigerred both with XDR/XHR on:
	        //   - DNS error
	        //   - unallowed cross domain request
	        reject(new errors.Network({
	          more: event
	        }));
	      }
	
	      function onTimeout() {
	        timedOut = true;
	        req.abort();
	
	        reject(new errors.RequestTimeout());
	      }
	
	      function onConnect() {
	        connected = true;
	        clearTimeout(reqTimeout);
	        reqTimeout = setTimeout(onTimeout, opts.timeouts.complete);
	      }
	
	      function onProgress() {
	        if (!connected) onConnect();
	      }
	
	      function onReadyStateChange() {
	        if (!connected && req.readyState > 1) onConnect();
	      }
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._request.fallback = function requestFallback(url, opts) {
	    url = inlineHeaders(url, opts.headers);
	
	    return new Promise(function wrapJsonpRequest(resolve, reject) {
	      jsonpRequest(url, opts, function jsonpRequestDone(err, content) {
	        if (err) {
	          reject(err);
	          return;
	        }
	
	        resolve(content);
	      });
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._promise = {
	    reject: function rejectPromise(val) {
	      return Promise.reject(val);
	    },
	    resolve: function resolvePromise(val) {
	      return Promise.resolve(val);
	    },
	    delay: function delayPromise(ms) {
	      return new Promise(function resolveOnTimeout(resolve /* , reject*/) {
	        setTimeout(resolve, ms);
	      });
	    }
	  };
	
	  return algoliasearch;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var win;
	
	if (typeof window !== "undefined") {
	    win = window;
	} else if (typeof global !== "undefined") {
	    win = global;
	} else if (typeof self !== "undefined") {
	    win = self;
	} else {
	    win = {};
	}
	
	module.exports = win;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.1.1
	 */
	
	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.ES6Promise = factory();
	})(undefined, function () {
	  'use strict';
	
	  function objectOrFunction(x) {
	    var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);
	    return x !== null && (type === 'object' || type === 'function');
	  }
	
	  function isFunction(x) {
	    return typeof x === 'function';
	  }
	
	  var _isArray = undefined;
	  if (Array.isArray) {
	    _isArray = Array.isArray;
	  } else {
	    _isArray = function _isArray(x) {
	      return Object.prototype.toString.call(x) === '[object Array]';
	    };
	  }
	
	  var isArray = _isArray;
	
	  var len = 0;
	  var vertxNext = undefined;
	  var customSchedulerFn = undefined;
	
	  var asap = function asap(callback, arg) {
	    queue[len] = callback;
	    queue[len + 1] = arg;
	    len += 2;
	    if (len === 2) {
	      // If len is 2, that means that we need to schedule an async flush.
	      // If additional callbacks are queued before the queue is flushed, they
	      // will be processed by this flush that we are scheduling.
	      if (customSchedulerFn) {
	        customSchedulerFn(flush);
	      } else {
	        scheduleFlush();
	      }
	    }
	  };
	
	  function setScheduler(scheduleFn) {
	    customSchedulerFn = scheduleFn;
	  }
	
	  function setAsap(asapFn) {
	    asap = asapFn;
	  }
	
	  var browserWindow = typeof window !== 'undefined' ? window : undefined;
	  var browserGlobal = browserWindow || {};
	  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	  // test for web worker but not in IE10
	  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	  // node
	  function useNextTick() {
	    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	    // see https://github.com/cujojs/when/issues/410 for details
	    return function () {
	      return process.nextTick(flush);
	    };
	  }
	
	  // vertx
	  function useVertxTimer() {
	    if (typeof vertxNext !== 'undefined') {
	      return function () {
	        vertxNext(flush);
	      };
	    }
	
	    return useSetTimeout();
	  }
	
	  function useMutationObserver() {
	    var iterations = 0;
	    var observer = new BrowserMutationObserver(flush);
	    var node = document.createTextNode('');
	    observer.observe(node, { characterData: true });
	
	    return function () {
	      node.data = iterations = ++iterations % 2;
	    };
	  }
	
	  // web worker
	  function useMessageChannel() {
	    var channel = new MessageChannel();
	    channel.port1.onmessage = flush;
	    return function () {
	      return channel.port2.postMessage(0);
	    };
	  }
	
	  function useSetTimeout() {
	    // Store setTimeout reference so es6-promise will be unaffected by
	    // other code modifying setTimeout (like sinon.useFakeTimers())
	    var globalSetTimeout = setTimeout;
	    return function () {
	      return globalSetTimeout(flush, 1);
	    };
	  }
	
	  var queue = new Array(1000);
	  function flush() {
	    for (var i = 0; i < len; i += 2) {
	      var callback = queue[i];
	      var arg = queue[i + 1];
	
	      callback(arg);
	
	      queue[i] = undefined;
	      queue[i + 1] = undefined;
	    }
	
	    len = 0;
	  }
	
	  function attemptVertx() {
	    try {
	      var r = require;
	      var vertx = __webpack_require__(41);
	      vertxNext = vertx.runOnLoop || vertx.runOnContext;
	      return useVertxTimer();
	    } catch (e) {
	      return useSetTimeout();
	    }
	  }
	
	  var scheduleFlush = undefined;
	  // Decide what async method to use to triggering processing of queued callbacks:
	  if (isNode) {
	    scheduleFlush = useNextTick();
	  } else if (BrowserMutationObserver) {
	    scheduleFlush = useMutationObserver();
	  } else if (isWorker) {
	    scheduleFlush = useMessageChannel();
	  } else if (browserWindow === undefined && "function" === 'function') {
	    scheduleFlush = attemptVertx();
	  } else {
	    scheduleFlush = useSetTimeout();
	  }
	
	  function then(onFulfillment, onRejection) {
	    var _arguments = arguments;
	
	    var parent = this;
	
	    var child = new this.constructor(noop);
	
	    if (child[PROMISE_ID] === undefined) {
	      makePromise(child);
	    }
	
	    var _state = parent._state;
	
	    if (_state) {
	      (function () {
	        var callback = _arguments[_state - 1];
	        asap(function () {
	          return invokeCallback(_state, child, callback, parent._result);
	        });
	      })();
	    } else {
	      subscribe(parent, child, onFulfillment, onRejection);
	    }
	
	    return child;
	  }
	
	  /**
	    `Promise.resolve` returns a promise that will become resolved with the
	    passed `value`. It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      resolve(1);
	    });
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.resolve(1);
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    @method resolve
	    @static
	    @param {Any} value value that the returned promise will be resolved with
	    Useful for tooling.
	    @return {Promise} a promise that will become fulfilled with the given
	    `value`
	  */
	  function resolve$1(object) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
	      return object;
	    }
	
	    var promise = new Constructor(noop);
	    resolve(promise, object);
	    return promise;
	  }
	
	  var PROMISE_ID = Math.random().toString(36).substring(16);
	
	  function noop() {}
	
	  var PENDING = void 0;
	  var FULFILLED = 1;
	  var REJECTED = 2;
	
	  var GET_THEN_ERROR = new ErrorObject();
	
	  function selfFulfillment() {
	    return new TypeError("You cannot resolve a promise with itself");
	  }
	
	  function cannotReturnOwn() {
	    return new TypeError('A promises callback cannot return that same promise.');
	  }
	
	  function getThen(promise) {
	    try {
	      return promise.then;
	    } catch (error) {
	      GET_THEN_ERROR.error = error;
	      return GET_THEN_ERROR;
	    }
	  }
	
	  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
	    try {
	      then$$1.call(value, fulfillmentHandler, rejectionHandler);
	    } catch (e) {
	      return e;
	    }
	  }
	
	  function handleForeignThenable(promise, thenable, then$$1) {
	    asap(function (promise) {
	      var sealed = false;
	      var error = tryThen(then$$1, thenable, function (value) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	        if (thenable !== value) {
	          resolve(promise, value);
	        } else {
	          fulfill(promise, value);
	        }
	      }, function (reason) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	
	        reject(promise, reason);
	      }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	      if (!sealed && error) {
	        sealed = true;
	        reject(promise, error);
	      }
	    }, promise);
	  }
	
	  function handleOwnThenable(promise, thenable) {
	    if (thenable._state === FULFILLED) {
	      fulfill(promise, thenable._result);
	    } else if (thenable._state === REJECTED) {
	      reject(promise, thenable._result);
	    } else {
	      subscribe(thenable, undefined, function (value) {
	        return resolve(promise, value);
	      }, function (reason) {
	        return reject(promise, reason);
	      });
	    }
	  }
	
	  function handleMaybeThenable(promise, maybeThenable, then$$1) {
	    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
	      handleOwnThenable(promise, maybeThenable);
	    } else {
	      if (then$$1 === GET_THEN_ERROR) {
	        reject(promise, GET_THEN_ERROR.error);
	        GET_THEN_ERROR.error = null;
	      } else if (then$$1 === undefined) {
	        fulfill(promise, maybeThenable);
	      } else if (isFunction(then$$1)) {
	        handleForeignThenable(promise, maybeThenable, then$$1);
	      } else {
	        fulfill(promise, maybeThenable);
	      }
	    }
	  }
	
	  function resolve(promise, value) {
	    if (promise === value) {
	      reject(promise, selfFulfillment());
	    } else if (objectOrFunction(value)) {
	      handleMaybeThenable(promise, value, getThen(value));
	    } else {
	      fulfill(promise, value);
	    }
	  }
	
	  function publishRejection(promise) {
	    if (promise._onerror) {
	      promise._onerror(promise._result);
	    }
	
	    publish(promise);
	  }
	
	  function fulfill(promise, value) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	
	    promise._result = value;
	    promise._state = FULFILLED;
	
	    if (promise._subscribers.length !== 0) {
	      asap(publish, promise);
	    }
	  }
	
	  function reject(promise, reason) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	    promise._state = REJECTED;
	    promise._result = reason;
	
	    asap(publishRejection, promise);
	  }
	
	  function subscribe(parent, child, onFulfillment, onRejection) {
	    var _subscribers = parent._subscribers;
	    var length = _subscribers.length;
	
	    parent._onerror = null;
	
	    _subscribers[length] = child;
	    _subscribers[length + FULFILLED] = onFulfillment;
	    _subscribers[length + REJECTED] = onRejection;
	
	    if (length === 0 && parent._state) {
	      asap(publish, parent);
	    }
	  }
	
	  function publish(promise) {
	    var subscribers = promise._subscribers;
	    var settled = promise._state;
	
	    if (subscribers.length === 0) {
	      return;
	    }
	
	    var child = undefined,
	        callback = undefined,
	        detail = promise._result;
	
	    for (var i = 0; i < subscribers.length; i += 3) {
	      child = subscribers[i];
	      callback = subscribers[i + settled];
	
	      if (child) {
	        invokeCallback(settled, child, callback, detail);
	      } else {
	        callback(detail);
	      }
	    }
	
	    promise._subscribers.length = 0;
	  }
	
	  function ErrorObject() {
	    this.error = null;
	  }
	
	  var TRY_CATCH_ERROR = new ErrorObject();
	
	  function tryCatch(callback, detail) {
	    try {
	      return callback(detail);
	    } catch (e) {
	      TRY_CATCH_ERROR.error = e;
	      return TRY_CATCH_ERROR;
	    }
	  }
	
	  function invokeCallback(settled, promise, callback, detail) {
	    var hasCallback = isFunction(callback),
	        value = undefined,
	        error = undefined,
	        succeeded = undefined,
	        failed = undefined;
	
	    if (hasCallback) {
	      value = tryCatch(callback, detail);
	
	      if (value === TRY_CATCH_ERROR) {
	        failed = true;
	        error = value.error;
	        value.error = null;
	      } else {
	        succeeded = true;
	      }
	
	      if (promise === value) {
	        reject(promise, cannotReturnOwn());
	        return;
	      }
	    } else {
	      value = detail;
	      succeeded = true;
	    }
	
	    if (promise._state !== PENDING) {
	      // noop
	    } else if (hasCallback && succeeded) {
	      resolve(promise, value);
	    } else if (failed) {
	      reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      reject(promise, value);
	    }
	  }
	
	  function initializePromise(promise, resolver) {
	    try {
	      resolver(function resolvePromise(value) {
	        resolve(promise, value);
	      }, function rejectPromise(reason) {
	        reject(promise, reason);
	      });
	    } catch (e) {
	      reject(promise, e);
	    }
	  }
	
	  var id = 0;
	  function nextId() {
	    return id++;
	  }
	
	  function makePromise(promise) {
	    promise[PROMISE_ID] = id++;
	    promise._state = undefined;
	    promise._result = undefined;
	    promise._subscribers = [];
	  }
	
	  function Enumerator$1(Constructor, input) {
	    this._instanceConstructor = Constructor;
	    this.promise = new Constructor(noop);
	
	    if (!this.promise[PROMISE_ID]) {
	      makePromise(this.promise);
	    }
	
	    if (isArray(input)) {
	      this.length = input.length;
	      this._remaining = input.length;
	
	      this._result = new Array(this.length);
	
	      if (this.length === 0) {
	        fulfill(this.promise, this._result);
	      } else {
	        this.length = this.length || 0;
	        this._enumerate(input);
	        if (this._remaining === 0) {
	          fulfill(this.promise, this._result);
	        }
	      }
	    } else {
	      reject(this.promise, validationError());
	    }
	  }
	
	  function validationError() {
	    return new Error('Array Methods must be provided an Array');
	  }
	
	  Enumerator$1.prototype._enumerate = function (input) {
	    for (var i = 0; this._state === PENDING && i < input.length; i++) {
	      this._eachEntry(input[i], i);
	    }
	  };
	
	  Enumerator$1.prototype._eachEntry = function (entry, i) {
	    var c = this._instanceConstructor;
	    var resolve$$1 = c.resolve;
	
	    if (resolve$$1 === resolve$1) {
	      var _then = getThen(entry);
	
	      if (_then === then && entry._state !== PENDING) {
	        this._settledAt(entry._state, i, entry._result);
	      } else if (typeof _then !== 'function') {
	        this._remaining--;
	        this._result[i] = entry;
	      } else if (c === Promise$2) {
	        var promise = new c(noop);
	        handleMaybeThenable(promise, entry, _then);
	        this._willSettleAt(promise, i);
	      } else {
	        this._willSettleAt(new c(function (resolve$$1) {
	          return resolve$$1(entry);
	        }), i);
	      }
	    } else {
	      this._willSettleAt(resolve$$1(entry), i);
	    }
	  };
	
	  Enumerator$1.prototype._settledAt = function (state, i, value) {
	    var promise = this.promise;
	
	    if (promise._state === PENDING) {
	      this._remaining--;
	
	      if (state === REJECTED) {
	        reject(promise, value);
	      } else {
	        this._result[i] = value;
	      }
	    }
	
	    if (this._remaining === 0) {
	      fulfill(promise, this._result);
	    }
	  };
	
	  Enumerator$1.prototype._willSettleAt = function (promise, i) {
	    var enumerator = this;
	
	    subscribe(promise, undefined, function (value) {
	      return enumerator._settledAt(FULFILLED, i, value);
	    }, function (reason) {
	      return enumerator._settledAt(REJECTED, i, reason);
	    });
	  };
	
	  /**
	    `Promise.all` accepts an array of promises, and returns a new promise which
	    is fulfilled with an array of fulfillment values for the passed promises, or
	    rejected with the reason of the first passed promise to be rejected. It casts all
	    elements of the passed iterable to promises as it runs this algorithm.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = resolve(2);
	    let promise3 = resolve(3);
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // The array here would be [ 1, 2, 3 ];
	    });
	    ```
	  
	    If any of the `promises` given to `all` are rejected, the first promise
	    that is rejected will be given as an argument to the returned promises's
	    rejection handler. For example:
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = reject(new Error("2"));
	    let promise3 = reject(new Error("3"));
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // Code here never runs because there are rejected promises!
	    }, function(error) {
	      // error.message === "2"
	    });
	    ```
	  
	    @method all
	    @static
	    @param {Array} entries array of promises
	    @param {String} label optional string for labeling the promise.
	    Useful for tooling.
	    @return {Promise} promise that is fulfilled when all `promises` have been
	    fulfilled, or rejected if any of them become rejected.
	    @static
	  */
	  function all$1(entries) {
	    return new Enumerator$1(this, entries).promise;
	  }
	
	  /**
	    `Promise.race` returns a new promise which is settled in the same way as the
	    first passed promise to settle.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 2');
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // result === 'promise 2' because it was resolved before promise1
	      // was resolved.
	    });
	    ```
	  
	    `Promise.race` is deterministic in that only the state of the first
	    settled promise matters. For example, even if other promises given to the
	    `promises` array argument are resolved, but the first settled promise has
	    become rejected before the other promises became fulfilled, the returned
	    promise will become rejected:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        reject(new Error('promise 2'));
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // Code here never runs
	    }, function(reason){
	      // reason.message === 'promise 2' because promise 2 became rejected before
	      // promise 1 became fulfilled
	    });
	    ```
	  
	    An example real-world use case is implementing timeouts:
	  
	    ```javascript
	    Promise.race([ajax('foo.json'), timeout(5000)])
	    ```
	  
	    @method race
	    @static
	    @param {Array} promises array of promises to observe
	    Useful for tooling.
	    @return {Promise} a promise which settles in the same way as the first passed
	    promise to settle.
	  */
	  function race$1(entries) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (!isArray(entries)) {
	      return new Constructor(function (_, reject) {
	        return reject(new TypeError('You must pass an array to race.'));
	      });
	    } else {
	      return new Constructor(function (resolve, reject) {
	        var length = entries.length;
	        for (var i = 0; i < length; i++) {
	          Constructor.resolve(entries[i]).then(resolve, reject);
	        }
	      });
	    }
	  }
	
	  /**
	    `Promise.reject` returns a promise rejected with the passed `reason`.
	    It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      reject(new Error('WHOOPS'));
	    });
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.reject(new Error('WHOOPS'));
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    @method reject
	    @static
	    @param {Any} reason value that the returned promise will be rejected with.
	    Useful for tooling.
	    @return {Promise} a promise rejected with the given `reason`.
	  */
	  function reject$1(reason) {
	    /*jshint validthis:true */
	    var Constructor = this;
	    var promise = new Constructor(noop);
	    reject(promise, reason);
	    return promise;
	  }
	
	  function needsResolver() {
	    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	  }
	
	  function needsNew() {
	    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	  }
	
	  /**
	    Promise objects represent the eventual result of an asynchronous operation. The
	    primary way of interacting with a promise is through its `then` method, which
	    registers callbacks to receive either a promise's eventual value or the reason
	    why the promise cannot be fulfilled.
	  
	    Terminology
	    -----------
	  
	    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	    - `thenable` is an object or function that defines a `then` method.
	    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	    - `exception` is a value that is thrown using the throw statement.
	    - `reason` is a value that indicates why a promise was rejected.
	    - `settled` the final resting state of a promise, fulfilled or rejected.
	  
	    A promise can be in one of three states: pending, fulfilled, or rejected.
	  
	    Promises that are fulfilled have a fulfillment value and are in the fulfilled
	    state.  Promises that are rejected have a rejection reason and are in the
	    rejected state.  A fulfillment value is never a thenable.
	  
	    Promises can also be said to *resolve* a value.  If this value is also a
	    promise, then the original promise's settled state will match the value's
	    settled state.  So a promise that *resolves* a promise that rejects will
	    itself reject, and a promise that *resolves* a promise that fulfills will
	    itself fulfill.
	  
	  
	    Basic Usage:
	    ------------
	  
	    ```js
	    let promise = new Promise(function(resolve, reject) {
	      // on success
	      resolve(value);
	  
	      // on failure
	      reject(reason);
	    });
	  
	    promise.then(function(value) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Advanced Usage:
	    ---------------
	  
	    Promises shine when abstracting away asynchronous interactions such as
	    `XMLHttpRequest`s.
	  
	    ```js
	    function getJSON(url) {
	      return new Promise(function(resolve, reject){
	        let xhr = new XMLHttpRequest();
	  
	        xhr.open('GET', url);
	        xhr.onreadystatechange = handler;
	        xhr.responseType = 'json';
	        xhr.setRequestHeader('Accept', 'application/json');
	        xhr.send();
	  
	        function handler() {
	          if (this.readyState === this.DONE) {
	            if (this.status === 200) {
	              resolve(this.response);
	            } else {
	              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	            }
	          }
	        };
	      });
	    }
	  
	    getJSON('/posts.json').then(function(json) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Unlike callbacks, promises are great composable primitives.
	  
	    ```js
	    Promise.all([
	      getJSON('/posts'),
	      getJSON('/comments')
	    ]).then(function(values){
	      values[0] // => postsJSON
	      values[1] // => commentsJSON
	  
	      return values;
	    });
	    ```
	  
	    @class Promise
	    @param {function} resolver
	    Useful for tooling.
	    @constructor
	  */
	  function Promise$2(resolver) {
	    this[PROMISE_ID] = nextId();
	    this._result = this._state = undefined;
	    this._subscribers = [];
	
	    if (noop !== resolver) {
	      typeof resolver !== 'function' && needsResolver();
	      this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
	    }
	  }
	
	  Promise$2.all = all$1;
	  Promise$2.race = race$1;
	  Promise$2.resolve = resolve$1;
	  Promise$2.reject = reject$1;
	  Promise$2._setScheduler = setScheduler;
	  Promise$2._setAsap = setAsap;
	  Promise$2._asap = asap;
	
	  Promise$2.prototype = {
	    constructor: Promise$2,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	    
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	    
	      Chaining
	      --------
	    
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	    
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	    
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	    
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	    
	      Assimilation
	      ------------
	    
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	    
	      If the assimliated promise rejects, then the downstream promise will also reject.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	    
	      Simple Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let result;
	    
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	    
	      Advanced Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let author, books;
	    
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	    
	      function foundBooks(books) {
	    
	      }
	    
	      function failure(reason) {
	    
	      }
	    
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	    then: then,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	    
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	    
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	    
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	    'catch': function _catch(onRejection) {
	      return this.then(null, onRejection);
	    }
	  };
	
	  /*global self*/
	  function polyfill$1() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	      local = global;
	    } else if (typeof self !== 'undefined') {
	      local = self;
	    } else {
	      try {
	        local = Function('return this')();
	      } catch (e) {
	        throw new Error('polyfill failed because global object is unavailable in this environment');
	      }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	      var promiseToString = null;
	      try {
	        promiseToString = Object.prototype.toString.call(P.resolve());
	      } catch (e) {
	        // silently ignored
	      }
	
	      if (promiseToString === '[object Promise]' && !P.cast) {
	        return;
	      }
	    }
	
	    local.Promise = Promise$2;
	  }
	
	  // Strange compat..
	  Promise$2.polyfill = polyfill$1;
	  Promise$2.Promise = Promise$2;
	
	  return Promise$2;
	});
	
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = inlineHeaders;
	
	var encode = __webpack_require__(43);
	
	function inlineHeaders(url, headers) {
	  if (/\?/.test(url)) {
	    url += '&';
	  } else {
	    url += '?';
	  }
	
	  return url + encode(headers);
	}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return map(objectKeys(obj), function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (isArray(obj[k])) {
	        return map(obj[k], function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};
	
	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	function map(xs, f) {
	  if (xs.map) return xs.map(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    res.push(f(xs[i], i));
	  }
	  return res;
	}
	
	var objectKeys = Object.keys || function (obj) {
	  var res = [];
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
	  }
	  return res;
	};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = jsonpRequest;
	
	var errors = __webpack_require__(19);
	
	var JSONPCounter = 0;
	
	function jsonpRequest(url, opts, cb) {
	  if (opts.method !== 'GET') {
	    cb(new Error('Method ' + opts.method + ' ' + url + ' is not supported by JSONP.'));
	    return;
	  }
	
	  opts.debug('JSONP: start');
	
	  var cbCalled = false;
	  var timedOut = false;
	
	  JSONPCounter += 1;
	  var head = document.getElementsByTagName('head')[0];
	  var script = document.createElement('script');
	  var cbName = 'algoliaJSONP_' + JSONPCounter;
	  var done = false;
	
	  window[cbName] = function (data) {
	    removeGlobals();
	
	    if (timedOut) {
	      opts.debug('JSONP: Late answer, ignoring');
	      return;
	    }
	
	    cbCalled = true;
	
	    clean();
	
	    cb(null, {
	      body: data /* ,
	                 // We do not send the statusCode, there's no statusCode in JSONP, it will be
	                 // computed using data.status && data.message like with XDR
	                 statusCode*/
	    });
	  };
	
	  // add callback by hand
	  url += '&callback=' + cbName;
	
	  // add body params manually
	  if (opts.jsonBody && opts.jsonBody.params) {
	    url += '&' + opts.jsonBody.params;
	  }
	
	  var ontimeout = setTimeout(timeout, opts.timeouts.complete);
	
	  // script onreadystatechange needed only for
	  // <= IE8
	  // https://github.com/angular/angular.js/issues/4523
	  script.onreadystatechange = readystatechange;
	  script.onload = success;
	  script.onerror = error;
	
	  script.async = true;
	  script.defer = true;
	  script.src = url;
	  head.appendChild(script);
	
	  function success() {
	    opts.debug('JSONP: success');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    done = true;
	
	    // script loaded but did not call the fn => script loading error
	    if (!cbCalled) {
	      opts.debug('JSONP: Fail. Script loaded but did not call the callback');
	      clean();
	      cb(new errors.JSONPScriptFail());
	    }
	  }
	
	  function readystatechange() {
	    if (this.readyState === 'loaded' || this.readyState === 'complete') {
	      success();
	    }
	  }
	
	  function clean() {
	    clearTimeout(ontimeout);
	    script.onload = null;
	    script.onreadystatechange = null;
	    script.onerror = null;
	    head.removeChild(script);
	  }
	
	  function removeGlobals() {
	    try {
	      delete window[cbName];
	      delete window[cbName + '_loaded'];
	    } catch (e) {
	      window[cbName] = window[cbName + '_loaded'] = undefined;
	    }
	  }
	
	  function timeout() {
	    opts.debug('JSONP: Script timeout');
	    timedOut = true;
	    clean();
	    cb(new errors.RequestTimeout());
	  }
	
	  function error() {
	    opts.debug('JSONP: Script error');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    clean();
	    cb(new errors.JSONPScriptError());
	  }
	}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = createPlacesClient;
	
	var buildSearchMethod = __webpack_require__(18);
	
	function createPlacesClient(algoliasearch) {
	  return function places(appID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    opts = opts && cloneDeep(opts) || {};
	    opts.hosts = opts.hosts || ['places-dsn.algolia.net', 'places-1.algolianet.com', 'places-2.algolianet.com', 'places-3.algolianet.com'];
	
	    // allow initPlaces() no arguments => community rate limited
	    if (arguments.length === 0 || (typeof appID === 'undefined' ? 'undefined' : _typeof(appID)) === 'object' || appID === undefined) {
	      appID = '';
	      apiKey = '';
	      opts._allowEmptyCredentials = true;
	    }
	
	    var client = algoliasearch(appID, apiKey, opts);
	    var index = client.initIndex('places');
	    index.search = buildSearchMethod('query', '/1/places/query');
	    index.getObject = function (objectID, callback) {
	      return this.as._jsonRequest({
	        method: 'GET',
	        url: '/1/places/' + encodeURIComponent(objectID),
	        hostType: 'read',
	        callback: callback
	      });
	    };
	    return index;
	  };
	}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = getDocumentProtocol;
	
	function getDocumentProtocol() {
	  var protocol = window.document.location.protocol;
	
	  // when in `file:` mode (local html file), default to `http:`
	  if (protocol !== 'http:' && protocol !== 'https:') {
	    protocol = 'http:';
	  }
	
	  return protocol;
	}

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = '3.24.3';

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOWUxODdhYjJlYjk2MjZjOGYzZGMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZXZlbnQtcGFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xL3EuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL2FwcC9wbHVnaW5zL2V4cGxhYWluLXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvYnVpbGRzL2FsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9BbGdvbGlhU2VhcmNoLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhDb3JlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnVpbGRTZWFyY2hNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3JlYWNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Nsb25lLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvb21pdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvbWFwLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZXhpdFByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleEJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaENvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2NyZWF0ZUFsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbG9iYWwvd2luZG93LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvaW5saW5lLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9qc29ucC1yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvcGxhY2VzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9nZXQtZG9jdW1lbnQtcHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy92ZXJzaW9uLmpzIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwiZGVmaW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwibG9nTWV0aG9kcyIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlYWxNZXRob2QiLCJjb25zb2xlIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJsb2dnZXJOYW1lIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJkZWJ1ZyIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIkxvZ2dlciIsIm5hbWUiLCJkZWZhdWx0TGV2ZWwiLCJmYWN0b3J5Iiwic2VsZiIsImN1cnJlbnRMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJ0b1VwcGVyQ2FzZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImlnbm9yZSIsImRvY3VtZW50IiwiY29va2llIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0UGVyc2lzdGVkTGV2ZWwiLCJzdG9yZWRMZXZlbCIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImxldmVscyIsImdldExldmVsIiwic2V0TGV2ZWwiLCJwZXJzaXN0IiwiU0lMRU5UIiwic2V0RGVmYXVsdExldmVsIiwiZW5hYmxlQWxsIiwiVFJBQ0UiLCJkaXNhYmxlQWxsIiwiaW5pdGlhbExldmVsIiwiZGVmYXVsdExvZ2dlciIsIl9sb2dnZXJzQnlOYW1lIiwiZ2V0TG9nZ2VyIiwiVHlwZUVycm9yIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJVc2VySURzIiwibGl2ZSIsIkplcmVteSIsIk1hdHQiLCJDYXJvbCIsIkhhcnJpZXQiLCJKb25ueSIsInN0YWdpbmciLCJsb2NhbCIsImRyaXZlIiwiQUNNRSIsIlVzZXJJRCIsIlBhZ2VSZXN1bHRzIiwiVXNlckNhcmRzIiwiTGFzdFJlZnJlc2giLCJhbGdvbGlhUGFyYW1zIiwiYXBwSUQiLCJhcGlLZXkiLCJpbmRleCIsInVzZSIsImNocm9tZSIsImJyb3dzZXJBY3Rpb24iLCJvbkNsaWNrZWQiLCJhZGRMaXN0ZW5lciIsInRhYiIsInRhYnMiLCJxdWVyeSIsImFjdGl2ZSIsImN1cnJlbnRXaW5kb3ciLCJzZW5kTWVzc2FnZSIsImlkIiwiYWN0aW9uIiwicmVzIiwiaW5mbyIsInJ1bnRpbWUiLCJvbk1lc3NhZ2UiLCJyZXF1ZXN0Iiwic2VuZGVyIiwic2VuZFJlc3BvbnNlIiwidXJsIiwiZ2V0Q3VycmVudFBhZ2VSZXN1bHRzIiwiZGF0YSIsInRoZW4iLCJ0cmFjZSIsImNoZWNrUmVmcmVzaCIsImdldFBhZ2VSZXN1bHRzIiwiYWRkVG9QYWdlUmVzdWx0cyIsImNhdGNoIiwiZXJyb3IiLCJnZXRBbGxVc2VyQ2FyZHMiLCJldmVudCIsInJlc3BvbnNlIiwiZCIsImRlZmVyIiwidGFiSUQiLCJnZXRDdXJyZW50VGFiIiwicmVzb2x2ZSIsImdldFBhZ2VEYXRhIiwicmVqZWN0IiwicHJvbWlzZSIsInBhZ2VEYXRhIiwic2VuZE1lc3NhZ2VUb1RhYiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicGFnZVRhYklEIiwiZmlsdGVyIiwibm93IiwiRGF0ZSIsInNlYXJjaENhcmRzIiwicmVzdWx0cyIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0IiwiX3RvU3RyaW5nIiwidG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwiU3RyaW5nIiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwiYiIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXkiLCJpc0FycmF5QiIsImV2ZXJ5Iiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwid2FybiIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm9wdGlvbnMiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwibWF0Y2giLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJjb25zdHJ1Y3RvciIsInB1c2giLCJoYW5kbGVFcnJvciIsImVyciIsImluQnJvd3NlciIsImhhc1Byb3RvIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwibmV4dFRpY2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwidGltZXJGdW5jIiwibmV4dFRpY2tIYW5kbGVyIiwiY29waWVzIiwiUHJvbWlzZSIsInAiLCJsb2dFcnJvciIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicXVldWVOZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ1aWQiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsInBvcCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsInBhcmVudCIsImNoaWxkIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJ0eXBlIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY2FwdHVyZSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImNoZWNrT3B0aW9uVHlwZSIsIm9wdGlvbiIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5Iiwic291cmNlIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJfY29udGV4dCIsImgiLCJjcmVhdGVFbGVtZW50IiwiaW5qZWN0aW9ucyIsImZ1bmN0aW9uYWxPcHRpb25zIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJzdGF0aWNSZW5kZXJGbnMiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwiY3VycmVudCIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImhvb2tzIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsIm1vZGVsUnMiLCJwYXJzZU1vZGVsIiwiaWR4IiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0Iiwic3Vic3RyaW5nIiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJkeW5hbWljVHlwZSIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJ0YXJnZXQkMSIsImFkZCQxIiwib2xkSGFuZGxlciIsImV2IiwicmVtb3ZlJDIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwiZW5kIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsIk51bWJlciIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwiaXNUZXh0SW5wdXRUeXBlIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJiaW5kaW5nIiwic2V0U2VsZWN0ZWQiLCJfdk9wdGlvbnMiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJzb21lIiwibyIsImlzTXVsdGlwbGUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsInNob3VsZERlY29kZSIsImNvbnRlbnQiLCJlbmNvZGVkIiwiZGl2IiwiaW5uZXJIVE1MIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsImxhc3RJbmRleCIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJtb2R1bGVzJDEiLCJodG1sIiwiZGlyZWN0aXZlcyQxIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYmFzZU9wdGlvbnMiLCJleHBlY3RIVE1MIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwic2luZ2xlQXR0cklkZW50aWZpZXIiLCJzaW5nbGVBdHRyQXNzaWduIiwic2luZ2xlQXR0clZhbHVlcyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5IiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJwYXJzZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImVsZW1lbnQiLCJjb21tZW50cyIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJzcGFjZSIsInVwIiwicmlnaHQiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsInNoaWZ0IiwiYWx0IiwibWV0YSIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJpZGVudFJFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImNyZWF0ZUZ1bmN0aW9uIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJyZWYkMSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsIkl0ZW0iLCJhcnJheSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJib290c3RyYXAiLCJzZXMiLCJvayIsIm1ha2VRIiwicHJldmlvdXNRIiwiUSIsImhhc1N0YWNrcyIsInFTdGFydGluZ0xpbmUiLCJjYXB0dXJlTGluZSIsInFGaWxlTmFtZSIsImhlYWQiLCJ0YXNrIiwidGFpbCIsInJlcXVlc3RUaWNrIiwiaXNOb2RlSlMiLCJsYXRlclF1ZXVlIiwiZmx1c2giLCJkb21haW4iLCJydW5TaW5nbGUiLCJleGl0Iiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJyZXF1ZXN0UG9ydFRpY2siLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwicnVuQWZ0ZXIiLCJ1bmN1cnJ5VGhpcyIsImFycmF5X3NsaWNlIiwiYXJyYXlfcmVkdWNlIiwiYmFzaXMiLCJhcnJheV9pbmRleE9mIiwiYXJyYXlfbWFwIiwidGhpc3AiLCJjb2xsZWN0Iiwib2JqZWN0X2NyZWF0ZSIsIlR5cGUiLCJvYmplY3RfZGVmaW5lUHJvcGVydHkiLCJkZXNjcmlwdG9yIiwib2JqZWN0X2hhc093blByb3BlcnR5Iiwib2JqZWN0X2tleXMiLCJvYmplY3QiLCJvYmplY3RfdG9TdHJpbmciLCJpc1N0b3BJdGVyYXRpb24iLCJleGNlcHRpb24iLCJRUmV0dXJuVmFsdWUiLCJSZXR1cm5WYWx1ZSIsIlNUQUNLX0pVTVBfU0VQQVJBVE9SIiwibWFrZVN0YWNrVHJhY2VMb25nIiwic3RhY2tzIiwiX19taW5pbXVtU3RhY2tDb3VudGVyX18iLCJzdGFja0NvdW50ZXIiLCJjb25jYXRlZFN0YWNrcyIsImZpbHRlclN0YWNrU3RyaW5nIiwic3RhY2tTdHJpbmciLCJsaW5lcyIsImRlc2lyZWRMaW5lcyIsImxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJpc05vZGVGcmFtZSIsInN0YWNrTGluZSIsImdldEZpbGVOYW1lQW5kTGluZU51bWJlciIsImF0dGVtcHQxIiwiYXR0ZW1wdDIiLCJhdHRlbXB0MyIsImZpbGVOYW1lQW5kTGluZU51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsInFFbmRpbmdMaW5lIiwiZmlyc3RMaW5lIiwiZGVwcmVjYXRlIiwiYWx0ZXJuYXRpdmUiLCJpc1Byb21pc2VBbGlrZSIsImNvZXJjZSIsImZ1bGZpbGwiLCJsb25nU3RhY2tTdXBwb3J0IiwibG9uZ1N0YWNrQ291bnRlciIsIlFfREVCVUciLCJtZXNzYWdlcyIsInByb2dyZXNzTGlzdGVuZXJzIiwicmVzb2x2ZWRQcm9taXNlIiwiZGVmZXJyZWQiLCJwcm9taXNlRGlzcGF0Y2giLCJvcCIsIm9wZXJhbmRzIiwidmFsdWVPZiIsIm5lYXJlclZhbHVlIiwibmVhcmVyIiwiaXNQcm9taXNlIiwiaW5zcGVjdCIsImJlY29tZSIsIm5ld1Byb21pc2UiLCJtZXNzYWdlIiwicHJvZ3Jlc3MiLCJwcm9ncmVzc0xpc3RlbmVyIiwibWFrZU5vZGVSZXNvbHZlciIsInJlc29sdmVyIiwicmFjZSIsInBhc3NCeUNvcHkiLCJ4IiwieSIsInRoYXQiLCJzcHJlYWQiLCJhbnN3ZXJQcyIsIm1ha2VQcm9taXNlIiwiaW5zcGVjdGVkIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwcm9ncmVzc2VkIiwiZG9uZSIsIl9mdWxmaWxsZWQiLCJfcmVqZWN0ZWQiLCJuZXdFeGNlcHRpb24iLCJfcHJvZ3Jlc3NlZCIsIm5ld1ZhbHVlIiwidGhyZXciLCJvbmVycm9yIiwidGFwIiwiZmNhbGwiLCJ0aGVuUmVzb2x2ZSIsIndoZW4iLCJ0aGVuUmVqZWN0IiwiaXNQZW5kaW5nIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwidW5oYW5kbGVkUmVhc29ucyIsInVuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXNldFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1JlamVjdGlvbiIsInVudHJhY2tSZWplY3Rpb24iLCJhdCIsImF0UmVwb3J0IiwiZ2V0VW5oYW5kbGVkUmVhc29ucyIsInN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyIsInJlamVjdGlvbiIsInJocyIsIm1hc3RlciIsImRpc3BhdGNoIiwiYXN5bmMiLCJtYWtlR2VuZXJhdG9yIiwiY29udGludWVyIiwidmVyYiIsIlN0b3BJdGVyYXRpb24iLCJnZW5lcmF0b3IiLCJlcnJiYWNrIiwic3Bhd24iLCJfcmV0dXJuIiwicHJvbWlzZWQiLCJtYXBwbHkiLCJwb3N0Iiwic2VuZCIsIm1jYWxsIiwiaW52b2tlIiwiZmFwcGx5IiwiZmJpbmQiLCJmYm91bmQiLCJwcm9taXNlcyIsInBlbmRpbmdDb3VudCIsInNuYXBzaG90IiwiYW55Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsImFsbFJlc29sdmVkIiwiYWxsU2V0dGxlZCIsInJlZ2FyZGxlc3MiLCJmYWlsIiwiZmluIiwib25VbmhhbmRsZWRFcnJvciIsIm1zIiwidGltZW91dElkIiwibmZhcHBseSIsIm5vZGVBcmdzIiwibmZjYWxsIiwibmZiaW5kIiwiZGVub2RlaWZ5IiwiYmFzZUFyZ3MiLCJuYmluZCIsImJvdW5kIiwibm1hcHBseSIsIm5wb3N0IiwibnNlbmQiLCJubWNhbGwiLCJuaW52b2tlIiwibm9kZWlmeSIsIm5vZGViYWNrIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJjbGVhckltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwid2VicGFja1BvbHlmaWxsIiwicGF0aHMiLCJlc2NhcGVSZWdFeHAiLCJTZWFyY2giLCJBbGdvbGlhQ2xpZW50IiwicHJvdG9jb2wiLCJBbGdvbGlhSW5kZXgiLCJpbml0SW5kZXgiLCJhZHZhbmNlZFNlYXJjaCIsInBhcmFtcyIsImNsZWFyQ2FjaGUiLCJzZWFyY2giLCJmZXRjaExpc3RJdGVtQ2FyZHMiLCJoaXRzIiwiZGVzY3JpcHRpb24iLCJzZW50ZW5jZSIsInVzZXJJRCIsInNlYXJjaFRleHQiLCJoaXRzUGVyUGFnZSIsImNhcmRzIiwiY2FyZCIsImxpc3RDYXJkcyIsImxpc3RJdGVtcyIsImdldENhcmQiLCJvYmplY3RJRCIsImdldE9iamVjdCIsImNvbXBvdW5kU2VhcmNoIiwibWF4TGVuZ3RoIiwic2VhcmNoVGV4dEFycmF5IiwibWluIiwiY2VpbCIsInQiLCJyIiwicmVtb3ZlRHVwbGljYXRlcyIsIm9yaWdpbmFsQXJyYXkiLCJvYmpLZXkiLCJ0cmltbWVkQXJyYXkiLCJ2YWx1ZXMiLCJjaGVja1BhZ2VIaXQiLCJib3JpbmdXb3JkcyIsImNvdW50IiwicGFnZVRleHQiLCJjaGVja1BhZ2VSZW1pbmRlciIsInVybFJvb3QiLCJiYXNlVXJsIiwicmVtaW5kZXJzIiwiYWxsVXNlckNhcmRzIiwicGFnZVJlc3VsdHMiLCJwaW5ncyIsIm1lbW9yaWVzIiwiZ21haWxCb3JpbmdQaHJhc2VzIiwicGhyYXNlIiwiYWxsV29yZHMiLCJzY29yZSIsImVudGl0eSIsInJlZyIsInBvaW50cyIsInRyaWdnZXJVUkwiLCJwaW5nIiwiaGlnaGxpZ2h0IiwiQWxnb2xpYVNlYXJjaCIsImNyZWF0ZUFsZ29saWFzZWFyY2giLCJJbmRleCIsImRlcHJlY2F0ZWRNZXNzYWdlIiwiQWxnb2xpYVNlYXJjaENvcmUiLCJpbmhlcml0cyIsImRlbGV0ZUluZGV4IiwiaW5kZXhOYW1lIiwiX2pzb25SZXF1ZXN0IiwiaG9zdFR5cGUiLCJtb3ZlSW5kZXgiLCJzcmNJbmRleE5hbWUiLCJkc3RJbmRleE5hbWUiLCJwb3N0T2JqIiwib3BlcmF0aW9uIiwiZGVzdGluYXRpb24iLCJjb3B5SW5kZXgiLCJnZXRMb2dzIiwib2Zmc2V0IiwiX2dldFNlYXJjaFBhcmFtcyIsImxpc3RJbmRleGVzIiwicGFnZSIsImxpc3RVc2VyS2V5cyIsImxpc3RBcGlLZXlzIiwiZ2V0VXNlcktleUFDTCIsImdldEFwaUtleSIsImRlbGV0ZVVzZXJLZXkiLCJkZWxldGVBcGlLZXkiLCJhZGRVc2VyS2V5IiwiYWNscyIsImFkZEFwaUtleSIsInVzYWdlIiwiYWNsIiwidmFsaWRpdHkiLCJtYXhRdWVyaWVzUGVySVBQZXJIb3VyIiwibWF4SGl0c1BlclF1ZXJ5IiwiaW5kZXhlcyIsInF1ZXJ5UGFyYW1ldGVycyIsInJlZmVyZXJzIiwiYWRkVXNlcktleVdpdGhWYWxpZGl0eSIsInVwZGF0ZVVzZXJLZXkiLCJ1cGRhdGVBcGlLZXkiLCJwdXRPYmoiLCJzdGFydFF1ZXJpZXNCYXRjaCIsInN0YXJ0UXVlcmllc0JhdGNoRGVwcmVjYXRlZCIsIl9iYXRjaCIsImFkZFF1ZXJ5SW5CYXRjaCIsImFkZFF1ZXJ5SW5CYXRjaERlcHJlY2F0ZWQiLCJzZW5kUXVlcmllc0JhdGNoIiwic2VuZFF1ZXJpZXNCYXRjaERlcHJlY2F0ZWQiLCJiYXRjaCIsIm9wZXJhdGlvbnMiLCJyZXF1ZXN0cyIsIm5vdEltcGxlbWVudGVkIiwiZW5hYmxlUmF0ZUxpbWl0Rm9yd2FyZCIsImRpc2FibGVSYXRlTGltaXRGb3J3YXJkIiwidXNlU2VjdXJlZEFQSUtleSIsImRpc2FibGVTZWN1cmVkQVBJS2V5IiwiZ2VuZXJhdGVTZWN1cmVkQXBpS2V5IiwiQWxnb2xpYVNlYXJjaEVycm9yIiwiSW5kZXhDb3JlIiwiZXhpdFByb21pc2UiLCJkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMiLCJhZGRPYmplY3QiLCJpbmRleE9iaiIsImFzIiwiYWRkT2JqZWN0cyIsIm9iamVjdHMiLCJwYXJ0aWFsVXBkYXRlT2JqZWN0IiwicGFydGlhbE9iamVjdCIsImNyZWF0ZUlmTm90RXhpc3RzIiwicGFydGlhbFVwZGF0ZU9iamVjdHMiLCJzYXZlT2JqZWN0Iiwic2F2ZU9iamVjdHMiLCJkZWxldGVPYmplY3QiLCJfcHJvbWlzZSIsImRlbGV0ZU9iamVjdHMiLCJvYmplY3RJRHMiLCJwcmVwYXJlUmVxdWVzdCIsImRlbGV0ZUJ5UXVlcnkiLCJjbGllbnQiLCJhdHRyaWJ1dGVzVG9SZXRyaWV2ZSIsImRpc3RpbmN0Iiwic3RvcE9yRGVsZXRlIiwic2VhcmNoQ29udGVudCIsIm5iSGl0cyIsImdldE9iamVjdElEIiwid2FpdFRhc2siLCJkb0RlbGV0ZUJ5UXVlcnkiLCJkZWxldGVPYmplY3RzQ29udGVudCIsInRhc2tJRCIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwiX3NldFRpbWVvdXQiLCJicm93c2VBbGwiLCJtZXJnZSIsIkluZGV4QnJvd3NlciIsImJyb3dzZUxvb3AiLCJjdXJzb3IiLCJfc3RvcHBlZCIsImJyb3dzZUNhbGxiYWNrIiwiX2Vycm9yIiwiX3Jlc3VsdCIsIl9lbmQiLCJ0dEFkYXB0ZXIiLCJzeW5jQ2IiLCJhc3luY0NiIiwic2VhcmNoRG9uZSIsImJhc2VEZWxheSIsIm1heERlbGF5IiwicmV0cnlMb29wIiwic3RhdHVzIiwic3VjY2Vzc0NiIiwiZmFpbHVyZUNiIiwiY2xlYXJJbmRleCIsImdldFNldHRpbmdzIiwic2VhcmNoU3lub255bXMiLCJzYXZlU3lub255bSIsInN5bm9ueW0iLCJmb3J3YXJkVG9TbGF2ZXMiLCJmb3J3YXJkVG9SZXBsaWNhcyIsImdldFN5bm9ueW0iLCJkZWxldGVTeW5vbnltIiwiY2xlYXJTeW5vbnltcyIsImJhdGNoU3lub255bXMiLCJzeW5vbnltcyIsInJlcGxhY2VFeGlzdGluZ1N5bm9ueW1zIiwic2VhcmNoUnVsZXMiLCJzYXZlUnVsZSIsInJ1bGUiLCJnZXRSdWxlIiwiZGVsZXRlUnVsZSIsImNsZWFyUnVsZXMiLCJiYXRjaFJ1bGVzIiwicnVsZXMiLCJjbGVhckV4aXN0aW5nUnVsZXMiLCJzZXRTZXR0aW5ncyIsInNldHRpbmdzIiwiZGVwcmVjYXRlZEFkZFVzZXJLZXlXaXRoVmFsaWRpdHkiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJidWlsZFNlYXJjaE1ldGhvZCIsImFsZ29saWFzZWFyY2giLCJ0eXBlQWhlYWRBcmdzIiwidHlwZUFoZWFkVmFsdWVPcHRpb24iLCJzaW1pbGFyU2VhcmNoIiwiYnJvd3NlIiwiYnJvd3NlRnJvbSIsInNlYXJjaEZvckZhY2V0VmFsdWVzIiwib21pdCIsImZhY2V0TmFtZSIsImZhY2V0UXVlcnkiLCJmaWx0ZXJlZFBhcmFtcyIsImtleU5hbWUiLCJzZWFyY2hQYXJhbWV0ZXJzIiwic2VhcmNoRmFjZXQiLCJfc2VhcmNoIiwiYWRkaXRpb25hbFVBIiwiZ2V0T2JqZWN0cyIsInF1ZXJ5UGFyYW0iLCJleHRyYVByb3BlcnRpZXMiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImFkZFRvRXJyb3JPYmplY3QiLCJjcmVhdGVDdXN0b21FcnJvciIsIkFsZ29saWFTZWFyY2hDdXN0b21FcnJvciIsIlVucGFyc2FibGVKU09OIiwiUmVxdWVzdFRpbWVvdXQiLCJOZXR3b3JrIiwiSlNPTlBTY3JpcHRGYWlsIiwiSlNPTlBTY3JpcHRFcnJvciIsIlVua25vd24iLCJrIiwiZGVwcmVjYXRlZCIsInByZXZpb3VzVXNhZ2UiLCJuZXdVc2FnZSIsImdpdGh1YkFuY2hvckxpbmsiLCJmb3JlYWNoIiwic291cmNlcyIsImZpbHRlcmVkIiwiZG9GaWx0ZXIiLCJ0b1N0ciIsImlzQXJncyIsImlzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaGFzRG9udEVudW1CdWciLCJoYXNQcm90b0VudW1CdWciLCJkb250RW51bXMiLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSIsImV4Y2x1ZGVkS2V5cyIsIiRjb25zb2xlIiwiJGV4dGVybmFsIiwiJGZyYW1lIiwiJGZyYW1lRWxlbWVudCIsIiRmcmFtZXMiLCIkaW5uZXJIZWlnaHQiLCIkaW5uZXJXaWR0aCIsIiRvdXRlckhlaWdodCIsIiRvdXRlcldpZHRoIiwiJHBhZ2VYT2Zmc2V0IiwiJHBhZ2VZT2Zmc2V0IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJrZXlzU2hpbSIsImlzRnVuY3Rpb24iLCJpc0FyZ3VtZW50cyIsImlzU3RyaW5nIiwidGhlS2V5cyIsInNraXBQcm90byIsInNraXBDb25zdHJ1Y3RvciIsInNoaW0iLCJzaGltT2JqZWN0S2V5cyIsImtleXNXb3Jrc1dpdGhBcmd1bWVudHMiLCJvcmlnaW5hbEtleXMiLCJjYWxsZWUiLCJuZXdBcnIiLCJpdGVtSW5kZXgiLCJFdmVudEVtaXR0ZXIiLCJfY2xlYW4iLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsImlzTnVtYmVyIiwiZXIiLCJpc1VuZGVmaW5lZCIsImxpc3RlbmVyIiwibmV3TGlzdGVuZXIiLCJmaXJlZCIsInBvc2l0aW9uIiwibGlzdGVuZXJDb3VudCIsImV2bGlzdGVuZXIiLCJlbWl0dGVyIiwic3RvcmUiLCJNQVhfQVBJX0tFWV9MRU5HVEgiLCJSRVNFVF9BUFBfREFUQV9USU1FUiIsImFwcGxpY2F0aW9uSUQiLCJfYWxsb3dFbXB0eUNyZWRlbnRpYWxzIiwiaG9zdHMiLCJyZWFkIiwid3JpdGUiLCJfdGltZW91dHMiLCJ0aW1lb3V0cyIsImNvbm5lY3QiLCJfY2hlY2tBcHBJZERhdGEiLCJkZWZhdWx0SG9zdHMiLCJfc2h1ZmZsZVJlc3VsdCIsImhvc3ROdW1iZXIiLCJwcmVwYXJlSG9zdCIsImV4dHJhSGVhZGVycyIsIl9jYWNoZSIsIl91YSIsIl91c2VDYWNoZSIsIl91c2VGYWxsYmFjayIsInVzZUZhbGxiYWNrIiwic2V0RXh0cmFIZWFkZXIiLCJnZXRFeHRyYUhlYWRlciIsInVuc2V0RXh0cmFIZWFkZXIiLCJhZGRBbGdvbGlhQWdlbnQiLCJhbGdvbGlhQWdlbnQiLCJpbml0aWFsT3B0cyIsInJlcXVlc3REZWJ1ZyIsInRyaWVzIiwidXNpbmdGYWxsYmFjayIsImhhc0ZhbGxiYWNrIiwiX3JlcXVlc3QiLCJoZWFkZXJzIiwiX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyIsInNhZmVKU09OU3RyaW5naWZ5IiwiZGVidWdEYXRhIiwiZG9SZXF1ZXN0IiwicmVxdWVzdGVyIiwicmVxT3B0cyIsInN0YXJ0VGltZSIsImNhY2hlSUQiLCJqc29uQm9keSIsIl9nZXRUaW1lb3V0c0ZvclJlcXVlc3QiLCJfc2V0SG9zdEluZGV4QnlUeXBlIiwiY3VycmVudEhvc3QiLCJfZ2V0SG9zdEJ5VHlwZSIsInRyeUZhbGxiYWNrIiwiaHR0cFJlc3BvbnNlIiwic3RhdHVzQ29kZSIsImh0dHBSZXNwb25zZU9rIiwiZW5kVGltZSIsInJlbW92ZUNyZWRlbnRpYWxzIiwiY29udGVudExlbmd0aCIsInJlc3BvbnNlVGV4dCIsInNob3VsZFJldHJ5IiwicmV0cnlSZXF1ZXN0IiwidW5yZWNvdmVyYWJsZUVycm9yIiwicmV0cnlSZXF1ZXN0V2l0aEhpZ2hlclRpbWVvdXQiLCJfaW5jcmVtZW50SG9zdEluZGV4IiwiX2luY3JlbWVudFRpbWVvdXRNdWx0aXBsZXIiLCJva0NiIiwibm9va0NiIiwid2l0aEFQSUtleSIsInVhIiwicmVxdWVzdEhlYWRlcnMiLCJ1c2VyVG9rZW4iLCJzZWN1cml0eVRhZ3MiLCJhZGRUb1JlcXVlc3RIZWFkZXJzIiwicXVlcmllcyIsIkpTT05QUGFyYW1zIiwicHJlcGFyZUpTT05QUGFyYW1zIiwicmVxdWVzdElkIiwic3RyYXRlZ3kiLCJzZXRTZWN1cml0eVRhZ3MiLCJ0YWdzIiwic3RyVGFncyIsIm9yZWRUYWdzIiwic2V0VXNlclRva2VuIiwic2V0UmVxdWVzdFRpbWVvdXQiLCJtaWxsaXNlY29uZHMiLCJzZXRUaW1lb3V0cyIsImdldFRpbWVvdXRzIiwiX2dldEFwcElkRGF0YSIsIl9jYWNoZUFwcElkRGF0YSIsIl9zZXRBcHBJZERhdGEiLCJsYXN0Q2hhbmdlIiwiZ2V0VGltZSIsIl9yZXNldEluaXRpYWxBcHBJZERhdGEiLCJob3N0SW5kZXhlcyIsInRpbWVvdXRNdWx0aXBsaWVyIiwic2h1ZmZsZVJlc3VsdCIsInNodWZmbGUiLCJfaG9zdEluZGV4ZXMiLCJfdGltZW91dE11bHRpcGxpZXIiLCJfcGFydGlhbEFwcElkRGF0YVVwZGF0ZSIsImN1cnJlbnREYXRhIiwiX2dldEhvc3RJbmRleEJ5VHlwZSIsIl9nZXRUaW1lb3V0TXVsdGlwbGllciIsImhvc3RJbmRleCIsIm5ld0hvc3RJbmRleGVzIiwiY29tcGxldGUiLCJwcmVwYXJlIiwiaG9zdCIsInRvSlNPTiIsIm91dCIsImN1cnJlbnRJbmRleCIsInRlbXBvcmFyeVZhbHVlIiwicmFuZG9tSW5kZXgiLCJuZXdIZWFkZXJzIiwiaGVhZGVyTmFtZSIsImxvY2FsU3RvcmFnZU5hbWVzcGFjZSIsIm1vZHVsZVN0b3JlIiwibG9jYWxTdG9yYWdlU3RvcmUiLCJsb2NhbFN0b3JhZ2VGYWlsdXJlIiwiY2xlYW51cCIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwiZ2V0T3JTZXQiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsInRhYmxlIiwiJDEiLCJmb3JtYXR0ZXJzIiwiaHVtYW5pemUiLCJkaWZmIiwiY29sb3IiLCJsYXN0QyIsIm5hbWVzcGFjZXMiLCJERUJVRyIsImVuYWJsZSIsImNyZWF0ZURlYnVnIiwiZGlzYWJsZSIsImVuYWJsZWQiLCJuYW1lcyIsInNraXBzIiwicHJldlRpbWUiLCJzZWxlY3RDb2xvciIsImFicyIsImN1cnIiLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJsb2dGbiIsInN1YnN0ciIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJyb3VuZCIsInBsdXJhbCIsInVhU3VmZml4IiwiaW5saW5lSGVhZGVycyIsImpzb25wUmVxdWVzdCIsInBsYWNlcyIsImNsb25lRGVlcCIsImdldERvY3VtZW50UHJvdG9jb2wiLCJBbGdvbGlhU2VhcmNoQnJvd3NlciIsImluaXRQbGFjZXMiLCJfX2FsZ29saWEiLCJzdXBwb3J0IiwiaGFzWE1MSHR0cFJlcXVlc3QiLCJoYXNYRG9tYWluUmVxdWVzdCIsImNvcnMiLCJYTUxIdHRwUmVxdWVzdCIsIndyYXBSZXF1ZXN0IiwicmVxIiwiWERvbWFpblJlcXVlc3QiLCJyZXFUaW1lb3V0IiwidGltZWRPdXQiLCJjb25uZWN0ZWQiLCJvbnByb2dyZXNzIiwib25SZWFkeVN0YXRlQ2hhbmdlIiwib25sb2FkIiwib25Mb2FkIiwib25FcnJvciIsInNldFJlcXVlc3RIZWFkZXIiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJtb3JlIiwiYWJvcnQiLCJvbkNvbm5lY3QiLCJyZWFkeVN0YXRlIiwicmVxdWVzdEZhbGxiYWNrIiwid3JhcEpzb25wUmVxdWVzdCIsImpzb25wUmVxdWVzdERvbmUiLCJyZWplY3RQcm9taXNlIiwicmVzb2x2ZVByb21pc2UiLCJkZWxheVByb21pc2UiLCJyZXNvbHZlT25UaW1lb3V0Iiwid2luIiwiRVM2UHJvbWlzZSIsIm9iamVjdE9yRnVuY3Rpb24iLCJfaXNBcnJheSIsInZlcnR4TmV4dCIsImN1c3RvbVNjaGVkdWxlckZuIiwiYXNhcCIsInNjaGVkdWxlRmx1c2giLCJzZXRTY2hlZHVsZXIiLCJzY2hlZHVsZUZuIiwic2V0QXNhcCIsImFzYXBGbiIsImJyb3dzZXJXaW5kb3ciLCJicm93c2VyR2xvYmFsIiwiQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiaXNOb2RlIiwiaXNXb3JrZXIiLCJVaW50OENsYW1wZWRBcnJheSIsInVzZU5leHRUaWNrIiwidXNlVmVydHhUaW1lciIsInVzZVNldFRpbWVvdXQiLCJ1c2VNdXRhdGlvbk9ic2VydmVyIiwiaXRlcmF0aW9ucyIsInVzZU1lc3NhZ2VDaGFubmVsIiwiZ2xvYmFsU2V0VGltZW91dCIsImF0dGVtcHRWZXJ0eCIsInZlcnR4IiwicnVuT25Mb29wIiwicnVuT25Db250ZXh0Iiwib25GdWxmaWxsbWVudCIsIm9uUmVqZWN0aW9uIiwiX2FyZ3VtZW50cyIsIlBST01JU0VfSUQiLCJfc3RhdGUiLCJpbnZva2VDYWxsYmFjayIsInN1YnNjcmliZSIsInJlc29sdmUkMSIsIkNvbnN0cnVjdG9yIiwiUEVORElORyIsIkZVTEZJTExFRCIsIlJFSkVDVEVEIiwiR0VUX1RIRU5fRVJST1IiLCJFcnJvck9iamVjdCIsInNlbGZGdWxmaWxsbWVudCIsImNhbm5vdFJldHVybk93biIsImdldFRoZW4iLCJ0cnlUaGVuIiwidGhlbiQkMSIsImZ1bGZpbGxtZW50SGFuZGxlciIsInJlamVjdGlvbkhhbmRsZXIiLCJoYW5kbGVGb3JlaWduVGhlbmFibGUiLCJ0aGVuYWJsZSIsIl9sYWJlbCIsImhhbmRsZU93blRoZW5hYmxlIiwiaGFuZGxlTWF5YmVUaGVuYWJsZSIsIm1heWJlVGhlbmFibGUiLCJwdWJsaXNoUmVqZWN0aW9uIiwiX29uZXJyb3IiLCJwdWJsaXNoIiwiX3N1YnNjcmliZXJzIiwic3Vic2NyaWJlcnMiLCJzZXR0bGVkIiwiZGV0YWlsIiwiVFJZX0NBVENIX0VSUk9SIiwidHJ5Q2F0Y2giLCJoYXNDYWxsYmFjayIsInN1Y2NlZWRlZCIsImZhaWxlZCIsImluaXRpYWxpemVQcm9taXNlIiwibmV4dElkIiwiRW51bWVyYXRvciQxIiwiaW5wdXQiLCJfaW5zdGFuY2VDb25zdHJ1Y3RvciIsIl9yZW1haW5pbmciLCJfZW51bWVyYXRlIiwidmFsaWRhdGlvbkVycm9yIiwiX2VhY2hFbnRyeSIsImVudHJ5IiwicmVzb2x2ZSQkMSIsIl90aGVuIiwiX3NldHRsZWRBdCIsIlByb21pc2UkMiIsIl93aWxsU2V0dGxlQXQiLCJlbnVtZXJhdG9yIiwiYWxsJDEiLCJlbnRyaWVzIiwicmFjZSQxIiwicmVqZWN0JDEiLCJuZWVkc1Jlc29sdmVyIiwibmVlZHNOZXciLCJfc2V0U2NoZWR1bGVyIiwiX3NldEFzYXAiLCJfYXNhcCIsIl9jYXRjaCIsInBvbHlmaWxsJDEiLCJQIiwicHJvbWlzZVRvU3RyaW5nIiwiY2FzdCIsInBvbHlmaWxsIiwiZW5jb2RlIiwic3RyaW5naWZ5UHJpbWl0aXZlIiwic2VwIiwiZXEiLCJvYmplY3RLZXlzIiwia3MiLCJ4cyIsIkpTT05QQ291bnRlciIsImNiQ2FsbGVkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjYk5hbWUiLCJyZW1vdmVHbG9iYWxzIiwiY2xlYW4iLCJvbnRpbWVvdXQiLCJyZWFkeXN0YXRlY2hhbmdlIiwiY3JlYXRlUGxhY2VzQ2xpZW50Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENBOzs7Ozs7QUFNQyxZQUFVQSxJQUFWLEVBQWdCQyxVQUFoQixFQUE0QjtBQUN6Qjs7QUFDQSxTQUFJLElBQUosRUFBZ0Q7QUFDNUNDLFNBQUEsb0NBQU9ELFVBQVA7QUFDSCxNQUZELE1BRU8sSUFBSSxRQUFPRSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCQSxPQUFPQyxPQUF6QyxFQUFrRDtBQUNyREQsZ0JBQU9DLE9BQVAsR0FBaUJILFlBQWpCO0FBQ0gsTUFGTSxNQUVBO0FBQ0hELGNBQUtLLEdBQUwsR0FBV0osWUFBWDtBQUNIO0FBQ0osRUFUQSxhQVNPLFlBQVk7QUFDaEI7O0FBRUE7O0FBQ0EsU0FBSUssT0FBTyxTQUFQQSxJQUFPLEdBQVcsQ0FBRSxDQUF4QjtBQUNBLFNBQUlDLGdCQUFnQixXQUFwQjs7QUFFQSxTQUFJQyxhQUFhLENBQ2IsT0FEYSxFQUViLE9BRmEsRUFHYixNQUhhLEVBSWIsTUFKYSxFQUtiLE9BTGEsQ0FBakI7O0FBUUE7QUFDQSxjQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUF5QkMsVUFBekIsRUFBcUM7QUFDakMsYUFBSUMsU0FBU0YsSUFBSUMsVUFBSixDQUFiO0FBQ0EsYUFBSSxPQUFPQyxPQUFPQyxJQUFkLEtBQXVCLFVBQTNCLEVBQXVDO0FBQ25DLG9CQUFPRCxPQUFPQyxJQUFQLENBQVlILEdBQVosQ0FBUDtBQUNILFVBRkQsTUFFTztBQUNILGlCQUFJO0FBQ0Esd0JBQU9JLFNBQVNDLFNBQVQsQ0FBbUJGLElBQW5CLENBQXdCRyxJQUF4QixDQUE2QkosTUFBN0IsRUFBcUNGLEdBQXJDLENBQVA7QUFDSCxjQUZELENBRUUsT0FBT08sQ0FBUCxFQUFVO0FBQ1I7QUFDQSx3QkFBTyxZQUFXO0FBQ2QsNEJBQU9ILFNBQVNDLFNBQVQsQ0FBbUJHLEtBQW5CLENBQXlCQSxLQUF6QixDQUErQk4sTUFBL0IsRUFBdUMsQ0FBQ0YsR0FBRCxFQUFNUyxTQUFOLENBQXZDLENBQVA7QUFDSCxrQkFGRDtBQUdIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0EsY0FBU0MsVUFBVCxDQUFvQlQsVUFBcEIsRUFBZ0M7QUFDNUIsYUFBSUEsZUFBZSxPQUFuQixFQUE0QjtBQUN4QkEsMEJBQWEsS0FBYjtBQUNIOztBQUVELGFBQUksUUFBT1UsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQmQsYUFBdkIsRUFBc0M7QUFDbEMsb0JBQU8sS0FBUCxDQURrQyxDQUNwQjtBQUNqQixVQUZELE1BRU8sSUFBSWMsUUFBUVYsVUFBUixNQUF3QlcsU0FBNUIsRUFBdUM7QUFDMUMsb0JBQU9iLFdBQVdZLE9BQVgsRUFBb0JWLFVBQXBCLENBQVA7QUFDSCxVQUZNLE1BRUEsSUFBSVUsUUFBUWhCLEdBQVIsS0FBZ0JpQixTQUFwQixFQUErQjtBQUNsQyxvQkFBT2IsV0FBV1ksT0FBWCxFQUFvQixLQUFwQixDQUFQO0FBQ0gsVUFGTSxNQUVBO0FBQ0gsb0JBQU9mLElBQVA7QUFDSDtBQUNKOztBQUVEOztBQUVBLGNBQVNpQixxQkFBVCxDQUErQkMsS0FBL0IsRUFBc0NDLFVBQXRDLEVBQWtEO0FBQzlDO0FBQ0EsY0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlsQixXQUFXbUIsTUFBL0IsRUFBdUNELEdBQXZDLEVBQTRDO0FBQ3hDLGlCQUFJZixhQUFhSCxXQUFXa0IsQ0FBWCxDQUFqQjtBQUNBLGtCQUFLZixVQUFMLElBQW9CZSxJQUFJRixLQUFMLEdBQ2ZsQixJQURlLEdBRWYsS0FBS3NCLGFBQUwsQ0FBbUJqQixVQUFuQixFQUErQmEsS0FBL0IsRUFBc0NDLFVBQXRDLENBRko7QUFHSDs7QUFFRDtBQUNBLGNBQUtwQixHQUFMLEdBQVcsS0FBS3dCLEtBQWhCO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLGNBQVNDLCtCQUFULENBQXlDbkIsVUFBekMsRUFBcURhLEtBQXJELEVBQTREQyxVQUE1RCxFQUF3RTtBQUNwRSxnQkFBTyxZQUFZO0FBQ2YsaUJBQUksUUFBT0osT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQmQsYUFBdkIsRUFBc0M7QUFDbENnQix1Q0FBc0JQLElBQXRCLENBQTJCLElBQTNCLEVBQWlDUSxLQUFqQyxFQUF3Q0MsVUFBeEM7QUFDQSxzQkFBS2QsVUFBTCxFQUFpQk8sS0FBakIsQ0FBdUIsSUFBdkIsRUFBNkJDLFNBQTdCO0FBQ0g7QUFDSixVQUxEO0FBTUg7O0FBRUQ7QUFDQTtBQUNBLGNBQVNZLG9CQUFULENBQThCcEIsVUFBOUIsRUFBMENhLEtBQTFDLEVBQWlEQyxVQUFqRCxFQUE2RDtBQUN6RDtBQUNBLGdCQUFPTCxXQUFXVCxVQUFYLEtBQ0FtQixnQ0FBZ0NaLEtBQWhDLENBQXNDLElBQXRDLEVBQTRDQyxTQUE1QyxDQURQO0FBRUg7O0FBRUQsY0FBU2EsTUFBVCxDQUFnQkMsSUFBaEIsRUFBc0JDLFlBQXRCLEVBQW9DQyxPQUFwQyxFQUE2QztBQUMzQyxhQUFJQyxPQUFPLElBQVg7QUFDQSxhQUFJQyxZQUFKO0FBQ0EsYUFBSUMsYUFBYSxVQUFqQjtBQUNBLGFBQUlMLElBQUosRUFBVTtBQUNSSywyQkFBYyxNQUFNTCxJQUFwQjtBQUNEOztBQUVELGtCQUFTTSxzQkFBVCxDQUFnQ0MsUUFBaEMsRUFBMEM7QUFDdEMsaUJBQUlDLFlBQVksQ0FBQ2pDLFdBQVdnQyxRQUFYLEtBQXdCLFFBQXpCLEVBQW1DRSxXQUFuQyxFQUFoQjs7QUFFQSxpQkFBSSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCcEMsYUFBdEIsRUFBcUM7O0FBRXJDO0FBQ0EsaUJBQUk7QUFDQW9DLHdCQUFPQyxZQUFQLENBQW9CTixVQUFwQixJQUFrQ0csU0FBbEM7QUFDQTtBQUNILGNBSEQsQ0FHRSxPQUFPSSxNQUFQLEVBQWUsQ0FBRTs7QUFFbkI7QUFDQSxpQkFBSTtBQUNBRix3QkFBT0csUUFBUCxDQUFnQkMsTUFBaEIsR0FDRUMsbUJBQW1CVixVQUFuQixJQUFpQyxHQUFqQyxHQUF1Q0csU0FBdkMsR0FBbUQsR0FEckQ7QUFFSCxjQUhELENBR0UsT0FBT0ksTUFBUCxFQUFlLENBQUU7QUFDdEI7O0FBRUQsa0JBQVNJLGlCQUFULEdBQTZCO0FBQ3pCLGlCQUFJQyxXQUFKOztBQUVBLGlCQUFJLFFBQU9QLE1BQVAseUNBQU9BLE1BQVAsT0FBa0JwQyxhQUF0QixFQUFxQzs7QUFFckMsaUJBQUk7QUFDQTJDLCtCQUFjUCxPQUFPQyxZQUFQLENBQW9CTixVQUFwQixDQUFkO0FBQ0gsY0FGRCxDQUVFLE9BQU9PLE1BQVAsRUFBZSxDQUFFOztBQUVuQjtBQUNBLGlCQUFJLFFBQU9LLFdBQVAseUNBQU9BLFdBQVAsT0FBdUIzQyxhQUEzQixFQUEwQztBQUN0QyxxQkFBSTtBQUNBLHlCQUFJd0MsU0FBU0osT0FBT0csUUFBUCxDQUFnQkMsTUFBN0I7QUFDQSx5QkFBSUksV0FBV0osT0FBT0ssT0FBUCxDQUNYSixtQkFBbUJWLFVBQW5CLElBQWlDLEdBRHRCLENBQWY7QUFFQSx5QkFBSWEsUUFBSixFQUFjO0FBQ1ZELHVDQUFjLFdBQVdHLElBQVgsQ0FBZ0JOLE9BQU9PLEtBQVAsQ0FBYUgsUUFBYixDQUFoQixFQUF3QyxDQUF4QyxDQUFkO0FBQ0g7QUFDSixrQkFQRCxDQU9FLE9BQU9OLE1BQVAsRUFBZSxDQUFFO0FBQ3RCOztBQUVEO0FBQ0EsaUJBQUlULEtBQUttQixNQUFMLENBQVlMLFdBQVosTUFBNkI1QixTQUFqQyxFQUE0QztBQUN4QzRCLCtCQUFjNUIsU0FBZDtBQUNIOztBQUVELG9CQUFPNEIsV0FBUDtBQUNIOztBQUVEOzs7Ozs7QUFNQWQsY0FBS21CLE1BQUwsR0FBYyxFQUFFLFNBQVMsQ0FBWCxFQUFjLFNBQVMsQ0FBdkIsRUFBMEIsUUFBUSxDQUFsQyxFQUFxQyxRQUFRLENBQTdDO0FBQ1Ysc0JBQVMsQ0FEQyxFQUNFLFVBQVUsQ0FEWixFQUFkOztBQUdBbkIsY0FBS1IsYUFBTCxHQUFxQk8sV0FBV0osb0JBQWhDOztBQUVBSyxjQUFLb0IsUUFBTCxHQUFnQixZQUFZO0FBQ3hCLG9CQUFPbkIsWUFBUDtBQUNILFVBRkQ7O0FBSUFELGNBQUtxQixRQUFMLEdBQWdCLFVBQVVqQyxLQUFWLEVBQWlCa0MsT0FBakIsRUFBMEI7QUFDdEMsaUJBQUksT0FBT2xDLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJZLEtBQUttQixNQUFMLENBQVkvQixNQUFNa0IsV0FBTixFQUFaLE1BQXFDcEIsU0FBdEUsRUFBaUY7QUFDN0VFLHlCQUFRWSxLQUFLbUIsTUFBTCxDQUFZL0IsTUFBTWtCLFdBQU4sRUFBWixDQUFSO0FBQ0g7QUFDRCxpQkFBSSxPQUFPbEIsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsU0FBUyxDQUF0QyxJQUEyQ0EsU0FBU1ksS0FBS21CLE1BQUwsQ0FBWUksTUFBcEUsRUFBNEU7QUFDeEV0QixnQ0FBZWIsS0FBZjtBQUNBLHFCQUFJa0MsWUFBWSxLQUFoQixFQUF1QjtBQUFHO0FBQ3RCbkIsNENBQXVCZixLQUF2QjtBQUNIO0FBQ0RELHVDQUFzQlAsSUFBdEIsQ0FBMkJvQixJQUEzQixFQUFpQ1osS0FBakMsRUFBd0NTLElBQXhDO0FBQ0EscUJBQUksUUFBT1osT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQmQsYUFBbkIsSUFBb0NpQixRQUFRWSxLQUFLbUIsTUFBTCxDQUFZSSxNQUE1RCxFQUFvRTtBQUNoRSw0QkFBTyxrQ0FBUDtBQUNIO0FBQ0osY0FURCxNQVNPO0FBQ0gsdUJBQU0sK0NBQStDbkMsS0FBckQ7QUFDSDtBQUNKLFVBaEJEOztBQWtCQVksY0FBS3dCLGVBQUwsR0FBdUIsVUFBVXBDLEtBQVYsRUFBaUI7QUFDcEMsaUJBQUksQ0FBQ3lCLG1CQUFMLEVBQTBCO0FBQ3RCYixzQkFBS3FCLFFBQUwsQ0FBY2pDLEtBQWQsRUFBcUIsS0FBckI7QUFDSDtBQUNKLFVBSkQ7O0FBTUFZLGNBQUt5QixTQUFMLEdBQWlCLFVBQVNILE9BQVQsRUFBa0I7QUFDL0J0QixrQkFBS3FCLFFBQUwsQ0FBY3JCLEtBQUttQixNQUFMLENBQVlPLEtBQTFCLEVBQWlDSixPQUFqQztBQUNILFVBRkQ7O0FBSUF0QixjQUFLMkIsVUFBTCxHQUFrQixVQUFTTCxPQUFULEVBQWtCO0FBQ2hDdEIsa0JBQUtxQixRQUFMLENBQWNyQixLQUFLbUIsTUFBTCxDQUFZSSxNQUExQixFQUFrQ0QsT0FBbEM7QUFDSCxVQUZEOztBQUlBO0FBQ0EsYUFBSU0sZUFBZWYsbUJBQW5CO0FBQ0EsYUFBSWUsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3RCQSw0QkFBZTlCLGdCQUFnQixJQUFoQixHQUF1QixNQUF2QixHQUFnQ0EsWUFBL0M7QUFDSDtBQUNERSxjQUFLcUIsUUFBTCxDQUFjTyxZQUFkLEVBQTRCLEtBQTVCO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQUlDLGdCQUFnQixJQUFJakMsTUFBSixFQUFwQjs7QUFFQSxTQUFJa0MsaUJBQWlCLEVBQXJCO0FBQ0FELG1CQUFjRSxTQUFkLEdBQTBCLFNBQVNBLFNBQVQsQ0FBbUJsQyxJQUFuQixFQUF5QjtBQUMvQyxhQUFJLE9BQU9BLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEJBLFNBQVMsRUFBekMsRUFBNkM7QUFDM0MsbUJBQU0sSUFBSW1DLFNBQUosQ0FBYyxnREFBZCxDQUFOO0FBQ0Q7O0FBRUQsYUFBSUMsU0FBU0gsZUFBZWpDLElBQWYsQ0FBYjtBQUNBLGFBQUksQ0FBQ29DLE1BQUwsRUFBYTtBQUNYQSxzQkFBU0gsZUFBZWpDLElBQWYsSUFBdUIsSUFBSUQsTUFBSixDQUM5QkMsSUFEOEIsRUFDeEJnQyxjQUFjVCxRQUFkLEVBRHdCLEVBQ0VTLGNBQWNyQyxhQURoQixDQUFoQztBQUVEO0FBQ0QsZ0JBQU95QyxNQUFQO0FBQ0gsTUFYRDs7QUFhQTtBQUNBLFNBQUlDLE9BQVEsUUFBTzNCLE1BQVAseUNBQU9BLE1BQVAsT0FBa0JwQyxhQUFuQixHQUFvQ29DLE9BQU90QyxHQUEzQyxHQUFpRGlCLFNBQTVEO0FBQ0EyQyxtQkFBY00sVUFBZCxHQUEyQixZQUFXO0FBQ2xDLGFBQUksUUFBTzVCLE1BQVAseUNBQU9BLE1BQVAsT0FBa0JwQyxhQUFsQixJQUNHb0MsT0FBT3RDLEdBQVAsS0FBZTRELGFBRHRCLEVBQ3FDO0FBQ2pDdEIsb0JBQU90QyxHQUFQLEdBQWFpRSxJQUFiO0FBQ0g7O0FBRUQsZ0JBQU9MLGFBQVA7QUFDSCxNQVBEOztBQVNBLFlBQU9BLGFBQVA7QUFDSCxFQTdPQSxDQUFELEM7Ozs7Ozs7O0FDTkE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQUVBLG9CQUFJUixRQUFKLENBQWEsT0FBYjs7QUFFQSxLQUFNZSxVQUFVO0FBQ2RDLFNBQU07QUFDSkMsYUFBUSxrQkFESjtBQUVKQyxXQUFNLGtCQUZGO0FBR0pDLFlBQU8sa0JBSEg7QUFJSkMsY0FBUyxrQkFKTDtBQUtKQyxZQUFPO0FBTEgsSUFEUTtBQVFkQyxZQUFTO0FBQ1BMLGFBQVEsa0JBREQ7QUFFUEMsV0FBTTtBQUZDLElBUks7QUFZZEssVUFBTztBQUNMTixhQUFRLGtCQURIO0FBRUxDLFdBQU07QUFGRCxJQVpPO0FBZ0JkTSxVQUFPO0FBQ0xQLGFBQVEsdUJBREg7QUFFTFEsV0FBTTtBQUZEO0FBaEJPLEVBQWhCOztBQXNCQSxLQUFNQyxTQUFTWCxRQUFRQyxJQUFSLENBQWFTLElBQTVCO0FBQ0EsS0FBSUUsY0FBYyxFQUFsQjtBQUNBLEtBQUlDLFlBQVksRUFBaEI7QUFDQSxLQUFJQyxjQUFjLENBQWxCOztBQUVBLEtBQU1DLGdCQUFnQixFQUFFO0FBQ3RCQyxVQUFPLFlBRGE7QUFFcEJDLFdBQVEsa0NBRlk7QUFHcEJDLFVBQU87QUFIYSxFQUF0QjtBQUtBLGVBQUlDLEdBQUosMkJBQXdCSixhQUF4Qjs7QUFFQUssUUFBT0MsYUFBUCxDQUFxQkMsU0FBckIsQ0FBK0JDLFdBQS9CLENBQTJDLFVBQVNDLEdBQVQsRUFBYztBQUN2REosVUFBT0ssSUFBUCxDQUFZQyxLQUFaLENBQWtCLEVBQUNDLFFBQVEsSUFBVCxFQUFlQyxlQUFlLElBQTlCLEVBQWxCLEVBQXVELFVBQVNILElBQVQsRUFBYztBQUNuRUwsWUFBT0ssSUFBUCxDQUFZSSxXQUFaLENBQXdCSixLQUFLLENBQUwsRUFBUUssRUFBaEMsRUFBb0MsRUFBQ0MsUUFBUSxjQUFULEVBQXBDLEVBQThELFVBQVNDLEdBQVQsRUFBYztBQUMxRSwwQkFBSUMsSUFBSixDQUFTRCxHQUFUO0FBQ0QsTUFGRDtBQUdELElBSkQ7QUFLRCxFQU5EOztBQVFBWixRQUFPYyxPQUFQLENBQWVDLFNBQWYsQ0FBeUJaLFdBQXpCLENBQXFDLFVBQVNhLE9BQVQsRUFBa0JDLE1BQWxCLEVBQTBCQyxZQUExQixFQUF3QztBQUMzRSxPQUFJO0FBQ0Ysd0JBQUlqRixLQUFKLENBQVdnRixPQUFPYixHQUFQLEdBQWEsNEJBQTRCYSxPQUFPYixHQUFQLENBQVdlLEdBQXBELEdBQTBELG9CQUFyRSxFQUE0RkgsT0FBNUY7O0FBRUEsU0FBR0EsUUFBUUwsTUFBUixJQUFrQixnQkFBckIsRUFBc0M7QUFDcENTLDZCQUFzQkosUUFBUUssSUFBOUIsRUFDQ0MsSUFERCxDQUNNLFVBQVNWLEdBQVQsRUFBYztBQUNsQiw0QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQU0sc0JBQWFOLEdBQWI7QUFDRCxRQUpEO0FBS0EsY0FBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFJSSxRQUFRTCxNQUFSLElBQWtCLFdBQXRCLEVBQW1DO0FBQ2pDLDBCQUFJWSxLQUFKLENBQVVQLFFBQVFLLElBQWxCO0FBQ0FHLHNCQUNDRixJQURELENBQ00sWUFBVztBQUNmLGdCQUFPLHlCQUFlRyxjQUFmLENBQThCbEMsTUFBOUIsRUFBc0N5QixRQUFRSyxJQUE5QyxFQUFvRDVCLFNBQXBELENBQVA7QUFDRCxRQUhELEVBR0c2QixJQUhILENBR1EsVUFBU1YsR0FBVCxFQUFjO0FBQ3BCYywwQkFBaUJULE9BQU9iLEdBQVAsQ0FBV00sRUFBNUIsRUFBZ0NFLEdBQWhDO0FBQ0FwQix1QkFBY29CLEdBQWQ7QUFDQU0sc0JBQWFOLEdBQWI7QUFDRCxRQVBELEVBT0dlLEtBUEgsQ0FPUyxVQUFTdEcsQ0FBVCxFQUFZO0FBQ25CLDRCQUFJdUcsS0FBSixDQUFVdkcsQ0FBVjtBQUNELFFBVEQ7QUFVQSxjQUFPLElBQVA7QUFDRDtBQUNELFNBQUcyRixRQUFRTCxNQUFSLElBQWtCLFNBQXJCLEVBQStCO0FBQzdCTyxvQkFBYTNCLE1BQWI7QUFDQSxjQUFPLElBQVA7QUFDRDtBQUNELFNBQUd5QixRQUFRTCxNQUFSLElBQWtCLGNBQXJCLEVBQW9DO0FBQ2xDa0I7QUFDQSxjQUFPLElBQVA7QUFDRDtBQUNELFNBQUdiLFFBQVFjLEtBQVIsSUFBaUIsYUFBcEIsRUFBa0M7QUFDaEM5QixjQUFPSyxJQUFQLENBQVlDLEtBQVosQ0FBa0IsRUFBQ0MsUUFBUSxJQUFULEVBQWVDLGVBQWUsSUFBOUIsRUFBbEIsRUFBdUQsVUFBU0gsSUFBVCxFQUFjO0FBQ25FTCxnQkFBT0ssSUFBUCxDQUFZSSxXQUFaLENBQXdCSixLQUFLLENBQUwsRUFBUUssRUFBaEMsRUFBb0MsRUFBQ29CLE9BQU8sYUFBUixFQUFwQyxFQUE0RCxVQUFTQyxRQUFULEVBQW1CLENBQUUsQ0FBakY7QUFDRCxRQUZEO0FBR0EsY0FBTyxJQUFQO0FBQ0Q7QUFDRixJQXZDRCxDQXVDRSxPQUFNMUcsQ0FBTixFQUFTO0FBQ1Qsd0JBQUl1RyxLQUFKLENBQVV2RyxDQUFWO0FBQ0Q7QUFDRixFQTNDRDs7QUE2Q0EsS0FBTStGLHdCQUF3QixTQUF4QkEscUJBQXdCLENBQVNDLElBQVQsRUFBZTtBQUMzQyxPQUFNVyxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBLE9BQUlDLEtBQUo7QUFDQSxzQkFBSWpHLEtBQUosQ0FBVSxDQUFWO0FBQ0F1RixrQkFDQ0YsSUFERCxDQUNNYSxhQUROLEVBRUNiLElBRkQsQ0FFTSxVQUFTbEIsR0FBVCxFQUFjO0FBQ2xCLHdCQUFJbkUsS0FBSixDQUFVbUUsSUFBSU0sRUFBZDtBQUNBd0IsYUFBUTlCLElBQUlNLEVBQVo7QUFDQSx3QkFBSXpFLEtBQUosQ0FBVXVELFdBQVY7QUFDQSxTQUFJQSxZQUFZMEMsS0FBWixDQUFKLEVBQXdCO0FBQ3RCRixTQUFFSSxPQUFGLENBQVU1QyxZQUFZMEMsS0FBWixDQUFWO0FBQ0QsTUFGRCxNQUVPO0FBQ0wsV0FBSSxDQUFDYixJQUFMLEVBQVdBLE9BQU8sRUFBQ2EsT0FBT0EsS0FBUixFQUFQO0FBQ1gsMEJBQUlqRyxLQUFKLENBQVVvRixJQUFWO0FBQ0FnQixtQkFBWWhCLElBQVosRUFDQ0MsSUFERCxDQUNNLFVBQVNWLEdBQVQsRUFBYztBQUNsQiw0QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQSxnQkFBTyx5QkFBZWEsY0FBZixDQUE4QmxDLE1BQTlCLEVBQXNDcUIsR0FBdEMsRUFBMkNuQixTQUEzQyxDQUFQO0FBQ0QsUUFKRCxFQUlHNkIsSUFKSCxDQUlRLFVBQVNWLEdBQVQsRUFBYztBQUNwQiw0QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQWMsMEJBQWlCUSxLQUFqQixFQUF3QnRCLEdBQXhCO0FBQ0FvQixXQUFFSSxPQUFGLENBQVV4QixHQUFWO0FBQ0QsUUFSRCxFQVFHZSxLQVJILENBUVMsVUFBU3RHLENBQVQsRUFBWTtBQUNuQjJHLFdBQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxRQVZEO0FBV0Q7QUFDRixJQXZCRCxFQXVCR3NHLEtBdkJILENBdUJTLFVBQVN0RyxDQUFULEVBQVk7QUFDbkIyRyxPQUFFTSxNQUFGLENBQVNqSCxDQUFUO0FBQ0QsSUF6QkQ7QUEwQkEsVUFBTzJHLEVBQUVPLE9BQVQ7QUFDRCxFQS9CRDs7QUFpQ0EsS0FBTUosZ0JBQWdCLFNBQWhCQSxhQUFnQixHQUFXO0FBQy9CO0FBQ0EsT0FBTUgsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQWpDLFVBQU9LLElBQVAsQ0FBWUMsS0FBWixDQUFrQixFQUFDQyxRQUFRLElBQVQsRUFBZUMsZUFBZSxJQUE5QixFQUFsQixFQUF1RCxVQUFTSCxJQUFULEVBQWM7QUFDbkUyQixPQUFFSSxPQUFGLENBQVUvQixLQUFLLENBQUwsQ0FBVjtBQUNELElBRkQ7QUFHQSxVQUFPMkIsRUFBRU8sT0FBVDtBQUNELEVBUEQ7O0FBU0EsS0FBTUYsY0FBYyxTQUFkQSxXQUFjLENBQVNoQixJQUFULEVBQWU7QUFDakMsT0FBTVcsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQSxPQUFJWixLQUFLbUIsUUFBVCxFQUFtQjtBQUNqQlIsT0FBRUksT0FBRixDQUFVZixLQUFLbUIsUUFBZjtBQUNELElBRkQsTUFFTyxJQUFJbkIsS0FBS2EsS0FBVCxFQUFnQjtBQUNyQk8sc0JBQWlCUCxLQUFqQixFQUF3QixFQUFDdkIsUUFBUSxhQUFULEVBQXhCLEVBQ0NXLElBREQsQ0FDTSxVQUFTVixHQUFULEVBQWM7QUFDbEJvQixTQUFFSSxPQUFGLENBQVV4QixHQUFWO0FBQ0QsTUFIRDtBQUlELElBTE0sTUFLQTtBQUNMb0IsT0FBRU0sTUFBRjtBQUNEO0FBQ0QsVUFBT04sRUFBRU8sT0FBVDtBQUNELEVBYkQ7O0FBZUEsS0FBTUUsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU1AsS0FBVCxFQUFnQmIsSUFBaEIsRUFBc0I7QUFDN0M7QUFDQSxPQUFNVyxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBakMsVUFBT0ssSUFBUCxDQUFZSSxXQUFaLENBQXdCeUIsS0FBeEIsRUFBK0JiLElBQS9CLEVBQXFDLFVBQVNULEdBQVQsRUFBYztBQUNqRCx3QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQW9CLE9BQUVJLE9BQUYsQ0FBVXhCLEdBQVY7QUFDRCxJQUhEO0FBSUEsVUFBT29CLEVBQUVPLE9BQVQ7QUFDRCxFQVJEOztBQVVBLEtBQU1iLG1CQUFtQixTQUFuQkEsZ0JBQW1CLENBQVNRLEtBQVQsRUFBZ0JiLElBQWhCLEVBQXNCO0FBQzdDN0IsZUFBWTBDLEtBQVosSUFBcUJiLElBQXJCO0FBQ0FyQixVQUFPSyxJQUFQLENBQVlDLEtBQVosQ0FBa0IsRUFBQ0MsUUFBUSxJQUFULEVBQWVDLGVBQWUsSUFBOUIsRUFBbEIsRUFBdUQsVUFBU0gsSUFBVCxFQUFjO0FBQ25FcUMsWUFBT0MsSUFBUCxDQUFZbkQsV0FBWixFQUF5Qm9ELE9BQXpCLENBQWlDLFVBQVNDLFNBQVQsRUFBb0I7QUFDbkQsV0FBS3hDLEtBQUt5QyxNQUFMLENBQVksVUFBUzFDLEdBQVQsRUFBYztBQUFDLGdCQUFPQSxJQUFJTSxFQUFKLElBQVVtQyxTQUFqQjtBQUEyQixRQUF0RCxFQUF3RDlHLE1BQXhELElBQWtFLENBQXZFLEVBQ0UsT0FBT3lELFlBQVlxRCxTQUFaLENBQVA7QUFDSCxNQUhEO0FBSUEsd0JBQUk1RyxLQUFKLENBQVV1RCxXQUFWO0FBQ0QsSUFORDtBQU9ELEVBVEQ7O0FBV0EsS0FBTWdDLGVBQWUsU0FBZkEsWUFBZSxHQUFXO0FBQzlCLE9BQU1RLElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0EsT0FBTWMsTUFBTSxJQUFJQyxJQUFKLEVBQVo7QUFDQSxPQUFJRCxNQUFNckQsV0FBTixHQUFvQixNQUF4QixFQUFnQztBQUM5Qm1DLHVCQUNDUCxJQURELENBQ00sWUFBVztBQUNmVSxTQUFFSSxPQUFGO0FBQ0QsTUFIRCxFQUdHVCxLQUhILENBR1MsVUFBU3RHLENBQVQsRUFBWTtBQUNuQiwwQkFBSXVHLEtBQUosQ0FBVXZHLENBQVY7QUFDQTJHLFNBQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxNQU5EO0FBT0QsSUFSRCxNQVFPO0FBQ0wyRyxPQUFFSSxPQUFGO0FBQ0Q7QUFDRCxVQUFPSixFQUFFTyxPQUFUO0FBQ0QsRUFmRDs7QUFpQkEsS0FBTVYsa0JBQWtCLFNBQWxCQSxlQUFrQixHQUFXO0FBQ2pDLE9BQU1HLElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0F2QyxpQkFBYyxJQUFJc0QsSUFBSixFQUFkO0FBQ0EsNEJBQWVDLFdBQWYsQ0FBMkIxRCxNQUEzQixFQUFtQyxFQUFuQyxFQUF1QyxJQUF2QyxFQUNDK0IsSUFERCxDQUNNLFVBQVM0QixPQUFULEVBQWtCO0FBQ3RCekQsaUJBQVl5RCxPQUFaO0FBQ0Esd0JBQUlqSCxLQUFKLENBQVV3RCxTQUFWO0FBQ0F1QyxPQUFFSSxPQUFGO0FBQ0QsSUFMRCxFQUtHVCxLQUxILENBS1MsVUFBU3RHLENBQVQsRUFBWTtBQUNuQix3QkFBSXVHLEtBQUosQ0FBVXZHLENBQVY7QUFDQTJHLE9BQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxJQVJEO0FBU0EsVUFBTzJHLEVBQUVPLE9BQVQ7QUFDRCxFQWJEO0FBY0FWLG1COzs7Ozs7Ozs7Ozs7OztBQzVNQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0EsVUFBU3NCLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFVBQU9BLE1BQU0xSCxTQUFOLElBQW1CMEgsTUFBTSxJQUFoQztBQUNEOztBQUVELFVBQVNDLEtBQVQsQ0FBZ0JELENBQWhCLEVBQW1CO0FBQ2pCLFVBQU9BLE1BQU0xSCxTQUFOLElBQW1CMEgsTUFBTSxJQUFoQztBQUNEOztBQUVELFVBQVNFLE1BQVQsQ0FBaUJGLENBQWpCLEVBQW9CO0FBQ2xCLFVBQU9BLE1BQU0sSUFBYjtBQUNEOztBQUVELFVBQVNHLE9BQVQsQ0FBa0JILENBQWxCLEVBQXFCO0FBQ25CLFVBQU9BLE1BQU0sS0FBYjtBQUNEOztBQUVEOzs7QUFHQSxVQUFTSSxXQUFULENBQXNCQyxLQUF0QixFQUE2QjtBQUMzQixVQUNFLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFDQSxPQUFPQSxLQUFQLEtBQWlCLFFBRGpCLElBRUEsT0FBT0EsS0FBUCxLQUFpQixTQUhuQjtBQUtEOztBQUVEOzs7OztBQUtBLFVBQVNDLFFBQVQsQ0FBbUI1SSxHQUFuQixFQUF3QjtBQUN0QixVQUFPQSxRQUFRLElBQVIsSUFBZ0IsUUFBT0EsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQXRDO0FBQ0Q7O0FBRUQsS0FBSTZJLFlBQVlqQixPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpDOztBQUVBOzs7O0FBSUEsVUFBU0MsYUFBVCxDQUF3Qi9JLEdBQXhCLEVBQTZCO0FBQzNCLFVBQU82SSxVQUFVdkksSUFBVixDQUFlTixHQUFmLE1BQXdCLGlCQUEvQjtBQUNEOztBQUVELFVBQVNnSixRQUFULENBQW1CVixDQUFuQixFQUFzQjtBQUNwQixVQUFPTyxVQUFVdkksSUFBVixDQUFlZ0ksQ0FBZixNQUFzQixpQkFBN0I7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU1csaUJBQVQsQ0FBNEJDLEdBQTVCLEVBQWlDO0FBQy9CLE9BQUlDLElBQUlDLFdBQVdGLEdBQVgsQ0FBUjtBQUNBLFVBQU9DLEtBQUssQ0FBTCxJQUFVRSxLQUFLQyxLQUFMLENBQVdILENBQVgsTUFBa0JBLENBQTVCLElBQWlDSSxTQUFTTCxHQUFULENBQXhDO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNKLFFBQVQsQ0FBbUJJLEdBQW5CLEVBQXdCO0FBQ3RCLFVBQU9BLE9BQU8sSUFBUCxHQUNILEVBREcsR0FFSCxRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBZixHQUNFTSxLQUFLQyxTQUFMLENBQWVQLEdBQWYsRUFBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsQ0FERixHQUVFUSxPQUFPUixHQUFQLENBSk47QUFLRDs7QUFFRDs7OztBQUlBLFVBQVNTLFFBQVQsQ0FBbUJULEdBQW5CLEVBQXdCO0FBQ3RCLE9BQUlDLElBQUlDLFdBQVdGLEdBQVgsQ0FBUjtBQUNBLFVBQU9VLE1BQU1ULENBQU4sSUFBV0QsR0FBWCxHQUFpQkMsQ0FBeEI7QUFDRDs7QUFFRDs7OztBQUlBLFVBQVNVLE9BQVQsQ0FDRUMsR0FERixFQUVFQyxnQkFGRixFQUdFO0FBQ0EsT0FBSUMsTUFBTXBDLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFWO0FBQ0EsT0FBSUMsT0FBT0osSUFBSUssS0FBSixDQUFVLEdBQVYsQ0FBWDtBQUNBLFFBQUssSUFBSW5KLElBQUksQ0FBYixFQUFnQkEsSUFBSWtKLEtBQUtqSixNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDcENnSixTQUFJRSxLQUFLbEosQ0FBTCxDQUFKLElBQWUsSUFBZjtBQUNEO0FBQ0QsVUFBTytJLG1CQUNILFVBQVViLEdBQVYsRUFBZTtBQUFFLFlBQU9jLElBQUlkLElBQUlrQixXQUFKLEVBQUosQ0FBUDtBQUFnQyxJQUQ5QyxHQUVILFVBQVVsQixHQUFWLEVBQWU7QUFBRSxZQUFPYyxJQUFJZCxHQUFKLENBQVA7QUFBa0IsSUFGdkM7QUFHRDs7QUFFRDs7O0FBR0EsS0FBSW1CLGVBQWVSLFFBQVEsZ0JBQVIsRUFBMEIsSUFBMUIsQ0FBbkI7O0FBRUE7OztBQUdBLEtBQUlTLHNCQUFzQlQsUUFBUSxpQkFBUixDQUExQjs7QUFFQTs7O0FBR0EsVUFBU1UsTUFBVCxDQUFpQkMsR0FBakIsRUFBc0JDLElBQXRCLEVBQTRCO0FBQzFCLE9BQUlELElBQUl2SixNQUFSLEVBQWdCO0FBQ2QsU0FBSStELFFBQVF3RixJQUFJOUgsT0FBSixDQUFZK0gsSUFBWixDQUFaO0FBQ0EsU0FBSXpGLFFBQVEsQ0FBQyxDQUFiLEVBQWdCO0FBQ2QsY0FBT3dGLElBQUlFLE1BQUosQ0FBVzFGLEtBQVgsRUFBa0IsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7O0FBR0EsS0FBSTJGLGlCQUFpQi9DLE9BQU92SCxTQUFQLENBQWlCc0ssY0FBdEM7QUFDQSxVQUFTQyxNQUFULENBQWlCNUssR0FBakIsRUFBc0I2SyxHQUF0QixFQUEyQjtBQUN6QixVQUFPRixlQUFlckssSUFBZixDQUFvQk4sR0FBcEIsRUFBeUI2SyxHQUF6QixDQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNDLE1BQVQsQ0FBaUJDLEVBQWpCLEVBQXFCO0FBQ25CLE9BQUlDLFFBQVFwRCxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBWjtBQUNBLFVBQVEsU0FBU2dCLFFBQVQsQ0FBbUJuQixHQUFuQixFQUF3QjtBQUM5QixTQUFJb0IsTUFBTUYsTUFBTWxCLEdBQU4sQ0FBVjtBQUNBLFlBQU9vQixRQUFRRixNQUFNbEIsR0FBTixJQUFhaUIsR0FBR2pCLEdBQUgsQ0FBckIsQ0FBUDtBQUNELElBSEQ7QUFJRDs7QUFFRDs7O0FBR0EsS0FBSXFCLGFBQWEsUUFBakI7QUFDQSxLQUFJQyxXQUFXTixPQUFPLFVBQVVoQixHQUFWLEVBQWU7QUFDbkMsVUFBT0EsSUFBSXVCLE9BQUosQ0FBWUYsVUFBWixFQUF3QixVQUFVRyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFBRSxZQUFPQSxJQUFJQSxFQUFFdkosV0FBRixFQUFKLEdBQXNCLEVBQTdCO0FBQWtDLElBQTVFLENBQVA7QUFDRCxFQUZjLENBQWY7O0FBSUE7OztBQUdBLEtBQUl3SixhQUFhVixPQUFPLFVBQVVoQixHQUFWLEVBQWU7QUFDckMsVUFBT0EsSUFBSTJCLE1BQUosQ0FBVyxDQUFYLEVBQWN6SixXQUFkLEtBQThCOEgsSUFBSWxILEtBQUosQ0FBVSxDQUFWLENBQXJDO0FBQ0QsRUFGZ0IsQ0FBakI7O0FBSUE7OztBQUdBLEtBQUk4SSxjQUFjLGdCQUFsQjtBQUNBLEtBQUlDLFlBQVliLE9BQU8sVUFBVWhCLEdBQVYsRUFBZTtBQUNwQyxVQUFPQSxJQUNKdUIsT0FESSxDQUNJSyxXQURKLEVBQ2lCLE9BRGpCLEVBRUpMLE9BRkksQ0FFSUssV0FGSixFQUVpQixPQUZqQixFQUdKdEIsV0FISSxFQUFQO0FBSUQsRUFMZSxDQUFoQjs7QUFPQTs7O0FBR0EsVUFBU2pLLElBQVQsQ0FBZTRLLEVBQWYsRUFBbUJhLEdBQW5CLEVBQXdCO0FBQ3RCLFlBQVNDLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFNBQUlDLElBQUl0TCxVQUFVUSxNQUFsQjtBQUNBLFlBQU84SyxJQUNIQSxJQUFJLENBQUosR0FDRWhCLEdBQUd2SyxLQUFILENBQVNvTCxHQUFULEVBQWNuTCxTQUFkLENBREYsR0FFRXNLLEdBQUd6SyxJQUFILENBQVFzTCxHQUFSLEVBQWFFLENBQWIsQ0FIQyxHQUlIZixHQUFHekssSUFBSCxDQUFRc0wsR0FBUixDQUpKO0FBS0Q7QUFDRDtBQUNBQyxXQUFRRyxPQUFSLEdBQWtCakIsR0FBRzlKLE1BQXJCO0FBQ0EsVUFBTzRLLE9BQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU0ksT0FBVCxDQUFrQi9CLElBQWxCLEVBQXdCZ0MsS0FBeEIsRUFBK0I7QUFDN0JBLFdBQVFBLFNBQVMsQ0FBakI7QUFDQSxPQUFJbEwsSUFBSWtKLEtBQUtqSixNQUFMLEdBQWNpTCxLQUF0QjtBQUNBLE9BQUlDLE1BQU0sSUFBSUMsS0FBSixDQUFVcEwsQ0FBVixDQUFWO0FBQ0EsVUFBT0EsR0FBUCxFQUFZO0FBQ1ZtTCxTQUFJbkwsQ0FBSixJQUFTa0osS0FBS2xKLElBQUlrTCxLQUFULENBQVQ7QUFDRDtBQUNELFVBQU9DLEdBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU0UsTUFBVCxDQUFpQkMsRUFBakIsRUFBcUJDLEtBQXJCLEVBQTRCO0FBQzFCLFFBQUssSUFBSTFCLEdBQVQsSUFBZ0IwQixLQUFoQixFQUF1QjtBQUNyQkQsUUFBR3pCLEdBQUgsSUFBVTBCLE1BQU0xQixHQUFOLENBQVY7QUFDRDtBQUNELFVBQU95QixFQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNFLFFBQVQsQ0FBbUJoQyxHQUFuQixFQUF3QjtBQUN0QixPQUFJMUUsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJOUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd0osSUFBSXZKLE1BQXhCLEVBQWdDRCxHQUFoQyxFQUFxQztBQUNuQyxTQUFJd0osSUFBSXhKLENBQUosQ0FBSixFQUFZO0FBQ1ZxTCxjQUFPdkcsR0FBUCxFQUFZMEUsSUFBSXhKLENBQUosQ0FBWjtBQUNEO0FBQ0Y7QUFDRCxVQUFPOEUsR0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFVBQVNsRyxJQUFULENBQWVrTSxDQUFmLEVBQWtCVyxDQUFsQixFQUFxQmxCLENBQXJCLEVBQXdCLENBQUU7O0FBRTFCOzs7QUFHQSxLQUFJbUIsS0FBSyxTQUFMQSxFQUFLLENBQVVaLENBQVYsRUFBYVcsQ0FBYixFQUFnQmxCLENBQWhCLEVBQW1CO0FBQUUsVUFBTyxLQUFQO0FBQWUsRUFBN0M7O0FBRUE7OztBQUdBLEtBQUlvQixXQUFXLFNBQVhBLFFBQVcsQ0FBVXJCLENBQVYsRUFBYTtBQUFFLFVBQU9BLENBQVA7QUFBVyxFQUF6Qzs7QUFFQTs7O0FBR0EsVUFBU3NCLGFBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDO0FBQy9CLFVBQU9BLFFBQVFDLE1BQVIsQ0FBZSxVQUFVakYsSUFBVixFQUFnQmtGLENBQWhCLEVBQW1CO0FBQ3ZDLFlBQU9sRixLQUFLbUYsTUFBTCxDQUFZRCxFQUFFRSxVQUFGLElBQWdCLEVBQTVCLENBQVA7QUFDRCxJQUZNLEVBRUosRUFGSSxFQUVBQyxJQUZBLENBRUssR0FGTCxDQUFQO0FBR0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTQyxVQUFULENBQXFCckIsQ0FBckIsRUFBd0JXLENBQXhCLEVBQTJCO0FBQ3pCLE9BQUlYLE1BQU1XLENBQVYsRUFBYTtBQUFFLFlBQU8sSUFBUDtBQUFhO0FBQzVCLE9BQUlXLFlBQVl4RSxTQUFTa0QsQ0FBVCxDQUFoQjtBQUNBLE9BQUl1QixZQUFZekUsU0FBUzZELENBQVQsQ0FBaEI7QUFDQSxPQUFJVyxhQUFhQyxTQUFqQixFQUE0QjtBQUMxQixTQUFJO0FBQ0YsV0FBSUMsV0FBV2xCLE1BQU1tQixPQUFOLENBQWN6QixDQUFkLENBQWY7QUFDQSxXQUFJMEIsV0FBV3BCLE1BQU1tQixPQUFOLENBQWNkLENBQWQsQ0FBZjtBQUNBLFdBQUlhLFlBQVlFLFFBQWhCLEVBQTBCO0FBQ3hCLGdCQUFPMUIsRUFBRTdLLE1BQUYsS0FBYXdMLEVBQUV4TCxNQUFmLElBQXlCNkssRUFBRTJCLEtBQUYsQ0FBUSxVQUFVbE4sQ0FBVixFQUFhUyxDQUFiLEVBQWdCO0FBQ3RELGtCQUFPbU0sV0FBVzVNLENBQVgsRUFBY2tNLEVBQUV6TCxDQUFGLENBQWQsQ0FBUDtBQUNELFVBRitCLENBQWhDO0FBR0QsUUFKRCxNQUlPLElBQUksQ0FBQ3NNLFFBQUQsSUFBYSxDQUFDRSxRQUFsQixFQUE0QjtBQUNqQyxhQUFJRSxRQUFROUYsT0FBT0MsSUFBUCxDQUFZaUUsQ0FBWixDQUFaO0FBQ0EsYUFBSTZCLFFBQVEvRixPQUFPQyxJQUFQLENBQVk0RSxDQUFaLENBQVo7QUFDQSxnQkFBT2lCLE1BQU16TSxNQUFOLEtBQWlCME0sTUFBTTFNLE1BQXZCLElBQWlDeU0sTUFBTUQsS0FBTixDQUFZLFVBQVU1QyxHQUFWLEVBQWU7QUFDakUsa0JBQU9zQyxXQUFXckIsRUFBRWpCLEdBQUYsQ0FBWCxFQUFtQjRCLEVBQUU1QixHQUFGLENBQW5CLENBQVA7QUFDRCxVQUZ1QyxDQUF4QztBQUdELFFBTk0sTUFNQTtBQUNMO0FBQ0EsZ0JBQU8sS0FBUDtBQUNEO0FBQ0YsTUFqQkQsQ0FpQkUsT0FBT3RLLENBQVAsRUFBVTtBQUNWO0FBQ0EsY0FBTyxLQUFQO0FBQ0Q7QUFDRixJQXRCRCxNQXNCTyxJQUFJLENBQUM2TSxTQUFELElBQWMsQ0FBQ0MsU0FBbkIsRUFBOEI7QUFDbkMsWUFBTzNELE9BQU9vQyxDQUFQLE1BQWNwQyxPQUFPK0MsQ0FBUCxDQUFyQjtBQUNELElBRk0sTUFFQTtBQUNMLFlBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsVUFBU21CLFlBQVQsQ0FBdUJwRCxHQUF2QixFQUE0QnRCLEdBQTVCLEVBQWlDO0FBQy9CLFFBQUssSUFBSWxJLElBQUksQ0FBYixFQUFnQkEsSUFBSXdKLElBQUl2SixNQUF4QixFQUFnQ0QsR0FBaEMsRUFBcUM7QUFDbkMsU0FBSW1NLFdBQVczQyxJQUFJeEosQ0FBSixDQUFYLEVBQW1Ca0ksR0FBbkIsQ0FBSixFQUE2QjtBQUFFLGNBQU9sSSxDQUFQO0FBQVU7QUFDMUM7QUFDRCxVQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVEOzs7QUFHQSxVQUFTNk0sSUFBVCxDQUFlOUMsRUFBZixFQUFtQjtBQUNqQixPQUFJK0MsU0FBUyxLQUFiO0FBQ0EsVUFBTyxZQUFZO0FBQ2pCLFNBQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1hBLGdCQUFTLElBQVQ7QUFDQS9DLFVBQUd2SyxLQUFILENBQVMsSUFBVCxFQUFlQyxTQUFmO0FBQ0Q7QUFDRixJQUxEO0FBTUQ7O0FBRUQsS0FBSXNOLFdBQVcsc0JBQWY7O0FBRUEsS0FBSUMsY0FBYyxDQUNoQixXQURnQixFQUVoQixXQUZnQixFQUdoQixRQUhnQixDQUFsQjs7QUFNQSxLQUFJQyxrQkFBa0IsQ0FDcEIsY0FEb0IsRUFFcEIsU0FGb0IsRUFHcEIsYUFIb0IsRUFJcEIsU0FKb0IsRUFLcEIsY0FMb0IsRUFNcEIsU0FOb0IsRUFPcEIsZUFQb0IsRUFRcEIsV0FSb0IsRUFTcEIsV0FUb0IsRUFVcEIsYUFWb0IsQ0FBdEI7O0FBYUE7O0FBRUEsS0FBSUMsU0FBVTtBQUNaOzs7QUFHQUMsMEJBQXVCdkcsT0FBT3FDLE1BQVAsQ0FBYyxJQUFkLENBSlg7O0FBTVo7OztBQUdBbUUsV0FBUSxLQVRJOztBQVdaOzs7QUFHQUMsa0JBQWVDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQWQ1Qjs7QUFnQlo7OztBQUdBQyxhQUFVSCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFuQnZCOztBQXFCWjs7O0FBR0FFLGdCQUFhLEtBeEJEOztBQTBCWjs7O0FBR0FDLGlCQUFjLElBN0JGOztBQStCWjs7O0FBR0FDLGdCQUFhLElBbENEOztBQW9DWjs7O0FBR0FDLG9CQUFpQixFQXZDTDs7QUF5Q1o7OztBQUdBQyxhQUFVbEgsT0FBT3FDLE1BQVAsQ0FBYyxJQUFkLENBNUNFOztBQThDWjs7OztBQUlBOEUsa0JBQWVyQyxFQWxESDs7QUFvRFo7Ozs7QUFJQXNDLG1CQUFnQnRDLEVBeERKOztBQTBEWjs7OztBQUlBdUMscUJBQWtCdkMsRUE5RE47O0FBZ0VaOzs7QUFHQXdDLG9CQUFpQnRQLElBbkVMOztBQXFFWjs7O0FBR0F1UCx5QkFBc0J4QyxRQXhFVjs7QUEwRVo7Ozs7QUFJQXlDLGdCQUFhMUMsRUE5RUQ7O0FBZ0ZaOzs7QUFHQTJDLG9CQUFpQnBCO0FBbkZMLEVBQWQ7O0FBc0ZBOztBQUVBLEtBQUlxQixjQUFjMUgsT0FBTzJILE1BQVAsQ0FBYyxFQUFkLENBQWxCOztBQUVBOzs7QUFHQSxVQUFTQyxVQUFULENBQXFCMUYsR0FBckIsRUFBMEI7QUFDeEIsT0FBSXlCLElBQUksQ0FBQ3pCLE1BQU0sRUFBUCxFQUFXMkYsVUFBWCxDQUFzQixDQUF0QixDQUFSO0FBQ0EsVUFBT2xFLE1BQU0sSUFBTixJQUFjQSxNQUFNLElBQTNCO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNtRSxHQUFULENBQWMxUCxHQUFkLEVBQW1CNkssR0FBbkIsRUFBd0IzQixHQUF4QixFQUE2QnlHLFVBQTdCLEVBQXlDO0FBQ3ZDL0gsVUFBT2dJLGNBQVAsQ0FBc0I1UCxHQUF0QixFQUEyQjZLLEdBQTNCLEVBQWdDO0FBQzlCbEMsWUFBT08sR0FEdUI7QUFFOUJ5RyxpQkFBWSxDQUFDLENBQUNBLFVBRmdCO0FBRzlCRSxlQUFVLElBSG9CO0FBSTlCQyxtQkFBYztBQUpnQixJQUFoQztBQU1EOztBQUVEOzs7QUFHQSxLQUFJQyxTQUFTLFNBQWI7QUFDQSxVQUFTQyxTQUFULENBQW9CQyxJQUFwQixFQUEwQjtBQUN4QixPQUFJRixPQUFPRyxJQUFQLENBQVlELElBQVosQ0FBSixFQUF1QjtBQUNyQjtBQUNEO0FBQ0QsT0FBSUUsV0FBV0YsS0FBSzlGLEtBQUwsQ0FBVyxHQUFYLENBQWY7QUFDQSxVQUFPLFVBQVVuSyxHQUFWLEVBQWU7QUFDcEIsVUFBSyxJQUFJZ0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbVAsU0FBU2xQLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4QyxXQUFJLENBQUNoQixHQUFMLEVBQVU7QUFBRTtBQUFRO0FBQ3BCQSxhQUFNQSxJQUFJbVEsU0FBU25QLENBQVQsQ0FBSixDQUFOO0FBQ0Q7QUFDRCxZQUFPaEIsR0FBUDtBQUNELElBTkQ7QUFPRDs7QUFFRDs7QUFFQSxLQUFJb1EsT0FBT3hRLElBQVg7QUFDQSxLQUFJeVEsTUFBTXpRLElBQVY7QUFDQSxLQUFJMFEsc0JBQXVCLElBQTNCLEMsQ0FBa0M7O0FBRWxDLEtBQUloQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsT0FBSStCLGFBQWEsT0FBTzVQLE9BQVAsS0FBbUIsV0FBcEM7QUFDQSxPQUFJNlAsYUFBYSxpQkFBakI7QUFDQSxPQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVTNHLEdBQVYsRUFBZTtBQUFFLFlBQU9BLElBQ3BDdUIsT0FEb0MsQ0FDNUJtRixVQUQ0QixFQUNoQixVQUFVakYsQ0FBVixFQUFhO0FBQUUsY0FBT0EsRUFBRXZKLFdBQUYsRUFBUDtBQUF5QixNQUR4QixFQUVwQ3FKLE9BRm9DLENBRTVCLE9BRjRCLEVBRW5CLEVBRm1CLENBQVA7QUFFTixJQUYxQjs7QUFJQStFLFVBQU8sY0FBVU0sR0FBVixFQUFlQyxFQUFmLEVBQW1CO0FBQ3hCLFNBQUlsSyxRQUFRa0ssS0FBS0MsdUJBQXVCRCxFQUF2QixDQUFMLEdBQWtDLEVBQTlDOztBQUVBLFNBQUl6QyxPQUFPVSxXQUFYLEVBQXdCO0FBQ3RCVixjQUFPVSxXQUFQLENBQW1CdE8sSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJvUSxHQUE5QixFQUFtQ0MsRUFBbkMsRUFBdUNsSyxLQUF2QztBQUNELE1BRkQsTUFFTyxJQUFJOEosY0FBZSxDQUFDckMsT0FBT0UsTUFBM0IsRUFBb0M7QUFDekN6TixlQUFRbUcsS0FBUixDQUFlLGlCQUFpQjRKLEdBQWpCLEdBQXVCakssS0FBdEM7QUFDRDtBQUNGLElBUkQ7O0FBVUE0SixTQUFNLGFBQVVLLEdBQVYsRUFBZUMsRUFBZixFQUFtQjtBQUN2QixTQUFJSixjQUFlLENBQUNyQyxPQUFPRSxNQUEzQixFQUFvQztBQUNsQ3pOLGVBQVF5UCxJQUFSLENBQWEsZ0JBQWdCTSxHQUFoQixJQUNYQyxLQUFLQyx1QkFBdUJELEVBQXZCLENBQUwsR0FBa0MsRUFEdkIsQ0FBYjtBQUdEO0FBQ0YsSUFORDs7QUFRQUwseUJBQXNCLDZCQUFVSyxFQUFWLEVBQWNFLFdBQWQsRUFBMkI7QUFDL0MsU0FBSUYsR0FBR0csS0FBSCxLQUFhSCxFQUFqQixFQUFxQjtBQUNuQixjQUFPLFFBQVA7QUFDRDtBQUNELFNBQUlwUCxPQUFPLE9BQU9vUCxFQUFQLEtBQWMsUUFBZCxHQUNQQSxFQURPLEdBRVAsT0FBT0EsRUFBUCxLQUFjLFVBQWQsSUFBNEJBLEdBQUdJLE9BQS9CLEdBQ0VKLEdBQUdJLE9BQUgsQ0FBV3hQLElBRGIsR0FFRW9QLEdBQUdLLE1BQUgsR0FDRUwsR0FBR00sUUFBSCxDQUFZMVAsSUFBWixJQUFvQm9QLEdBQUdNLFFBQUgsQ0FBWUMsYUFEbEMsR0FFRVAsR0FBR3BQLElBTlg7O0FBUUEsU0FBSTRQLE9BQU9SLEdBQUdLLE1BQUgsSUFBYUwsR0FBR00sUUFBSCxDQUFZRyxNQUFwQztBQUNBLFNBQUksQ0FBQzdQLElBQUQsSUFBUzRQLElBQWIsRUFBbUI7QUFDakIsV0FBSUUsUUFBUUYsS0FBS0UsS0FBTCxDQUFXLGlCQUFYLENBQVo7QUFDQTlQLGNBQU84UCxTQUFTQSxNQUFNLENBQU4sQ0FBaEI7QUFDRDs7QUFFRCxZQUNFLENBQUM5UCxPQUFRLE1BQU9rUCxTQUFTbFAsSUFBVCxDQUFQLEdBQXlCLEdBQWpDLEdBQXdDLGFBQXpDLEtBQ0M0UCxRQUFRTixnQkFBZ0IsS0FBeEIsR0FBaUMsU0FBU00sSUFBMUMsR0FBa0QsRUFEbkQsQ0FERjtBQUlELElBdEJEOztBQXdCQSxPQUFJRyxTQUFTLFNBQVRBLE1BQVMsQ0FBVXhILEdBQVYsRUFBZVgsQ0FBZixFQUFrQjtBQUM3QixTQUFJckQsTUFBTSxFQUFWO0FBQ0EsWUFBT3FELENBQVAsRUFBVTtBQUNSLFdBQUlBLElBQUksQ0FBSixLQUFVLENBQWQsRUFBaUI7QUFBRXJELGdCQUFPZ0UsR0FBUDtBQUFhO0FBQ2hDLFdBQUlYLElBQUksQ0FBUixFQUFXO0FBQUVXLGdCQUFPQSxHQUFQO0FBQWE7QUFDMUJYLGFBQU0sQ0FBTjtBQUNEO0FBQ0QsWUFBT3JELEdBQVA7QUFDRCxJQVJEOztBQVVBLE9BQUk4Syx5QkFBeUIsU0FBekJBLHNCQUF5QixDQUFVRCxFQUFWLEVBQWM7QUFDekMsU0FBSUEsR0FBR0ssTUFBSCxJQUFhTCxHQUFHWSxPQUFwQixFQUE2QjtBQUMzQixXQUFJQyxPQUFPLEVBQVg7QUFDQSxXQUFJQywyQkFBMkIsQ0FBL0I7QUFDQSxjQUFPZCxFQUFQLEVBQVc7QUFDVCxhQUFJYSxLQUFLdlEsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ25CLGVBQUl5USxPQUFPRixLQUFLQSxLQUFLdlEsTUFBTCxHQUFjLENBQW5CLENBQVg7QUFDQSxlQUFJeVEsS0FBS0MsV0FBTCxLQUFxQmhCLEdBQUdnQixXQUE1QixFQUF5QztBQUN2Q0Y7QUFDQWQsa0JBQUtBLEdBQUdZLE9BQVI7QUFDQTtBQUNELFlBSkQsTUFJTyxJQUFJRSwyQkFBMkIsQ0FBL0IsRUFBa0M7QUFDdkNELGtCQUFLQSxLQUFLdlEsTUFBTCxHQUFjLENBQW5CLElBQXdCLENBQUN5USxJQUFELEVBQU9ELHdCQUFQLENBQXhCO0FBQ0FBLHdDQUEyQixDQUEzQjtBQUNEO0FBQ0Y7QUFDREQsY0FBS0ksSUFBTCxDQUFVakIsRUFBVjtBQUNBQSxjQUFLQSxHQUFHWSxPQUFSO0FBQ0Q7QUFDRCxjQUFPLHFCQUFxQkMsS0FDekJ4SCxHQUR5QixDQUNyQixVQUFVMkcsRUFBVixFQUFjM1AsQ0FBZCxFQUFpQjtBQUFFLGdCQUFRLE1BQU1BLE1BQU0sQ0FBTixHQUFVLE9BQVYsR0FBb0JzUSxPQUFPLEdBQVAsRUFBWSxJQUFJdFEsSUFBSSxDQUFwQixDQUExQixLQUFxRG9MLE1BQU1tQixPQUFOLENBQWNvRCxFQUFkLElBQzdFTCxvQkFBb0JLLEdBQUcsQ0FBSCxDQUFwQixDQUFELEdBQStCLE9BQS9CLEdBQTBDQSxHQUFHLENBQUgsQ0FBMUMsR0FBbUQsbUJBRDJCLEdBRS9FTCxvQkFBb0JLLEVBQXBCLENBRjBCLENBQVI7QUFFVSxRQUhSLEVBSXpCekQsSUFKeUIsQ0FJcEIsSUFKb0IsQ0FBNUI7QUFLRCxNQXZCRCxNQXVCTztBQUNMLGNBQVEsbUJBQW9Cb0Qsb0JBQW9CSyxFQUFwQixDQUFwQixHQUErQyxHQUF2RDtBQUNEO0FBQ0YsSUEzQkQ7QUE0QkQ7O0FBRUQ7O0FBRUEsVUFBU2tCLFdBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCbkIsRUFBM0IsRUFBK0I1SyxJQUEvQixFQUFxQztBQUNuQyxPQUFJbUksT0FBT1MsWUFBWCxFQUF5QjtBQUN2QlQsWUFBT1MsWUFBUCxDQUFvQnJPLElBQXBCLENBQXlCLElBQXpCLEVBQStCd1IsR0FBL0IsRUFBb0NuQixFQUFwQyxFQUF3QzVLLElBQXhDO0FBQ0QsSUFGRCxNQUVPO0FBQ0wsU0FBSXVJLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzRCLFlBQU0sY0FBY3JLLElBQWQsR0FBcUIsTUFBckIsR0FBK0IrTCxJQUFJaEosUUFBSixFQUEvQixHQUFpRCxJQUF2RCxFQUE4RDZILEVBQTlEO0FBQ0Q7QUFDRDtBQUNBLFNBQUlvQixhQUFhLE9BQU9wUixPQUFQLEtBQW1CLFdBQXBDLEVBQWlEO0FBQy9DQSxlQUFRbUcsS0FBUixDQUFjZ0wsR0FBZDtBQUNELE1BRkQsTUFFTztBQUNMLGFBQU1BLEdBQU47QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLEtBQUlFLFdBQVcsZUFBZSxFQUE5Qjs7QUFFQTtBQUNBLEtBQUlELFlBQVksT0FBTzlQLE1BQVAsS0FBa0IsV0FBbEM7QUFDQSxLQUFJZ1EsS0FBS0YsYUFBYTlQLE9BQU9pUSxTQUFQLENBQWlCQyxTQUFqQixDQUEyQi9ILFdBQTNCLEVBQXRCO0FBQ0EsS0FBSWdJLE9BQU9ILE1BQU0sZUFBZS9CLElBQWYsQ0FBb0IrQixFQUFwQixDQUFqQjtBQUNBLEtBQUlJLFFBQVFKLE1BQU1BLEdBQUd2UCxPQUFILENBQVcsVUFBWCxJQUF5QixDQUEzQztBQUNBLEtBQUk0UCxTQUFTTCxNQUFNQSxHQUFHdlAsT0FBSCxDQUFXLE9BQVgsSUFBc0IsQ0FBekM7QUFDQSxLQUFJNlAsWUFBWU4sTUFBTUEsR0FBR3ZQLE9BQUgsQ0FBVyxTQUFYLElBQXdCLENBQTlDO0FBQ0EsS0FBSThQLFFBQVFQLE1BQU0sdUJBQXVCL0IsSUFBdkIsQ0FBNEIrQixFQUE1QixDQUFsQjtBQUNBLEtBQUlRLFdBQVdSLE1BQU0sY0FBYy9CLElBQWQsQ0FBbUIrQixFQUFuQixDQUFOLElBQWdDLENBQUNLLE1BQWhEOztBQUVBO0FBQ0EsS0FBSUksY0FBZSxFQUFELENBQUtDLEtBQXZCOztBQUVBLEtBQUlDLGtCQUFrQixLQUF0QjtBQUNBLEtBQUliLFNBQUosRUFBZTtBQUNiLE9BQUk7QUFDRixTQUFJYyxPQUFPLEVBQVg7QUFDQWpMLFlBQU9nSSxjQUFQLENBQXNCaUQsSUFBdEIsRUFBNEIsU0FBNUIsRUFBd0M7QUFDdENDLFlBQUssU0FBU0EsR0FBVCxHQUFnQjtBQUNuQjtBQUNBRiwyQkFBa0IsSUFBbEI7QUFDRDtBQUpxQyxNQUF4QyxFQUZFLENBT0c7QUFDTDNRLFlBQU84USxnQkFBUCxDQUF3QixjQUF4QixFQUF3QyxJQUF4QyxFQUE4Q0YsSUFBOUM7QUFDRCxJQVRELENBU0UsT0FBT3RTLENBQVAsRUFBVSxDQUFFO0FBQ2Y7O0FBRUQ7QUFDQTtBQUNBLEtBQUl5UyxTQUFKO0FBQ0EsS0FBSUMsb0JBQW9CLFNBQXBCQSxpQkFBb0IsR0FBWTtBQUNsQyxPQUFJRCxjQUFjcFMsU0FBbEIsRUFBNkI7QUFDM0I7QUFDQSxTQUFJLENBQUNtUixTQUFELElBQWMsT0FBT21CLE1BQVAsS0FBa0IsV0FBcEMsRUFBaUQ7QUFDL0M7QUFDQTtBQUNBRixtQkFBWUUsT0FBTyxTQUFQLEVBQWtCM0UsR0FBbEIsQ0FBc0I0RSxPQUF0QixLQUFrQyxRQUE5QztBQUNELE1BSkQsTUFJTztBQUNMSCxtQkFBWSxLQUFaO0FBQ0Q7QUFDRjtBQUNELFVBQU9BLFNBQVA7QUFDRCxFQVpEOztBQWNBO0FBQ0EsS0FBSXZFLFdBQVdzRCxhQUFhOVAsT0FBT21SLDRCQUFuQzs7QUFFQTtBQUNBLFVBQVNDLFFBQVQsQ0FBbUJDLElBQW5CLEVBQXlCO0FBQ3ZCLFVBQU8sT0FBT0EsSUFBUCxLQUFnQixVQUFoQixJQUE4QixjQUFjcEQsSUFBZCxDQUFtQm9ELEtBQUt4SyxRQUFMLEVBQW5CLENBQXJDO0FBQ0Q7O0FBRUQsS0FBSXlLLFlBQ0YsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0gsU0FBU0csTUFBVCxDQUFqQyxJQUNBLE9BQU9DLE9BQVAsS0FBbUIsV0FEbkIsSUFDa0NKLFNBQVNJLFFBQVFDLE9BQWpCLENBRnBDOztBQUlBOzs7QUFHQSxLQUFJQyxXQUFZLFlBQVk7QUFDMUIsT0FBSUMsWUFBWSxFQUFoQjtBQUNBLE9BQUlDLFVBQVUsS0FBZDtBQUNBLE9BQUlDLFNBQUo7O0FBRUEsWUFBU0MsZUFBVCxHQUE0QjtBQUMxQkYsZUFBVSxLQUFWO0FBQ0EsU0FBSUcsU0FBU0osVUFBVWhSLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBYjtBQUNBZ1IsZUFBVTNTLE1BQVYsR0FBbUIsQ0FBbkI7QUFDQSxVQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSWdULE9BQU8vUyxNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDdENnVCxjQUFPaFQsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFJLE9BQU9pVCxPQUFQLEtBQW1CLFdBQW5CLElBQWtDWixTQUFTWSxPQUFULENBQXRDLEVBQXlEO0FBQ3ZELFNBQUlDLElBQUlELFFBQVEzTSxPQUFSLEVBQVI7QUFDQSxTQUFJNk0sV0FBVyxTQUFYQSxRQUFXLENBQVVyQyxHQUFWLEVBQWU7QUFBRW5SLGVBQVFtRyxLQUFSLENBQWNnTCxHQUFkO0FBQXFCLE1BQXJEO0FBQ0FnQyxpQkFBWSxxQkFBWTtBQUN0QkksU0FBRTFOLElBQUYsQ0FBT3VOLGVBQVAsRUFBd0JsTixLQUF4QixDQUE4QnNOLFFBQTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUkzQixLQUFKLEVBQVc7QUFBRTRCLG9CQUFXeFUsSUFBWDtBQUFtQjtBQUNqQyxNQVJEO0FBU0QsSUFaRCxNQVlPLElBQUksT0FBT3lVLGdCQUFQLEtBQTRCLFdBQTVCLEtBQ1RoQixTQUFTZ0IsZ0JBQVQ7QUFDQTtBQUNBQSxvQkFBaUJ2TCxRQUFqQixPQUFnQyxzQ0FIdkIsQ0FBSixFQUlKO0FBQ0Q7QUFDQTtBQUNBLFNBQUl3TCxVQUFVLENBQWQ7QUFDQSxTQUFJQyxXQUFXLElBQUlGLGdCQUFKLENBQXFCTixlQUFyQixDQUFmO0FBQ0EsU0FBSVMsV0FBV3BTLFNBQVNxUyxjQUFULENBQXdCL0ssT0FBTzRLLE9BQVAsQ0FBeEIsQ0FBZjtBQUNBQyxjQUFTRyxPQUFULENBQWlCRixRQUFqQixFQUEyQjtBQUN6Qkcsc0JBQWU7QUFEVSxNQUEzQjtBQUdBYixpQkFBWSxxQkFBWTtBQUN0QlEsaUJBQVUsQ0FBQ0EsVUFBVSxDQUFYLElBQWdCLENBQTFCO0FBQ0FFLGdCQUFTak8sSUFBVCxHQUFnQm1ELE9BQU80SyxPQUFQLENBQWhCO0FBQ0QsTUFIRDtBQUlELElBakJNLE1BaUJBO0FBQ0w7QUFDQTtBQUNBUixpQkFBWSxxQkFBWTtBQUN0Qk0sa0JBQVdMLGVBQVgsRUFBNEIsQ0FBNUI7QUFDRCxNQUZEO0FBR0Q7O0FBRUQsVUFBTyxTQUFTYSxhQUFULENBQXdCQyxFQUF4QixFQUE0QmpKLEdBQTVCLEVBQWlDO0FBQ3RDLFNBQUlrSixRQUFKO0FBQ0FsQixlQUFVaEMsSUFBVixDQUFlLFlBQVk7QUFDekIsV0FBSWlELEVBQUosRUFBUTtBQUNOLGFBQUk7QUFDRkEsY0FBR3ZVLElBQUgsQ0FBUXNMLEdBQVI7QUFDRCxVQUZELENBRUUsT0FBT3JMLENBQVAsRUFBVTtBQUNWc1IsdUJBQVl0UixDQUFaLEVBQWVxTCxHQUFmLEVBQW9CLFVBQXBCO0FBQ0Q7QUFDRixRQU5ELE1BTU8sSUFBSWtKLFFBQUosRUFBYztBQUNuQkEsa0JBQVNsSixHQUFUO0FBQ0Q7QUFDRixNQVZEO0FBV0EsU0FBSSxDQUFDaUksT0FBTCxFQUFjO0FBQ1pBLGlCQUFVLElBQVY7QUFDQUM7QUFDRDtBQUNELFNBQUksQ0FBQ2UsRUFBRCxJQUFPLE9BQU9aLE9BQVAsS0FBbUIsV0FBOUIsRUFBMkM7QUFDekMsY0FBTyxJQUFJQSxPQUFKLENBQVksVUFBVTNNLE9BQVYsRUFBbUJFLE1BQW5CLEVBQTJCO0FBQzVDc04sb0JBQVd4TixPQUFYO0FBQ0QsUUFGTSxDQUFQO0FBR0Q7QUFDRixJQXRCRDtBQXVCRCxFQWpGYyxFQUFmOztBQW1GQSxLQUFJeU4sSUFBSjtBQUNBO0FBQ0EsS0FBSSxPQUFPQyxHQUFQLEtBQWUsV0FBZixJQUE4QjNCLFNBQVMyQixHQUFULENBQWxDLEVBQWlEO0FBQy9DO0FBQ0FELFVBQU9DLEdBQVA7QUFDRCxFQUhELE1BR087QUFDTDtBQUNBRCxVQUFRLFlBQVk7QUFDbEIsY0FBU0MsR0FBVCxHQUFnQjtBQUNkLFlBQUtDLEdBQUwsR0FBV3JOLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFYO0FBQ0Q7QUFDRCtLLFNBQUkzVSxTQUFKLENBQWM2VSxHQUFkLEdBQW9CLFNBQVNBLEdBQVQsQ0FBY3JLLEdBQWQsRUFBbUI7QUFDckMsY0FBTyxLQUFLb0ssR0FBTCxDQUFTcEssR0FBVCxNQUFrQixJQUF6QjtBQUNELE1BRkQ7QUFHQW1LLFNBQUkzVSxTQUFKLENBQWM4VSxHQUFkLEdBQW9CLFNBQVNBLEdBQVQsQ0FBY3RLLEdBQWQsRUFBbUI7QUFDckMsWUFBS29LLEdBQUwsQ0FBU3BLLEdBQVQsSUFBZ0IsSUFBaEI7QUFDRCxNQUZEO0FBR0FtSyxTQUFJM1UsU0FBSixDQUFjK1UsS0FBZCxHQUFzQixTQUFTQSxLQUFULEdBQWtCO0FBQ3RDLFlBQUtILEdBQUwsR0FBV3JOLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFYO0FBQ0QsTUFGRDs7QUFJQSxZQUFPK0ssR0FBUDtBQUNELElBZk8sRUFBUjtBQWdCRDs7QUFFRDs7QUFHQSxLQUFJSyxNQUFNLENBQVY7O0FBRUE7Ozs7QUFJQSxLQUFJQyxNQUFNLFNBQVNBLEdBQVQsR0FBZ0I7QUFDeEIsUUFBSzFQLEVBQUwsR0FBVXlQLEtBQVY7QUFDQSxRQUFLRSxJQUFMLEdBQVksRUFBWjtBQUNELEVBSEQ7O0FBS0FELEtBQUlqVixTQUFKLENBQWNtVixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQzNDLFFBQUtGLElBQUwsQ0FBVTNELElBQVYsQ0FBZTZELEdBQWY7QUFDRCxFQUZEOztBQUlBSCxLQUFJalYsU0FBSixDQUFjcVYsU0FBZCxHQUEwQixTQUFTQSxTQUFULENBQW9CRCxHQUFwQixFQUF5QjtBQUNqRGxMLFVBQU8sS0FBS2dMLElBQVosRUFBa0JFLEdBQWxCO0FBQ0QsRUFGRDs7QUFJQUgsS0FBSWpWLFNBQUosQ0FBY3NWLE1BQWQsR0FBdUIsU0FBU0EsTUFBVCxHQUFtQjtBQUN4QyxPQUFJTCxJQUFJTSxNQUFSLEVBQWdCO0FBQ2ROLFNBQUlNLE1BQUosQ0FBV0MsTUFBWCxDQUFrQixJQUFsQjtBQUNEO0FBQ0YsRUFKRDs7QUFNQVAsS0FBSWpWLFNBQUosQ0FBY3lWLE1BQWQsR0FBdUIsU0FBU0EsTUFBVCxHQUFtQjtBQUN4QztBQUNBLE9BQUlQLE9BQU8sS0FBS0EsSUFBTCxDQUFVM1MsS0FBVixFQUFYO0FBQ0EsUUFBSyxJQUFJNUIsSUFBSSxDQUFSLEVBQVcrSyxJQUFJd0osS0FBS3RVLE1BQXpCLEVBQWlDRCxJQUFJK0ssQ0FBckMsRUFBd0MvSyxHQUF4QyxFQUE2QztBQUMzQ3VVLFVBQUt2VSxDQUFMLEVBQVErVSxNQUFSO0FBQ0Q7QUFDRixFQU5EOztBQVFBO0FBQ0E7QUFDQTtBQUNBVCxLQUFJTSxNQUFKLEdBQWEsSUFBYjtBQUNBLEtBQUlJLGNBQWMsRUFBbEI7O0FBRUEsVUFBU0MsVUFBVCxDQUFxQkMsT0FBckIsRUFBOEI7QUFDNUIsT0FBSVosSUFBSU0sTUFBUixFQUFnQjtBQUFFSSxpQkFBWXBFLElBQVosQ0FBaUIwRCxJQUFJTSxNQUFyQjtBQUErQjtBQUNqRE4sT0FBSU0sTUFBSixHQUFhTSxPQUFiO0FBQ0Q7O0FBRUQsVUFBU0MsU0FBVCxHQUFzQjtBQUNwQmIsT0FBSU0sTUFBSixHQUFhSSxZQUFZSSxHQUFaLEVBQWI7QUFDRDs7QUFFRDs7Ozs7QUFLQSxLQUFJQyxhQUFhakssTUFBTS9MLFNBQXZCO0FBQ0EsS0FBSWlXLGVBQWUxTyxPQUFPcUMsTUFBUCxDQUFjb00sVUFBZCxDQUFuQixDQUE2QyxDQUMzQyxNQUQyQyxFQUUzQyxLQUYyQyxFQUczQyxPQUgyQyxFQUkzQyxTQUoyQyxFQUszQyxRQUwyQyxFQU0zQyxNQU4yQyxFQU8zQyxTQVAyQyxFQVM1Q3ZPLE9BVDRDLENBU3BDLFVBQVU1SCxNQUFWLEVBQWtCO0FBQ3pCO0FBQ0EsT0FBSXFXLFdBQVdGLFdBQVduVyxNQUFYLENBQWY7QUFDQXdQLE9BQUk0RyxZQUFKLEVBQWtCcFcsTUFBbEIsRUFBMEIsU0FBU3NXLE9BQVQsR0FBb0I7QUFDNUMsU0FBSUMsT0FBTyxFQUFYO0FBQUEsU0FBZUMsTUFBTWpXLFVBQVVRLE1BQS9CO0FBQ0EsWUFBUXlWLEtBQVI7QUFBZ0JELFlBQU1DLEdBQU4sSUFBY2pXLFVBQVdpVyxHQUFYLENBQWQ7QUFBaEIsTUFFQSxJQUFJQyxTQUFTSixTQUFTL1YsS0FBVCxDQUFlLElBQWYsRUFBcUJpVyxJQUFyQixDQUFiO0FBQ0EsU0FBSUcsS0FBSyxLQUFLQyxNQUFkO0FBQ0EsU0FBSUMsUUFBSjtBQUNBLGFBQVE1VyxNQUFSO0FBQ0UsWUFBSyxNQUFMO0FBQ0EsWUFBSyxTQUFMO0FBQ0U0VyxvQkFBV0wsSUFBWDtBQUNBO0FBQ0YsWUFBSyxRQUFMO0FBQ0VLLG9CQUFXTCxLQUFLN1QsS0FBTCxDQUFXLENBQVgsQ0FBWDtBQUNBO0FBUEo7QUFTQSxTQUFJa1UsUUFBSixFQUFjO0FBQUVGLFVBQUdHLFlBQUgsQ0FBZ0JELFFBQWhCO0FBQTRCO0FBQzVDO0FBQ0FGLFFBQUdJLEdBQUgsQ0FBT2xCLE1BQVA7QUFDQSxZQUFPYSxNQUFQO0FBQ0QsSUFwQkQ7QUFxQkQsRUFqQzRDOztBQW1DN0M7O0FBRUEsS0FBSU0sWUFBWXJQLE9BQU9zUCxtQkFBUCxDQUEyQlosWUFBM0IsQ0FBaEI7O0FBRUE7Ozs7OztBQU1BLEtBQUlhLGdCQUFnQjtBQUNsQkMsa0JBQWU7QUFERyxFQUFwQjs7QUFJQTs7Ozs7O0FBTUEsS0FBSUMsV0FBVyxTQUFTQSxRQUFULENBQW1CMU8sS0FBbkIsRUFBMEI7QUFDdkMsUUFBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsUUFBS3FPLEdBQUwsR0FBVyxJQUFJMUIsR0FBSixFQUFYO0FBQ0EsUUFBS2dDLE9BQUwsR0FBZSxDQUFmO0FBQ0E1SCxPQUFJL0csS0FBSixFQUFXLFFBQVgsRUFBcUIsSUFBckI7QUFDQSxPQUFJeUQsTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixTQUFJNE8sVUFBVXZGLFdBQ1Z3RixZQURVLEdBRVZDLFdBRko7QUFHQUYsYUFBUTVPLEtBQVIsRUFBZTJOLFlBQWYsRUFBNkJXLFNBQTdCO0FBQ0EsVUFBS0YsWUFBTCxDQUFrQnBPLEtBQWxCO0FBQ0QsSUFORCxNQU1PO0FBQ0wsVUFBSytPLElBQUwsQ0FBVS9PLEtBQVY7QUFDRDtBQUNGLEVBZEQ7O0FBZ0JBOzs7OztBQUtBME8sVUFBU2hYLFNBQVQsQ0FBbUJxWCxJQUFuQixHQUEwQixTQUFTQSxJQUFULENBQWUxWCxHQUFmLEVBQW9CO0FBQzVDLE9BQUk2SCxPQUFPRCxPQUFPQyxJQUFQLENBQVk3SCxHQUFaLENBQVg7QUFDQSxRQUFLLElBQUlnQixJQUFJLENBQWIsRUFBZ0JBLElBQUk2RyxLQUFLNUcsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDMlcsdUJBQWtCM1gsR0FBbEIsRUFBdUI2SCxLQUFLN0csQ0FBTCxDQUF2QixFQUFnQ2hCLElBQUk2SCxLQUFLN0csQ0FBTCxDQUFKLENBQWhDO0FBQ0Q7QUFDRixFQUxEOztBQU9BOzs7QUFHQXFXLFVBQVNoWCxTQUFULENBQW1CMFcsWUFBbkIsR0FBa0MsU0FBU0EsWUFBVCxDQUF1QmEsS0FBdkIsRUFBOEI7QUFDOUQsUUFBSyxJQUFJNVcsSUFBSSxDQUFSLEVBQVcrSyxJQUFJNkwsTUFBTTNXLE1BQTFCLEVBQWtDRCxJQUFJK0ssQ0FBdEMsRUFBeUMvSyxHQUF6QyxFQUE4QztBQUM1QzBULGFBQVFrRCxNQUFNNVcsQ0FBTixDQUFSO0FBQ0Q7QUFDRixFQUpEOztBQU1BOztBQUVBOzs7O0FBSUEsVUFBU3dXLFlBQVQsQ0FBdUI1QixNQUF2QixFQUErQmlDLEdBQS9CLEVBQW9DaFEsSUFBcEMsRUFBMEM7QUFDeEM7QUFDQStOLFVBQU9rQyxTQUFQLEdBQW1CRCxHQUFuQjtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTtBQUNBLFVBQVNKLFdBQVQsQ0FBc0I3QixNQUF0QixFQUE4QmlDLEdBQTlCLEVBQW1DaFEsSUFBbkMsRUFBeUM7QUFDdkMsUUFBSyxJQUFJN0csSUFBSSxDQUFSLEVBQVcrSyxJQUFJbEUsS0FBSzVHLE1BQXpCLEVBQWlDRCxJQUFJK0ssQ0FBckMsRUFBd0MvSyxHQUF4QyxFQUE2QztBQUMzQyxTQUFJNkosTUFBTWhELEtBQUs3RyxDQUFMLENBQVY7QUFDQTBPLFNBQUlrRyxNQUFKLEVBQVkvSyxHQUFaLEVBQWlCZ04sSUFBSWhOLEdBQUosQ0FBakI7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFVBQVM2SixPQUFULENBQWtCL0wsS0FBbEIsRUFBeUJvUCxVQUF6QixFQUFxQztBQUNuQyxPQUFJLENBQUNuUCxTQUFTRCxLQUFULENBQUwsRUFBc0I7QUFDcEI7QUFDRDtBQUNELE9BQUlpTyxFQUFKO0FBQ0EsT0FBSWhNLE9BQU9qQyxLQUFQLEVBQWMsUUFBZCxLQUEyQkEsTUFBTWtPLE1BQU4sWUFBd0JRLFFBQXZELEVBQWlFO0FBQy9EVCxVQUFLak8sTUFBTWtPLE1BQVg7QUFDRCxJQUZELE1BRU8sSUFDTE0sY0FBY0MsYUFBZCxJQUNBLENBQUNuRSxtQkFERCxLQUVDN0csTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsS0FBd0JJLGNBQWNKLEtBQWQsQ0FGekIsS0FHQWYsT0FBT29RLFlBQVAsQ0FBb0JyUCxLQUFwQixDQUhBLElBSUEsQ0FBQ0EsTUFBTXFJLE1BTEYsRUFNTDtBQUNBNEYsVUFBSyxJQUFJUyxRQUFKLENBQWExTyxLQUFiLENBQUw7QUFDRDtBQUNELE9BQUlvUCxjQUFjbkIsRUFBbEIsRUFBc0I7QUFDcEJBLFFBQUdVLE9BQUg7QUFDRDtBQUNELFVBQU9WLEVBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU2UsaUJBQVQsQ0FDRTNYLEdBREYsRUFFRTZLLEdBRkYsRUFHRTNCLEdBSEYsRUFJRStPLFlBSkYsRUFLRUMsT0FMRixFQU1FO0FBQ0EsT0FBSWxCLE1BQU0sSUFBSTFCLEdBQUosRUFBVjs7QUFFQSxPQUFJNkMsV0FBV3ZRLE9BQU93USx3QkFBUCxDQUFnQ3BZLEdBQWhDLEVBQXFDNkssR0FBckMsQ0FBZjtBQUNBLE9BQUlzTixZQUFZQSxTQUFTckksWUFBVCxLQUEwQixLQUExQyxFQUFpRDtBQUMvQztBQUNEOztBQUVEO0FBQ0EsT0FBSXVJLFNBQVNGLFlBQVlBLFNBQVNyRixHQUFsQztBQUNBLE9BQUl3RixTQUFTSCxZQUFZQSxTQUFTbEQsR0FBbEM7O0FBRUEsT0FBSXNELFVBQVUsQ0FBQ0wsT0FBRCxJQUFZeEQsUUFBUXhMLEdBQVIsQ0FBMUI7QUFDQXRCLFVBQU9nSSxjQUFQLENBQXNCNVAsR0FBdEIsRUFBMkI2SyxHQUEzQixFQUFnQztBQUM5QjhFLGlCQUFZLElBRGtCO0FBRTlCRyxtQkFBYyxJQUZnQjtBQUc5QmdELFVBQUssU0FBUzBGLGNBQVQsR0FBMkI7QUFDOUIsV0FBSTdQLFFBQVEwUCxTQUFTQSxPQUFPL1gsSUFBUCxDQUFZTixHQUFaLENBQVQsR0FBNEJrSixHQUF4QztBQUNBLFdBQUlvTSxJQUFJTSxNQUFSLEVBQWdCO0FBQ2RvQixhQUFJckIsTUFBSjtBQUNBLGFBQUk0QyxPQUFKLEVBQWE7QUFDWEEsbUJBQVF2QixHQUFSLENBQVlyQixNQUFaO0FBQ0Q7QUFDRCxhQUFJdkosTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBSixFQUEwQjtBQUN4QjhQLHVCQUFZOVAsS0FBWjtBQUNEO0FBQ0Y7QUFDRCxjQUFPQSxLQUFQO0FBQ0QsTUFmNkI7QUFnQjlCc00sVUFBSyxTQUFTeUQsY0FBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDcEMsV0FBSWhRLFFBQVEwUCxTQUFTQSxPQUFPL1gsSUFBUCxDQUFZTixHQUFaLENBQVQsR0FBNEJrSixHQUF4QztBQUNBO0FBQ0EsV0FBSXlQLFdBQVdoUSxLQUFYLElBQXFCZ1EsV0FBV0EsTUFBWCxJQUFxQmhRLFVBQVVBLEtBQXhELEVBQWdFO0FBQzlEO0FBQ0Q7QUFDRDtBQUNBLFdBQUkyRixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUN5SixZQUE3QyxFQUEyRDtBQUN6REE7QUFDRDtBQUNELFdBQUlLLE1BQUosRUFBWTtBQUNWQSxnQkFBT2hZLElBQVAsQ0FBWU4sR0FBWixFQUFpQjJZLE1BQWpCO0FBQ0QsUUFGRCxNQUVPO0FBQ0x6UCxlQUFNeVAsTUFBTjtBQUNEO0FBQ0RKLGlCQUFVLENBQUNMLE9BQUQsSUFBWXhELFFBQVFpRSxNQUFSLENBQXRCO0FBQ0EzQixXQUFJbEIsTUFBSjtBQUNEO0FBakM2QixJQUFoQztBQW1DRDs7QUFFRDs7Ozs7QUFLQSxVQUFTYixHQUFULENBQWNXLE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQjNCLEdBQTNCLEVBQWdDO0FBQzlCLE9BQUlrRCxNQUFNbUIsT0FBTixDQUFjcUksTUFBZCxLQUF5QjNNLGtCQUFrQjRCLEdBQWxCLENBQTdCLEVBQXFEO0FBQ25EK0ssWUFBTzNVLE1BQVAsR0FBZ0JvSSxLQUFLdVAsR0FBTCxDQUFTaEQsT0FBTzNVLE1BQWhCLEVBQXdCNEosR0FBeEIsQ0FBaEI7QUFDQStLLFlBQU9sTCxNQUFQLENBQWNHLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0IzQixHQUF0QjtBQUNBLFlBQU9BLEdBQVA7QUFDRDtBQUNELE9BQUkwQixPQUFPZ0wsTUFBUCxFQUFlL0ssR0FBZixDQUFKLEVBQXlCO0FBQ3ZCK0ssWUFBTy9LLEdBQVAsSUFBYzNCLEdBQWQ7QUFDQSxZQUFPQSxHQUFQO0FBQ0Q7QUFDRCxPQUFJME4sS0FBTWhCLE1BQUQsQ0FBU2lCLE1BQWxCO0FBQ0EsT0FBSWpCLE9BQU81RSxNQUFQLElBQWtCNEYsTUFBTUEsR0FBR1UsT0FBL0IsRUFBeUM7QUFDdkNoSixhQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2QywwRUFDQSxxREFGdUMsQ0FBekM7QUFJQSxZQUFPbEgsR0FBUDtBQUNEO0FBQ0QsT0FBSSxDQUFDME4sRUFBTCxFQUFTO0FBQ1BoQixZQUFPL0ssR0FBUCxJQUFjM0IsR0FBZDtBQUNBLFlBQU9BLEdBQVA7QUFDRDtBQUNEeU8scUJBQWtCZixHQUFHak8sS0FBckIsRUFBNEJrQyxHQUE1QixFQUFpQzNCLEdBQWpDO0FBQ0EwTixNQUFHSSxHQUFILENBQU9sQixNQUFQO0FBQ0EsVUFBTzVNLEdBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBUzJQLEdBQVQsQ0FBY2pELE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQjtBQUN6QixPQUFJdUIsTUFBTW1CLE9BQU4sQ0FBY3FJLE1BQWQsS0FBeUIzTSxrQkFBa0I0QixHQUFsQixDQUE3QixFQUFxRDtBQUNuRCtLLFlBQU9sTCxNQUFQLENBQWNHLEdBQWQsRUFBbUIsQ0FBbkI7QUFDQTtBQUNEO0FBQ0QsT0FBSStMLEtBQU1oQixNQUFELENBQVNpQixNQUFsQjtBQUNBLE9BQUlqQixPQUFPNUUsTUFBUCxJQUFrQjRGLE1BQU1BLEdBQUdVLE9BQS9CLEVBQXlDO0FBQ3ZDaEosYUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsbUVBQ0Esd0JBRnVDLENBQXpDO0FBSUE7QUFDRDtBQUNELE9BQUksQ0FBQ3hGLE9BQU9nTCxNQUFQLEVBQWUvSyxHQUFmLENBQUwsRUFBMEI7QUFDeEI7QUFDRDtBQUNELFVBQU8rSyxPQUFPL0ssR0FBUCxDQUFQO0FBQ0EsT0FBSSxDQUFDK0wsRUFBTCxFQUFTO0FBQ1A7QUFDRDtBQUNEQSxNQUFHSSxHQUFILENBQU9sQixNQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTMkMsV0FBVCxDQUFzQjlQLEtBQXRCLEVBQTZCO0FBQzNCLFFBQUssSUFBSXBJLElBQUssS0FBSyxDQUFkLEVBQWtCUyxJQUFJLENBQXRCLEVBQXlCK0ssSUFBSXBELE1BQU0xSCxNQUF4QyxFQUFnREQsSUFBSStLLENBQXBELEVBQXVEL0ssR0FBdkQsRUFBNEQ7QUFDMURULFNBQUlvSSxNQUFNM0gsQ0FBTixDQUFKO0FBQ0FULFVBQUtBLEVBQUVzVyxNQUFQLElBQWlCdFcsRUFBRXNXLE1BQUYsQ0FBU0csR0FBVCxDQUFhckIsTUFBYixFQUFqQjtBQUNBLFNBQUl2SixNQUFNbUIsT0FBTixDQUFjaE4sQ0FBZCxDQUFKLEVBQXNCO0FBQ3BCa1ksbUJBQVlsWSxDQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBOzs7OztBQUtBLEtBQUl1WSxTQUFTNUssT0FBT0MscUJBQXBCOztBQUVBOzs7QUFHQSxLQUFJRyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNzSyxVQUFPQyxFQUFQLEdBQVlELE9BQU9FLFNBQVAsR0FBbUIsVUFBVUMsTUFBVixFQUFrQkMsS0FBbEIsRUFBeUJ2SSxFQUF6QixFQUE2QjlGLEdBQTdCLEVBQWtDO0FBQy9ELFNBQUksQ0FBQzhGLEVBQUwsRUFBUztBQUNQUCxZQUNFLGNBQWN2RixHQUFkLEdBQW9CLHNDQUFwQixHQUNBLGtDQUZGO0FBSUQ7QUFDRCxZQUFPc08sYUFBYUYsTUFBYixFQUFxQkMsS0FBckIsQ0FBUDtBQUNELElBUkQ7QUFTRDs7QUFFRDs7O0FBR0EsVUFBU0UsU0FBVCxDQUFvQjlNLEVBQXBCLEVBQXdCK00sSUFBeEIsRUFBOEI7QUFDNUIsT0FBSSxDQUFDQSxJQUFMLEVBQVc7QUFBRSxZQUFPL00sRUFBUDtBQUFXO0FBQ3hCLE9BQUl6QixHQUFKLEVBQVN5TyxLQUFULEVBQWdCQyxPQUFoQjtBQUNBLE9BQUkxUixPQUFPRCxPQUFPQyxJQUFQLENBQVl3UixJQUFaLENBQVg7QUFDQSxRQUFLLElBQUlyWSxJQUFJLENBQWIsRUFBZ0JBLElBQUk2RyxLQUFLNUcsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDNkosV0FBTWhELEtBQUs3RyxDQUFMLENBQU47QUFDQXNZLGFBQVFoTixHQUFHekIsR0FBSCxDQUFSO0FBQ0EwTyxlQUFVRixLQUFLeE8sR0FBTCxDQUFWO0FBQ0EsU0FBSSxDQUFDRCxPQUFPMEIsRUFBUCxFQUFXekIsR0FBWCxDQUFMLEVBQXNCO0FBQ3BCb0ssV0FBSTNJLEVBQUosRUFBUXpCLEdBQVIsRUFBYTBPLE9BQWI7QUFDRCxNQUZELE1BRU8sSUFBSXhRLGNBQWN1USxLQUFkLEtBQXdCdlEsY0FBY3dRLE9BQWQsQ0FBNUIsRUFBb0Q7QUFDekRILGlCQUFVRSxLQUFWLEVBQWlCQyxPQUFqQjtBQUNEO0FBQ0Y7QUFDRCxVQUFPak4sRUFBUDtBQUNEOztBQUVEOzs7QUFHQSxVQUFTa04sYUFBVCxDQUNFQyxTQURGLEVBRUVDLFFBRkYsRUFHRS9JLEVBSEYsRUFJRTtBQUNBLE9BQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1A7QUFDQSxTQUFJLENBQUMrSSxRQUFMLEVBQWU7QUFDYixjQUFPRCxTQUFQO0FBQ0Q7QUFDRCxTQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZCxjQUFPQyxRQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBTyxTQUFTQyxZQUFULEdBQXlCO0FBQzlCLGNBQU9QLFVBQ0wsT0FBT00sUUFBUCxLQUFvQixVQUFwQixHQUFpQ0EsU0FBU3BaLElBQVQsQ0FBYyxJQUFkLENBQWpDLEdBQXVEb1osUUFEbEQsRUFFTCxPQUFPRCxTQUFQLEtBQXFCLFVBQXJCLEdBQWtDQSxVQUFVblosSUFBVixDQUFlLElBQWYsQ0FBbEMsR0FBeURtWixTQUZwRCxDQUFQO0FBSUQsTUFMRDtBQU1ELElBbkJELE1BbUJPLElBQUlBLGFBQWFDLFFBQWpCLEVBQTJCO0FBQ2hDLFlBQU8sU0FBU0Usb0JBQVQsR0FBaUM7QUFDdEM7QUFDQSxXQUFJQyxlQUFlLE9BQU9ILFFBQVAsS0FBb0IsVUFBcEIsR0FDZkEsU0FBU3BaLElBQVQsQ0FBY3FRLEVBQWQsQ0FEZSxHQUVmK0ksUUFGSjtBQUdBLFdBQUlJLGNBQWMsT0FBT0wsU0FBUCxLQUFxQixVQUFyQixHQUNkQSxVQUFVblosSUFBVixDQUFlcVEsRUFBZixDQURjLEdBRWQvUCxTQUZKO0FBR0EsV0FBSWlaLFlBQUosRUFBa0I7QUFDaEIsZ0JBQU9ULFVBQVVTLFlBQVYsRUFBd0JDLFdBQXhCLENBQVA7QUFDRCxRQUZELE1BRU87QUFDTCxnQkFBT0EsV0FBUDtBQUNEO0FBQ0YsTUFiRDtBQWNEO0FBQ0Y7O0FBRURoQixRQUFPdlMsSUFBUCxHQUFjLFVBQ1prVCxTQURZLEVBRVpDLFFBRlksRUFHWi9JLEVBSFksRUFJWjtBQUNBLE9BQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1AsU0FBSStJLFlBQVksT0FBT0EsUUFBUCxLQUFvQixVQUFwQyxFQUFnRDtBQUM5Q3BMLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLDRDQUNBLGlEQURBLEdBRUEsY0FIdUMsRUFJdkNPLEVBSnVDLENBQXpDOztBQU9BLGNBQU84SSxTQUFQO0FBQ0Q7QUFDRCxZQUFPRCxjQUFjbFosSUFBZCxDQUFtQixJQUFuQixFQUF5Qm1aLFNBQXpCLEVBQW9DQyxRQUFwQyxDQUFQO0FBQ0Q7O0FBRUQsVUFBT0YsY0FBY0MsU0FBZCxFQUF5QkMsUUFBekIsRUFBbUMvSSxFQUFuQyxDQUFQO0FBQ0QsRUFwQkQ7O0FBc0JBOzs7QUFHQSxVQUFTb0osU0FBVCxDQUNFTixTQURGLEVBRUVDLFFBRkYsRUFHRTtBQUNBLFVBQU9BLFdBQ0hELFlBQ0VBLFVBQVV6TSxNQUFWLENBQWlCME0sUUFBakIsQ0FERixHQUVFdE4sTUFBTW1CLE9BQU4sQ0FBY21NLFFBQWQsSUFDRUEsUUFERixHQUVFLENBQUNBLFFBQUQsQ0FMRCxHQU1IRCxTQU5KO0FBT0Q7O0FBRUR4TCxpQkFBZ0JuRyxPQUFoQixDQUF3QixVQUFVa1MsSUFBVixFQUFnQjtBQUN0Q2xCLFVBQU9rQixJQUFQLElBQWVELFNBQWY7QUFDRCxFQUZEOztBQUlBOzs7Ozs7O0FBT0EsVUFBU0UsV0FBVCxDQUFzQlIsU0FBdEIsRUFBaUNDLFFBQWpDLEVBQTJDO0FBQ3pDLE9BQUk1VCxNQUFNOEIsT0FBT3FDLE1BQVAsQ0FBY3dQLGFBQWEsSUFBM0IsQ0FBVjtBQUNBLFVBQU9DLFdBQ0hyTixPQUFPdkcsR0FBUCxFQUFZNFQsUUFBWixDQURHLEdBRUg1VCxHQUZKO0FBR0Q7O0FBRURrSSxhQUFZbEcsT0FBWixDQUFvQixVQUFVb1MsSUFBVixFQUFnQjtBQUNsQ3BCLFVBQU9vQixPQUFPLEdBQWQsSUFBcUJELFdBQXJCO0FBQ0QsRUFGRDs7QUFJQTs7Ozs7O0FBTUFuQixRQUFPbkcsS0FBUCxHQUFlLFVBQVU4RyxTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtBQUM1QztBQUNBLE9BQUlELGNBQWMvRyxXQUFsQixFQUErQjtBQUFFK0csaUJBQVk3WSxTQUFaO0FBQXdCO0FBQ3pELE9BQUk4WSxhQUFhaEgsV0FBakIsRUFBOEI7QUFBRWdILGdCQUFXOVksU0FBWDtBQUF1QjtBQUN2RDtBQUNBLE9BQUksQ0FBQzhZLFFBQUwsRUFBZTtBQUFFLFlBQU85UixPQUFPcUMsTUFBUCxDQUFjd1AsYUFBYSxJQUEzQixDQUFQO0FBQXlDO0FBQzFELE9BQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUFFLFlBQU9DLFFBQVA7QUFBaUI7QUFDbkMsT0FBSXZOLE1BQU0sRUFBVjtBQUNBRSxVQUFPRixHQUFQLEVBQVlzTixTQUFaO0FBQ0EsUUFBSyxJQUFJNU8sR0FBVCxJQUFnQjZPLFFBQWhCLEVBQTBCO0FBQ3hCLFNBQUlULFNBQVM5TSxJQUFJdEIsR0FBSixDQUFiO0FBQ0EsU0FBSXFPLFFBQVFRLFNBQVM3TyxHQUFULENBQVo7QUFDQSxTQUFJb08sVUFBVSxDQUFDN00sTUFBTW1CLE9BQU4sQ0FBYzBMLE1BQWQsQ0FBZixFQUFzQztBQUNwQ0EsZ0JBQVMsQ0FBQ0EsTUFBRCxDQUFUO0FBQ0Q7QUFDRDlNLFNBQUl0QixHQUFKLElBQVdvTyxTQUNQQSxPQUFPak0sTUFBUCxDQUFja00sS0FBZCxDQURPLEdBRVA5TSxNQUFNbUIsT0FBTixDQUFjMkwsS0FBZCxJQUF1QkEsS0FBdkIsR0FBK0IsQ0FBQ0EsS0FBRCxDQUZuQztBQUdEO0FBQ0QsVUFBTy9NLEdBQVA7QUFDRCxFQXBCRDs7QUFzQkE7OztBQUdBMk0sUUFBT3FCLEtBQVAsR0FDQXJCLE9BQU9zQixPQUFQLEdBQ0F0QixPQUFPdUIsTUFBUCxHQUNBdkIsT0FBT3dCLFFBQVAsR0FBa0IsVUFBVWIsU0FBVixFQUFxQkMsUUFBckIsRUFBK0I7QUFDL0MsT0FBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQUUsWUFBT0MsUUFBUDtBQUFpQjtBQUNuQyxPQUFJdk4sTUFBTXZFLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFWO0FBQ0FvQyxVQUFPRixHQUFQLEVBQVlzTixTQUFaO0FBQ0EsT0FBSUMsUUFBSixFQUFjO0FBQUVyTixZQUFPRixHQUFQLEVBQVl1TixRQUFaO0FBQXdCO0FBQ3hDLFVBQU92TixHQUFQO0FBQ0QsRUFURDtBQVVBMk0sUUFBT3lCLE9BQVAsR0FBaUJmLGFBQWpCOztBQUVBOzs7QUFHQSxLQUFJTCxlQUFlLFNBQWZBLFlBQWUsQ0FBVU0sU0FBVixFQUFxQkMsUUFBckIsRUFBK0I7QUFDaEQsVUFBT0EsYUFBYTlZLFNBQWIsR0FDSDZZLFNBREcsR0FFSEMsUUFGSjtBQUdELEVBSkQ7O0FBTUE7OztBQUdBLFVBQVNjLGVBQVQsQ0FBMEJ6SixPQUExQixFQUFtQztBQUNqQyxRQUFLLElBQUlsRyxHQUFULElBQWdCa0csUUFBUTBKLFVBQXhCLEVBQW9DO0FBQ2xDLFNBQUlDLFFBQVE3UCxJQUFJVCxXQUFKLEVBQVo7QUFDQSxTQUFJQyxhQUFhcVEsS0FBYixLQUF1QnhNLE9BQU9hLGFBQVAsQ0FBcUIyTCxLQUFyQixDQUEzQixFQUF3RDtBQUN0RHRLLFlBQ0UsZ0VBQ0EsTUFEQSxHQUNTdkYsR0FGWDtBQUlEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVM4UCxjQUFULENBQXlCNUosT0FBekIsRUFBa0M7QUFDaEMsT0FBSW9KLFFBQVFwSixRQUFRb0osS0FBcEI7QUFDQSxPQUFJLENBQUNBLEtBQUwsRUFBWTtBQUFFO0FBQVE7QUFDdEIsT0FBSXJVLE1BQU0sRUFBVjtBQUNBLE9BQUk5RSxDQUFKLEVBQU9rSSxHQUFQLEVBQVkzSCxJQUFaO0FBQ0EsT0FBSTZLLE1BQU1tQixPQUFOLENBQWM0TSxLQUFkLENBQUosRUFBMEI7QUFDeEJuWixTQUFJbVosTUFBTWxaLE1BQVY7QUFDQSxZQUFPRCxHQUFQLEVBQVk7QUFDVmtJLGFBQU1pUixNQUFNblosQ0FBTixDQUFOO0FBQ0EsV0FBSSxPQUFPa0ksR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCM0gsZ0JBQU82SixTQUFTbEMsR0FBVCxDQUFQO0FBQ0FwRCxhQUFJdkUsSUFBSixJQUFZLEVBQUUyWSxNQUFNLElBQVIsRUFBWjtBQUNELFFBSEQsTUFHTyxJQUFJNUwsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hENEIsY0FBSyxnREFBTDtBQUNEO0FBQ0Y7QUFDRixJQVhELE1BV08sSUFBSXJILGNBQWNvUixLQUFkLENBQUosRUFBMEI7QUFDL0IsVUFBSyxJQUFJdFAsR0FBVCxJQUFnQnNQLEtBQWhCLEVBQXVCO0FBQ3JCalIsYUFBTWlSLE1BQU10UCxHQUFOLENBQU47QUFDQXRKLGNBQU82SixTQUFTUCxHQUFULENBQVA7QUFDQS9FLFdBQUl2RSxJQUFKLElBQVl3SCxjQUFjRyxHQUFkLElBQ1JBLEdBRFEsR0FFUixFQUFFZ1IsTUFBTWhSLEdBQVIsRUFGSjtBQUdEO0FBQ0Y7QUFDRDZILFdBQVFvSixLQUFSLEdBQWdCclUsR0FBaEI7QUFDRDs7QUFFRDs7O0FBR0EsVUFBUzhVLGVBQVQsQ0FBMEI3SixPQUExQixFQUFtQztBQUNqQyxPQUFJc0osU0FBU3RKLFFBQVFzSixNQUFyQjtBQUNBLE9BQUlqTyxNQUFNbUIsT0FBTixDQUFjOE0sTUFBZCxDQUFKLEVBQTJCO0FBQ3pCLFNBQUlRLGFBQWE5SixRQUFRc0osTUFBUixHQUFpQixFQUFsQztBQUNBLFVBQUssSUFBSXJaLElBQUksQ0FBYixFQUFnQkEsSUFBSXFaLE9BQU9wWixNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDdEM2WixrQkFBV1IsT0FBT3JaLENBQVAsQ0FBWCxJQUF3QnFaLE9BQU9yWixDQUFQLENBQXhCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7QUFHQSxVQUFTOFosbUJBQVQsQ0FBOEIvSixPQUE5QixFQUF1QztBQUNyQyxPQUFJZ0ssT0FBT2hLLFFBQVFpSyxVQUFuQjtBQUNBLE9BQUlELElBQUosRUFBVTtBQUNSLFVBQUssSUFBSWxRLEdBQVQsSUFBZ0JrUSxJQUFoQixFQUFzQjtBQUNwQixXQUFJckwsTUFBTXFMLEtBQUtsUSxHQUFMLENBQVY7QUFDQSxXQUFJLE9BQU82RSxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0JxTCxjQUFLbFEsR0FBTCxJQUFZLEVBQUUxSyxNQUFNdVAsR0FBUixFQUFhcUcsUUFBUXJHLEdBQXJCLEVBQVo7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVN1TCxZQUFULENBQ0VoQyxNQURGLEVBRUVDLEtBRkYsRUFHRXZJLEVBSEYsRUFJRTtBQUNBLE9BQUlyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnTSxxQkFBZ0J0QixLQUFoQjtBQUNEOztBQUVELE9BQUksT0FBT0EsS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUMvQkEsYUFBUUEsTUFBTW5JLE9BQWQ7QUFDRDs7QUFFRDRKLGtCQUFlekIsS0FBZjtBQUNBMEIsbUJBQWdCMUIsS0FBaEI7QUFDQTRCLHVCQUFvQjVCLEtBQXBCO0FBQ0EsT0FBSWdDLGNBQWNoQyxNQUFNaUMsT0FBeEI7QUFDQSxPQUFJRCxXQUFKLEVBQWlCO0FBQ2ZqQyxjQUFTZ0MsYUFBYWhDLE1BQWIsRUFBcUJpQyxXQUFyQixFQUFrQ3ZLLEVBQWxDLENBQVQ7QUFDRDtBQUNELE9BQUl1SSxNQUFNa0MsTUFBVixFQUFrQjtBQUNoQixVQUFLLElBQUlwYSxJQUFJLENBQVIsRUFBVytLLElBQUltTixNQUFNa0MsTUFBTixDQUFhbmEsTUFBakMsRUFBeUNELElBQUkrSyxDQUE3QyxFQUFnRC9LLEdBQWhELEVBQXFEO0FBQ25EaVksZ0JBQVNnQyxhQUFhaEMsTUFBYixFQUFxQkMsTUFBTWtDLE1BQU4sQ0FBYXBhLENBQWIsQ0FBckIsRUFBc0MyUCxFQUF0QyxDQUFUO0FBQ0Q7QUFDRjtBQUNELE9BQUlJLFVBQVUsRUFBZDtBQUNBLE9BQUlsRyxHQUFKO0FBQ0EsUUFBS0EsR0FBTCxJQUFZb08sTUFBWixFQUFvQjtBQUNsQm9DLGdCQUFXeFEsR0FBWDtBQUNEO0FBQ0QsUUFBS0EsR0FBTCxJQUFZcU8sS0FBWixFQUFtQjtBQUNqQixTQUFJLENBQUN0TyxPQUFPcU8sTUFBUCxFQUFlcE8sR0FBZixDQUFMLEVBQTBCO0FBQ3hCd1Esa0JBQVd4USxHQUFYO0FBQ0Q7QUFDRjtBQUNELFlBQVN3USxVQUFULENBQXFCeFEsR0FBckIsRUFBMEI7QUFDeEIsU0FBSXlRLFFBQVF4QyxPQUFPak8sR0FBUCxLQUFlc08sWUFBM0I7QUFDQXBJLGFBQVFsRyxHQUFSLElBQWV5USxNQUFNckMsT0FBT3BPLEdBQVAsQ0FBTixFQUFtQnFPLE1BQU1yTyxHQUFOLENBQW5CLEVBQStCOEYsRUFBL0IsRUFBbUM5RixHQUFuQyxDQUFmO0FBQ0Q7QUFDRCxVQUFPa0csT0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFVBQVN3SyxZQUFULENBQ0V4SyxPQURGLEVBRUVtSixJQUZGLEVBR0V0VSxFQUhGLEVBSUU0VixXQUpGLEVBS0U7QUFDQTtBQUNBLE9BQUksT0FBTzVWLEVBQVAsS0FBYyxRQUFsQixFQUE0QjtBQUMxQjtBQUNEO0FBQ0QsT0FBSTZWLFNBQVMxSyxRQUFRbUosSUFBUixDQUFiO0FBQ0E7QUFDQSxPQUFJdFAsT0FBTzZRLE1BQVAsRUFBZTdWLEVBQWYsQ0FBSixFQUF3QjtBQUFFLFlBQU82VixPQUFPN1YsRUFBUCxDQUFQO0FBQW1CO0FBQzdDLE9BQUk4VixjQUFjdFEsU0FBU3hGLEVBQVQsQ0FBbEI7QUFDQSxPQUFJZ0YsT0FBTzZRLE1BQVAsRUFBZUMsV0FBZixDQUFKLEVBQWlDO0FBQUUsWUFBT0QsT0FBT0MsV0FBUCxDQUFQO0FBQTRCO0FBQy9ELE9BQUlDLGVBQWVuUSxXQUFXa1EsV0FBWCxDQUFuQjtBQUNBLE9BQUk5USxPQUFPNlEsTUFBUCxFQUFlRSxZQUFmLENBQUosRUFBa0M7QUFBRSxZQUFPRixPQUFPRSxZQUFQLENBQVA7QUFBNkI7QUFDakU7QUFDQSxPQUFJN1YsTUFBTTJWLE9BQU83VixFQUFQLEtBQWM2VixPQUFPQyxXQUFQLENBQWQsSUFBcUNELE9BQU9FLFlBQVAsQ0FBL0M7QUFDQSxPQUFJck4sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDZ04sV0FBekMsSUFBd0QsQ0FBQzFWLEdBQTdELEVBQWtFO0FBQ2hFc0ssVUFDRSx1QkFBdUI4SixLQUFLdFgsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLENBQWYsQ0FBdkIsR0FBMkMsSUFBM0MsR0FBa0RnRCxFQURwRCxFQUVFbUwsT0FGRjtBQUlEO0FBQ0QsVUFBT2pMLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxVQUFTOFYsWUFBVCxDQUNFL1EsR0FERixFQUVFZ1IsV0FGRixFQUdFN0MsU0FIRixFQUlFckksRUFKRixFQUtFO0FBQ0EsT0FBSW1MLE9BQU9ELFlBQVloUixHQUFaLENBQVg7QUFDQSxPQUFJa1IsU0FBUyxDQUFDblIsT0FBT29PLFNBQVAsRUFBa0JuTyxHQUFsQixDQUFkO0FBQ0EsT0FBSWxDLFFBQVFxUSxVQUFVbk8sR0FBVixDQUFaO0FBQ0E7QUFDQSxPQUFJbVIsT0FBT0MsT0FBUCxFQUFnQkgsS0FBSzVCLElBQXJCLENBQUosRUFBZ0M7QUFDOUIsU0FBSTZCLFVBQVUsQ0FBQ25SLE9BQU9rUixJQUFQLEVBQWEsU0FBYixDQUFmLEVBQXdDO0FBQ3RDblQsZUFBUSxLQUFSO0FBQ0QsTUFGRCxNQUVPLElBQUksQ0FBQ3FULE9BQU90UyxNQUFQLEVBQWVvUyxLQUFLNUIsSUFBcEIsQ0FBRCxLQUErQnZSLFVBQVUsRUFBVixJQUFnQkEsVUFBVWdELFVBQVVkLEdBQVYsQ0FBekQsQ0FBSixFQUE4RTtBQUNuRmxDLGVBQVEsSUFBUjtBQUNEO0FBQ0Y7QUFDRDtBQUNBLE9BQUlBLFVBQVUvSCxTQUFkLEVBQXlCO0FBQ3ZCK0gsYUFBUXVULG9CQUFvQnZMLEVBQXBCLEVBQXdCbUwsSUFBeEIsRUFBOEJqUixHQUE5QixDQUFSO0FBQ0E7QUFDQTtBQUNBLFNBQUlzUixvQkFBb0JoRixjQUFjQyxhQUF0QztBQUNBRCxtQkFBY0MsYUFBZCxHQUE4QixJQUE5QjtBQUNBMUMsYUFBUS9MLEtBQVI7QUFDQXdPLG1CQUFjQyxhQUFkLEdBQThCK0UsaUJBQTlCO0FBQ0Q7QUFDRCxPQUFJN04sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNE4sZ0JBQVdOLElBQVgsRUFBaUJqUixHQUFqQixFQUFzQmxDLEtBQXRCLEVBQTZCZ0ksRUFBN0IsRUFBaUNvTCxNQUFqQztBQUNEO0FBQ0QsVUFBT3BULEtBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU3VULG1CQUFULENBQThCdkwsRUFBOUIsRUFBa0NtTCxJQUFsQyxFQUF3Q2pSLEdBQXhDLEVBQTZDO0FBQzNDO0FBQ0EsT0FBSSxDQUFDRCxPQUFPa1IsSUFBUCxFQUFhLFNBQWIsQ0FBTCxFQUE4QjtBQUM1QixZQUFPbGIsU0FBUDtBQUNEO0FBQ0QsT0FBSThPLE1BQU1vTSxLQUFLTyxPQUFmO0FBQ0E7QUFDQSxPQUFJL04sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNUYsU0FBUzhHLEdBQVQsQ0FBN0MsRUFBNEQ7QUFDMURVLFVBQ0UscUNBQXFDdkYsR0FBckMsR0FBMkMsS0FBM0MsR0FDQSwyREFEQSxHQUVBLDhCQUhGLEVBSUU4RixFQUpGO0FBTUQ7QUFDRDtBQUNBO0FBQ0EsT0FBSUEsTUFBTUEsR0FBR00sUUFBSCxDQUFZK0gsU0FBbEIsSUFDRnJJLEdBQUdNLFFBQUgsQ0FBWStILFNBQVosQ0FBc0JuTyxHQUF0QixNQUErQmpLLFNBRDdCLElBRUYrUCxHQUFHMkwsTUFBSCxDQUFVelIsR0FBVixNQUFtQmpLLFNBRnJCLEVBR0U7QUFDQSxZQUFPK1AsR0FBRzJMLE1BQUgsQ0FBVXpSLEdBQVYsQ0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFVBQU8sT0FBTzZFLEdBQVAsS0FBZSxVQUFmLElBQTZCNk0sUUFBUVQsS0FBSzVCLElBQWIsTUFBdUIsVUFBcEQsR0FDSHhLLElBQUlwUCxJQUFKLENBQVNxUSxFQUFULENBREcsR0FFSGpCLEdBRko7QUFHRDs7QUFFRDs7O0FBR0EsVUFBUzBNLFVBQVQsQ0FDRU4sSUFERixFQUVFdmEsSUFGRixFQUdFb0gsS0FIRixFQUlFZ0ksRUFKRixFQUtFb0wsTUFMRixFQU1FO0FBQ0EsT0FBSUQsS0FBS1UsUUFBTCxJQUFpQlQsTUFBckIsRUFBNkI7QUFDM0IzTCxVQUNFLDZCQUE2QjdPLElBQTdCLEdBQW9DLEdBRHRDLEVBRUVvUCxFQUZGO0FBSUE7QUFDRDtBQUNELE9BQUloSSxTQUFTLElBQVQsSUFBaUIsQ0FBQ21ULEtBQUtVLFFBQTNCLEVBQXFDO0FBQ25DO0FBQ0Q7QUFDRCxPQUFJdEMsT0FBTzRCLEtBQUs1QixJQUFoQjtBQUNBLE9BQUl1QyxRQUFRLENBQUN2QyxJQUFELElBQVNBLFNBQVMsSUFBOUI7QUFDQSxPQUFJd0MsZ0JBQWdCLEVBQXBCO0FBQ0EsT0FBSXhDLElBQUosRUFBVTtBQUNSLFNBQUksQ0FBQzlOLE1BQU1tQixPQUFOLENBQWMyTSxJQUFkLENBQUwsRUFBMEI7QUFDeEJBLGNBQU8sQ0FBQ0EsSUFBRCxDQUFQO0FBQ0Q7QUFDRCxVQUFLLElBQUlsWixJQUFJLENBQWIsRUFBZ0JBLElBQUlrWixLQUFLalosTUFBVCxJQUFtQixDQUFDd2IsS0FBcEMsRUFBMkN6YixHQUEzQyxFQUFnRDtBQUM5QyxXQUFJMmIsZUFBZUMsV0FBV2pVLEtBQVgsRUFBa0J1UixLQUFLbFosQ0FBTCxDQUFsQixDQUFuQjtBQUNBMGIscUJBQWM5SyxJQUFkLENBQW1CK0ssYUFBYUUsWUFBYixJQUE2QixFQUFoRDtBQUNBSixlQUFRRSxhQUFhRixLQUFyQjtBQUNEO0FBQ0Y7QUFDRCxPQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNWck0sVUFDRSwrQ0FBK0M3TyxJQUEvQyxHQUFzRCxJQUF0RCxHQUNBLFlBREEsR0FDZW1iLGNBQWMxUyxHQUFkLENBQWtCd0IsVUFBbEIsRUFBOEIwQixJQUE5QixDQUFtQyxJQUFuQyxDQURmLEdBRUEsUUFGQSxHQUVXdEYsT0FBT3ZILFNBQVAsQ0FBaUJ5SSxRQUFqQixDQUEwQnhJLElBQTFCLENBQStCcUksS0FBL0IsRUFBc0MvRixLQUF0QyxDQUE0QyxDQUE1QyxFQUErQyxDQUFDLENBQWhELENBRlgsR0FFZ0UsR0FIbEUsRUFJRStOLEVBSkY7QUFNQTtBQUNEO0FBQ0QsT0FBSW1NLFlBQVloQixLQUFLZ0IsU0FBckI7QUFDQSxPQUFJQSxTQUFKLEVBQWU7QUFDYixTQUFJLENBQUNBLFVBQVVuVSxLQUFWLENBQUwsRUFBdUI7QUFDckJ5SCxZQUNFLDJEQUEyRDdPLElBQTNELEdBQWtFLElBRHBFLEVBRUVvUCxFQUZGO0FBSUQ7QUFDRjtBQUNGOztBQUVELEtBQUlvTSxnQkFBZ0IsMkNBQXBCOztBQUVBLFVBQVNILFVBQVQsQ0FBcUJqVSxLQUFyQixFQUE0QnVSLElBQTVCLEVBQWtDO0FBQ2hDLE9BQUl1QyxLQUFKO0FBQ0EsT0FBSUksZUFBZU4sUUFBUXJDLElBQVIsQ0FBbkI7QUFDQSxPQUFJNkMsY0FBYzdNLElBQWQsQ0FBbUIyTSxZQUFuQixDQUFKLEVBQXNDO0FBQ3BDSixhQUFRLFFBQU85VCxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCa1UsYUFBYXpTLFdBQWIsRUFBekI7QUFDRCxJQUZELE1BRU8sSUFBSXlTLGlCQUFpQixRQUFyQixFQUErQjtBQUNwQ0osYUFBUTFULGNBQWNKLEtBQWQsQ0FBUjtBQUNELElBRk0sTUFFQSxJQUFJa1UsaUJBQWlCLE9BQXJCLEVBQThCO0FBQ25DSixhQUFRclEsTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBUjtBQUNELElBRk0sTUFFQTtBQUNMOFQsYUFBUTlULGlCQUFpQnVSLElBQXpCO0FBQ0Q7QUFDRCxVQUFPO0FBQ0x1QyxZQUFPQSxLQURGO0FBRUxJLG1CQUFjQTtBQUZULElBQVA7QUFJRDs7QUFFRDs7Ozs7QUFLQSxVQUFTTixPQUFULENBQWtCeFIsRUFBbEIsRUFBc0I7QUFDcEIsT0FBSXNHLFFBQVF0RyxNQUFNQSxHQUFHakMsUUFBSCxHQUFjdUksS0FBZCxDQUFvQixvQkFBcEIsQ0FBbEI7QUFDQSxVQUFPQSxRQUFRQSxNQUFNLENBQU4sQ0FBUixHQUFtQixFQUExQjtBQUNEOztBQUVELFVBQVMySyxNQUFULENBQWlCOUIsSUFBakIsRUFBdUJuUCxFQUF2QixFQUEyQjtBQUN6QixPQUFJLENBQUNxQixNQUFNbUIsT0FBTixDQUFjeEMsRUFBZCxDQUFMLEVBQXdCO0FBQ3RCLFlBQU93UixRQUFReFIsRUFBUixNQUFnQndSLFFBQVFyQyxJQUFSLENBQXZCO0FBQ0Q7QUFDRCxRQUFLLElBQUlsWixJQUFJLENBQVIsRUFBVzBWLE1BQU0zTCxHQUFHOUosTUFBekIsRUFBaUNELElBQUkwVixHQUFyQyxFQUEwQzFWLEdBQTFDLEVBQStDO0FBQzdDLFNBQUl1YixRQUFReFIsR0FBRy9KLENBQUgsQ0FBUixNQUFtQnViLFFBQVFyQyxJQUFSLENBQXZCLEVBQXNDO0FBQ3BDLGNBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFVBQU8sS0FBUDtBQUNEOztBQUVEOztBQUVBLEtBQUk4QyxJQUFKO0FBQ0EsS0FBSUMsT0FBSjs7QUFFQSxLQUFJM08sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE9BQUkwTyxPQUFPbkwsYUFBYTlQLE9BQU95TSxXQUEvQjtBQUNBO0FBQ0EsT0FDRXdPLFFBQ0FBLEtBQUtGLElBREwsSUFFQUUsS0FBS0QsT0FGTCxJQUdBQyxLQUFLQyxVQUhMLElBSUFELEtBQUtFLGFBTFAsRUFNRTtBQUNBSixZQUFPLGNBQVVLLEdBQVYsRUFBZTtBQUFFLGNBQU9ILEtBQUtGLElBQUwsQ0FBVUssR0FBVixDQUFQO0FBQXdCLE1BQWhEO0FBQ0FKLGVBQVUsaUJBQVUxYixJQUFWLEVBQWdCK2IsUUFBaEIsRUFBMEJDLE1BQTFCLEVBQWtDO0FBQzFDTCxZQUFLRCxPQUFMLENBQWExYixJQUFiLEVBQW1CK2IsUUFBbkIsRUFBNkJDLE1BQTdCO0FBQ0FMLFlBQUtDLFVBQUwsQ0FBZ0JHLFFBQWhCO0FBQ0FKLFlBQUtDLFVBQUwsQ0FBZ0JJLE1BQWhCO0FBQ0FMLFlBQUtFLGFBQUwsQ0FBbUI3YixJQUFuQjtBQUNELE1BTEQ7QUFNRDtBQUNGOztBQUVEOztBQUVBLEtBQUlpYyxTQUFKOztBQUVBLEtBQUlsUCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsT0FBSWlQLGlCQUFpQjVULFFBQ25CLDJDQUNBLGdGQURBLEdBRUEsd0VBRkEsR0FHQSxTQUptQixDQUlUO0FBSlMsSUFBckI7O0FBT0EsT0FBSTZULGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBVTlILE1BQVYsRUFBa0IvSyxHQUFsQixFQUF1QjtBQUMxQ3VGLFVBQ0UsMEJBQTBCdkYsR0FBMUIsR0FBZ0Msd0NBQWhDLEdBQ0EsK0RBREEsR0FFQSxnQ0FIRixFQUlFK0ssTUFKRjtBQU1ELElBUEQ7O0FBU0EsT0FBSStILFdBQ0YsT0FBT0MsS0FBUCxLQUFpQixXQUFqQixJQUNBQSxNQUFNOVUsUUFBTixHQUFpQnVJLEtBQWpCLENBQXVCLGFBQXZCLENBRkY7O0FBSUEsT0FBSXNNLFFBQUosRUFBYztBQUNaLFNBQUlFLG9CQUFvQmhVLFFBQVEsdUNBQVIsQ0FBeEI7QUFDQXFFLFlBQU9ZLFFBQVAsR0FBa0IsSUFBSThPLEtBQUosQ0FBVTFQLE9BQU9ZLFFBQWpCLEVBQTJCO0FBQzNDbUcsWUFBSyxTQUFTQSxHQUFULENBQWNXLE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQmxDLEtBQTNCLEVBQWtDO0FBQ3JDLGFBQUlrVixrQkFBa0JoVCxHQUFsQixDQUFKLEVBQTRCO0FBQzFCdUYsZ0JBQU0sOERBQThEdkYsR0FBcEU7QUFDQSxrQkFBTyxLQUFQO0FBQ0QsVUFIRCxNQUdPO0FBQ0wrSyxrQkFBTy9LLEdBQVAsSUFBY2xDLEtBQWQ7QUFDQSxrQkFBTyxJQUFQO0FBQ0Q7QUFDRjtBQVQwQyxNQUEzQixDQUFsQjtBQVdEOztBQUVELE9BQUltVixhQUFhO0FBQ2Y1SSxVQUFLLFNBQVNBLEdBQVQsQ0FBY1UsTUFBZCxFQUFzQi9LLEdBQXRCLEVBQTJCO0FBQzlCLFdBQUlxSyxNQUFNckssT0FBTytLLE1BQWpCO0FBQ0EsV0FBSW1JLFlBQVlOLGVBQWU1UyxHQUFmLEtBQXVCQSxJQUFJWSxNQUFKLENBQVcsQ0FBWCxNQUFrQixHQUF6RDtBQUNBLFdBQUksQ0FBQ3lKLEdBQUQsSUFBUSxDQUFDNkksU0FBYixFQUF3QjtBQUN0Qkwsd0JBQWU5SCxNQUFmLEVBQXVCL0ssR0FBdkI7QUFDRDtBQUNELGNBQU9xSyxPQUFPLENBQUM2SSxTQUFmO0FBQ0Q7QUFSYyxJQUFqQjs7QUFXQSxPQUFJQyxhQUFhO0FBQ2ZsTCxVQUFLLFNBQVNBLEdBQVQsQ0FBYzhDLE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQjtBQUM5QixXQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLEVBQUVBLE9BQU8rSyxNQUFULENBQS9CLEVBQWlEO0FBQy9DOEgsd0JBQWU5SCxNQUFmLEVBQXVCL0ssR0FBdkI7QUFDRDtBQUNELGNBQU8rSyxPQUFPL0ssR0FBUCxDQUFQO0FBQ0Q7QUFOYyxJQUFqQjs7QUFTQTJTLGVBQVksU0FBU0EsU0FBVCxDQUFvQjdNLEVBQXBCLEVBQXdCO0FBQ2xDLFNBQUlnTixRQUFKLEVBQWM7QUFDWjtBQUNBLFdBQUk1TSxVQUFVSixHQUFHTSxRQUFqQjtBQUNBLFdBQUlnTixXQUFXbE4sUUFBUW1OLE1BQVIsSUFBa0JuTixRQUFRbU4sTUFBUixDQUFlQyxhQUFqQyxHQUNYSCxVQURXLEdBRVhGLFVBRko7QUFHQW5OLFVBQUd5TixZQUFILEdBQWtCLElBQUlSLEtBQUosQ0FBVWpOLEVBQVYsRUFBY3NOLFFBQWQsQ0FBbEI7QUFDRCxNQVBELE1BT087QUFDTHROLFVBQUd5TixZQUFILEdBQWtCek4sRUFBbEI7QUFDRDtBQUNGLElBWEQ7QUFZRDs7QUFFRDs7QUFFQSxLQUFJME4sUUFBUSxTQUFTQSxLQUFULENBQ1ZoQixHQURVLEVBRVY5VyxJQUZVLEVBR1YrWCxRQUhVLEVBSVZDLElBSlUsRUFLVkMsR0FMVSxFQU1WQyxPQU5VLEVBT1ZDLGdCQVBVLEVBUVZDLFlBUlUsRUFTVjtBQUNBLFFBQUt0QixHQUFMLEdBQVdBLEdBQVg7QUFDQSxRQUFLOVcsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsUUFBSytYLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsUUFBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsUUFBS0MsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsUUFBS0ksRUFBTCxHQUFVaGUsU0FBVjtBQUNBLFFBQUs2ZCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxRQUFLSSxpQkFBTCxHQUF5QmplLFNBQXpCO0FBQ0EsUUFBS2lLLEdBQUwsR0FBV3RFLFFBQVFBLEtBQUtzRSxHQUF4QjtBQUNBLFFBQUs2VCxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBQ0EsUUFBS0ksaUJBQUwsR0FBeUJsZSxTQUF6QjtBQUNBLFFBQUtxWSxNQUFMLEdBQWNyWSxTQUFkO0FBQ0EsUUFBS21lLEdBQUwsR0FBVyxLQUFYO0FBQ0EsUUFBS0MsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFFBQUtDLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxRQUFLQyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsUUFBS0MsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFFBQUtDLE1BQUwsR0FBYyxLQUFkO0FBQ0EsUUFBS1QsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxRQUFLVSxTQUFMLEdBQWlCemUsU0FBakI7QUFDQSxRQUFLMGUsa0JBQUwsR0FBMEIsS0FBMUI7QUFDRCxFQS9CRDs7QUFpQ0EsS0FBSUMscUJBQXFCLEVBQUVyRyxPQUFPLEVBQVQsRUFBekI7O0FBRUE7QUFDQTtBQUNBcUcsb0JBQW1CckcsS0FBbkIsQ0FBeUJwRyxHQUF6QixHQUErQixZQUFZO0FBQ3pDLFVBQU8sS0FBS2dNLGlCQUFaO0FBQ0QsRUFGRDs7QUFJQWxYLFFBQU80WCxnQkFBUCxDQUF5Qm5CLE1BQU1oZSxTQUEvQixFQUEwQ2tmLGtCQUExQzs7QUFFQSxLQUFJRSxtQkFBbUIsU0FBbkJBLGdCQUFtQixDQUFVbEIsSUFBVixFQUFnQjtBQUNyQyxPQUFLQSxTQUFTLEtBQUssQ0FBbkIsRUFBdUJBLE9BQU8sRUFBUDs7QUFFdkIsT0FBSW1CLE9BQU8sSUFBSXJCLEtBQUosRUFBWDtBQUNBcUIsUUFBS25CLElBQUwsR0FBWUEsSUFBWjtBQUNBbUIsUUFBS1IsU0FBTCxHQUFpQixJQUFqQjtBQUNBLFVBQU9RLElBQVA7QUFDRCxFQVBEOztBQVNBLFVBQVNDLGVBQVQsQ0FBMEJ6VyxHQUExQixFQUErQjtBQUM3QixVQUFPLElBQUltVixLQUFKLENBQVV6ZCxTQUFWLEVBQXFCQSxTQUFyQixFQUFnQ0EsU0FBaEMsRUFBMkM4SSxPQUFPUixHQUFQLENBQTNDLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMwVyxVQUFULENBQXFCQyxLQUFyQixFQUE0QjtBQUMxQixPQUFJQyxTQUFTLElBQUl6QixLQUFKLENBQ1h3QixNQUFNeEMsR0FESyxFQUVYd0MsTUFBTXRaLElBRkssRUFHWHNaLE1BQU12QixRQUhLLEVBSVh1QixNQUFNdEIsSUFKSyxFQUtYc0IsTUFBTXJCLEdBTEssRUFNWHFCLE1BQU1wQixPQU5LLEVBT1hvQixNQUFNbkIsZ0JBUEssRUFRWG1CLE1BQU1sQixZQVJLLENBQWI7QUFVQW1CLFVBQU9sQixFQUFQLEdBQVlpQixNQUFNakIsRUFBbEI7QUFDQWtCLFVBQU9kLFFBQVAsR0FBa0JhLE1BQU1iLFFBQXhCO0FBQ0FjLFVBQU9qVixHQUFQLEdBQWFnVixNQUFNaFYsR0FBbkI7QUFDQWlWLFVBQU9aLFNBQVAsR0FBbUJXLE1BQU1YLFNBQXpCO0FBQ0FZLFVBQU9YLFFBQVAsR0FBa0IsSUFBbEI7QUFDQSxVQUFPVyxNQUFQO0FBQ0Q7O0FBRUQsVUFBU0MsV0FBVCxDQUFzQkMsTUFBdEIsRUFBOEI7QUFDNUIsT0FBSXRKLE1BQU1zSixPQUFPL2UsTUFBakI7QUFDQSxPQUFJNkUsTUFBTSxJQUFJc0csS0FBSixDQUFVc0ssR0FBVixDQUFWO0FBQ0EsUUFBSyxJQUFJMVYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMFYsR0FBcEIsRUFBeUIxVixHQUF6QixFQUE4QjtBQUM1QjhFLFNBQUk5RSxDQUFKLElBQVM0ZSxXQUFXSSxPQUFPaGYsQ0FBUCxDQUFYLENBQVQ7QUFDRDtBQUNELFVBQU84RSxHQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsS0FBSW1hLGlCQUFpQm5WLE9BQU8sVUFBVXZKLElBQVYsRUFBZ0I7QUFDMUMsT0FBSTJlLFVBQVUzZSxLQUFLa0ssTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBakM7QUFDQWxLLFVBQU8yZSxVQUFVM2UsS0FBS3FCLEtBQUwsQ0FBVyxDQUFYLENBQVYsR0FBMEJyQixJQUFqQztBQUNBLE9BQUk0ZSxVQUFVNWUsS0FBS2tLLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQWpDLENBSDBDLENBR0o7QUFDdENsSyxVQUFPNGUsVUFBVTVlLEtBQUtxQixLQUFMLENBQVcsQ0FBWCxDQUFWLEdBQTBCckIsSUFBakM7QUFDQSxPQUFJNmUsVUFBVTdlLEtBQUtrSyxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFqQztBQUNBbEssVUFBTzZlLFVBQVU3ZSxLQUFLcUIsS0FBTCxDQUFXLENBQVgsQ0FBVixHQUEwQnJCLElBQWpDO0FBQ0EsVUFBTztBQUNMQSxXQUFNQSxJQUREO0FBRUxzTSxXQUFNc1MsT0FGRDtBQUdMQyxjQUFTQSxPQUhKO0FBSUxGLGNBQVNBO0FBSkosSUFBUDtBQU1ELEVBYm9CLENBQXJCOztBQWVBLFVBQVNHLGVBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQzdCLFlBQVNDLE9BQVQsR0FBb0I7QUFDbEIsU0FBSUMsY0FBYy9mLFNBQWxCOztBQUVBLFNBQUk2ZixNQUFNQyxRQUFRRCxHQUFsQjtBQUNBLFNBQUlsVSxNQUFNbUIsT0FBTixDQUFjK1MsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCLFdBQUlSLFNBQVNRLElBQUkxZCxLQUFKLEVBQWI7QUFDQSxZQUFLLElBQUk1QixJQUFJLENBQWIsRUFBZ0JBLElBQUk4ZSxPQUFPN2UsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDO0FBQ3RDOGUsZ0JBQU85ZSxDQUFQLEVBQVVSLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0JnZ0IsV0FBdEI7QUFDRDtBQUNGLE1BTEQsTUFLTztBQUNMO0FBQ0EsY0FBT0YsSUFBSTlmLEtBQUosQ0FBVSxJQUFWLEVBQWdCQyxTQUFoQixDQUFQO0FBQ0Q7QUFDRjtBQUNEOGYsV0FBUUQsR0FBUixHQUFjQSxHQUFkO0FBQ0EsVUFBT0MsT0FBUDtBQUNEOztBQUVELFVBQVNFLGVBQVQsQ0FDRUMsRUFERixFQUVFQyxLQUZGLEVBR0V4TCxHQUhGLEVBSUV5TCxTQUpGLEVBS0VqUSxFQUxGLEVBTUU7QUFDQSxPQUFJcFAsSUFBSixFQUFVc2YsR0FBVixFQUFlQyxHQUFmLEVBQW9COVosS0FBcEI7QUFDQSxRQUFLekYsSUFBTCxJQUFhbWYsRUFBYixFQUFpQjtBQUNmRyxXQUFNSCxHQUFHbmYsSUFBSCxDQUFOO0FBQ0F1ZixXQUFNSCxNQUFNcGYsSUFBTixDQUFOO0FBQ0F5RixhQUFRaVosZUFBZTFlLElBQWYsQ0FBUjtBQUNBLFNBQUk4RyxRQUFRd1ksR0FBUixDQUFKLEVBQWtCO0FBQ2hCdlMsZUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsaUNBQWtDcEosTUFBTXpGLElBQXhDLEdBQWdELFVBQWhELEdBQTZEbUksT0FBT21YLEdBQVAsQ0FEdEIsRUFFdkNsUSxFQUZ1QyxDQUF6QztBQUlELE1BTEQsTUFLTyxJQUFJdEksUUFBUXlZLEdBQVIsQ0FBSixFQUFrQjtBQUN2QixXQUFJelksUUFBUXdZLElBQUlQLEdBQVosQ0FBSixFQUFzQjtBQUNwQk8sZUFBTUgsR0FBR25mLElBQUgsSUFBVzhlLGdCQUFnQlEsR0FBaEIsQ0FBakI7QUFDRDtBQUNEMUwsV0FBSW5PLE1BQU16RixJQUFWLEVBQWdCc2YsR0FBaEIsRUFBcUI3WixNQUFNNkcsSUFBM0IsRUFBaUM3RyxNQUFNb1osT0FBdkMsRUFBZ0RwWixNQUFNa1osT0FBdEQ7QUFDRCxNQUxNLE1BS0EsSUFBSVcsUUFBUUMsR0FBWixFQUFpQjtBQUN0QkEsV0FBSVIsR0FBSixHQUFVTyxHQUFWO0FBQ0FILFVBQUduZixJQUFILElBQVd1ZixHQUFYO0FBQ0Q7QUFDRjtBQUNELFFBQUt2ZixJQUFMLElBQWFvZixLQUFiLEVBQW9CO0FBQ2xCLFNBQUl0WSxRQUFRcVksR0FBR25mLElBQUgsQ0FBUixDQUFKLEVBQXVCO0FBQ3JCeUYsZUFBUWlaLGVBQWUxZSxJQUFmLENBQVI7QUFDQXFmLGlCQUFVNVosTUFBTXpGLElBQWhCLEVBQXNCb2YsTUFBTXBmLElBQU4sQ0FBdEIsRUFBbUN5RixNQUFNb1osT0FBekM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUEsVUFBU1csY0FBVCxDQUF5QnJSLEdBQXpCLEVBQThCc1IsT0FBOUIsRUFBdUNoSCxJQUF2QyxFQUE2QztBQUMzQyxPQUFJdUcsT0FBSjtBQUNBLE9BQUlVLFVBQVV2UixJQUFJc1IsT0FBSixDQUFkOztBQUVBLFlBQVNFLFdBQVQsR0FBd0I7QUFDdEJsSCxVQUFLeFosS0FBTCxDQUFXLElBQVgsRUFBaUJDLFNBQWpCO0FBQ0E7QUFDQTtBQUNBOEosWUFBT2dXLFFBQVFELEdBQWYsRUFBb0JZLFdBQXBCO0FBQ0Q7O0FBRUQsT0FBSTdZLFFBQVE0WSxPQUFSLENBQUosRUFBc0I7QUFDcEI7QUFDQVYsZUFBVUYsZ0JBQWdCLENBQUNhLFdBQUQsQ0FBaEIsQ0FBVjtBQUNELElBSEQsTUFHTztBQUNMO0FBQ0EsU0FBSTNZLE1BQU0wWSxRQUFRWCxHQUFkLEtBQXNCOVgsT0FBT3lZLFFBQVFFLE1BQWYsQ0FBMUIsRUFBa0Q7QUFDaEQ7QUFDQVosaUJBQVVVLE9BQVY7QUFDQVYsZUFBUUQsR0FBUixDQUFZMU8sSUFBWixDQUFpQnNQLFdBQWpCO0FBQ0QsTUFKRCxNQUlPO0FBQ0w7QUFDQVgsaUJBQVVGLGdCQUFnQixDQUFDWSxPQUFELEVBQVVDLFdBQVYsQ0FBaEIsQ0FBVjtBQUNEO0FBQ0Y7O0FBRURYLFdBQVFZLE1BQVIsR0FBaUIsSUFBakI7QUFDQXpSLE9BQUlzUixPQUFKLElBQWVULE9BQWY7QUFDRDs7QUFFRDs7QUFFQSxVQUFTYSx5QkFBVCxDQUNFN2EsSUFERixFQUVFK00sSUFGRixFQUdFK0osR0FIRixFQUlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBSXhCLGNBQWN2SSxLQUFLdkMsT0FBTCxDQUFhb0osS0FBL0I7QUFDQSxPQUFJOVIsUUFBUXdULFdBQVIsQ0FBSixFQUEwQjtBQUN4QjtBQUNEO0FBQ0QsT0FBSS9WLE1BQU0sRUFBVjtBQUNBLE9BQUl1YixRQUFROWEsS0FBSzhhLEtBQWpCO0FBQ0EsT0FBSWxILFFBQVE1VCxLQUFLNFQsS0FBakI7QUFDQSxPQUFJNVIsTUFBTThZLEtBQU4sS0FBZ0I5WSxNQUFNNFIsS0FBTixDQUFwQixFQUFrQztBQUNoQyxVQUFLLElBQUl0UCxHQUFULElBQWdCZ1IsV0FBaEIsRUFBNkI7QUFDM0IsV0FBSXlGLFNBQVMzVixVQUFVZCxHQUFWLENBQWI7QUFDQSxXQUFJeUQsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGFBQUkrUyxpQkFBaUIxVyxJQUFJVCxXQUFKLEVBQXJCO0FBQ0EsYUFDRVMsUUFBUTBXLGNBQVIsSUFDQUYsS0FEQSxJQUNTelcsT0FBT3lXLEtBQVAsRUFBY0UsY0FBZCxDQUZYLEVBR0U7QUFDQWxSLGVBQ0UsWUFBWWtSLGNBQVosR0FBNkIsNEJBQTdCLEdBQ0NqUixvQkFBb0IrTSxPQUFPL0osSUFBM0IsQ0FERCxHQUNxQyxpQ0FEckMsR0FFQSxLQUZBLEdBRVF6SSxHQUZSLEdBRWMsTUFGZCxHQUdBLGdFQUhBLEdBSUEsbUVBSkEsR0FLQSx1Q0FMQSxHQUswQ3lXLE1BTDFDLEdBS21ELGtCQUxuRCxHQUt3RXpXLEdBTHhFLEdBSzhFLEtBTmhGO0FBUUQ7QUFDRjtBQUNEMlcsaUJBQVUxYixHQUFWLEVBQWVxVSxLQUFmLEVBQXNCdFAsR0FBdEIsRUFBMkJ5VyxNQUEzQixFQUFtQyxJQUFuQyxLQUNBRSxVQUFVMWIsR0FBVixFQUFldWIsS0FBZixFQUFzQnhXLEdBQXRCLEVBQTJCeVcsTUFBM0IsRUFBbUMsS0FBbkMsQ0FEQTtBQUVEO0FBQ0Y7QUFDRCxVQUFPeGIsR0FBUDtBQUNEOztBQUVELFVBQVMwYixTQUFULENBQ0UxYixHQURGLEVBRUUyYixJQUZGLEVBR0U1VyxHQUhGLEVBSUV5VyxNQUpGLEVBS0VJLFFBTEYsRUFNRTtBQUNBLE9BQUluWixNQUFNa1osSUFBTixDQUFKLEVBQWlCO0FBQ2YsU0FBSTdXLE9BQU82VyxJQUFQLEVBQWE1VyxHQUFiLENBQUosRUFBdUI7QUFDckIvRSxXQUFJK0UsR0FBSixJQUFXNFcsS0FBSzVXLEdBQUwsQ0FBWDtBQUNBLFdBQUksQ0FBQzZXLFFBQUwsRUFBZTtBQUNiLGdCQUFPRCxLQUFLNVcsR0FBTCxDQUFQO0FBQ0Q7QUFDRCxjQUFPLElBQVA7QUFDRCxNQU5ELE1BTU8sSUFBSUQsT0FBTzZXLElBQVAsRUFBYUgsTUFBYixDQUFKLEVBQTBCO0FBQy9CeGIsV0FBSStFLEdBQUosSUFBVzRXLEtBQUtILE1BQUwsQ0FBWDtBQUNBLFdBQUksQ0FBQ0ksUUFBTCxFQUFlO0FBQ2IsZ0JBQU9ELEtBQUtILE1BQUwsQ0FBUDtBQUNEO0FBQ0QsY0FBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQU8sS0FBUDtBQUNEOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBU0ssdUJBQVQsQ0FBa0NyRCxRQUFsQyxFQUE0QztBQUMxQyxRQUFLLElBQUl0ZCxJQUFJLENBQWIsRUFBZ0JBLElBQUlzZCxTQUFTcmQsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQ3hDLFNBQUlvTCxNQUFNbUIsT0FBTixDQUFjK1EsU0FBU3RkLENBQVQsQ0FBZCxDQUFKLEVBQWdDO0FBQzlCLGNBQU9vTCxNQUFNL0wsU0FBTixDQUFnQjJNLE1BQWhCLENBQXVCeE0sS0FBdkIsQ0FBNkIsRUFBN0IsRUFBaUM4ZCxRQUFqQyxDQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQU9BLFFBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVNzRCxpQkFBVCxDQUE0QnRELFFBQTVCLEVBQXNDO0FBQ3BDLFVBQU81VixZQUFZNFYsUUFBWixJQUNILENBQUNxQixnQkFBZ0JyQixRQUFoQixDQUFELENBREcsR0FFSGxTLE1BQU1tQixPQUFOLENBQWMrUSxRQUFkLElBQ0V1RCx1QkFBdUJ2RCxRQUF2QixDQURGLEdBRUUxZCxTQUpOO0FBS0Q7O0FBRUQsVUFBU2toQixVQUFULENBQXFCcEMsSUFBckIsRUFBMkI7QUFDekIsVUFBT25YLE1BQU1tWCxJQUFOLEtBQWVuWCxNQUFNbVgsS0FBS25CLElBQVgsQ0FBZixJQUFtQzlWLFFBQVFpWCxLQUFLUixTQUFiLENBQTFDO0FBQ0Q7O0FBRUQsVUFBUzJDLHNCQUFULENBQWlDdkQsUUFBakMsRUFBMkN5RCxXQUEzQyxFQUF3RDtBQUN0RCxPQUFJamMsTUFBTSxFQUFWO0FBQ0EsT0FBSTlFLENBQUosRUFBT3VLLENBQVAsRUFBVW1HLElBQVY7QUFDQSxRQUFLMVEsSUFBSSxDQUFULEVBQVlBLElBQUlzZCxTQUFTcmQsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDdUssU0FBSStTLFNBQVN0ZCxDQUFULENBQUo7QUFDQSxTQUFJcUgsUUFBUWtELENBQVIsS0FBYyxPQUFPQSxDQUFQLEtBQWEsU0FBL0IsRUFBMEM7QUFBRTtBQUFVO0FBQ3REbUcsWUFBTzVMLElBQUlBLElBQUk3RSxNQUFKLEdBQWEsQ0FBakIsQ0FBUDtBQUNBO0FBQ0EsU0FBSW1MLE1BQU1tQixPQUFOLENBQWNoQyxDQUFkLENBQUosRUFBc0I7QUFDcEJ6RixXQUFJOEwsSUFBSixDQUFTcFIsS0FBVCxDQUFlc0YsR0FBZixFQUFvQitiLHVCQUF1QnRXLENBQXZCLEVBQTJCLENBQUN3VyxlQUFlLEVBQWhCLElBQXNCLEdBQXRCLEdBQTRCL2dCLENBQXZELENBQXBCO0FBQ0QsTUFGRCxNQUVPLElBQUkwSCxZQUFZNkMsQ0FBWixDQUFKLEVBQW9CO0FBQ3pCLFdBQUl1VyxXQUFXcFEsSUFBWCxDQUFKLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNDQSxhQUFELENBQU82TSxJQUFQLElBQWU3VSxPQUFPNkIsQ0FBUCxDQUFmO0FBQ0QsUUFMRCxNQUtPLElBQUlBLE1BQU0sRUFBVixFQUFjO0FBQ25CO0FBQ0F6RixhQUFJOEwsSUFBSixDQUFTK04sZ0JBQWdCcFUsQ0FBaEIsQ0FBVDtBQUNEO0FBQ0YsTUFWTSxNQVVBO0FBQ0wsV0FBSXVXLFdBQVd2VyxDQUFYLEtBQWlCdVcsV0FBV3BRLElBQVgsQ0FBckIsRUFBdUM7QUFDckM7QUFDQTVMLGFBQUlBLElBQUk3RSxNQUFKLEdBQWEsQ0FBakIsSUFBc0IwZSxnQkFBZ0JqTyxLQUFLNk0sSUFBTCxHQUFZaFQsRUFBRWdULElBQTlCLENBQXRCO0FBQ0QsUUFIRCxNQUdPO0FBQ0w7QUFDQSxhQUFJL1YsT0FBTzhWLFNBQVMwRCxRQUFoQixLQUNGelosTUFBTWdELEVBQUU4UixHQUFSLENBREUsSUFFRmhWLFFBQVFrRCxFQUFFVixHQUFWLENBRkUsSUFHRnRDLE1BQU13WixXQUFOLENBSEYsRUFHc0I7QUFDcEJ4VyxhQUFFVixHQUFGLEdBQVEsWUFBWWtYLFdBQVosR0FBMEIsR0FBMUIsR0FBZ0MvZ0IsQ0FBaEMsR0FBb0MsSUFBNUM7QUFDRDtBQUNEOEUsYUFBSThMLElBQUosQ0FBU3JHLENBQVQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPekYsR0FBUDtBQUNEOztBQUVEOztBQUVBLFVBQVNtYyxVQUFULENBQXFCQyxJQUFyQixFQUEyQkMsSUFBM0IsRUFBaUM7QUFDL0IsT0FBSUQsS0FBS0UsVUFBTCxJQUFtQkYsS0FBSzdGLE9BQTVCLEVBQXFDO0FBQ25DNkYsWUFBT0EsS0FBSzdGLE9BQVo7QUFDRDtBQUNELFVBQU96VCxTQUFTc1osSUFBVCxJQUNIQyxLQUFLOVYsTUFBTCxDQUFZNlYsSUFBWixDQURHLEdBRUhBLElBRko7QUFHRDs7QUFFRCxVQUFTRyxzQkFBVCxDQUNFNWdCLE9BREYsRUFFRThFLElBRkYsRUFHRWtZLE9BSEYsRUFJRUgsUUFKRixFQUtFakIsR0FMRixFQU1FO0FBQ0EsT0FBSXFDLE9BQU9ELGtCQUFYO0FBQ0FDLFFBQUtmLFlBQUwsR0FBb0JsZCxPQUFwQjtBQUNBaWUsUUFBS0wsU0FBTCxHQUFpQixFQUFFOVksTUFBTUEsSUFBUixFQUFja1ksU0FBU0EsT0FBdkIsRUFBZ0NILFVBQVVBLFFBQTFDLEVBQW9EakIsS0FBS0EsR0FBekQsRUFBakI7QUFDQSxVQUFPcUMsSUFBUDtBQUNEOztBQUVELFVBQVM0QyxxQkFBVCxDQUNFN2dCLE9BREYsRUFFRThnQixRQUZGLEVBR0U5RCxPQUhGLEVBSUU7QUFDQSxPQUFJalcsT0FBTy9HLFFBQVFxRixLQUFmLEtBQXlCeUIsTUFBTTlHLFFBQVErZ0IsU0FBZCxDQUE3QixFQUF1RDtBQUNyRCxZQUFPL2dCLFFBQVErZ0IsU0FBZjtBQUNEOztBQUVELE9BQUlqYSxNQUFNOUcsUUFBUWdoQixRQUFkLENBQUosRUFBNkI7QUFDM0IsWUFBT2hoQixRQUFRZ2hCLFFBQWY7QUFDRDs7QUFFRCxPQUFJamEsT0FBTy9HLFFBQVFpaEIsT0FBZixLQUEyQm5hLE1BQU05RyxRQUFRa2hCLFdBQWQsQ0FBL0IsRUFBMkQ7QUFDekQsWUFBT2xoQixRQUFRa2hCLFdBQWY7QUFDRDs7QUFFRCxPQUFJcGEsTUFBTTlHLFFBQVFtaEIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCO0FBQ0FuaEIsYUFBUW1oQixRQUFSLENBQWlCaFIsSUFBakIsQ0FBc0I2TSxPQUF0QjtBQUNELElBSEQsTUFHTztBQUNMLFNBQUltRSxXQUFXbmhCLFFBQVFtaEIsUUFBUixHQUFtQixDQUFDbkUsT0FBRCxDQUFsQztBQUNBLFNBQUlvRSxPQUFPLElBQVg7O0FBRUEsU0FBSUMsY0FBYyxTQUFkQSxXQUFjLEdBQVk7QUFDNUIsWUFBSyxJQUFJOWhCLElBQUksQ0FBUixFQUFXK0ssSUFBSTZXLFNBQVMzaEIsTUFBN0IsRUFBcUNELElBQUkrSyxDQUF6QyxFQUE0Qy9LLEdBQTVDLEVBQWlEO0FBQy9DNGhCLGtCQUFTNWhCLENBQVQsRUFBWStoQixZQUFaO0FBQ0Q7QUFDRixNQUpEOztBQU1BLFNBQUl6YixVQUFVdUcsS0FBSyxVQUFVL0gsR0FBVixFQUFlO0FBQ2hDO0FBQ0FyRSxlQUFRZ2hCLFFBQVIsR0FBbUJSLFdBQVduYyxHQUFYLEVBQWdCeWMsUUFBaEIsQ0FBbkI7QUFDQTtBQUNBO0FBQ0EsV0FBSSxDQUFDTSxJQUFMLEVBQVc7QUFDVEM7QUFDRDtBQUNGLE1BUmEsQ0FBZDs7QUFVQSxTQUFJdGIsU0FBU3FHLEtBQUssVUFBVW1WLE1BQVYsRUFBa0I7QUFDbEMxVSxlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2Qyx3Q0FBeUMxRyxPQUFPakksT0FBUCxDQUF6QyxJQUNDdWhCLFNBQVUsZUFBZUEsTUFBekIsR0FBbUMsRUFEcEMsQ0FEdUMsQ0FBekM7QUFJQSxXQUFJemEsTUFBTTlHLFFBQVErZ0IsU0FBZCxDQUFKLEVBQThCO0FBQzVCL2dCLGlCQUFRcUYsS0FBUixHQUFnQixJQUFoQjtBQUNBZ2M7QUFDRDtBQUNGLE1BVFksQ0FBYjs7QUFXQSxTQUFJaGQsTUFBTXJFLFFBQVE2RixPQUFSLEVBQWlCRSxNQUFqQixDQUFWOztBQUVBLFNBQUlvQixTQUFTOUMsR0FBVCxDQUFKLEVBQW1CO0FBQ2pCLFdBQUksT0FBT0EsSUFBSVUsSUFBWCxLQUFvQixVQUF4QixFQUFvQztBQUNsQztBQUNBLGFBQUk2QixRQUFRNUcsUUFBUWdoQixRQUFoQixDQUFKLEVBQStCO0FBQzdCM2MsZUFBSVUsSUFBSixDQUFTYyxPQUFULEVBQWtCRSxNQUFsQjtBQUNEO0FBQ0YsUUFMRCxNQUtPLElBQUllLE1BQU16QyxJQUFJbWQsU0FBVixLQUF3QixPQUFPbmQsSUFBSW1kLFNBQUosQ0FBY3pjLElBQXJCLEtBQThCLFVBQTFELEVBQXNFO0FBQzNFVixhQUFJbWQsU0FBSixDQUFjemMsSUFBZCxDQUFtQmMsT0FBbkIsRUFBNEJFLE1BQTVCOztBQUVBLGFBQUllLE1BQU16QyxJQUFJZ0IsS0FBVixDQUFKLEVBQXNCO0FBQ3BCckYsbUJBQVErZ0IsU0FBUixHQUFvQlAsV0FBV25jLElBQUlnQixLQUFmLEVBQXNCeWIsUUFBdEIsQ0FBcEI7QUFDRDs7QUFFRCxhQUFJaGEsTUFBTXpDLElBQUk0YyxPQUFWLENBQUosRUFBd0I7QUFDdEJqaEIsbUJBQVFraEIsV0FBUixHQUFzQlYsV0FBV25jLElBQUk0YyxPQUFmLEVBQXdCSCxRQUF4QixDQUF0QjtBQUNBLGVBQUl6YyxJQUFJb2QsS0FBSixLQUFjLENBQWxCLEVBQXFCO0FBQ25CemhCLHFCQUFRaWhCLE9BQVIsR0FBa0IsSUFBbEI7QUFDRCxZQUZELE1BRU87QUFDTHRPLHdCQUFXLFlBQVk7QUFDckIsbUJBQUkvTCxRQUFRNUcsUUFBUWdoQixRQUFoQixLQUE2QnBhLFFBQVE1RyxRQUFRcUYsS0FBaEIsQ0FBakMsRUFBeUQ7QUFDdkRyRix5QkFBUWloQixPQUFSLEdBQWtCLElBQWxCO0FBQ0FJO0FBQ0Q7QUFDRixjQUxELEVBS0doZCxJQUFJb2QsS0FBSixJQUFhLEdBTGhCO0FBTUQ7QUFDRjs7QUFFRCxhQUFJM2EsTUFBTXpDLElBQUlxZCxPQUFWLENBQUosRUFBd0I7QUFDdEIvTyxzQkFBVyxZQUFZO0FBQ3JCLGlCQUFJL0wsUUFBUTVHLFFBQVFnaEIsUUFBaEIsQ0FBSixFQUErQjtBQUM3QmpiLHNCQUNFOEcsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLEdBQ0ssY0FBZTFJLElBQUlxZCxPQUFuQixHQUE4QixLQURuQyxHQUVJLElBSE47QUFLRDtBQUNGLFlBUkQsRUFRR3JkLElBQUlxZCxPQVJQO0FBU0Q7QUFDRjtBQUNGOztBQUVETixZQUFPLEtBQVA7QUFDQTtBQUNBLFlBQU9waEIsUUFBUWloQixPQUFSLEdBQ0hqaEIsUUFBUWtoQixXQURMLEdBRUhsaEIsUUFBUWdoQixRQUZaO0FBR0Q7QUFDRjs7QUFFRDs7QUFFQSxVQUFTVyxzQkFBVCxDQUFpQzlFLFFBQWpDLEVBQTJDO0FBQ3pDLE9BQUlsUyxNQUFNbUIsT0FBTixDQUFjK1EsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFVBQUssSUFBSXRkLElBQUksQ0FBYixFQUFnQkEsSUFBSXNkLFNBQVNyZCxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDeEMsV0FBSXVLLElBQUkrUyxTQUFTdGQsQ0FBVCxDQUFSO0FBQ0EsV0FBSXVILE1BQU1nRCxDQUFOLEtBQVloRCxNQUFNZ0QsRUFBRW1ULGdCQUFSLENBQWhCLEVBQTJDO0FBQ3pDLGdCQUFPblQsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEOztBQUVBOztBQUVBLFVBQVM4WCxVQUFULENBQXFCMVMsRUFBckIsRUFBeUI7QUFDdkJBLE1BQUcyUyxPQUFILEdBQWExYixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNBMEcsTUFBRzRTLGFBQUgsR0FBbUIsS0FBbkI7QUFDQTtBQUNBLE9BQUlDLFlBQVk3UyxHQUFHTSxRQUFILENBQVl3UyxnQkFBNUI7QUFDQSxPQUFJRCxTQUFKLEVBQWU7QUFDYkUsOEJBQXlCL1MsRUFBekIsRUFBNkI2UyxTQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsS0FBSTVOLE1BQUo7O0FBRUEsVUFBU1QsR0FBVCxDQUFjbk8sS0FBZCxFQUFxQitELEVBQXJCLEVBQXlCb1YsT0FBekIsRUFBa0M7QUFDaEMsT0FBSUEsT0FBSixFQUFhO0FBQ1h2SyxZQUFPK04sS0FBUCxDQUFhM2MsS0FBYixFQUFvQitELEVBQXBCO0FBQ0QsSUFGRCxNQUVPO0FBQ0w2SyxZQUFPZ08sR0FBUCxDQUFXNWMsS0FBWCxFQUFrQitELEVBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTOFksUUFBVCxDQUFtQjdjLEtBQW5CLEVBQTBCK0QsRUFBMUIsRUFBOEI7QUFDNUI2SyxVQUFPa08sSUFBUCxDQUFZOWMsS0FBWixFQUFtQitELEVBQW5CO0FBQ0Q7O0FBRUQsVUFBUzJZLHdCQUFULENBQ0UvUyxFQURGLEVBRUU2UyxTQUZGLEVBR0VPLFlBSEYsRUFJRTtBQUNBbk8sWUFBU2pGLEVBQVQ7QUFDQThQLG1CQUFnQitDLFNBQWhCLEVBQTJCTyxnQkFBZ0IsRUFBM0MsRUFBK0M1TyxHQUEvQyxFQUFvRDBPLFFBQXBELEVBQThEbFQsRUFBOUQ7QUFDRDs7QUFFRCxVQUFTcVQsV0FBVCxDQUFzQkMsR0FBdEIsRUFBMkI7QUFDekIsT0FBSUMsU0FBUyxRQUFiO0FBQ0FELE9BQUk1akIsU0FBSixDQUFjdWpCLEdBQWQsR0FBb0IsVUFBVTVjLEtBQVYsRUFBaUIrRCxFQUFqQixFQUFxQjtBQUN2QyxTQUFJb1osU0FBUyxJQUFiOztBQUVBLFNBQUl4VCxLQUFLLElBQVQ7QUFDQSxTQUFJdkUsTUFBTW1CLE9BQU4sQ0FBY3ZHLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixZQUFLLElBQUloRyxJQUFJLENBQVIsRUFBVytLLElBQUkvRSxNQUFNL0YsTUFBMUIsRUFBa0NELElBQUkrSyxDQUF0QyxFQUF5Qy9LLEdBQXpDLEVBQThDO0FBQzVDbWpCLGdCQUFPUCxHQUFQLENBQVc1YyxNQUFNaEcsQ0FBTixDQUFYLEVBQXFCK0osRUFBckI7QUFDRDtBQUNGLE1BSkQsTUFJTztBQUNMLFFBQUM0RixHQUFHMlMsT0FBSCxDQUFXdGMsS0FBWCxNQUFzQjJKLEdBQUcyUyxPQUFILENBQVd0YyxLQUFYLElBQW9CLEVBQTFDLENBQUQsRUFBZ0Q0SyxJQUFoRCxDQUFxRDdHLEVBQXJEO0FBQ0E7QUFDQTtBQUNBLFdBQUltWixPQUFPaFUsSUFBUCxDQUFZbEosS0FBWixDQUFKLEVBQXdCO0FBQ3RCMkosWUFBRzRTLGFBQUgsR0FBbUIsSUFBbkI7QUFDRDtBQUNGO0FBQ0QsWUFBTzVTLEVBQVA7QUFDRCxJQWpCRDs7QUFtQkFzVCxPQUFJNWpCLFNBQUosQ0FBY3NqQixLQUFkLEdBQXNCLFVBQVUzYyxLQUFWLEVBQWlCK0QsRUFBakIsRUFBcUI7QUFDekMsU0FBSTRGLEtBQUssSUFBVDtBQUNBLGNBQVMrUCxFQUFULEdBQWU7QUFDYi9QLFVBQUdtVCxJQUFILENBQVE5YyxLQUFSLEVBQWUwWixFQUFmO0FBQ0EzVixVQUFHdkssS0FBSCxDQUFTbVEsRUFBVCxFQUFhbFEsU0FBYjtBQUNEO0FBQ0RpZ0IsUUFBRzNWLEVBQUgsR0FBUUEsRUFBUjtBQUNBNEYsUUFBR2lULEdBQUgsQ0FBTzVjLEtBQVAsRUFBYzBaLEVBQWQ7QUFDQSxZQUFPL1AsRUFBUDtBQUNELElBVEQ7O0FBV0FzVCxPQUFJNWpCLFNBQUosQ0FBY3lqQixJQUFkLEdBQXFCLFVBQVU5YyxLQUFWLEVBQWlCK0QsRUFBakIsRUFBcUI7QUFDeEMsU0FBSW9aLFNBQVMsSUFBYjs7QUFFQSxTQUFJeFQsS0FBSyxJQUFUO0FBQ0E7QUFDQSxTQUFJLENBQUNsUSxVQUFVUSxNQUFmLEVBQXVCO0FBQ3JCMFAsVUFBRzJTLE9BQUgsR0FBYTFiLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFiO0FBQ0EsY0FBTzBHLEVBQVA7QUFDRDtBQUNEO0FBQ0EsU0FBSXZFLE1BQU1tQixPQUFOLENBQWN2RyxLQUFkLENBQUosRUFBMEI7QUFDeEIsWUFBSyxJQUFJb2QsTUFBTSxDQUFWLEVBQWFyWSxJQUFJL0UsTUFBTS9GLE1BQTVCLEVBQW9DbWpCLE1BQU1yWSxDQUExQyxFQUE2Q3FZLEtBQTdDLEVBQW9EO0FBQ2xERCxnQkFBT0wsSUFBUCxDQUFZOWMsTUFBTW9kLEdBQU4sQ0FBWixFQUF3QnJaLEVBQXhCO0FBQ0Q7QUFDRCxjQUFPNEYsRUFBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFJMFQsTUFBTTFULEdBQUcyUyxPQUFILENBQVd0YyxLQUFYLENBQVY7QUFDQSxTQUFJLENBQUNxZCxHQUFMLEVBQVU7QUFDUixjQUFPMVQsRUFBUDtBQUNEO0FBQ0QsU0FBSWxRLFVBQVVRLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIwUCxVQUFHMlMsT0FBSCxDQUFXdGMsS0FBWCxJQUFvQixJQUFwQjtBQUNBLGNBQU8ySixFQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQUlrRSxFQUFKO0FBQ0EsU0FBSTdULElBQUlxakIsSUFBSXBqQixNQUFaO0FBQ0EsWUFBT0QsR0FBUCxFQUFZO0FBQ1Y2VCxZQUFLd1AsSUFBSXJqQixDQUFKLENBQUw7QUFDQSxXQUFJNlQsT0FBTzlKLEVBQVAsSUFBYThKLEdBQUc5SixFQUFILEtBQVVBLEVBQTNCLEVBQStCO0FBQzdCc1osYUFBSTNaLE1BQUosQ0FBVzFKLENBQVgsRUFBYyxDQUFkO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsWUFBTzJQLEVBQVA7QUFDRCxJQXBDRDs7QUFzQ0FzVCxPQUFJNWpCLFNBQUosQ0FBY2lrQixLQUFkLEdBQXNCLFVBQVV0ZCxLQUFWLEVBQWlCO0FBQ3JDLFNBQUkySixLQUFLLElBQVQ7QUFDQSxTQUFJckMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFdBQUkrVixpQkFBaUJ2ZCxNQUFNb0QsV0FBTixFQUFyQjtBQUNBLFdBQUltYSxtQkFBbUJ2ZCxLQUFuQixJQUE0QjJKLEdBQUcyUyxPQUFILENBQVdpQixjQUFYLENBQWhDLEVBQTREO0FBQzFEbFUsYUFDRSxhQUFha1UsY0FBYixHQUE4Qiw2QkFBOUIsR0FDQ2pVLG9CQUFvQkssRUFBcEIsQ0FERCxHQUM0Qix1Q0FENUIsR0FDc0UzSixLQUR0RSxHQUM4RSxNQUQ5RSxHQUVBLG9FQUZBLEdBR0Esa0VBSEEsR0FJQSw0QkFKQSxHQUlnQzJFLFVBQVUzRSxLQUFWLENBSmhDLEdBSW9ELGtCQUpwRCxHQUl5RUEsS0FKekUsR0FJaUYsS0FMbkY7QUFPRDtBQUNGO0FBQ0QsU0FBSXFkLE1BQU0xVCxHQUFHMlMsT0FBSCxDQUFXdGMsS0FBWCxDQUFWO0FBQ0EsU0FBSXFkLEdBQUosRUFBUztBQUNQQSxhQUFNQSxJQUFJcGpCLE1BQUosR0FBYSxDQUFiLEdBQWlCZ0wsUUFBUW9ZLEdBQVIsQ0FBakIsR0FBZ0NBLEdBQXRDO0FBQ0EsV0FBSTVOLE9BQU94SyxRQUFReEwsU0FBUixFQUFtQixDQUFuQixDQUFYO0FBQ0EsWUFBSyxJQUFJTyxJQUFJLENBQVIsRUFBVytLLElBQUlzWSxJQUFJcGpCLE1BQXhCLEVBQWdDRCxJQUFJK0ssQ0FBcEMsRUFBdUMvSyxHQUF2QyxFQUE0QztBQUMxQyxhQUFJO0FBQ0ZxakIsZUFBSXJqQixDQUFKLEVBQU9SLEtBQVAsQ0FBYW1RLEVBQWIsRUFBaUI4RixJQUFqQjtBQUNELFVBRkQsQ0FFRSxPQUFPbFcsQ0FBUCxFQUFVO0FBQ1ZzUix1QkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBb0IseUJBQXlCM0osS0FBekIsR0FBaUMsSUFBckQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxZQUFPMkosRUFBUDtBQUNELElBM0JEO0FBNEJEOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTNlQsWUFBVCxDQUNFbEcsUUFERixFQUVFRyxPQUZGLEVBR0U7QUFDQSxPQUFJZ0csUUFBUSxFQUFaO0FBQ0EsT0FBSSxDQUFDbkcsUUFBTCxFQUFlO0FBQ2IsWUFBT21HLEtBQVA7QUFDRDtBQUNELE9BQUlDLGNBQWMsRUFBbEI7QUFDQSxRQUFLLElBQUkxakIsSUFBSSxDQUFSLEVBQVcrSyxJQUFJdVMsU0FBU3JkLE1BQTdCLEVBQXFDRCxJQUFJK0ssQ0FBekMsRUFBNEMvSyxHQUE1QyxFQUFpRDtBQUMvQyxTQUFJa1ksUUFBUW9GLFNBQVN0ZCxDQUFULENBQVo7QUFDQTtBQUNBO0FBQ0EsU0FBSSxDQUFDa1ksTUFBTXVGLE9BQU4sS0FBa0JBLE9BQWxCLElBQTZCdkYsTUFBTTJGLGlCQUFOLEtBQTRCSixPQUExRCxLQUNGdkYsTUFBTTNTLElBREosSUFDWTJTLE1BQU0zUyxJQUFOLENBQVdvZSxJQUFYLElBQW1CLElBRG5DLEVBRUU7QUFDQSxXQUFJcGpCLE9BQU8yWCxNQUFNM1MsSUFBTixDQUFXb2UsSUFBdEI7QUFDQSxXQUFJQSxPQUFRRixNQUFNbGpCLElBQU4sTUFBZ0JrakIsTUFBTWxqQixJQUFOLElBQWMsRUFBOUIsQ0FBWjtBQUNBLFdBQUkyWCxNQUFNbUUsR0FBTixLQUFjLFVBQWxCLEVBQThCO0FBQzVCc0gsY0FBSy9TLElBQUwsQ0FBVXBSLEtBQVYsQ0FBZ0Jta0IsSUFBaEIsRUFBc0J6TCxNQUFNb0YsUUFBNUI7QUFDRCxRQUZELE1BRU87QUFDTHFHLGNBQUsvUyxJQUFMLENBQVVzSCxLQUFWO0FBQ0Q7QUFDRixNQVZELE1BVU87QUFDTHdMLG1CQUFZOVMsSUFBWixDQUFpQnNILEtBQWpCO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsT0FBSSxDQUFDd0wsWUFBWWpYLEtBQVosQ0FBa0JtWCxZQUFsQixDQUFMLEVBQXNDO0FBQ3BDSCxXQUFNcEksT0FBTixHQUFnQnFJLFdBQWhCO0FBQ0Q7QUFDRCxVQUFPRCxLQUFQO0FBQ0Q7O0FBRUQsVUFBU0csWUFBVCxDQUF1QmxGLElBQXZCLEVBQTZCO0FBQzNCLFVBQU9BLEtBQUtSLFNBQUwsSUFBa0JRLEtBQUtuQixJQUFMLEtBQWMsR0FBdkM7QUFDRDs7QUFFRCxVQUFTc0csa0JBQVQsQ0FDRXZFLEdBREYsRUFDTztBQUNMeGEsSUFGRixFQUdFO0FBQ0FBLFNBQU1BLE9BQU8sRUFBYjtBQUNBLFFBQUssSUFBSTlFLElBQUksQ0FBYixFQUFnQkEsSUFBSXNmLElBQUlyZixNQUF4QixFQUFnQ0QsR0FBaEMsRUFBcUM7QUFDbkMsU0FBSW9MLE1BQU1tQixPQUFOLENBQWMrUyxJQUFJdGYsQ0FBSixDQUFkLENBQUosRUFBMkI7QUFDekI2akIsMEJBQW1CdkUsSUFBSXRmLENBQUosQ0FBbkIsRUFBMkI4RSxHQUEzQjtBQUNELE1BRkQsTUFFTztBQUNMQSxXQUFJd2EsSUFBSXRmLENBQUosRUFBTzZKLEdBQVgsSUFBa0J5VixJQUFJdGYsQ0FBSixFQUFPK0osRUFBekI7QUFDRDtBQUNGO0FBQ0QsVUFBT2pGLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxLQUFJZ2YsaUJBQWlCLElBQXJCO0FBQ0EsS0FBSUMsMkJBQTJCLEtBQS9COztBQUVBLFVBQVNDLGFBQVQsQ0FBd0JyVSxFQUF4QixFQUE0QjtBQUMxQixPQUFJSSxVQUFVSixHQUFHTSxRQUFqQjs7QUFFQTtBQUNBLE9BQUlnSSxTQUFTbEksUUFBUWtJLE1BQXJCO0FBQ0EsT0FBSUEsVUFBVSxDQUFDbEksUUFBUWtVLFFBQXZCLEVBQWlDO0FBQy9CLFlBQU9oTSxPQUFPaEksUUFBUCxDQUFnQmdVLFFBQWhCLElBQTRCaE0sT0FBTzFILE9BQTFDLEVBQW1EO0FBQ2pEMEgsZ0JBQVNBLE9BQU8xSCxPQUFoQjtBQUNEO0FBQ0QwSCxZQUFPaU0sU0FBUCxDQUFpQnRULElBQWpCLENBQXNCakIsRUFBdEI7QUFDRDs7QUFFREEsTUFBR1ksT0FBSCxHQUFhMEgsTUFBYjtBQUNBdEksTUFBR0csS0FBSCxHQUFXbUksU0FBU0EsT0FBT25JLEtBQWhCLEdBQXdCSCxFQUFuQzs7QUFFQUEsTUFBR3VVLFNBQUgsR0FBZSxFQUFmO0FBQ0F2VSxNQUFHd1UsS0FBSCxHQUFXLEVBQVg7O0FBRUF4VSxNQUFHeVUsUUFBSCxHQUFjLElBQWQ7QUFDQXpVLE1BQUcwVSxTQUFILEdBQWUsSUFBZjtBQUNBMVUsTUFBRzJVLGVBQUgsR0FBcUIsS0FBckI7QUFDQTNVLE1BQUc0VSxVQUFILEdBQWdCLEtBQWhCO0FBQ0E1VSxNQUFHNlUsWUFBSCxHQUFrQixLQUFsQjtBQUNBN1UsTUFBRzhVLGlCQUFILEdBQXVCLEtBQXZCO0FBQ0Q7O0FBRUQsVUFBU0MsY0FBVCxDQUF5QnpCLEdBQXpCLEVBQThCO0FBQzVCQSxPQUFJNWpCLFNBQUosQ0FBY3NsQixPQUFkLEdBQXdCLFVBQVU5RixLQUFWLEVBQWlCK0YsU0FBakIsRUFBNEI7QUFDbEQsU0FBSWpWLEtBQUssSUFBVDtBQUNBLFNBQUlBLEdBQUc0VSxVQUFQLEVBQW1CO0FBQ2pCTSxnQkFBU2xWLEVBQVQsRUFBYSxjQUFiO0FBQ0Q7QUFDRCxTQUFJbVYsU0FBU25WLEdBQUdvVixHQUFoQjtBQUNBLFNBQUlDLFlBQVlyVixHQUFHc1YsTUFBbkI7QUFDQSxTQUFJQyxxQkFBcUJwQixjQUF6QjtBQUNBQSxzQkFBaUJuVSxFQUFqQjtBQUNBQSxRQUFHc1YsTUFBSCxHQUFZcEcsS0FBWjtBQUNBO0FBQ0E7QUFDQSxTQUFJLENBQUNtRyxTQUFMLEVBQWdCO0FBQ2Q7QUFDQXJWLFVBQUdvVixHQUFILEdBQVNwVixHQUFHd1YsU0FBSCxDQUNQeFYsR0FBR29WLEdBREksRUFDQ2xHLEtBREQsRUFDUStGLFNBRFIsRUFDbUIsS0FEbkIsQ0FDeUI7QUFEekIsU0FFUGpWLEdBQUdNLFFBQUgsQ0FBWW1WLFVBRkwsRUFHUHpWLEdBQUdNLFFBQUgsQ0FBWW9WLE9BSEwsQ0FBVDtBQUtBO0FBQ0E7QUFDQTFWLFVBQUdNLFFBQUgsQ0FBWW1WLFVBQVosR0FBeUJ6VixHQUFHTSxRQUFILENBQVlvVixPQUFaLEdBQXNCLElBQS9DO0FBQ0QsTUFWRCxNQVVPO0FBQ0w7QUFDQTFWLFVBQUdvVixHQUFILEdBQVNwVixHQUFHd1YsU0FBSCxDQUFhSCxTQUFiLEVBQXdCbkcsS0FBeEIsQ0FBVDtBQUNEO0FBQ0RpRixzQkFBaUJvQixrQkFBakI7QUFDQTtBQUNBLFNBQUlKLE1BQUosRUFBWTtBQUNWQSxjQUFPUSxPQUFQLEdBQWlCLElBQWpCO0FBQ0Q7QUFDRCxTQUFJM1YsR0FBR29WLEdBQVAsRUFBWTtBQUNWcFYsVUFBR29WLEdBQUgsQ0FBT08sT0FBUCxHQUFpQjNWLEVBQWpCO0FBQ0Q7QUFDRDtBQUNBLFNBQUlBLEdBQUc0VixNQUFILElBQWE1VixHQUFHWSxPQUFoQixJQUEyQlosR0FBRzRWLE1BQUgsS0FBYzVWLEdBQUdZLE9BQUgsQ0FBVzBVLE1BQXhELEVBQWdFO0FBQzlEdFYsVUFBR1ksT0FBSCxDQUFXd1UsR0FBWCxHQUFpQnBWLEdBQUdvVixHQUFwQjtBQUNEO0FBQ0Q7QUFDQTtBQUNELElBeENEOztBQTBDQTlCLE9BQUk1akIsU0FBSixDQUFjMGlCLFlBQWQsR0FBNkIsWUFBWTtBQUN2QyxTQUFJcFMsS0FBSyxJQUFUO0FBQ0EsU0FBSUEsR0FBR3lVLFFBQVAsRUFBaUI7QUFDZnpVLFVBQUd5VSxRQUFILENBQVlyUCxNQUFaO0FBQ0Q7QUFDRixJQUxEOztBQU9Ba08sT0FBSTVqQixTQUFKLENBQWNtbUIsUUFBZCxHQUF5QixZQUFZO0FBQ25DLFNBQUk3VixLQUFLLElBQVQ7QUFDQSxTQUFJQSxHQUFHOFUsaUJBQVAsRUFBMEI7QUFDeEI7QUFDRDtBQUNESSxjQUFTbFYsRUFBVCxFQUFhLGVBQWI7QUFDQUEsUUFBRzhVLGlCQUFILEdBQXVCLElBQXZCO0FBQ0E7QUFDQSxTQUFJeE0sU0FBU3RJLEdBQUdZLE9BQWhCO0FBQ0EsU0FBSTBILFVBQVUsQ0FBQ0EsT0FBT3dNLGlCQUFsQixJQUF1QyxDQUFDOVUsR0FBR00sUUFBSCxDQUFZZ1UsUUFBeEQsRUFBa0U7QUFDaEUxYSxjQUFPME8sT0FBT2lNLFNBQWQsRUFBeUJ2VSxFQUF6QjtBQUNEO0FBQ0Q7QUFDQSxTQUFJQSxHQUFHeVUsUUFBUCxFQUFpQjtBQUNmelUsVUFBR3lVLFFBQUgsQ0FBWXFCLFFBQVo7QUFDRDtBQUNELFNBQUl6bEIsSUFBSTJQLEdBQUcrVixTQUFILENBQWF6bEIsTUFBckI7QUFDQSxZQUFPRCxHQUFQLEVBQVk7QUFDVjJQLFVBQUcrVixTQUFILENBQWExbEIsQ0FBYixFQUFnQnlsQixRQUFoQjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFNBQUk5VixHQUFHZ1csS0FBSCxDQUFTOVAsTUFBYixFQUFxQjtBQUNuQmxHLFVBQUdnVyxLQUFILENBQVM5UCxNQUFULENBQWdCUyxPQUFoQjtBQUNEO0FBQ0Q7QUFDQTNHLFFBQUc2VSxZQUFILEdBQWtCLElBQWxCO0FBQ0E7QUFDQTdVLFFBQUd3VixTQUFILENBQWF4VixHQUFHc1YsTUFBaEIsRUFBd0IsSUFBeEI7QUFDQTtBQUNBSixjQUFTbFYsRUFBVCxFQUFhLFdBQWI7QUFDQTtBQUNBQSxRQUFHbVQsSUFBSDtBQUNBO0FBQ0EsU0FBSW5ULEdBQUdvVixHQUFQLEVBQVk7QUFDVnBWLFVBQUdvVixHQUFILENBQU9PLE9BQVAsR0FBaUIsSUFBakI7QUFDRDtBQUNGLElBckNEO0FBc0NEOztBQUVELFVBQVNNLGNBQVQsQ0FDRWpXLEVBREYsRUFFRW9JLEVBRkYsRUFHRTZNLFNBSEYsRUFJRTtBQUNBalYsTUFBR29WLEdBQUgsR0FBU2hOLEVBQVQ7QUFDQSxPQUFJLENBQUNwSSxHQUFHTSxRQUFILENBQVlpTixNQUFqQixFQUF5QjtBQUN2QnZOLFFBQUdNLFFBQUgsQ0FBWWlOLE1BQVosR0FBcUJ1QixnQkFBckI7QUFDQSxTQUFJblIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDO0FBQ0EsV0FBS21DLEdBQUdNLFFBQUgsQ0FBWTRWLFFBQVosSUFBd0JsVyxHQUFHTSxRQUFILENBQVk0VixRQUFaLENBQXFCcGIsTUFBckIsQ0FBNEIsQ0FBNUIsTUFBbUMsR0FBNUQsSUFDRmtGLEdBQUdNLFFBQUgsQ0FBWThILEVBRFYsSUFDZ0JBLEVBRHBCLEVBQ3dCO0FBQ3RCM0ksY0FDRSxvRUFDQSxtRUFEQSxHQUVBLHVEQUhGLEVBSUVPLEVBSkY7QUFNRCxRQVJELE1BUU87QUFDTFAsY0FDRSxxRUFERixFQUVFTyxFQUZGO0FBSUQ7QUFDRjtBQUNGO0FBQ0RrVixZQUFTbFYsRUFBVCxFQUFhLGFBQWI7O0FBRUEsT0FBSW1XLGVBQUo7QUFDQTtBQUNBLE9BQUl4WSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkU4Six1QkFBa0IsMkJBQVk7QUFDNUIsV0FBSXZsQixPQUFPb1AsR0FBR29XLEtBQWQ7QUFDQSxXQUFJbmhCLEtBQUsrSyxHQUFHcVcsSUFBWjtBQUNBLFdBQUkxSixXQUFXLG9CQUFvQjFYLEVBQW5DO0FBQ0EsV0FBSTJYLFNBQVMsa0JBQWtCM1gsRUFBL0I7O0FBRUFvWCxZQUFLTSxRQUFMO0FBQ0EsV0FBSXVDLFFBQVFsUCxHQUFHc1csT0FBSCxFQUFaO0FBQ0FqSyxZQUFLTyxNQUFMO0FBQ0FOLGVBQVMxYixPQUFPLFNBQWhCLEVBQTRCK2IsUUFBNUIsRUFBc0NDLE1BQXRDOztBQUVBUCxZQUFLTSxRQUFMO0FBQ0EzTSxVQUFHZ1YsT0FBSCxDQUFXOUYsS0FBWCxFQUFrQitGLFNBQWxCO0FBQ0E1SSxZQUFLTyxNQUFMO0FBQ0FOLGVBQVMxYixPQUFPLFFBQWhCLEVBQTJCK2IsUUFBM0IsRUFBcUNDLE1BQXJDO0FBQ0QsTUFmRDtBQWdCRCxJQWpCRCxNQWlCTztBQUNMdUosdUJBQWtCLDJCQUFZO0FBQzVCblcsVUFBR2dWLE9BQUgsQ0FBV2hWLEdBQUdzVyxPQUFILEVBQVgsRUFBeUJyQixTQUF6QjtBQUNELE1BRkQ7QUFHRDs7QUFFRGpWLE1BQUd5VSxRQUFILEdBQWMsSUFBSThCLE9BQUosQ0FBWXZXLEVBQVosRUFBZ0JtVyxlQUFoQixFQUFpQ2xuQixJQUFqQyxDQUFkO0FBQ0FnbUIsZUFBWSxLQUFaOztBQUVBO0FBQ0E7QUFDQSxPQUFJalYsR0FBRzRWLE1BQUgsSUFBYSxJQUFqQixFQUF1QjtBQUNyQjVWLFFBQUc0VSxVQUFILEdBQWdCLElBQWhCO0FBQ0FNLGNBQVNsVixFQUFULEVBQWEsU0FBYjtBQUNEO0FBQ0QsVUFBT0EsRUFBUDtBQUNEOztBQUVELFVBQVN3VyxvQkFBVCxDQUNFeFcsRUFERixFQUVFcUksU0FGRixFQUdFd0ssU0FIRixFQUlFNEQsV0FKRixFQUtFQyxjQUxGLEVBTUU7QUFDQSxPQUFJL1ksUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDdVcsZ0NBQTJCLElBQTNCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQUl1QyxjQUFjLENBQUMsRUFDakJELGtCQUFnQztBQUNoQzFXLE1BQUdNLFFBQUgsQ0FBWXNXLGVBRFosSUFDZ0M7QUFDaENILGVBQVk3Z0IsSUFBWixDQUFpQmloQixXQUZqQixJQUVnQztBQUNoQzdXLE1BQUc4VyxZQUFILEtBQW9CblksV0FKSCxDQUllO0FBSmYsSUFBbkI7O0FBT0FxQixNQUFHTSxRQUFILENBQVl5VyxZQUFaLEdBQTJCTixXQUEzQjtBQUNBelcsTUFBRzRWLE1BQUgsR0FBWWEsV0FBWixDQWZBLENBZXlCOztBQUV6QixPQUFJelcsR0FBR3NWLE1BQVAsRUFBZTtBQUFFO0FBQ2Z0VixRQUFHc1YsTUFBSCxDQUFVaE4sTUFBVixHQUFtQm1PLFdBQW5CO0FBQ0Q7QUFDRHpXLE1BQUdNLFFBQUgsQ0FBWXNXLGVBQVosR0FBOEJGLGNBQTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBMVcsTUFBR2dYLE1BQUgsR0FBWVAsWUFBWTdnQixJQUFaLElBQW9CNmdCLFlBQVk3Z0IsSUFBWixDQUFpQjhhLEtBQWpEO0FBQ0ExUSxNQUFHaVgsVUFBSCxHQUFnQnBFLFNBQWhCOztBQUVBO0FBQ0EsT0FBSXhLLGFBQWFySSxHQUFHTSxRQUFILENBQVlrSixLQUE3QixFQUFvQztBQUNsQ2hELG1CQUFjQyxhQUFkLEdBQThCLEtBQTlCO0FBQ0EsU0FBSStDLFFBQVF4SixHQUFHMkwsTUFBZjtBQUNBLFNBQUl1TCxXQUFXbFgsR0FBR00sUUFBSCxDQUFZNlcsU0FBWixJQUF5QixFQUF4QztBQUNBLFVBQUssSUFBSTltQixJQUFJLENBQWIsRUFBZ0JBLElBQUk2bUIsU0FBUzVtQixNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDeEMsV0FBSTZKLE1BQU1nZCxTQUFTN21CLENBQVQsQ0FBVjtBQUNBbVosYUFBTXRQLEdBQU4sSUFBYStRLGFBQWEvUSxHQUFiLEVBQWtCOEYsR0FBR00sUUFBSCxDQUFZa0osS0FBOUIsRUFBcUNuQixTQUFyQyxFQUFnRHJJLEVBQWhELENBQWI7QUFDRDtBQUNEd0csbUJBQWNDLGFBQWQsR0FBOEIsSUFBOUI7QUFDQTtBQUNBekcsUUFBR00sUUFBSCxDQUFZK0gsU0FBWixHQUF3QkEsU0FBeEI7QUFDRDs7QUFFRDtBQUNBLE9BQUl3SyxTQUFKLEVBQWU7QUFDYixTQUFJTyxlQUFlcFQsR0FBR00sUUFBSCxDQUFZd1MsZ0JBQS9CO0FBQ0E5UyxRQUFHTSxRQUFILENBQVl3UyxnQkFBWixHQUErQkQsU0FBL0I7QUFDQUUsOEJBQXlCL1MsRUFBekIsRUFBNkI2UyxTQUE3QixFQUF3Q08sWUFBeEM7QUFDRDtBQUNEO0FBQ0EsT0FBSXVELFdBQUosRUFBaUI7QUFDZjNXLFFBQUdvWCxNQUFILEdBQVl2RCxhQUFhNkMsY0FBYixFQUE2QkQsWUFBWTNJLE9BQXpDLENBQVo7QUFDQTlOLFFBQUdvUyxZQUFIO0FBQ0Q7O0FBRUQsT0FBSXpVLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3VXLGdDQUEyQixLQUEzQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU2lELGdCQUFULENBQTJCclgsRUFBM0IsRUFBK0I7QUFDN0IsVUFBT0EsT0FBT0EsS0FBS0EsR0FBR1ksT0FBZixDQUFQLEVBQWdDO0FBQzlCLFNBQUlaLEdBQUcwVSxTQUFQLEVBQWtCO0FBQUUsY0FBTyxJQUFQO0FBQWE7QUFDbEM7QUFDRCxVQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFTNEMsc0JBQVQsQ0FBaUN0WCxFQUFqQyxFQUFxQ3VYLE1BQXJDLEVBQTZDO0FBQzNDLE9BQUlBLE1BQUosRUFBWTtBQUNWdlgsUUFBRzJVLGVBQUgsR0FBcUIsS0FBckI7QUFDQSxTQUFJMEMsaUJBQWlCclgsRUFBakIsQ0FBSixFQUEwQjtBQUN4QjtBQUNEO0FBQ0YsSUFMRCxNQUtPLElBQUlBLEdBQUcyVSxlQUFQLEVBQXdCO0FBQzdCO0FBQ0Q7QUFDRCxPQUFJM1UsR0FBRzBVLFNBQUgsSUFBZ0IxVSxHQUFHMFUsU0FBSCxLQUFpQixJQUFyQyxFQUEyQztBQUN6QzFVLFFBQUcwVSxTQUFILEdBQWUsS0FBZjtBQUNBLFVBQUssSUFBSXJrQixJQUFJLENBQWIsRUFBZ0JBLElBQUkyUCxHQUFHdVUsU0FBSCxDQUFhamtCLE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1Q2luQiw4QkFBdUJ0WCxHQUFHdVUsU0FBSCxDQUFhbGtCLENBQWIsQ0FBdkI7QUFDRDtBQUNENmtCLGNBQVNsVixFQUFULEVBQWEsV0FBYjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU3dYLHdCQUFULENBQW1DeFgsRUFBbkMsRUFBdUN1WCxNQUF2QyxFQUErQztBQUM3QyxPQUFJQSxNQUFKLEVBQVk7QUFDVnZYLFFBQUcyVSxlQUFILEdBQXFCLElBQXJCO0FBQ0EsU0FBSTBDLGlCQUFpQnJYLEVBQWpCLENBQUosRUFBMEI7QUFDeEI7QUFDRDtBQUNGO0FBQ0QsT0FBSSxDQUFDQSxHQUFHMFUsU0FBUixFQUFtQjtBQUNqQjFVLFFBQUcwVSxTQUFILEdBQWUsSUFBZjtBQUNBLFVBQUssSUFBSXJrQixJQUFJLENBQWIsRUFBZ0JBLElBQUkyUCxHQUFHdVUsU0FBSCxDQUFhamtCLE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1Q21uQixnQ0FBeUJ4WCxHQUFHdVUsU0FBSCxDQUFhbGtCLENBQWIsQ0FBekI7QUFDRDtBQUNENmtCLGNBQVNsVixFQUFULEVBQWEsYUFBYjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU2tWLFFBQVQsQ0FBbUJsVixFQUFuQixFQUF1QnFKLElBQXZCLEVBQTZCO0FBQzNCLE9BQUlpRSxXQUFXdE4sR0FBR00sUUFBSCxDQUFZK0ksSUFBWixDQUFmO0FBQ0EsT0FBSWlFLFFBQUosRUFBYztBQUNaLFVBQUssSUFBSWpkLElBQUksQ0FBUixFQUFXb25CLElBQUluSyxTQUFTaGQsTUFBN0IsRUFBcUNELElBQUlvbkIsQ0FBekMsRUFBNENwbkIsR0FBNUMsRUFBaUQ7QUFDL0MsV0FBSTtBQUNGaWQsa0JBQVNqZCxDQUFULEVBQVlWLElBQVosQ0FBaUJxUSxFQUFqQjtBQUNELFFBRkQsQ0FFRSxPQUFPcFEsQ0FBUCxFQUFVO0FBQ1ZzUixxQkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBb0JxSixPQUFPLE9BQTNCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsT0FBSXJKLEdBQUc0UyxhQUFQLEVBQXNCO0FBQ3BCNVMsUUFBRzJULEtBQUgsQ0FBUyxVQUFVdEssSUFBbkI7QUFDRDtBQUNGOztBQUVEOztBQUdBLEtBQUlxTyxtQkFBbUIsR0FBdkI7O0FBRUEsS0FBSUMsUUFBUSxFQUFaO0FBQ0EsS0FBSUMsb0JBQW9CLEVBQXhCO0FBQ0EsS0FBSXJULE1BQU0sRUFBVjtBQUNBLEtBQUlzVCxXQUFXLEVBQWY7QUFDQSxLQUFJQyxVQUFVLEtBQWQ7QUFDQSxLQUFJQyxXQUFXLEtBQWY7QUFDQSxLQUFJMWpCLFFBQVEsQ0FBWjs7QUFFQTs7O0FBR0EsVUFBUzJqQixtQkFBVCxHQUFnQztBQUM5QjNqQixXQUFRc2pCLE1BQU1ybkIsTUFBTixHQUFlc25CLGtCQUFrQnRuQixNQUFsQixHQUEyQixDQUFsRDtBQUNBaVUsU0FBTSxFQUFOO0FBQ0EsT0FBSTVHLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2dhLGdCQUFXLEVBQVg7QUFDRDtBQUNEQyxhQUFVQyxXQUFXLEtBQXJCO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNFLG1CQUFULEdBQWdDO0FBQzlCRixjQUFXLElBQVg7QUFDQSxPQUFJRyxPQUFKLEVBQWFqakIsRUFBYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EwaUIsU0FBTVEsSUFBTixDQUFXLFVBQVVoZCxDQUFWLEVBQWFXLENBQWIsRUFBZ0I7QUFBRSxZQUFPWCxFQUFFbEcsRUFBRixHQUFPNkcsRUFBRTdHLEVBQWhCO0FBQXFCLElBQWxEOztBQUVBO0FBQ0E7QUFDQSxRQUFLWixRQUFRLENBQWIsRUFBZ0JBLFFBQVFzakIsTUFBTXJuQixNQUE5QixFQUFzQytELE9BQXRDLEVBQStDO0FBQzdDNmpCLGVBQVVQLE1BQU10akIsS0FBTixDQUFWO0FBQ0FZLFVBQUtpakIsUUFBUWpqQixFQUFiO0FBQ0FzUCxTQUFJdFAsRUFBSixJQUFVLElBQVY7QUFDQWlqQixhQUFRRSxHQUFSO0FBQ0E7QUFDQSxTQUFJemEsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDMEcsSUFBSXRQLEVBQUosS0FBVyxJQUF4RCxFQUE4RDtBQUM1RDRpQixnQkFBUzVpQixFQUFULElBQWUsQ0FBQzRpQixTQUFTNWlCLEVBQVQsS0FBZ0IsQ0FBakIsSUFBc0IsQ0FBckM7QUFDQSxXQUFJNGlCLFNBQVM1aUIsRUFBVCxJQUFleWlCLGdCQUFuQixFQUFxQztBQUNuQ2pZLGNBQ0UsMkNBQ0V5WSxRQUFRRyxJQUFSLEdBQ0ssa0NBQW1DSCxRQUFRSSxVQUEzQyxHQUF5RCxJQUQ5RCxHQUVJLGlDQUhOLENBREYsRUFNRUosUUFBUWxZLEVBTlY7QUFRQTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBLE9BQUl1WSxpQkFBaUJYLGtCQUFrQjNsQixLQUFsQixFQUFyQjtBQUNBLE9BQUl1bUIsZUFBZWIsTUFBTTFsQixLQUFOLEVBQW5COztBQUVBK2xCOztBQUVBO0FBQ0FTLHNCQUFtQkYsY0FBbkI7QUFDQUcsb0JBQWlCRixZQUFqQjs7QUFFQTtBQUNBO0FBQ0EsT0FBSTFhLFlBQVlQLE9BQU9PLFFBQXZCLEVBQWlDO0FBQy9CQSxjQUFTNmEsSUFBVCxDQUFjLE9BQWQ7QUFDRDtBQUNGOztBQUVELFVBQVNELGdCQUFULENBQTJCZixLQUEzQixFQUFrQztBQUNoQyxPQUFJdG5CLElBQUlzbkIsTUFBTXJuQixNQUFkO0FBQ0EsVUFBT0QsR0FBUCxFQUFZO0FBQ1YsU0FBSTZuQixVQUFVUCxNQUFNdG5CLENBQU4sQ0FBZDtBQUNBLFNBQUkyUCxLQUFLa1ksUUFBUWxZLEVBQWpCO0FBQ0EsU0FBSUEsR0FBR3lVLFFBQUgsS0FBZ0J5RCxPQUFoQixJQUEyQmxZLEdBQUc0VSxVQUFsQyxFQUE4QztBQUM1Q00sZ0JBQVNsVixFQUFULEVBQWEsU0FBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVM0WSx1QkFBVCxDQUFrQzVZLEVBQWxDLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQUEsTUFBRzBVLFNBQUgsR0FBZSxLQUFmO0FBQ0FrRCxxQkFBa0IzVyxJQUFsQixDQUF1QmpCLEVBQXZCO0FBQ0Q7O0FBRUQsVUFBU3lZLGtCQUFULENBQTZCZCxLQUE3QixFQUFvQztBQUNsQyxRQUFLLElBQUl0bkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc25CLE1BQU1ybkIsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3JDc25CLFdBQU10bkIsQ0FBTixFQUFTcWtCLFNBQVQsR0FBcUIsSUFBckI7QUFDQTRDLDRCQUF1QkssTUFBTXRuQixDQUFOLENBQXZCLEVBQWlDLElBQWpDLENBQXNDLFVBQXRDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7QUFLQSxVQUFTd29CLFlBQVQsQ0FBdUJYLE9BQXZCLEVBQWdDO0FBQzlCLE9BQUlqakIsS0FBS2lqQixRQUFRampCLEVBQWpCO0FBQ0EsT0FBSXNQLElBQUl0UCxFQUFKLEtBQVcsSUFBZixFQUFxQjtBQUNuQnNQLFNBQUl0UCxFQUFKLElBQVUsSUFBVjtBQUNBLFNBQUksQ0FBQzhpQixRQUFMLEVBQWU7QUFDYkosYUFBTTFXLElBQU4sQ0FBV2lYLE9BQVg7QUFDRCxNQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EsV0FBSTduQixJQUFJc25CLE1BQU1ybkIsTUFBTixHQUFlLENBQXZCO0FBQ0EsY0FBT0QsSUFBSWdFLEtBQUosSUFBYXNqQixNQUFNdG5CLENBQU4sRUFBUzRFLEVBQVQsR0FBY2lqQixRQUFRampCLEVBQTFDLEVBQThDO0FBQzVDNUU7QUFDRDtBQUNEc25CLGFBQU01ZCxNQUFOLENBQWExSixJQUFJLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCNm5CLE9BQXZCO0FBQ0Q7QUFDRDtBQUNBLFNBQUksQ0FBQ0osT0FBTCxFQUFjO0FBQ1pBLGlCQUFVLElBQVY7QUFDQTlVLGdCQUFTaVYsbUJBQVQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSWEsUUFBUSxDQUFaOztBQUVBOzs7OztBQUtBLEtBQUl2QyxVQUFVLFNBQVNBLE9BQVQsQ0FDWnZXLEVBRFksRUFFWitZLE9BRlksRUFHWjdVLEVBSFksRUFJWjlELE9BSlksRUFLWjtBQUNBLFFBQUtKLEVBQUwsR0FBVUEsRUFBVjtBQUNBQSxNQUFHK1YsU0FBSCxDQUFhOVUsSUFBYixDQUFrQixJQUFsQjtBQUNBO0FBQ0EsT0FBSWIsT0FBSixFQUFhO0FBQ1gsVUFBSzRZLElBQUwsR0FBWSxDQUFDLENBQUM1WSxRQUFRNFksSUFBdEI7QUFDQSxVQUFLWCxJQUFMLEdBQVksQ0FBQyxDQUFDalksUUFBUWlZLElBQXRCO0FBQ0EsVUFBS1ksSUFBTCxHQUFZLENBQUMsQ0FBQzdZLFFBQVE2WSxJQUF0QjtBQUNBLFVBQUsvRyxJQUFMLEdBQVksQ0FBQyxDQUFDOVIsUUFBUThSLElBQXRCO0FBQ0QsSUFMRCxNQUtPO0FBQ0wsVUFBSzhHLElBQUwsR0FBWSxLQUFLWCxJQUFMLEdBQVksS0FBS1ksSUFBTCxHQUFZLEtBQUsvRyxJQUFMLEdBQVksS0FBaEQ7QUFDRDtBQUNELFFBQUtoTyxFQUFMLEdBQVVBLEVBQVY7QUFDQSxRQUFLalAsRUFBTCxHQUFVLEVBQUU2akIsS0FBWixDQWJBLENBYW1CO0FBQ25CLFFBQUtoa0IsTUFBTCxHQUFjLElBQWQ7QUFDQSxRQUFLb2tCLEtBQUwsR0FBYSxLQUFLRCxJQUFsQixDQWZBLENBZXdCO0FBQ3hCLFFBQUtFLElBQUwsR0FBWSxFQUFaO0FBQ0EsUUFBS0MsT0FBTCxHQUFlLEVBQWY7QUFDQSxRQUFLQyxNQUFMLEdBQWMsSUFBSWpWLElBQUosRUFBZDtBQUNBLFFBQUtrVixTQUFMLEdBQWlCLElBQUlsVixJQUFKLEVBQWpCO0FBQ0EsUUFBS2tVLFVBQUwsR0FBa0IzYSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsR0FDZGtiLFFBQVE1Z0IsUUFBUixFQURjLEdBRWQsRUFGSjtBQUdBO0FBQ0EsT0FBSSxPQUFPNGdCLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakMsVUFBS3JSLE1BQUwsR0FBY3FSLE9BQWQ7QUFDRCxJQUZELE1BRU87QUFDTCxVQUFLclIsTUFBTCxHQUFjckksVUFBVTBaLE9BQVYsQ0FBZDtBQUNBLFNBQUksQ0FBQyxLQUFLclIsTUFBVixFQUFrQjtBQUNoQixZQUFLQSxNQUFMLEdBQWMsWUFBWSxDQUFFLENBQTVCO0FBQ0EvSixlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2Qyw2QkFBNkJzWixPQUE3QixHQUF1QyxLQUF2QyxHQUNBLG1EQURBLEdBRUEsMkNBSHVDLEVBSXZDL1ksRUFKdUMsQ0FBekM7QUFNRDtBQUNGO0FBQ0QsUUFBS2hJLEtBQUwsR0FBYSxLQUFLaWhCLElBQUwsR0FDVGhwQixTQURTLEdBRVQsS0FBS2tTLEdBQUwsRUFGSjtBQUdELEVBOUNEOztBQWdEQTs7O0FBR0FvVSxTQUFRN21CLFNBQVIsQ0FBa0J5UyxHQUFsQixHQUF3QixTQUFTQSxHQUFULEdBQWdCO0FBQ3RDbUQsY0FBVyxJQUFYO0FBQ0EsT0FBSXROLEtBQUo7QUFDQSxPQUFJZ0ksS0FBSyxLQUFLQSxFQUFkO0FBQ0EsT0FBSTtBQUNGaEksYUFBUSxLQUFLMFAsTUFBTCxDQUFZL1gsSUFBWixDQUFpQnFRLEVBQWpCLEVBQXFCQSxFQUFyQixDQUFSO0FBQ0QsSUFGRCxDQUVFLE9BQU9wUSxDQUFQLEVBQVU7QUFDVixTQUFJLEtBQUt5b0IsSUFBVCxFQUFlO0FBQ2JuWCxtQkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBb0IsMEJBQTJCLEtBQUtzWSxVQUFoQyxHQUE4QyxJQUFsRTtBQUNELE1BRkQsTUFFTztBQUNMLGFBQU0xb0IsQ0FBTjtBQUNEO0FBQ0YsSUFSRCxTQVFVO0FBQ1I7QUFDQTtBQUNBLFNBQUksS0FBS29wQixJQUFULEVBQWU7QUFDYk8sZ0JBQVN2aEIsS0FBVDtBQUNEO0FBQ0R3TjtBQUNBLFVBQUtnVSxXQUFMO0FBQ0Q7QUFDRCxVQUFPeGhCLEtBQVA7QUFDRCxFQXRCRDs7QUF3QkE7OztBQUdBdWUsU0FBUTdtQixTQUFSLENBQWtCd1YsTUFBbEIsR0FBMkIsU0FBU0EsTUFBVCxDQUFpQm1CLEdBQWpCLEVBQXNCO0FBQy9DLE9BQUlwUixLQUFLb1IsSUFBSXBSLEVBQWI7QUFDQSxPQUFJLENBQUMsS0FBS3FrQixTQUFMLENBQWUvVSxHQUFmLENBQW1CdFAsRUFBbkIsQ0FBTCxFQUE2QjtBQUMzQixVQUFLcWtCLFNBQUwsQ0FBZTlVLEdBQWYsQ0FBbUJ2UCxFQUFuQjtBQUNBLFVBQUtta0IsT0FBTCxDQUFhblksSUFBYixDQUFrQm9GLEdBQWxCO0FBQ0EsU0FBSSxDQUFDLEtBQUtnVCxNQUFMLENBQVk5VSxHQUFaLENBQWdCdFAsRUFBaEIsQ0FBTCxFQUEwQjtBQUN4Qm9SLFdBQUl4QixNQUFKLENBQVcsSUFBWDtBQUNEO0FBQ0Y7QUFDRixFQVREOztBQVdBOzs7QUFHQTBSLFNBQVE3bUIsU0FBUixDQUFrQjhwQixXQUFsQixHQUFnQyxTQUFTQSxXQUFULEdBQXdCO0FBQ3BELE9BQUloRyxTQUFTLElBQWI7O0FBRUYsT0FBSW5qQixJQUFJLEtBQUs4b0IsSUFBTCxDQUFVN29CLE1BQWxCO0FBQ0EsVUFBT0QsR0FBUCxFQUFZO0FBQ1YsU0FBSWdXLE1BQU1tTixPQUFPMkYsSUFBUCxDQUFZOW9CLENBQVosQ0FBVjtBQUNBLFNBQUksQ0FBQ21qQixPQUFPOEYsU0FBUCxDQUFpQi9VLEdBQWpCLENBQXFCOEIsSUFBSXBSLEVBQXpCLENBQUwsRUFBbUM7QUFDakNvUixXQUFJdEIsU0FBSixDQUFjeU8sTUFBZDtBQUNEO0FBQ0Y7QUFDRCxPQUFJaUcsTUFBTSxLQUFLSixNQUFmO0FBQ0EsUUFBS0EsTUFBTCxHQUFjLEtBQUtDLFNBQW5CO0FBQ0EsUUFBS0EsU0FBTCxHQUFpQkcsR0FBakI7QUFDQSxRQUFLSCxTQUFMLENBQWU3VSxLQUFmO0FBQ0FnVixTQUFNLEtBQUtOLElBQVg7QUFDQSxRQUFLQSxJQUFMLEdBQVksS0FBS0MsT0FBakI7QUFDQSxRQUFLQSxPQUFMLEdBQWVLLEdBQWY7QUFDQSxRQUFLTCxPQUFMLENBQWE5b0IsTUFBYixHQUFzQixDQUF0QjtBQUNELEVBbEJEOztBQW9CQTs7OztBQUlBaW1CLFNBQVE3bUIsU0FBUixDQUFrQjBWLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsR0FBbUI7QUFDNUM7QUFDQSxPQUFJLEtBQUs2VCxJQUFULEVBQWU7QUFDYixVQUFLQyxLQUFMLEdBQWEsSUFBYjtBQUNELElBRkQsTUFFTyxJQUFJLEtBQUtoSCxJQUFULEVBQWU7QUFDcEIsVUFBS2tHLEdBQUw7QUFDRCxJQUZNLE1BRUE7QUFDTFMsa0JBQWEsSUFBYjtBQUNEO0FBQ0YsRUFURDs7QUFXQTs7OztBQUlBdEMsU0FBUTdtQixTQUFSLENBQWtCMG9CLEdBQWxCLEdBQXdCLFNBQVNBLEdBQVQsR0FBZ0I7QUFDdEMsT0FBSSxLQUFLdGpCLE1BQVQsRUFBaUI7QUFDZixTQUFJa0QsUUFBUSxLQUFLbUssR0FBTCxFQUFaO0FBQ0EsU0FDRW5LLFVBQVUsS0FBS0EsS0FBZjtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxjQUFTRCxLQUFULENBSkEsSUFLQSxLQUFLZ2hCLElBTlAsRUFPRTtBQUNBO0FBQ0EsV0FBSVUsV0FBVyxLQUFLMWhCLEtBQXBCO0FBQ0EsWUFBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsV0FBSSxLQUFLcWdCLElBQVQsRUFBZTtBQUNiLGFBQUk7QUFDRixnQkFBS25VLEVBQUwsQ0FBUXZVLElBQVIsQ0FBYSxLQUFLcVEsRUFBbEIsRUFBc0JoSSxLQUF0QixFQUE2QjBoQixRQUE3QjtBQUNELFVBRkQsQ0FFRSxPQUFPOXBCLENBQVAsRUFBVTtBQUNWc1IsdUJBQVl0UixDQUFaLEVBQWUsS0FBS29RLEVBQXBCLEVBQXlCLDRCQUE2QixLQUFLc1ksVUFBbEMsR0FBZ0QsSUFBekU7QUFDRDtBQUNGLFFBTkQsTUFNTztBQUNMLGNBQUtwVSxFQUFMLENBQVF2VSxJQUFSLENBQWEsS0FBS3FRLEVBQWxCLEVBQXNCaEksS0FBdEIsRUFBNkIwaEIsUUFBN0I7QUFDRDtBQUNGO0FBQ0Y7QUFDRixFQXpCRDs7QUEyQkE7Ozs7QUFJQW5ELFNBQVE3bUIsU0FBUixDQUFrQmlxQixRQUFsQixHQUE2QixTQUFTQSxRQUFULEdBQXFCO0FBQ2hELFFBQUszaEIsS0FBTCxHQUFhLEtBQUttSyxHQUFMLEVBQWI7QUFDQSxRQUFLK1csS0FBTCxHQUFhLEtBQWI7QUFDRCxFQUhEOztBQUtBOzs7QUFHQTNDLFNBQVE3bUIsU0FBUixDQUFrQnNWLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsR0FBbUI7QUFDMUMsT0FBSXdPLFNBQVMsSUFBYjs7QUFFRixPQUFJbmpCLElBQUksS0FBSzhvQixJQUFMLENBQVU3b0IsTUFBbEI7QUFDQSxVQUFPRCxHQUFQLEVBQVk7QUFDVm1qQixZQUFPMkYsSUFBUCxDQUFZOW9CLENBQVosRUFBZTJVLE1BQWY7QUFDRDtBQUNGLEVBUEQ7O0FBU0E7OztBQUdBdVIsU0FBUTdtQixTQUFSLENBQWtCb21CLFFBQWxCLEdBQTZCLFNBQVNBLFFBQVQsR0FBcUI7QUFDOUMsT0FBSXRDLFNBQVMsSUFBYjs7QUFFRixPQUFJLEtBQUsxZSxNQUFULEVBQWlCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBSSxDQUFDLEtBQUtrTCxFQUFMLENBQVE4VSxpQkFBYixFQUFnQztBQUM5QmxiLGNBQU8sS0FBS29HLEVBQUwsQ0FBUStWLFNBQWYsRUFBMEIsSUFBMUI7QUFDRDtBQUNELFNBQUkxbEIsSUFBSSxLQUFLOG9CLElBQUwsQ0FBVTdvQixNQUFsQjtBQUNBLFlBQU9ELEdBQVAsRUFBWTtBQUNWbWpCLGNBQU8yRixJQUFQLENBQVk5b0IsQ0FBWixFQUFlMFUsU0FBZixDQUF5QnlPLE1BQXpCO0FBQ0Q7QUFDRCxVQUFLMWUsTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGLEVBaEJEOztBQWtCQTs7Ozs7QUFLQSxLQUFJOGtCLGNBQWMsSUFBSXhWLElBQUosRUFBbEI7QUFDQSxVQUFTbVYsUUFBVCxDQUFtQmhoQixHQUFuQixFQUF3QjtBQUN0QnFoQixlQUFZblYsS0FBWjtBQUNBb1YsYUFBVXRoQixHQUFWLEVBQWVxaEIsV0FBZjtBQUNEOztBQUVELFVBQVNDLFNBQVQsQ0FBb0J0aEIsR0FBcEIsRUFBeUJ1aEIsSUFBekIsRUFBK0I7QUFDN0IsT0FBSXpwQixDQUFKLEVBQU82RyxJQUFQO0FBQ0EsT0FBSTZpQixNQUFNdGUsTUFBTW1CLE9BQU4sQ0FBY3JFLEdBQWQsQ0FBVjtBQUNBLE9BQUssQ0FBQ3doQixHQUFELElBQVEsQ0FBQzloQixTQUFTTSxHQUFULENBQVYsSUFBNEIsQ0FBQ3RCLE9BQU9vUSxZQUFQLENBQW9COU8sR0FBcEIsQ0FBakMsRUFBMkQ7QUFDekQ7QUFDRDtBQUNELE9BQUlBLElBQUkyTixNQUFSLEVBQWdCO0FBQ2QsU0FBSThULFFBQVF6aEIsSUFBSTJOLE1BQUosQ0FBV0csR0FBWCxDQUFlcFIsRUFBM0I7QUFDQSxTQUFJNmtCLEtBQUt2VixHQUFMLENBQVN5VixLQUFULENBQUosRUFBcUI7QUFDbkI7QUFDRDtBQUNERixVQUFLdFYsR0FBTCxDQUFTd1YsS0FBVDtBQUNEO0FBQ0QsT0FBSUQsR0FBSixFQUFTO0FBQ1AxcEIsU0FBSWtJLElBQUlqSSxNQUFSO0FBQ0EsWUFBT0QsR0FBUCxFQUFZO0FBQUV3cEIsaUJBQVV0aEIsSUFBSWxJLENBQUosQ0FBVixFQUFrQnlwQixJQUFsQjtBQUEwQjtBQUN6QyxJQUhELE1BR087QUFDTDVpQixZQUFPRCxPQUFPQyxJQUFQLENBQVlxQixHQUFaLENBQVA7QUFDQWxJLFNBQUk2RyxLQUFLNUcsTUFBVDtBQUNBLFlBQU9ELEdBQVAsRUFBWTtBQUFFd3BCLGlCQUFVdGhCLElBQUlyQixLQUFLN0csQ0FBTCxDQUFKLENBQVYsRUFBd0J5cEIsSUFBeEI7QUFBZ0M7QUFDL0M7QUFDRjs7QUFFRDs7QUFFQSxLQUFJRywyQkFBMkI7QUFDN0JqYixlQUFZLElBRGlCO0FBRTdCRyxpQkFBYyxJQUZlO0FBRzdCZ0QsUUFBS2xULElBSHdCO0FBSTdCcVYsUUFBS3JWO0FBSndCLEVBQS9COztBQU9BLFVBQVNpckIsS0FBVCxDQUFnQmpWLE1BQWhCLEVBQXdCa1YsU0FBeEIsRUFBbUNqZ0IsR0FBbkMsRUFBd0M7QUFDdEMrZiw0QkFBeUI5WCxHQUF6QixHQUErQixTQUFTaVksV0FBVCxHQUF3QjtBQUNyRCxZQUFPLEtBQUtELFNBQUwsRUFBZ0JqZ0IsR0FBaEIsQ0FBUDtBQUNELElBRkQ7QUFHQStmLDRCQUF5QjNWLEdBQXpCLEdBQStCLFNBQVMrVixXQUFULENBQXNCOWhCLEdBQXRCLEVBQTJCO0FBQ3hELFVBQUs0aEIsU0FBTCxFQUFnQmpnQixHQUFoQixJQUF1QjNCLEdBQXZCO0FBQ0QsSUFGRDtBQUdBdEIsVUFBT2dJLGNBQVAsQ0FBc0JnRyxNQUF0QixFQUE4Qi9LLEdBQTlCLEVBQW1DK2Ysd0JBQW5DO0FBQ0Q7O0FBRUQsVUFBU0ssU0FBVCxDQUFvQnRhLEVBQXBCLEVBQXdCO0FBQ3RCQSxNQUFHK1YsU0FBSCxHQUFlLEVBQWY7QUFDQSxPQUFJN1QsT0FBT2xDLEdBQUdNLFFBQWQ7QUFDQSxPQUFJNEIsS0FBS3NILEtBQVQsRUFBZ0I7QUFBRStRLGVBQVV2YSxFQUFWLEVBQWNrQyxLQUFLc0gsS0FBbkI7QUFBNEI7QUFDOUMsT0FBSXRILEtBQUt1SCxPQUFULEVBQWtCO0FBQUUrUSxpQkFBWXhhLEVBQVosRUFBZ0JrQyxLQUFLdUgsT0FBckI7QUFBZ0M7QUFDcEQsT0FBSXZILEtBQUt0TSxJQUFULEVBQWU7QUFDYjZrQixjQUFTemEsRUFBVDtBQUNELElBRkQsTUFFTztBQUNMK0QsYUFBUS9ELEdBQUdnVyxLQUFILEdBQVcsRUFBbkIsRUFBdUIsSUFBdkIsQ0FBNEIsZ0JBQTVCO0FBQ0Q7QUFDRCxPQUFJOVQsS0FBS3lILFFBQVQsRUFBbUI7QUFBRStRLGtCQUFhMWEsRUFBYixFQUFpQmtDLEtBQUt5SCxRQUF0QjtBQUFrQztBQUN2RCxPQUFJekgsS0FBS0YsS0FBTCxJQUFjRSxLQUFLRixLQUFMLEtBQWVELFdBQWpDLEVBQThDO0FBQzVDNFksZUFBVTNhLEVBQVYsRUFBY2tDLEtBQUtGLEtBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTNFksZUFBVCxDQUEwQjVhLEVBQTFCLEVBQThCcFAsSUFBOUIsRUFBb0M7QUFDbEMsT0FBSWlxQixTQUFTN2EsR0FBR00sUUFBSCxDQUFZMVAsSUFBWixDQUFiO0FBQ0EsT0FBSSxDQUFDd0gsY0FBY3lpQixNQUFkLENBQUwsRUFBNEI7QUFDMUJwYixVQUNHLHdCQUF3QjdPLElBQXhCLEdBQStCLHlCQURsQyxFQUVFb1AsRUFGRjtBQUlEO0FBQ0Y7O0FBRUQsVUFBU3VhLFNBQVQsQ0FBb0J2YSxFQUFwQixFQUF3QjhhLFlBQXhCLEVBQXNDO0FBQ3BDLE9BQUl6UyxZQUFZckksR0FBR00sUUFBSCxDQUFZK0gsU0FBWixJQUF5QixFQUF6QztBQUNBLE9BQUltQixRQUFReEosR0FBRzJMLE1BQUgsR0FBWSxFQUF4QjtBQUNBO0FBQ0E7QUFDQSxPQUFJelUsT0FBTzhJLEdBQUdNLFFBQUgsQ0FBWTZXLFNBQVosR0FBd0IsRUFBbkM7QUFDQSxPQUFJNEQsU0FBUyxDQUFDL2EsR0FBR1ksT0FBakI7QUFDQTtBQUNBNEYsaUJBQWNDLGFBQWQsR0FBOEJzVSxNQUE5QjtBQUNBLE9BQUlDLE9BQU8sU0FBUEEsSUFBTyxDQUFXOWdCLEdBQVgsRUFBaUI7QUFDMUJoRCxVQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNBLFNBQUlsQyxRQUFRaVQsYUFBYS9RLEdBQWIsRUFBa0I0Z0IsWUFBbEIsRUFBZ0N6UyxTQUFoQyxFQUEyQ3JJLEVBQTNDLENBQVo7QUFDQTtBQUNBLFNBQUlyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsV0FBSWxFLG9CQUFvQk8sR0FBcEIsS0FBNEJxRCxPQUFPYyxjQUFQLENBQXNCbkUsR0FBdEIsQ0FBaEMsRUFBNEQ7QUFDMUR1RixjQUNHLE9BQU92RixHQUFQLEdBQWEsa0VBRGhCLEVBRUU4RixFQUZGO0FBSUQ7QUFDRGdILHlCQUFrQndDLEtBQWxCLEVBQXlCdFAsR0FBekIsRUFBOEJsQyxLQUE5QixFQUFxQyxZQUFZO0FBQy9DLGFBQUlnSSxHQUFHWSxPQUFILElBQWMsQ0FBQ3dULHdCQUFuQixFQUE2QztBQUMzQzNVLGdCQUNFLDREQUNBLHdEQURBLEdBRUEsK0RBRkEsR0FHQSwrQkFIQSxHQUdrQ3ZGLEdBSGxDLEdBR3dDLElBSjFDLEVBS0U4RixFQUxGO0FBT0Q7QUFDRixRQVZEO0FBV0QsTUFsQkQsTUFrQk87QUFDTGdILHlCQUFrQndDLEtBQWxCLEVBQXlCdFAsR0FBekIsRUFBOEJsQyxLQUE5QjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsU0FBSSxFQUFFa0MsT0FBTzhGLEVBQVQsQ0FBSixFQUFrQjtBQUNoQmthLGFBQU1sYSxFQUFOLEVBQVUsUUFBVixFQUFvQjlGLEdBQXBCO0FBQ0Q7QUFDRixJQS9CRDs7QUFpQ0EsUUFBSyxJQUFJQSxHQUFULElBQWdCNGdCLFlBQWhCO0FBQThCRSxVQUFNOWdCLEdBQU47QUFBOUIsSUFDQXNNLGNBQWNDLGFBQWQsR0FBOEIsSUFBOUI7QUFDRDs7QUFFRCxVQUFTZ1UsUUFBVCxDQUFtQnphLEVBQW5CLEVBQXVCO0FBQ3JCLE9BQUlwSyxPQUFPb0ssR0FBR00sUUFBSCxDQUFZMUssSUFBdkI7QUFDQUEsVUFBT29LLEdBQUdnVyxLQUFILEdBQVcsT0FBT3BnQixJQUFQLEtBQWdCLFVBQWhCLEdBQ2RxbEIsUUFBUXJsQixJQUFSLEVBQWNvSyxFQUFkLENBRGMsR0FFZHBLLFFBQVEsRUFGWjtBQUdBLE9BQUksQ0FBQ3dDLGNBQWN4QyxJQUFkLENBQUwsRUFBMEI7QUFDeEJBLFlBQU8sRUFBUDtBQUNBK0gsYUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsOENBQ0Esb0VBRnVDLEVBR3ZDTyxFQUh1QyxDQUF6QztBQUtEO0FBQ0Q7QUFDQSxPQUFJOUksT0FBT0QsT0FBT0MsSUFBUCxDQUFZdEIsSUFBWixDQUFYO0FBQ0EsT0FBSTRULFFBQVF4SixHQUFHTSxRQUFILENBQVlrSixLQUF4QjtBQUNBLE9BQUlDLFVBQVV6SixHQUFHTSxRQUFILENBQVltSixPQUExQjtBQUNBLE9BQUlwWixJQUFJNkcsS0FBSzVHLE1BQWI7QUFDQSxVQUFPRCxHQUFQLEVBQVk7QUFDVixTQUFJNkosTUFBTWhELEtBQUs3RyxDQUFMLENBQVY7QUFDQSxTQUFJc04sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFdBQUk0TCxXQUFXeFAsT0FBT3dQLE9BQVAsRUFBZ0J2UCxHQUFoQixDQUFmLEVBQXFDO0FBQ25DdUYsY0FDRyxjQUFjdkYsR0FBZCxHQUFvQixpREFEdkIsRUFFRThGLEVBRkY7QUFJRDtBQUNGO0FBQ0QsU0FBSXdKLFNBQVN2UCxPQUFPdVAsS0FBUCxFQUFjdFAsR0FBZCxDQUFiLEVBQWlDO0FBQy9CeUQsZUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMseUJBQXlCdkYsR0FBekIsR0FBK0Isb0NBQS9CLEdBQ0EsaUNBRnVDLEVBR3ZDOEYsRUFIdUMsQ0FBekM7QUFLRCxNQU5ELE1BTU8sSUFBSSxDQUFDbkIsV0FBVzNFLEdBQVgsQ0FBTCxFQUFzQjtBQUMzQmdnQixhQUFNbGEsRUFBTixFQUFVLE9BQVYsRUFBbUI5RixHQUFuQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBNkosV0FBUW5PLElBQVIsRUFBYyxJQUFkLENBQW1CLGdCQUFuQjtBQUNEOztBQUVELFVBQVNxbEIsT0FBVCxDQUFrQnJsQixJQUFsQixFQUF3Qm9LLEVBQXhCLEVBQTRCO0FBQzFCLE9BQUk7QUFDRixZQUFPcEssS0FBS2pHLElBQUwsQ0FBVXFRLEVBQVYsQ0FBUDtBQUNELElBRkQsQ0FFRSxPQUFPcFEsQ0FBUCxFQUFVO0FBQ1ZzUixpQkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBbUIsUUFBbkI7QUFDQSxZQUFPLEVBQVA7QUFDRDtBQUNGOztBQUVELEtBQUlrYix5QkFBeUIsRUFBRWpDLE1BQU0sSUFBUixFQUE3Qjs7QUFFQSxVQUFTeUIsWUFBVCxDQUF1QjFhLEVBQXZCLEVBQTJCMkosUUFBM0IsRUFBcUM7QUFDbkNoTSxXQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMrYyxnQkFBZ0I1YSxFQUFoQixFQUFvQixVQUFwQixDQUF6QztBQUNBLE9BQUltYixXQUFXbmIsR0FBR29iLGlCQUFILEdBQXVCbmtCLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUF0Qzs7QUFFQSxRQUFLLElBQUlZLEdBQVQsSUFBZ0J5UCxRQUFoQixFQUEwQjtBQUN4QixTQUFJMFIsVUFBVTFSLFNBQVN6UCxHQUFULENBQWQ7QUFDQSxTQUFJd04sU0FBUyxPQUFPMlQsT0FBUCxLQUFtQixVQUFuQixHQUFnQ0EsT0FBaEMsR0FBMENBLFFBQVFsWixHQUEvRDtBQUNBLFNBQUl4RSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM2SixVQUFVLElBQXZELEVBQTZEO0FBQzNEakksWUFDRywrQ0FBK0N2RixHQUEvQyxHQUFxRCxLQUR4RCxFQUVFOEYsRUFGRjtBQUlEO0FBQ0Q7QUFDQW1iLGNBQVNqaEIsR0FBVCxJQUFnQixJQUFJcWMsT0FBSixDQUFZdlcsRUFBWixFQUFnQjBILFVBQVV6WSxJQUExQixFQUFnQ0EsSUFBaEMsRUFBc0Npc0Isc0JBQXRDLENBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQUksRUFBRWhoQixPQUFPOEYsRUFBVCxDQUFKLEVBQWtCO0FBQ2hCc2Isc0JBQWV0YixFQUFmLEVBQW1COUYsR0FBbkIsRUFBd0JtaEIsT0FBeEI7QUFDRCxNQUZELE1BRU8sSUFBSTFkLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRCxXQUFJM0QsT0FBTzhGLEdBQUd1YixLQUFkLEVBQXFCO0FBQ25COWIsY0FBTSw2QkFBNkJ2RixHQUE3QixHQUFtQyxnQ0FBekMsRUFBNEU4RixFQUE1RTtBQUNELFFBRkQsTUFFTyxJQUFJQSxHQUFHTSxRQUFILENBQVlrSixLQUFaLElBQXFCdFAsT0FBTzhGLEdBQUdNLFFBQUgsQ0FBWWtKLEtBQTVDLEVBQW1EO0FBQ3hEL0osY0FBTSw2QkFBNkJ2RixHQUE3QixHQUFtQyxrQ0FBekMsRUFBOEU4RixFQUE5RTtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVNzYixjQUFULENBQXlCclcsTUFBekIsRUFBaUMvSyxHQUFqQyxFQUFzQ21oQixPQUF0QyxFQUErQztBQUM3QyxPQUFJLE9BQU9BLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakNwQiw4QkFBeUI5WCxHQUF6QixHQUErQnFaLHFCQUFxQnRoQixHQUFyQixDQUEvQjtBQUNBK2YsOEJBQXlCM1YsR0FBekIsR0FBK0JyVixJQUEvQjtBQUNELElBSEQsTUFHTztBQUNMZ3JCLDhCQUF5QjlYLEdBQXpCLEdBQStCa1osUUFBUWxaLEdBQVIsR0FDM0JrWixRQUFRaGhCLEtBQVIsS0FBa0IsS0FBbEIsR0FDRW1oQixxQkFBcUJ0aEIsR0FBckIsQ0FERixHQUVFbWhCLFFBQVFsWixHQUhpQixHQUkzQmxULElBSko7QUFLQWdyQiw4QkFBeUIzVixHQUF6QixHQUErQitXLFFBQVEvVyxHQUFSLEdBQzNCK1csUUFBUS9XLEdBRG1CLEdBRTNCclYsSUFGSjtBQUdEO0FBQ0QsT0FBSTBPLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUNBb2MseUJBQXlCM1YsR0FBekIsS0FBaUNyVixJQURyQyxFQUMyQztBQUN6Q2dyQiw4QkFBeUIzVixHQUF6QixHQUErQixZQUFZO0FBQ3pDN0UsWUFDRyx5QkFBeUJ2RixHQUF6QixHQUErQiwwQ0FEbEMsRUFFRSxJQUZGO0FBSUQsTUFMRDtBQU1EO0FBQ0RqRCxVQUFPZ0ksY0FBUCxDQUFzQmdHLE1BQXRCLEVBQThCL0ssR0FBOUIsRUFBbUMrZix3QkFBbkM7QUFDRDs7QUFFRCxVQUFTdUIsb0JBQVQsQ0FBK0J0aEIsR0FBL0IsRUFBb0M7QUFDbEMsVUFBTyxTQUFTdWhCLGNBQVQsR0FBMkI7QUFDaEMsU0FBSXZELFVBQVUsS0FBS2tELGlCQUFMLElBQTBCLEtBQUtBLGlCQUFMLENBQXVCbGhCLEdBQXZCLENBQXhDO0FBQ0EsU0FBSWdlLE9BQUosRUFBYTtBQUNYLFdBQUlBLFFBQVFnQixLQUFaLEVBQW1CO0FBQ2pCaEIsaUJBQVF5QixRQUFSO0FBQ0Q7QUFDRCxXQUFJaFYsSUFBSU0sTUFBUixFQUFnQjtBQUNkaVQsaUJBQVFsVCxNQUFSO0FBQ0Q7QUFDRCxjQUFPa1QsUUFBUWxnQixLQUFmO0FBQ0Q7QUFDRixJQVhEO0FBWUQ7O0FBRUQsVUFBU3dpQixXQUFULENBQXNCeGEsRUFBdEIsRUFBMEJ5SixPQUExQixFQUFtQztBQUNqQzlMLFdBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QytjLGdCQUFnQjVhLEVBQWhCLEVBQW9CLFNBQXBCLENBQXpDO0FBQ0EsT0FBSXdKLFFBQVF4SixHQUFHTSxRQUFILENBQVlrSixLQUF4QjtBQUNBLFFBQUssSUFBSXRQLEdBQVQsSUFBZ0J1UCxPQUFoQixFQUF5QjtBQUN2QnpKLFFBQUc5RixHQUFILElBQVV1UCxRQUFRdlAsR0FBUixLQUFnQixJQUFoQixHQUF1QmpMLElBQXZCLEdBQThCTyxLQUFLaWEsUUFBUXZQLEdBQVIsQ0FBTCxFQUFtQjhGLEVBQW5CLENBQXhDO0FBQ0EsU0FBSXJDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJNEwsUUFBUXZQLEdBQVIsS0FBZ0IsSUFBcEIsRUFBMEI7QUFDeEJ1RixjQUNFLGNBQWN2RixHQUFkLEdBQW9CLHlEQUFwQixHQUNBLDJDQUZGLEVBR0U4RixFQUhGO0FBS0Q7QUFDRCxXQUFJd0osU0FBU3ZQLE9BQU91UCxLQUFQLEVBQWN0UCxHQUFkLENBQWIsRUFBaUM7QUFDL0J1RixjQUNHLGNBQWN2RixHQUFkLEdBQW9CLHdDQUR2QixFQUVFOEYsRUFGRjtBQUlEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVMyYSxTQUFULENBQW9CM2EsRUFBcEIsRUFBd0JnQyxLQUF4QixFQUErQjtBQUM3QnJFLFdBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QytjLGdCQUFnQjVhLEVBQWhCLEVBQW9CLE9BQXBCLENBQXpDO0FBQ0EsUUFBSyxJQUFJOUYsR0FBVCxJQUFnQjhILEtBQWhCLEVBQXVCO0FBQ3JCLFNBQUkwWixVQUFVMVosTUFBTTlILEdBQU4sQ0FBZDtBQUNBLFNBQUl1QixNQUFNbUIsT0FBTixDQUFjOGUsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFlBQUssSUFBSXJyQixJQUFJLENBQWIsRUFBZ0JBLElBQUlxckIsUUFBUXByQixNQUE1QixFQUFvQ0QsR0FBcEMsRUFBeUM7QUFDdkNzckIsdUJBQWMzYixFQUFkLEVBQWtCOUYsR0FBbEIsRUFBdUJ3aEIsUUFBUXJyQixDQUFSLENBQXZCO0FBQ0Q7QUFDRixNQUpELE1BSU87QUFDTHNyQixxQkFBYzNiLEVBQWQsRUFBa0I5RixHQUFsQixFQUF1QndoQixPQUF2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxVQUFTQyxhQUFULENBQ0UzYixFQURGLEVBRUU0YixPQUZGLEVBR0VGLE9BSEYsRUFJRXRiLE9BSkYsRUFLRTtBQUNBLE9BQUloSSxjQUFjc2pCLE9BQWQsQ0FBSixFQUE0QjtBQUMxQnRiLGVBQVVzYixPQUFWO0FBQ0FBLGVBQVVBLFFBQVFBLE9BQWxCO0FBQ0Q7QUFDRCxPQUFJLE9BQU9BLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0JBLGVBQVUxYixHQUFHMGIsT0FBSCxDQUFWO0FBQ0Q7QUFDRCxVQUFPMWIsR0FBRzZiLE1BQUgsQ0FBVUQsT0FBVixFQUFtQkYsT0FBbkIsRUFBNEJ0YixPQUE1QixDQUFQO0FBQ0Q7O0FBRUQsVUFBUzBiLFVBQVQsQ0FBcUJ4SSxHQUFyQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFJeUksVUFBVSxFQUFkO0FBQ0FBLFdBQVE1WixHQUFSLEdBQWMsWUFBWTtBQUFFLFlBQU8sS0FBSzZULEtBQVo7QUFBbUIsSUFBL0M7QUFDQSxPQUFJZ0csV0FBVyxFQUFmO0FBQ0FBLFlBQVM3WixHQUFULEdBQWUsWUFBWTtBQUFFLFlBQU8sS0FBS3dKLE1BQVo7QUFBb0IsSUFBakQ7QUFDQSxPQUFJaE8sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDa2UsYUFBUXpYLEdBQVIsR0FBYyxVQUFVMlgsT0FBVixFQUFtQjtBQUMvQnhjLFlBQ0UsMENBQ0EscUNBRkYsRUFHRSxJQUhGO0FBS0QsTUFORDtBQU9BdWMsY0FBUzFYLEdBQVQsR0FBZSxZQUFZO0FBQ3pCN0UsWUFBSyxxQkFBTCxFQUE0QixJQUE1QjtBQUNELE1BRkQ7QUFHRDtBQUNEeEksVUFBT2dJLGNBQVAsQ0FBc0JxVSxJQUFJNWpCLFNBQTFCLEVBQXFDLE9BQXJDLEVBQThDcXNCLE9BQTlDO0FBQ0E5a0IsVUFBT2dJLGNBQVAsQ0FBc0JxVSxJQUFJNWpCLFNBQTFCLEVBQXFDLFFBQXJDLEVBQStDc3NCLFFBQS9DOztBQUVBMUksT0FBSTVqQixTQUFKLENBQWN3c0IsSUFBZCxHQUFxQjVYLEdBQXJCO0FBQ0FnUCxPQUFJNWpCLFNBQUosQ0FBY3lzQixPQUFkLEdBQXdCalUsR0FBeEI7O0FBRUFvTCxPQUFJNWpCLFNBQUosQ0FBY21zQixNQUFkLEdBQXVCLFVBQ3JCOUMsT0FEcUIsRUFFckI3VSxFQUZxQixFQUdyQjlELE9BSHFCLEVBSXJCO0FBQ0EsU0FBSUosS0FBSyxJQUFUO0FBQ0EsU0FBSTVILGNBQWM4TCxFQUFkLENBQUosRUFBdUI7QUFDckIsY0FBT3lYLGNBQWMzYixFQUFkLEVBQWtCK1ksT0FBbEIsRUFBMkI3VSxFQUEzQixFQUErQjlELE9BQS9CLENBQVA7QUFDRDtBQUNEQSxlQUFVQSxXQUFXLEVBQXJCO0FBQ0FBLGFBQVFpWSxJQUFSLEdBQWUsSUFBZjtBQUNBLFNBQUlILFVBQVUsSUFBSTNCLE9BQUosQ0FBWXZXLEVBQVosRUFBZ0IrWSxPQUFoQixFQUF5QjdVLEVBQXpCLEVBQTZCOUQsT0FBN0IsQ0FBZDtBQUNBLFNBQUlBLFFBQVFnYyxTQUFaLEVBQXVCO0FBQ3JCbFksVUFBR3ZVLElBQUgsQ0FBUXFRLEVBQVIsRUFBWWtZLFFBQVFsZ0IsS0FBcEI7QUFDRDtBQUNELFlBQU8sU0FBU3FrQixTQUFULEdBQXNCO0FBQzNCbkUsZUFBUXBDLFFBQVI7QUFDRCxNQUZEO0FBR0QsSUFsQkQ7QUFtQkQ7O0FBRUQ7O0FBRUEsVUFBU3dHLFdBQVQsQ0FBc0J0YyxFQUF0QixFQUEwQjtBQUN4QixPQUFJNEosVUFBVTVKLEdBQUdNLFFBQUgsQ0FBWXNKLE9BQTFCO0FBQ0EsT0FBSUEsT0FBSixFQUFhO0FBQ1g1SixRQUFHdWMsU0FBSCxHQUFlLE9BQU8zUyxPQUFQLEtBQW1CLFVBQW5CLEdBQ1hBLFFBQVFqYSxJQUFSLENBQWFxUSxFQUFiLENBRFcsR0FFWDRKLE9BRko7QUFHRDtBQUNGOztBQUVELFVBQVM0UyxjQUFULENBQXlCeGMsRUFBekIsRUFBNkI7QUFDM0IsT0FBSWdHLFNBQVN5VyxjQUFjemMsR0FBR00sUUFBSCxDQUFZb0osTUFBMUIsRUFBa0MxSixFQUFsQyxDQUFiO0FBQ0EsT0FBSWdHLE1BQUosRUFBWTtBQUNWUSxtQkFBY0MsYUFBZCxHQUE4QixLQUE5QjtBQUNBeFAsWUFBT0MsSUFBUCxDQUFZOE8sTUFBWixFQUFvQjdPLE9BQXBCLENBQTRCLFVBQVUrQyxHQUFWLEVBQWU7QUFDekM7QUFDQSxXQUFJeUQsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbUosMkJBQWtCaEgsRUFBbEIsRUFBc0I5RixHQUF0QixFQUEyQjhMLE9BQU85TCxHQUFQLENBQTNCLEVBQXdDLFlBQVk7QUFDbER1RixnQkFDRSx5RUFDQSwwREFEQSxHQUVBLDZCQUZBLEdBRWdDdkYsR0FGaEMsR0FFc0MsSUFIeEMsRUFJRThGLEVBSkY7QUFNRCxVQVBEO0FBUUQsUUFURCxNQVNPO0FBQ0xnSCwyQkFBa0JoSCxFQUFsQixFQUFzQjlGLEdBQXRCLEVBQTJCOEwsT0FBTzlMLEdBQVAsQ0FBM0I7QUFDRDtBQUNGLE1BZEQ7QUFlQXNNLG1CQUFjQyxhQUFkLEdBQThCLElBQTlCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTZ1csYUFBVCxDQUF3Qi9TLE1BQXhCLEVBQWdDMUosRUFBaEMsRUFBb0M7QUFDbEMsT0FBSTBKLE1BQUosRUFBWTtBQUNWO0FBQ0EsU0FBSTFELFNBQVMvTyxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNBLFNBQUlwQyxPQUFPMEwsWUFDTEUsUUFBUUMsT0FBUixDQUFnQjJHLE1BQWhCLENBREssR0FFTHpTLE9BQU9DLElBQVAsQ0FBWXdTLE1BQVosQ0FGTjs7QUFJQSxVQUFLLElBQUlyWixJQUFJLENBQWIsRUFBZ0JBLElBQUk2RyxLQUFLNUcsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDLFdBQUk2SixNQUFNaEQsS0FBSzdHLENBQUwsQ0FBVjtBQUNBLFdBQUlxc0IsYUFBYWhULE9BQU94UCxHQUFQLENBQWpCO0FBQ0EsV0FBSXlpQixTQUFTM2MsRUFBYjtBQUNBLGNBQU8yYyxNQUFQLEVBQWU7QUFDYixhQUFJQSxPQUFPSixTQUFQLElBQW9CRyxjQUFjQyxPQUFPSixTQUE3QyxFQUF3RDtBQUN0RHZXLGtCQUFPOUwsR0FBUCxJQUFjeWlCLE9BQU9KLFNBQVAsQ0FBaUJHLFVBQWpCLENBQWQ7QUFDQTtBQUNEO0FBQ0RDLGtCQUFTQSxPQUFPL2IsT0FBaEI7QUFDRDtBQUNELFdBQUlqRCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQzhlLE1BQTlDLEVBQXNEO0FBQ3BEbGQsY0FBTSxpQkFBaUJ2RixHQUFqQixHQUF1QixjQUE3QixFQUE4QzhGLEVBQTlDO0FBQ0Q7QUFDRjtBQUNELFlBQU9nRyxNQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxVQUFTNFcseUJBQVQsQ0FDRWphLElBREYsRUFFRTBGLFNBRkYsRUFHRXpTLElBSEYsRUFJRWtZLE9BSkYsRUFLRUgsUUFMRixFQU1FO0FBQ0EsT0FBSW5FLFFBQVEsRUFBWjtBQUNBLE9BQUkwQixjQUFjdkksS0FBS3ZDLE9BQUwsQ0FBYW9KLEtBQS9CO0FBQ0EsT0FBSTVSLE1BQU1zVCxXQUFOLENBQUosRUFBd0I7QUFDdEIsVUFBSyxJQUFJaFIsR0FBVCxJQUFnQmdSLFdBQWhCLEVBQTZCO0FBQzNCMUIsYUFBTXRQLEdBQU4sSUFBYStRLGFBQWEvUSxHQUFiLEVBQWtCZ1IsV0FBbEIsRUFBK0I3QyxhQUFhLEVBQTVDLENBQWI7QUFDRDtBQUNGLElBSkQsTUFJTztBQUNMLFNBQUl6USxNQUFNaEMsS0FBSzhhLEtBQVgsQ0FBSixFQUF1QjtBQUFFbU0sa0JBQVdyVCxLQUFYLEVBQWtCNVQsS0FBSzhhLEtBQXZCO0FBQWdDO0FBQ3pELFNBQUk5WSxNQUFNaEMsS0FBSzRULEtBQVgsQ0FBSixFQUF1QjtBQUFFcVQsa0JBQVdyVCxLQUFYLEVBQWtCNVQsS0FBSzRULEtBQXZCO0FBQWdDO0FBQzFEO0FBQ0Q7QUFDQTtBQUNBLE9BQUlzVCxXQUFXN2xCLE9BQU9xQyxNQUFQLENBQWN3VSxPQUFkLENBQWY7QUFDQSxPQUFJaVAsSUFBSSxTQUFKQSxDQUFJLENBQVU1aEIsQ0FBVixFQUFhVyxDQUFiLEVBQWdCbEIsQ0FBaEIsRUFBbUJyRSxDQUFuQixFQUFzQjtBQUFFLFlBQU95bUIsY0FBY0YsUUFBZCxFQUF3QjNoQixDQUF4QixFQUEyQlcsQ0FBM0IsRUFBOEJsQixDQUE5QixFQUFpQ3JFLENBQWpDLEVBQW9DLElBQXBDLENBQVA7QUFBbUQsSUFBbkY7QUFDQSxPQUFJMlksUUFBUXZNLEtBQUt2QyxPQUFMLENBQWFtTixNQUFiLENBQW9CNWQsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0JvdEIsQ0FBL0IsRUFBa0M7QUFDNUNubkIsV0FBTUEsSUFEc0M7QUFFNUM0VCxZQUFPQSxLQUZxQztBQUc1Q21FLGVBQVVBLFFBSGtDO0FBSTVDckYsYUFBUXdGLE9BSm9DO0FBSzVDK0UsZ0JBQVdqZCxLQUFLbWEsRUFBTCxJQUFXLEVBTHNCO0FBTTVDa04saUJBQVlSLGNBQWM5WixLQUFLdkMsT0FBTCxDQUFhc0osTUFBM0IsRUFBbUNvRSxPQUFuQyxDQU5nQztBQU81Q2dHLFlBQU8saUJBQVk7QUFBRSxjQUFPRCxhQUFhbEcsUUFBYixFQUF1QkcsT0FBdkIsQ0FBUDtBQUF5QztBQVBsQixJQUFsQyxDQUFaO0FBU0EsT0FBSW9CLGlCQUFpQnhCLEtBQXJCLEVBQTRCO0FBQzFCd0IsV0FBTWhCLGlCQUFOLEdBQTBCSixPQUExQjtBQUNBb0IsV0FBTWdPLGlCQUFOLEdBQTBCdmEsS0FBS3ZDLE9BQS9CO0FBQ0EsU0FBSXhLLEtBQUtvZSxJQUFULEVBQWU7QUFDYixRQUFDOUUsTUFBTXRaLElBQU4sS0FBZXNaLE1BQU10WixJQUFOLEdBQWEsRUFBNUIsQ0FBRCxFQUFrQ29lLElBQWxDLEdBQXlDcGUsS0FBS29lLElBQTlDO0FBQ0Q7QUFDRjtBQUNELFVBQU85RSxLQUFQO0FBQ0Q7O0FBRUQsVUFBUzJOLFVBQVQsQ0FBcUJsaEIsRUFBckIsRUFBeUIrTSxJQUF6QixFQUErQjtBQUM3QixRQUFLLElBQUl4TyxHQUFULElBQWdCd08sSUFBaEIsRUFBc0I7QUFDcEIvTSxRQUFHbEIsU0FBU1AsR0FBVCxDQUFILElBQW9Cd08sS0FBS3hPLEdBQUwsQ0FBcEI7QUFDRDtBQUNGOztBQUVEOztBQUVBO0FBQ0EsS0FBSWlqQixzQkFBc0I7QUFDeEJDLFNBQU0sU0FBU0EsSUFBVCxDQUNKbE8sS0FESSxFQUVKK0YsU0FGSSxFQUdKb0ksU0FISSxFQUlKQyxNQUpJLEVBS0o7QUFDQSxTQUFJLENBQUNwTyxNQUFNZixpQkFBUCxJQUE0QmUsTUFBTWYsaUJBQU4sQ0FBd0IwRyxZQUF4RCxFQUFzRTtBQUNwRSxXQUFJdE0sUUFBUTJHLE1BQU1mLGlCQUFOLEdBQTBCb1AsZ0NBQ3BDck8sS0FEb0MsRUFFcENpRixjQUZvQyxFQUdwQ2tKLFNBSG9DLEVBSXBDQyxNQUpvQyxDQUF0QztBQU1BL1UsYUFBTWlWLE1BQU4sQ0FBYXZJLFlBQVkvRixNQUFNckIsR0FBbEIsR0FBd0I1ZCxTQUFyQyxFQUFnRGdsQixTQUFoRDtBQUNELE1BUkQsTUFRTyxJQUFJL0YsTUFBTXRaLElBQU4sQ0FBVzZuQixTQUFmLEVBQTBCO0FBQy9CO0FBQ0EsV0FBSUMsY0FBY3hPLEtBQWxCLENBRitCLENBRU47QUFDekJpTywyQkFBb0JRLFFBQXBCLENBQTZCRCxXQUE3QixFQUEwQ0EsV0FBMUM7QUFDRDtBQUNGLElBcEJ1Qjs7QUFzQnhCQyxhQUFVLFNBQVNBLFFBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCMU8sS0FBN0IsRUFBb0M7QUFDNUMsU0FBSTlPLFVBQVU4TyxNQUFNbkIsZ0JBQXBCO0FBQ0EsU0FBSXhGLFFBQVEyRyxNQUFNZixpQkFBTixHQUEwQnlQLFNBQVN6UCxpQkFBL0M7QUFDQXFJLDBCQUNFak8sS0FERixFQUVFbkksUUFBUWlJLFNBRlYsRUFFcUI7QUFDbkJqSSxhQUFReVMsU0FIVixFQUdxQjtBQUNuQjNELFVBSkYsRUFJUztBQUNQOU8sYUFBUXVOLFFBTFYsQ0FLbUI7QUFMbkI7QUFPRCxJQWhDdUI7O0FBa0N4QmtRLFdBQVEsU0FBU0EsTUFBVCxDQUFpQjNPLEtBQWpCLEVBQXdCO0FBQzlCLFNBQUlwQixVQUFVb0IsTUFBTXBCLE9BQXBCO0FBQ0EsU0FBSUssb0JBQW9CZSxNQUFNZixpQkFBOUI7QUFDQSxTQUFJLENBQUNBLGtCQUFrQnlHLFVBQXZCLEVBQW1DO0FBQ2pDekcseUJBQWtCeUcsVUFBbEIsR0FBK0IsSUFBL0I7QUFDQU0sZ0JBQVMvRyxpQkFBVCxFQUE0QixTQUE1QjtBQUNEO0FBQ0QsU0FBSWUsTUFBTXRaLElBQU4sQ0FBVzZuQixTQUFmLEVBQTBCO0FBQ3hCLFdBQUkzUCxRQUFROEcsVUFBWixFQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FnRSxpQ0FBd0J6SyxpQkFBeEI7QUFDRCxRQVBELE1BT087QUFDTG1KLGdDQUF1Qm5KLGlCQUF2QixFQUEwQyxJQUExQyxDQUErQyxZQUEvQztBQUNEO0FBQ0Y7QUFDRixJQXJEdUI7O0FBdUR4QjJQLFlBQVMsU0FBU0EsT0FBVCxDQUFrQjVPLEtBQWxCLEVBQXlCO0FBQ2hDLFNBQUlmLG9CQUFvQmUsTUFBTWYsaUJBQTlCO0FBQ0EsU0FBSSxDQUFDQSxrQkFBa0IwRyxZQUF2QixFQUFxQztBQUNuQyxXQUFJLENBQUMzRixNQUFNdFosSUFBTixDQUFXNm5CLFNBQWhCLEVBQTJCO0FBQ3pCdFAsMkJBQWtCMEgsUUFBbEI7QUFDRCxRQUZELE1BRU87QUFDTDJCLGtDQUF5QnJKLGlCQUF6QixFQUE0QyxJQUE1QyxDQUFpRCxZQUFqRDtBQUNEO0FBQ0Y7QUFDRjtBQWhFdUIsRUFBMUI7O0FBbUVBLEtBQUk0UCxlQUFlOW1CLE9BQU9DLElBQVAsQ0FBWWltQixtQkFBWixDQUFuQjs7QUFFQSxVQUFTYSxlQUFULENBQ0VyYixJQURGLEVBRUUvTSxJQUZGLEVBR0VrWSxPQUhGLEVBSUVILFFBSkYsRUFLRWpCLEdBTEYsRUFNRTtBQUNBLE9BQUloVixRQUFRaUwsSUFBUixDQUFKLEVBQW1CO0FBQ2pCO0FBQ0Q7O0FBRUQsT0FBSWlQLFdBQVc5RCxRQUFReE4sUUFBUixDQUFpQjJkLEtBQWhDOztBQUVBO0FBQ0EsT0FBSWhtQixTQUFTMEssSUFBVCxDQUFKLEVBQW9CO0FBQ2xCQSxZQUFPaVAsU0FBU2xXLE1BQVQsQ0FBZ0JpSCxJQUFoQixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQUksT0FBT0EsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QixTQUFJaEYsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNEIsWUFBTSxtQ0FBb0MxRyxPQUFPNEosSUFBUCxDQUExQyxFQUEwRG1MLE9BQTFEO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBSUUsWUFBSjtBQUNBLE9BQUl0VyxRQUFRaUwsS0FBS3ViLEdBQWIsQ0FBSixFQUF1QjtBQUNyQmxRLG9CQUFlckwsSUFBZjtBQUNBQSxZQUFPZ1Asc0JBQXNCM0QsWUFBdEIsRUFBb0M0RCxRQUFwQyxFQUE4QzlELE9BQTlDLENBQVA7QUFDQSxTQUFJbkwsU0FBUzFTLFNBQWIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBT3loQix1QkFDTDFELFlBREssRUFFTHBZLElBRkssRUFHTGtZLE9BSEssRUFJTEgsUUFKSyxFQUtMakIsR0FMSyxDQUFQO0FBT0Q7QUFDRjs7QUFFRDlXLFVBQU9BLFFBQVEsRUFBZjs7QUFFQTtBQUNBO0FBQ0F1b0IsNkJBQTBCeGIsSUFBMUI7O0FBRUE7QUFDQSxPQUFJL0ssTUFBTWhDLEtBQUt3b0IsS0FBWCxDQUFKLEVBQXVCO0FBQ3JCQyxvQkFBZTFiLEtBQUt2QyxPQUFwQixFQUE2QnhLLElBQTdCO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFJeVMsWUFBWW9JLDBCQUEwQjdhLElBQTFCLEVBQWdDK00sSUFBaEMsRUFBc0MrSixHQUF0QyxDQUFoQjs7QUFFQTtBQUNBLE9BQUk3VSxPQUFPOEssS0FBS3ZDLE9BQUwsQ0FBYWtlLFVBQXBCLENBQUosRUFBcUM7QUFDbkMsWUFBTzFCLDBCQUEwQmphLElBQTFCLEVBQWdDMEYsU0FBaEMsRUFBMkN6UyxJQUEzQyxFQUFpRGtZLE9BQWpELEVBQTBESCxRQUExRCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQUlrRixZQUFZamQsS0FBS21hLEVBQXJCO0FBQ0E7QUFDQTtBQUNBbmEsUUFBS21hLEVBQUwsR0FBVW5hLEtBQUsyb0IsUUFBZjs7QUFFQSxPQUFJMW1CLE9BQU84SyxLQUFLdkMsT0FBTCxDQUFha1UsUUFBcEIsQ0FBSixFQUFtQztBQUNqQztBQUNBOztBQUVBO0FBQ0EsU0FBSU4sT0FBT3BlLEtBQUtvZSxJQUFoQjtBQUNBcGUsWUFBTyxFQUFQO0FBQ0EsU0FBSW9lLElBQUosRUFBVTtBQUNScGUsWUFBS29lLElBQUwsR0FBWUEsSUFBWjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQXdLLGNBQVc1b0IsSUFBWDs7QUFFQTtBQUNBLE9BQUloRixPQUFPK1IsS0FBS3ZDLE9BQUwsQ0FBYXhQLElBQWIsSUFBcUI4YixHQUFoQztBQUNBLE9BQUl3QyxRQUFRLElBQUl4QixLQUFKLENBQ1QsbUJBQW9CL0ssS0FBS3ViLEdBQXpCLElBQWlDdHRCLE9BQVEsTUFBTUEsSUFBZCxHQUFzQixFQUF2RCxDQURTLEVBRVZnRixJQUZVLEVBRUozRixTQUZJLEVBRU9BLFNBRlAsRUFFa0JBLFNBRmxCLEVBRTZCNmQsT0FGN0IsRUFHVixFQUFFbkwsTUFBTUEsSUFBUixFQUFjMEYsV0FBV0EsU0FBekIsRUFBb0N3SyxXQUFXQSxTQUEvQyxFQUEwRG5HLEtBQUtBLEdBQS9ELEVBQW9FaUIsVUFBVUEsUUFBOUUsRUFIVSxFQUlWSyxZQUpVLENBQVo7QUFNQSxVQUFPa0IsS0FBUDtBQUNEOztBQUVELFVBQVNxTywrQkFBVCxDQUNFck8sS0FERixFQUNTO0FBQ1A1RyxPQUZGLEVBRVU7QUFDUitVLFVBSEYsRUFJRUMsTUFKRixFQUtFO0FBQ0EsT0FBSW1CLHdCQUF3QnZQLE1BQU1uQixnQkFBbEM7QUFDQSxPQUFJM04sVUFBVTtBQUNac2UsbUJBQWMsSUFERjtBQUVacFcsYUFBUUEsTUFGSTtBQUdaRCxnQkFBV29XLHNCQUFzQnBXLFNBSHJCO0FBSVo5SCxvQkFBZWtlLHNCQUFzQi9SLEdBSnpCO0FBS1pxSyxtQkFBYzdILEtBTEY7QUFNWjRELHVCQUFrQjJMLHNCQUFzQjVMLFNBTjVCO0FBT1orRCxzQkFBaUI2SCxzQkFBc0I5USxRQVAzQjtBQVFaOEgsaUJBQVk0SCxhQUFhLElBUmI7QUFTWjNILGNBQVM0SCxVQUFVO0FBVFAsSUFBZDtBQVdBO0FBQ0EsT0FBSXFCLGlCQUFpQnpQLE1BQU10WixJQUFOLENBQVcrb0IsY0FBaEM7QUFDQSxPQUFJL21CLE1BQU0rbUIsY0FBTixDQUFKLEVBQTJCO0FBQ3pCdmUsYUFBUW1OLE1BQVIsR0FBaUJvUixlQUFlcFIsTUFBaEM7QUFDQW5OLGFBQVF3ZSxlQUFSLEdBQTBCRCxlQUFlQyxlQUF6QztBQUNEO0FBQ0QsVUFBTyxJQUFJSCxzQkFBc0I5YixJQUExQixDQUErQnZDLE9BQS9CLENBQVA7QUFDRDs7QUFFRCxVQUFTb2UsVUFBVCxDQUFxQjVvQixJQUFyQixFQUEyQjtBQUN6QixPQUFJLENBQUNBLEtBQUt5VCxJQUFWLEVBQWdCO0FBQ2R6VCxVQUFLeVQsSUFBTCxHQUFZLEVBQVo7QUFDRDtBQUNELFFBQUssSUFBSWhaLElBQUksQ0FBYixFQUFnQkEsSUFBSTB0QixhQUFhenRCLE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1QyxTQUFJNkosTUFBTTZqQixhQUFhMXRCLENBQWIsQ0FBVjtBQUNBLFNBQUl3dUIsYUFBYWpwQixLQUFLeVQsSUFBTCxDQUFVblAsR0FBVixDQUFqQjtBQUNBLFNBQUk0a0IsT0FBTzNCLG9CQUFvQmpqQixHQUFwQixDQUFYO0FBQ0F0RSxVQUFLeVQsSUFBTCxDQUFVblAsR0FBVixJQUFpQjJrQixhQUFhRSxZQUFZRCxJQUFaLEVBQWtCRCxVQUFsQixDQUFiLEdBQTZDQyxJQUE5RDtBQUNEO0FBQ0Y7O0FBRUQsVUFBU0MsV0FBVCxDQUFzQkMsR0FBdEIsRUFBMkJDLEdBQTNCLEVBQWdDO0FBQzlCLFVBQU8sVUFBVTlqQixDQUFWLEVBQWFXLENBQWIsRUFBZ0JsQixDQUFoQixFQUFtQnJFLENBQW5CLEVBQXNCO0FBQzNCeW9CLFNBQUk3akIsQ0FBSixFQUFPVyxDQUFQLEVBQVVsQixDQUFWLEVBQWFyRSxDQUFiO0FBQ0Ewb0IsU0FBSTlqQixDQUFKLEVBQU9XLENBQVAsRUFBVWxCLENBQVYsRUFBYXJFLENBQWI7QUFDRCxJQUhEO0FBSUQ7O0FBRUQ7QUFDQTtBQUNBLFVBQVM4bkIsY0FBVCxDQUF5QmplLE9BQXpCLEVBQWtDeEssSUFBbEMsRUFBd0M7QUFDdEMsT0FBSXVWLE9BQVEvSyxRQUFRZ2UsS0FBUixJQUFpQmhlLFFBQVFnZSxLQUFSLENBQWNqVCxJQUFoQyxJQUF5QyxPQUFwRDtBQUNBLE9BQUk5VSxRQUFTK0osUUFBUWdlLEtBQVIsSUFBaUJoZSxRQUFRZ2UsS0FBUixDQUFjL25CLEtBQWhDLElBQTBDLE9BQXRELENBQThELENBQUNULEtBQUs0VCxLQUFMLEtBQWU1VCxLQUFLNFQsS0FBTCxHQUFhLEVBQTVCLENBQUQsRUFBa0MyQixJQUFsQyxJQUEwQ3ZWLEtBQUt3b0IsS0FBTCxDQUFXcG1CLEtBQXJEO0FBQzlELE9BQUkrWCxLQUFLbmEsS0FBS21hLEVBQUwsS0FBWW5hLEtBQUttYSxFQUFMLEdBQVUsRUFBdEIsQ0FBVDtBQUNBLE9BQUluWSxNQUFNbVksR0FBRzFaLEtBQUgsQ0FBTixDQUFKLEVBQXNCO0FBQ3BCMFosUUFBRzFaLEtBQUgsSUFBWSxDQUFDVCxLQUFLd29CLEtBQUwsQ0FBV2MsUUFBWixFQUFzQjdpQixNQUF0QixDQUE2QjBULEdBQUcxWixLQUFILENBQTdCLENBQVo7QUFDRCxJQUZELE1BRU87QUFDTDBaLFFBQUcxWixLQUFILElBQVlULEtBQUt3b0IsS0FBTCxDQUFXYyxRQUF2QjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSUMsbUJBQW1CLENBQXZCO0FBQ0EsS0FBSUMsbUJBQW1CLENBQXZCOztBQUVBO0FBQ0E7QUFDQSxVQUFTcEMsYUFBVCxDQUNFbFAsT0FERixFQUVFcEIsR0FGRixFQUdFOVcsSUFIRixFQUlFK1gsUUFKRixFQUtFMFIsaUJBTEYsRUFNRUMsZUFORixFQU9FO0FBQ0EsT0FBSTdqQixNQUFNbUIsT0FBTixDQUFjaEgsSUFBZCxLQUF1Qm1DLFlBQVluQyxJQUFaLENBQTNCLEVBQThDO0FBQzVDeXBCLHlCQUFvQjFSLFFBQXBCO0FBQ0FBLGdCQUFXL1gsSUFBWDtBQUNBQSxZQUFPM0YsU0FBUDtBQUNEO0FBQ0QsT0FBSTRILE9BQU95bkIsZUFBUCxDQUFKLEVBQTZCO0FBQzNCRCx5QkFBb0JELGdCQUFwQjtBQUNEO0FBQ0QsVUFBT0csZUFBZXpSLE9BQWYsRUFBd0JwQixHQUF4QixFQUE2QjlXLElBQTdCLEVBQW1DK1gsUUFBbkMsRUFBNkMwUixpQkFBN0MsQ0FBUDtBQUNEOztBQUVELFVBQVNFLGNBQVQsQ0FDRXpSLE9BREYsRUFFRXBCLEdBRkYsRUFHRTlXLElBSEYsRUFJRStYLFFBSkYsRUFLRTBSLGlCQUxGLEVBTUU7QUFDQSxPQUFJem5CLE1BQU1oQyxJQUFOLEtBQWVnQyxNQUFPaEMsSUFBRCxDQUFPc1EsTUFBYixDQUFuQixFQUF5QztBQUN2Q3ZJLGFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLHFEQUFzRDVHLEtBQUtDLFNBQUwsQ0FBZWxELElBQWYsQ0FBdEQsR0FBOEUsSUFBOUUsR0FDQSx3REFGdUMsRUFHdkNrWSxPQUh1QyxDQUF6QztBQUtBLFlBQU9nQixrQkFBUDtBQUNEO0FBQ0Q7QUFDQSxPQUFJbFgsTUFBTWhDLElBQU4sS0FBZWdDLE1BQU1oQyxLQUFLNHBCLEVBQVgsQ0FBbkIsRUFBbUM7QUFDakM5UyxXQUFNOVcsS0FBSzRwQixFQUFYO0FBQ0Q7QUFDRCxPQUFJLENBQUM5UyxHQUFMLEVBQVU7QUFDUjtBQUNBLFlBQU9vQyxrQkFBUDtBQUNEO0FBQ0Q7QUFDQSxPQUFJblIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0ZqRyxNQUFNaEMsSUFBTixDQURFLElBQ2FnQyxNQUFNaEMsS0FBS3NFLEdBQVgsQ0FEYixJQUNnQyxDQUFDbkMsWUFBWW5DLEtBQUtzRSxHQUFqQixDQURyQyxFQUVFO0FBQ0F1RixVQUNFLDZDQUNBLGtDQUZGLEVBR0VxTyxPQUhGO0FBS0Q7QUFDRDtBQUNBLE9BQUlyUyxNQUFNbUIsT0FBTixDQUFjK1EsUUFBZCxLQUNGLE9BQU9BLFNBQVMsQ0FBVCxDQUFQLEtBQXVCLFVBRHpCLEVBRUU7QUFDQS9YLFlBQU9BLFFBQVEsRUFBZjtBQUNBQSxVQUFLaWhCLFdBQUwsR0FBbUIsRUFBRW5MLFNBQVNpQyxTQUFTLENBQVQsQ0FBWCxFQUFuQjtBQUNBQSxjQUFTcmQsTUFBVCxHQUFrQixDQUFsQjtBQUNEO0FBQ0QsT0FBSSt1QixzQkFBc0JELGdCQUExQixFQUE0QztBQUMxQ3pSLGdCQUFXc0Qsa0JBQWtCdEQsUUFBbEIsQ0FBWDtBQUNELElBRkQsTUFFTyxJQUFJMFIsc0JBQXNCRixnQkFBMUIsRUFBNEM7QUFDakR4UixnQkFBV3FELHdCQUF3QnJELFFBQXhCLENBQVg7QUFDRDtBQUNELE9BQUl1QixLQUFKLEVBQVdqQixFQUFYO0FBQ0EsT0FBSSxPQUFPdkIsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFNBQUkvSixJQUFKO0FBQ0FzTCxVQUFLMVEsT0FBT2dCLGVBQVAsQ0FBdUJtTyxHQUF2QixDQUFMO0FBQ0EsU0FBSW5QLE9BQU9hLGFBQVAsQ0FBcUJzTyxHQUFyQixDQUFKLEVBQStCO0FBQzdCO0FBQ0F3QyxlQUFRLElBQUl4QixLQUFKLENBQ05uUSxPQUFPaUIsb0JBQVAsQ0FBNEJrTyxHQUE1QixDQURNLEVBQzRCOVcsSUFENUIsRUFDa0MrWCxRQURsQyxFQUVOMWQsU0FGTSxFQUVLQSxTQUZMLEVBRWdCNmQsT0FGaEIsQ0FBUjtBQUlELE1BTkQsTUFNTyxJQUFJbFcsTUFBTStLLE9BQU9pSSxhQUFha0QsUUFBUXhOLFFBQXJCLEVBQStCLFlBQS9CLEVBQTZDb00sR0FBN0MsQ0FBYixDQUFKLEVBQXFFO0FBQzFFO0FBQ0F3QyxlQUFROE8sZ0JBQWdCcmIsSUFBaEIsRUFBc0IvTSxJQUF0QixFQUE0QmtZLE9BQTVCLEVBQXFDSCxRQUFyQyxFQUErQ2pCLEdBQS9DLENBQVI7QUFDRCxNQUhNLE1BR0E7QUFDTDtBQUNBO0FBQ0E7QUFDQXdDLGVBQVEsSUFBSXhCLEtBQUosQ0FDTmhCLEdBRE0sRUFDRDlXLElBREMsRUFDSytYLFFBREwsRUFFTjFkLFNBRk0sRUFFS0EsU0FGTCxFQUVnQjZkLE9BRmhCLENBQVI7QUFJRDtBQUNGLElBckJELE1BcUJPO0FBQ0w7QUFDQW9CLGFBQVE4TyxnQkFBZ0J0UixHQUFoQixFQUFxQjlXLElBQXJCLEVBQTJCa1ksT0FBM0IsRUFBb0NILFFBQXBDLENBQVI7QUFDRDtBQUNELE9BQUkvVixNQUFNc1gsS0FBTixDQUFKLEVBQWtCO0FBQ2hCLFNBQUlqQixFQUFKLEVBQVE7QUFBRXdSLGVBQVF2USxLQUFSLEVBQWVqQixFQUFmO0FBQXFCO0FBQy9CLFlBQU9pQixLQUFQO0FBQ0QsSUFIRCxNQUdPO0FBQ0wsWUFBT0osa0JBQVA7QUFDRDtBQUNGOztBQUVELFVBQVMyUSxPQUFULENBQWtCdlEsS0FBbEIsRUFBeUJqQixFQUF6QixFQUE2QjtBQUMzQmlCLFNBQU1qQixFQUFOLEdBQVdBLEVBQVg7QUFDQSxPQUFJaUIsTUFBTXhDLEdBQU4sS0FBYyxlQUFsQixFQUFtQztBQUNqQztBQUNBO0FBQ0Q7QUFDRCxPQUFJOVUsTUFBTXNYLE1BQU12QixRQUFaLENBQUosRUFBMkI7QUFDekIsVUFBSyxJQUFJdGQsSUFBSSxDQUFSLEVBQVcrSyxJQUFJOFQsTUFBTXZCLFFBQU4sQ0FBZXJkLE1BQW5DLEVBQTJDRCxJQUFJK0ssQ0FBL0MsRUFBa0QvSyxHQUFsRCxFQUF1RDtBQUNyRCxXQUFJa1ksUUFBUTJHLE1BQU12QixRQUFOLENBQWV0ZCxDQUFmLENBQVo7QUFDQSxXQUFJdUgsTUFBTTJRLE1BQU1tRSxHQUFaLEtBQW9CaFYsUUFBUTZRLE1BQU0wRixFQUFkLENBQXhCLEVBQTJDO0FBQ3pDd1IsaUJBQVFsWCxLQUFSLEVBQWUwRixFQUFmO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUE7OztBQUdBLFVBQVN5UixVQUFULENBQ0VubkIsR0FERixFQUVFZ1YsTUFGRixFQUdFO0FBQ0EsT0FBSS9SLEdBQUosRUFBU25MLENBQVQsRUFBWStLLENBQVosRUFBZWxFLElBQWYsRUFBcUJnRCxHQUFyQjtBQUNBLE9BQUl1QixNQUFNbUIsT0FBTixDQUFjckUsR0FBZCxLQUFzQixPQUFPQSxHQUFQLEtBQWUsUUFBekMsRUFBbUQ7QUFDakRpRCxXQUFNLElBQUlDLEtBQUosQ0FBVWxELElBQUlqSSxNQUFkLENBQU47QUFDQSxVQUFLRCxJQUFJLENBQUosRUFBTytLLElBQUk3QyxJQUFJakksTUFBcEIsRUFBNEJELElBQUkrSyxDQUFoQyxFQUFtQy9LLEdBQW5DLEVBQXdDO0FBQ3RDbUwsV0FBSW5MLENBQUosSUFBU2tkLE9BQU9oVixJQUFJbEksQ0FBSixDQUFQLEVBQWVBLENBQWYsQ0FBVDtBQUNEO0FBQ0YsSUFMRCxNQUtPLElBQUksT0FBT2tJLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQ2lELFdBQU0sSUFBSUMsS0FBSixDQUFVbEQsR0FBVixDQUFOO0FBQ0EsVUFBS2xJLElBQUksQ0FBVCxFQUFZQSxJQUFJa0ksR0FBaEIsRUFBcUJsSSxHQUFyQixFQUEwQjtBQUN4Qm1MLFdBQUluTCxDQUFKLElBQVNrZCxPQUFPbGQsSUFBSSxDQUFYLEVBQWNBLENBQWQsQ0FBVDtBQUNEO0FBQ0YsSUFMTSxNQUtBLElBQUk0SCxTQUFTTSxHQUFULENBQUosRUFBbUI7QUFDeEJyQixZQUFPRCxPQUFPQyxJQUFQLENBQVlxQixHQUFaLENBQVA7QUFDQWlELFdBQU0sSUFBSUMsS0FBSixDQUFVdkUsS0FBSzVHLE1BQWYsQ0FBTjtBQUNBLFVBQUtELElBQUksQ0FBSixFQUFPK0ssSUFBSWxFLEtBQUs1RyxNQUFyQixFQUE2QkQsSUFBSStLLENBQWpDLEVBQW9DL0ssR0FBcEMsRUFBeUM7QUFDdkM2SixhQUFNaEQsS0FBSzdHLENBQUwsQ0FBTjtBQUNBbUwsV0FBSW5MLENBQUosSUFBU2tkLE9BQU9oVixJQUFJMkIsR0FBSixDQUFQLEVBQWlCQSxHQUFqQixFQUFzQjdKLENBQXRCLENBQVQ7QUFDRDtBQUNGO0FBQ0QsT0FBSXVILE1BQU00RCxHQUFOLENBQUosRUFBZ0I7QUFDYkEsUUFBRCxDQUFNNlYsUUFBTixHQUFpQixJQUFqQjtBQUNEO0FBQ0QsVUFBTzdWLEdBQVA7QUFDRDs7QUFFRDs7QUFFQTs7O0FBR0EsVUFBU21rQixVQUFULENBQ0UvdUIsSUFERixFQUVFZ3ZCLFFBRkYsRUFHRXBXLEtBSEYsRUFJRXFXLFVBSkYsRUFLRTtBQUNBLE9BQUlDLGVBQWUsS0FBS2hKLFlBQUwsQ0FBa0JsbUIsSUFBbEIsQ0FBbkI7QUFDQSxPQUFJa3ZCLFlBQUosRUFBa0I7QUFBRTtBQUNsQnRXLGFBQVFBLFNBQVMsRUFBakI7QUFDQSxTQUFJcVcsVUFBSixFQUFnQjtBQUNkclcsZUFBUTlOLE9BQU9BLE9BQU8sRUFBUCxFQUFXbWtCLFVBQVgsQ0FBUCxFQUErQnJXLEtBQS9CLENBQVI7QUFDRDtBQUNELFlBQU9zVyxhQUFhdFcsS0FBYixLQUF1Qm9XLFFBQTlCO0FBQ0QsSUFORCxNQU1PO0FBQ0wsU0FBSUcsWUFBWSxLQUFLM0ksTUFBTCxDQUFZeG1CLElBQVosQ0FBaEI7QUFDQTtBQUNBLFNBQUltdkIsYUFBYXBpQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBMUMsRUFBd0Q7QUFDdERraUIsaUJBQVVDLFNBQVYsSUFBdUJ2Z0IsS0FDckIsa0NBQWtDN08sSUFBbEMsR0FBeUMsbUNBQXpDLEdBQ0EseUNBRnFCLEVBR3JCLElBSHFCLENBQXZCO0FBS0FtdkIsaUJBQVVDLFNBQVYsR0FBc0IsSUFBdEI7QUFDRDtBQUNELFlBQU9ELGFBQWFILFFBQXBCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7O0FBR0EsVUFBU0ssYUFBVCxDQUF3QmhyQixFQUF4QixFQUE0QjtBQUMxQixVQUFPMlYsYUFBYSxLQUFLdEssUUFBbEIsRUFBNEIsU0FBNUIsRUFBdUNyTCxFQUF2QyxFQUEyQyxJQUEzQyxLQUFvRCtHLFFBQTNEO0FBQ0Q7O0FBRUQ7O0FBRUE7OztBQUdBLFVBQVNra0IsYUFBVCxDQUNFQyxZQURGLEVBRUVqbUIsR0FGRixFQUdFa21CLFlBSEYsRUFJRTtBQUNBLE9BQUlqaUIsV0FBV1osT0FBT1ksUUFBUCxDQUFnQmpFLEdBQWhCLEtBQXdCa21CLFlBQXZDO0FBQ0EsT0FBSTNrQixNQUFNbUIsT0FBTixDQUFjdUIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFlBQU9BLFNBQVNwTSxPQUFULENBQWlCb3VCLFlBQWpCLE1BQW1DLENBQUMsQ0FBM0M7QUFDRCxJQUZELE1BRU87QUFDTCxZQUFPaGlCLGFBQWFnaUIsWUFBcEI7QUFDRDtBQUNGOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTRSxlQUFULENBQ0V6cUIsSUFERixFQUVFOFcsR0FGRixFQUdFMVUsS0FIRixFQUlFc29CLE1BSkYsRUFLRUMsTUFMRixFQU1FO0FBQ0EsT0FBSXZvQixLQUFKLEVBQVc7QUFDVCxTQUFJLENBQUNDLFNBQVNELEtBQVQsQ0FBTCxFQUFzQjtBQUNwQjJGLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLDBEQUR1QyxFQUV2QyxJQUZ1QyxDQUF6QztBQUlELE1BTEQsTUFLTztBQUNMLFdBQUloRSxNQUFNbUIsT0FBTixDQUFjNUUsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCQSxpQkFBUTZELFNBQVM3RCxLQUFULENBQVI7QUFDRDtBQUNELFdBQUk4WSxJQUFKO0FBQ0EsV0FBSWtLLE9BQU8sU0FBUEEsSUFBTyxDQUFXOWdCLEdBQVgsRUFBaUI7QUFDMUIsYUFDRUEsUUFBUSxPQUFSLElBQ0FBLFFBQVEsT0FEUixJQUVBUCxvQkFBb0JPLEdBQXBCLENBSEYsRUFJRTtBQUNBNFcsa0JBQU9sYixJQUFQO0FBQ0QsVUFORCxNQU1PO0FBQ0wsZUFBSTJULE9BQU8zVCxLQUFLOGEsS0FBTCxJQUFjOWEsS0FBSzhhLEtBQUwsQ0FBV25ILElBQXBDO0FBQ0F1SCxrQkFBT3dQLFVBQVUvaUIsT0FBT2tCLFdBQVAsQ0FBbUJpTyxHQUFuQixFQUF3Qm5ELElBQXhCLEVBQThCclAsR0FBOUIsQ0FBVixHQUNIdEUsS0FBSzRxQixRQUFMLEtBQWtCNXFCLEtBQUs0cUIsUUFBTCxHQUFnQixFQUFsQyxDQURHLEdBRUg1cUIsS0FBSzhhLEtBQUwsS0FBZTlhLEtBQUs4YSxLQUFMLEdBQWEsRUFBNUIsQ0FGSjtBQUdEO0FBQ0QsYUFBSSxFQUFFeFcsT0FBTzRXLElBQVQsQ0FBSixFQUFvQjtBQUNsQkEsZ0JBQUs1VyxHQUFMLElBQVlsQyxNQUFNa0MsR0FBTixDQUFaOztBQUVBLGVBQUlxbUIsTUFBSixFQUFZO0FBQ1YsaUJBQUl4USxLQUFLbmEsS0FBS21hLEVBQUwsS0FBWW5hLEtBQUttYSxFQUFMLEdBQVUsRUFBdEIsQ0FBVDtBQUNBQSxnQkFBSSxZQUFZN1YsR0FBaEIsSUFBd0IsVUFBVXVtQixNQUFWLEVBQWtCO0FBQ3hDem9CLHFCQUFNa0MsR0FBTixJQUFhdW1CLE1BQWI7QUFDRCxjQUZEO0FBR0Q7QUFDRjtBQUNGLFFBdkJEOztBQXlCQSxZQUFLLElBQUl2bUIsR0FBVCxJQUFnQmxDLEtBQWhCO0FBQXVCZ2pCLGNBQU05Z0IsR0FBTjtBQUF2QjtBQUNEO0FBQ0Y7QUFDRCxVQUFPdEUsSUFBUDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTOHFCLFlBQVQsQ0FDRXJzQixLQURGLEVBRUVzc0IsT0FGRixFQUdFO0FBQ0EsT0FBSTlmLE9BQU8sS0FBSytmLFlBQUwsQ0FBa0J2c0IsS0FBbEIsQ0FBWDtBQUNBO0FBQ0E7QUFDQSxPQUFJd00sUUFBUSxDQUFDOGYsT0FBYixFQUFzQjtBQUNwQixZQUFPbGxCLE1BQU1tQixPQUFOLENBQWNpRSxJQUFkLElBQ0h1TyxZQUFZdk8sSUFBWixDQURHLEdBRUhvTyxXQUFXcE8sSUFBWCxDQUZKO0FBR0Q7QUFDRDtBQUNBQSxVQUFPLEtBQUsrZixZQUFMLENBQWtCdnNCLEtBQWxCLElBQ0wsS0FBS2lNLFFBQUwsQ0FBY3NlLGVBQWQsQ0FBOEJ2cUIsS0FBOUIsRUFBcUMxRSxJQUFyQyxDQUEwQyxLQUFLOGQsWUFBL0MsQ0FERjtBQUVBb1QsY0FBV2hnQixJQUFYLEVBQWtCLGVBQWV4TSxLQUFqQyxFQUF5QyxLQUF6QztBQUNBLFVBQU93TSxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTaWdCLFFBQVQsQ0FDRWpnQixJQURGLEVBRUV4TSxLQUZGLEVBR0U2RixHQUhGLEVBSUU7QUFDQTJtQixjQUFXaGdCLElBQVgsRUFBa0IsYUFBYXhNLEtBQWIsSUFBc0I2RixNQUFPLE1BQU1BLEdBQWIsR0FBb0IsRUFBMUMsQ0FBbEIsRUFBa0UsSUFBbEU7QUFDQSxVQUFPMkcsSUFBUDtBQUNEOztBQUVELFVBQVNnZ0IsVUFBVCxDQUNFaGdCLElBREYsRUFFRTNHLEdBRkYsRUFHRXVVLE1BSEYsRUFJRTtBQUNBLE9BQUloVCxNQUFNbUIsT0FBTixDQUFjaUUsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFVBQUssSUFBSXhRLElBQUksQ0FBYixFQUFnQkEsSUFBSXdRLEtBQUt2USxNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDcEMsV0FBSXdRLEtBQUt4USxDQUFMLEtBQVcsT0FBT3dRLEtBQUt4USxDQUFMLENBQVAsS0FBbUIsUUFBbEMsRUFBNEM7QUFDMUMwd0Isd0JBQWVsZ0IsS0FBS3hRLENBQUwsQ0FBZixFQUF5QjZKLE1BQU0sR0FBTixHQUFZN0osQ0FBckMsRUFBeUNvZSxNQUF6QztBQUNEO0FBQ0Y7QUFDRixJQU5ELE1BTU87QUFDTHNTLG9CQUFlbGdCLElBQWYsRUFBcUIzRyxHQUFyQixFQUEwQnVVLE1BQTFCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTc1MsY0FBVCxDQUF5QmhTLElBQXpCLEVBQStCN1UsR0FBL0IsRUFBb0N1VSxNQUFwQyxFQUE0QztBQUMxQ00sUUFBS1YsUUFBTCxHQUFnQixJQUFoQjtBQUNBVSxRQUFLN1UsR0FBTCxHQUFXQSxHQUFYO0FBQ0E2VSxRQUFLTixNQUFMLEdBQWNBLE1BQWQ7QUFDRDs7QUFFRDs7QUFFQSxVQUFTdVMsbUJBQVQsQ0FBOEJwckIsSUFBOUIsRUFBb0NvQyxLQUFwQyxFQUEyQztBQUN6QyxPQUFJQSxLQUFKLEVBQVc7QUFDVCxTQUFJLENBQUNJLGNBQWNKLEtBQWQsQ0FBTCxFQUEyQjtBQUN6QjJGLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLCtDQUR1QyxFQUV2QyxJQUZ1QyxDQUF6QztBQUlELE1BTEQsTUFLTztBQUNMLFdBQUlzUSxLQUFLbmEsS0FBS21hLEVBQUwsR0FBVW5hLEtBQUttYSxFQUFMLEdBQVVyVSxPQUFPLEVBQVAsRUFBVzlGLEtBQUttYSxFQUFoQixDQUFWLEdBQWdDLEVBQW5EO0FBQ0EsWUFBSyxJQUFJN1YsR0FBVCxJQUFnQmxDLEtBQWhCLEVBQXVCO0FBQ3JCLGFBQUlpcEIsV0FBV2xSLEdBQUc3VixHQUFILENBQWY7QUFDQSxhQUFJNGtCLE9BQU85bUIsTUFBTWtDLEdBQU4sQ0FBWDtBQUNBNlYsWUFBRzdWLEdBQUgsSUFBVSttQixXQUFXLEdBQUc1a0IsTUFBSCxDQUFVeWlCLElBQVYsRUFBZ0JtQyxRQUFoQixDQUFYLEdBQXVDbkMsSUFBakQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPbHBCLElBQVA7QUFDRDs7QUFFRDs7QUFFQSxVQUFTc3JCLFVBQVQsQ0FBcUJsaEIsRUFBckIsRUFBeUI7QUFDdkJBLE1BQUdzVixNQUFILEdBQVksSUFBWixDQUR1QixDQUNMO0FBQ2xCdFYsTUFBRzRnQixZQUFILEdBQWtCLElBQWxCO0FBQ0EsT0FBSW5LLGNBQWN6VyxHQUFHNFYsTUFBSCxHQUFZNVYsR0FBR00sUUFBSCxDQUFZeVcsWUFBMUMsQ0FIdUIsQ0FHaUM7QUFDeEQsT0FBSW9LLGdCQUFnQjFLLGVBQWVBLFlBQVkzSSxPQUEvQztBQUNBOU4sTUFBR29YLE1BQUgsR0FBWXZELGFBQWE3VCxHQUFHTSxRQUFILENBQVlzVyxlQUF6QixFQUEwQ3VLLGFBQTFDLENBQVo7QUFDQW5oQixNQUFHOFcsWUFBSCxHQUFrQm5ZLFdBQWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXFCLE1BQUdvaEIsRUFBSCxHQUFRLFVBQVVqbUIsQ0FBVixFQUFhVyxDQUFiLEVBQWdCbEIsQ0FBaEIsRUFBbUJyRSxDQUFuQixFQUFzQjtBQUFFLFlBQU95bUIsY0FBY2hkLEVBQWQsRUFBa0I3RSxDQUFsQixFQUFxQlcsQ0FBckIsRUFBd0JsQixDQUF4QixFQUEyQnJFLENBQTNCLEVBQThCLEtBQTlCLENBQVA7QUFBOEMsSUFBOUU7QUFDQTtBQUNBO0FBQ0F5SixNQUFHcWhCLGNBQUgsR0FBb0IsVUFBVWxtQixDQUFWLEVBQWFXLENBQWIsRUFBZ0JsQixDQUFoQixFQUFtQnJFLENBQW5CLEVBQXNCO0FBQUUsWUFBT3ltQixjQUFjaGQsRUFBZCxFQUFrQjdFLENBQWxCLEVBQXFCVyxDQUFyQixFQUF3QmxCLENBQXhCLEVBQTJCckUsQ0FBM0IsRUFBOEIsSUFBOUIsQ0FBUDtBQUE2QyxJQUF6Rjs7QUFFQTtBQUNBO0FBQ0EsT0FBSStxQixhQUFhN0ssZUFBZUEsWUFBWTdnQixJQUE1QztBQUNBO0FBQ0EsT0FBSStILFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q21KLHVCQUFrQmhILEVBQWxCLEVBQXNCLFFBQXRCLEVBQWdDc2hCLGNBQWNBLFdBQVc1USxLQUF6RCxFQUFnRSxZQUFZO0FBQzFFLFFBQUMwRCx3QkFBRCxJQUE2QjNVLEtBQUsscUJBQUwsRUFBNEJPLEVBQTVCLENBQTdCO0FBQ0QsTUFGRCxFQUVHLElBRkg7QUFHQWdILHVCQUFrQmhILEVBQWxCLEVBQXNCLFlBQXRCLEVBQW9DQSxHQUFHTSxRQUFILENBQVl3UyxnQkFBaEQsRUFBa0UsWUFBWTtBQUM1RSxRQUFDc0Isd0JBQUQsSUFBNkIzVSxLQUFLLHlCQUFMLEVBQWdDTyxFQUFoQyxDQUE3QjtBQUNELE1BRkQsRUFFRyxJQUZIO0FBR0QsSUFQRCxNQU9PO0FBQ0xnSCx1QkFBa0JoSCxFQUFsQixFQUFzQixRQUF0QixFQUFnQ3NoQixjQUFjQSxXQUFXNVEsS0FBekQsRUFBZ0UsSUFBaEUsRUFBc0UsSUFBdEU7QUFDQTFKLHVCQUFrQmhILEVBQWxCLEVBQXNCLFlBQXRCLEVBQW9DQSxHQUFHTSxRQUFILENBQVl3UyxnQkFBaEQsRUFBa0UsSUFBbEUsRUFBd0UsSUFBeEU7QUFDRDtBQUNGOztBQUVELFVBQVN5TyxXQUFULENBQXNCak8sR0FBdEIsRUFBMkI7QUFDekJBLE9BQUk1akIsU0FBSixDQUFjOHhCLFNBQWQsR0FBMEIsVUFBVXBuQixFQUFWLEVBQWM7QUFDdEMsWUFBTzRJLFNBQVM1SSxFQUFULEVBQWEsSUFBYixDQUFQO0FBQ0QsSUFGRDs7QUFJQWtaLE9BQUk1akIsU0FBSixDQUFjNG1CLE9BQWQsR0FBd0IsWUFBWTtBQUNsQyxTQUFJdFcsS0FBSyxJQUFUO0FBQ0EsU0FBSXloQixNQUFNemhCLEdBQUdNLFFBQWI7QUFDQSxTQUFJaU4sU0FBU2tVLElBQUlsVSxNQUFqQjtBQUNBLFNBQUlxUixrQkFBa0I2QyxJQUFJN0MsZUFBMUI7QUFDQSxTQUFJN0gsZUFBZTBLLElBQUkxSyxZQUF2Qjs7QUFFQSxTQUFJL1csR0FBRzRVLFVBQVAsRUFBbUI7QUFDakI7QUFDQSxZQUFLLElBQUkxYSxHQUFULElBQWdCOEYsR0FBR29YLE1BQW5CLEVBQTJCO0FBQ3pCcFgsWUFBR29YLE1BQUgsQ0FBVWxkLEdBQVYsSUFBaUJrVixZQUFZcFAsR0FBR29YLE1BQUgsQ0FBVWxkLEdBQVYsQ0FBWixDQUFqQjtBQUNEO0FBQ0Y7O0FBRUQ4RixRQUFHOFcsWUFBSCxHQUFtQkMsZ0JBQWdCQSxhQUFhbmhCLElBQWIsQ0FBa0JpaEIsV0FBbkMsSUFBbURsWSxXQUFyRTs7QUFFQSxTQUFJaWdCLG1CQUFtQixDQUFDNWUsR0FBRzRnQixZQUEzQixFQUF5QztBQUN2QzVnQixVQUFHNGdCLFlBQUgsR0FBa0IsRUFBbEI7QUFDRDtBQUNEO0FBQ0E7QUFDQTVnQixRQUFHNFYsTUFBSCxHQUFZbUIsWUFBWjtBQUNBO0FBQ0EsU0FBSTdILEtBQUo7QUFDQSxTQUFJO0FBQ0ZBLGVBQVEzQixPQUFPNWQsSUFBUCxDQUFZcVEsR0FBR3lOLFlBQWYsRUFBNkJ6TixHQUFHcWhCLGNBQWhDLENBQVI7QUFDRCxNQUZELENBRUUsT0FBT3p4QixDQUFQLEVBQVU7QUFDVnNSLG1CQUFZdFIsQ0FBWixFQUFlb1EsRUFBZixFQUFtQixpQkFBbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFJckMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDcVIsaUJBQVFsUCxHQUFHTSxRQUFILENBQVlvaEIsV0FBWixHQUNKMWhCLEdBQUdNLFFBQUgsQ0FBWW9oQixXQUFaLENBQXdCL3hCLElBQXhCLENBQTZCcVEsR0FBR3lOLFlBQWhDLEVBQThDek4sR0FBR3FoQixjQUFqRCxFQUFpRXp4QixDQUFqRSxDQURJLEdBRUpvUSxHQUFHc1YsTUFGUDtBQUdELFFBSkQsTUFJTztBQUNMcEcsaUJBQVFsUCxHQUFHc1YsTUFBWDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFNBQUksRUFBRXBHLGlCQUFpQnhCLEtBQW5CLENBQUosRUFBK0I7QUFDN0IsV0FBSS9QLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5Q3BDLE1BQU1tQixPQUFOLENBQWNzUyxLQUFkLENBQTdDLEVBQW1FO0FBQ2pFelAsY0FDRSx3RUFDQSxtQ0FGRixFQUdFTyxFQUhGO0FBS0Q7QUFDRGtQLGVBQVFKLGtCQUFSO0FBQ0Q7QUFDRDtBQUNBSSxXQUFNNUcsTUFBTixHQUFleU8sWUFBZjtBQUNBLFlBQU83SCxLQUFQO0FBQ0QsSUFyREQ7O0FBdURBO0FBQ0E7QUFDQTtBQUNBb0UsT0FBSTVqQixTQUFKLENBQWNpeUIsRUFBZCxHQUFtQmIsUUFBbkI7QUFDQXhOLE9BQUk1akIsU0FBSixDQUFja3lCLEVBQWQsR0FBbUI1b0IsUUFBbkI7QUFDQXNhLE9BQUk1akIsU0FBSixDQUFjbXlCLEVBQWQsR0FBbUIxcEIsUUFBbkI7QUFDQW1iLE9BQUk1akIsU0FBSixDQUFjb3lCLEVBQWQsR0FBbUJwQyxVQUFuQjtBQUNBcE0sT0FBSTVqQixTQUFKLENBQWNxeUIsRUFBZCxHQUFtQnBDLFVBQW5CO0FBQ0FyTSxPQUFJNWpCLFNBQUosQ0FBY3N5QixFQUFkLEdBQW1CeGxCLFVBQW5CO0FBQ0E4VyxPQUFJNWpCLFNBQUosQ0FBY3V5QixFQUFkLEdBQW1CaGxCLFlBQW5CO0FBQ0FxVyxPQUFJNWpCLFNBQUosQ0FBY3d5QixFQUFkLEdBQW1CeEIsWUFBbkI7QUFDQXBOLE9BQUk1akIsU0FBSixDQUFjeXlCLEVBQWQsR0FBbUJsQyxhQUFuQjtBQUNBM00sT0FBSTVqQixTQUFKLENBQWMweUIsRUFBZCxHQUFtQmxDLGFBQW5CO0FBQ0E1TSxPQUFJNWpCLFNBQUosQ0FBYzJ5QixFQUFkLEdBQW1CaEMsZUFBbkI7QUFDQS9NLE9BQUk1akIsU0FBSixDQUFjNHlCLEVBQWQsR0FBbUJ0VCxlQUFuQjtBQUNBc0UsT0FBSTVqQixTQUFKLENBQWM2eUIsRUFBZCxHQUFtQnpULGdCQUFuQjtBQUNBd0UsT0FBSTVqQixTQUFKLENBQWM4eUIsRUFBZCxHQUFtQnRPLGtCQUFuQjtBQUNBWixPQUFJNWpCLFNBQUosQ0FBYyt5QixFQUFkLEdBQW1CekIsbUJBQW5CO0FBQ0Q7O0FBRUQ7O0FBRUEsS0FBSTBCLFFBQVEsQ0FBWjs7QUFFQSxVQUFTQyxTQUFULENBQW9CclAsR0FBcEIsRUFBeUI7QUFDdkJBLE9BQUk1akIsU0FBSixDQUFja3pCLEtBQWQsR0FBc0IsVUFBVXhpQixPQUFWLEVBQW1CO0FBQ3ZDLFNBQUlKLEtBQUssSUFBVDtBQUNBO0FBQ0FBLFFBQUdxVyxJQUFILEdBQVVxTSxPQUFWOztBQUVBLFNBQUkvVixRQUFKLEVBQWNDLE1BQWQ7QUFDQTtBQUNBLFNBQUlqUCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkVNLGtCQUFXLG1CQUFvQjNNLEdBQUdxVyxJQUFsQztBQUNBekosZ0JBQVMsa0JBQW1CNU0sR0FBR3FXLElBQS9CO0FBQ0FoSyxZQUFLTSxRQUFMO0FBQ0Q7O0FBRUQ7QUFDQTNNLFFBQUdLLE1BQUgsR0FBWSxJQUFaO0FBQ0E7QUFDQSxTQUFJRCxXQUFXQSxRQUFRc2UsWUFBdkIsRUFBcUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0FtRSw2QkFBc0I3aUIsRUFBdEIsRUFBMEJJLE9BQTFCO0FBQ0QsTUFMRCxNQUtPO0FBQ0xKLFVBQUdNLFFBQUgsR0FBY2dLLGFBQ1o2VCwwQkFBMEJuZSxHQUFHZ0IsV0FBN0IsQ0FEWSxFQUVaWixXQUFXLEVBRkMsRUFHWkosRUFIWSxDQUFkO0FBS0Q7QUFDRDtBQUNBLFNBQUlyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnUCxpQkFBVTdNLEVBQVY7QUFDRCxNQUZELE1BRU87QUFDTEEsVUFBR3lOLFlBQUgsR0FBa0J6TixFQUFsQjtBQUNEO0FBQ0Q7QUFDQUEsUUFBRzhpQixLQUFILEdBQVc5aUIsRUFBWDtBQUNBcVUsbUJBQWNyVSxFQUFkO0FBQ0EwUyxnQkFBVzFTLEVBQVg7QUFDQWtoQixnQkFBV2xoQixFQUFYO0FBQ0FrVixjQUFTbFYsRUFBVCxFQUFhLGNBQWI7QUFDQXdjLG9CQUFleGMsRUFBZixFQXhDdUMsQ0F3Q25CO0FBQ3BCc2EsZUFBVXRhLEVBQVY7QUFDQXNjLGlCQUFZdGMsRUFBWixFQTFDdUMsQ0EwQ3RCO0FBQ2pCa1YsY0FBU2xWLEVBQVQsRUFBYSxTQUFiOztBQUVBO0FBQ0EsU0FBSXJDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5Q04sT0FBT1EsV0FBaEQsSUFBK0RzTyxJQUFuRSxFQUF5RTtBQUN2RXJNLFVBQUdvVyxLQUFILEdBQVd6VyxvQkFBb0JLLEVBQXBCLEVBQXdCLEtBQXhCLENBQVg7QUFDQXFNLFlBQUtPLE1BQUw7QUFDQU4sZUFBVXRNLEdBQUdvVyxLQUFKLEdBQWEsT0FBdEIsRUFBZ0N6SixRQUFoQyxFQUEwQ0MsTUFBMUM7QUFDRDs7QUFFRCxTQUFJNU0sR0FBR00sUUFBSCxDQUFZOEgsRUFBaEIsRUFBb0I7QUFDbEJwSSxVQUFHd2QsTUFBSCxDQUFVeGQsR0FBR00sUUFBSCxDQUFZOEgsRUFBdEI7QUFDRDtBQUNGLElBdkREO0FBd0REOztBQUVELFVBQVN5YSxxQkFBVCxDQUFnQzdpQixFQUFoQyxFQUFvQ0ksT0FBcEMsRUFBNkM7QUFDM0MsT0FBSThCLE9BQU9sQyxHQUFHTSxRQUFILEdBQWNySixPQUFPcUMsTUFBUCxDQUFjMEcsR0FBR2dCLFdBQUgsQ0FBZVosT0FBN0IsQ0FBekI7QUFDQTtBQUNBOEIsUUFBS29HLE1BQUwsR0FBY2xJLFFBQVFrSSxNQUF0QjtBQUNBcEcsUUFBS21HLFNBQUwsR0FBaUJqSSxRQUFRaUksU0FBekI7QUFDQW5HLFFBQUs2VSxZQUFMLEdBQW9CM1csUUFBUTJXLFlBQTVCO0FBQ0E3VSxRQUFLNFEsZ0JBQUwsR0FBd0IxUyxRQUFRMFMsZ0JBQWhDO0FBQ0E1USxRQUFLMFUsZUFBTCxHQUF1QnhXLFFBQVF3VyxlQUEvQjtBQUNBMVUsUUFBSzNCLGFBQUwsR0FBcUJILFFBQVFHLGFBQTdCO0FBQ0EyQixRQUFLdVQsVUFBTCxHQUFrQnJWLFFBQVFxVixVQUExQjtBQUNBdlQsUUFBS3dULE9BQUwsR0FBZXRWLFFBQVFzVixPQUF2QjtBQUNBLE9BQUl0VixRQUFRbU4sTUFBWixFQUFvQjtBQUNsQnJMLFVBQUtxTCxNQUFMLEdBQWNuTixRQUFRbU4sTUFBdEI7QUFDQXJMLFVBQUswYyxlQUFMLEdBQXVCeGUsUUFBUXdlLGVBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTVCx5QkFBVCxDQUFvQ3hiLElBQXBDLEVBQTBDO0FBQ3hDLE9BQUl2QyxVQUFVdUMsS0FBS3ZDLE9BQW5CO0FBQ0EsT0FBSXVDLEtBQUtvZ0IsS0FBVCxFQUFnQjtBQUNkLFNBQUlDLGVBQWU3RSwwQkFBMEJ4YixLQUFLb2dCLEtBQS9CLENBQW5CO0FBQ0EsU0FBSUUscUJBQXFCdGdCLEtBQUtxZ0IsWUFBOUI7QUFDQSxTQUFJQSxpQkFBaUJDLGtCQUFyQixFQUF5QztBQUN2QztBQUNBO0FBQ0F0Z0IsWUFBS3FnQixZQUFMLEdBQW9CQSxZQUFwQjtBQUNBO0FBQ0EsV0FBSUUsa0JBQWtCQyx1QkFBdUJ4Z0IsSUFBdkIsQ0FBdEI7QUFDQTtBQUNBLFdBQUl1Z0IsZUFBSixFQUFxQjtBQUNuQnhuQixnQkFBT2lILEtBQUt5Z0IsYUFBWixFQUEyQkYsZUFBM0I7QUFDRDtBQUNEOWlCLGlCQUFVdUMsS0FBS3ZDLE9BQUwsR0FBZWtLLGFBQWEwWSxZQUFiLEVBQTJCcmdCLEtBQUt5Z0IsYUFBaEMsQ0FBekI7QUFDQSxXQUFJaGpCLFFBQVF4UCxJQUFaLEVBQWtCO0FBQ2hCd1AsaUJBQVEwSixVQUFSLENBQW1CMUosUUFBUXhQLElBQTNCLElBQW1DK1IsSUFBbkM7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPdkMsT0FBUDtBQUNEOztBQUVELFVBQVMraUIsc0JBQVQsQ0FBaUN4Z0IsSUFBakMsRUFBdUM7QUFDckMsT0FBSTBnQixRQUFKO0FBQ0EsT0FBSUMsU0FBUzNnQixLQUFLdkMsT0FBbEI7QUFDQSxPQUFJbWpCLFdBQVc1Z0IsS0FBS3lnQixhQUFwQjtBQUNBLE9BQUlJLFNBQVM3Z0IsS0FBSzhnQixhQUFsQjtBQUNBLFFBQUssSUFBSXZwQixHQUFULElBQWdCb3BCLE1BQWhCLEVBQXdCO0FBQ3RCLFNBQUlBLE9BQU9wcEIsR0FBUCxNQUFnQnNwQixPQUFPdHBCLEdBQVAsQ0FBcEIsRUFBaUM7QUFDL0IsV0FBSSxDQUFDbXBCLFFBQUwsRUFBZTtBQUFFQSxvQkFBVyxFQUFYO0FBQWdCO0FBQ2pDQSxnQkFBU25wQixHQUFULElBQWdCd3BCLE9BQU9KLE9BQU9wcEIsR0FBUCxDQUFQLEVBQW9CcXBCLFNBQVNycEIsR0FBVCxDQUFwQixFQUFtQ3NwQixPQUFPdHBCLEdBQVAsQ0FBbkMsQ0FBaEI7QUFDRDtBQUNGO0FBQ0QsVUFBT21wQixRQUFQO0FBQ0Q7O0FBRUQsVUFBU0ssTUFBVCxDQUFpQkosTUFBakIsRUFBeUJDLFFBQXpCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6QztBQUNBO0FBQ0EsT0FBSS9uQixNQUFNbUIsT0FBTixDQUFjMG1CLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixTQUFJbnVCLE1BQU0sRUFBVjtBQUNBcXVCLGNBQVMvbkIsTUFBTW1CLE9BQU4sQ0FBYzRtQixNQUFkLElBQXdCQSxNQUF4QixHQUFpQyxDQUFDQSxNQUFELENBQTFDO0FBQ0FELGdCQUFXOW5CLE1BQU1tQixPQUFOLENBQWMybUIsUUFBZCxJQUEwQkEsUUFBMUIsR0FBcUMsQ0FBQ0EsUUFBRCxDQUFoRDtBQUNBLFVBQUssSUFBSWx6QixJQUFJLENBQWIsRUFBZ0JBLElBQUlpekIsT0FBT2h6QixNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDdEM7QUFDQSxXQUFJa3pCLFNBQVN4eEIsT0FBVCxDQUFpQnV4QixPQUFPanpCLENBQVAsQ0FBakIsS0FBK0IsQ0FBL0IsSUFBb0NtekIsT0FBT3p4QixPQUFQLENBQWV1eEIsT0FBT2p6QixDQUFQLENBQWYsSUFBNEIsQ0FBcEUsRUFBdUU7QUFDckU4RSxhQUFJOEwsSUFBSixDQUFTcWlCLE9BQU9qekIsQ0FBUCxDQUFUO0FBQ0Q7QUFDRjtBQUNELFlBQU84RSxHQUFQO0FBQ0QsSUFYRCxNQVdPO0FBQ0wsWUFBT211QixNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTSyxLQUFULENBQWdCdmpCLE9BQWhCLEVBQXlCO0FBQ3ZCLE9BQUl6QyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFDRixFQUFFLGdCQUFnQjhsQixLQUFsQixDQURGLEVBRUU7QUFDQWxrQixVQUFLLGtFQUFMO0FBQ0Q7QUFDRCxRQUFLbWpCLEtBQUwsQ0FBV3hpQixPQUFYO0FBQ0Q7O0FBRUR1aUIsV0FBVWdCLEtBQVY7QUFDQTdILFlBQVc2SCxLQUFYO0FBQ0F0USxhQUFZc1EsS0FBWjtBQUNBNU8sZ0JBQWU0TyxLQUFmO0FBQ0FwQyxhQUFZb0MsS0FBWjs7QUFFQTs7QUFFQSxVQUFTQyxPQUFULENBQWtCdFEsR0FBbEIsRUFBdUI7QUFDckJBLE9BQUloZixHQUFKLEdBQVUsVUFBVXV2QixNQUFWLEVBQWtCO0FBQzFCLFNBQUlDLG1CQUFvQixLQUFLQyxpQkFBTCxLQUEyQixLQUFLQSxpQkFBTCxHQUF5QixFQUFwRCxDQUF4QjtBQUNBLFNBQUlELGlCQUFpQi94QixPQUFqQixDQUF5Qjh4QixNQUF6QixJQUFtQyxDQUFDLENBQXhDLEVBQTJDO0FBQ3pDLGNBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0EsU0FBSS9kLE9BQU94SyxRQUFReEwsU0FBUixFQUFtQixDQUFuQixDQUFYO0FBQ0FnVyxVQUFLa2UsT0FBTCxDQUFhLElBQWI7QUFDQSxTQUFJLE9BQU9ILE9BQU9JLE9BQWQsS0FBMEIsVUFBOUIsRUFBMEM7QUFDeENKLGNBQU9JLE9BQVAsQ0FBZXAwQixLQUFmLENBQXFCZzBCLE1BQXJCLEVBQTZCL2QsSUFBN0I7QUFDRCxNQUZELE1BRU8sSUFBSSxPQUFPK2QsTUFBUCxLQUFrQixVQUF0QixFQUFrQztBQUN2Q0EsY0FBT2gwQixLQUFQLENBQWEsSUFBYixFQUFtQmlXLElBQW5CO0FBQ0Q7QUFDRGdlLHNCQUFpQjdpQixJQUFqQixDQUFzQjRpQixNQUF0QjtBQUNBLFlBQU8sSUFBUDtBQUNELElBaEJEO0FBaUJEOztBQUVEOztBQUVBLFVBQVNLLFdBQVQsQ0FBc0I1USxHQUF0QixFQUEyQjtBQUN6QkEsT0FBSTZRLEtBQUosR0FBWSxVQUFVQSxLQUFWLEVBQWlCO0FBQzNCLFVBQUsvakIsT0FBTCxHQUFla0ssYUFBYSxLQUFLbEssT0FBbEIsRUFBMkIrakIsS0FBM0IsQ0FBZjtBQUNBLFlBQU8sSUFBUDtBQUNELElBSEQ7QUFJRDs7QUFFRDs7QUFFQSxVQUFTQyxVQUFULENBQXFCOVEsR0FBckIsRUFBMEI7QUFDeEI7Ozs7O0FBS0FBLE9BQUk0SyxHQUFKLEdBQVUsQ0FBVjtBQUNBLE9BQUlBLE1BQU0sQ0FBVjs7QUFFQTs7O0FBR0E1SyxPQUFJNVgsTUFBSixHQUFhLFVBQVUwbkIsYUFBVixFQUF5QjtBQUNwQ0EscUJBQWdCQSxpQkFBaUIsRUFBakM7QUFDQSxTQUFJaUIsUUFBUSxJQUFaO0FBQ0EsU0FBSUMsVUFBVUQsTUFBTW5HLEdBQXBCO0FBQ0EsU0FBSXFHLGNBQWNuQixjQUFjb0IsS0FBZCxLQUF3QnBCLGNBQWNvQixLQUFkLEdBQXNCLEVBQTlDLENBQWxCO0FBQ0EsU0FBSUQsWUFBWUQsT0FBWixDQUFKLEVBQTBCO0FBQ3hCLGNBQU9DLFlBQVlELE9BQVosQ0FBUDtBQUNEOztBQUVELFNBQUkxekIsT0FBT3d5QixjQUFjeHlCLElBQWQsSUFBc0J5ekIsTUFBTWprQixPQUFOLENBQWN4UCxJQUEvQztBQUNBLFNBQUkrTSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsV0FBSSxDQUFDLG1CQUFtQjBCLElBQW5CLENBQXdCM08sSUFBeEIsQ0FBTCxFQUFvQztBQUNsQzZPLGNBQ0UsOEJBQThCN08sSUFBOUIsR0FBcUMscUJBQXJDLEdBQ0EsMkRBREEsR0FFQSwrQkFIRjtBQUtEO0FBQ0Y7O0FBRUQsU0FBSTZ6QixNQUFNLFNBQVNDLFlBQVQsQ0FBdUJ0a0IsT0FBdkIsRUFBZ0M7QUFDeEMsWUFBS3dpQixLQUFMLENBQVd4aUIsT0FBWDtBQUNELE1BRkQ7QUFHQXFrQixTQUFJLzBCLFNBQUosR0FBZ0J1SCxPQUFPcUMsTUFBUCxDQUFjK3FCLE1BQU0zMEIsU0FBcEIsQ0FBaEI7QUFDQSswQixTQUFJLzBCLFNBQUosQ0FBY3NSLFdBQWQsR0FBNEJ5akIsR0FBNUI7QUFDQUEsU0FBSXZHLEdBQUosR0FBVUEsS0FBVjtBQUNBdUcsU0FBSXJrQixPQUFKLEdBQWNrSyxhQUNaK1osTUFBTWprQixPQURNLEVBRVpnakIsYUFGWSxDQUFkO0FBSUFxQixTQUFJLE9BQUosSUFBZUosS0FBZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFJSSxJQUFJcmtCLE9BQUosQ0FBWW9KLEtBQWhCLEVBQXVCO0FBQ3JCbWIsbUJBQVlGLEdBQVo7QUFDRDtBQUNELFNBQUlBLElBQUlya0IsT0FBSixDQUFZdUosUUFBaEIsRUFBMEI7QUFDeEJpYixzQkFBZUgsR0FBZjtBQUNEOztBQUVEO0FBQ0FBLFNBQUkvb0IsTUFBSixHQUFhMm9CLE1BQU0zb0IsTUFBbkI7QUFDQStvQixTQUFJTixLQUFKLEdBQVlFLE1BQU1GLEtBQWxCO0FBQ0FNLFNBQUlud0IsR0FBSixHQUFVK3ZCLE1BQU0vdkIsR0FBaEI7O0FBRUE7QUFDQTtBQUNBK0ksaUJBQVlsRyxPQUFaLENBQW9CLFVBQVVvUyxJQUFWLEVBQWdCO0FBQ2xDa2IsV0FBSWxiLElBQUosSUFBWThhLE1BQU05YSxJQUFOLENBQVo7QUFDRCxNQUZEO0FBR0E7QUFDQSxTQUFJM1ksSUFBSixFQUFVO0FBQ1I2ekIsV0FBSXJrQixPQUFKLENBQVkwSixVQUFaLENBQXVCbFosSUFBdkIsSUFBK0I2ekIsR0FBL0I7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQUEsU0FBSXpCLFlBQUosR0FBbUJxQixNQUFNamtCLE9BQXpCO0FBQ0Fxa0IsU0FBSXJCLGFBQUosR0FBb0JBLGFBQXBCO0FBQ0FxQixTQUFJaEIsYUFBSixHQUFvQi9uQixPQUFPLEVBQVAsRUFBVytvQixJQUFJcmtCLE9BQWYsQ0FBcEI7O0FBRUE7QUFDQW1rQixpQkFBWUQsT0FBWixJQUF1QkcsR0FBdkI7QUFDQSxZQUFPQSxHQUFQO0FBQ0QsSUFuRUQ7QUFvRUQ7O0FBRUQsVUFBU0UsV0FBVCxDQUFzQkUsSUFBdEIsRUFBNEI7QUFDMUIsT0FBSXJiLFFBQVFxYixLQUFLemtCLE9BQUwsQ0FBYW9KLEtBQXpCO0FBQ0EsUUFBSyxJQUFJdFAsR0FBVCxJQUFnQnNQLEtBQWhCLEVBQXVCO0FBQ3JCMFEsV0FBTTJLLEtBQUtuMUIsU0FBWCxFQUFzQixRQUF0QixFQUFnQ3dLLEdBQWhDO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTMHFCLGNBQVQsQ0FBeUJDLElBQXpCLEVBQStCO0FBQzdCLE9BQUlsYixXQUFXa2IsS0FBS3prQixPQUFMLENBQWF1SixRQUE1QjtBQUNBLFFBQUssSUFBSXpQLEdBQVQsSUFBZ0J5UCxRQUFoQixFQUEwQjtBQUN4QjJSLG9CQUFldUosS0FBS24xQixTQUFwQixFQUErQndLLEdBQS9CLEVBQW9DeVAsU0FBU3pQLEdBQVQsQ0FBcEM7QUFDRDtBQUNGOztBQUVEOztBQUVBLFVBQVM0cUIsa0JBQVQsQ0FBNkJ4UixHQUE3QixFQUFrQztBQUNoQzs7O0FBR0FqVyxlQUFZbEcsT0FBWixDQUFvQixVQUFVb1MsSUFBVixFQUFnQjtBQUNsQytKLFNBQUkvSixJQUFKLElBQVksVUFDVnRVLEVBRFUsRUFFVnJHLFVBRlUsRUFHVjtBQUNBLFdBQUksQ0FBQ0EsVUFBTCxFQUFpQjtBQUNmLGdCQUFPLEtBQUt3UixPQUFMLENBQWFtSixPQUFPLEdBQXBCLEVBQXlCdFUsRUFBekIsQ0FBUDtBQUNELFFBRkQsTUFFTztBQUNMO0FBQ0EsYUFBSTBJLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxlQUFJMEwsU0FBUyxXQUFULElBQXdCaE0sT0FBT2EsYUFBUCxDQUFxQm5KLEVBQXJCLENBQTVCLEVBQXNEO0FBQ3BEd0ssa0JBQ0UsZ0VBQ0EsTUFEQSxHQUNTeEssRUFGWDtBQUlEO0FBQ0Y7QUFDRCxhQUFJc1UsU0FBUyxXQUFULElBQXdCblIsY0FBY3hKLFVBQWQsQ0FBNUIsRUFBdUQ7QUFDckRBLHNCQUFXZ0MsSUFBWCxHQUFrQmhDLFdBQVdnQyxJQUFYLElBQW1CcUUsRUFBckM7QUFDQXJHLHdCQUFhLEtBQUt3UixPQUFMLENBQWE2ZCxLQUFiLENBQW1CdmlCLE1BQW5CLENBQTBCOU0sVUFBMUIsQ0FBYjtBQUNEO0FBQ0QsYUFBSTJhLFNBQVMsV0FBVCxJQUF3QixPQUFPM2EsVUFBUCxLQUFzQixVQUFsRCxFQUE4RDtBQUM1REEsd0JBQWEsRUFBRVksTUFBTVosVUFBUixFQUFvQndXLFFBQVF4VyxVQUE1QixFQUFiO0FBQ0Q7QUFDRCxjQUFLd1IsT0FBTCxDQUFhbUosT0FBTyxHQUFwQixFQUF5QnRVLEVBQXpCLElBQStCckcsVUFBL0I7QUFDQSxnQkFBT0EsVUFBUDtBQUNEO0FBQ0YsTUExQkQ7QUEyQkQsSUE1QkQ7QUE2QkQ7O0FBRUQ7O0FBRUEsS0FBSW0yQixlQUFlLENBQUNoc0IsTUFBRCxFQUFTaXNCLE1BQVQsRUFBaUJ2cEIsS0FBakIsQ0FBbkI7O0FBRUEsVUFBU3dwQixnQkFBVCxDQUEyQi9pQixJQUEzQixFQUFpQztBQUMvQixVQUFPQSxTQUFTQSxLQUFLUyxJQUFMLENBQVV2QyxPQUFWLENBQWtCeFAsSUFBbEIsSUFBMEJzUixLQUFLd0ssR0FBeEMsQ0FBUDtBQUNEOztBQUVELFVBQVN3WSxPQUFULENBQWtCQyxPQUFsQixFQUEyQnYwQixJQUEzQixFQUFpQztBQUMvQixPQUFJNkssTUFBTW1CLE9BQU4sQ0FBY3VvQixPQUFkLENBQUosRUFBNEI7QUFDMUIsWUFBT0EsUUFBUXB6QixPQUFSLENBQWdCbkIsSUFBaEIsSUFBd0IsQ0FBQyxDQUFoQztBQUNELElBRkQsTUFFTyxJQUFJLE9BQU91MEIsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUN0QyxZQUFPQSxRQUFRM3JCLEtBQVIsQ0FBYyxHQUFkLEVBQW1CekgsT0FBbkIsQ0FBMkJuQixJQUEzQixJQUFtQyxDQUFDLENBQTNDO0FBQ0QsSUFGTSxNQUVBLElBQUl5SCxTQUFTOHNCLE9BQVQsQ0FBSixFQUF1QjtBQUM1QixZQUFPQSxRQUFRNWxCLElBQVIsQ0FBYTNPLElBQWIsQ0FBUDtBQUNEO0FBQ0Q7QUFDQSxVQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFTdzBCLFVBQVQsQ0FBcUIvcUIsS0FBckIsRUFBNEJnckIsT0FBNUIsRUFBcUNodUIsTUFBckMsRUFBNkM7QUFDM0MsUUFBSyxJQUFJNkMsR0FBVCxJQUFnQkcsS0FBaEIsRUFBdUI7QUFDckIsU0FBSWlyQixhQUFhanJCLE1BQU1ILEdBQU4sQ0FBakI7QUFDQSxTQUFJb3JCLFVBQUosRUFBZ0I7QUFDZCxXQUFJMTBCLE9BQU9xMEIsaUJBQWlCSyxXQUFXdlgsZ0JBQTVCLENBQVg7QUFDQSxXQUFJbmQsUUFBUSxDQUFDeUcsT0FBT3pHLElBQVAsQ0FBYixFQUEyQjtBQUN6QixhQUFJMDBCLGVBQWVELE9BQW5CLEVBQTRCO0FBQzFCRSwyQkFBZ0JELFVBQWhCO0FBQ0Q7QUFDRGpyQixlQUFNSCxHQUFOLElBQWEsSUFBYjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVNxckIsZUFBVCxDQUEwQnJXLEtBQTFCLEVBQWlDO0FBQy9CLE9BQUlBLEtBQUosRUFBVztBQUNUQSxXQUFNZixpQkFBTixDQUF3QjBILFFBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxLQUFJMlAsWUFBWTtBQUNkNTBCLFNBQU0sWUFEUTtBQUVkMGpCLGFBQVUsSUFGSTs7QUFJZDlLLFVBQU87QUFDTGljLGNBQVNWLFlBREo7QUFFTFcsY0FBU1g7QUFGSixJQUpPOztBQVNkWSxZQUFTLFNBQVNBLE9BQVQsR0FBb0I7QUFDM0IsVUFBS3RyQixLQUFMLEdBQWFwRCxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNELElBWGE7O0FBYWRzc0IsY0FBVyxTQUFTQSxTQUFULEdBQXNCO0FBQy9CLFNBQUlwUyxTQUFTLElBQWI7O0FBRUEsVUFBSyxJQUFJdFosR0FBVCxJQUFnQnNaLE9BQU9uWixLQUF2QixFQUE4QjtBQUM1QmtyQix1QkFBZ0IvUixPQUFPblosS0FBUCxDQUFhSCxHQUFiLENBQWhCO0FBQ0Q7QUFDRixJQW5CYTs7QUFxQmQ4SCxVQUFPO0FBQ0x5akIsY0FBUyxTQUFTQSxPQUFULENBQWtCbHRCLEdBQWxCLEVBQXVCO0FBQzlCNnNCLGtCQUFXLEtBQUsvcUIsS0FBaEIsRUFBdUIsS0FBS2liLE1BQTVCLEVBQW9DLFVBQVUxa0IsSUFBVixFQUFnQjtBQUFFLGdCQUFPczBCLFFBQVEzc0IsR0FBUixFQUFhM0gsSUFBYixDQUFQO0FBQTRCLFFBQWxGO0FBQ0QsTUFISTtBQUlMODBCLGNBQVMsU0FBU0EsT0FBVCxDQUFrQm50QixHQUFsQixFQUF1QjtBQUM5QjZzQixrQkFBVyxLQUFLL3FCLEtBQWhCLEVBQXVCLEtBQUtpYixNQUE1QixFQUFvQyxVQUFVMWtCLElBQVYsRUFBZ0I7QUFBRSxnQkFBTyxDQUFDczBCLFFBQVEzc0IsR0FBUixFQUFhM0gsSUFBYixDQUFSO0FBQTZCLFFBQW5GO0FBQ0Q7QUFOSSxJQXJCTzs7QUE4QmQyYyxXQUFRLFNBQVNBLE1BQVQsR0FBbUI7QUFDekIsU0FBSTJCLFFBQVF1RCx1QkFBdUIsS0FBSzJFLE1BQUwsQ0FBWTFMLE9BQW5DLENBQVo7QUFDQSxTQUFJcUMsbUJBQW1CbUIsU0FBU0EsTUFBTW5CLGdCQUF0QztBQUNBLFNBQUlBLGdCQUFKLEVBQXNCO0FBQ3BCO0FBQ0EsV0FBSW5kLE9BQU9xMEIsaUJBQWlCbFgsZ0JBQWpCLENBQVg7QUFDQSxXQUFJbmQsU0FDRCxLQUFLNjBCLE9BQUwsSUFBZ0IsQ0FBQ1AsUUFBUSxLQUFLTyxPQUFiLEVBQXNCNzBCLElBQXRCLENBQWxCLElBQ0MsS0FBSzgwQixPQUFMLElBQWdCUixRQUFRLEtBQUtRLE9BQWIsRUFBc0I5MEIsSUFBdEIsQ0FGZixDQUFKLEVBR0c7QUFDRCxnQkFBT3NlLEtBQVA7QUFDRDtBQUNELFdBQUloVixNQUFNZ1YsTUFBTWhWLEdBQU4sSUFBYTtBQUNyQjtBQUNBO0FBRlEsU0FHTjZULGlCQUFpQnBMLElBQWpCLENBQXNCdWIsR0FBdEIsSUFBNkJuUSxpQkFBaUJyQixHQUFqQixHQUF3QixPQUFRcUIsaUJBQWlCckIsR0FBakQsR0FBeUQsRUFBdEYsQ0FITSxHQUlOd0MsTUFBTWhWLEdBSlY7QUFLQSxXQUFJLEtBQUtHLEtBQUwsQ0FBV0gsR0FBWCxDQUFKLEVBQXFCO0FBQ25CZ1YsZUFBTWYsaUJBQU4sR0FBMEIsS0FBSzlULEtBQUwsQ0FBV0gsR0FBWCxFQUFnQmlVLGlCQUExQztBQUNELFFBRkQsTUFFTztBQUNMLGNBQUs5VCxLQUFMLENBQVdILEdBQVgsSUFBa0JnVixLQUFsQjtBQUNEO0FBQ0RBLGFBQU10WixJQUFOLENBQVc2bkIsU0FBWCxHQUF1QixJQUF2QjtBQUNEO0FBQ0QsWUFBT3ZPLEtBQVA7QUFDRDtBQXZEYSxFQUFoQjs7QUEwREEsS0FBSTJXLG9CQUFvQjtBQUN0QkwsY0FBV0E7QUFEVyxFQUF4Qjs7QUFJQTs7QUFFQSxVQUFTTSxhQUFULENBQXdCeFMsR0FBeEIsRUFBNkI7QUFDM0I7QUFDQSxPQUFJeVMsWUFBWSxFQUFoQjtBQUNBQSxhQUFVNWpCLEdBQVYsR0FBZ0IsWUFBWTtBQUFFLFlBQU81RSxNQUFQO0FBQWdCLElBQTlDO0FBQ0EsT0FBSUksUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDa29CLGVBQVV6aEIsR0FBVixHQUFnQixZQUFZO0FBQzFCN0UsWUFDRSxzRUFERjtBQUdELE1BSkQ7QUFLRDtBQUNEeEksVUFBT2dJLGNBQVAsQ0FBc0JxVSxHQUF0QixFQUEyQixRQUEzQixFQUFxQ3lTLFNBQXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBelMsT0FBSTBTLElBQUosR0FBVztBQUNUdm1CLFdBQU1BLElBREc7QUFFVC9ELGFBQVFBLE1BRkM7QUFHVDRPLG1CQUFjQSxZQUhMO0FBSVQyYixxQkFBZ0JqZjtBQUpQLElBQVg7O0FBT0FzTSxPQUFJaFAsR0FBSixHQUFVQSxHQUFWO0FBQ0FnUCxPQUFJNFMsTUFBSixHQUFhaGUsR0FBYjtBQUNBb0wsT0FBSXRRLFFBQUosR0FBZUEsUUFBZjs7QUFFQXNRLE9BQUlsVCxPQUFKLEdBQWNuSixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBZDtBQUNBK0QsZUFBWWxHLE9BQVosQ0FBb0IsVUFBVW9TLElBQVYsRUFBZ0I7QUFDbEMrSixTQUFJbFQsT0FBSixDQUFZbUosT0FBTyxHQUFuQixJQUEwQnRTLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUExQjtBQUNELElBRkQ7O0FBSUE7QUFDQTtBQUNBZ2EsT0FBSWxULE9BQUosQ0FBWTZkLEtBQVosR0FBb0IzSyxHQUFwQjs7QUFFQTVYLFVBQU80WCxJQUFJbFQsT0FBSixDQUFZMEosVUFBbkIsRUFBK0IrYixpQkFBL0I7O0FBRUFqQyxXQUFRdFEsR0FBUjtBQUNBNFEsZUFBWTVRLEdBQVo7QUFDQThRLGNBQVc5USxHQUFYO0FBQ0F3UixzQkFBbUJ4UixHQUFuQjtBQUNEOztBQUVEd1MsZUFBY25DLEtBQWQ7O0FBRUExc0IsUUFBT2dJLGNBQVAsQ0FBc0Iwa0IsTUFBTWowQixTQUE1QixFQUF1QyxXQUF2QyxFQUFvRDtBQUNsRHlTLFFBQUtHO0FBRDZDLEVBQXBEOztBQUlBckwsUUFBT2dJLGNBQVAsQ0FBc0Iwa0IsTUFBTWowQixTQUE1QixFQUF1QyxhQUF2QyxFQUFzRDtBQUNwRHlTLFFBQUssU0FBU0EsR0FBVCxHQUFnQjtBQUNuQjtBQUNBLFlBQU8sS0FBS3lULE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVl1USxVQUFsQztBQUNEO0FBSm1ELEVBQXREOztBQU9BeEMsT0FBTXlDLE9BQU4sR0FBZ0IsT0FBaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUkvbkIsaUJBQWlCbkYsUUFBUSxhQUFSLENBQXJCOztBQUVBO0FBQ0EsS0FBSW10QixjQUFjbnRCLFFBQVEsOEJBQVIsQ0FBbEI7QUFDQSxLQUFJdUYsY0FBYyxTQUFkQSxXQUFjLENBQVVpTyxHQUFWLEVBQWVuRCxJQUFmLEVBQXFCK2MsSUFBckIsRUFBMkI7QUFDM0MsVUFDR0EsU0FBUyxPQUFULElBQW9CRCxZQUFZM1osR0FBWixDQUFyQixJQUEwQ25ELFNBQVMsUUFBbkQsSUFDQytjLFNBQVMsVUFBVCxJQUF1QjVaLFFBQVEsUUFEaEMsSUFFQzRaLFNBQVMsU0FBVCxJQUFzQjVaLFFBQVEsT0FGL0IsSUFHQzRaLFNBQVMsT0FBVCxJQUFvQjVaLFFBQVEsT0FKL0I7QUFNRCxFQVBEOztBQVNBLEtBQUk2WixtQkFBbUJydEIsUUFBUSxzQ0FBUixDQUF2Qjs7QUFFQSxLQUFJc3RCLGdCQUFnQnR0QixRQUNsQiwrRUFDQSxxRUFEQSxHQUVBLGtGQUZBLEdBR0EsNEVBSEEsR0FJQSxnRUFKQSxHQUtBLGlDQU5rQixDQUFwQjs7QUFTQSxLQUFJdXRCLFVBQVUsOEJBQWQ7O0FBRUEsS0FBSUMsVUFBVSxTQUFWQSxPQUFVLENBQVU5MUIsSUFBVixFQUFnQjtBQUM1QixVQUFPQSxLQUFLa0ssTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBbkIsSUFBMEJsSyxLQUFLcUIsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFkLE1BQXFCLE9BQXREO0FBQ0QsRUFGRDs7QUFJQSxLQUFJMDBCLGVBQWUsU0FBZkEsWUFBZSxDQUFVLzFCLElBQVYsRUFBZ0I7QUFDakMsVUFBTzgxQixRQUFROTFCLElBQVIsSUFBZ0JBLEtBQUtxQixLQUFMLENBQVcsQ0FBWCxFQUFjckIsS0FBS04sTUFBbkIsQ0FBaEIsR0FBNkMsRUFBcEQ7QUFDRCxFQUZEOztBQUlBLEtBQUlzMkIsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBVXJ1QixHQUFWLEVBQWU7QUFDcEMsVUFBT0EsT0FBTyxJQUFQLElBQWVBLFFBQVEsS0FBOUI7QUFDRCxFQUZEOztBQUlBOztBQUVBLFVBQVNzdUIsZ0JBQVQsQ0FBMkIzWCxLQUEzQixFQUFrQztBQUNoQyxPQUFJdFosT0FBT3NaLE1BQU10WixJQUFqQjtBQUNBLE9BQUlreEIsYUFBYTVYLEtBQWpCO0FBQ0EsT0FBSTZYLFlBQVk3WCxLQUFoQjtBQUNBLFVBQU90WCxNQUFNbXZCLFVBQVU1WSxpQkFBaEIsQ0FBUCxFQUEyQztBQUN6QzRZLGlCQUFZQSxVQUFVNVksaUJBQVYsQ0FBNEJtSCxNQUF4QztBQUNBLFNBQUl5UixVQUFVbnhCLElBQWQsRUFBb0I7QUFDbEJBLGNBQU9veEIsZUFBZUQsVUFBVW54QixJQUF6QixFQUErQkEsSUFBL0IsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxVQUFPZ0MsTUFBTWt2QixhQUFhQSxXQUFXeGUsTUFBOUIsQ0FBUCxFQUE4QztBQUM1QyxTQUFJd2UsV0FBV2x4QixJQUFmLEVBQXFCO0FBQ25CQSxjQUFPb3hCLGVBQWVweEIsSUFBZixFQUFxQmt4QixXQUFXbHhCLElBQWhDLENBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBT3F4QixZQUFZcnhCLEtBQUtzeEIsV0FBakIsRUFBOEJ0eEIsS0FBS3V4QixLQUFuQyxDQUFQO0FBQ0Q7O0FBRUQsVUFBU0gsY0FBVCxDQUF5QnplLEtBQXpCLEVBQWdDRCxNQUFoQyxFQUF3QztBQUN0QyxVQUFPO0FBQ0w0ZSxrQkFBYTdxQixPQUFPa00sTUFBTTJlLFdBQWIsRUFBMEI1ZSxPQUFPNGUsV0FBakMsQ0FEUjtBQUVMQyxZQUFPdnZCLE1BQU0yUSxNQUFNNGUsS0FBWixJQUNILENBQUM1ZSxNQUFNNGUsS0FBUCxFQUFjN2UsT0FBTzZlLEtBQXJCLENBREcsR0FFSDdlLE9BQU82ZTtBQUpOLElBQVA7QUFNRDs7QUFFRCxVQUFTRixXQUFULENBQ0VDLFdBREYsRUFFRUUsWUFGRixFQUdFO0FBQ0EsT0FBSXh2QixNQUFNc3ZCLFdBQU4sS0FBc0J0dkIsTUFBTXd2QixZQUFOLENBQTFCLEVBQStDO0FBQzdDLFlBQU8vcUIsT0FBTzZxQixXQUFQLEVBQW9CRyxlQUFlRCxZQUFmLENBQXBCLENBQVA7QUFDRDtBQUNEO0FBQ0EsVUFBTyxFQUFQO0FBQ0Q7O0FBRUQsVUFBUy9xQixNQUFULENBQWlCbEIsQ0FBakIsRUFBb0JXLENBQXBCLEVBQXVCO0FBQ3JCLFVBQU9YLElBQUlXLElBQUtYLElBQUksR0FBSixHQUFVVyxDQUFmLEdBQW9CWCxDQUF4QixHQUE2QlcsS0FBSyxFQUF6QztBQUNEOztBQUVELFVBQVN1ckIsY0FBVCxDQUF5QnJ2QixLQUF6QixFQUFnQztBQUM5QixPQUFJeUQsTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixZQUFPc3ZCLGVBQWV0dkIsS0FBZixDQUFQO0FBQ0Q7QUFDRCxPQUFJQyxTQUFTRCxLQUFULENBQUosRUFBcUI7QUFDbkIsWUFBT3V2QixnQkFBZ0J2dkIsS0FBaEIsQ0FBUDtBQUNEO0FBQ0QsT0FBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFlBQU9BLEtBQVA7QUFDRDtBQUNEO0FBQ0EsVUFBTyxFQUFQO0FBQ0Q7O0FBRUQsVUFBU3N2QixjQUFULENBQXlCdHZCLEtBQXpCLEVBQWdDO0FBQzlCLE9BQUk3QyxNQUFNLEVBQVY7QUFDQSxPQUFJcXlCLFdBQUo7QUFDQSxRQUFLLElBQUluM0IsSUFBSSxDQUFSLEVBQVcrSyxJQUFJcEQsTUFBTTFILE1BQTFCLEVBQWtDRCxJQUFJK0ssQ0FBdEMsRUFBeUMvSyxHQUF6QyxFQUE4QztBQUM1QyxTQUFJdUgsTUFBTTR2QixjQUFjSCxlQUFlcnZCLE1BQU0zSCxDQUFOLENBQWYsQ0FBcEIsS0FBaURtM0IsZ0JBQWdCLEVBQXJFLEVBQXlFO0FBQ3ZFLFdBQUlyeUIsR0FBSixFQUFTO0FBQUVBLGdCQUFPLEdBQVA7QUFBYTtBQUN4QkEsY0FBT3F5QixXQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQU9yeUIsR0FBUDtBQUNEOztBQUVELFVBQVNveUIsZUFBVCxDQUEwQnZ2QixLQUExQixFQUFpQztBQUMvQixPQUFJN0MsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJK0UsR0FBVCxJQUFnQmxDLEtBQWhCLEVBQXVCO0FBQ3JCLFNBQUlBLE1BQU1rQyxHQUFOLENBQUosRUFBZ0I7QUFDZCxXQUFJL0UsR0FBSixFQUFTO0FBQUVBLGdCQUFPLEdBQVA7QUFBYTtBQUN4QkEsY0FBTytFLEdBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBTy9FLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxLQUFJc3lCLGVBQWU7QUFDakJDLFFBQUssNEJBRFk7QUFFakJDLFNBQU07QUFGVyxFQUFuQjs7QUFLQSxLQUFJQyxZQUFZMXVCLFFBQ2QsK0NBQ0EsMkVBREEsR0FFQSxvRUFGQSxHQUdBLHdFQUhBLEdBSUEsNkVBSkEsR0FLQSwyREFMQSxHQU1BLGtEQU5BLEdBT0EseUVBUEEsR0FRQSxrQ0FSQSxHQVNBLHVDQVRBLEdBVUEseURBWGMsQ0FBaEI7O0FBY0E7QUFDQTtBQUNBLEtBQUkydUIsUUFBUTN1QixRQUNWLDJFQUNBLDBFQURBLEdBRUEsa0VBSFUsRUFJVixJQUpVLENBQVo7O0FBT0EsS0FBSTR1QixXQUFXLFNBQVhBLFFBQVcsQ0FBVXBiLEdBQVYsRUFBZTtBQUFFLFVBQU9BLFFBQVEsS0FBZjtBQUF1QixFQUF2RDs7QUFFQSxLQUFJdE8sZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFVc08sR0FBVixFQUFlO0FBQ2pDLFVBQU9rYixVQUFVbGIsR0FBVixLQUFrQm1iLE1BQU1uYixHQUFOLENBQXpCO0FBQ0QsRUFGRDs7QUFJQSxVQUFTbk8sZUFBVCxDQUEwQm1PLEdBQTFCLEVBQStCO0FBQzdCLE9BQUltYixNQUFNbmIsR0FBTixDQUFKLEVBQWdCO0FBQ2QsWUFBTyxLQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsT0FBSUEsUUFBUSxNQUFaLEVBQW9CO0FBQ2xCLFlBQU8sTUFBUDtBQUNEO0FBQ0Y7O0FBRUQsS0FBSXFiLHNCQUFzQjl3QixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBMUI7QUFDQSxVQUFTZ0YsZ0JBQVQsQ0FBMkJvTyxHQUEzQixFQUFnQztBQUM5QjtBQUNBLE9BQUksQ0FBQ3RMLFNBQUwsRUFBZ0I7QUFDZCxZQUFPLElBQVA7QUFDRDtBQUNELE9BQUloRCxjQUFjc08sR0FBZCxDQUFKLEVBQXdCO0FBQ3RCLFlBQU8sS0FBUDtBQUNEO0FBQ0RBLFNBQU1BLElBQUlqVCxXQUFKLEVBQU47QUFDQTtBQUNBLE9BQUlzdUIsb0JBQW9CcmIsR0FBcEIsS0FBNEIsSUFBaEMsRUFBc0M7QUFDcEMsWUFBT3FiLG9CQUFvQnJiLEdBQXBCLENBQVA7QUFDRDtBQUNELE9BQUl0RSxLQUFLM1csU0FBU3VyQixhQUFULENBQXVCdFEsR0FBdkIsQ0FBVDtBQUNBLE9BQUlBLElBQUkzYSxPQUFKLENBQVksR0FBWixJQUFtQixDQUFDLENBQXhCLEVBQTJCO0FBQ3pCO0FBQ0EsWUFBUWcyQixvQkFBb0JyYixHQUFwQixJQUNOdEUsR0FBR3BILFdBQUgsS0FBbUIxUCxPQUFPMDJCLGtCQUExQixJQUNBNWYsR0FBR3BILFdBQUgsS0FBbUIxUCxPQUFPMjJCLFdBRjVCO0FBSUQsSUFORCxNQU1PO0FBQ0wsWUFBUUYsb0JBQW9CcmIsR0FBcEIsSUFBMkIscUJBQXFCbk4sSUFBckIsQ0FBMEI2SSxHQUFHalEsUUFBSCxFQUExQixDQUFuQztBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7OztBQUdBLFVBQVN0RCxLQUFULENBQWdCdVQsRUFBaEIsRUFBb0I7QUFDbEIsT0FBSSxPQUFPQSxFQUFQLEtBQWMsUUFBbEIsRUFBNEI7QUFDMUIsU0FBSThmLFdBQVd6MkIsU0FBUzAyQixhQUFULENBQXVCL2YsRUFBdkIsQ0FBZjtBQUNBLFNBQUksQ0FBQzhmLFFBQUwsRUFBZTtBQUNidnFCLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLDBCQUEwQjJJLEVBRGEsQ0FBekM7QUFHQSxjQUFPM1csU0FBU3VyQixhQUFULENBQXVCLEtBQXZCLENBQVA7QUFDRDtBQUNELFlBQU9rTCxRQUFQO0FBQ0QsSUFURCxNQVNPO0FBQ0wsWUFBTzlmLEVBQVA7QUFDRDtBQUNGOztBQUVEOztBQUVBLFVBQVNnZ0IsZUFBVCxDQUEwQkMsT0FBMUIsRUFBbUNuWixLQUFuQyxFQUEwQztBQUN4QyxPQUFJckIsTUFBTXBjLFNBQVN1ckIsYUFBVCxDQUF1QnFMLE9BQXZCLENBQVY7QUFDQSxPQUFJQSxZQUFZLFFBQWhCLEVBQTBCO0FBQ3hCLFlBQU94YSxHQUFQO0FBQ0Q7QUFDRDtBQUNBLE9BQUlxQixNQUFNdFosSUFBTixJQUFjc1osTUFBTXRaLElBQU4sQ0FBVzhhLEtBQXpCLElBQWtDeEIsTUFBTXRaLElBQU4sQ0FBVzhhLEtBQVgsQ0FBaUI0WCxRQUFqQixLQUE4QnI0QixTQUFwRSxFQUErRTtBQUM3RTRkLFNBQUkwYSxZQUFKLENBQWlCLFVBQWpCLEVBQTZCLFVBQTdCO0FBQ0Q7QUFDRCxVQUFPMWEsR0FBUDtBQUNEOztBQUVELFVBQVMyYSxlQUFULENBQTBCQyxTQUExQixFQUFxQ0osT0FBckMsRUFBOEM7QUFDNUMsVUFBTzUyQixTQUFTKzJCLGVBQVQsQ0FBeUJmLGFBQWFnQixTQUFiLENBQXpCLEVBQWtESixPQUFsRCxDQUFQO0FBQ0Q7O0FBRUQsVUFBU3ZrQixjQUFULENBQXlCOEosSUFBekIsRUFBK0I7QUFDN0IsVUFBT25jLFNBQVNxUyxjQUFULENBQXdCOEosSUFBeEIsQ0FBUDtBQUNEOztBQUVELFVBQVM4YSxhQUFULENBQXdCOWEsSUFBeEIsRUFBOEI7QUFDNUIsVUFBT25jLFNBQVNpM0IsYUFBVCxDQUF1QjlhLElBQXZCLENBQVA7QUFDRDs7QUFFRCxVQUFTK2EsWUFBVCxDQUF1QjdCLFVBQXZCLEVBQW1DOEIsT0FBbkMsRUFBNENDLGFBQTVDLEVBQTJEO0FBQ3pEL0IsY0FBVzZCLFlBQVgsQ0FBd0JDLE9BQXhCLEVBQWlDQyxhQUFqQztBQUNEOztBQUVELFVBQVNDLFdBQVQsQ0FBc0IvWixJQUF0QixFQUE0QnhHLEtBQTVCLEVBQW1DO0FBQ2pDd0csUUFBSytaLFdBQUwsQ0FBaUJ2Z0IsS0FBakI7QUFDRDs7QUFFRCxVQUFTd2dCLFdBQVQsQ0FBc0JoYSxJQUF0QixFQUE0QnhHLEtBQTVCLEVBQW1DO0FBQ2pDd0csUUFBS2dhLFdBQUwsQ0FBaUJ4Z0IsS0FBakI7QUFDRDs7QUFFRCxVQUFTdWUsVUFBVCxDQUFxQi9YLElBQXJCLEVBQTJCO0FBQ3pCLFVBQU9BLEtBQUsrWCxVQUFaO0FBQ0Q7O0FBRUQsVUFBU2tDLFdBQVQsQ0FBc0JqYSxJQUF0QixFQUE0QjtBQUMxQixVQUFPQSxLQUFLaWEsV0FBWjtBQUNEOztBQUVELFVBQVNYLE9BQVQsQ0FBa0J0WixJQUFsQixFQUF3QjtBQUN0QixVQUFPQSxLQUFLc1osT0FBWjtBQUNEOztBQUVELFVBQVNZLGNBQVQsQ0FBeUJsYSxJQUF6QixFQUErQm5CLElBQS9CLEVBQXFDO0FBQ25DbUIsUUFBS21hLFdBQUwsR0FBbUJ0YixJQUFuQjtBQUNEOztBQUVELFVBQVMyYSxZQUFULENBQXVCeFosSUFBdkIsRUFBNkI3VSxHQUE3QixFQUFrQzNCLEdBQWxDLEVBQXVDO0FBQ3JDd1csUUFBS3daLFlBQUwsQ0FBa0JydUIsR0FBbEIsRUFBdUIzQixHQUF2QjtBQUNEOztBQUdELEtBQUk0d0IsVUFBVWx5QixPQUFPMkgsTUFBUCxDQUFjO0FBQzNCb2Usa0JBQWVvTCxlQURZO0FBRTNCSSxvQkFBaUJBLGVBRlU7QUFHM0Ixa0IsbUJBQWdCQSxjQUhXO0FBSTNCNGtCLGtCQUFlQSxhQUpZO0FBSzNCQyxpQkFBY0EsWUFMYTtBQU0zQkcsZ0JBQWFBLFdBTmM7QUFPM0JDLGdCQUFhQSxXQVBjO0FBUTNCakMsZUFBWUEsVUFSZTtBQVMzQmtDLGdCQUFhQSxXQVRjO0FBVTNCWCxZQUFTQSxPQVZrQjtBQVczQlksbUJBQWdCQSxjQVhXO0FBWTNCVixpQkFBY0E7QUFaYSxFQUFkLENBQWQ7O0FBZUE7O0FBRUEsS0FBSTlHLE1BQU07QUFDUm5vQixXQUFRLFNBQVNBLE1BQVQsQ0FBaUJxQixDQUFqQixFQUFvQnVVLEtBQXBCLEVBQTJCO0FBQ2pDa2EsaUJBQVlsYSxLQUFaO0FBQ0QsSUFITztBQUlSOUosV0FBUSxTQUFTQSxNQUFULENBQWlCd1ksUUFBakIsRUFBMkIxTyxLQUEzQixFQUFrQztBQUN4QyxTQUFJME8sU0FBU2hvQixJQUFULENBQWM2ckIsR0FBZCxLQUFzQnZTLE1BQU10WixJQUFOLENBQVc2ckIsR0FBckMsRUFBMEM7QUFDeEMySCxtQkFBWXhMLFFBQVosRUFBc0IsSUFBdEI7QUFDQXdMLG1CQUFZbGEsS0FBWjtBQUNEO0FBQ0YsSUFUTztBQVVSNE8sWUFBUyxTQUFTQSxPQUFULENBQWtCNU8sS0FBbEIsRUFBeUI7QUFDaENrYSxpQkFBWWxhLEtBQVosRUFBbUIsSUFBbkI7QUFDRDtBQVpPLEVBQVY7O0FBZUEsVUFBU2thLFdBQVQsQ0FBc0JsYSxLQUF0QixFQUE2Qm1hLFNBQTdCLEVBQXdDO0FBQ3RDLE9BQUludkIsTUFBTWdWLE1BQU10WixJQUFOLENBQVc2ckIsR0FBckI7QUFDQSxPQUFJLENBQUN2bkIsR0FBTCxFQUFVO0FBQUU7QUFBUTs7QUFFcEIsT0FBSThGLEtBQUtrUCxNQUFNcEIsT0FBZjtBQUNBLE9BQUkyVCxNQUFNdlMsTUFBTWYsaUJBQU4sSUFBMkJlLE1BQU1yQixHQUEzQztBQUNBLE9BQUl5YixPQUFPdHBCLEdBQUd3VSxLQUFkO0FBQ0EsT0FBSTZVLFNBQUosRUFBZTtBQUNiLFNBQUk1dEIsTUFBTW1CLE9BQU4sQ0FBYzBzQixLQUFLcHZCLEdBQUwsQ0FBZCxDQUFKLEVBQThCO0FBQzVCTixjQUFPMHZCLEtBQUtwdkIsR0FBTCxDQUFQLEVBQWtCdW5CLEdBQWxCO0FBQ0QsTUFGRCxNQUVPLElBQUk2SCxLQUFLcHZCLEdBQUwsTUFBY3VuQixHQUFsQixFQUF1QjtBQUM1QjZILFlBQUtwdkIsR0FBTCxJQUFZakssU0FBWjtBQUNEO0FBQ0YsSUFORCxNQU1PO0FBQ0wsU0FBSWlmLE1BQU10WixJQUFOLENBQVcyekIsUUFBZixFQUF5QjtBQUN2QixXQUFJLENBQUM5dEIsTUFBTW1CLE9BQU4sQ0FBYzBzQixLQUFLcHZCLEdBQUwsQ0FBZCxDQUFMLEVBQStCO0FBQzdCb3ZCLGNBQUtwdkIsR0FBTCxJQUFZLENBQUN1bkIsR0FBRCxDQUFaO0FBQ0QsUUFGRCxNQUVPLElBQUk2SCxLQUFLcHZCLEdBQUwsRUFBVW5JLE9BQVYsQ0FBa0IwdkIsR0FBbEIsSUFBeUIsQ0FBN0IsRUFBZ0M7QUFDckM7QUFDQTZILGNBQUtwdkIsR0FBTCxFQUFVK0csSUFBVixDQUFld2dCLEdBQWY7QUFDRDtBQUNGLE1BUEQsTUFPTztBQUNMNkgsWUFBS3B2QixHQUFMLElBQVl1bkIsR0FBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxLQUFJK0gsWUFBWSxJQUFJOWIsS0FBSixDQUFVLEVBQVYsRUFBYyxFQUFkLEVBQWtCLEVBQWxCLENBQWhCOztBQUVBLEtBQUkrYixRQUFRLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsUUFBdkIsRUFBaUMsUUFBakMsRUFBMkMsU0FBM0MsQ0FBWjs7QUFFQSxVQUFTQyxTQUFULENBQW9CdnVCLENBQXBCLEVBQXVCVyxDQUF2QixFQUEwQjtBQUN4QixVQUNFWCxFQUFFakIsR0FBRixLQUFVNEIsRUFBRTVCLEdBQVosS0FFSWlCLEVBQUV1UixHQUFGLEtBQVU1USxFQUFFNFEsR0FBWixJQUNBdlIsRUFBRW9ULFNBQUYsS0FBZ0J6UyxFQUFFeVMsU0FEbEIsSUFFQTNXLE1BQU11RCxFQUFFdkYsSUFBUixNQUFrQmdDLE1BQU1rRSxFQUFFbEcsSUFBUixDQUZsQixJQUdBK3pCLGNBQWN4dUIsQ0FBZCxFQUFpQlcsQ0FBakIsQ0FKRixJQU1FakUsT0FBT3NELEVBQUV3VCxrQkFBVCxLQUNBeFQsRUFBRTZTLFlBQUYsS0FBbUJsUyxFQUFFa1MsWUFEckIsSUFFQXRXLFFBQVFvRSxFQUFFa1MsWUFBRixDQUFlN1gsS0FBdkIsQ0FUSixDQURGO0FBY0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQVN3ekIsYUFBVCxDQUF3Qnh1QixDQUF4QixFQUEyQlcsQ0FBM0IsRUFBOEI7QUFDNUIsT0FBSVgsRUFBRXVSLEdBQUYsS0FBVSxPQUFkLEVBQXVCO0FBQUUsWUFBTyxJQUFQO0FBQWE7QUFDdEMsT0FBSXJjLENBQUo7QUFDQSxPQUFJdTVCLFFBQVFoeUIsTUFBTXZILElBQUk4SyxFQUFFdkYsSUFBWixLQUFxQmdDLE1BQU12SCxJQUFJQSxFQUFFcWdCLEtBQVosQ0FBckIsSUFBMkNyZ0IsRUFBRWtaLElBQXpEO0FBQ0EsT0FBSXNnQixRQUFRanlCLE1BQU12SCxJQUFJeUwsRUFBRWxHLElBQVosS0FBcUJnQyxNQUFNdkgsSUFBSUEsRUFBRXFnQixLQUFaLENBQXJCLElBQTJDcmdCLEVBQUVrWixJQUF6RDtBQUNBLFVBQU9xZ0IsVUFBVUMsS0FBakI7QUFDRDs7QUFFRCxVQUFTQyxpQkFBVCxDQUE0Qm5jLFFBQTVCLEVBQXNDb2MsUUFBdEMsRUFBZ0RDLE1BQWhELEVBQXdEO0FBQ3RELE9BQUkzNUIsQ0FBSixFQUFPNkosR0FBUDtBQUNBLE9BQUliLE1BQU0sRUFBVjtBQUNBLFFBQUtoSixJQUFJMDVCLFFBQVQsRUFBbUIxNUIsS0FBSzI1QixNQUF4QixFQUFnQyxFQUFFMzVCLENBQWxDLEVBQXFDO0FBQ25DNkosV0FBTXlULFNBQVN0ZCxDQUFULEVBQVk2SixHQUFsQjtBQUNBLFNBQUl0QyxNQUFNc0MsR0FBTixDQUFKLEVBQWdCO0FBQUViLFdBQUlhLEdBQUosSUFBVzdKLENBQVg7QUFBZTtBQUNsQztBQUNELFVBQU9nSixHQUFQO0FBQ0Q7O0FBRUQsVUFBUzR3QixtQkFBVCxDQUE4QkMsT0FBOUIsRUFBdUM7QUFDckMsT0FBSTc1QixDQUFKLEVBQU9vbkIsQ0FBUDtBQUNBLE9BQUkvRCxNQUFNLEVBQVY7O0FBRUEsT0FBSXhYLFVBQVVndUIsUUFBUWh1QixPQUF0QjtBQUNBLE9BQUlpdEIsVUFBVWUsUUFBUWYsT0FBdEI7O0FBRUEsUUFBSzk0QixJQUFJLENBQVQsRUFBWUEsSUFBSW81QixNQUFNbjVCLE1BQXRCLEVBQThCLEVBQUVELENBQWhDLEVBQW1DO0FBQ2pDcWpCLFNBQUkrVixNQUFNcDVCLENBQU4sQ0FBSixJQUFnQixFQUFoQjtBQUNBLFVBQUtvbkIsSUFBSSxDQUFULEVBQVlBLElBQUl2YixRQUFRNUwsTUFBeEIsRUFBZ0MsRUFBRW1uQixDQUFsQyxFQUFxQztBQUNuQyxXQUFJN2YsTUFBTXNFLFFBQVF1YixDQUFSLEVBQVdnUyxNQUFNcDVCLENBQU4sQ0FBWCxDQUFOLENBQUosRUFBaUM7QUFDL0JxakIsYUFBSStWLE1BQU1wNUIsQ0FBTixDQUFKLEVBQWM0USxJQUFkLENBQW1CL0UsUUFBUXViLENBQVIsRUFBV2dTLE1BQU1wNUIsQ0FBTixDQUFYLENBQW5CO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFlBQVM4NUIsV0FBVCxDQUFzQnRjLEdBQXRCLEVBQTJCO0FBQ3pCLFlBQU8sSUFBSUgsS0FBSixDQUFVeWIsUUFBUWQsT0FBUixDQUFnQnhhLEdBQWhCLEVBQXFCcFUsV0FBckIsRUFBVixFQUE4QyxFQUE5QyxFQUFrRCxFQUFsRCxFQUFzRHhKLFNBQXRELEVBQWlFNGQsR0FBakUsQ0FBUDtBQUNEOztBQUVELFlBQVN1YyxVQUFULENBQXFCQyxRQUFyQixFQUErQnhYLFNBQS9CLEVBQTBDO0FBQ3hDLGNBQVM1QyxTQUFULEdBQXNCO0FBQ3BCLFdBQUksRUFBRUEsVUFBVTRDLFNBQVosS0FBMEIsQ0FBOUIsRUFBaUM7QUFDL0J5WCxvQkFBV0QsUUFBWDtBQUNEO0FBQ0Y7QUFDRHBhLGVBQVU0QyxTQUFWLEdBQXNCQSxTQUF0QjtBQUNBLFlBQU81QyxTQUFQO0FBQ0Q7O0FBRUQsWUFBU3FhLFVBQVQsQ0FBcUJsaUIsRUFBckIsRUFBeUI7QUFDdkIsU0FBSUUsU0FBUzZnQixRQUFRckMsVUFBUixDQUFtQjFlLEVBQW5CLENBQWI7QUFDQTtBQUNBLFNBQUl4USxNQUFNMFEsTUFBTixDQUFKLEVBQW1CO0FBQ2pCNmdCLGVBQVFMLFdBQVIsQ0FBb0J4Z0IsTUFBcEIsRUFBNEJGLEVBQTVCO0FBQ0Q7QUFDRjs7QUFFRCxPQUFJbWlCLFFBQVEsQ0FBWjtBQUNBLFlBQVNDLFNBQVQsQ0FBb0J0YixLQUFwQixFQUEyQnViLGtCQUEzQixFQUErQ3BOLFNBQS9DLEVBQTBEQyxNQUExRCxFQUFrRW9OLE1BQWxFLEVBQTBFO0FBQ3hFeGIsV0FBTVosWUFBTixHQUFxQixDQUFDb2MsTUFBdEIsQ0FEd0UsQ0FDMUM7QUFDOUIsU0FBSTFNLGdCQUFnQjlPLEtBQWhCLEVBQXVCdWIsa0JBQXZCLEVBQTJDcE4sU0FBM0MsRUFBc0RDLE1BQXRELENBQUosRUFBbUU7QUFDakU7QUFDRDs7QUFFRCxTQUFJMW5CLE9BQU9zWixNQUFNdFosSUFBakI7QUFDQSxTQUFJK1gsV0FBV3VCLE1BQU12QixRQUFyQjtBQUNBLFNBQUlqQixNQUFNd0MsTUFBTXhDLEdBQWhCO0FBQ0EsU0FBSTlVLE1BQU04VSxHQUFOLENBQUosRUFBZ0I7QUFDZCxXQUFJL08sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGFBQUlqSSxRQUFRQSxLQUFLKzBCLEdBQWpCLEVBQXNCO0FBQ3BCSjtBQUNEO0FBQ0QsYUFDRSxDQUFDQSxLQUFELElBQ0EsQ0FBQ3JiLE1BQU1qQixFQURQLElBRUEsRUFBRTFRLE9BQU9XLGVBQVAsQ0FBdUI1TixNQUF2QixJQUFpQ2lOLE9BQU9XLGVBQVAsQ0FBdUJuTSxPQUF2QixDQUErQjJhLEdBQS9CLElBQXNDLENBQUMsQ0FBMUUsQ0FGQSxJQUdBblAsT0FBT2UsZ0JBQVAsQ0FBd0JvTyxHQUF4QixDQUpGLEVBS0U7QUFDQWpOLGdCQUNFLDhCQUE4QmlOLEdBQTlCLEdBQW9DLGNBQXBDLEdBQ0EsOERBREEsR0FFQSx5Q0FIRixFQUlFd0MsTUFBTXBCLE9BSlI7QUFNRDtBQUNGO0FBQ0RvQixhQUFNckIsR0FBTixHQUFZcUIsTUFBTWpCLEVBQU4sR0FDUmtiLFFBQVFYLGVBQVIsQ0FBd0J0WixNQUFNakIsRUFBOUIsRUFBa0N2QixHQUFsQyxDQURRLEdBRVJ5YyxRQUFRbk0sYUFBUixDQUFzQnRRLEdBQXRCLEVBQTJCd0MsS0FBM0IsQ0FGSjtBQUdBMGIsZ0JBQVMxYixLQUFUOztBQUVBO0FBQ0E7QUFDRTJiLHdCQUFlM2IsS0FBZixFQUFzQnZCLFFBQXRCLEVBQWdDOGMsa0JBQWhDO0FBQ0EsYUFBSTd5QixNQUFNaEMsSUFBTixDQUFKLEVBQWlCO0FBQ2ZrMUIsNkJBQWtCNWIsS0FBbEIsRUFBeUJ1YixrQkFBekI7QUFDRDtBQUNENU0sZ0JBQU9SLFNBQVAsRUFBa0JuTyxNQUFNckIsR0FBeEIsRUFBNkJ5UCxNQUE3QjtBQUNEOztBQUVELFdBQUkzZixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNqSSxJQUF6QyxJQUFpREEsS0FBSyswQixHQUExRCxFQUErRDtBQUM3REo7QUFDRDtBQUNGLE1BcENELE1Bb0NPLElBQUkxeUIsT0FBT3FYLE1BQU1YLFNBQWIsQ0FBSixFQUE2QjtBQUNsQ1csYUFBTXJCLEdBQU4sR0FBWXNiLFFBQVFULGFBQVIsQ0FBc0J4WixNQUFNdEIsSUFBNUIsQ0FBWjtBQUNBaVEsY0FBT1IsU0FBUCxFQUFrQm5PLE1BQU1yQixHQUF4QixFQUE2QnlQLE1BQTdCO0FBQ0QsTUFITSxNQUdBO0FBQ0xwTyxhQUFNckIsR0FBTixHQUFZc2IsUUFBUXJsQixjQUFSLENBQXVCb0wsTUFBTXRCLElBQTdCLENBQVo7QUFDQWlRLGNBQU9SLFNBQVAsRUFBa0JuTyxNQUFNckIsR0FBeEIsRUFBNkJ5UCxNQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsWUFBU1UsZUFBVCxDQUEwQjlPLEtBQTFCLEVBQWlDdWIsa0JBQWpDLEVBQXFEcE4sU0FBckQsRUFBZ0VDLE1BQWhFLEVBQXdFO0FBQ3RFLFNBQUlqdEIsSUFBSTZlLE1BQU10WixJQUFkO0FBQ0EsU0FBSWdDLE1BQU12SCxDQUFOLENBQUosRUFBYztBQUNaLFdBQUkwNkIsZ0JBQWdCbnpCLE1BQU1zWCxNQUFNZixpQkFBWixLQUFrQzlkLEVBQUVvdEIsU0FBeEQ7QUFDQSxXQUFJN2xCLE1BQU12SCxJQUFJQSxFQUFFZ1osSUFBWixLQUFxQnpSLE1BQU12SCxJQUFJQSxFQUFFK3NCLElBQVosQ0FBekIsRUFBNEM7QUFDMUMvc0IsV0FBRTZlLEtBQUYsRUFBUyxLQUFULENBQWUsZUFBZixFQUFnQ21PLFNBQWhDLEVBQTJDQyxNQUEzQztBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFJMWxCLE1BQU1zWCxNQUFNZixpQkFBWixDQUFKLEVBQW9DO0FBQ2xDNmMsdUJBQWM5YixLQUFkLEVBQXFCdWIsa0JBQXJCO0FBQ0EsYUFBSTV5QixPQUFPa3pCLGFBQVAsQ0FBSixFQUEyQjtBQUN6QkUsK0JBQW9CL2IsS0FBcEIsRUFBMkJ1YixrQkFBM0IsRUFBK0NwTixTQUEvQyxFQUEwREMsTUFBMUQ7QUFDRDtBQUNELGdCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBUzBOLGFBQVQsQ0FBd0I5YixLQUF4QixFQUErQnViLGtCQUEvQixFQUFtRDtBQUNqRCxTQUFJN3lCLE1BQU1zWCxNQUFNdFosSUFBTixDQUFXczFCLGFBQWpCLENBQUosRUFBcUM7QUFDbkNULDBCQUFtQnhwQixJQUFuQixDQUF3QnBSLEtBQXhCLENBQThCNDZCLGtCQUE5QixFQUFrRHZiLE1BQU10WixJQUFOLENBQVdzMUIsYUFBN0Q7QUFDQWhjLGFBQU10WixJQUFOLENBQVdzMUIsYUFBWCxHQUEyQixJQUEzQjtBQUNEO0FBQ0RoYyxXQUFNckIsR0FBTixHQUFZcUIsTUFBTWYsaUJBQU4sQ0FBd0JpSCxHQUFwQztBQUNBLFNBQUkrVixZQUFZamMsS0FBWixDQUFKLEVBQXdCO0FBQ3RCNGIseUJBQWtCNWIsS0FBbEIsRUFBeUJ1YixrQkFBekI7QUFDQUcsZ0JBQVMxYixLQUFUO0FBQ0QsTUFIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBa2EsbUJBQVlsYSxLQUFaO0FBQ0E7QUFDQXViLDBCQUFtQnhwQixJQUFuQixDQUF3QmlPLEtBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTK2IsbUJBQVQsQ0FBOEIvYixLQUE5QixFQUFxQ3ViLGtCQUFyQyxFQUF5RHBOLFNBQXpELEVBQW9FQyxNQUFwRSxFQUE0RTtBQUMxRSxTQUFJanRCLENBQUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUkrNkIsWUFBWWxjLEtBQWhCO0FBQ0EsWUFBT2tjLFVBQVVqZCxpQkFBakIsRUFBb0M7QUFDbENpZCxtQkFBWUEsVUFBVWpkLGlCQUFWLENBQTRCbUgsTUFBeEM7QUFDQSxXQUFJMWQsTUFBTXZILElBQUkrNkIsVUFBVXgxQixJQUFwQixLQUE2QmdDLE1BQU12SCxJQUFJQSxFQUFFZzdCLFVBQVosQ0FBakMsRUFBMEQ7QUFDeEQsY0FBS2g3QixJQUFJLENBQVQsRUFBWUEsSUFBSXFqQixJQUFJNFgsUUFBSixDQUFhaDdCLE1BQTdCLEVBQXFDLEVBQUVELENBQXZDLEVBQTBDO0FBQ3hDcWpCLGVBQUk0WCxRQUFKLENBQWFqN0IsQ0FBYixFQUFnQm01QixTQUFoQixFQUEyQjRCLFNBQTNCO0FBQ0Q7QUFDRFgsNEJBQW1CeHBCLElBQW5CLENBQXdCbXFCLFNBQXhCO0FBQ0E7QUFDRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBdk4sWUFBT1IsU0FBUCxFQUFrQm5PLE1BQU1yQixHQUF4QixFQUE2QnlQLE1BQTdCO0FBQ0Q7O0FBRUQsWUFBU08sTUFBVCxDQUFpQnZWLE1BQWpCLEVBQXlCdUYsR0FBekIsRUFBOEIwZCxNQUE5QixFQUFzQztBQUNwQyxTQUFJM3pCLE1BQU0wUSxNQUFOLENBQUosRUFBbUI7QUFDakIsV0FBSTFRLE1BQU0yekIsTUFBTixDQUFKLEVBQW1CO0FBQ2pCLGFBQUlBLE9BQU96RSxVQUFQLEtBQXNCeGUsTUFBMUIsRUFBa0M7QUFDaEM2Z0IsbUJBQVFSLFlBQVIsQ0FBcUJyZ0IsTUFBckIsRUFBNkJ1RixHQUE3QixFQUFrQzBkLE1BQWxDO0FBQ0Q7QUFDRixRQUpELE1BSU87QUFDTHBDLGlCQUFRSixXQUFSLENBQW9CemdCLE1BQXBCLEVBQTRCdUYsR0FBNUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBU2dkLGNBQVQsQ0FBeUIzYixLQUF6QixFQUFnQ3ZCLFFBQWhDLEVBQTBDOGMsa0JBQTFDLEVBQThEO0FBQzVELFNBQUlodkIsTUFBTW1CLE9BQU4sQ0FBYytRLFFBQWQsQ0FBSixFQUE2QjtBQUMzQixZQUFLLElBQUl0ZCxJQUFJLENBQWIsRUFBZ0JBLElBQUlzZCxTQUFTcmQsTUFBN0IsRUFBcUMsRUFBRUQsQ0FBdkMsRUFBMEM7QUFDeENtNkIsbUJBQVU3YyxTQUFTdGQsQ0FBVCxDQUFWLEVBQXVCbzZCLGtCQUF2QixFQUEyQ3ZiLE1BQU1yQixHQUFqRCxFQUFzRCxJQUF0RCxFQUE0RCxJQUE1RDtBQUNEO0FBQ0YsTUFKRCxNQUlPLElBQUk5VixZQUFZbVgsTUFBTXRCLElBQWxCLENBQUosRUFBNkI7QUFDbEN1YixlQUFRSixXQUFSLENBQW9CN1osTUFBTXJCLEdBQTFCLEVBQStCc2IsUUFBUXJsQixjQUFSLENBQXVCb0wsTUFBTXRCLElBQTdCLENBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTdWQsV0FBVCxDQUFzQmpjLEtBQXRCLEVBQTZCO0FBQzNCLFlBQU9BLE1BQU1mLGlCQUFiLEVBQWdDO0FBQzlCZSxlQUFRQSxNQUFNZixpQkFBTixDQUF3Qm1ILE1BQWhDO0FBQ0Q7QUFDRCxZQUFPMWQsTUFBTXNYLE1BQU14QyxHQUFaLENBQVA7QUFDRDs7QUFFRCxZQUFTb2UsaUJBQVQsQ0FBNEI1YixLQUE1QixFQUFtQ3ViLGtCQUFuQyxFQUF1RDtBQUNyRCxVQUFLLElBQUloWCxNQUFNLENBQWYsRUFBa0JBLE1BQU1DLElBQUlwYSxNQUFKLENBQVdoSixNQUFuQyxFQUEyQyxFQUFFbWpCLEdBQTdDLEVBQWtEO0FBQ2hEQyxXQUFJcGEsTUFBSixDQUFXbWEsR0FBWCxFQUFnQitWLFNBQWhCLEVBQTJCdGEsS0FBM0I7QUFDRDtBQUNEN2UsU0FBSTZlLE1BQU10WixJQUFOLENBQVd5VCxJQUFmLENBSnFELENBSWhDO0FBQ3JCLFNBQUl6UixNQUFNdkgsQ0FBTixDQUFKLEVBQWM7QUFDWixXQUFJdUgsTUFBTXZILEVBQUVpSixNQUFSLENBQUosRUFBcUI7QUFBRWpKLFdBQUVpSixNQUFGLENBQVNrd0IsU0FBVCxFQUFvQnRhLEtBQXBCO0FBQTZCO0FBQ3BELFdBQUl0WCxNQUFNdkgsRUFBRXd0QixNQUFSLENBQUosRUFBcUI7QUFBRTRNLDRCQUFtQnhwQixJQUFuQixDQUF3QmlPLEtBQXhCO0FBQWlDO0FBQ3pEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBUzBiLFFBQVQsQ0FBbUIxYixLQUFuQixFQUEwQjtBQUN4QixTQUFJN2UsQ0FBSjtBQUNBLFNBQUltN0IsV0FBV3RjLEtBQWY7QUFDQSxZQUFPc2MsUUFBUCxFQUFpQjtBQUNmLFdBQUk1ekIsTUFBTXZILElBQUltN0IsU0FBUzFkLE9BQW5CLEtBQStCbFcsTUFBTXZILElBQUlBLEVBQUVpUSxRQUFGLENBQVdtckIsUUFBckIsQ0FBbkMsRUFBbUU7QUFDakV0QyxpQkFBUVosWUFBUixDQUFxQnJaLE1BQU1yQixHQUEzQixFQUFnQ3hkLENBQWhDLEVBQW1DLEVBQW5DO0FBQ0Q7QUFDRG03QixrQkFBV0EsU0FBU2xqQixNQUFwQjtBQUNEO0FBQ0Q7QUFDQSxTQUFJMVEsTUFBTXZILElBQUk4akIsY0FBVixLQUNGOWpCLE1BQU02ZSxNQUFNcEIsT0FEVixJQUVGbFcsTUFBTXZILElBQUlBLEVBQUVpUSxRQUFGLENBQVdtckIsUUFBckIsQ0FGRixFQUdFO0FBQ0F0QyxlQUFRWixZQUFSLENBQXFCclosTUFBTXJCLEdBQTNCLEVBQWdDeGQsQ0FBaEMsRUFBbUMsRUFBbkM7QUFDRDtBQUNGOztBQUVELFlBQVNxN0IsU0FBVCxDQUFvQnJPLFNBQXBCLEVBQStCQyxNQUEvQixFQUF1Q2pPLE1BQXZDLEVBQStDc2MsUUFBL0MsRUFBeUQzQixNQUF6RCxFQUFpRVMsa0JBQWpFLEVBQXFGO0FBQ25GLFlBQU9rQixZQUFZM0IsTUFBbkIsRUFBMkIsRUFBRTJCLFFBQTdCLEVBQXVDO0FBQ3JDbkIsaUJBQVVuYixPQUFPc2MsUUFBUCxDQUFWLEVBQTRCbEIsa0JBQTVCLEVBQWdEcE4sU0FBaEQsRUFBMkRDLE1BQTNEO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTc08saUJBQVQsQ0FBNEIxYyxLQUE1QixFQUFtQztBQUNqQyxTQUFJN2UsQ0FBSixFQUFPb25CLENBQVA7QUFDQSxTQUFJN2hCLE9BQU9zWixNQUFNdFosSUFBakI7QUFDQSxTQUFJZ0MsTUFBTWhDLElBQU4sQ0FBSixFQUFpQjtBQUNmLFdBQUlnQyxNQUFNdkgsSUFBSXVGLEtBQUt5VCxJQUFmLEtBQXdCelIsTUFBTXZILElBQUlBLEVBQUV5dEIsT0FBWixDQUE1QixFQUFrRDtBQUFFenRCLFdBQUU2ZSxLQUFGO0FBQVc7QUFDL0QsWUFBSzdlLElBQUksQ0FBVCxFQUFZQSxJQUFJcWpCLElBQUlvSyxPQUFKLENBQVl4dEIsTUFBNUIsRUFBb0MsRUFBRUQsQ0FBdEMsRUFBeUM7QUFBRXFqQixhQUFJb0ssT0FBSixDQUFZenRCLENBQVosRUFBZTZlLEtBQWY7QUFBd0I7QUFDcEU7QUFDRCxTQUFJdFgsTUFBTXZILElBQUk2ZSxNQUFNdkIsUUFBaEIsQ0FBSixFQUErQjtBQUM3QixZQUFLOEosSUFBSSxDQUFULEVBQVlBLElBQUl2SSxNQUFNdkIsUUFBTixDQUFlcmQsTUFBL0IsRUFBdUMsRUFBRW1uQixDQUF6QyxFQUE0QztBQUMxQ21VLDJCQUFrQjFjLE1BQU12QixRQUFOLENBQWU4SixDQUFmLENBQWxCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFlBQVNvVSxZQUFULENBQXVCeE8sU0FBdkIsRUFBa0NoTyxNQUFsQyxFQUEwQ3NjLFFBQTFDLEVBQW9EM0IsTUFBcEQsRUFBNEQ7QUFDMUQsWUFBTzJCLFlBQVkzQixNQUFuQixFQUEyQixFQUFFMkIsUUFBN0IsRUFBdUM7QUFDckMsV0FBSUcsS0FBS3pjLE9BQU9zYyxRQUFQLENBQVQ7QUFDQSxXQUFJL3pCLE1BQU1rMEIsRUFBTixDQUFKLEVBQWU7QUFDYixhQUFJbDBCLE1BQU1rMEIsR0FBR3BmLEdBQVQsQ0FBSixFQUFtQjtBQUNqQnFmLHFDQUEwQkQsRUFBMUI7QUFDQUYsNkJBQWtCRSxFQUFsQjtBQUNELFVBSEQsTUFHTztBQUFFO0FBQ1B4QixzQkFBV3dCLEdBQUdqZSxHQUFkO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsWUFBU2tlLHlCQUFULENBQW9DN2MsS0FBcEMsRUFBMkM4YyxFQUEzQyxFQUErQztBQUM3QyxTQUFJcDBCLE1BQU1vMEIsRUFBTixLQUFhcDBCLE1BQU1zWCxNQUFNdFosSUFBWixDQUFqQixFQUFvQztBQUNsQyxXQUFJdkYsQ0FBSjtBQUNBLFdBQUl3aUIsWUFBWWEsSUFBSTlaLE1BQUosQ0FBV3RKLE1BQVgsR0FBb0IsQ0FBcEM7QUFDQSxXQUFJc0gsTUFBTW8wQixFQUFOLENBQUosRUFBZTtBQUNiO0FBQ0E7QUFDQUEsWUFBR25aLFNBQUgsSUFBZ0JBLFNBQWhCO0FBQ0QsUUFKRCxNQUlPO0FBQ0w7QUFDQW1aLGNBQUs1QixXQUFXbGIsTUFBTXJCLEdBQWpCLEVBQXNCZ0YsU0FBdEIsQ0FBTDtBQUNEO0FBQ0Q7QUFDQSxXQUFJamIsTUFBTXZILElBQUk2ZSxNQUFNZixpQkFBaEIsS0FBc0N2VyxNQUFNdkgsSUFBSUEsRUFBRWlsQixNQUFaLENBQXRDLElBQTZEMWQsTUFBTXZILEVBQUV1RixJQUFSLENBQWpFLEVBQWdGO0FBQzlFbTJCLG1DQUEwQjE3QixDQUExQixFQUE2QjI3QixFQUE3QjtBQUNEO0FBQ0QsWUFBSzM3QixJQUFJLENBQVQsRUFBWUEsSUFBSXFqQixJQUFJOVosTUFBSixDQUFXdEosTUFBM0IsRUFBbUMsRUFBRUQsQ0FBckMsRUFBd0M7QUFDdENxakIsYUFBSTlaLE1BQUosQ0FBV3ZKLENBQVgsRUFBYzZlLEtBQWQsRUFBcUI4YyxFQUFyQjtBQUNEO0FBQ0QsV0FBSXAwQixNQUFNdkgsSUFBSTZlLE1BQU10WixJQUFOLENBQVd5VCxJQUFyQixLQUE4QnpSLE1BQU12SCxJQUFJQSxFQUFFdUosTUFBWixDQUFsQyxFQUF1RDtBQUNyRHZKLFdBQUU2ZSxLQUFGLEVBQVM4YyxFQUFUO0FBQ0QsUUFGRCxNQUVPO0FBQ0xBO0FBQ0Q7QUFDRixNQXZCRCxNQXVCTztBQUNMMUIsa0JBQVdwYixNQUFNckIsR0FBakI7QUFDRDtBQUNGOztBQUVELFlBQVNvZSxjQUFULENBQXlCNU8sU0FBekIsRUFBb0M2TyxLQUFwQyxFQUEyQ0MsS0FBM0MsRUFBa0QxQixrQkFBbEQsRUFBc0UyQixVQUF0RSxFQUFrRjtBQUNoRixTQUFJQyxjQUFjLENBQWxCO0FBQ0EsU0FBSUMsY0FBYyxDQUFsQjtBQUNBLFNBQUlDLFlBQVlMLE1BQU01N0IsTUFBTixHQUFlLENBQS9CO0FBQ0EsU0FBSWs4QixnQkFBZ0JOLE1BQU0sQ0FBTixDQUFwQjtBQUNBLFNBQUlPLGNBQWNQLE1BQU1LLFNBQU4sQ0FBbEI7QUFDQSxTQUFJRyxZQUFZUCxNQUFNNzdCLE1BQU4sR0FBZSxDQUEvQjtBQUNBLFNBQUlxOEIsZ0JBQWdCUixNQUFNLENBQU4sQ0FBcEI7QUFDQSxTQUFJUyxjQUFjVCxNQUFNTyxTQUFOLENBQWxCO0FBQ0EsU0FBSUcsV0FBSixFQUFpQkMsUUFBakIsRUFBMkJDLFNBQTNCLEVBQXNDelAsTUFBdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBSTBQLFVBQVUsQ0FBQ1osVUFBZjs7QUFFQSxZQUFPQyxlQUFlRSxTQUFmLElBQTRCRCxlQUFlSSxTQUFsRCxFQUE2RDtBQUMzRCxXQUFJaDFCLFFBQVE4MEIsYUFBUixDQUFKLEVBQTRCO0FBQzFCQSx5QkFBZ0JOLE1BQU0sRUFBRUcsV0FBUixDQUFoQixDQUQwQixDQUNZO0FBQ3ZDLFFBRkQsTUFFTyxJQUFJMzBCLFFBQVErMEIsV0FBUixDQUFKLEVBQTBCO0FBQy9CQSx1QkFBY1AsTUFBTSxFQUFFSyxTQUFSLENBQWQ7QUFDRCxRQUZNLE1BRUEsSUFBSTdDLFVBQVU4QyxhQUFWLEVBQXlCRyxhQUF6QixDQUFKLEVBQTZDO0FBQ2xETSxvQkFBV1QsYUFBWCxFQUEwQkcsYUFBMUIsRUFBeUNsQyxrQkFBekM7QUFDQStCLHlCQUFnQk4sTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0FNLHlCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsUUFKTSxNQUlBLElBQUk1QyxVQUFVK0MsV0FBVixFQUF1QkcsV0FBdkIsQ0FBSixFQUF5QztBQUM5Q0ssb0JBQVdSLFdBQVgsRUFBd0JHLFdBQXhCLEVBQXFDbkMsa0JBQXJDO0FBQ0FnQyx1QkFBY1AsTUFBTSxFQUFFSyxTQUFSLENBQWQ7QUFDQUssdUJBQWNULE1BQU0sRUFBRU8sU0FBUixDQUFkO0FBQ0QsUUFKTSxNQUlBLElBQUloRCxVQUFVOEMsYUFBVixFQUF5QkksV0FBekIsQ0FBSixFQUEyQztBQUFFO0FBQ2xESyxvQkFBV1QsYUFBWCxFQUEwQkksV0FBMUIsRUFBdUNuQyxrQkFBdkM7QUFDQXVDLG9CQUFXN0QsUUFBUVIsWUFBUixDQUFxQnRMLFNBQXJCLEVBQWdDbVAsY0FBYzNlLEdBQTlDLEVBQW1Ec2IsUUFBUUgsV0FBUixDQUFvQnlELFlBQVk1ZSxHQUFoQyxDQUFuRCxDQUFYO0FBQ0EyZSx5QkFBZ0JOLE1BQU0sRUFBRUcsV0FBUixDQUFoQjtBQUNBTyx1QkFBY1QsTUFBTSxFQUFFTyxTQUFSLENBQWQ7QUFDRCxRQUxNLE1BS0EsSUFBSWhELFVBQVUrQyxXQUFWLEVBQXVCRSxhQUF2QixDQUFKLEVBQTJDO0FBQUU7QUFDbERNLG9CQUFXUixXQUFYLEVBQXdCRSxhQUF4QixFQUF1Q2xDLGtCQUF2QztBQUNBdUMsb0JBQVc3RCxRQUFRUixZQUFSLENBQXFCdEwsU0FBckIsRUFBZ0NvUCxZQUFZNWUsR0FBNUMsRUFBaUQyZSxjQUFjM2UsR0FBL0QsQ0FBWDtBQUNBNGUsdUJBQWNQLE1BQU0sRUFBRUssU0FBUixDQUFkO0FBQ0FJLHlCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsUUFMTSxNQUtBO0FBQ0wsYUFBSTUwQixRQUFRbTFCLFdBQVIsQ0FBSixFQUEwQjtBQUFFQSx5QkFBYy9DLGtCQUFrQm9DLEtBQWxCLEVBQXlCRyxXQUF6QixFQUFzQ0UsU0FBdEMsQ0FBZDtBQUFpRTtBQUM3Rk8sb0JBQVdsMUIsTUFBTSswQixjQUFjenlCLEdBQXBCLElBQTJCMnlCLFlBQVlGLGNBQWN6eUIsR0FBMUIsQ0FBM0IsR0FBNEQsSUFBdkU7QUFDQSxhQUFJeEMsUUFBUW8xQixRQUFSLENBQUosRUFBdUI7QUFBRTtBQUN2QnRDLHFCQUFVbUMsYUFBVixFQUF5QmxDLGtCQUF6QixFQUE2Q3BOLFNBQTdDLEVBQXdEbVAsY0FBYzNlLEdBQXRFO0FBQ0E4ZSwyQkFBZ0JSLE1BQU0sRUFBRUcsV0FBUixDQUFoQjtBQUNELFVBSEQsTUFHTztBQUNMUyx1QkFBWWIsTUFBTVksUUFBTixDQUFaO0FBQ0E7QUFDQSxlQUFJbnZCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QyxDQUFDa3ZCLFNBQTlDLEVBQXlEO0FBQ3ZEdHRCLGtCQUNFLHdFQUNBLDZDQUZGO0FBSUQ7QUFDRCxlQUFJaXFCLFVBQVVxRCxTQUFWLEVBQXFCSixhQUFyQixDQUFKLEVBQXlDO0FBQ3ZDTSx3QkFBV0YsU0FBWCxFQUFzQkosYUFBdEIsRUFBcUNsQyxrQkFBckM7QUFDQXlCLG1CQUFNWSxRQUFOLElBQWtCNzhCLFNBQWxCO0FBQ0ErOEIsd0JBQVc3RCxRQUFRUixZQUFSLENBQXFCdEwsU0FBckIsRUFBZ0MwUCxVQUFVbGYsR0FBMUMsRUFBK0MyZSxjQUFjM2UsR0FBN0QsQ0FBWDtBQUNBOGUsNkJBQWdCUixNQUFNLEVBQUVHLFdBQVIsQ0FBaEI7QUFDRCxZQUxELE1BS087QUFDTDtBQUNBOUIsdUJBQVVtQyxhQUFWLEVBQXlCbEMsa0JBQXpCLEVBQTZDcE4sU0FBN0MsRUFBd0RtUCxjQUFjM2UsR0FBdEU7QUFDQThlLDZCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxTQUFJRCxjQUFjRSxTQUFsQixFQUE2QjtBQUMzQmpQLGdCQUFTNWxCLFFBQVF5MEIsTUFBTU8sWUFBWSxDQUFsQixDQUFSLElBQWdDLElBQWhDLEdBQXVDUCxNQUFNTyxZQUFZLENBQWxCLEVBQXFCN2UsR0FBckU7QUFDQTZkLGlCQUFVck8sU0FBVixFQUFxQkMsTUFBckIsRUFBNkI2TyxLQUE3QixFQUFvQ0csV0FBcEMsRUFBaURJLFNBQWpELEVBQTREakMsa0JBQTVEO0FBQ0QsTUFIRCxNQUdPLElBQUk2QixjQUFjSSxTQUFsQixFQUE2QjtBQUNsQ2Isb0JBQWF4TyxTQUFiLEVBQXdCNk8sS0FBeEIsRUFBK0JHLFdBQS9CLEVBQTRDRSxTQUE1QztBQUNEO0FBQ0Y7O0FBRUQsWUFBU1UsVUFBVCxDQUFxQnJQLFFBQXJCLEVBQStCMU8sS0FBL0IsRUFBc0N1YixrQkFBdEMsRUFBMEQyQixVQUExRCxFQUFzRTtBQUNwRSxTQUFJeE8sYUFBYTFPLEtBQWpCLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBRUQsU0FBSXJCLE1BQU1xQixNQUFNckIsR0FBTixHQUFZK1AsU0FBUy9QLEdBQS9COztBQUVBLFNBQUloVyxPQUFPK2xCLFNBQVNqUCxrQkFBaEIsQ0FBSixFQUF5QztBQUN2QyxXQUFJL1csTUFBTXNYLE1BQU1sQixZQUFOLENBQW1COEQsUUFBekIsQ0FBSixFQUF3QztBQUN0Q29iLGlCQUFRdFAsU0FBUy9QLEdBQWpCLEVBQXNCcUIsS0FBdEIsRUFBNkJ1YixrQkFBN0I7QUFDRCxRQUZELE1BRU87QUFDTHZiLGVBQU1QLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBSTlXLE9BQU9xWCxNQUFNYixRQUFiLEtBQ0Z4VyxPQUFPK2xCLFNBQVN2UCxRQUFoQixDQURFLElBRUZhLE1BQU1oVixHQUFOLEtBQWMwakIsU0FBUzFqQixHQUZyQixLQUdEckMsT0FBT3FYLE1BQU1WLFFBQWIsS0FBMEIzVyxPQUFPcVgsTUFBTVQsTUFBYixDQUh6QixDQUFKLEVBSUU7QUFDQVMsYUFBTWYsaUJBQU4sR0FBMEJ5UCxTQUFTelAsaUJBQW5DO0FBQ0E7QUFDRDs7QUFFRCxTQUFJOWQsQ0FBSjtBQUNBLFNBQUl1RixPQUFPc1osTUFBTXRaLElBQWpCO0FBQ0EsU0FBSWdDLE1BQU1oQyxJQUFOLEtBQWVnQyxNQUFNdkgsSUFBSXVGLEtBQUt5VCxJQUFmLENBQWYsSUFBdUN6UixNQUFNdkgsSUFBSUEsRUFBRXN0QixRQUFaLENBQTNDLEVBQWtFO0FBQ2hFdHRCLFNBQUV1dEIsUUFBRixFQUFZMU8sS0FBWjtBQUNEOztBQUVELFNBQUlnZCxRQUFRdE8sU0FBU2pRLFFBQXJCO0FBQ0EsU0FBSW1lLEtBQUs1YyxNQUFNdkIsUUFBZjtBQUNBLFNBQUkvVixNQUFNaEMsSUFBTixLQUFldTFCLFlBQVlqYyxLQUFaLENBQW5CLEVBQXVDO0FBQ3JDLFlBQUs3ZSxJQUFJLENBQVQsRUFBWUEsSUFBSXFqQixJQUFJdE8sTUFBSixDQUFXOVUsTUFBM0IsRUFBbUMsRUFBRUQsQ0FBckMsRUFBd0M7QUFBRXFqQixhQUFJdE8sTUFBSixDQUFXL1UsQ0FBWCxFQUFjdXRCLFFBQWQsRUFBd0IxTyxLQUF4QjtBQUFpQztBQUMzRSxXQUFJdFgsTUFBTXZILElBQUl1RixLQUFLeVQsSUFBZixLQUF3QnpSLE1BQU12SCxJQUFJQSxFQUFFK1UsTUFBWixDQUE1QixFQUFpRDtBQUFFL1UsV0FBRXV0QixRQUFGLEVBQVkxTyxLQUFaO0FBQXFCO0FBQ3pFO0FBQ0QsU0FBSXhYLFFBQVF3WCxNQUFNdEIsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFdBQUloVyxNQUFNczBCLEtBQU4sS0FBZ0J0MEIsTUFBTWswQixFQUFOLENBQXBCLEVBQStCO0FBQzdCLGFBQUlJLFVBQVVKLEVBQWQsRUFBa0I7QUFBRUcsMEJBQWVwZSxHQUFmLEVBQW9CcWUsS0FBcEIsRUFBMkJKLEVBQTNCLEVBQStCckIsa0JBQS9CLEVBQW1EMkIsVUFBbkQ7QUFBaUU7QUFDdEYsUUFGRCxNQUVPLElBQUl4MEIsTUFBTWswQixFQUFOLENBQUosRUFBZTtBQUNwQixhQUFJbDBCLE1BQU1nbUIsU0FBU2hRLElBQWYsQ0FBSixFQUEwQjtBQUFFdWIsbUJBQVFGLGNBQVIsQ0FBdUJwYixHQUF2QixFQUE0QixFQUE1QjtBQUFrQztBQUM5RDZkLG1CQUFVN2QsR0FBVixFQUFlLElBQWYsRUFBcUJpZSxFQUFyQixFQUF5QixDQUF6QixFQUE0QkEsR0FBR3g3QixNQUFILEdBQVksQ0FBeEMsRUFBMkNtNkIsa0JBQTNDO0FBQ0QsUUFITSxNQUdBLElBQUk3eUIsTUFBTXMwQixLQUFOLENBQUosRUFBa0I7QUFDdkJMLHNCQUFhaGUsR0FBYixFQUFrQnFlLEtBQWxCLEVBQXlCLENBQXpCLEVBQTRCQSxNQUFNNTdCLE1BQU4sR0FBZSxDQUEzQztBQUNELFFBRk0sTUFFQSxJQUFJc0gsTUFBTWdtQixTQUFTaFEsSUFBZixDQUFKLEVBQTBCO0FBQy9CdWIsaUJBQVFGLGNBQVIsQ0FBdUJwYixHQUF2QixFQUE0QixFQUE1QjtBQUNEO0FBQ0YsTUFYRCxNQVdPLElBQUkrUCxTQUFTaFEsSUFBVCxLQUFrQnNCLE1BQU10QixJQUE1QixFQUFrQztBQUN2Q3ViLGVBQVFGLGNBQVIsQ0FBdUJwYixHQUF2QixFQUE0QnFCLE1BQU10QixJQUFsQztBQUNEO0FBQ0QsU0FBSWhXLE1BQU1oQyxJQUFOLENBQUosRUFBaUI7QUFDZixXQUFJZ0MsTUFBTXZILElBQUl1RixLQUFLeVQsSUFBZixLQUF3QnpSLE1BQU12SCxJQUFJQSxFQUFFODhCLFNBQVosQ0FBNUIsRUFBb0Q7QUFBRTk4QixXQUFFdXRCLFFBQUYsRUFBWTFPLEtBQVo7QUFBcUI7QUFDNUU7QUFDRjs7QUFFRCxZQUFTa2UsZ0JBQVQsQ0FBMkJsZSxLQUEzQixFQUFrQ3lJLEtBQWxDLEVBQXlDMFYsT0FBekMsRUFBa0Q7QUFDaEQ7QUFDQTtBQUNBLFNBQUl4MUIsT0FBT3cxQixPQUFQLEtBQW1CejFCLE1BQU1zWCxNQUFNNUcsTUFBWixDQUF2QixFQUE0QztBQUMxQzRHLGFBQU01RyxNQUFOLENBQWExUyxJQUFiLENBQWtCczFCLGFBQWxCLEdBQWtDdlQsS0FBbEM7QUFDRCxNQUZELE1BRU87QUFDTCxZQUFLLElBQUl0bkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc25CLE1BQU1ybkIsTUFBMUIsRUFBa0MsRUFBRUQsQ0FBcEMsRUFBdUM7QUFDckNzbkIsZUFBTXRuQixDQUFOLEVBQVN1RixJQUFULENBQWN5VCxJQUFkLENBQW1Cd1UsTUFBbkIsQ0FBMEJsRyxNQUFNdG5CLENBQU4sQ0FBMUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsT0FBSWk5QixTQUFTLEtBQWI7QUFDQTtBQUNBO0FBQ0EsT0FBSUMsbUJBQW1CcjBCLFFBQVEsK0NBQVIsQ0FBdkI7O0FBRUE7QUFDQSxZQUFTZzBCLE9BQVQsQ0FBa0JyZixHQUFsQixFQUF1QnFCLEtBQXZCLEVBQThCdWIsa0JBQTlCLEVBQWtEO0FBQ2hELFNBQUk1eUIsT0FBT3FYLE1BQU1YLFNBQWIsS0FBMkIzVyxNQUFNc1gsTUFBTWxCLFlBQVosQ0FBL0IsRUFBMEQ7QUFDeERrQixhQUFNckIsR0FBTixHQUFZQSxHQUFaO0FBQ0FxQixhQUFNUCxrQkFBTixHQUEyQixJQUEzQjtBQUNBLGNBQU8sSUFBUDtBQUNEO0FBQ0QsU0FBSWhSLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJLENBQUMydkIsZ0JBQWdCM2YsR0FBaEIsRUFBcUJxQixLQUFyQixDQUFMLEVBQWtDO0FBQ2hDLGdCQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0RBLFdBQU1yQixHQUFOLEdBQVlBLEdBQVo7QUFDQSxTQUFJbkIsTUFBTXdDLE1BQU14QyxHQUFoQjtBQUNBLFNBQUk5VyxPQUFPc1osTUFBTXRaLElBQWpCO0FBQ0EsU0FBSStYLFdBQVd1QixNQUFNdkIsUUFBckI7QUFDQSxTQUFJL1YsTUFBTWhDLElBQU4sQ0FBSixFQUFpQjtBQUNmLFdBQUlnQyxNQUFNdkgsSUFBSXVGLEtBQUt5VCxJQUFmLEtBQXdCelIsTUFBTXZILElBQUlBLEVBQUUrc0IsSUFBWixDQUE1QixFQUErQztBQUFFL3NCLFdBQUU2ZSxLQUFGLEVBQVMsSUFBVCxDQUFjLGVBQWQ7QUFBaUM7QUFDbEYsV0FBSXRYLE1BQU12SCxJQUFJNmUsTUFBTWYsaUJBQWhCLENBQUosRUFBd0M7QUFDdEM7QUFDQTZjLHVCQUFjOWIsS0FBZCxFQUFxQnViLGtCQUFyQjtBQUNBLGdCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBSTd5QixNQUFNOFUsR0FBTixDQUFKLEVBQWdCO0FBQ2QsV0FBSTlVLE1BQU0rVixRQUFOLENBQUosRUFBcUI7QUFDbkI7QUFDQSxhQUFJLENBQUNFLElBQUk0ZixhQUFKLEVBQUwsRUFBMEI7QUFDeEI1QywwQkFBZTNiLEtBQWYsRUFBc0J2QixRQUF0QixFQUFnQzhjLGtCQUFoQztBQUNELFVBRkQsTUFFTztBQUNMLGVBQUlpRCxnQkFBZ0IsSUFBcEI7QUFDQSxlQUFJM0csWUFBWWxaLElBQUk4ZixVQUFwQjtBQUNBLGdCQUFLLElBQUlsYSxNQUFNLENBQWYsRUFBa0JBLE1BQU05RixTQUFTcmQsTUFBakMsRUFBeUNtakIsS0FBekMsRUFBZ0Q7QUFDOUMsaUJBQUksQ0FBQ3NULFNBQUQsSUFBYyxDQUFDbUcsUUFBUW5HLFNBQVIsRUFBbUJwWixTQUFTOEYsR0FBVCxDQUFuQixFQUFrQ2dYLGtCQUFsQyxDQUFuQixFQUEwRTtBQUN4RWlELCtCQUFnQixLQUFoQjtBQUNBO0FBQ0Q7QUFDRDNHLHlCQUFZQSxVQUFVaUMsV0FBdEI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxlQUFJLENBQUMwRSxhQUFELElBQWtCM0csU0FBdEIsRUFBaUM7QUFDL0IsaUJBQUlwcEIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0YsT0FBTzdOLE9BQVAsS0FBbUIsV0FEakIsSUFFRixDQUFDczlCLE1BRkgsRUFHRTtBQUNBQSx3QkFBUyxJQUFUO0FBQ0F0OUIsdUJBQVF5UCxJQUFSLENBQWEsVUFBYixFQUF5Qm9PLEdBQXpCO0FBQ0E3ZCx1QkFBUXlQLElBQVIsQ0FBYSxxQ0FBYixFQUFvRG9PLElBQUkrZixVQUF4RCxFQUFvRWpnQixRQUFwRTtBQUNEO0FBQ0Qsb0JBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFdBQUkvVixNQUFNaEMsSUFBTixDQUFKLEVBQWlCO0FBQ2YsY0FBSyxJQUFJc0UsR0FBVCxJQUFnQnRFLElBQWhCLEVBQXNCO0FBQ3BCLGVBQUksQ0FBQzIzQixpQkFBaUJyekIsR0FBakIsQ0FBTCxFQUE0QjtBQUMxQjR3QiwrQkFBa0I1YixLQUFsQixFQUF5QnViLGtCQUF6QjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsTUF0Q0QsTUFzQ08sSUFBSTVjLElBQUlqWSxJQUFKLEtBQWFzWixNQUFNdEIsSUFBdkIsRUFBNkI7QUFDbENDLFdBQUlqWSxJQUFKLEdBQVdzWixNQUFNdEIsSUFBakI7QUFDRDtBQUNELFlBQU8sSUFBUDtBQUNEOztBQUVELFlBQVM0ZixlQUFULENBQTBCemUsSUFBMUIsRUFBZ0NHLEtBQWhDLEVBQXVDO0FBQ3JDLFNBQUl0WCxNQUFNc1gsTUFBTXhDLEdBQVosQ0FBSixFQUFzQjtBQUNwQixjQUNFd0MsTUFBTXhDLEdBQU4sQ0FBVTNhLE9BQVYsQ0FBa0IsZUFBbEIsTUFBdUMsQ0FBdkMsSUFDQW1kLE1BQU14QyxHQUFOLENBQVVqVCxXQUFWLFFBQTZCc1YsS0FBS3NaLE9BQUwsSUFBZ0J0WixLQUFLc1osT0FBTCxDQUFhNXVCLFdBQWIsRUFBN0MsQ0FGRjtBQUlELE1BTEQsTUFLTztBQUNMLGNBQU9zVixLQUFLOGUsUUFBTCxNQUFtQjNlLE1BQU1YLFNBQU4sR0FBa0IsQ0FBbEIsR0FBc0IsQ0FBekMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsVUFBTyxTQUFTdWYsS0FBVCxDQUFnQmxRLFFBQWhCLEVBQTBCMU8sS0FBMUIsRUFBaUMrRixTQUFqQyxFQUE0Q21YLFVBQTVDLEVBQXdEL08sU0FBeEQsRUFBbUVDLE1BQW5FLEVBQTJFO0FBQ2hGLFNBQUk1bEIsUUFBUXdYLEtBQVIsQ0FBSixFQUFvQjtBQUNsQixXQUFJdFgsTUFBTWdtQixRQUFOLENBQUosRUFBcUI7QUFBRWdPLDJCQUFrQmhPLFFBQWxCO0FBQThCO0FBQ3JEO0FBQ0Q7O0FBRUQsU0FBSW1RLGlCQUFpQixLQUFyQjtBQUNBLFNBQUl0RCxxQkFBcUIsRUFBekI7O0FBRUEsU0FBSS95QixRQUFRa21CLFFBQVIsQ0FBSixFQUF1QjtBQUNyQjtBQUNBbVEsd0JBQWlCLElBQWpCO0FBQ0F2RCxpQkFBVXRiLEtBQVYsRUFBaUJ1YixrQkFBakIsRUFBcUNwTixTQUFyQyxFQUFnREMsTUFBaEQ7QUFDRCxNQUpELE1BSU87QUFDTCxXQUFJMFEsZ0JBQWdCcDJCLE1BQU1nbUIsU0FBU2lRLFFBQWYsQ0FBcEI7QUFDQSxXQUFJLENBQUNHLGFBQUQsSUFBa0J0RSxVQUFVOUwsUUFBVixFQUFvQjFPLEtBQXBCLENBQXRCLEVBQWtEO0FBQ2hEO0FBQ0ErZCxvQkFBV3JQLFFBQVgsRUFBcUIxTyxLQUFyQixFQUE0QnViLGtCQUE1QixFQUFnRDJCLFVBQWhEO0FBQ0QsUUFIRCxNQUdPO0FBQ0wsYUFBSTRCLGFBQUosRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBSXBRLFNBQVNpUSxRQUFULEtBQXNCLENBQXRCLElBQTJCalEsU0FBU3FRLFlBQVQsQ0FBc0I3d0IsUUFBdEIsQ0FBL0IsRUFBZ0U7QUFDOUR3Z0Isc0JBQVNzUSxlQUFULENBQXlCOXdCLFFBQXpCO0FBQ0E2WCx5QkFBWSxJQUFaO0FBQ0Q7QUFDRCxlQUFJcGQsT0FBT29kLFNBQVAsQ0FBSixFQUF1QjtBQUNyQixpQkFBSWlZLFFBQVF0UCxRQUFSLEVBQWtCMU8sS0FBbEIsRUFBeUJ1YixrQkFBekIsQ0FBSixFQUFrRDtBQUNoRDJDLGdDQUFpQmxlLEtBQWpCLEVBQXdCdWIsa0JBQXhCLEVBQTRDLElBQTVDO0FBQ0Esc0JBQU83TSxRQUFQO0FBQ0QsY0FIRCxNQUdPLElBQUlqZ0IsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hENEIsb0JBQ0UsK0RBQ0EsOERBREEsR0FFQSwrREFGQSxHQUdBLDREQUhBLEdBSUEsMEJBTEY7QUFPRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBbWUsc0JBQVd1TSxZQUFZdk0sUUFBWixDQUFYO0FBQ0Q7QUFDRDtBQUNBLGFBQUl1USxTQUFTdlEsU0FBUy9QLEdBQXRCO0FBQ0EsYUFBSXVnQixjQUFjakYsUUFBUXJDLFVBQVIsQ0FBbUJxSCxNQUFuQixDQUFsQjtBQUNBM0QsbUJBQ0V0YixLQURGLEVBRUV1YixrQkFGRjtBQUdFO0FBQ0E7QUFDQTtBQUNBMEQsZ0JBQU9FLFFBQVAsR0FBa0IsSUFBbEIsR0FBeUJELFdBTjNCLEVBT0VqRixRQUFRSCxXQUFSLENBQW9CbUYsTUFBcEIsQ0FQRjs7QUFVQSxhQUFJdjJCLE1BQU1zWCxNQUFNNUcsTUFBWixDQUFKLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFJa2pCLFdBQVd0YyxNQUFNNUcsTUFBckI7QUFDQSxrQkFBT2tqQixRQUFQLEVBQWlCO0FBQ2ZBLHNCQUFTM2QsR0FBVCxHQUFlcUIsTUFBTXJCLEdBQXJCO0FBQ0EyZCx3QkFBV0EsU0FBU2xqQixNQUFwQjtBQUNEO0FBQ0QsZUFBSTZpQixZQUFZamMsS0FBWixDQUFKLEVBQXdCO0FBQ3RCLGtCQUFLLElBQUk3ZSxJQUFJLENBQWIsRUFBZ0JBLElBQUlxakIsSUFBSXBhLE1BQUosQ0FBV2hKLE1BQS9CLEVBQXVDLEVBQUVELENBQXpDLEVBQTRDO0FBQzFDcWpCLG1CQUFJcGEsTUFBSixDQUFXakosQ0FBWCxFQUFjbTVCLFNBQWQsRUFBeUJ0YSxNQUFNNUcsTUFBL0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBSTFRLE1BQU13MkIsV0FBTixDQUFKLEVBQXdCO0FBQ3RCdkMsd0JBQWF1QyxXQUFiLEVBQTBCLENBQUN4USxRQUFELENBQTFCLEVBQXNDLENBQXRDLEVBQXlDLENBQXpDO0FBQ0QsVUFGRCxNQUVPLElBQUlobUIsTUFBTWdtQixTQUFTbFIsR0FBZixDQUFKLEVBQXlCO0FBQzlCa2YsNkJBQWtCaE8sUUFBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUR3UCxzQkFBaUJsZSxLQUFqQixFQUF3QnViLGtCQUF4QixFQUE0Q3NELGNBQTVDO0FBQ0EsWUFBTzdlLE1BQU1yQixHQUFiO0FBQ0QsSUFuRkQ7QUFvRkQ7O0FBRUQ7O0FBRUEsS0FBSXhELGFBQWE7QUFDZi9RLFdBQVFnMUIsZ0JBRE87QUFFZmxwQixXQUFRa3BCLGdCQUZPO0FBR2Z4USxZQUFTLFNBQVN5USxnQkFBVCxDQUEyQnJmLEtBQTNCLEVBQWtDO0FBQ3pDb2Ysc0JBQWlCcGYsS0FBakIsRUFBd0JzYSxTQUF4QjtBQUNEO0FBTGMsRUFBakI7O0FBUUEsVUFBUzhFLGdCQUFULENBQTJCMVEsUUFBM0IsRUFBcUMxTyxLQUFyQyxFQUE0QztBQUMxQyxPQUFJME8sU0FBU2hvQixJQUFULENBQWN5VSxVQUFkLElBQTRCNkUsTUFBTXRaLElBQU4sQ0FBV3lVLFVBQTNDLEVBQXVEO0FBQ3JEMkssYUFBUTRJLFFBQVIsRUFBa0IxTyxLQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzhGLE9BQVQsQ0FBa0I0SSxRQUFsQixFQUE0QjFPLEtBQTVCLEVBQW1DO0FBQ2pDLE9BQUlzZixXQUFXNVEsYUFBYTRMLFNBQTVCO0FBQ0EsT0FBSWlGLFlBQVl2ZixVQUFVc2EsU0FBMUI7QUFDQSxPQUFJa0YsVUFBVUMsc0JBQXNCL1EsU0FBU2hvQixJQUFULENBQWN5VSxVQUFwQyxFQUFnRHVULFNBQVM5UCxPQUF6RCxDQUFkO0FBQ0EsT0FBSThnQixVQUFVRCxzQkFBc0J6ZixNQUFNdFosSUFBTixDQUFXeVUsVUFBakMsRUFBNkM2RSxNQUFNcEIsT0FBbkQsQ0FBZDs7QUFFQSxPQUFJK2dCLGlCQUFpQixFQUFyQjtBQUNBLE9BQUlDLG9CQUFvQixFQUF4Qjs7QUFFQSxPQUFJNTBCLEdBQUosRUFBUzYwQixNQUFULEVBQWlCQyxHQUFqQjtBQUNBLFFBQUs5MEIsR0FBTCxJQUFZMDBCLE9BQVosRUFBcUI7QUFDbkJHLGNBQVNMLFFBQVF4MEIsR0FBUixDQUFUO0FBQ0E4MEIsV0FBTUosUUFBUTEwQixHQUFSLENBQU47QUFDQSxTQUFJLENBQUM2MEIsTUFBTCxFQUFhO0FBQ1g7QUFDQUUsa0JBQVdELEdBQVgsRUFBZ0IsTUFBaEIsRUFBd0I5ZixLQUF4QixFQUErQjBPLFFBQS9CO0FBQ0EsV0FBSW9SLElBQUlqd0IsR0FBSixJQUFXaXdCLElBQUlqd0IsR0FBSixDQUFRb0gsUUFBdkIsRUFBaUM7QUFDL0Iwb0Isd0JBQWU1dEIsSUFBZixDQUFvQit0QixHQUFwQjtBQUNEO0FBQ0YsTUFORCxNQU1PO0FBQ0w7QUFDQUEsV0FBSXRWLFFBQUosR0FBZXFWLE9BQU8vMkIsS0FBdEI7QUFDQWkzQixrQkFBV0QsR0FBWCxFQUFnQixRQUFoQixFQUEwQjlmLEtBQTFCLEVBQWlDME8sUUFBakM7QUFDQSxXQUFJb1IsSUFBSWp3QixHQUFKLElBQVdpd0IsSUFBSWp3QixHQUFKLENBQVFtd0IsZ0JBQXZCLEVBQXlDO0FBQ3ZDSiwyQkFBa0I3dEIsSUFBbEIsQ0FBdUIrdEIsR0FBdkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsT0FBSUgsZUFBZXYrQixNQUFuQixFQUEyQjtBQUN6QixTQUFJNitCLGFBQWEsU0FBYkEsVUFBYSxHQUFZO0FBQzNCLFlBQUssSUFBSTkrQixJQUFJLENBQWIsRUFBZ0JBLElBQUl3K0IsZUFBZXYrQixNQUFuQyxFQUEyQ0QsR0FBM0MsRUFBZ0Q7QUFDOUM0K0Isb0JBQVdKLGVBQWV4K0IsQ0FBZixDQUFYLEVBQThCLFVBQTlCLEVBQTBDNmUsS0FBMUMsRUFBaUQwTyxRQUFqRDtBQUNEO0FBQ0YsTUFKRDtBQUtBLFNBQUk0USxRQUFKLEVBQWM7QUFDWnBlLHNCQUFlbEIsTUFBTXRaLElBQU4sQ0FBV3lULElBQVgsS0FBb0I2RixNQUFNdFosSUFBTixDQUFXeVQsSUFBWCxHQUFrQixFQUF0QyxDQUFmLEVBQTBELFFBQTFELEVBQW9FOGxCLFVBQXBFO0FBQ0QsTUFGRCxNQUVPO0FBQ0xBO0FBQ0Q7QUFDRjs7QUFFRCxPQUFJTCxrQkFBa0J4K0IsTUFBdEIsRUFBOEI7QUFDNUI4ZixvQkFBZWxCLE1BQU10WixJQUFOLENBQVd5VCxJQUFYLEtBQW9CNkYsTUFBTXRaLElBQU4sQ0FBV3lULElBQVgsR0FBa0IsRUFBdEMsQ0FBZixFQUEwRCxXQUExRCxFQUF1RSxZQUFZO0FBQ2pGLFlBQUssSUFBSWhaLElBQUksQ0FBYixFQUFnQkEsSUFBSXkrQixrQkFBa0J4K0IsTUFBdEMsRUFBOENELEdBQTlDLEVBQW1EO0FBQ2pENCtCLG9CQUFXSCxrQkFBa0J6K0IsQ0FBbEIsQ0FBWCxFQUFpQyxrQkFBakMsRUFBcUQ2ZSxLQUFyRCxFQUE0RDBPLFFBQTVEO0FBQ0Q7QUFDRixNQUpEO0FBS0Q7O0FBRUQsT0FBSSxDQUFDNFEsUUFBTCxFQUFlO0FBQ2IsVUFBS3QwQixHQUFMLElBQVl3MEIsT0FBWixFQUFxQjtBQUNuQixXQUFJLENBQUNFLFFBQVExMEIsR0FBUixDQUFMLEVBQW1CO0FBQ2pCO0FBQ0ErMEIsb0JBQVdQLFFBQVF4MEIsR0FBUixDQUFYLEVBQXlCLFFBQXpCLEVBQW1DMGpCLFFBQW5DLEVBQTZDQSxRQUE3QyxFQUF1RDZRLFNBQXZEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsS0FBSVcsaUJBQWlCbjRCLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFyQjs7QUFFQSxVQUFTcTFCLHFCQUFULENBQ0V2a0IsSUFERixFQUVFcEssRUFGRixFQUdFO0FBQ0EsT0FBSTdLLE1BQU04QixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLE9BQUksQ0FBQzhRLElBQUwsRUFBVztBQUNULFlBQU9qVixHQUFQO0FBQ0Q7QUFDRCxPQUFJOUUsQ0FBSixFQUFPMitCLEdBQVA7QUFDQSxRQUFLMytCLElBQUksQ0FBVCxFQUFZQSxJQUFJK1osS0FBSzlaLE1BQXJCLEVBQTZCRCxHQUE3QixFQUFrQztBQUNoQzIrQixXQUFNNWtCLEtBQUsvWixDQUFMLENBQU47QUFDQSxTQUFJLENBQUMyK0IsSUFBSUssU0FBVCxFQUFvQjtBQUNsQkwsV0FBSUssU0FBSixHQUFnQkQsY0FBaEI7QUFDRDtBQUNEajZCLFNBQUltNkIsY0FBY04sR0FBZCxDQUFKLElBQTBCQSxHQUExQjtBQUNBQSxTQUFJandCLEdBQUosR0FBVTZMLGFBQWE1SyxHQUFHTSxRQUFoQixFQUEwQixZQUExQixFQUF3QzB1QixJQUFJcCtCLElBQTVDLEVBQWtELElBQWxELENBQVY7QUFDRDtBQUNELFVBQU91RSxHQUFQO0FBQ0Q7O0FBRUQsVUFBU202QixhQUFULENBQXdCTixHQUF4QixFQUE2QjtBQUMzQixVQUFPQSxJQUFJTyxPQUFKLElBQWlCUCxJQUFJcCtCLElBQUwsR0FBYSxHQUFiLEdBQW9CcUcsT0FBT0MsSUFBUCxDQUFZODNCLElBQUlLLFNBQUosSUFBaUIsRUFBN0IsRUFBaUM5eUIsSUFBakMsQ0FBc0MsR0FBdEMsQ0FBM0M7QUFDRDs7QUFFRCxVQUFTMHlCLFVBQVQsQ0FBcUJELEdBQXJCLEVBQTBCM2xCLElBQTFCLEVBQWdDNkYsS0FBaEMsRUFBdUMwTyxRQUF2QyxFQUFpRDZRLFNBQWpELEVBQTREO0FBQzFELE9BQUlyMEIsS0FBSzQwQixJQUFJandCLEdBQUosSUFBV2l3QixJQUFJandCLEdBQUosQ0FBUXNLLElBQVIsQ0FBcEI7QUFDQSxPQUFJalAsRUFBSixFQUFRO0FBQ04sU0FBSTtBQUNGQSxVQUFHOFUsTUFBTXJCLEdBQVQsRUFBY21oQixHQUFkLEVBQW1COWYsS0FBbkIsRUFBMEIwTyxRQUExQixFQUFvQzZRLFNBQXBDO0FBQ0QsTUFGRCxDQUVFLE9BQU83K0IsQ0FBUCxFQUFVO0FBQ1ZzUixtQkFBWXRSLENBQVosRUFBZXNmLE1BQU1wQixPQUFyQixFQUErQixlQUFnQmtoQixJQUFJcCtCLElBQXBCLEdBQTRCLEdBQTVCLEdBQWtDeVksSUFBbEMsR0FBeUMsT0FBeEU7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsS0FBSW1tQixjQUFjLENBQ2hCL04sR0FEZ0IsRUFFaEJwWCxVQUZnQixDQUFsQjs7QUFLQTs7QUFFQSxVQUFTb2xCLFdBQVQsQ0FBc0I3UixRQUF0QixFQUFnQzFPLEtBQWhDLEVBQXVDO0FBQ3JDLE9BQUloTixPQUFPZ04sTUFBTW5CLGdCQUFqQjtBQUNBLE9BQUluVyxNQUFNc0ssSUFBTixLQUFlQSxLQUFLUyxJQUFMLENBQVV2QyxPQUFWLENBQWtCc3ZCLFlBQWxCLEtBQW1DLEtBQXRELEVBQTZEO0FBQzNEO0FBQ0Q7QUFDRCxPQUFJaDRCLFFBQVFrbUIsU0FBU2hvQixJQUFULENBQWM4YSxLQUF0QixLQUFnQ2haLFFBQVF3WCxNQUFNdFosSUFBTixDQUFXOGEsS0FBbkIsQ0FBcEMsRUFBK0Q7QUFDN0Q7QUFDRDtBQUNELE9BQUl4VyxHQUFKLEVBQVNnVyxHQUFULEVBQWNDLEdBQWQ7QUFDQSxPQUFJdEMsTUFBTXFCLE1BQU1yQixHQUFoQjtBQUNBLE9BQUk4aEIsV0FBVy9SLFNBQVNob0IsSUFBVCxDQUFjOGEsS0FBZCxJQUF1QixFQUF0QztBQUNBLE9BQUlBLFFBQVF4QixNQUFNdFosSUFBTixDQUFXOGEsS0FBWCxJQUFvQixFQUFoQztBQUNBO0FBQ0EsT0FBSTlZLE1BQU04WSxNQUFNeEssTUFBWixDQUFKLEVBQXlCO0FBQ3ZCd0ssYUFBUXhCLE1BQU10WixJQUFOLENBQVc4YSxLQUFYLEdBQW1CaFYsT0FBTyxFQUFQLEVBQVdnVixLQUFYLENBQTNCO0FBQ0Q7O0FBRUQsUUFBS3hXLEdBQUwsSUFBWXdXLEtBQVosRUFBbUI7QUFDakJSLFdBQU1RLE1BQU14VyxHQUFOLENBQU47QUFDQWlXLFdBQU13ZixTQUFTejFCLEdBQVQsQ0FBTjtBQUNBLFNBQUlpVyxRQUFRRCxHQUFaLEVBQWlCO0FBQ2YwZixlQUFRL2hCLEdBQVIsRUFBYTNULEdBQWIsRUFBa0JnVyxHQUFsQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBO0FBQ0EsT0FBSXhPLFNBQVNnUCxNQUFNMVksS0FBTixLQUFnQjIzQixTQUFTMzNCLEtBQXRDLEVBQTZDO0FBQzNDNDNCLGFBQVEvaEIsR0FBUixFQUFhLE9BQWIsRUFBc0I2QyxNQUFNMVksS0FBNUI7QUFDRDtBQUNELFFBQUtrQyxHQUFMLElBQVl5MUIsUUFBWixFQUFzQjtBQUNwQixTQUFJajRCLFFBQVFnWixNQUFNeFcsR0FBTixDQUFSLENBQUosRUFBeUI7QUFDdkIsV0FBSXdzQixRQUFReHNCLEdBQVIsQ0FBSixFQUFrQjtBQUNoQjJULGFBQUlnaUIsaUJBQUosQ0FBc0JwSixPQUF0QixFQUErQkUsYUFBYXpzQixHQUFiLENBQS9CO0FBQ0QsUUFGRCxNQUVPLElBQUksQ0FBQ3FzQixpQkFBaUJyc0IsR0FBakIsQ0FBTCxFQUE0QjtBQUNqQzJULGFBQUlxZ0IsZUFBSixDQUFvQmgwQixHQUFwQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVMwMUIsT0FBVCxDQUFrQnhuQixFQUFsQixFQUFzQmxPLEdBQXRCLEVBQTJCbEMsS0FBM0IsRUFBa0M7QUFDaEMsT0FBSXd1QixjQUFjdHNCLEdBQWQsQ0FBSixFQUF3QjtBQUN0QjtBQUNBO0FBQ0EsU0FBSTBzQixpQkFBaUI1dUIsS0FBakIsQ0FBSixFQUE2QjtBQUMzQm9RLFVBQUc4bEIsZUFBSCxDQUFtQmgwQixHQUFuQjtBQUNELE1BRkQsTUFFTztBQUNMa08sVUFBR21nQixZQUFILENBQWdCcnVCLEdBQWhCLEVBQXFCQSxHQUFyQjtBQUNEO0FBQ0YsSUFSRCxNQVFPLElBQUlxc0IsaUJBQWlCcnNCLEdBQWpCLENBQUosRUFBMkI7QUFDaENrTyxRQUFHbWdCLFlBQUgsQ0FBZ0JydUIsR0FBaEIsRUFBcUIwc0IsaUJBQWlCNXVCLEtBQWpCLEtBQTJCQSxVQUFVLE9BQXJDLEdBQStDLE9BQS9DLEdBQXlELE1BQTlFO0FBQ0QsSUFGTSxNQUVBLElBQUkwdUIsUUFBUXhzQixHQUFSLENBQUosRUFBa0I7QUFDdkIsU0FBSTBzQixpQkFBaUI1dUIsS0FBakIsQ0FBSixFQUE2QjtBQUMzQm9RLFVBQUd5bkIsaUJBQUgsQ0FBcUJwSixPQUFyQixFQUE4QkUsYUFBYXpzQixHQUFiLENBQTlCO0FBQ0QsTUFGRCxNQUVPO0FBQ0xrTyxVQUFHMG5CLGNBQUgsQ0FBa0JySixPQUFsQixFQUEyQnZzQixHQUEzQixFQUFnQ2xDLEtBQWhDO0FBQ0Q7QUFDRixJQU5NLE1BTUE7QUFDTCxTQUFJNHVCLGlCQUFpQjV1QixLQUFqQixDQUFKLEVBQTZCO0FBQzNCb1EsVUFBRzhsQixlQUFILENBQW1CaDBCLEdBQW5CO0FBQ0QsTUFGRCxNQUVPO0FBQ0xrTyxVQUFHbWdCLFlBQUgsQ0FBZ0JydUIsR0FBaEIsRUFBcUJsQyxLQUFyQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxLQUFJMFksUUFBUTtBQUNWcFgsV0FBUW0yQixXQURFO0FBRVZycUIsV0FBUXFxQjtBQUZFLEVBQVo7O0FBS0E7O0FBRUEsVUFBU00sV0FBVCxDQUFzQm5TLFFBQXRCLEVBQWdDMU8sS0FBaEMsRUFBdUM7QUFDckMsT0FBSTlHLEtBQUs4RyxNQUFNckIsR0FBZjtBQUNBLE9BQUlqWSxPQUFPc1osTUFBTXRaLElBQWpCO0FBQ0EsT0FBSW82QixVQUFVcFMsU0FBU2hvQixJQUF2QjtBQUNBLE9BQ0U4QixRQUFROUIsS0FBS3N4QixXQUFiLEtBQ0F4dkIsUUFBUTlCLEtBQUt1eEIsS0FBYixDQURBLEtBRUV6dkIsUUFBUXM0QixPQUFSLEtBQ0V0NEIsUUFBUXM0QixRQUFROUksV0FBaEIsS0FDQXh2QixRQUFRczRCLFFBQVE3SSxLQUFoQixDQUpKLENBREYsRUFRRTtBQUNBO0FBQ0Q7O0FBRUQsT0FBSThJLE1BQU1wSixpQkFBaUIzWCxLQUFqQixDQUFWOztBQUVBO0FBQ0EsT0FBSWdoQixrQkFBa0I5bkIsR0FBRytuQixrQkFBekI7QUFDQSxPQUFJdjRCLE1BQU1zNEIsZUFBTixDQUFKLEVBQTRCO0FBQzFCRCxXQUFNNXpCLE9BQU80ekIsR0FBUCxFQUFZNUksZUFBZTZJLGVBQWYsQ0FBWixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFJRCxRQUFRN25CLEdBQUdnb0IsVUFBZixFQUEyQjtBQUN6QmhvQixRQUFHbWdCLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIwSCxHQUF6QjtBQUNBN25CLFFBQUdnb0IsVUFBSCxHQUFnQkgsR0FBaEI7QUFDRDtBQUNGOztBQUVELEtBQUlJLFFBQVE7QUFDVi8yQixXQUFReTJCLFdBREU7QUFFVjNxQixXQUFRMnFCO0FBRkUsRUFBWjs7QUFLQTs7QUFFQSxLQUFJTyxzQkFBc0IsZUFBMUI7O0FBRUEsVUFBU0MsWUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFDMUIsT0FBSUMsV0FBVyxLQUFmO0FBQ0EsT0FBSUMsV0FBVyxLQUFmO0FBQ0EsT0FBSUMsbUJBQW1CLEtBQXZCO0FBQ0EsT0FBSUMsVUFBVSxLQUFkO0FBQ0EsT0FBSUMsUUFBUSxDQUFaO0FBQ0EsT0FBSUMsU0FBUyxDQUFiO0FBQ0EsT0FBSUMsUUFBUSxDQUFaO0FBQ0EsT0FBSUMsa0JBQWtCLENBQXRCO0FBQ0EsT0FBSXAyQixDQUFKLEVBQU9xMkIsSUFBUCxFQUFhNWdDLENBQWIsRUFBZ0Jpb0IsVUFBaEIsRUFBNEI0WSxPQUE1Qjs7QUFFQSxRQUFLN2dDLElBQUksQ0FBVCxFQUFZQSxJQUFJbWdDLElBQUlsZ0MsTUFBcEIsRUFBNEJELEdBQTVCLEVBQWlDO0FBQy9CNGdDLFlBQU9yMkIsQ0FBUDtBQUNBQSxTQUFJNDFCLElBQUkxeEIsVUFBSixDQUFlek8sQ0FBZixDQUFKO0FBQ0EsU0FBSW9nQyxRQUFKLEVBQWM7QUFDWixXQUFJNzFCLE1BQU0sSUFBTixJQUFjcTJCLFNBQVMsSUFBM0IsRUFBaUM7QUFBRVIsb0JBQVcsS0FBWDtBQUFtQjtBQUN2RCxNQUZELE1BRU8sSUFBSUMsUUFBSixFQUFjO0FBQ25CLFdBQUk5MUIsTUFBTSxJQUFOLElBQWNxMkIsU0FBUyxJQUEzQixFQUFpQztBQUFFUCxvQkFBVyxLQUFYO0FBQW1CO0FBQ3ZELE1BRk0sTUFFQSxJQUFJQyxnQkFBSixFQUFzQjtBQUMzQixXQUFJLzFCLE1BQU0sSUFBTixJQUFjcTJCLFNBQVMsSUFBM0IsRUFBaUM7QUFBRU4sNEJBQW1CLEtBQW5CO0FBQTJCO0FBQy9ELE1BRk0sTUFFQSxJQUFJQyxPQUFKLEVBQWE7QUFDbEIsV0FBSWgyQixNQUFNLElBQU4sSUFBY3EyQixTQUFTLElBQTNCLEVBQWlDO0FBQUVMLG1CQUFVLEtBQVY7QUFBa0I7QUFDdEQsTUFGTSxNQUVBLElBQ0xoMkIsTUFBTSxJQUFOLElBQWM7QUFDZDQxQixTQUFJMXhCLFVBQUosQ0FBZXpPLElBQUksQ0FBbkIsTUFBMEIsSUFEMUIsSUFFQW1nQyxJQUFJMXhCLFVBQUosQ0FBZXpPLElBQUksQ0FBbkIsTUFBMEIsSUFGMUIsSUFHQSxDQUFDd2dDLEtBSEQsSUFHVSxDQUFDQyxNQUhYLElBR3FCLENBQUNDLEtBSmpCLEVBS0w7QUFDQSxXQUFJelksZUFBZXJvQixTQUFuQixFQUE4QjtBQUM1QjtBQUNBK2dDLDJCQUFrQjNnQyxJQUFJLENBQXRCO0FBQ0Fpb0Isc0JBQWFrWSxJQUFJditCLEtBQUosQ0FBVSxDQUFWLEVBQWE1QixDQUFiLEVBQWdCOGdDLElBQWhCLEVBQWI7QUFDRCxRQUpELE1BSU87QUFDTEM7QUFDRDtBQUNGLE1BYk0sTUFhQTtBQUNMLGVBQVF4MkIsQ0FBUjtBQUNFLGNBQUssSUFBTDtBQUFXODFCLHNCQUFXLElBQVgsQ0FBaUIsTUFEOUIsQ0FDNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdELHNCQUFXLElBQVgsQ0FBaUIsTUFGOUIsQ0FFNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdFLDhCQUFtQixJQUFuQixDQUF5QixNQUh0QyxDQUc0QztBQUMxQyxjQUFLLElBQUw7QUFBV0ksbUJBQVMsTUFKdEIsQ0FJNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdBLG1CQUFTLE1BTHRCLENBSzRDO0FBQzFDLGNBQUssSUFBTDtBQUFXRCxvQkFBVSxNQU52QixDQU00QztBQUMxQyxjQUFLLElBQUw7QUFBV0Esb0JBQVUsTUFQdkIsQ0FPNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdELG1CQUFTLE1BUnRCLENBUTRDO0FBQzFDLGNBQUssSUFBTDtBQUFXQSxtQkFBUyxNQVR0QixDQVM0QztBQVQ1QztBQVdBLFdBQUlqMkIsTUFBTSxJQUFWLEVBQWdCO0FBQUU7QUFDaEIsYUFBSTZjLElBQUlwbkIsSUFBSSxDQUFaO0FBQ0EsYUFBSWtULElBQUssS0FBSyxDQUFkO0FBQ0E7QUFDQSxnQkFBT2tVLEtBQUssQ0FBWixFQUFlQSxHQUFmLEVBQW9CO0FBQ2xCbFUsZUFBSWl0QixJQUFJMTFCLE1BQUosQ0FBVzJjLENBQVgsQ0FBSjtBQUNBLGVBQUlsVSxNQUFNLEdBQVYsRUFBZTtBQUFFO0FBQU87QUFDekI7QUFDRCxhQUFJLENBQUNBLENBQUQsSUFBTSxDQUFDK3NCLG9CQUFvQi93QixJQUFwQixDQUF5QmdFLENBQXpCLENBQVgsRUFBd0M7QUFDdENxdEIscUJBQVUsSUFBVjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELE9BQUl0WSxlQUFlcm9CLFNBQW5CLEVBQThCO0FBQzVCcW9CLGtCQUFha1ksSUFBSXYrQixLQUFKLENBQVUsQ0FBVixFQUFhNUIsQ0FBYixFQUFnQjhnQyxJQUFoQixFQUFiO0FBQ0QsSUFGRCxNQUVPLElBQUlILG9CQUFvQixDQUF4QixFQUEyQjtBQUNoQ0k7QUFDRDs7QUFFRCxZQUFTQSxVQUFULEdBQXVCO0FBQ3JCLE1BQUNGLFlBQVlBLFVBQVUsRUFBdEIsQ0FBRCxFQUE0Qmp3QixJQUE1QixDQUFpQ3V2QixJQUFJditCLEtBQUosQ0FBVSsrQixlQUFWLEVBQTJCM2dDLENBQTNCLEVBQThCOGdDLElBQTlCLEVBQWpDO0FBQ0FILHVCQUFrQjNnQyxJQUFJLENBQXRCO0FBQ0Q7O0FBRUQsT0FBSTZnQyxPQUFKLEVBQWE7QUFDWCxVQUFLN2dDLElBQUksQ0FBVCxFQUFZQSxJQUFJNmdDLFFBQVE1Z0MsTUFBeEIsRUFBZ0NELEdBQWhDLEVBQXFDO0FBQ25DaW9CLG9CQUFhK1ksV0FBVy9ZLFVBQVgsRUFBdUI0WSxRQUFRN2dDLENBQVIsQ0FBdkIsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsVUFBT2lvQixVQUFQO0FBQ0Q7O0FBRUQsVUFBUytZLFVBQVQsQ0FBcUJiLEdBQXJCLEVBQTBCbjVCLE1BQTFCLEVBQWtDO0FBQ2hDLE9BQUloSCxJQUFJZ0gsT0FBT3RGLE9BQVAsQ0FBZSxHQUFmLENBQVI7QUFDQSxPQUFJMUIsSUFBSSxDQUFSLEVBQVc7QUFDVDtBQUNBLFlBQVEsVUFBVWdILE1BQVYsR0FBbUIsTUFBbkIsR0FBNEJtNUIsR0FBNUIsR0FBa0MsR0FBMUM7QUFDRCxJQUhELE1BR087QUFDTCxTQUFJNS9CLE9BQU95RyxPQUFPcEYsS0FBUCxDQUFhLENBQWIsRUFBZ0I1QixDQUFoQixDQUFYO0FBQ0EsU0FBSXlWLE9BQU96TyxPQUFPcEYsS0FBUCxDQUFhNUIsSUFBSSxDQUFqQixDQUFYO0FBQ0EsWUFBUSxVQUFVTyxJQUFWLEdBQWlCLE1BQWpCLEdBQTBCNC9CLEdBQTFCLEdBQWdDLEdBQWhDLEdBQXNDMXFCLElBQTlDO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxVQUFTd3JCLFFBQVQsQ0FBbUJ2eEIsR0FBbkIsRUFBd0I7QUFDdEIvUCxXQUFRbUcsS0FBUixDQUFlLHFCQUFxQjRKLEdBQXBDO0FBQ0Q7O0FBRUQsVUFBU3d4QixtQkFBVCxDQUNFcjFCLE9BREYsRUFFRWhDLEdBRkYsRUFHRTtBQUNBLFVBQU9nQyxVQUNIQSxRQUFRN0MsR0FBUixDQUFZLFVBQVUrQyxDQUFWLEVBQWE7QUFBRSxZQUFPQSxFQUFFbEMsR0FBRixDQUFQO0FBQWdCLElBQTNDLEVBQTZDN0MsTUFBN0MsQ0FBb0QsVUFBVXNELENBQVYsRUFBYTtBQUFFLFlBQU9BLENBQVA7QUFBVyxJQUE5RSxDQURHLEdBRUgsRUFGSjtBQUdEOztBQUVELFVBQVM2MkIsT0FBVCxDQUFrQnBwQixFQUFsQixFQUFzQnhYLElBQXRCLEVBQTRCb0gsS0FBNUIsRUFBbUM7QUFDakMsSUFBQ29RLEdBQUdvQixLQUFILEtBQWFwQixHQUFHb0IsS0FBSCxHQUFXLEVBQXhCLENBQUQsRUFBOEJ2SSxJQUE5QixDQUFtQyxFQUFFclEsTUFBTUEsSUFBUixFQUFjb0gsT0FBT0EsS0FBckIsRUFBbkM7QUFDRDs7QUFFRCxVQUFTeTVCLE9BQVQsQ0FBa0JycEIsRUFBbEIsRUFBc0J4WCxJQUF0QixFQUE0Qm9ILEtBQTVCLEVBQW1DO0FBQ2pDLElBQUNvUSxHQUFHc0ksS0FBSCxLQUFhdEksR0FBR3NJLEtBQUgsR0FBVyxFQUF4QixDQUFELEVBQThCelAsSUFBOUIsQ0FBbUMsRUFBRXJRLE1BQU1BLElBQVIsRUFBY29ILE9BQU9BLEtBQXJCLEVBQW5DO0FBQ0Q7O0FBRUQsVUFBUzA1QixZQUFULENBQ0V0cEIsRUFERixFQUVFeFgsSUFGRixFQUdFMitCLE9BSEYsRUFJRXYzQixLQUpGLEVBS0UyNUIsR0FMRixFQU1FdEMsU0FORixFQU9FO0FBQ0EsSUFBQ2puQixHQUFHaUMsVUFBSCxLQUFrQmpDLEdBQUdpQyxVQUFILEdBQWdCLEVBQWxDLENBQUQsRUFBd0NwSixJQUF4QyxDQUE2QyxFQUFFclEsTUFBTUEsSUFBUixFQUFjMitCLFNBQVNBLE9BQXZCLEVBQWdDdjNCLE9BQU9BLEtBQXZDLEVBQThDMjVCLEtBQUtBLEdBQW5ELEVBQXdEdEMsV0FBV0EsU0FBbkUsRUFBN0M7QUFDRDs7QUFFRCxVQUFTdUMsVUFBVCxDQUNFeHBCLEVBREYsRUFFRXhYLElBRkYsRUFHRW9ILEtBSEYsRUFJRXEzQixTQUpGLEVBS0V3QyxTQUxGLEVBTUVweUIsSUFORixFQU9FO0FBQ0E7QUFDQTtBQUNBLE9BQ0U5QixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixJQUF6QyxJQUNBNHZCLFNBREEsSUFDYUEsVUFBVXlDLE9BRHZCLElBQ2tDekMsVUFBVTlmLE9BRjlDLEVBR0U7QUFDQTlQLFVBQ0Usa0RBQ0EsK0NBRkY7QUFJRDtBQUNEO0FBQ0EsT0FBSTR2QixhQUFhQSxVQUFVNWYsT0FBM0IsRUFBb0M7QUFDbEMsWUFBTzRmLFVBQVU1ZixPQUFqQjtBQUNBN2UsWUFBTyxNQUFNQSxJQUFiLENBRmtDLENBRWY7QUFDcEI7QUFDRCxPQUFJeStCLGFBQWFBLFVBQVVueUIsSUFBM0IsRUFBaUM7QUFDL0IsWUFBT215QixVQUFVbnlCLElBQWpCO0FBQ0F0TSxZQUFPLE1BQU1BLElBQWIsQ0FGK0IsQ0FFWjtBQUNwQjtBQUNEO0FBQ0EsT0FBSXkrQixhQUFhQSxVQUFVOWYsT0FBM0IsRUFBb0M7QUFDbEMsWUFBTzhmLFVBQVU5ZixPQUFqQjtBQUNBM2UsWUFBTyxNQUFNQSxJQUFiLENBRmtDLENBRWY7QUFDcEI7QUFDRCxPQUFJbWhDLE1BQUo7QUFDQSxPQUFJMUMsYUFBYUEsVUFBVTJDLE1BQTNCLEVBQW1DO0FBQ2pDLFlBQU8zQyxVQUFVMkMsTUFBakI7QUFDQUQsY0FBUzNwQixHQUFHNnBCLFlBQUgsS0FBb0I3cEIsR0FBRzZwQixZQUFILEdBQWtCLEVBQXRDLENBQVQ7QUFDRCxJQUhELE1BR087QUFDTEYsY0FBUzNwQixHQUFHMnBCLE1BQUgsS0FBYzNwQixHQUFHMnBCLE1BQUgsR0FBWSxFQUExQixDQUFUO0FBQ0Q7QUFDRCxPQUFJRyxhQUFhLEVBQUVsNkIsT0FBT0EsS0FBVCxFQUFnQnEzQixXQUFXQSxTQUEzQixFQUFqQjtBQUNBLE9BQUkvaEIsV0FBV3lrQixPQUFPbmhDLElBQVAsQ0FBZjtBQUNBO0FBQ0EsT0FBSTZLLE1BQU1tQixPQUFOLENBQWMwUSxRQUFkLENBQUosRUFBNkI7QUFDM0J1a0IsaUJBQVl2a0IsU0FBUzBXLE9BQVQsQ0FBaUJrTyxVQUFqQixDQUFaLEdBQTJDNWtCLFNBQVNyTSxJQUFULENBQWNpeEIsVUFBZCxDQUEzQztBQUNELElBRkQsTUFFTyxJQUFJNWtCLFFBQUosRUFBYztBQUNuQnlrQixZQUFPbmhDLElBQVAsSUFBZWloQyxZQUFZLENBQUNLLFVBQUQsRUFBYTVrQixRQUFiLENBQVosR0FBcUMsQ0FBQ0EsUUFBRCxFQUFXNGtCLFVBQVgsQ0FBcEQ7QUFDRCxJQUZNLE1BRUE7QUFDTEgsWUFBT25oQyxJQUFQLElBQWVzaEMsVUFBZjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU0MsY0FBVCxDQUNFL3BCLEVBREYsRUFFRXhYLElBRkYsRUFHRXdoQyxTQUhGLEVBSUU7QUFDQSxPQUFJQyxlQUNGQyxpQkFBaUJscUIsRUFBakIsRUFBcUIsTUFBTXhYLElBQTNCLEtBQ0EwaEMsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLFlBQVl4WCxJQUFqQyxDQUZGO0FBR0EsT0FBSXloQyxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsWUFBTzlCLGFBQWE4QixZQUFiLENBQVA7QUFDRCxJQUZELE1BRU8sSUFBSUQsY0FBYyxLQUFsQixFQUF5QjtBQUM5QixTQUFJRyxjQUFjRCxpQkFBaUJscUIsRUFBakIsRUFBcUJ4WCxJQUFyQixDQUFsQjtBQUNBLFNBQUkyaEMsZUFBZSxJQUFuQixFQUF5QjtBQUN2QixjQUFPMTVCLEtBQUtDLFNBQUwsQ0FBZXk1QixXQUFmLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU0QsZ0JBQVQsQ0FBMkJscUIsRUFBM0IsRUFBK0J4WCxJQUEvQixFQUFxQztBQUNuQyxPQUFJMkgsR0FBSjtBQUNBLE9BQUksQ0FBQ0EsTUFBTTZQLEdBQUdvcUIsUUFBSCxDQUFZNWhDLElBQVosQ0FBUCxLQUE2QixJQUFqQyxFQUF1QztBQUNyQyxTQUFJMkksT0FBTzZPLEdBQUdxcUIsU0FBZDtBQUNBLFVBQUssSUFBSXBpQyxJQUFJLENBQVIsRUFBVytLLElBQUk3QixLQUFLakosTUFBekIsRUFBaUNELElBQUkrSyxDQUFyQyxFQUF3Qy9LLEdBQXhDLEVBQTZDO0FBQzNDLFdBQUlrSixLQUFLbEosQ0FBTCxFQUFRTyxJQUFSLEtBQWlCQSxJQUFyQixFQUEyQjtBQUN6QjJJLGNBQUtRLE1BQUwsQ0FBWTFKLENBQVosRUFBZSxDQUFmO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPa0ksR0FBUDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTbTZCLGlCQUFULENBQ0V0cUIsRUFERixFQUVFcFEsS0FGRixFQUdFcTNCLFNBSEYsRUFJRTtBQUNBLE9BQUk1TixNQUFNNE4sYUFBYSxFQUF2QjtBQUNBLE9BQUlzRCxTQUFTbFIsSUFBSWtSLE1BQWpCO0FBQ0EsT0FBSXhCLE9BQU8xUCxJQUFJMFAsSUFBZjs7QUFFQSxPQUFJeUIsc0JBQXNCLEtBQTFCO0FBQ0EsT0FBSUMsa0JBQWtCRCxtQkFBdEI7QUFDQSxPQUFJekIsSUFBSixFQUFVO0FBQ1IwQix1QkFDRSxhQUFhRCxtQkFBYixHQUFtQyxlQUFuQyxHQUNFLElBREYsR0FDU0EsbUJBRFQsR0FDK0IsU0FEL0IsR0FFRSxJQUZGLEdBRVNBLG1CQUZULEdBRStCLEdBSGpDO0FBSUQ7QUFDRCxPQUFJRCxNQUFKLEVBQVk7QUFDVkUsdUJBQWtCLFFBQVFBLGVBQVIsR0FBMEIsR0FBNUM7QUFDRDtBQUNELE9BQUlDLGFBQWFDLGtCQUFrQi82QixLQUFsQixFQUF5QjY2QixlQUF6QixDQUFqQjs7QUFFQXpxQixNQUFHZ1csS0FBSCxHQUFXO0FBQ1RwbUIsWUFBUSxNQUFNQSxLQUFOLEdBQWMsR0FEYjtBQUVUc2dCLGlCQUFhLE9BQU90Z0IsS0FBUCxHQUFlLElBRm5CO0FBR1RrbkIsZUFBVyxlQUFlMFQsbUJBQWYsR0FBcUMsS0FBckMsR0FBNkNFLFVBQTdDLEdBQTBEO0FBSDVELElBQVg7QUFLRDs7QUFFRDs7O0FBR0EsVUFBU0MsaUJBQVQsQ0FDRS82QixLQURGLEVBRUU4NkIsVUFGRixFQUdFO0FBQ0EsT0FBSUUsVUFBVUMsV0FBV2o3QixLQUFYLENBQWQ7QUFDQSxPQUFJZzdCLFFBQVFFLEdBQVIsS0FBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsWUFBUWw3QixRQUFRLEdBQVIsR0FBYzg2QixVQUF0QjtBQUNELElBRkQsTUFFTztBQUNMLFlBQVEsVUFBV0UsUUFBUXhDLEdBQW5CLEdBQTBCLElBQTFCLEdBQWtDd0MsUUFBUUUsR0FBMUMsR0FBaUQsSUFBakQsR0FBd0RKLFVBQXhELEdBQXFFLEdBQTdFO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxLQUFJL3NCLEdBQUo7QUFDQSxLQUFJNU0sR0FBSjtBQUNBLEtBQUlnNkIsR0FBSjtBQUNBLEtBQUlDLE9BQUo7QUFDQSxLQUFJQyxhQUFKO0FBQ0EsS0FBSUMsZ0JBQUo7O0FBRUEsVUFBU0wsVUFBVCxDQUFxQjE2QixHQUFyQixFQUEwQjtBQUN4QlksU0FBTVosR0FBTjtBQUNBd04sU0FBTTVNLElBQUk3SSxNQUFWO0FBQ0E4aUMsYUFBVUMsZ0JBQWdCQyxtQkFBbUIsQ0FBN0M7O0FBRUEsT0FBSS82QixJQUFJeEcsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBbkIsSUFBd0J3RyxJQUFJZzdCLFdBQUosQ0FBZ0IsR0FBaEIsSUFBdUJ4dEIsTUFBTSxDQUF6RCxFQUE0RDtBQUMxRCxZQUFPO0FBQ0x5cUIsWUFBS2o0QixHQURBO0FBRUwyNkIsWUFBSztBQUZBLE1BQVA7QUFJRDs7QUFFRCxVQUFPLENBQUNNLEtBQVIsRUFBZTtBQUNiTCxXQUFNTSxNQUFOO0FBQ0E7QUFDQSxTQUFJQyxjQUFjUCxHQUFkLENBQUosRUFBd0I7QUFDdEJRLG1CQUFZUixHQUFaO0FBQ0QsTUFGRCxNQUVPLElBQUlBLFFBQVEsSUFBWixFQUFrQjtBQUN2QlMsb0JBQWFULEdBQWI7QUFDRDtBQUNGOztBQUVELFVBQU87QUFDTDNDLFVBQUtqNEIsSUFBSXM3QixTQUFKLENBQWMsQ0FBZCxFQUFpQlIsYUFBakIsQ0FEQTtBQUVMSCxVQUFLMzZCLElBQUlzN0IsU0FBSixDQUFjUixnQkFBZ0IsQ0FBOUIsRUFBaUNDLGdCQUFqQztBQUZBLElBQVA7QUFJRDs7QUFFRCxVQUFTRyxJQUFULEdBQWlCO0FBQ2YsVUFBT3Q2QixJQUFJMkYsVUFBSixDQUFlLEVBQUVzMEIsT0FBakIsQ0FBUDtBQUNEOztBQUVELFVBQVNJLEdBQVQsR0FBZ0I7QUFDZCxVQUFPSixXQUFXcnRCLEdBQWxCO0FBQ0Q7O0FBRUQsVUFBUzJ0QixhQUFULENBQXdCUCxHQUF4QixFQUE2QjtBQUMzQixVQUFPQSxRQUFRLElBQVIsSUFBZ0JBLFFBQVEsSUFBL0I7QUFDRDs7QUFFRCxVQUFTUyxZQUFULENBQXVCVCxHQUF2QixFQUE0QjtBQUMxQixPQUFJVyxZQUFZLENBQWhCO0FBQ0FULG1CQUFnQkQsT0FBaEI7QUFDQSxVQUFPLENBQUNJLEtBQVIsRUFBZTtBQUNiTCxXQUFNTSxNQUFOO0FBQ0EsU0FBSUMsY0FBY1AsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCUSxtQkFBWVIsR0FBWjtBQUNBO0FBQ0Q7QUFDRCxTQUFJQSxRQUFRLElBQVosRUFBa0I7QUFBRVc7QUFBYztBQUNsQyxTQUFJWCxRQUFRLElBQVosRUFBa0I7QUFBRVc7QUFBYztBQUNsQyxTQUFJQSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CUiwwQkFBbUJGLE9BQW5CO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU08sV0FBVCxDQUFzQlIsR0FBdEIsRUFBMkI7QUFDekIsT0FBSVksY0FBY1osR0FBbEI7QUFDQSxVQUFPLENBQUNLLEtBQVIsRUFBZTtBQUNiTCxXQUFNTSxNQUFOO0FBQ0EsU0FBSU4sUUFBUVksV0FBWixFQUF5QjtBQUN2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxLQUFJQyxNQUFKOztBQUVBO0FBQ0E7QUFDQSxLQUFJQyxjQUFjLEtBQWxCO0FBQ0EsS0FBSUMsdUJBQXVCLEtBQTNCOztBQUVBLFVBQVM5VixLQUFULENBQ0VoVyxFQURGLEVBRUU0bUIsR0FGRixFQUdFbUYsS0FIRixFQUlFO0FBQ0FILFlBQVNHLEtBQVQ7QUFDQSxPQUFJbjhCLFFBQVFnM0IsSUFBSWgzQixLQUFoQjtBQUNBLE9BQUlxM0IsWUFBWUwsSUFBSUssU0FBcEI7QUFDQSxPQUFJM2lCLE1BQU10RSxHQUFHc0UsR0FBYjtBQUNBLE9BQUluRCxPQUFPbkIsR0FBR29xQixRQUFILENBQVlqcEIsSUFBdkI7O0FBRUEsT0FBSTVMLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxTQUFJdTJCLGNBQWNoc0IsR0FBR29xQixRQUFILENBQVksYUFBWixLQUE4QnBxQixHQUFHb3FCLFFBQUgsQ0FBWSxPQUFaLENBQWhEO0FBQ0EsU0FBSTlsQixRQUFRLE9BQVIsSUFBbUIwbkIsV0FBdkIsRUFBb0M7QUFDbENKLGNBQ0Usb0JBQW9CSSxXQUFwQixHQUFrQyxlQUFsQyxHQUFvRHA4QixLQUFwRCxHQUE0RCxRQUE1RCxHQUNBLDBFQUZGO0FBSUQ7QUFDRDtBQUNBO0FBQ0EsU0FBSTBVLFFBQVEsT0FBUixJQUFtQm5ELFNBQVMsTUFBaEMsRUFBd0M7QUFDdEN5cUIsY0FDRSxNQUFPNXJCLEdBQUdzRSxHQUFWLEdBQWlCLGFBQWpCLEdBQWlDMVUsS0FBakMsR0FBeUMsc0JBQXpDLEdBQ0EsZ0VBRkY7QUFJRDtBQUNGOztBQUVELE9BQUlvUSxHQUFHa0ssU0FBUCxFQUFrQjtBQUNoQm9nQix1QkFBa0J0cUIsRUFBbEIsRUFBc0JwUSxLQUF0QixFQUE2QnEzQixTQUE3QjtBQUNBO0FBQ0EsWUFBTyxLQUFQO0FBQ0QsSUFKRCxNQUlPLElBQUkzaUIsUUFBUSxRQUFaLEVBQXNCO0FBQzNCMm5CLGVBQVVqc0IsRUFBVixFQUFjcFEsS0FBZCxFQUFxQnEzQixTQUFyQjtBQUNELElBRk0sTUFFQSxJQUFJM2lCLFFBQVEsT0FBUixJQUFtQm5ELFNBQVMsVUFBaEMsRUFBNEM7QUFDakQrcUIsc0JBQWlCbHNCLEVBQWpCLEVBQXFCcFEsS0FBckIsRUFBNEJxM0IsU0FBNUI7QUFDRCxJQUZNLE1BRUEsSUFBSTNpQixRQUFRLE9BQVIsSUFBbUJuRCxTQUFTLE9BQWhDLEVBQXlDO0FBQzlDZ3JCLG1CQUFjbnNCLEVBQWQsRUFBa0JwUSxLQUFsQixFQUF5QnEzQixTQUF6QjtBQUNELElBRk0sTUFFQSxJQUFJM2lCLFFBQVEsT0FBUixJQUFtQkEsUUFBUSxVQUEvQixFQUEyQztBQUNoRDhuQixxQkFBZ0Jwc0IsRUFBaEIsRUFBb0JwUSxLQUFwQixFQUEyQnEzQixTQUEzQjtBQUNELElBRk0sTUFFQSxJQUFJLENBQUM5eEIsT0FBT2EsYUFBUCxDQUFxQnNPLEdBQXJCLENBQUwsRUFBZ0M7QUFDckNnbUIsdUJBQWtCdHFCLEVBQWxCLEVBQXNCcFEsS0FBdEIsRUFBNkJxM0IsU0FBN0I7QUFDQTtBQUNBLFlBQU8sS0FBUDtBQUNELElBSk0sTUFJQSxJQUFJMXhCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRG0yQixZQUNFLE1BQU81ckIsR0FBR3NFLEdBQVYsR0FBaUIsYUFBakIsR0FBaUMxVSxLQUFqQyxHQUF5QyxPQUF6QyxHQUNBLGlEQURBLEdBRUEsZ0VBRkEsR0FHQSxzRUFKRjtBQU1EOztBQUVEO0FBQ0EsVUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBU3M4QixnQkFBVCxDQUNFbHNCLEVBREYsRUFFRXBRLEtBRkYsRUFHRXEzQixTQUhGLEVBSUU7QUFDQSxPQUFJc0QsU0FBU3RELGFBQWFBLFVBQVVzRCxNQUFwQztBQUNBLE9BQUk4QixlQUFldEMsZUFBZS9wQixFQUFmLEVBQW1CLE9BQW5CLEtBQStCLE1BQWxEO0FBQ0EsT0FBSXNzQixtQkFBbUJ2QyxlQUFlL3BCLEVBQWYsRUFBbUIsWUFBbkIsS0FBb0MsTUFBM0Q7QUFDQSxPQUFJdXNCLG9CQUFvQnhDLGVBQWUvcEIsRUFBZixFQUFtQixhQUFuQixLQUFxQyxPQUE3RDtBQUNBb3BCLFdBQVFwcEIsRUFBUixFQUFZLFNBQVosRUFDRSxtQkFBbUJwUSxLQUFuQixHQUEyQixHQUEzQixHQUNFLE1BREYsR0FDV0EsS0FEWCxHQUNtQixHQURuQixHQUN5Qnk4QixZQUR6QixHQUN3QyxNQUR4QyxJQUVJQyxxQkFBcUIsTUFBckIsR0FDSyxPQUFPMThCLEtBQVAsR0FBZSxHQURwQixHQUVLLFNBQVNBLEtBQVQsR0FBaUIsR0FBakIsR0FBdUIwOEIsZ0JBQXZCLEdBQTBDLEdBSm5ELENBREY7QUFRQTlDLGNBQVd4cEIsRUFBWCxFQUFlOHJCLG9CQUFmLEVBQ0UsYUFBYWw4QixLQUFiLEdBQXFCLEdBQXJCLEdBQ0kscUJBREosR0FFSSxvQkFGSixHQUUyQjA4QixnQkFGM0IsR0FFOEMsS0FGOUMsR0FFc0RDLGlCQUZ0RCxHQUUwRSxJQUYxRSxHQUdBLHlCQUhBLEdBSUUsVUFKRixJQUlnQmhDLFNBQVMsUUFBUThCLFlBQVIsR0FBdUIsR0FBaEMsR0FBc0NBLFlBSnRELElBSXNFLEdBSnRFLEdBS00sa0JBTE4sR0FNRSwyQkFORixHQU1nQ3o4QixLQU5oQyxHQU13QyxvQkFOeEMsR0FPRSxnQkFQRixHQU9xQkEsS0FQckIsR0FPNkIsOENBUDdCLEdBUUEsUUFSQSxHQVFZKzZCLGtCQUFrQi82QixLQUFsQixFQUF5QixLQUF6QixDQVJaLEdBUStDLEdBVGpELEVBVUUsSUFWRixFQVVRLElBVlI7QUFZRDs7QUFFRCxVQUFTdThCLGFBQVQsQ0FDSW5zQixFQURKLEVBRUlwUSxLQUZKLEVBR0lxM0IsU0FISixFQUlFO0FBQ0EsT0FBSXNELFNBQVN0RCxhQUFhQSxVQUFVc0QsTUFBcEM7QUFDQSxPQUFJOEIsZUFBZXRDLGVBQWUvcEIsRUFBZixFQUFtQixPQUFuQixLQUErQixNQUFsRDtBQUNBcXNCLGtCQUFlOUIsU0FBVSxRQUFROEIsWUFBUixHQUF1QixHQUFqQyxHQUF3Q0EsWUFBdkQ7QUFDQWpELFdBQVFwcEIsRUFBUixFQUFZLFNBQVosRUFBd0IsUUFBUXBRLEtBQVIsR0FBZ0IsR0FBaEIsR0FBc0J5OEIsWUFBdEIsR0FBcUMsR0FBN0Q7QUFDQTdDLGNBQVd4cEIsRUFBWCxFQUFlOHJCLG9CQUFmLEVBQXFDbkIsa0JBQWtCLzZCLEtBQWxCLEVBQXlCeThCLFlBQXpCLENBQXJDLEVBQTZFLElBQTdFLEVBQW1GLElBQW5GO0FBQ0Q7O0FBRUQsVUFBU0osU0FBVCxDQUNJanNCLEVBREosRUFFSXBRLEtBRkosRUFHSXEzQixTQUhKLEVBSUU7QUFDQSxPQUFJc0QsU0FBU3RELGFBQWFBLFVBQVVzRCxNQUFwQztBQUNBLE9BQUlpQyxjQUFjLDJCQUNoQiw2REFEZ0IsR0FFaEIsa0VBRmdCLEdBR2hCLFNBSGdCLElBR0hqQyxTQUFTLFNBQVQsR0FBcUIsS0FIbEIsSUFHMkIsSUFIN0M7O0FBS0EsT0FBSUcsYUFBYSwyREFBakI7QUFDQSxPQUFJK0IsT0FBTyx5QkFBeUJELFdBQXpCLEdBQXVDLEdBQWxEO0FBQ0FDLFVBQU9BLE9BQU8sR0FBUCxHQUFjOUIsa0JBQWtCLzZCLEtBQWxCLEVBQXlCODZCLFVBQXpCLENBQXJCO0FBQ0FsQixjQUFXeHBCLEVBQVgsRUFBZSxRQUFmLEVBQXlCeXNCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLElBQXJDO0FBQ0Q7O0FBRUQsVUFBU0wsZUFBVCxDQUNFcHNCLEVBREYsRUFFRXBRLEtBRkYsRUFHRXEzQixTQUhGLEVBSUU7QUFDQSxPQUFJOWxCLE9BQU9uQixHQUFHb3FCLFFBQUgsQ0FBWWpwQixJQUF2QjtBQUNBLE9BQUlrWSxNQUFNNE4sYUFBYSxFQUF2QjtBQUNBLE9BQUlwVyxPQUFPd0ksSUFBSXhJLElBQWY7QUFDQSxPQUFJMFosU0FBU2xSLElBQUlrUixNQUFqQjtBQUNBLE9BQUl4QixPQUFPMVAsSUFBSTBQLElBQWY7QUFDQSxPQUFJMkQsdUJBQXVCLENBQUM3YixJQUFELElBQVMxUCxTQUFTLE9BQTdDO0FBQ0EsT0FBSWxULFFBQVE0aUIsT0FDUixRQURRLEdBRVIxUCxTQUFTLE9BQVQsR0FDRTBxQixXQURGLEdBRUUsT0FKTjs7QUFNQSxPQUFJcEIsa0JBQWtCLHFCQUF0QjtBQUNBLE9BQUkxQixJQUFKLEVBQVU7QUFDUjBCLHVCQUFrQiw0QkFBbEI7QUFDRDtBQUNELE9BQUlGLE1BQUosRUFBWTtBQUNWRSx1QkFBa0IsUUFBUUEsZUFBUixHQUEwQixHQUE1QztBQUNEOztBQUVELE9BQUlnQyxPQUFPOUIsa0JBQWtCLzZCLEtBQWxCLEVBQXlCNjZCLGVBQXpCLENBQVg7QUFDQSxPQUFJaUMsb0JBQUosRUFBMEI7QUFDeEJELFlBQU8sdUNBQXVDQSxJQUE5QztBQUNEOztBQUVEckQsV0FBUXBwQixFQUFSLEVBQVksT0FBWixFQUFzQixNQUFNcFEsS0FBTixHQUFjLEdBQXBDO0FBQ0E0NUIsY0FBV3hwQixFQUFYLEVBQWUvUixLQUFmLEVBQXNCdytCLElBQXRCLEVBQTRCLElBQTVCLEVBQWtDLElBQWxDO0FBQ0EsT0FBSTFELFFBQVF3QixNQUFaLEVBQW9CO0FBQ2xCZixnQkFBV3hwQixFQUFYLEVBQWUsTUFBZixFQUF1QixnQkFBdkI7QUFDRDtBQUNGOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzJzQixlQUFULENBQTBCaGxCLEVBQTFCLEVBQThCO0FBQzVCLE9BQUkxWixLQUFKO0FBQ0E7QUFDQSxPQUFJdUIsTUFBTW1ZLEdBQUdra0IsV0FBSCxDQUFOLENBQUosRUFBNEI7QUFDMUI7QUFDQTU5QixhQUFRb0wsT0FBTyxRQUFQLEdBQWtCLE9BQTFCO0FBQ0FzTyxRQUFHMVosS0FBSCxJQUFZLEdBQUdnRyxNQUFILENBQVUwVCxHQUFHa2tCLFdBQUgsQ0FBVixFQUEyQmxrQixHQUFHMVosS0FBSCxLQUFhLEVBQXhDLENBQVo7QUFDQSxZQUFPMFosR0FBR2trQixXQUFILENBQVA7QUFDRDtBQUNELE9BQUlyOEIsTUFBTW1ZLEdBQUdta0Isb0JBQUgsQ0FBTixDQUFKLEVBQXFDO0FBQ25DO0FBQ0E3OUIsYUFBUXlMLFdBQVcsT0FBWCxHQUFxQixRQUE3QjtBQUNBaU8sUUFBRzFaLEtBQUgsSUFBWSxHQUFHZ0csTUFBSCxDQUFVMFQsR0FBR21rQixvQkFBSCxDQUFWLEVBQW9DbmtCLEdBQUcxWixLQUFILEtBQWEsRUFBakQsQ0FBWjtBQUNBLFlBQU8wWixHQUFHbWtCLG9CQUFILENBQVA7QUFDRDtBQUNGOztBQUVELEtBQUljLFFBQUo7O0FBRUEsVUFBU0MsS0FBVCxDQUNFNStCLEtBREYsRUFFRXFsQixRQUZGLEVBR0VsTSxPQUhGLEVBSUVDLE9BSkYsRUFLRUYsT0FMRixFQU1FO0FBQ0EsT0FBSUMsT0FBSixFQUFhO0FBQ1gsU0FBSTBsQixhQUFheFosUUFBakI7QUFDQSxTQUFJblcsVUFBVXl2QixRQUFkLENBRlcsQ0FFYTtBQUN4QnRaLGdCQUFVLGlCQUFVeVosRUFBVixFQUFjO0FBQ3RCLFdBQUloZ0MsTUFBTXJGLFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsR0FDTjRrQyxXQUFXQyxFQUFYLENBRE0sR0FFTkQsV0FBV3JsQyxLQUFYLENBQWlCLElBQWpCLEVBQXVCQyxTQUF2QixDQUZKO0FBR0EsV0FBSXFGLFFBQVEsSUFBWixFQUFrQjtBQUNoQmlnQyxrQkFBUy8rQixLQUFULEVBQWdCcWxCLFFBQWhCLEVBQXlCak0sT0FBekIsRUFBa0NsSyxPQUFsQztBQUNEO0FBQ0YsTUFQRDtBQVFEO0FBQ0R5dkIsWUFBUzV5QixnQkFBVCxDQUNFL0wsS0FERixFQUVFcWxCLFFBRkYsRUFHRXpaLGtCQUNJLEVBQUV3TixTQUFTQSxPQUFYLEVBQW9CRixTQUFTQSxPQUE3QixFQURKLEdBRUlFLE9BTE47QUFPRDs7QUFFRCxVQUFTMmxCLFFBQVQsQ0FDRS8rQixLQURGLEVBRUVxbEIsT0FGRixFQUdFak0sT0FIRixFQUlFbEssT0FKRixFQUtFO0FBQ0EsSUFBQ0EsV0FBV3l2QixRQUFaLEVBQXNCSyxtQkFBdEIsQ0FBMENoL0IsS0FBMUMsRUFBaURxbEIsT0FBakQsRUFBMERqTSxPQUExRDtBQUNEOztBQUVELFVBQVM2bEIsa0JBQVQsQ0FBNkIxWCxRQUE3QixFQUF1QzFPLEtBQXZDLEVBQThDO0FBQzVDLE9BQUl4WCxRQUFRa21CLFNBQVNob0IsSUFBVCxDQUFjbWEsRUFBdEIsS0FBNkJyWSxRQUFRd1gsTUFBTXRaLElBQU4sQ0FBV21hLEVBQW5CLENBQWpDLEVBQXlEO0FBQ3ZEO0FBQ0Q7QUFDRCxPQUFJQSxLQUFLYixNQUFNdFosSUFBTixDQUFXbWEsRUFBWCxJQUFpQixFQUExQjtBQUNBLE9BQUlDLFFBQVE0TixTQUFTaG9CLElBQVQsQ0FBY21hLEVBQWQsSUFBb0IsRUFBaEM7QUFDQWlsQixjQUFXOWxCLE1BQU1yQixHQUFqQjtBQUNBa25CLG1CQUFnQmhsQixFQUFoQjtBQUNBRCxtQkFBZ0JDLEVBQWhCLEVBQW9CQyxLQUFwQixFQUEyQmlsQixLQUEzQixFQUFrQ0csUUFBbEMsRUFBNENsbUIsTUFBTXBCLE9BQWxEO0FBQ0Q7O0FBRUQsS0FBSWlrQixTQUFTO0FBQ1h6NEIsV0FBUWc4QixrQkFERztBQUVYbHdCLFdBQVFrd0I7QUFGRyxFQUFiOztBQUtBOztBQUVBLFVBQVNDLGNBQVQsQ0FBeUIzWCxRQUF6QixFQUFtQzFPLEtBQW5DLEVBQTBDO0FBQ3hDLE9BQUl4WCxRQUFRa21CLFNBQVNob0IsSUFBVCxDQUFjNHFCLFFBQXRCLEtBQW1DOW9CLFFBQVF3WCxNQUFNdFosSUFBTixDQUFXNHFCLFFBQW5CLENBQXZDLEVBQXFFO0FBQ25FO0FBQ0Q7QUFDRCxPQUFJdG1CLEdBQUosRUFBU2dXLEdBQVQ7QUFDQSxPQUFJckMsTUFBTXFCLE1BQU1yQixHQUFoQjtBQUNBLE9BQUkybkIsV0FBVzVYLFNBQVNob0IsSUFBVCxDQUFjNHFCLFFBQWQsSUFBMEIsRUFBekM7QUFDQSxPQUFJaFgsUUFBUTBGLE1BQU10WixJQUFOLENBQVc0cUIsUUFBWCxJQUF1QixFQUFuQztBQUNBO0FBQ0EsT0FBSTVvQixNQUFNNFIsTUFBTXRELE1BQVosQ0FBSixFQUF5QjtBQUN2QnNELGFBQVEwRixNQUFNdFosSUFBTixDQUFXNHFCLFFBQVgsR0FBc0I5a0IsT0FBTyxFQUFQLEVBQVc4TixLQUFYLENBQTlCO0FBQ0Q7O0FBRUQsUUFBS3RQLEdBQUwsSUFBWXM3QixRQUFaLEVBQXNCO0FBQ3BCLFNBQUk5OUIsUUFBUThSLE1BQU10UCxHQUFOLENBQVIsQ0FBSixFQUF5QjtBQUN2QjJULFdBQUkzVCxHQUFKLElBQVcsRUFBWDtBQUNEO0FBQ0Y7QUFDRCxRQUFLQSxHQUFMLElBQVlzUCxLQUFaLEVBQW1CO0FBQ2pCMEcsV0FBTTFHLE1BQU10UCxHQUFOLENBQU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFJQSxRQUFRLGFBQVIsSUFBeUJBLFFBQVEsV0FBckMsRUFBa0Q7QUFDaEQsV0FBSWdWLE1BQU12QixRQUFWLEVBQW9CO0FBQUV1QixlQUFNdkIsUUFBTixDQUFlcmQsTUFBZixHQUF3QixDQUF4QjtBQUE0QjtBQUNsRCxXQUFJNGYsUUFBUXNsQixTQUFTdDdCLEdBQVQsQ0FBWixFQUEyQjtBQUFFO0FBQVU7QUFDeEM7O0FBRUQsU0FBSUEsUUFBUSxPQUFaLEVBQXFCO0FBQ25CO0FBQ0E7QUFDQTJULFdBQUk0bkIsTUFBSixHQUFhdmxCLEdBQWI7QUFDQTtBQUNBLFdBQUl3bEIsU0FBU2grQixRQUFRd1ksR0FBUixJQUFlLEVBQWYsR0FBb0JuWCxPQUFPbVgsR0FBUCxDQUFqQztBQUNBLFdBQUl5bEIsa0JBQWtCOW5CLEdBQWxCLEVBQXVCcUIsS0FBdkIsRUFBOEJ3bUIsTUFBOUIsQ0FBSixFQUEyQztBQUN6QzduQixhQUFJN1YsS0FBSixHQUFZMDlCLE1BQVo7QUFDRDtBQUNGLE1BVEQsTUFTTztBQUNMN25CLFdBQUkzVCxHQUFKLElBQVdnVyxHQUFYO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7QUFHQSxVQUFTeWxCLGlCQUFULENBQ0U5bkIsR0FERixFQUVFcUIsS0FGRixFQUdFMG1CLFFBSEYsRUFJRTtBQUNBLFVBQVEsQ0FBQy9uQixJQUFJZ29CLFNBQUwsS0FDTjNtQixNQUFNeEMsR0FBTixLQUFjLFFBQWQsSUFDQW9wQixRQUFRam9CLEdBQVIsRUFBYStuQixRQUFiLENBREEsSUFFQUcsZUFBZWxvQixHQUFmLEVBQW9CK25CLFFBQXBCLENBSE0sQ0FBUjtBQUtEOztBQUVELFVBQVNFLE9BQVQsQ0FBa0Jqb0IsR0FBbEIsRUFBdUIrbkIsUUFBdkIsRUFBaUM7QUFDL0I7QUFDQTtBQUNBLE9BQUlJLGFBQWEsSUFBakI7QUFDQTtBQUNBO0FBQ0EsT0FBSTtBQUFFQSxrQkFBYXZrQyxTQUFTd2tDLGFBQVQsS0FBMkJwb0IsR0FBeEM7QUFBOEMsSUFBcEQsQ0FBcUQsT0FBT2plLENBQVAsRUFBVSxDQUFFO0FBQ2pFLFVBQU9vbUMsY0FBY25vQixJQUFJN1YsS0FBSixLQUFjNDlCLFFBQW5DO0FBQ0Q7O0FBRUQsVUFBU0csY0FBVCxDQUF5QmxvQixHQUF6QixFQUE4QjdGLE1BQTlCLEVBQXNDO0FBQ3BDLE9BQUloUSxRQUFRNlYsSUFBSTdWLEtBQWhCO0FBQ0EsT0FBSXEzQixZQUFZeGhCLElBQUlxb0IsV0FBcEIsQ0FGb0MsQ0FFSDtBQUNqQyxPQUFJdCtCLE1BQU15M0IsU0FBTixLQUFvQkEsVUFBVXNELE1BQWxDLEVBQTBDO0FBQ3hDLFlBQU8zNUIsU0FBU2hCLEtBQVQsTUFBb0JnQixTQUFTZ1AsTUFBVCxDQUEzQjtBQUNEO0FBQ0QsT0FBSXBRLE1BQU15M0IsU0FBTixLQUFvQkEsVUFBVThCLElBQWxDLEVBQXdDO0FBQ3RDLFlBQU9uNUIsTUFBTW01QixJQUFOLE9BQWlCbnBCLE9BQU9tcEIsSUFBUCxFQUF4QjtBQUNEO0FBQ0QsVUFBT241QixVQUFVZ1EsTUFBakI7QUFDRDs7QUFFRCxLQUFJd1ksV0FBVztBQUNibG5CLFdBQVFpOEIsY0FESztBQUVibndCLFdBQVFtd0I7QUFGSyxFQUFmOztBQUtBOztBQUVBLEtBQUlZLGlCQUFpQmg4QixPQUFPLFVBQVVpOEIsT0FBVixFQUFtQjtBQUM3QyxPQUFJamhDLE1BQU0sRUFBVjtBQUNBLE9BQUlraEMsZ0JBQWdCLGVBQXBCO0FBQ0EsT0FBSUMsb0JBQW9CLE9BQXhCO0FBQ0FGLFdBQVE1OEIsS0FBUixDQUFjNjhCLGFBQWQsRUFBNkJsL0IsT0FBN0IsQ0FBcUMsVUFBVTJDLElBQVYsRUFBZ0I7QUFDbkQsU0FBSUEsSUFBSixFQUFVO0FBQ1IsV0FBSTJmLE1BQU0zZixLQUFLTixLQUFMLENBQVc4OEIsaUJBQVgsQ0FBVjtBQUNBN2MsV0FBSW5wQixNQUFKLEdBQWEsQ0FBYixLQUFtQjZFLElBQUlza0IsSUFBSSxDQUFKLEVBQU8wWCxJQUFQLEVBQUosSUFBcUIxWCxJQUFJLENBQUosRUFBTzBYLElBQVAsRUFBeEM7QUFDRDtBQUNGLElBTEQ7QUFNQSxVQUFPaDhCLEdBQVA7QUFDRCxFQVhvQixDQUFyQjs7QUFhQTtBQUNBLFVBQVNvaEMsa0JBQVQsQ0FBNkIzZ0MsSUFBN0IsRUFBbUM7QUFDakMsT0FBSTRnQyxRQUFRQyxzQkFBc0I3Z0MsS0FBSzRnQyxLQUEzQixDQUFaO0FBQ0E7QUFDQTtBQUNBLFVBQU81Z0MsS0FBSzhnQyxXQUFMLEdBQ0hoN0IsT0FBTzlGLEtBQUs4Z0MsV0FBWixFQUF5QkYsS0FBekIsQ0FERyxHQUVIQSxLQUZKO0FBR0Q7O0FBRUQ7QUFDQSxVQUFTQyxxQkFBVCxDQUFnQ0UsWUFBaEMsRUFBOEM7QUFDNUMsT0FBSWw3QixNQUFNbUIsT0FBTixDQUFjKzVCLFlBQWQsQ0FBSixFQUFpQztBQUMvQixZQUFPOTZCLFNBQVM4NkIsWUFBVCxDQUFQO0FBQ0Q7QUFDRCxPQUFJLE9BQU9BLFlBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDcEMsWUFBT1IsZUFBZVEsWUFBZixDQUFQO0FBQ0Q7QUFDRCxVQUFPQSxZQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTQyxRQUFULENBQW1CMW5CLEtBQW5CLEVBQTBCMm5CLFVBQTFCLEVBQXNDO0FBQ3BDLE9BQUkxaEMsTUFBTSxFQUFWO0FBQ0EsT0FBSTJoQyxTQUFKOztBQUVBLE9BQUlELFVBQUosRUFBZ0I7QUFDZCxTQUFJOVAsWUFBWTdYLEtBQWhCO0FBQ0EsWUFBTzZYLFVBQVU1WSxpQkFBakIsRUFBb0M7QUFDbEM0WSxtQkFBWUEsVUFBVTVZLGlCQUFWLENBQTRCbUgsTUFBeEM7QUFDQSxXQUFJeVIsVUFBVW54QixJQUFWLEtBQW1Ca2hDLFlBQVlQLG1CQUFtQnhQLFVBQVVueEIsSUFBN0IsQ0FBL0IsQ0FBSixFQUF3RTtBQUN0RThGLGdCQUFPdkcsR0FBUCxFQUFZMmhDLFNBQVo7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsT0FBS0EsWUFBWVAsbUJBQW1Ccm5CLE1BQU10WixJQUF6QixDQUFqQixFQUFrRDtBQUNoRDhGLFlBQU92RyxHQUFQLEVBQVkyaEMsU0FBWjtBQUNEOztBQUVELE9BQUloUSxhQUFhNVgsS0FBakI7QUFDQSxVQUFRNFgsYUFBYUEsV0FBV3hlLE1BQWhDLEVBQXlDO0FBQ3ZDLFNBQUl3ZSxXQUFXbHhCLElBQVgsS0FBb0JraEMsWUFBWVAsbUJBQW1CelAsV0FBV2x4QixJQUE5QixDQUFoQyxDQUFKLEVBQTBFO0FBQ3hFOEYsY0FBT3ZHLEdBQVAsRUFBWTJoQyxTQUFaO0FBQ0Q7QUFDRjtBQUNELFVBQU8zaEMsR0FBUDtBQUNEOztBQUVEOztBQUVBLEtBQUk0aEMsV0FBVyxLQUFmO0FBQ0EsS0FBSUMsY0FBYyxnQkFBbEI7QUFDQSxLQUFJQyxVQUFVLFNBQVZBLE9BQVUsQ0FBVTd1QixFQUFWLEVBQWN4WCxJQUFkLEVBQW9CMkgsR0FBcEIsRUFBeUI7QUFDckM7QUFDQSxPQUFJdytCLFNBQVN4M0IsSUFBVCxDQUFjM08sSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCd1gsUUFBR291QixLQUFILENBQVNVLFdBQVQsQ0FBcUJ0bUMsSUFBckIsRUFBMkIySCxHQUEzQjtBQUNELElBRkQsTUFFTyxJQUFJeStCLFlBQVl6M0IsSUFBWixDQUFpQmhILEdBQWpCLENBQUosRUFBMkI7QUFDaEM2UCxRQUFHb3VCLEtBQUgsQ0FBU1UsV0FBVCxDQUFxQnRtQyxJQUFyQixFQUEyQjJILElBQUltQyxPQUFKLENBQVlzOEIsV0FBWixFQUF5QixFQUF6QixDQUEzQixFQUF5RCxXQUF6RDtBQUNELElBRk0sTUFFQTtBQUNMLFNBQUlHLGlCQUFpQkMsVUFBVXhtQyxJQUFWLENBQXJCO0FBQ0EsU0FBSTZLLE1BQU1tQixPQUFOLENBQWNyRSxHQUFkLENBQUosRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBSyxJQUFJbEksSUFBSSxDQUFSLEVBQVcwVixNQUFNeE4sSUFBSWpJLE1BQTFCLEVBQWtDRCxJQUFJMFYsR0FBdEMsRUFBMkMxVixHQUEzQyxFQUFnRDtBQUM5QytYLFlBQUdvdUIsS0FBSCxDQUFTVyxjQUFULElBQTJCNStCLElBQUlsSSxDQUFKLENBQTNCO0FBQ0Q7QUFDRixNQVBELE1BT087QUFDTCtYLFVBQUdvdUIsS0FBSCxDQUFTVyxjQUFULElBQTJCNStCLEdBQTNCO0FBQ0Q7QUFDRjtBQUNGLEVBbkJEOztBQXFCQSxLQUFJOCtCLGNBQWMsQ0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixJQUFsQixDQUFsQjs7QUFFQSxLQUFJQyxVQUFKO0FBQ0EsS0FBSUYsWUFBWWo5QixPQUFPLFVBQVVnUixJQUFWLEVBQWdCO0FBQ3JDbXNCLGdCQUFhQSxjQUFjN2xDLFNBQVN1ckIsYUFBVCxDQUF1QixLQUF2QixFQUE4QndaLEtBQXpEO0FBQ0FyckIsVUFBTzFRLFNBQVMwUSxJQUFULENBQVA7QUFDQSxPQUFJQSxTQUFTLFFBQVQsSUFBc0JBLFFBQVFtc0IsVUFBbEMsRUFBK0M7QUFDN0MsWUFBT25zQixJQUFQO0FBQ0Q7QUFDRCxPQUFJb3NCLFVBQVVwc0IsS0FBS3JRLE1BQUwsQ0FBWSxDQUFaLEVBQWV6SixXQUFmLEtBQStCOFosS0FBS2xaLEtBQUwsQ0FBVyxDQUFYLENBQTdDO0FBQ0EsUUFBSyxJQUFJNUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZ25DLFlBQVkvbUMsTUFBaEMsRUFBd0NELEdBQXhDLEVBQTZDO0FBQzNDLFNBQUlPLE9BQU95bUMsWUFBWWhuQyxDQUFaLElBQWlCa25DLE9BQTVCO0FBQ0EsU0FBSTNtQyxRQUFRMG1DLFVBQVosRUFBd0I7QUFDdEIsY0FBTzFtQyxJQUFQO0FBQ0Q7QUFDRjtBQUNGLEVBYmUsQ0FBaEI7O0FBZUEsVUFBUzRtQyxXQUFULENBQXNCNVosUUFBdEIsRUFBZ0MxTyxLQUFoQyxFQUF1QztBQUNyQyxPQUFJdFosT0FBT3NaLE1BQU10WixJQUFqQjtBQUNBLE9BQUlvNkIsVUFBVXBTLFNBQVNob0IsSUFBdkI7O0FBRUEsT0FBSThCLFFBQVE5QixLQUFLOGdDLFdBQWIsS0FBNkJoL0IsUUFBUTlCLEtBQUs0Z0MsS0FBYixDQUE3QixJQUNGOStCLFFBQVFzNEIsUUFBUTBHLFdBQWhCLENBREUsSUFDOEJoL0IsUUFBUXM0QixRQUFRd0csS0FBaEIsQ0FEbEMsRUFFRTtBQUNBO0FBQ0Q7O0FBRUQsT0FBSXRtQixHQUFKLEVBQVN0ZixJQUFUO0FBQ0EsT0FBSXdYLEtBQUs4RyxNQUFNckIsR0FBZjtBQUNBLE9BQUk0cEIsaUJBQWlCekgsUUFBUTBHLFdBQTdCO0FBQ0EsT0FBSWdCLGtCQUFrQjFILFFBQVEySCxlQUFSLElBQTJCM0gsUUFBUXdHLEtBQW5DLElBQTRDLEVBQWxFOztBQUVBO0FBQ0EsT0FBSW9CLFdBQVdILGtCQUFrQkMsZUFBakM7O0FBRUEsT0FBSWxCLFFBQVFDLHNCQUFzQnZuQixNQUFNdFosSUFBTixDQUFXNGdDLEtBQWpDLEtBQTJDLEVBQXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBdG5CLFNBQU10WixJQUFOLENBQVcraEMsZUFBWCxHQUE2Qi8vQixNQUFNNCtCLE1BQU10d0IsTUFBWixJQUN6QnhLLE9BQU8sRUFBUCxFQUFXODZCLEtBQVgsQ0FEeUIsR0FFekJBLEtBRko7O0FBSUEsT0FBSXFCLFdBQVdqQixTQUFTMW5CLEtBQVQsRUFBZ0IsSUFBaEIsQ0FBZjs7QUFFQSxRQUFLdGUsSUFBTCxJQUFhZ25DLFFBQWIsRUFBdUI7QUFDckIsU0FBSWxnQyxRQUFRbWdDLFNBQVNqbkMsSUFBVCxDQUFSLENBQUosRUFBNkI7QUFDM0JxbUMsZUFBUTd1QixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCLEVBQWxCO0FBQ0Q7QUFDRjtBQUNELFFBQUtBLElBQUwsSUFBYWluQyxRQUFiLEVBQXVCO0FBQ3JCM25CLFdBQU0ybkIsU0FBU2puQyxJQUFULENBQU47QUFDQSxTQUFJc2YsUUFBUTBuQixTQUFTaG5DLElBQVQsQ0FBWixFQUE0QjtBQUMxQjtBQUNBcW1DLGVBQVE3dUIsRUFBUixFQUFZeFgsSUFBWixFQUFrQnNmLE9BQU8sSUFBUCxHQUFjLEVBQWQsR0FBbUJBLEdBQXJDO0FBQ0Q7QUFDRjtBQUNGOztBQUVELEtBQUlzbUIsUUFBUTtBQUNWbDlCLFdBQVFrK0IsV0FERTtBQUVWcHlCLFdBQVFveUI7QUFGRSxFQUFaOztBQUtBOztBQUVBOzs7O0FBSUEsVUFBU00sUUFBVCxDQUFtQjF2QixFQUFuQixFQUF1QjZuQixHQUF2QixFQUE0QjtBQUMxQjtBQUNBLE9BQUksQ0FBQ0EsR0FBRCxJQUFRLEVBQUVBLE1BQU1BLElBQUlrQixJQUFKLEVBQVIsQ0FBWixFQUFpQztBQUMvQjtBQUNEOztBQUVEO0FBQ0EsT0FBSS9vQixHQUFHMnZCLFNBQVAsRUFBa0I7QUFDaEIsU0FBSTlILElBQUlsK0IsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBQyxDQUF4QixFQUEyQjtBQUN6QmsrQixXQUFJejJCLEtBQUosQ0FBVSxLQUFWLEVBQWlCckMsT0FBakIsQ0FBeUIsVUFBVXlELENBQVYsRUFBYTtBQUFFLGdCQUFPd04sR0FBRzJ2QixTQUFILENBQWF2ekIsR0FBYixDQUFpQjVKLENBQWpCLENBQVA7QUFBNkIsUUFBckU7QUFDRCxNQUZELE1BRU87QUFDTHdOLFVBQUcydkIsU0FBSCxDQUFhdnpCLEdBQWIsQ0FBaUJ5ckIsR0FBakI7QUFDRDtBQUNGLElBTkQsTUFNTztBQUNMLFNBQUkvZixNQUFNLE9BQU85SCxHQUFHNHZCLFlBQUgsQ0FBZ0IsT0FBaEIsS0FBNEIsRUFBbkMsSUFBeUMsR0FBbkQ7QUFDQSxTQUFJOW5CLElBQUluZSxPQUFKLENBQVksTUFBTWsrQixHQUFOLEdBQVksR0FBeEIsSUFBK0IsQ0FBbkMsRUFBc0M7QUFDcEM3bkIsVUFBR21nQixZQUFILENBQWdCLE9BQWhCLEVBQXlCLENBQUNyWSxNQUFNK2YsR0FBUCxFQUFZa0IsSUFBWixFQUF6QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVM4RyxXQUFULENBQXNCN3ZCLEVBQXRCLEVBQTBCNm5CLEdBQTFCLEVBQStCO0FBQzdCO0FBQ0EsT0FBSSxDQUFDQSxHQUFELElBQVEsRUFBRUEsTUFBTUEsSUFBSWtCLElBQUosRUFBUixDQUFaLEVBQWlDO0FBQy9CO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFJL29CLEdBQUcydkIsU0FBUCxFQUFrQjtBQUNoQixTQUFJOUgsSUFBSWwrQixPQUFKLENBQVksR0FBWixJQUFtQixDQUFDLENBQXhCLEVBQTJCO0FBQ3pCaytCLFdBQUl6MkIsS0FBSixDQUFVLEtBQVYsRUFBaUJyQyxPQUFqQixDQUF5QixVQUFVeUQsQ0FBVixFQUFhO0FBQUUsZ0JBQU93TixHQUFHMnZCLFNBQUgsQ0FBYW4rQixNQUFiLENBQW9CZ0IsQ0FBcEIsQ0FBUDtBQUFnQyxRQUF4RTtBQUNELE1BRkQsTUFFTztBQUNMd04sVUFBRzJ2QixTQUFILENBQWFuK0IsTUFBYixDQUFvQnEyQixHQUFwQjtBQUNEO0FBQ0QsU0FBSSxDQUFDN25CLEdBQUcydkIsU0FBSCxDQUFhem5DLE1BQWxCLEVBQTBCO0FBQ3hCOFgsVUFBRzhsQixlQUFILENBQW1CLE9BQW5CO0FBQ0Q7QUFDRixJQVRELE1BU087QUFDTCxTQUFJaGUsTUFBTSxPQUFPOUgsR0FBRzR2QixZQUFILENBQWdCLE9BQWhCLEtBQTRCLEVBQW5DLElBQXlDLEdBQW5EO0FBQ0EsU0FBSUUsTUFBTSxNQUFNakksR0FBTixHQUFZLEdBQXRCO0FBQ0EsWUFBTy9mLElBQUluZSxPQUFKLENBQVltbUMsR0FBWixLQUFvQixDQUEzQixFQUE4QjtBQUM1QmhvQixhQUFNQSxJQUFJeFYsT0FBSixDQUFZdzlCLEdBQVosRUFBaUIsR0FBakIsQ0FBTjtBQUNEO0FBQ0Rob0IsV0FBTUEsSUFBSWloQixJQUFKLEVBQU47QUFDQSxTQUFJamhCLEdBQUosRUFBUztBQUNQOUgsVUFBR21nQixZQUFILENBQWdCLE9BQWhCLEVBQXlCclksR0FBekI7QUFDRCxNQUZELE1BRU87QUFDTDlILFVBQUc4bEIsZUFBSCxDQUFtQixPQUFuQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxVQUFTaUssaUJBQVQsQ0FBNEJDLE1BQTVCLEVBQW9DO0FBQ2xDLE9BQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1g7QUFDRDtBQUNEO0FBQ0EsT0FBSSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDO0FBQzlCLFNBQUlqakMsTUFBTSxFQUFWO0FBQ0EsU0FBSWlqQyxPQUFPQyxHQUFQLEtBQWUsS0FBbkIsRUFBMEI7QUFDeEIzOEIsY0FBT3ZHLEdBQVAsRUFBWW1qQyxrQkFBa0JGLE9BQU94bkMsSUFBUCxJQUFlLEdBQWpDLENBQVo7QUFDRDtBQUNEOEssWUFBT3ZHLEdBQVAsRUFBWWlqQyxNQUFaO0FBQ0EsWUFBT2pqQyxHQUFQO0FBQ0QsSUFQRCxNQU9PLElBQUksT0FBT2lqQyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQ3JDLFlBQU9FLGtCQUFrQkYsTUFBbEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsS0FBSUUsb0JBQW9CbitCLE9BQU8sVUFBVXZKLElBQVYsRUFBZ0I7QUFDN0MsVUFBTztBQUNMMm5DLGlCQUFhM25DLE9BQU8sUUFEZjtBQUVMNG5DLG1CQUFlNW5DLE9BQU8sV0FGakI7QUFHTDZuQyx1QkFBbUI3bkMsT0FBTyxlQUhyQjtBQUlMOG5DLGlCQUFhOW5DLE9BQU8sUUFKZjtBQUtMK25DLG1CQUFlL25DLE9BQU8sV0FMakI7QUFNTGdvQyx1QkFBbUJob0MsT0FBTztBQU5yQixJQUFQO0FBUUQsRUFUdUIsQ0FBeEI7O0FBV0EsS0FBSWlvQyxnQkFBZ0J6M0IsYUFBYSxDQUFDTSxLQUFsQztBQUNBLEtBQUlvM0IsYUFBYSxZQUFqQjtBQUNBLEtBQUlDLFlBQVksV0FBaEI7O0FBRUE7QUFDQSxLQUFJQyxpQkFBaUIsWUFBckI7QUFDQSxLQUFJQyxxQkFBcUIsZUFBekI7QUFDQSxLQUFJQyxnQkFBZ0IsV0FBcEI7QUFDQSxLQUFJQyxvQkFBb0IsY0FBeEI7QUFDQSxLQUFJTixhQUFKLEVBQW1CO0FBQ2pCO0FBQ0EsT0FBSXZuQyxPQUFPOG5DLGVBQVAsS0FBMkJucEMsU0FBM0IsSUFDRnFCLE9BQU8rbkMscUJBQVAsS0FBaUNwcEMsU0FEbkMsRUFFRTtBQUNBK29DLHNCQUFpQixrQkFBakI7QUFDQUMsMEJBQXFCLHFCQUFyQjtBQUNEO0FBQ0QsT0FBSTNuQyxPQUFPZ29DLGNBQVAsS0FBMEJycEMsU0FBMUIsSUFDRnFCLE9BQU9pb0Msb0JBQVAsS0FBZ0N0cEMsU0FEbEMsRUFFRTtBQUNBaXBDLHFCQUFnQixpQkFBaEI7QUFDQUMseUJBQW9CLG9CQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxLQUFJSyxNQUFNcDRCLGFBQWE5UCxPQUFPbW9DLHFCQUFwQixHQUNObm9DLE9BQU9tb0MscUJBQVAsQ0FBNkJqcUMsSUFBN0IsQ0FBa0M4QixNQUFsQyxDQURNLEdBRU5tUyxVQUZKOztBQUlBLFVBQVNpMkIsU0FBVCxDQUFvQnQvQixFQUFwQixFQUF3QjtBQUN0Qm8vQixPQUFJLFlBQVk7QUFDZEEsU0FBSXAvQixFQUFKO0FBQ0QsSUFGRDtBQUdEOztBQUVELFVBQVN1L0Isa0JBQVQsQ0FBNkJ2eEIsRUFBN0IsRUFBaUM2bkIsR0FBakMsRUFBc0M7QUFDcEMsT0FBSTJKLG9CQUFvQnh4QixHQUFHK25CLGtCQUFILEtBQTBCL25CLEdBQUcrbkIsa0JBQUgsR0FBd0IsRUFBbEQsQ0FBeEI7QUFDQSxPQUFJeUosa0JBQWtCN25DLE9BQWxCLENBQTBCaytCLEdBQTFCLElBQWlDLENBQXJDLEVBQXdDO0FBQ3RDMkosdUJBQWtCMzRCLElBQWxCLENBQXVCZ3ZCLEdBQXZCO0FBQ0E2SCxjQUFTMXZCLEVBQVQsRUFBYTZuQixHQUFiO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTNEoscUJBQVQsQ0FBZ0N6eEIsRUFBaEMsRUFBb0M2bkIsR0FBcEMsRUFBeUM7QUFDdkMsT0FBSTduQixHQUFHK25CLGtCQUFQLEVBQTJCO0FBQ3pCdjJCLFlBQU93TyxHQUFHK25CLGtCQUFWLEVBQThCRixHQUE5QjtBQUNEO0FBQ0RnSSxlQUFZN3ZCLEVBQVosRUFBZ0I2bkIsR0FBaEI7QUFDRDs7QUFFRCxVQUFTNkosa0JBQVQsQ0FDRTF4QixFQURGLEVBRUU4RCxZQUZGLEVBR0VoSSxFQUhGLEVBSUU7QUFDQSxPQUFJdWQsTUFBTXNZLGtCQUFrQjN4QixFQUFsQixFQUFzQjhELFlBQXRCLENBQVY7QUFDQSxPQUFJM0MsT0FBT2tZLElBQUlsWSxJQUFmO0FBQ0EsT0FBSWlKLFVBQVVpUCxJQUFJalAsT0FBbEI7QUFDQSxPQUFJd25CLFlBQVl2WSxJQUFJdVksU0FBcEI7QUFDQSxPQUFJLENBQUN6d0IsSUFBTCxFQUFXO0FBQUUsWUFBT3JGLElBQVA7QUFBYTtBQUMxQixPQUFJN04sUUFBUWtULFNBQVN1dkIsVUFBVCxHQUFzQkcsa0JBQXRCLEdBQTJDRSxpQkFBdkQ7QUFDQSxPQUFJYyxRQUFRLENBQVo7QUFDQSxPQUFJQyxNQUFNLFNBQU5BLEdBQU0sR0FBWTtBQUNwQjl4QixRQUFHaXRCLG1CQUFILENBQXVCaC9CLEtBQXZCLEVBQThCOGpDLEtBQTlCO0FBQ0FqMkI7QUFDRCxJQUhEO0FBSUEsT0FBSWkyQixRQUFRLFNBQVJBLEtBQVEsQ0FBVXZxQyxDQUFWLEVBQWE7QUFDdkIsU0FBSUEsRUFBRXFWLE1BQUYsS0FBYW1ELEVBQWpCLEVBQXFCO0FBQ25CLFdBQUksRUFBRTZ4QixLQUFGLElBQVdELFNBQWYsRUFBMEI7QUFDeEJFO0FBQ0Q7QUFDRjtBQUNGLElBTkQ7QUFPQXoyQixjQUFXLFlBQVk7QUFDckIsU0FBSXcyQixRQUFRRCxTQUFaLEVBQXVCO0FBQ3JCRTtBQUNEO0FBQ0YsSUFKRCxFQUlHMW5CLFVBQVUsQ0FKYjtBQUtBcEssTUFBR2hHLGdCQUFILENBQW9CL0wsS0FBcEIsRUFBMkI4akMsS0FBM0I7QUFDRDs7QUFFRCxLQUFJQyxjQUFjLHdCQUFsQjs7QUFFQSxVQUFTTCxpQkFBVCxDQUE0QjN4QixFQUE1QixFQUFnQzhELFlBQWhDLEVBQThDO0FBQzVDLE9BQUltdUIsU0FBUy9vQyxPQUFPZ3BDLGdCQUFQLENBQXdCbHlCLEVBQXhCLENBQWI7QUFDQSxPQUFJbXlCLG1CQUFtQkYsT0FBT3JCLGlCQUFpQixPQUF4QixFQUFpQ3gvQixLQUFqQyxDQUF1QyxJQUF2QyxDQUF2QjtBQUNBLE9BQUlnaEMsc0JBQXNCSCxPQUFPckIsaUJBQWlCLFVBQXhCLEVBQW9DeC9CLEtBQXBDLENBQTBDLElBQTFDLENBQTFCO0FBQ0EsT0FBSWloQyxvQkFBb0JDLFdBQVdILGdCQUFYLEVBQTZCQyxtQkFBN0IsQ0FBeEI7QUFDQSxPQUFJRyxrQkFBa0JOLE9BQU9uQixnQkFBZ0IsT0FBdkIsRUFBZ0MxL0IsS0FBaEMsQ0FBc0MsSUFBdEMsQ0FBdEI7QUFDQSxPQUFJb2hDLHFCQUFxQlAsT0FBT25CLGdCQUFnQixVQUF2QixFQUFtQzEvQixLQUFuQyxDQUF5QyxJQUF6QyxDQUF6QjtBQUNBLE9BQUlxaEMsbUJBQW1CSCxXQUFXQyxlQUFYLEVBQTRCQyxrQkFBNUIsQ0FBdkI7O0FBRUEsT0FBSXJ4QixJQUFKO0FBQ0EsT0FBSWlKLFVBQVUsQ0FBZDtBQUNBLE9BQUl3bkIsWUFBWSxDQUFoQjtBQUNBO0FBQ0EsT0FBSTl0QixpQkFBaUI0c0IsVUFBckIsRUFBaUM7QUFDL0IsU0FBSTJCLG9CQUFvQixDQUF4QixFQUEyQjtBQUN6Qmx4QixjQUFPdXZCLFVBQVA7QUFDQXRtQixpQkFBVWlvQixpQkFBVjtBQUNBVCxtQkFBWVEsb0JBQW9CbHFDLE1BQWhDO0FBQ0Q7QUFDRixJQU5ELE1BTU8sSUFBSTRiLGlCQUFpQjZzQixTQUFyQixFQUFnQztBQUNyQyxTQUFJOEIsbUJBQW1CLENBQXZCLEVBQTBCO0FBQ3hCdHhCLGNBQU93dkIsU0FBUDtBQUNBdm1CLGlCQUFVcW9CLGdCQUFWO0FBQ0FiLG1CQUFZWSxtQkFBbUJ0cUMsTUFBL0I7QUFDRDtBQUNGLElBTk0sTUFNQTtBQUNMa2lCLGVBQVU5WixLQUFLdVAsR0FBTCxDQUFTd3lCLGlCQUFULEVBQTRCSSxnQkFBNUIsQ0FBVjtBQUNBdHhCLFlBQU9pSixVQUFVLENBQVYsR0FDSGlvQixvQkFBb0JJLGdCQUFwQixHQUNFL0IsVUFERixHQUVFQyxTQUhDLEdBSUgsSUFKSjtBQUtBaUIsaUJBQVl6d0IsT0FDUkEsU0FBU3V2QixVQUFULEdBQ0UwQixvQkFBb0JscUMsTUFEdEIsR0FFRXNxQyxtQkFBbUJ0cUMsTUFIYixHQUlSLENBSko7QUFLRDtBQUNELE9BQUl3cUMsZUFDRnZ4QixTQUFTdXZCLFVBQVQsSUFDQXNCLFlBQVk3NkIsSUFBWixDQUFpQjg2QixPQUFPckIsaUJBQWlCLFVBQXhCLENBQWpCLENBRkY7QUFHQSxVQUFPO0FBQ0x6dkIsV0FBTUEsSUFERDtBQUVMaUosY0FBU0EsT0FGSjtBQUdMd25CLGdCQUFXQSxTQUhOO0FBSUxjLG1CQUFjQTtBQUpULElBQVA7QUFNRDs7QUFFRCxVQUFTSixVQUFULENBQXFCSyxNQUFyQixFQUE2QkMsU0FBN0IsRUFBd0M7QUFDdEM7QUFDQSxVQUFPRCxPQUFPenFDLE1BQVAsR0FBZ0IwcUMsVUFBVTFxQyxNQUFqQyxFQUF5QztBQUN2Q3lxQyxjQUFTQSxPQUFPMStCLE1BQVAsQ0FBYzArQixNQUFkLENBQVQ7QUFDRDs7QUFFRCxVQUFPcmlDLEtBQUt1UCxHQUFMLENBQVNwWSxLQUFULENBQWUsSUFBZixFQUFxQm1yQyxVQUFVM2hDLEdBQVYsQ0FBYyxVQUFVOUMsQ0FBVixFQUFhbEcsQ0FBYixFQUFnQjtBQUN4RCxZQUFPNHFDLEtBQUsxa0MsQ0FBTCxJQUFVMGtDLEtBQUtGLE9BQU8xcUMsQ0FBUCxDQUFMLENBQWpCO0FBQ0QsSUFGMkIsQ0FBckIsQ0FBUDtBQUdEOztBQUVELFVBQVM0cUMsSUFBVCxDQUFlQyxDQUFmLEVBQWtCO0FBQ2hCLFVBQU9DLE9BQU9ELEVBQUVqcEMsS0FBRixDQUFRLENBQVIsRUFBVyxDQUFDLENBQVosQ0FBUCxJQUF5QixJQUFoQztBQUNEOztBQUVEOztBQUVBLFVBQVNtcEMsS0FBVCxDQUFnQmxzQixLQUFoQixFQUF1Qm1zQixhQUF2QixFQUFzQztBQUNwQyxPQUFJanpCLEtBQUs4RyxNQUFNckIsR0FBZjs7QUFFQTtBQUNBLE9BQUlqVyxNQUFNd1EsR0FBR2ltQixRQUFULENBQUosRUFBd0I7QUFDdEJqbUIsUUFBR2ltQixRQUFILENBQVlpTixTQUFaLEdBQXdCLElBQXhCO0FBQ0FsekIsUUFBR2ltQixRQUFIO0FBQ0Q7O0FBRUQsT0FBSXo0QixPQUFPdWlDLGtCQUFrQmpwQixNQUFNdFosSUFBTixDQUFXeTFCLFVBQTdCLENBQVg7QUFDQSxPQUFJM3pCLFFBQVE5QixJQUFSLENBQUosRUFBbUI7QUFDakI7QUFDRDs7QUFFRDtBQUNBLE9BQUlnQyxNQUFNd1EsR0FBR216QixRQUFULEtBQXNCbnpCLEdBQUd5bEIsUUFBSCxLQUFnQixDQUExQyxFQUE2QztBQUMzQztBQUNEOztBQUVELE9BQUl3SyxNQUFNemlDLEtBQUt5aUMsR0FBZjtBQUNBLE9BQUk5dUIsT0FBTzNULEtBQUsyVCxJQUFoQjtBQUNBLE9BQUlndkIsYUFBYTNpQyxLQUFLMmlDLFVBQXRCO0FBQ0EsT0FBSUMsZUFBZTVpQyxLQUFLNGlDLFlBQXhCO0FBQ0EsT0FBSUMsbUJBQW1CN2lDLEtBQUs2aUMsZ0JBQTVCO0FBQ0EsT0FBSStDLGNBQWM1bEMsS0FBSzRsQyxXQUF2QjtBQUNBLE9BQUlDLGdCQUFnQjdsQyxLQUFLNmxDLGFBQXpCO0FBQ0EsT0FBSUMsb0JBQW9COWxDLEtBQUs4bEMsaUJBQTdCO0FBQ0EsT0FBSUMsY0FBYy9sQyxLQUFLK2xDLFdBQXZCO0FBQ0EsT0FBSVAsUUFBUXhsQyxLQUFLd2xDLEtBQWpCO0FBQ0EsT0FBSVEsYUFBYWhtQyxLQUFLZ21DLFVBQXRCO0FBQ0EsT0FBSUMsaUJBQWlCam1DLEtBQUtpbUMsY0FBMUI7QUFDQSxPQUFJQyxlQUFlbG1DLEtBQUtrbUMsWUFBeEI7QUFDQSxPQUFJQyxTQUFTbm1DLEtBQUttbUMsTUFBbEI7QUFDQSxPQUFJQyxjQUFjcG1DLEtBQUtvbUMsV0FBdkI7QUFDQSxPQUFJQyxrQkFBa0JybUMsS0FBS3FtQyxlQUEzQjtBQUNBLE9BQUlDLFdBQVd0bUMsS0FBS3NtQyxRQUFwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQUlwdUIsVUFBVXFHLGNBQWQ7QUFDQSxPQUFJZ29CLGlCQUFpQmhvQixlQUFleUIsTUFBcEM7QUFDQSxVQUFPdW1CLGtCQUFrQkEsZUFBZTd6QixNQUF4QyxFQUFnRDtBQUM5QzZ6QixzQkFBaUJBLGVBQWU3ekIsTUFBaEM7QUFDQXdGLGVBQVVxdUIsZUFBZXJ1QixPQUF6QjtBQUNEOztBQUVELE9BQUlzdUIsV0FBVyxDQUFDdHVCLFFBQVE4RyxVQUFULElBQXVCLENBQUMxRixNQUFNWixZQUE3Qzs7QUFFQSxPQUFJOHRCLFlBQVksQ0FBQ0wsTUFBYixJQUF1QkEsV0FBVyxFQUF0QyxFQUEwQztBQUN4QztBQUNEOztBQUVELE9BQUlNLGFBQWFELFlBQVlaLFdBQVosR0FDYkEsV0FEYSxHQUViakQsVUFGSjtBQUdBLE9BQUkrRCxjQUFjRixZQUFZVixpQkFBWixHQUNkQSxpQkFEYyxHQUVkakQsZ0JBRko7QUFHQSxPQUFJOEQsVUFBVUgsWUFBWVgsYUFBWixHQUNWQSxhQURVLEdBRVZqRCxZQUZKOztBQUlBLE9BQUlnRSxrQkFBa0JKLFdBQ2pCTixnQkFBZ0JILFdBREMsR0FFbEJBLFdBRko7QUFHQSxPQUFJYyxZQUFZTCxXQUNYLE9BQU9MLE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQS9CLEdBQXdDWCxLQUQ3QixHQUVaQSxLQUZKO0FBR0EsT0FBSXNCLGlCQUFpQk4sV0FDaEJKLGVBQWVKLFVBREMsR0FFakJBLFVBRko7QUFHQSxPQUFJZSxxQkFBcUJQLFdBQ3BCSCxtQkFBbUJKLGNBREMsR0FFckJBLGNBRko7O0FBSUEsT0FBSWUsd0JBQXdCNWpDLFNBQzFCZixTQUFTaWtDLFFBQVQsSUFDSUEsU0FBU2QsS0FEYixHQUVJYyxRQUhzQixDQUE1Qjs7QUFNQSxPQUFJditCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QysrQix5QkFBeUIsSUFBdEUsRUFBNEU7QUFDMUVDLG1CQUFjRCxxQkFBZCxFQUFxQyxPQUFyQyxFQUE4QzF0QixLQUE5QztBQUNEOztBQUVELE9BQUk0dEIsYUFBYXpFLFFBQVEsS0FBUixJQUFpQixDQUFDMzJCLEtBQW5DO0FBQ0EsT0FBSXE3QixtQkFBbUJDLHVCQUF1QlAsU0FBdkIsQ0FBdkI7O0FBRUEsT0FBSXY0QixLQUFLa0UsR0FBR216QixRQUFILEdBQWNyK0IsS0FBSyxZQUFZO0FBQ3RDLFNBQUk0L0IsVUFBSixFQUFnQjtBQUNkakQsNkJBQXNCenhCLEVBQXRCLEVBQTBCbTBCLE9BQTFCO0FBQ0ExQyw2QkFBc0J6eEIsRUFBdEIsRUFBMEJrMEIsV0FBMUI7QUFDRDtBQUNELFNBQUlwNEIsR0FBR28zQixTQUFQLEVBQWtCO0FBQ2hCLFdBQUl3QixVQUFKLEVBQWdCO0FBQ2RqRCwrQkFBc0J6eEIsRUFBdEIsRUFBMEJpMEIsVUFBMUI7QUFDRDtBQUNETSw2QkFBc0JBLG1CQUFtQnYwQixFQUFuQixDQUF0QjtBQUNELE1BTEQsTUFLTztBQUNMczBCLHlCQUFrQkEsZUFBZXQwQixFQUFmLENBQWxCO0FBQ0Q7QUFDREEsUUFBR216QixRQUFILEdBQWMsSUFBZDtBQUNELElBZHNCLENBQXZCOztBQWdCQSxPQUFJLENBQUNyc0IsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFoQixFQUFzQjtBQUNwQjtBQUNBN3NCLG9CQUFlbEIsTUFBTXRaLElBQU4sQ0FBV3lULElBQVgsS0FBb0I2RixNQUFNdFosSUFBTixDQUFXeVQsSUFBWCxHQUFrQixFQUF0QyxDQUFmLEVBQTBELFFBQTFELEVBQW9FLFlBQVk7QUFDOUUsV0FBSWYsU0FBU0YsR0FBRzBlLFVBQWhCO0FBQ0EsV0FBSW9XLGNBQWM1MEIsVUFBVUEsT0FBTzYwQixRQUFqQixJQUE2QjcwQixPQUFPNjBCLFFBQVAsQ0FBZ0JqdUIsTUFBTWhWLEdBQXRCLENBQS9DO0FBQ0EsV0FBSWdqQyxlQUNGQSxZQUFZeHdCLEdBQVosS0FBb0J3QyxNQUFNeEMsR0FEeEIsSUFFRnd3QixZQUFZcnZCLEdBQVosQ0FBZ0J3Z0IsUUFGbEIsRUFHRTtBQUNBNk8scUJBQVlydkIsR0FBWixDQUFnQndnQixRQUFoQjtBQUNEO0FBQ0RvTyxvQkFBYUEsVUFBVXIwQixFQUFWLEVBQWNsRSxFQUFkLENBQWI7QUFDRCxNQVZEO0FBV0Q7O0FBRUQ7QUFDQXM0QixzQkFBbUJBLGdCQUFnQnAwQixFQUFoQixDQUFuQjtBQUNBLE9BQUkwMEIsVUFBSixFQUFnQjtBQUNkbkQsd0JBQW1CdnhCLEVBQW5CLEVBQXVCaTBCLFVBQXZCO0FBQ0ExQyx3QkFBbUJ2eEIsRUFBbkIsRUFBdUJrMEIsV0FBdkI7QUFDQTVDLGVBQVUsWUFBWTtBQUNwQkMsMEJBQW1CdnhCLEVBQW5CLEVBQXVCbTBCLE9BQXZCO0FBQ0ExQyw2QkFBc0J6eEIsRUFBdEIsRUFBMEJpMEIsVUFBMUI7QUFDQSxXQUFJLENBQUNuNEIsR0FBR28zQixTQUFKLElBQWlCLENBQUN5QixnQkFBdEIsRUFBd0M7QUFDdEMsYUFBSUssZ0JBQWdCUixxQkFBaEIsQ0FBSixFQUE0QztBQUMxQ241QixzQkFBV1MsRUFBWCxFQUFlMDRCLHFCQUFmO0FBQ0QsVUFGRCxNQUVPO0FBQ0w5Qyw4QkFBbUIxeEIsRUFBbkIsRUFBdUJtQixJQUF2QixFQUE2QnJGLEVBQTdCO0FBQ0Q7QUFDRjtBQUNGLE1BVkQ7QUFXRDs7QUFFRCxPQUFJZ0wsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFmLEVBQXFCO0FBQ25CNUIsc0JBQWlCQSxlQUFqQjtBQUNBb0Isa0JBQWFBLFVBQVVyMEIsRUFBVixFQUFjbEUsRUFBZCxDQUFiO0FBQ0Q7O0FBRUQsT0FBSSxDQUFDNDRCLFVBQUQsSUFBZSxDQUFDQyxnQkFBcEIsRUFBc0M7QUFDcEM3NEI7QUFDRDtBQUNGOztBQUVELFVBQVNtNUIsS0FBVCxDQUFnQm51QixLQUFoQixFQUF1QjhjLEVBQXZCLEVBQTJCO0FBQ3pCLE9BQUk1akIsS0FBSzhHLE1BQU1yQixHQUFmOztBQUVBO0FBQ0EsT0FBSWpXLE1BQU13USxHQUFHbXpCLFFBQVQsQ0FBSixFQUF3QjtBQUN0Qm56QixRQUFHbXpCLFFBQUgsQ0FBWUQsU0FBWixHQUF3QixJQUF4QjtBQUNBbHpCLFFBQUdtekIsUUFBSDtBQUNEOztBQUVELE9BQUkzbEMsT0FBT3VpQyxrQkFBa0JqcEIsTUFBTXRaLElBQU4sQ0FBV3kxQixVQUE3QixDQUFYO0FBQ0EsT0FBSTN6QixRQUFROUIsSUFBUixDQUFKLEVBQW1CO0FBQ2pCLFlBQU9vMkIsSUFBUDtBQUNEOztBQUVEO0FBQ0EsT0FBSXAwQixNQUFNd1EsR0FBR2ltQixRQUFULEtBQXNCam1CLEdBQUd5bEIsUUFBSCxLQUFnQixDQUExQyxFQUE2QztBQUMzQztBQUNEOztBQUVELE9BQUl3SyxNQUFNemlDLEtBQUt5aUMsR0FBZjtBQUNBLE9BQUk5dUIsT0FBTzNULEtBQUsyVCxJQUFoQjtBQUNBLE9BQUltdkIsYUFBYTlpQyxLQUFLOGlDLFVBQXRCO0FBQ0EsT0FBSUMsZUFBZS9pQyxLQUFLK2lDLFlBQXhCO0FBQ0EsT0FBSUMsbUJBQW1CaGpDLEtBQUtnakMsZ0JBQTVCO0FBQ0EsT0FBSTBFLGNBQWMxbkMsS0FBSzBuQyxXQUF2QjtBQUNBLE9BQUlELFFBQVF6bkMsS0FBS3luQyxLQUFqQjtBQUNBLE9BQUlFLGFBQWEzbkMsS0FBSzJuQyxVQUF0QjtBQUNBLE9BQUlDLGlCQUFpQjVuQyxLQUFLNG5DLGNBQTFCO0FBQ0EsT0FBSUMsYUFBYTduQyxLQUFLNm5DLFVBQXRCO0FBQ0EsT0FBSXZCLFdBQVd0bUMsS0FBS3NtQyxRQUFwQjs7QUFFQSxPQUFJWSxhQUFhekUsUUFBUSxLQUFSLElBQWlCLENBQUMzMkIsS0FBbkM7QUFDQSxPQUFJcTdCLG1CQUFtQkMsdUJBQXVCSyxLQUF2QixDQUF2Qjs7QUFFQSxPQUFJSyx3QkFBd0Ixa0MsU0FDMUJmLFNBQVNpa0MsUUFBVCxJQUNJQSxTQUFTbUIsS0FEYixHQUVJbkIsUUFIc0IsQ0FBNUI7O0FBTUEsT0FBSXYrQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNqRyxNQUFNOGxDLHFCQUFOLENBQTdDLEVBQTJFO0FBQ3pFYixtQkFBY2EscUJBQWQsRUFBcUMsT0FBckMsRUFBOEN4dUIsS0FBOUM7QUFDRDs7QUFFRCxPQUFJaEwsS0FBS2tFLEdBQUdpbUIsUUFBSCxHQUFjbnhCLEtBQUssWUFBWTtBQUN0QyxTQUFJa0wsR0FBRzBlLFVBQUgsSUFBaUIxZSxHQUFHMGUsVUFBSCxDQUFjcVcsUUFBbkMsRUFBNkM7QUFDM0MvMEIsVUFBRzBlLFVBQUgsQ0FBY3FXLFFBQWQsQ0FBdUJqdUIsTUFBTWhWLEdBQTdCLElBQW9DLElBQXBDO0FBQ0Q7QUFDRCxTQUFJNGlDLFVBQUosRUFBZ0I7QUFDZGpELDZCQUFzQnp4QixFQUF0QixFQUEwQnV3QixZQUExQjtBQUNBa0IsNkJBQXNCenhCLEVBQXRCLEVBQTBCd3dCLGdCQUExQjtBQUNEO0FBQ0QsU0FBSTEwQixHQUFHbzNCLFNBQVAsRUFBa0I7QUFDaEIsV0FBSXdCLFVBQUosRUFBZ0I7QUFDZGpELCtCQUFzQnp4QixFQUF0QixFQUEwQnN3QixVQUExQjtBQUNEO0FBQ0Q4RSx5QkFBa0JBLGVBQWVwMUIsRUFBZixDQUFsQjtBQUNELE1BTEQsTUFLTztBQUNMNGpCO0FBQ0F1UixxQkFBY0EsV0FBV24xQixFQUFYLENBQWQ7QUFDRDtBQUNEQSxRQUFHaW1CLFFBQUgsR0FBYyxJQUFkO0FBQ0QsSUFsQnNCLENBQXZCOztBQW9CQSxPQUFJb1AsVUFBSixFQUFnQjtBQUNkQSxnQkFBV0UsWUFBWDtBQUNELElBRkQsTUFFTztBQUNMQTtBQUNEOztBQUVELFlBQVNBLFlBQVQsR0FBeUI7QUFDdkI7QUFDQSxTQUFJejVCLEdBQUdvM0IsU0FBUCxFQUFrQjtBQUNoQjtBQUNEO0FBQ0Q7QUFDQSxTQUFJLENBQUNwc0IsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFoQixFQUFzQjtBQUNwQixRQUFDNzBCLEdBQUcwZSxVQUFILENBQWNxVyxRQUFkLEtBQTJCLzBCLEdBQUcwZSxVQUFILENBQWNxVyxRQUFkLEdBQXlCLEVBQXBELENBQUQsRUFBMkRqdUIsTUFBTWhWLEdBQWpFLElBQXlFZ1YsS0FBekU7QUFDRDtBQUNEb3VCLG9CQUFlQSxZQUFZbDFCLEVBQVosQ0FBZjtBQUNBLFNBQUkwMEIsVUFBSixFQUFnQjtBQUNkbkQsMEJBQW1CdnhCLEVBQW5CLEVBQXVCc3dCLFVBQXZCO0FBQ0FpQiwwQkFBbUJ2eEIsRUFBbkIsRUFBdUJ3d0IsZ0JBQXZCO0FBQ0FjLGlCQUFVLFlBQVk7QUFDcEJDLDRCQUFtQnZ4QixFQUFuQixFQUF1QnV3QixZQUF2QjtBQUNBa0IsK0JBQXNCenhCLEVBQXRCLEVBQTBCc3dCLFVBQTFCO0FBQ0EsYUFBSSxDQUFDeDBCLEdBQUdvM0IsU0FBSixJQUFpQixDQUFDeUIsZ0JBQXRCLEVBQXdDO0FBQ3RDLGVBQUlLLGdCQUFnQk0scUJBQWhCLENBQUosRUFBNEM7QUFDMUNqNkIsd0JBQVdTLEVBQVgsRUFBZXc1QixxQkFBZjtBQUNELFlBRkQsTUFFTztBQUNMNUQsZ0NBQW1CMXhCLEVBQW5CLEVBQXVCbUIsSUFBdkIsRUFBNkJyRixFQUE3QjtBQUNEO0FBQ0Y7QUFDRixRQVZEO0FBV0Q7QUFDRG01QixjQUFTQSxNQUFNajFCLEVBQU4sRUFBVWxFLEVBQVYsQ0FBVDtBQUNBLFNBQUksQ0FBQzQ0QixVQUFELElBQWUsQ0FBQ0MsZ0JBQXBCLEVBQXNDO0FBQ3BDNzRCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsVUFBUzI0QixhQUFULENBQXdCdGtDLEdBQXhCLEVBQTZCM0gsSUFBN0IsRUFBbUNzZSxLQUFuQyxFQUEwQztBQUN4QyxPQUFJLE9BQU8zVyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0JrSCxVQUNFLDJCQUEyQjdPLElBQTNCLEdBQWtDLG9DQUFsQyxHQUNBLE1BREEsR0FDVWlJLEtBQUtDLFNBQUwsQ0FBZVAsR0FBZixDQURWLEdBQ2lDLEdBRm5DLEVBR0UyVyxNQUFNcEIsT0FIUjtBQUtELElBTkQsTUFNTyxJQUFJN1UsTUFBTVYsR0FBTixDQUFKLEVBQWdCO0FBQ3JCa0gsVUFDRSwyQkFBMkI3TyxJQUEzQixHQUFrQyxxQkFBbEMsR0FDQSw2Q0FGRixFQUdFc2UsTUFBTXBCLE9BSFI7QUFLRDtBQUNGOztBQUVELFVBQVNzdkIsZUFBVCxDQUEwQjdrQyxHQUExQixFQUErQjtBQUM3QixVQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLENBQUNVLE1BQU1WLEdBQU4sQ0FBbkM7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsVUFBU3lrQyxzQkFBVCxDQUFpQzVpQyxFQUFqQyxFQUFxQztBQUNuQyxPQUFJMUMsUUFBUTBDLEVBQVIsQ0FBSixFQUFpQjtBQUNmLFlBQU8sS0FBUDtBQUNEO0FBQ0QsT0FBSXdqQyxhQUFheGpDLEdBQUd1VixHQUFwQjtBQUNBLE9BQUkvWCxNQUFNZ21DLFVBQU4sQ0FBSixFQUF1QjtBQUNyQjtBQUNBLFlBQU9aLHVCQUNMdmhDLE1BQU1tQixPQUFOLENBQWNnaEMsVUFBZCxJQUNJQSxXQUFXLENBQVgsQ0FESixHQUVJQSxVQUhDLENBQVA7QUFLRCxJQVBELE1BT087QUFDTCxZQUFPLENBQUN4akMsR0FBR2lCLE9BQUgsSUFBY2pCLEdBQUc5SixNQUFsQixJQUE0QixDQUFuQztBQUNEO0FBQ0Y7O0FBRUQsVUFBU3V0QyxNQUFULENBQWlCbGpDLENBQWpCLEVBQW9CdVUsS0FBcEIsRUFBMkI7QUFDekIsT0FBSUEsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFYLEtBQW9CLElBQXhCLEVBQThCO0FBQzVCN0IsV0FBTWxzQixLQUFOO0FBQ0Q7QUFDRjs7QUFFRCxLQUFJbWMsYUFBYWpxQixZQUFZO0FBQzNCOUgsV0FBUXVrQyxNQURtQjtBQUUzQnZTLGFBQVV1UyxNQUZpQjtBQUczQmprQyxXQUFRLFNBQVNxVyxTQUFULENBQW9CZixLQUFwQixFQUEyQjhjLEVBQTNCLEVBQStCO0FBQ3JDO0FBQ0EsU0FBSTljLE1BQU10WixJQUFOLENBQVdxbkMsSUFBWCxLQUFvQixJQUF4QixFQUE4QjtBQUM1QkksYUFBTW51QixLQUFOLEVBQWE4YyxFQUFiO0FBQ0QsTUFGRCxNQUVPO0FBQ0xBO0FBQ0Q7QUFDRjtBQVYwQixFQUFaLEdBV2IsRUFYSjs7QUFhQSxLQUFJOFIsa0JBQWtCLENBQ3BCcHRCLEtBRG9CLEVBRXBCMmYsS0FGb0IsRUFHcEIwQixNQUhvQixFQUlwQnZSLFFBSm9CLEVBS3BCZ1csS0FMb0IsRUFNcEJuTCxVQU5vQixDQUF0Qjs7QUFTQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSW52QixVQUFVNGhDLGdCQUFnQnpoQyxNQUFoQixDQUF1Qm16QixXQUF2QixDQUFkOztBQUVBLEtBQUkxQixRQUFRN0Qsb0JBQW9CLEVBQUVkLFNBQVNBLE9BQVgsRUFBb0JqdEIsU0FBU0EsT0FBN0IsRUFBcEIsQ0FBWjs7QUFFQTs7Ozs7QUFLQSxLQUFJNmhDLGtCQUFrQjdrQyxRQUFRLDJDQUFSLENBQXRCOztBQUVBO0FBQ0EsS0FBSXdJLEtBQUosRUFBVztBQUNUO0FBQ0FqUSxZQUFTMlEsZ0JBQVQsQ0FBMEIsaUJBQTFCLEVBQTZDLFlBQVk7QUFDdkQsU0FBSWdHLEtBQUszVyxTQUFTd2tDLGFBQWxCO0FBQ0EsU0FBSTd0QixNQUFNQSxHQUFHNDFCLE1BQWIsRUFBcUI7QUFDbkJDLGVBQVE3MUIsRUFBUixFQUFZLE9BQVo7QUFDRDtBQUNGLElBTEQ7QUFNRDs7QUFFRCxLQUFJODFCLFVBQVU7QUFDWi8zQixhQUFVLFNBQVNBLFFBQVQsQ0FBbUJpQyxFQUFuQixFQUF1QisxQixPQUF2QixFQUFnQ2p2QixLQUFoQyxFQUF1QztBQUMvQyxTQUFJQSxNQUFNeEMsR0FBTixLQUFjLFFBQWxCLEVBQTRCO0FBQzFCLFdBQUl4SSxLQUFLLFNBQUxBLEVBQUssR0FBWTtBQUNuQms2QixxQkFBWWgyQixFQUFaLEVBQWdCKzFCLE9BQWhCLEVBQXlCanZCLE1BQU1wQixPQUEvQjtBQUNELFFBRkQ7QUFHQTVKO0FBQ0E7QUFDQSxXQUFJekMsUUFBUUUsTUFBWixFQUFvQjtBQUNsQjhCLG9CQUFXUyxFQUFYLEVBQWUsQ0FBZjtBQUNEO0FBQ0RrRSxVQUFHaTJCLFNBQUgsR0FBZSxHQUFHaGxDLEdBQUgsQ0FBTzFKLElBQVAsQ0FBWXlZLEdBQUdoSSxPQUFmLEVBQXdCaytCLFFBQXhCLENBQWY7QUFDRCxNQVZELE1BVU8sSUFBSXB2QixNQUFNeEMsR0FBTixLQUFjLFVBQWQsSUFBNEJxeEIsZ0JBQWdCMzFCLEdBQUdtQixJQUFuQixDQUFoQyxFQUEwRDtBQUMvRG5CLFVBQUc4dEIsV0FBSCxHQUFpQmlJLFFBQVE5TyxTQUF6QjtBQUNBLFdBQUksQ0FBQzhPLFFBQVE5TyxTQUFSLENBQWtCcFcsSUFBdkIsRUFBNkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTdRLFlBQUdoRyxnQkFBSCxDQUFvQixRQUFwQixFQUE4Qm04QixnQkFBOUI7QUFDQSxhQUFJLENBQUMzOEIsU0FBTCxFQUFnQjtBQUNkd0csY0FBR2hHLGdCQUFILENBQW9CLGtCQUFwQixFQUF3Q284QixrQkFBeEM7QUFDQXAyQixjQUFHaEcsZ0JBQUgsQ0FBb0IsZ0JBQXBCLEVBQXNDbThCLGdCQUF0QztBQUNEO0FBQ0Q7QUFDQSxhQUFJNzhCLEtBQUosRUFBVztBQUNUMEcsY0FBRzQxQixNQUFILEdBQVksSUFBWjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLElBOUJXO0FBK0JaOU8scUJBQWtCLFNBQVNBLGdCQUFULENBQTJCOW1CLEVBQTNCLEVBQStCKzFCLE9BQS9CLEVBQXdDanZCLEtBQXhDLEVBQStDO0FBQy9ELFNBQUlBLE1BQU14QyxHQUFOLEtBQWMsUUFBbEIsRUFBNEI7QUFDMUIweEIsbUJBQVloMkIsRUFBWixFQUFnQisxQixPQUFoQixFQUF5Qmp2QixNQUFNcEIsT0FBL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUkyd0IsY0FBY3IyQixHQUFHaTJCLFNBQXJCO0FBQ0EsV0FBSUssYUFBYXQyQixHQUFHaTJCLFNBQUgsR0FBZSxHQUFHaGxDLEdBQUgsQ0FBTzFKLElBQVAsQ0FBWXlZLEdBQUdoSSxPQUFmLEVBQXdCaytCLFFBQXhCLENBQWhDO0FBQ0EsV0FBSUksV0FBV0MsSUFBWCxDQUFnQixVQUFVQyxDQUFWLEVBQWF2dUMsQ0FBYixFQUFnQjtBQUFFLGdCQUFPLENBQUNtTSxXQUFXb2lDLENBQVgsRUFBY0gsWUFBWXB1QyxDQUFaLENBQWQsQ0FBUjtBQUF3QyxRQUExRSxDQUFKLEVBQWlGO0FBQy9FNHRDLGlCQUFRNzFCLEVBQVIsRUFBWSxRQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBNUNXLEVBQWQ7O0FBK0NBLFVBQVNnMkIsV0FBVCxDQUFzQmgyQixFQUF0QixFQUEwQisxQixPQUExQixFQUFtQ24rQixFQUFuQyxFQUF1QztBQUNyQyxPQUFJaEksUUFBUW1tQyxRQUFRbm1DLEtBQXBCO0FBQ0EsT0FBSTZtQyxhQUFhejJCLEdBQUdrZ0IsUUFBcEI7QUFDQSxPQUFJdVcsY0FBYyxDQUFDcGpDLE1BQU1tQixPQUFOLENBQWM1RSxLQUFkLENBQW5CLEVBQXlDO0FBQ3ZDMkYsYUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsZ0NBQWlDMCtCLFFBQVE3bEIsVUFBekMsR0FBdUQsTUFBdkQsR0FDQSxrREFEQSxHQUNzRHJoQixPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpCLENBQTBCeEksSUFBMUIsQ0FBK0JxSSxLQUEvQixFQUFzQy9GLEtBQXRDLENBQTRDLENBQTVDLEVBQStDLENBQUMsQ0FBaEQsQ0FGZixFQUd2QytOLEVBSHVDLENBQXpDO0FBS0E7QUFDRDtBQUNELE9BQUlrb0IsUUFBSixFQUFjck4sTUFBZDtBQUNBLFFBQUssSUFBSXhxQixJQUFJLENBQVIsRUFBVytLLElBQUlnTixHQUFHaEksT0FBSCxDQUFXOVAsTUFBL0IsRUFBdUNELElBQUkrSyxDQUEzQyxFQUE4Qy9LLEdBQTlDLEVBQW1EO0FBQ2pEd3FCLGNBQVN6UyxHQUFHaEksT0FBSCxDQUFXL1AsQ0FBWCxDQUFUO0FBQ0EsU0FBSXd1QyxVQUFKLEVBQWdCO0FBQ2QzVyxrQkFBV2pyQixhQUFhakYsS0FBYixFQUFvQnNtQyxTQUFTempCLE1BQVQsQ0FBcEIsSUFBd0MsQ0FBQyxDQUFwRDtBQUNBLFdBQUlBLE9BQU9xTixRQUFQLEtBQW9CQSxRQUF4QixFQUFrQztBQUNoQ3JOLGdCQUFPcU4sUUFBUCxHQUFrQkEsUUFBbEI7QUFDRDtBQUNGLE1BTEQsTUFLTztBQUNMLFdBQUkxckIsV0FBVzhoQyxTQUFTempCLE1BQVQsQ0FBWCxFQUE2QjdpQixLQUE3QixDQUFKLEVBQXlDO0FBQ3ZDLGFBQUlvUSxHQUFHMDJCLGFBQUgsS0FBcUJ6dUMsQ0FBekIsRUFBNEI7QUFDMUIrWCxjQUFHMDJCLGFBQUgsR0FBbUJ6dUMsQ0FBbkI7QUFDRDtBQUNEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsT0FBSSxDQUFDd3VDLFVBQUwsRUFBaUI7QUFDZnoyQixRQUFHMDJCLGFBQUgsR0FBbUIsQ0FBQyxDQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU1IsUUFBVCxDQUFtQnpqQixNQUFuQixFQUEyQjtBQUN6QixVQUFPLFlBQVlBLE1BQVosR0FDSEEsT0FBTzRhLE1BREosR0FFSDVhLE9BQU83aUIsS0FGWDtBQUdEOztBQUVELFVBQVN3bUMsa0JBQVQsQ0FBNkI1dUMsQ0FBN0IsRUFBZ0M7QUFDOUJBLEtBQUVxVixNQUFGLENBQVM0d0IsU0FBVCxHQUFxQixJQUFyQjtBQUNEOztBQUVELFVBQVMwSSxnQkFBVCxDQUEyQjN1QyxDQUEzQixFQUE4QjtBQUM1QjtBQUNBLE9BQUksQ0FBQ0EsRUFBRXFWLE1BQUYsQ0FBUzR3QixTQUFkLEVBQXlCO0FBQUU7QUFBUTtBQUNuQ2ptQyxLQUFFcVYsTUFBRixDQUFTNHdCLFNBQVQsR0FBcUIsS0FBckI7QUFDQW9JLFdBQVFydUMsRUFBRXFWLE1BQVYsRUFBa0IsT0FBbEI7QUFDRDs7QUFFRCxVQUFTZzVCLE9BQVQsQ0FBa0I3MUIsRUFBbEIsRUFBc0JtQixJQUF0QixFQUE0QjtBQUMxQixPQUFJM1osSUFBSTZCLFNBQVNzdEMsV0FBVCxDQUFxQixZQUFyQixDQUFSO0FBQ0FudkMsS0FBRW92QyxTQUFGLENBQVl6MUIsSUFBWixFQUFrQixJQUFsQixFQUF3QixJQUF4QjtBQUNBbkIsTUFBRzYyQixhQUFILENBQWlCcnZDLENBQWpCO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQSxVQUFTc3ZDLFVBQVQsQ0FBcUJod0IsS0FBckIsRUFBNEI7QUFDMUIsVUFBT0EsTUFBTWYsaUJBQU4sS0FBNEIsQ0FBQ2UsTUFBTXRaLElBQVAsSUFBZSxDQUFDc1osTUFBTXRaLElBQU4sQ0FBV3kxQixVQUF2RCxJQUNINlQsV0FBV2h3QixNQUFNZixpQkFBTixDQUF3Qm1ILE1BQW5DLENBREcsR0FFSHBHLEtBRko7QUFHRDs7QUFFRCxLQUFJK3RCLE9BQU87QUFDVHp0QyxTQUFNLFNBQVNBLElBQVQsQ0FBZTRZLEVBQWYsRUFBbUJxWixHQUFuQixFQUF3QnZTLEtBQXhCLEVBQStCO0FBQ25DLFNBQUlsWCxRQUFReXBCLElBQUl6cEIsS0FBaEI7O0FBRUFrWCxhQUFRZ3dCLFdBQVdod0IsS0FBWCxDQUFSO0FBQ0EsU0FBSWl3QixnQkFBZ0Jqd0IsTUFBTXRaLElBQU4sSUFBY3NaLE1BQU10WixJQUFOLENBQVd5MUIsVUFBN0M7QUFDQSxTQUFJK1Qsa0JBQWtCaDNCLEdBQUdpM0Isa0JBQUgsR0FDcEJqM0IsR0FBR291QixLQUFILENBQVM4SSxPQUFULEtBQXFCLE1BQXJCLEdBQThCLEVBQTlCLEdBQW1DbDNCLEdBQUdvdUIsS0FBSCxDQUFTOEksT0FEOUM7QUFFQSxTQUFJdG5DLFNBQVNtbkMsYUFBYixFQUE0QjtBQUMxQmp3QixhQUFNdFosSUFBTixDQUFXcW5DLElBQVgsR0FBa0IsSUFBbEI7QUFDQTdCLGFBQU1sc0IsS0FBTixFQUFhLFlBQVk7QUFDdkI5RyxZQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUJGLGVBQW5CO0FBQ0QsUUFGRDtBQUdELE1BTEQsTUFLTztBQUNMaDNCLFVBQUdvdUIsS0FBSCxDQUFTOEksT0FBVCxHQUFtQnRuQyxRQUFRb25DLGVBQVIsR0FBMEIsTUFBN0M7QUFDRDtBQUNGLElBaEJROztBQWtCVGg2QixXQUFRLFNBQVNBLE1BQVQsQ0FBaUJnRCxFQUFqQixFQUFxQnFaLEdBQXJCLEVBQTBCdlMsS0FBMUIsRUFBaUM7QUFDdkMsU0FBSWxYLFFBQVF5cEIsSUFBSXpwQixLQUFoQjtBQUNBLFNBQUkwaEIsV0FBVytILElBQUkvSCxRQUFuQjs7QUFFQTtBQUNBLFNBQUkxaEIsVUFBVTBoQixRQUFkLEVBQXdCO0FBQUU7QUFBUTtBQUNsQ3hLLGFBQVFnd0IsV0FBV2h3QixLQUFYLENBQVI7QUFDQSxTQUFJaXdCLGdCQUFnQmp3QixNQUFNdFosSUFBTixJQUFjc1osTUFBTXRaLElBQU4sQ0FBV3kxQixVQUE3QztBQUNBLFNBQUk4VCxhQUFKLEVBQW1CO0FBQ2pCandCLGFBQU10WixJQUFOLENBQVdxbkMsSUFBWCxHQUFrQixJQUFsQjtBQUNBLFdBQUlqbEMsS0FBSixFQUFXO0FBQ1RvakMsZUFBTWxzQixLQUFOLEVBQWEsWUFBWTtBQUN2QjlHLGNBQUdvdUIsS0FBSCxDQUFTOEksT0FBVCxHQUFtQmwzQixHQUFHaTNCLGtCQUF0QjtBQUNELFVBRkQ7QUFHRCxRQUpELE1BSU87QUFDTGhDLGVBQU1udUIsS0FBTixFQUFhLFlBQVk7QUFDdkI5RyxjQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUIsTUFBbkI7QUFDRCxVQUZEO0FBR0Q7QUFDRixNQVhELE1BV087QUFDTGwzQixVQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUJ0bkMsUUFBUW9RLEdBQUdpM0Isa0JBQVgsR0FBZ0MsTUFBbkQ7QUFDRDtBQUNGLElBeENROztBQTBDVEUsV0FBUSxTQUFTQSxNQUFULENBQ05uM0IsRUFETSxFQUVOKzFCLE9BRk0sRUFHTmp2QixLQUhNLEVBSU4wTyxRQUpNLEVBS042USxTQUxNLEVBTU47QUFDQSxTQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZHJtQixVQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUJsM0IsR0FBR2kzQixrQkFBdEI7QUFDRDtBQUNGO0FBcERRLEVBQVg7O0FBdURBLEtBQUlHLHFCQUFxQjtBQUN2QnBoQixVQUFPOGYsT0FEZ0I7QUFFdkJqQixTQUFNQTtBQUZpQixFQUF6Qjs7QUFLQTs7QUFFQTtBQUNBOztBQUVBLEtBQUl3QyxrQkFBa0I7QUFDcEI3dUMsU0FBTW1JLE1BRGM7QUFFcEJnakMsV0FBUXp3QixPQUZZO0FBR3BCK3NCLFFBQUsvc0IsT0FIZTtBQUlwQm8wQixTQUFNM21DLE1BSmM7QUFLcEJ3USxTQUFNeFEsTUFMYztBQU1wQncvQixlQUFZeC9CLE1BTlE7QUFPcEIyL0IsZUFBWTMvQixNQVBRO0FBUXBCeS9CLGlCQUFjei9CLE1BUk07QUFTcEI0L0IsaUJBQWM1L0IsTUFUTTtBQVVwQjAvQixxQkFBa0IxL0IsTUFWRTtBQVdwQjYvQixxQkFBa0I3L0IsTUFYRTtBQVlwQnlpQyxnQkFBYXppQyxNQVpPO0FBYXBCMmlDLHNCQUFtQjNpQyxNQWJDO0FBY3BCMGlDLGtCQUFlMWlDLE1BZEs7QUFlcEJtakMsYUFBVSxDQUFDZixNQUFELEVBQVNwaUMsTUFBVCxFQUFpQjlCLE1BQWpCO0FBZlUsRUFBdEI7O0FBa0JBO0FBQ0E7QUFDQSxVQUFTMG9DLFlBQVQsQ0FBdUJ6d0IsS0FBdkIsRUFBOEI7QUFDNUIsT0FBSTB3QixjQUFjMXdCLFNBQVNBLE1BQU1uQixnQkFBakM7QUFDQSxPQUFJNnhCLGVBQWVBLFlBQVlqOUIsSUFBWixDQUFpQnZDLE9BQWpCLENBQXlCa1UsUUFBNUMsRUFBc0Q7QUFDcEQsWUFBT3FyQixhQUFhbHRCLHVCQUF1Qm10QixZQUFZanlCLFFBQW5DLENBQWIsQ0FBUDtBQUNELElBRkQsTUFFTztBQUNMLFlBQU91QixLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTMndCLHFCQUFULENBQWdDdHVCLElBQWhDLEVBQXNDO0FBQ3BDLE9BQUkzYixPQUFPLEVBQVg7QUFDQSxPQUFJd0ssVUFBVW1SLEtBQUtqUixRQUFuQjtBQUNBO0FBQ0EsUUFBSyxJQUFJcEcsR0FBVCxJQUFnQmtHLFFBQVFpSSxTQUF4QixFQUFtQztBQUNqQ3pTLFVBQUtzRSxHQUFMLElBQVlxWCxLQUFLclgsR0FBTCxDQUFaO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsT0FBSTJZLFlBQVl6UyxRQUFRMFMsZ0JBQXhCO0FBQ0EsUUFBSyxJQUFJZ3RCLEtBQVQsSUFBa0JqdEIsU0FBbEIsRUFBNkI7QUFDM0JqZCxVQUFLNkUsU0FBU3FsQyxLQUFULENBQUwsSUFBd0JqdEIsVUFBVWl0QixLQUFWLENBQXhCO0FBQ0Q7QUFDRCxVQUFPbHFDLElBQVA7QUFDRDs7QUFFRCxVQUFTbXFDLFdBQVQsQ0FBc0JoakIsQ0FBdEIsRUFBeUJpakIsUUFBekIsRUFBbUM7QUFDakMsT0FBSSxpQkFBaUJ6Z0MsSUFBakIsQ0FBc0J5Z0MsU0FBU3R6QixHQUEvQixDQUFKLEVBQXlDO0FBQ3ZDLFlBQU9xUSxFQUFFLFlBQUYsRUFBZ0I7QUFDckJ2VCxjQUFPdzJCLFNBQVNqeUIsZ0JBQVQsQ0FBMEIxRjtBQURaLE1BQWhCLENBQVA7QUFHRDtBQUNGOztBQUVELFVBQVM0M0IsbUJBQVQsQ0FBOEIvd0IsS0FBOUIsRUFBcUM7QUFDbkMsVUFBUUEsUUFBUUEsTUFBTTVHLE1BQXRCLEVBQStCO0FBQzdCLFNBQUk0RyxNQUFNdFosSUFBTixDQUFXeTFCLFVBQWYsRUFBMkI7QUFDekIsY0FBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVM2VSxXQUFULENBQXNCMzNCLEtBQXRCLEVBQTZCNDNCLFFBQTdCLEVBQXVDO0FBQ3JDLFVBQU9BLFNBQVNqbUMsR0FBVCxLQUFpQnFPLE1BQU1yTyxHQUF2QixJQUE4QmltQyxTQUFTenpCLEdBQVQsS0FBaUJuRSxNQUFNbUUsR0FBNUQ7QUFDRDs7QUFFRCxVQUFTaUMsa0JBQVQsQ0FBNkJJLElBQTdCLEVBQW1DO0FBQ2pDLFVBQU9BLEtBQUtSLFNBQUwsSUFBa0JRLEtBQUtmLFlBQTlCO0FBQ0Q7O0FBRUQsS0FBSW95QixhQUFhO0FBQ2Z4dkMsU0FBTSxZQURTO0FBRWY0WSxVQUFPaTJCLGVBRlE7QUFHZm5yQixhQUFVLElBSEs7O0FBS2YvRyxXQUFRLFNBQVNBLE1BQVQsQ0FBaUJ3UCxDQUFqQixFQUFvQjtBQUMxQixTQUFJdkosU0FBUyxJQUFiOztBQUVBLFNBQUk3RixXQUFXLEtBQUtyTixRQUFMLENBQWNzVyxlQUE3QjtBQUNBLFNBQUksQ0FBQ2pKLFFBQUwsRUFBZTtBQUNiO0FBQ0Q7O0FBRUQ7QUFDQUEsZ0JBQVdBLFNBQVN0VyxNQUFULENBQWdCLFVBQVV1RCxDQUFWLEVBQWE7QUFBRSxjQUFPQSxFQUFFOFIsR0FBRixJQUFTaUMsbUJBQW1CL1QsQ0FBbkIsQ0FBaEI7QUFBd0MsTUFBdkUsQ0FBWDtBQUNBO0FBQ0EsU0FBSSxDQUFDK1MsU0FBU3JkLE1BQWQsRUFBc0I7QUFDcEI7QUFDRDs7QUFFRDtBQUNBLFNBQUlxTixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM4UCxTQUFTcmQsTUFBVCxHQUFrQixDQUEvRCxFQUFrRTtBQUNoRW1QLFlBQ0UsNERBQ0EsK0JBRkYsRUFHRSxLQUFLbUIsT0FIUDtBQUtEOztBQUVELFNBQUk4K0IsT0FBTyxLQUFLQSxJQUFoQjs7QUFFQTtBQUNBLFNBQUkvaEMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0Y2aEMsSUFERSxJQUNNQSxTQUFTLFFBRGYsSUFDMkJBLFNBQVMsUUFEeEMsRUFFRTtBQUNBamdDLFlBQ0UsZ0NBQWdDaWdDLElBRGxDLEVBRUUsS0FBSzkrQixPQUZQO0FBSUQ7O0FBRUQsU0FBSW8vQixXQUFXcnlCLFNBQVMsQ0FBVCxDQUFmOztBQUVBO0FBQ0E7QUFDQSxTQUFJc3lCLG9CQUFvQixLQUFLcnFCLE1BQXpCLENBQUosRUFBc0M7QUFDcEMsY0FBT29xQixRQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQUl6M0IsUUFBUW8zQixhQUFhSyxRQUFiLENBQVo7QUFDQTtBQUNBLFNBQUksQ0FBQ3ozQixLQUFMLEVBQVk7QUFDVixjQUFPeTNCLFFBQVA7QUFDRDs7QUFFRCxTQUFJLEtBQUtLLFFBQVQsRUFBbUI7QUFDakIsY0FBT04sWUFBWWhqQixDQUFaLEVBQWVpakIsUUFBZixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsU0FBSS9xQyxLQUFLLGtCQUFtQixLQUFLb2hCLElBQXhCLEdBQWdDLEdBQXpDO0FBQ0E5TixXQUFNck8sR0FBTixHQUFZcU8sTUFBTXJPLEdBQU4sSUFBYSxJQUFiLEdBQ1JxTyxNQUFNZ0csU0FBTixHQUNFdFosS0FBSyxTQURQLEdBRUVBLEtBQUtzVCxNQUFNbUUsR0FITCxHQUlSM1UsWUFBWXdRLE1BQU1yTyxHQUFsQixJQUNHbkIsT0FBT3dQLE1BQU1yTyxHQUFiLEVBQWtCbkksT0FBbEIsQ0FBMEJrRCxFQUExQixNQUFrQyxDQUFsQyxHQUFzQ3NULE1BQU1yTyxHQUE1QyxHQUFrRGpGLEtBQUtzVCxNQUFNck8sR0FEaEUsR0FFRXFPLE1BQU1yTyxHQU5aOztBQVFBLFNBQUl0RSxPQUFPLENBQUMyUyxNQUFNM1MsSUFBTixLQUFlMlMsTUFBTTNTLElBQU4sR0FBYSxFQUE1QixDQUFELEVBQWtDeTFCLFVBQWxDLEdBQStDd1Usc0JBQXNCLElBQXRCLENBQTFEO0FBQ0EsU0FBSVMsY0FBYyxLQUFLaHJCLE1BQXZCO0FBQ0EsU0FBSTZxQixXQUFXUixhQUFhVyxXQUFiLENBQWY7O0FBRUE7QUFDQTtBQUNBLFNBQUkvM0IsTUFBTTNTLElBQU4sQ0FBV3lVLFVBQVgsSUFBeUI5QixNQUFNM1MsSUFBTixDQUFXeVUsVUFBWCxDQUFzQnMwQixJQUF0QixDQUEyQixVQUFVcG9DLENBQVYsRUFBYTtBQUFFLGNBQU9BLEVBQUUzRixJQUFGLEtBQVcsTUFBbEI7QUFBMkIsTUFBckUsQ0FBN0IsRUFBcUc7QUFDbkcyWCxhQUFNM1MsSUFBTixDQUFXcW5DLElBQVgsR0FBa0IsSUFBbEI7QUFDRDs7QUFFRCxTQUNFa0QsWUFDQUEsU0FBU3ZxQyxJQURULElBRUEsQ0FBQ3NxQyxZQUFZMzNCLEtBQVosRUFBbUI0M0IsUUFBbkIsQ0FGRCxJQUdBLENBQUN4eEIsbUJBQW1Cd3hCLFFBQW5CLENBSkgsRUFLRTtBQUNBO0FBQ0E7QUFDQSxXQUFJblEsVUFBVW1RLGFBQWFBLFNBQVN2cUMsSUFBVCxDQUFjeTFCLFVBQWQsR0FBMkIzdkIsT0FBTyxFQUFQLEVBQVc5RixJQUFYLENBQXhDLENBQWQ7QUFDQTtBQUNBLFdBQUk4cEMsU0FBUyxRQUFiLEVBQXVCO0FBQ3JCO0FBQ0EsY0FBS1csUUFBTCxHQUFnQixJQUFoQjtBQUNBandCLHdCQUFlNGYsT0FBZixFQUF3QixZQUF4QixFQUFzQyxZQUFZO0FBQ2hEeGMsa0JBQU82c0IsUUFBUCxHQUFrQixLQUFsQjtBQUNBN3NCLGtCQUFPcEIsWUFBUDtBQUNELFVBSEQ7QUFJQSxnQkFBTzJ0QixZQUFZaGpCLENBQVosRUFBZWlqQixRQUFmLENBQVA7QUFDRCxRQVJELE1BUU8sSUFBSU4sU0FBUyxRQUFiLEVBQXVCO0FBQzVCLGFBQUkvd0IsbUJBQW1CcEcsS0FBbkIsQ0FBSixFQUErQjtBQUM3QixrQkFBTyszQixXQUFQO0FBQ0Q7QUFDRCxhQUFJQyxZQUFKO0FBQ0EsYUFBSTVDLGVBQWUsU0FBZkEsWUFBZSxHQUFZO0FBQUU0QztBQUFpQixVQUFsRDtBQUNBbndCLHdCQUFleGEsSUFBZixFQUFxQixZQUFyQixFQUFtQytuQyxZQUFuQztBQUNBdnRCLHdCQUFleGEsSUFBZixFQUFxQixnQkFBckIsRUFBdUMrbkMsWUFBdkM7QUFDQXZ0Qix3QkFBZTRmLE9BQWYsRUFBd0IsWUFBeEIsRUFBc0MsVUFBVXFOLEtBQVYsRUFBaUI7QUFBRWtELDBCQUFlbEQsS0FBZjtBQUF1QixVQUFoRjtBQUNEO0FBQ0Y7O0FBRUQsWUFBTzJDLFFBQVA7QUFDRDtBQWxIYyxFQUFqQjs7QUFxSEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJeDJCLFFBQVE5TixPQUFPO0FBQ2pCZ1IsUUFBSzNULE1BRFk7QUFFakJ5bkMsY0FBV3puQztBQUZNLEVBQVAsRUFHVDBtQyxlQUhTLENBQVo7O0FBS0EsUUFBT2oyQixNQUFNazJCLElBQWI7O0FBRUEsS0FBSWUsa0JBQWtCO0FBQ3BCajNCLFVBQU9BLEtBRGE7O0FBR3BCK0QsV0FBUSxTQUFTQSxNQUFULENBQWlCd1AsQ0FBakIsRUFBb0I7QUFDMUIsU0FBSXJRLE1BQU0sS0FBS0EsR0FBTCxJQUFZLEtBQUtrSixNQUFMLENBQVloZ0IsSUFBWixDQUFpQjhXLEdBQTdCLElBQW9DLE1BQTlDO0FBQ0EsU0FBSXJULE1BQU1wQyxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLFNBQUlvbkMsZUFBZSxLQUFLQSxZQUFMLEdBQW9CLEtBQUsveUIsUUFBNUM7QUFDQSxTQUFJZ3pCLGNBQWMsS0FBS3ZwQixNQUFMLENBQVkxTCxPQUFaLElBQXVCLEVBQXpDO0FBQ0EsU0FBSWlDLFdBQVcsS0FBS0EsUUFBTCxHQUFnQixFQUEvQjtBQUNBLFNBQUlpekIsaUJBQWlCZixzQkFBc0IsSUFBdEIsQ0FBckI7O0FBRUEsVUFBSyxJQUFJeHZDLElBQUksQ0FBYixFQUFnQkEsSUFBSXN3QyxZQUFZcndDLE1BQWhDLEVBQXdDRCxHQUF4QyxFQUE2QztBQUMzQyxXQUFJdUssSUFBSStsQyxZQUFZdHdDLENBQVosQ0FBUjtBQUNBLFdBQUl1SyxFQUFFOFIsR0FBTixFQUFXO0FBQ1QsYUFBSTlSLEVBQUVWLEdBQUYsSUFBUyxJQUFULElBQWlCbkIsT0FBTzZCLEVBQUVWLEdBQVQsRUFBY25JLE9BQWQsQ0FBc0IsU0FBdEIsTUFBcUMsQ0FBMUQsRUFBNkQ7QUFDM0Q0YixvQkFBUzFNLElBQVQsQ0FBY3JHLENBQWQ7QUFDQXZCLGVBQUl1QixFQUFFVixHQUFOLElBQWFVLENBQWIsQ0FDQyxDQUFDQSxFQUFFaEYsSUFBRixLQUFXZ0YsRUFBRWhGLElBQUYsR0FBUyxFQUFwQixDQUFELEVBQTBCeTFCLFVBQTFCLEdBQXVDdVYsY0FBdkM7QUFDRixVQUpELE1BSU8sSUFBSWpqQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDaEQsZUFBSXFFLE9BQU90SCxFQUFFbVQsZ0JBQWI7QUFDQSxlQUFJbmQsT0FBT3NSLE9BQVFBLEtBQUtTLElBQUwsQ0FBVXZDLE9BQVYsQ0FBa0J4UCxJQUFsQixJQUEwQnNSLEtBQUt3SyxHQUEvQixJQUFzQyxFQUE5QyxHQUFvRDlSLEVBQUU4UixHQUFqRTtBQUNBak4sZ0JBQU0saURBQWlEN08sSUFBakQsR0FBd0QsR0FBOUQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBSTh2QyxZQUFKLEVBQWtCO0FBQ2hCLFdBQUlHLE9BQU8sRUFBWDtBQUNBLFdBQUlDLFVBQVUsRUFBZDtBQUNBLFlBQUssSUFBSXJ0QixNQUFNLENBQWYsRUFBa0JBLE1BQU1pdEIsYUFBYXB3QyxNQUFyQyxFQUE2Q21qQixLQUE3QyxFQUFvRDtBQUNsRCxhQUFJc3RCLE1BQU1MLGFBQWFqdEIsR0FBYixDQUFWO0FBQ0FzdEIsYUFBSW5yQyxJQUFKLENBQVN5MUIsVUFBVCxHQUFzQnVWLGNBQXRCO0FBQ0FHLGFBQUluckMsSUFBSixDQUFTb3JDLEdBQVQsR0FBZUQsSUFBSWx6QixHQUFKLENBQVFvekIscUJBQVIsRUFBZjtBQUNBLGFBQUk1bkMsSUFBSTBuQyxJQUFJN21DLEdBQVIsQ0FBSixFQUFrQjtBQUNoQjJtQyxnQkFBSzUvQixJQUFMLENBQVU4L0IsR0FBVjtBQUNELFVBRkQsTUFFTztBQUNMRCxtQkFBUTcvQixJQUFSLENBQWE4L0IsR0FBYjtBQUNEO0FBQ0Y7QUFDRCxZQUFLRixJQUFMLEdBQVk5akIsRUFBRXJRLEdBQUYsRUFBTyxJQUFQLEVBQWFtMEIsSUFBYixDQUFaO0FBQ0EsWUFBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRUQsWUFBTy9qQixFQUFFclEsR0FBRixFQUFPLElBQVAsRUFBYWlCLFFBQWIsQ0FBUDtBQUNELElBNUNtQjs7QUE4Q3BCdXpCLGlCQUFjLFNBQVNBLFlBQVQsR0FBeUI7QUFDckM7QUFDQSxVQUFLMXJCLFNBQUwsQ0FDRSxLQUFLRixNQURQLEVBRUUsS0FBS3VyQixJQUZQLEVBR0UsS0FIRixFQUdTO0FBQ1AsU0FKRixDQUlPO0FBSlA7QUFNQSxVQUFLdnJCLE1BQUwsR0FBYyxLQUFLdXJCLElBQW5CO0FBQ0QsSUF2RG1COztBQXlEcEJNLFlBQVMsU0FBU0EsT0FBVCxHQUFvQjtBQUMzQixTQUFJeHpCLFdBQVcsS0FBSyt5QixZQUFwQjtBQUNBLFNBQUlGLFlBQVksS0FBS0EsU0FBTCxJQUFtQixDQUFDLEtBQUs1dkMsSUFBTCxJQUFhLEdBQWQsSUFBcUIsT0FBeEQ7QUFDQSxTQUFJLENBQUMrYyxTQUFTcmQsTUFBVixJQUFvQixDQUFDLEtBQUs4d0MsT0FBTCxDQUFhenpCLFNBQVMsQ0FBVCxFQUFZRSxHQUF6QixFQUE4QjJ5QixTQUE5QixDQUF6QixFQUFtRTtBQUNqRTtBQUNEOztBQUVEO0FBQ0E7QUFDQTd5QixjQUFTeFcsT0FBVCxDQUFpQmtxQyxjQUFqQjtBQUNBMXpCLGNBQVN4VyxPQUFULENBQWlCbXFDLGNBQWpCO0FBQ0EzekIsY0FBU3hXLE9BQVQsQ0FBaUJvcUMsZ0JBQWpCOztBQUVBO0FBQ0EsU0FBSUMsT0FBTy92QyxTQUFTK3ZDLElBQXBCO0FBQ0EsU0FBSUMsSUFBSUQsS0FBS0UsWUFBYixDQWYyQixDQWVBOztBQUUzQi96QixjQUFTeFcsT0FBVCxDQUFpQixVQUFVeUQsQ0FBVixFQUFhO0FBQzVCLFdBQUlBLEVBQUVoRixJQUFGLENBQU8rckMsS0FBWCxFQUFrQjtBQUNoQixhQUFJdjVCLEtBQUt4TixFQUFFaVQsR0FBWDtBQUNBLGFBQUlxdEIsSUFBSTl5QixHQUFHb3VCLEtBQVg7QUFDQW1ELDRCQUFtQnZ4QixFQUFuQixFQUF1Qm80QixTQUF2QjtBQUNBdEYsV0FBRTBHLFNBQUYsR0FBYzFHLEVBQUUyRyxlQUFGLEdBQW9CM0csRUFBRTRHLGtCQUFGLEdBQXVCLEVBQXpEO0FBQ0ExNUIsWUFBR2hHLGdCQUFILENBQW9CNjJCLGtCQUFwQixFQUF3Qzd3QixHQUFHMjVCLE9BQUgsR0FBYSxTQUFTNzlCLEVBQVQsQ0FBYXRVLENBQWIsRUFBZ0I7QUFDbkUsZUFBSSxDQUFDQSxDQUFELElBQU0sYUFBYTJQLElBQWIsQ0FBa0IzUCxFQUFFb3lDLFlBQXBCLENBQVYsRUFBNkM7QUFDM0M1NUIsZ0JBQUdpdEIsbUJBQUgsQ0FBdUI0RCxrQkFBdkIsRUFBMkMvMEIsRUFBM0M7QUFDQWtFLGdCQUFHMjVCLE9BQUgsR0FBYSxJQUFiO0FBQ0FsSSxtQ0FBc0J6eEIsRUFBdEIsRUFBMEJvNEIsU0FBMUI7QUFDRDtBQUNGLFVBTkQ7QUFPRDtBQUNGLE1BZEQ7QUFlRCxJQXpGbUI7O0FBMkZwQi8yQixZQUFTO0FBQ1AyM0IsY0FBUyxTQUFTQSxPQUFULENBQWtCaDVCLEVBQWxCLEVBQXNCbzRCLFNBQXRCLEVBQWlDO0FBQ3hDO0FBQ0EsV0FBSSxDQUFDM0gsYUFBTCxFQUFvQjtBQUNsQixnQkFBTyxLQUFQO0FBQ0Q7QUFDRDtBQUNBLFdBQUksS0FBS29KLFFBQVQsRUFBbUI7QUFDakIsZ0JBQU8sS0FBS0EsUUFBWjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUlDLFFBQVE5NUIsR0FBRys1QixTQUFILEVBQVo7QUFDQSxXQUFJLzVCLEdBQUcrbkIsa0JBQVAsRUFBMkI7QUFDekIvbkIsWUFBRytuQixrQkFBSCxDQUFzQmg1QixPQUF0QixDQUE4QixVQUFVODRCLEdBQVYsRUFBZTtBQUFFZ0ksdUJBQVlpSyxLQUFaLEVBQW1CalMsR0FBbkI7QUFBMEIsVUFBekU7QUFDRDtBQUNENkgsZ0JBQVNvSyxLQUFULEVBQWdCMUIsU0FBaEI7QUFDQTBCLGFBQU0xTCxLQUFOLENBQVk4SSxPQUFaLEdBQXNCLE1BQXRCO0FBQ0EsWUFBS2xxQixHQUFMLENBQVMyVCxXQUFULENBQXFCbVosS0FBckI7QUFDQSxXQUFJOXNDLE9BQU8ya0Msa0JBQWtCbUksS0FBbEIsQ0FBWDtBQUNBLFlBQUs5c0IsR0FBTCxDQUFTMFQsV0FBVCxDQUFxQm9aLEtBQXJCO0FBQ0EsY0FBUSxLQUFLRCxRQUFMLEdBQWdCN3NDLEtBQUswbEMsWUFBN0I7QUFDRDtBQXpCTTtBQTNGVyxFQUF0Qjs7QUF3SEEsVUFBU3VHLGNBQVQsQ0FBeUJ6bUMsQ0FBekIsRUFBNEI7QUFDMUI7QUFDQSxPQUFJQSxFQUFFaVQsR0FBRixDQUFNazBCLE9BQVYsRUFBbUI7QUFDakJubkMsT0FBRWlULEdBQUYsQ0FBTWswQixPQUFOO0FBQ0Q7QUFDRDtBQUNBLE9BQUlubkMsRUFBRWlULEdBQUYsQ0FBTTB0QixRQUFWLEVBQW9CO0FBQ2xCM2dDLE9BQUVpVCxHQUFGLENBQU0wdEIsUUFBTjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUytGLGNBQVQsQ0FBeUIxbUMsQ0FBekIsRUFBNEI7QUFDMUJBLEtBQUVoRixJQUFGLENBQU93c0MsTUFBUCxHQUFnQnhuQyxFQUFFaVQsR0FBRixDQUFNb3pCLHFCQUFOLEVBQWhCO0FBQ0Q7O0FBRUQsVUFBU00sZ0JBQVQsQ0FBMkIzbUMsQ0FBM0IsRUFBOEI7QUFDNUIsT0FBSXluQyxTQUFTem5DLEVBQUVoRixJQUFGLENBQU9vckMsR0FBcEI7QUFDQSxPQUFJb0IsU0FBU3huQyxFQUFFaEYsSUFBRixDQUFPd3NDLE1BQXBCO0FBQ0EsT0FBSUUsS0FBS0QsT0FBT0UsSUFBUCxHQUFjSCxPQUFPRyxJQUE5QjtBQUNBLE9BQUlDLEtBQUtILE9BQU9JLEdBQVAsR0FBYUwsT0FBT0ssR0FBN0I7QUFDQSxPQUFJSCxNQUFNRSxFQUFWLEVBQWM7QUFDWjVuQyxPQUFFaEYsSUFBRixDQUFPK3JDLEtBQVAsR0FBZSxJQUFmO0FBQ0EsU0FBSXpHLElBQUl0Z0MsRUFBRWlULEdBQUYsQ0FBTTJvQixLQUFkO0FBQ0EwRSxPQUFFMEcsU0FBRixHQUFjMUcsRUFBRTJHLGVBQUYsR0FBb0IsZUFBZVMsRUFBZixHQUFvQixLQUFwQixHQUE0QkUsRUFBNUIsR0FBaUMsS0FBbkU7QUFDQXRILE9BQUU0RyxrQkFBRixHQUF1QixJQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsS0FBSVkscUJBQXFCO0FBQ3ZCdEMsZUFBWUEsVUFEVztBQUV2Qkssb0JBQWlCQTtBQUZNLEVBQXpCOztBQUtBOztBQUVBO0FBQ0E5YyxPQUFNcG1CLE1BQU4sQ0FBYWtCLFdBQWIsR0FBMkJBLFdBQTNCO0FBQ0FrbEIsT0FBTXBtQixNQUFOLENBQWFhLGFBQWIsR0FBNkJBLGFBQTdCO0FBQ0F1bEIsT0FBTXBtQixNQUFOLENBQWFjLGNBQWIsR0FBOEJBLGNBQTlCO0FBQ0FzbEIsT0FBTXBtQixNQUFOLENBQWFnQixlQUFiLEdBQStCQSxlQUEvQjtBQUNBb2xCLE9BQU1wbUIsTUFBTixDQUFhZSxnQkFBYixHQUFnQ0EsZ0JBQWhDOztBQUVBO0FBQ0E1QyxRQUFPaW9CLE1BQU12akIsT0FBTixDQUFjaUssVUFBckIsRUFBaUNtMUIsa0JBQWpDO0FBQ0E5akMsUUFBT2lvQixNQUFNdmpCLE9BQU4sQ0FBYzBKLFVBQXJCLEVBQWlDNDRCLGtCQUFqQzs7QUFFQTtBQUNBL2UsT0FBTWowQixTQUFOLENBQWdCOGxCLFNBQWhCLEdBQTRCcFUsWUFBWTBzQixLQUFaLEdBQW9CNytCLElBQWhEOztBQUVBO0FBQ0EwMEIsT0FBTWowQixTQUFOLENBQWdCOHRCLE1BQWhCLEdBQXlCLFVBQ3ZCcFYsRUFEdUIsRUFFdkI2TSxTQUZ1QixFQUd2QjtBQUNBN00sUUFBS0EsTUFBTWhILFNBQU4sR0FBa0J2TSxNQUFNdVQsRUFBTixDQUFsQixHQUE4Qm5ZLFNBQW5DO0FBQ0EsVUFBT2dtQixlQUFlLElBQWYsRUFBcUI3TixFQUFyQixFQUF5QjZNLFNBQXpCLENBQVA7QUFDRCxFQU5EOztBQVFBO0FBQ0E7QUFDQXhSLFlBQVcsWUFBWTtBQUNyQixPQUFJbEcsT0FBT08sUUFBWCxFQUFxQjtBQUNuQixTQUFJQSxRQUFKLEVBQWM7QUFDWkEsZ0JBQVM2YSxJQUFULENBQWMsTUFBZCxFQUFzQmdMLEtBQXRCO0FBQ0QsTUFGRCxNQUVPLElBQUlobUIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDaUUsUUFBN0MsRUFBdUQ7QUFDNUQ5UixlQUFRQSxRQUFRb0YsSUFBUixHQUFlLE1BQWYsR0FBd0IsS0FBaEMsRUFDRSwrRUFDQSx1Q0FGRjtBQUlEO0FBQ0Y7QUFDRCxPQUFJdUksUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0ZOLE9BQU9HLGFBQVAsS0FBeUIsS0FEdkIsSUFFRjBELFNBRkUsSUFFVyxPQUFPcFIsT0FBUCxLQUFtQixXQUZsQyxFQUdFO0FBQ0FBLGFBQVFBLFFBQVFvRixJQUFSLEdBQWUsTUFBZixHQUF3QixLQUFoQyxFQUNFLCtDQUNBLHVFQURBLEdBRUEsMERBSEY7QUFLRDtBQUNGLEVBckJELEVBcUJHLENBckJIOztBQXVCQTs7QUFFQTtBQUNBLFVBQVN1dEMsWUFBVCxDQUF1QkMsT0FBdkIsRUFBZ0NDLE9BQWhDLEVBQXlDO0FBQ3ZDLE9BQUlDLE1BQU1yeEMsU0FBU3VyQixhQUFULENBQXVCLEtBQXZCLENBQVY7QUFDQThsQixPQUFJQyxTQUFKLEdBQWdCLGNBQWNILE9BQWQsR0FBd0IsTUFBeEM7QUFDQSxVQUFPRSxJQUFJQyxTQUFKLENBQWNoeEMsT0FBZCxDQUFzQjh3QyxPQUF0QixJQUFpQyxDQUF4QztBQUNEOztBQUVEO0FBQ0E7QUFDQSxLQUFJRyx1QkFBdUI1aEMsWUFBWXVoQyxhQUFhLElBQWIsRUFBbUIsT0FBbkIsQ0FBWixHQUEwQyxLQUFyRTs7QUFFQTs7QUFFQSxLQUFJTSxlQUFlLHVCQUFuQjtBQUNBLEtBQUlDLGdCQUFnQix3QkFBcEI7O0FBRUEsS0FBSUMsYUFBYWhwQyxPQUFPLFVBQVVpcEMsVUFBVixFQUFzQjtBQUM1QyxPQUFJQyxPQUFPRCxXQUFXLENBQVgsRUFBYzFvQyxPQUFkLENBQXNCd29DLGFBQXRCLEVBQXFDLE1BQXJDLENBQVg7QUFDQSxPQUFJSSxRQUFRRixXQUFXLENBQVgsRUFBYzFvQyxPQUFkLENBQXNCd29DLGFBQXRCLEVBQXFDLE1BQXJDLENBQVo7QUFDQSxVQUFPLElBQUlsZSxNQUFKLENBQVdxZSxPQUFPLGVBQVAsR0FBeUJDLEtBQXBDLEVBQTJDLEdBQTNDLENBQVA7QUFDRCxFQUpnQixDQUFqQjs7QUFNQSxVQUFTQyxTQUFULENBQ0UzMUIsSUFERixFQUVFdzFCLFVBRkYsRUFHRTtBQUNBLE9BQUlJLFFBQVFKLGFBQWFELFdBQVdDLFVBQVgsQ0FBYixHQUFzQ0gsWUFBbEQ7QUFDQSxPQUFJLENBQUNPLE1BQU1qa0MsSUFBTixDQUFXcU8sSUFBWCxDQUFMLEVBQXVCO0FBQ3JCO0FBQ0Q7QUFDRCxPQUFJNjFCLFNBQVMsRUFBYjtBQUNBLE9BQUlDLFlBQVlGLE1BQU1FLFNBQU4sR0FBa0IsQ0FBbEM7QUFDQSxPQUFJaGpDLEtBQUosRUFBV3JNLEtBQVg7QUFDQSxVQUFRcU0sUUFBUThpQyxNQUFNeHhDLElBQU4sQ0FBVzRiLElBQVgsQ0FBaEIsRUFBbUM7QUFDakN2WixhQUFRcU0sTUFBTXJNLEtBQWQ7QUFDQTtBQUNBLFNBQUlBLFFBQVFxdkMsU0FBWixFQUF1QjtBQUNyQkQsY0FBT3hpQyxJQUFQLENBQVlwSSxLQUFLQyxTQUFMLENBQWU4VSxLQUFLM2IsS0FBTCxDQUFXeXhDLFNBQVgsRUFBc0JydkMsS0FBdEIsQ0FBZixDQUFaO0FBQ0Q7QUFDRDtBQUNBLFNBQUltOEIsTUFBTUQsYUFBYTd2QixNQUFNLENBQU4sRUFBU3l3QixJQUFULEVBQWIsQ0FBVjtBQUNBc1MsWUFBT3hpQyxJQUFQLENBQWEsUUFBUXV2QixHQUFSLEdBQWMsR0FBM0I7QUFDQWtULGlCQUFZcnZDLFFBQVFxTSxNQUFNLENBQU4sRUFBU3BRLE1BQTdCO0FBQ0Q7QUFDRCxPQUFJb3pDLFlBQVk5MUIsS0FBS3RkLE1BQXJCLEVBQTZCO0FBQzNCbXpDLFlBQU94aUMsSUFBUCxDQUFZcEksS0FBS0MsU0FBTCxDQUFlOFUsS0FBSzNiLEtBQUwsQ0FBV3l4QyxTQUFYLENBQWYsQ0FBWjtBQUNEO0FBQ0QsVUFBT0QsT0FBT2xuQyxJQUFQLENBQVksR0FBWixDQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsVUFBU29uQyxhQUFULENBQXdCdjdCLEVBQXhCLEVBQTRCaEksT0FBNUIsRUFBcUM7QUFDbkMsT0FBSVgsT0FBT1csUUFBUVgsSUFBUixJQUFnQjZ4QixRQUEzQjtBQUNBLE9BQUlwSyxjQUFjb0wsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE9BQXJCLENBQWxCO0FBQ0EsT0FBSXpLLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5Q3FwQixXQUE3QyxFQUEwRDtBQUN4RCxTQUFJNU8sYUFBYWlyQixVQUFVcmMsV0FBVixFQUF1QjltQixRQUFRZ2pDLFVBQS9CLENBQWpCO0FBQ0EsU0FBSTlxQixVQUFKLEVBQWdCO0FBQ2Q3WSxZQUNFLGFBQWF5bkIsV0FBYixHQUEyQixNQUEzQixHQUNBLG9EQURBLEdBRUEsMERBRkEsR0FHQSw2REFKRjtBQU1EO0FBQ0Y7QUFDRCxPQUFJQSxXQUFKLEVBQWlCO0FBQ2Y5ZSxRQUFHOGUsV0FBSCxHQUFpQnJ1QixLQUFLQyxTQUFMLENBQWVvdUIsV0FBZixDQUFqQjtBQUNEO0FBQ0QsT0FBSTBjLGVBQWV6UixlQUFlL3BCLEVBQWYsRUFBbUIsT0FBbkIsRUFBNEIsS0FBNUIsQ0FBa0MsZUFBbEMsQ0FBbkI7QUFDQSxPQUFJdzdCLFlBQUosRUFBa0I7QUFDaEJ4N0IsUUFBR3c3QixZQUFILEdBQWtCQSxZQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU0MsT0FBVCxDQUFrQno3QixFQUFsQixFQUFzQjtBQUNwQixPQUFJeFMsT0FBTyxFQUFYO0FBQ0EsT0FBSXdTLEdBQUc4ZSxXQUFQLEVBQW9CO0FBQ2xCdHhCLGFBQVEsaUJBQWtCd1MsR0FBRzhlLFdBQXJCLEdBQW9DLEdBQTVDO0FBQ0Q7QUFDRCxPQUFJOWUsR0FBR3c3QixZQUFQLEVBQXFCO0FBQ25CaHVDLGFBQVEsV0FBWXdTLEdBQUd3N0IsWUFBZixHQUErQixHQUF2QztBQUNEO0FBQ0QsVUFBT2h1QyxJQUFQO0FBQ0Q7O0FBRUQsS0FBSWt1QyxVQUFVO0FBQ1p4bkMsZUFBWSxDQUFDLGFBQUQsQ0FEQTtBQUVacW5DLGtCQUFlQSxhQUZIO0FBR1pFLFlBQVNBO0FBSEcsRUFBZDs7QUFNQTs7QUFFQSxVQUFTRSxlQUFULENBQTBCMzdCLEVBQTFCLEVBQThCaEksT0FBOUIsRUFBdUM7QUFDckMsT0FBSVgsT0FBT1csUUFBUVgsSUFBUixJQUFnQjZ4QixRQUEzQjtBQUNBLE9BQUlvRixjQUFjcEUsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE9BQXJCLENBQWxCO0FBQ0EsT0FBSXN1QixXQUFKLEVBQWlCO0FBQ2Y7QUFDQSxTQUFJLzRCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJeWEsYUFBYWlyQixVQUFVN00sV0FBVixFQUF1QnQyQixRQUFRZ2pDLFVBQS9CLENBQWpCO0FBQ0EsV0FBSTlxQixVQUFKLEVBQWdCO0FBQ2Q3WSxjQUNFLGFBQWFpM0IsV0FBYixHQUEyQixNQUEzQixHQUNBLG9EQURBLEdBRUEsMERBRkEsR0FHQSw2REFKRjtBQU1EO0FBQ0Y7QUFDRHR1QixRQUFHc3VCLFdBQUgsR0FBaUI3OUIsS0FBS0MsU0FBTCxDQUFlcTlCLGVBQWVPLFdBQWYsQ0FBZixDQUFqQjtBQUNEOztBQUVELE9BQUlzTixlQUFlN1IsZUFBZS9wQixFQUFmLEVBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLENBQWtDLGVBQWxDLENBQW5CO0FBQ0EsT0FBSTQ3QixZQUFKLEVBQWtCO0FBQ2hCNTdCLFFBQUc0N0IsWUFBSCxHQUFrQkEsWUFBbEI7QUFDRDtBQUNGOztBQUVELFVBQVNDLFNBQVQsQ0FBb0I3N0IsRUFBcEIsRUFBd0I7QUFDdEIsT0FBSXhTLE9BQU8sRUFBWDtBQUNBLE9BQUl3UyxHQUFHc3VCLFdBQVAsRUFBb0I7QUFDbEI5Z0MsYUFBUSxpQkFBa0J3UyxHQUFHc3VCLFdBQXJCLEdBQW9DLEdBQTVDO0FBQ0Q7QUFDRCxPQUFJdHVCLEdBQUc0N0IsWUFBUCxFQUFxQjtBQUNuQnB1QyxhQUFRLFlBQWF3UyxHQUFHNDdCLFlBQWhCLEdBQWdDLElBQXhDO0FBQ0Q7QUFDRCxVQUFPcHVDLElBQVA7QUFDRDs7QUFFRCxLQUFJc3VDLFVBQVU7QUFDWjVuQyxlQUFZLENBQUMsYUFBRCxDQURBO0FBRVpxbkMsa0JBQWVJLGVBRkg7QUFHWkYsWUFBU0k7QUFIRyxFQUFkOztBQU1BLEtBQUlFLFlBQVksQ0FDZEwsT0FEYyxFQUVkSSxPQUZjLENBQWhCOztBQUtBOztBQUVBLFVBQVN0MkIsSUFBVCxDQUFleEYsRUFBZixFQUFtQjRtQixHQUFuQixFQUF3QjtBQUN0QixPQUFJQSxJQUFJaDNCLEtBQVIsRUFBZTtBQUNidzVCLGFBQVFwcEIsRUFBUixFQUFZLGFBQVosRUFBNEIsUUFBUzRtQixJQUFJaDNCLEtBQWIsR0FBc0IsR0FBbEQ7QUFDRDtBQUNGOztBQUVEOztBQUVBLFVBQVNvc0MsSUFBVCxDQUFlaDhCLEVBQWYsRUFBbUI0bUIsR0FBbkIsRUFBd0I7QUFDdEIsT0FBSUEsSUFBSWgzQixLQUFSLEVBQWU7QUFDYnc1QixhQUFRcHBCLEVBQVIsRUFBWSxXQUFaLEVBQTBCLFFBQVM0bUIsSUFBSWgzQixLQUFiLEdBQXNCLEdBQWhEO0FBQ0Q7QUFDRjs7QUFFRCxLQUFJcXNDLGVBQWU7QUFDakJqbUIsVUFBT0EsS0FEVTtBQUVqQnhRLFNBQU1BLElBRlc7QUFHakJ3MkIsU0FBTUE7QUFIVyxFQUFuQjs7QUFNQTs7QUFFQSxLQUFJRSxhQUFhcHJDLFFBQ2YsOERBQ0Esa0NBRmUsQ0FBakI7O0FBS0E7QUFDQTtBQUNBLEtBQUlxckMsbUJBQW1CcnJDLFFBQ3JCLHlEQURxQixDQUF2Qjs7QUFJQTtBQUNBO0FBQ0EsS0FBSXNyQyxtQkFBbUJ0ckMsUUFDckIsd0VBQ0Esa0VBREEsR0FFQSx1RUFGQSxHQUdBLDJFQUhBLEdBSUEsZ0JBTHFCLENBQXZCOztBQVFBOztBQUVBLEtBQUl1ckMsY0FBYztBQUNoQkMsZUFBWSxJQURJO0FBRWhCeG9DLFlBQVNpb0MsU0FGTztBQUdoQjk1QixlQUFZZzZCLFlBSEk7QUFJaEJ2YyxhQUFVQSxRQUpNO0FBS2hCd2MsZUFBWUEsVUFMSTtBQU1oQjdsQyxnQkFBYUEsV0FORztBQU9oQjhsQyxxQkFBa0JBLGdCQVBGO0FBUWhCbm1DLGtCQUFlQSxhQVJDO0FBU2hCRyxvQkFBaUJBLGVBVEQ7QUFVaEJqQyxlQUFZTCxjQUFja29DLFNBQWQ7QUFWSSxFQUFsQjs7QUFhQTs7QUFFQSxLQUFJUSxPQUFKOztBQUVBLEtBQUlDLEtBQUs7QUFDUEMsV0FBUSxTQUFTQSxNQUFULENBQWlCVCxJQUFqQixFQUF1QjtBQUM3Qk8sZUFBVUEsV0FBV2x6QyxTQUFTdXJCLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBckI7QUFDQTJuQixhQUFRNUIsU0FBUixHQUFvQnFCLElBQXBCO0FBQ0EsWUFBT08sUUFBUXpiLFdBQWY7QUFDRDtBQUxNLEVBQVQ7O0FBUUE7Ozs7QUFJQTs7Ozs7OztBQU9BO0FBQ0EsS0FBSTRiLHVCQUF1QixnQkFBM0I7QUFDQSxLQUFJQyxtQkFBbUIsT0FBdkI7QUFDQSxLQUFJQyxtQkFBbUI7QUFDckI7QUFDQSxjQUFhcm9CLE1BRlE7QUFHckI7QUFDQSxjQUFhQSxNQUpRO0FBS3JCO0FBQ0Esa0JBQWlCQSxNQU5JLENBQXZCO0FBUUEsS0FBSXNvQixZQUFZLElBQUlqZ0IsTUFBSixDQUNkLFVBQVU4ZixxQkFBcUJub0IsTUFBL0IsR0FDQSxVQURBLEdBQ2Fvb0IsaUJBQWlCcG9CLE1BRDlCLEdBQ3VDLEdBRHZDLEdBRUEsU0FGQSxHQUVZcW9CLGlCQUFpQnpvQyxJQUFqQixDQUFzQixHQUF0QixDQUZaLEdBRXlDLEtBSDNCLENBQWhCOztBQU1BO0FBQ0E7QUFDQSxLQUFJMm9DLFNBQVMsdUJBQWI7QUFDQSxLQUFJQyxlQUFlLFNBQVNELE1BQVQsR0FBa0IsT0FBbEIsR0FBNEJBLE1BQTVCLEdBQXFDLEdBQXhEO0FBQ0EsS0FBSUUsZUFBZSxJQUFJcGdCLE1BQUosQ0FBVyxPQUFPbWdCLFlBQWxCLENBQW5CO0FBQ0EsS0FBSUUsZ0JBQWdCLFlBQXBCO0FBQ0EsS0FBSXo0QixTQUFTLElBQUlvWSxNQUFKLENBQVcsVUFBVW1nQixZQUFWLEdBQXlCLFFBQXBDLENBQWI7QUFDQSxLQUFJRyxVQUFVLG9CQUFkO0FBQ0EsS0FBSUMsVUFBVSxPQUFkO0FBQ0EsS0FBSUMscUJBQXFCLE9BQXpCOztBQUVBLEtBQUlDLDRCQUE0QixLQUFoQztBQUNBLEtBQUkvcUMsT0FBSixDQUFZLFFBQVosRUFBc0IsVUFBVTBCLENBQVYsRUFBYXNwQyxDQUFiLEVBQWdCO0FBQ3BDRCwrQkFBNEJDLE1BQU0sRUFBbEM7QUFDRCxFQUZEOztBQUlBO0FBQ0EsS0FBSUMscUJBQXFCenNDLFFBQVEsdUJBQVIsRUFBaUMsSUFBakMsQ0FBekI7QUFDQSxLQUFJMHNDLFVBQVUsRUFBZDs7QUFFQSxLQUFJQyxjQUFjO0FBQ2hCLFdBQVEsR0FEUTtBQUVoQixXQUFRLEdBRlE7QUFHaEIsYUFBVSxHQUhNO0FBSWhCLFlBQVMsR0FKTztBQUtoQixZQUFTO0FBTE8sRUFBbEI7QUFPQSxLQUFJQyxjQUFjLHVCQUFsQjtBQUNBLEtBQUlDLDBCQUEwQiwyQkFBOUI7O0FBRUE7QUFDQSxLQUFJQyxxQkFBcUI5c0MsUUFBUSxjQUFSLEVBQXdCLElBQXhCLENBQXpCO0FBQ0EsS0FBSStzQywyQkFBMkIsU0FBM0JBLHdCQUEyQixDQUFVdjVCLEdBQVYsRUFBZTAzQixJQUFmLEVBQXFCO0FBQUUsVUFBTzEzQixPQUFPczVCLG1CQUFtQnQ1QixHQUFuQixDQUFQLElBQWtDMDNCLEtBQUssQ0FBTCxNQUFZLElBQXJEO0FBQTRELEVBQWxIOztBQUVBLFVBQVM4QixVQUFULENBQXFCbHVDLEtBQXJCLEVBQTRCZ3JDLG9CQUE1QixFQUFrRDtBQUNoRCxPQUFJbUQsS0FBS25ELHVCQUF1QitDLHVCQUF2QixHQUFpREQsV0FBMUQ7QUFDQSxVQUFPOXRDLE1BQU0wQyxPQUFOLENBQWN5ckMsRUFBZCxFQUFrQixVQUFVemxDLEtBQVYsRUFBaUI7QUFBRSxZQUFPbWxDLFlBQVlubEMsS0FBWixDQUFQO0FBQTRCLElBQWpFLENBQVA7QUFDRDs7QUFFRCxVQUFTMGxDLFNBQVQsQ0FBb0JoQyxJQUFwQixFQUEwQmhrQyxPQUExQixFQUFtQztBQUNqQyxPQUFJaW1DLFFBQVEsRUFBWjtBQUNBLE9BQUkzQixhQUFhdGtDLFFBQVFza0MsVUFBekI7QUFDQSxPQUFJNEIsZ0JBQWdCbG1DLFFBQVFra0MsVUFBUixJQUFzQnZvQyxFQUExQztBQUNBLE9BQUl3cUMsc0JBQXNCbm1DLFFBQVFta0MsZ0JBQVIsSUFBNEJ4b0MsRUFBdEQ7QUFDQSxPQUFJMUgsUUFBUSxDQUFaO0FBQ0EsT0FBSTBNLElBQUosRUFBVXlsQyxPQUFWO0FBQ0EsVUFBT3BDLElBQVAsRUFBYTtBQUNYcmpDLFlBQU9xakMsSUFBUDtBQUNBO0FBQ0EsU0FBSSxDQUFDb0MsT0FBRCxJQUFZLENBQUNiLG1CQUFtQmEsT0FBbkIsQ0FBakIsRUFBOEM7QUFDNUMsV0FBSUMsVUFBVXJDLEtBQUtyeUMsT0FBTCxDQUFhLEdBQWIsQ0FBZDtBQUNBLFdBQUkwMEMsWUFBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNBLGFBQUlsQixRQUFRaG1DLElBQVIsQ0FBYTZrQyxJQUFiLENBQUosRUFBd0I7QUFDdEIsZUFBSXNDLGFBQWF0QyxLQUFLcnlDLE9BQUwsQ0FBYSxLQUFiLENBQWpCOztBQUVBLGVBQUkyMEMsY0FBYyxDQUFsQixFQUFxQjtBQUNuQixpQkFBSXRtQyxRQUFRdW1DLGlCQUFaLEVBQStCO0FBQzdCdm1DLHVCQUFRbWxDLE9BQVIsQ0FBZ0JuQixLQUFLdlEsU0FBTCxDQUFlLENBQWYsRUFBa0I2UyxVQUFsQixDQUFoQjtBQUNEO0FBQ0RFLHFCQUFRRixhQUFhLENBQXJCO0FBQ0E7QUFDRDtBQUNGOztBQUVEO0FBQ0EsYUFBSWxCLG1CQUFtQmptQyxJQUFuQixDQUF3QjZrQyxJQUF4QixDQUFKLEVBQW1DO0FBQ2pDLGVBQUl5QyxpQkFBaUJ6QyxLQUFLcnlDLE9BQUwsQ0FBYSxJQUFiLENBQXJCOztBQUVBLGVBQUk4MEMsa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCRCxxQkFBUUMsaUJBQWlCLENBQXpCO0FBQ0E7QUFDRDtBQUNGOztBQUVEO0FBQ0EsYUFBSUMsZUFBZTFDLEtBQUsxakMsS0FBTCxDQUFXNGtDLE9BQVgsQ0FBbkI7QUFDQSxhQUFJd0IsWUFBSixFQUFrQjtBQUNoQkYsbUJBQVFFLGFBQWEsQ0FBYixFQUFnQngyQyxNQUF4QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxhQUFJeTJDLGNBQWMzQyxLQUFLMWpDLEtBQUwsQ0FBV2tNLE1BQVgsQ0FBbEI7QUFDQSxhQUFJbTZCLFdBQUosRUFBaUI7QUFDZixlQUFJQyxXQUFXM3lDLEtBQWY7QUFDQXV5QyxtQkFBUUcsWUFBWSxDQUFaLEVBQWV6MkMsTUFBdkI7QUFDQTIyQyx1QkFBWUYsWUFBWSxDQUFaLENBQVosRUFBNEJDLFFBQTVCLEVBQXNDM3lDLEtBQXRDO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLGFBQUk2eUMsZ0JBQWdCQyxlQUFwQjtBQUNBLGFBQUlELGFBQUosRUFBbUI7QUFDakJFLDBCQUFlRixhQUFmO0FBQ0EsZUFBSWpCLHlCQUF5Qk8sT0FBekIsRUFBa0NwQyxJQUFsQyxDQUFKLEVBQTZDO0FBQzNDd0MscUJBQVEsQ0FBUjtBQUNEO0FBQ0Q7QUFDRDtBQUNGOztBQUVELFdBQUloNUIsT0FBUSxLQUFLLENBQWpCO0FBQUEsV0FBcUJ5NUIsT0FBUSxLQUFLLENBQWxDO0FBQUEsV0FBc0M1VCxPQUFRLEtBQUssQ0FBbkQ7QUFDQSxXQUFJZ1QsV0FBVyxDQUFmLEVBQWtCO0FBQ2hCWSxnQkFBT2pELEtBQUtueUMsS0FBTCxDQUFXdzBDLE9BQVgsQ0FBUDtBQUNBLGdCQUNFLENBQUM3NUIsT0FBT3JOLElBQVAsQ0FBWThuQyxJQUFaLENBQUQsSUFDQSxDQUFDakMsYUFBYTdsQyxJQUFiLENBQWtCOG5DLElBQWxCLENBREQsSUFFQSxDQUFDOUIsUUFBUWhtQyxJQUFSLENBQWE4bkMsSUFBYixDQUZELElBR0EsQ0FBQzdCLG1CQUFtQmptQyxJQUFuQixDQUF3QjhuQyxJQUF4QixDQUpILEVBS0U7QUFDQTtBQUNBNVQsa0JBQU80VCxLQUFLdDFDLE9BQUwsQ0FBYSxHQUFiLEVBQWtCLENBQWxCLENBQVA7QUFDQSxlQUFJMGhDLE9BQU8sQ0FBWCxFQUFjO0FBQUU7QUFBTztBQUN2QmdULHNCQUFXaFQsSUFBWDtBQUNBNFQsa0JBQU9qRCxLQUFLbnlDLEtBQUwsQ0FBV3cwQyxPQUFYLENBQVA7QUFDRDtBQUNENzRCLGdCQUFPdzJCLEtBQUt2USxTQUFMLENBQWUsQ0FBZixFQUFrQjRTLE9BQWxCLENBQVA7QUFDQUcsaUJBQVFILE9BQVI7QUFDRDs7QUFFRCxXQUFJQSxVQUFVLENBQWQsRUFBaUI7QUFDZjc0QixnQkFBT3cyQixJQUFQO0FBQ0FBLGdCQUFPLEVBQVA7QUFDRDs7QUFFRCxXQUFJaGtDLFFBQVFrbkMsS0FBUixJQUFpQjE1QixJQUFyQixFQUEyQjtBQUN6QnhOLGlCQUFRa25DLEtBQVIsQ0FBYzE1QixJQUFkO0FBQ0Q7QUFDRixNQWhGRCxNQWdGTztBQUNMLFdBQUkyNUIsZUFBZSxDQUFuQjtBQUNBLFdBQUlDLGFBQWFoQixRQUFRL3NDLFdBQVIsRUFBakI7QUFDQSxXQUFJZ3VDLGVBQWU3QixRQUFRNEIsVUFBUixNQUF3QjVCLFFBQVE0QixVQUFSLElBQXNCLElBQUl4aUIsTUFBSixDQUFXLG9CQUFvQndpQixVQUFwQixHQUFpQyxTQUE1QyxFQUF1RCxHQUF2RCxDQUE5QyxDQUFuQjtBQUNBLFdBQUlFLFNBQVN0RCxLQUFLMXBDLE9BQUwsQ0FBYStzQyxZQUFiLEVBQTJCLFVBQVVFLEdBQVYsRUFBZS81QixJQUFmLEVBQXFCaEIsTUFBckIsRUFBNkI7QUFDbkUyNkIsd0JBQWUzNkIsT0FBT3RjLE1BQXRCO0FBQ0EsYUFBSSxDQUFDcTFDLG1CQUFtQjZCLFVBQW5CLENBQUQsSUFBbUNBLGVBQWUsVUFBdEQsRUFBa0U7QUFDaEU1NUIsa0JBQU9BLEtBQ0psVCxPQURJLENBQ0ksb0JBREosRUFDMEIsSUFEMUIsRUFFSkEsT0FGSSxDQUVJLDJCQUZKLEVBRWlDLElBRmpDLENBQVA7QUFHRDtBQUNELGFBQUl1ckMseUJBQXlCdUIsVUFBekIsRUFBcUM1NUIsSUFBckMsQ0FBSixFQUFnRDtBQUM5Q0Esa0JBQU9BLEtBQUszYixLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0Q7QUFDRCxhQUFJbU8sUUFBUWtuQyxLQUFaLEVBQW1CO0FBQ2pCbG5DLG1CQUFRa25DLEtBQVIsQ0FBYzE1QixJQUFkO0FBQ0Q7QUFDRCxnQkFBTyxFQUFQO0FBQ0QsUUFkWSxDQUFiO0FBZUF2WixnQkFBUyt2QyxLQUFLOXpDLE1BQUwsR0FBY28zQyxPQUFPcDNDLE1BQTlCO0FBQ0E4ekMsY0FBT3NELE1BQVA7QUFDQVQsbUJBQVlPLFVBQVosRUFBd0JuekMsUUFBUWt6QyxZQUFoQyxFQUE4Q2x6QyxLQUE5QztBQUNEOztBQUVELFNBQUkrdkMsU0FBU3JqQyxJQUFiLEVBQW1CO0FBQ2pCWCxlQUFRa25DLEtBQVIsSUFBaUJsbkMsUUFBUWtuQyxLQUFSLENBQWNsRCxJQUFkLENBQWpCO0FBQ0EsV0FBSXptQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQ3dvQyxNQUFNLzFDLE1BQWhELElBQTBEOFAsUUFBUVgsSUFBdEUsRUFBNEU7QUFDMUVXLGlCQUFRWCxJQUFSLENBQWMsNkNBQTZDMmtDLElBQTdDLEdBQW9ELElBQWxFO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTZDOztBQUVBLFlBQVNMLE9BQVQsQ0FBa0JwdUMsQ0FBbEIsRUFBcUI7QUFDbkJuRSxjQUFTbUUsQ0FBVDtBQUNBNHJDLFlBQU9BLEtBQUt2USxTQUFMLENBQWVyN0IsQ0FBZixDQUFQO0FBQ0Q7O0FBRUQsWUFBUzJ1QyxhQUFULEdBQTBCO0FBQ3hCLFNBQUk1ckMsUUFBUTZvQyxLQUFLMWpDLEtBQUwsQ0FBVzBrQyxZQUFYLENBQVo7QUFDQSxTQUFJN3BDLEtBQUosRUFBVztBQUNULFdBQUltRixRQUFRO0FBQ1YybkIsa0JBQVM5c0IsTUFBTSxDQUFOLENBREM7QUFFVm1WLGdCQUFPLEVBRkc7QUFHVm5WLGdCQUFPbEg7QUFIRyxRQUFaO0FBS0F1eUMsZUFBUXJyQyxNQUFNLENBQU4sRUFBU2pMLE1BQWpCO0FBQ0EsV0FBSTRwQyxHQUFKLEVBQVM1VCxJQUFUO0FBQ0EsY0FBTyxFQUFFNFQsTUFBTWtLLEtBQUsxakMsS0FBTCxDQUFXMmtDLGFBQVgsQ0FBUixNQUF1Qy9lLE9BQU84ZCxLQUFLMWpDLEtBQUwsQ0FBV3VrQyxTQUFYLENBQTlDLENBQVAsRUFBNkU7QUFDM0UyQixpQkFBUXRnQixLQUFLLENBQUwsRUFBUWgyQixNQUFoQjtBQUNBb1EsZUFBTWdRLEtBQU4sQ0FBWXpQLElBQVosQ0FBaUJxbEIsSUFBakI7QUFDRDtBQUNELFdBQUk0VCxHQUFKLEVBQVM7QUFDUHg1QixlQUFNa25DLFVBQU4sR0FBbUIxTixJQUFJLENBQUosQ0FBbkI7QUFDQTBNLGlCQUFRMU0sSUFBSSxDQUFKLEVBQU81cEMsTUFBZjtBQUNBb1EsZUFBTXc1QixHQUFOLEdBQVk3bEMsS0FBWjtBQUNBLGdCQUFPcU0sS0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFTMG1DLGNBQVQsQ0FBeUIxbUMsS0FBekIsRUFBZ0M7QUFDOUIsU0FBSTJuQixVQUFVM25CLE1BQU0ybkIsT0FBcEI7QUFDQSxTQUFJdWYsYUFBYWxuQyxNQUFNa25DLFVBQXZCOztBQUVBLFNBQUlsRCxVQUFKLEVBQWdCO0FBQ2QsV0FBSThCLFlBQVksR0FBWixJQUFtQmhDLGlCQUFpQm5jLE9BQWpCLENBQXZCLEVBQWtEO0FBQ2hENGUscUJBQVlULE9BQVo7QUFDRDtBQUNELFdBQUlELG9CQUFvQmxlLE9BQXBCLEtBQWdDbWUsWUFBWW5lLE9BQWhELEVBQXlEO0FBQ3ZENGUscUJBQVk1ZSxPQUFaO0FBQ0Q7QUFDRjs7QUFFRCxTQUFJd2YsUUFBUXZCLGNBQWNqZSxPQUFkLEtBQTBCLENBQUMsQ0FBQ3VmLFVBQXhDOztBQUVBLFNBQUl4c0MsSUFBSXNGLE1BQU1nUSxLQUFOLENBQVlwZ0IsTUFBcEI7QUFDQSxTQUFJb2dCLFFBQVEsSUFBSWpWLEtBQUosQ0FBVUwsQ0FBVixDQUFaO0FBQ0EsVUFBSyxJQUFJL0ssSUFBSSxDQUFiLEVBQWdCQSxJQUFJK0ssQ0FBcEIsRUFBdUIvSyxHQUF2QixFQUE0QjtBQUMxQixXQUFJeVYsT0FBT3BGLE1BQU1nUSxLQUFOLENBQVlyZ0IsQ0FBWixDQUFYO0FBQ0E7QUFDQSxXQUFJbzFDLDZCQUE2QjMvQixLQUFLLENBQUwsRUFBUS9ULE9BQVIsQ0FBZ0IsSUFBaEIsTUFBMEIsQ0FBQyxDQUE1RCxFQUErRDtBQUM3RCxhQUFJK1QsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxrQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDdkMsYUFBSUEsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxrQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDdkMsYUFBSUEsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxrQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDeEM7QUFDRCxXQUFJOU4sUUFBUThOLEtBQUssQ0FBTCxLQUFXQSxLQUFLLENBQUwsQ0FBWCxJQUFzQkEsS0FBSyxDQUFMLENBQXRCLElBQWlDLEVBQTdDO0FBQ0E0SyxhQUFNcmdCLENBQU4sSUFBVztBQUNUTyxlQUFNa1YsS0FBSyxDQUFMLENBREc7QUFFVDlOLGdCQUFPa3VDLFdBQ0xsdUMsS0FESyxFQUVMb0ksUUFBUTRpQyxvQkFGSDtBQUZFLFFBQVg7QUFPRDs7QUFFRCxTQUFJLENBQUM2RSxLQUFMLEVBQVk7QUFDVnhCLGFBQU1wbEMsSUFBTixDQUFXLEVBQUV5TCxLQUFLMmIsT0FBUCxFQUFnQnlmLGVBQWV6ZixRQUFRNXVCLFdBQVIsRUFBL0IsRUFBc0RpWCxPQUFPQSxLQUE3RCxFQUFYO0FBQ0E4MUIsaUJBQVVuZSxPQUFWO0FBQ0Q7O0FBRUQsU0FBSWpvQixRQUFRN0UsS0FBWixFQUFtQjtBQUNqQjZFLGVBQVE3RSxLQUFSLENBQWM4c0IsT0FBZCxFQUF1QjNYLEtBQXZCLEVBQThCbTNCLEtBQTlCLEVBQXFDbm5DLE1BQU1uRixLQUEzQyxFQUFrRG1GLE1BQU13NUIsR0FBeEQ7QUFDRDtBQUNGOztBQUVELFlBQVMrTSxXQUFULENBQXNCNWUsT0FBdEIsRUFBK0I5c0IsS0FBL0IsRUFBc0MyK0IsR0FBdEMsRUFBMkM7QUFDekMsU0FBSThHLEdBQUosRUFBUytHLGlCQUFUO0FBQ0EsU0FBSXhzQyxTQUFTLElBQWIsRUFBbUI7QUFBRUEsZUFBUWxILEtBQVI7QUFBZ0I7QUFDckMsU0FBSTZsQyxPQUFPLElBQVgsRUFBaUI7QUFBRUEsYUFBTTdsQyxLQUFOO0FBQWM7O0FBRWpDLFNBQUlnMEIsT0FBSixFQUFhO0FBQ1gwZiwyQkFBb0IxZixRQUFRNXVCLFdBQVIsRUFBcEI7QUFDRDs7QUFFRDtBQUNBLFNBQUk0dUIsT0FBSixFQUFhO0FBQ1gsWUFBSzJZLE1BQU1xRixNQUFNLzFDLE1BQU4sR0FBZSxDQUExQixFQUE2QjB3QyxPQUFPLENBQXBDLEVBQXVDQSxLQUF2QyxFQUE4QztBQUM1QyxhQUFJcUYsTUFBTXJGLEdBQU4sRUFBVzhHLGFBQVgsS0FBNkJDLGlCQUFqQyxFQUFvRDtBQUNsRDtBQUNEO0FBQ0Y7QUFDRixNQU5ELE1BTU87QUFDTDtBQUNBL0csYUFBTSxDQUFOO0FBQ0Q7O0FBRUQsU0FBSUEsT0FBTyxDQUFYLEVBQWM7QUFDWjtBQUNBLFlBQUssSUFBSTN3QyxJQUFJZzJDLE1BQU0vMUMsTUFBTixHQUFlLENBQTVCLEVBQStCRCxLQUFLMndDLEdBQXBDLEVBQXlDM3dDLEdBQXpDLEVBQThDO0FBQzVDLGFBQUlzTixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsS0FDRHhOLElBQUkyd0MsR0FBSixJQUFXLENBQUMzWSxPQURYLEtBRUZqb0IsUUFBUVgsSUFGVixFQUdFO0FBQ0FXLG1CQUFRWCxJQUFSLENBQ0csVUFBVzRtQyxNQUFNaDJDLENBQU4sRUFBU3FjLEdBQXBCLEdBQTJCLDRCQUQ5QjtBQUdEO0FBQ0QsYUFBSXRNLFFBQVE4NUIsR0FBWixFQUFpQjtBQUNmOTVCLG1CQUFRODVCLEdBQVIsQ0FBWW1NLE1BQU1oMkMsQ0FBTixFQUFTcWMsR0FBckIsRUFBMEJuUixLQUExQixFQUFpQzIrQixHQUFqQztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQW1NLGFBQU0vMUMsTUFBTixHQUFlMHdDLEdBQWY7QUFDQXdGLGlCQUFVeEYsT0FBT3FGLE1BQU1yRixNQUFNLENBQVosRUFBZXQwQixHQUFoQztBQUNELE1BbkJELE1BbUJPLElBQUlxN0Isc0JBQXNCLElBQTFCLEVBQWdDO0FBQ3JDLFdBQUkzbkMsUUFBUTdFLEtBQVosRUFBbUI7QUFDakI2RSxpQkFBUTdFLEtBQVIsQ0FBYzhzQixPQUFkLEVBQXVCLEVBQXZCLEVBQTJCLElBQTNCLEVBQWlDOXNCLEtBQWpDLEVBQXdDMitCLEdBQXhDO0FBQ0Q7QUFDRixNQUpNLE1BSUEsSUFBSTZOLHNCQUFzQixHQUExQixFQUErQjtBQUNwQyxXQUFJM25DLFFBQVE3RSxLQUFaLEVBQW1CO0FBQ2pCNkUsaUJBQVE3RSxLQUFSLENBQWM4c0IsT0FBZCxFQUF1QixFQUF2QixFQUEyQixLQUEzQixFQUFrQzlzQixLQUFsQyxFQUF5QzIrQixHQUF6QztBQUNEO0FBQ0QsV0FBSTk1QixRQUFRODVCLEdBQVosRUFBaUI7QUFDZjk1QixpQkFBUTg1QixHQUFSLENBQVk3UixPQUFaLEVBQXFCOXNCLEtBQXJCLEVBQTRCMitCLEdBQTVCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSThOLE9BQU8sV0FBWDtBQUNBLEtBQUlDLFFBQVEsV0FBWjtBQUNBLEtBQUlDLGFBQWEsMEJBQWpCO0FBQ0EsS0FBSUMsZ0JBQWdCLDRDQUFwQjs7QUFFQSxLQUFJQyxRQUFRLFFBQVo7QUFDQSxLQUFJQyxTQUFTLGFBQWI7QUFDQSxLQUFJQyxhQUFhLFVBQWpCOztBQUVBLEtBQUlDLG1CQUFtQnB1QyxPQUFPeXFDLEdBQUdDLE1BQVYsQ0FBdkI7O0FBRUE7QUFDQSxLQUFJMkQsTUFBSjtBQUNBLEtBQUlwRixVQUFKO0FBQ0EsS0FBSXFGLFVBQUo7QUFDQSxLQUFJQyxhQUFKO0FBQ0EsS0FBSUMsY0FBSjtBQUNBLEtBQUlDLGdCQUFKO0FBQ0EsS0FBSUMsbUJBQUo7QUFDQSxLQUFJQyx1QkFBSjs7QUFFQTs7O0FBR0EsVUFBU0MsS0FBVCxDQUNFN3lCLFFBREYsRUFFRTlWLE9BRkYsRUFHRTtBQUNBb29DLFlBQVNwb0MsUUFBUVgsSUFBUixJQUFnQjZ4QixRQUF6Qjs7QUFFQXNYLHNCQUFtQnhvQyxRQUFRMG5CLFFBQVIsSUFBb0IvckIsRUFBdkM7QUFDQThzQyx5QkFBc0J6b0MsUUFBUTNCLFdBQVIsSUFBdUIxQyxFQUE3QztBQUNBK3NDLDZCQUEwQjFvQyxRQUFRN0IsZUFBUixJQUEyQnhDLEVBQXJEOztBQUVBMHNDLGdCQUFhbFgsb0JBQW9CbnhCLFFBQVFsRSxPQUE1QixFQUFxQyxlQUFyQyxDQUFiO0FBQ0F3c0MsbUJBQWdCblgsb0JBQW9CbnhCLFFBQVFsRSxPQUE1QixFQUFxQyxrQkFBckMsQ0FBaEI7QUFDQXlzQyxvQkFBaUJwWCxvQkFBb0JueEIsUUFBUWxFLE9BQTVCLEVBQXFDLG1CQUFyQyxDQUFqQjs7QUFFQWtuQyxnQkFBYWhqQyxRQUFRZ2pDLFVBQXJCOztBQUVBLE9BQUlpRCxRQUFRLEVBQVo7QUFDQSxPQUFJMkMscUJBQXFCNW9DLFFBQVE0b0Msa0JBQVIsS0FBK0IsS0FBeEQ7QUFDQSxPQUFJcjZDLElBQUo7QUFDQSxPQUFJczZDLGFBQUo7QUFDQSxPQUFJQyxTQUFTLEtBQWI7QUFDQSxPQUFJM2UsUUFBUSxLQUFaO0FBQ0EsT0FBSTRlLFNBQVMsS0FBYjs7QUFFQSxZQUFTQyxRQUFULENBQW1CcnBDLEdBQW5CLEVBQXdCO0FBQ3RCLFNBQUksQ0FBQ29wQyxNQUFMLEVBQWE7QUFDWEEsZ0JBQVMsSUFBVDtBQUNBWCxjQUFPem9DLEdBQVA7QUFDRDtBQUNGOztBQUVELFlBQVNzcEMsTUFBVCxDQUFpQkMsT0FBakIsRUFBMEI7QUFDeEI7QUFDQSxTQUFJQSxRQUFRM2UsR0FBWixFQUFpQjtBQUNmdWUsZ0JBQVMsS0FBVDtBQUNEO0FBQ0QsU0FBSU4saUJBQWlCVSxRQUFRNThCLEdBQXpCLENBQUosRUFBbUM7QUFDakM2ZCxlQUFRLEtBQVI7QUFDRDtBQUNGOztBQUVENmIsYUFBVWx3QixRQUFWLEVBQW9CO0FBQ2xCelcsV0FBTStvQyxNQURZO0FBRWxCOUQsaUJBQVl0a0MsUUFBUXNrQyxVQUZGO0FBR2xCSixpQkFBWWxrQyxRQUFRa2tDLFVBSEY7QUFJbEJDLHVCQUFrQm5rQyxRQUFRbWtDLGdCQUpSO0FBS2xCdkIsMkJBQXNCNWlDLFFBQVE0aUMsb0JBTFo7QUFNbEIyRCx3QkFBbUJ2bUMsUUFBUW1wQyxRQU5UO0FBT2xCaHVDLFlBQU8sU0FBU0EsS0FBVCxDQUFnQm1SLEdBQWhCLEVBQXFCZ0UsS0FBckIsRUFBNEJtM0IsS0FBNUIsRUFBbUM7QUFDeEM7QUFDQTtBQUNBLFdBQUk1NUIsS0FBTWc3QixpQkFBaUJBLGNBQWNoN0IsRUFBaEMsSUFBdUM2NkIsd0JBQXdCcDhCLEdBQXhCLENBQWhEOztBQUVBO0FBQ0E7QUFDQSxXQUFJakwsUUFBUXdNLE9BQU8sS0FBbkIsRUFBMEI7QUFDeEJ5QyxpQkFBUTg0QixjQUFjOTRCLEtBQWQsQ0FBUjtBQUNEOztBQUVELFdBQUk0NEIsVUFBVTtBQUNaLy9CLGVBQU0sQ0FETTtBQUVabUQsY0FBS0EsR0FGTztBQUdaK2xCLG9CQUFXL2hCLEtBSEM7QUFJWjhoQixtQkFBVWlYLGFBQWEvNEIsS0FBYixDQUpFO0FBS1pwSSxpQkFBUTJnQyxhQUxJO0FBTVp0N0IsbUJBQVU7QUFORSxRQUFkO0FBUUEsV0FBSU0sRUFBSixFQUFRO0FBQ05xN0IsaUJBQVFyN0IsRUFBUixHQUFhQSxFQUFiO0FBQ0Q7O0FBRUQsV0FBSXk3QixlQUFlSixPQUFmLEtBQTJCLENBQUNobkMsbUJBQWhDLEVBQXFEO0FBQ25EZ25DLGlCQUFRSyxTQUFSLEdBQW9CLElBQXBCO0FBQ0Foc0MsaUJBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzJxQyxPQUN2Qyx1RUFDQSxzRUFEQSxHQUVBLEdBRkEsR0FFTTk3QixHQUZOLEdBRVksR0FGWixHQUVrQiwrQkFIcUIsQ0FBekM7QUFLRDs7QUFFRDtBQUNBLFlBQUssSUFBSXJjLElBQUksQ0FBYixFQUFnQkEsSUFBSXE0QyxjQUFjcDRDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztBQUM3Q3E0Qyx1QkFBY3I0QyxDQUFkLEVBQWlCaTVDLE9BQWpCLEVBQTBCbHBDLE9BQTFCO0FBQ0Q7O0FBRUQsV0FBSSxDQUFDOG9DLE1BQUwsRUFBYTtBQUNYVSxvQkFBV04sT0FBWDtBQUNBLGFBQUlBLFFBQVEzZSxHQUFaLEVBQWlCO0FBQ2Z1ZSxvQkFBUyxJQUFUO0FBQ0Q7QUFDRjtBQUNELFdBQUlOLGlCQUFpQlUsUUFBUTU4QixHQUF6QixDQUFKLEVBQW1DO0FBQ2pDNmQsaUJBQVEsSUFBUjtBQUNEO0FBQ0QsV0FBSTJlLE1BQUosRUFBWTtBQUNWVyx5QkFBZ0JQLE9BQWhCO0FBQ0QsUUFGRCxNQUVPO0FBQ0xRLG9CQUFXUixPQUFYO0FBQ0FTLG1CQUFVVCxPQUFWO0FBQ0FVLHFCQUFZVixPQUFaO0FBQ0FXLG9CQUFXWCxPQUFYOztBQUVBO0FBQ0E7QUFDQUEsaUJBQVFZLEtBQVIsR0FBZ0IsQ0FBQ1osUUFBUXB2QyxHQUFULElBQWdCLENBQUN3VyxNQUFNcGdCLE1BQXZDOztBQUVBNjVDLG9CQUFXYixPQUFYO0FBQ0FjLHFCQUFZZCxPQUFaO0FBQ0FlLDBCQUFpQmYsT0FBakI7QUFDQSxjQUFLLElBQUk3MUIsTUFBTSxDQUFmLEVBQWtCQSxNQUFNZzFCLFdBQVduNEMsTUFBbkMsRUFBMkNtakIsS0FBM0MsRUFBa0Q7QUFDaERnMUIsc0JBQVdoMUIsR0FBWCxFQUFnQjYxQixPQUFoQixFQUF5QmxwQyxPQUF6QjtBQUNEO0FBQ0RrcUMsc0JBQWFoQixPQUFiO0FBQ0Q7O0FBRUQsZ0JBQVNpQixvQkFBVCxDQUErQm5pQyxFQUEvQixFQUFtQztBQUNqQyxhQUFJekssUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGVBQUl1SyxHQUFHc0UsR0FBSCxLQUFXLE1BQVgsSUFBcUJ0RSxHQUFHc0UsR0FBSCxLQUFXLFVBQXBDLEVBQWdEO0FBQzlDMDhCLHNCQUNFLGlCQUFrQmhoQyxHQUFHc0UsR0FBckIsR0FBNEIsNkNBQTVCLEdBQ0EseUJBRkY7QUFJRDtBQUNELGVBQUl0RSxHQUFHb3FCLFFBQUgsQ0FBWXg0QixjQUFaLENBQTJCLE9BQTNCLENBQUosRUFBeUM7QUFDdkNvdkMsc0JBQ0UsaUVBQ0EsK0JBRkY7QUFJRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxXQUFJLENBQUN6NkMsSUFBTCxFQUFXO0FBQ1RBLGdCQUFPMjZDLE9BQVA7QUFDQWlCLDhCQUFxQjU3QyxJQUFyQjtBQUNELFFBSEQsTUFHTyxJQUFJLENBQUMwM0MsTUFBTS8xQyxNQUFYLEVBQW1CO0FBQ3hCO0FBQ0EsYUFBSTNCLEtBQUs2N0MsRUFBTCxLQUFZbEIsUUFBUW1CLE1BQVIsSUFBa0JuQixRQUFRb0IsSUFBdEMsQ0FBSixFQUFpRDtBQUMvQ0gsZ0NBQXFCakIsT0FBckI7QUFDQXFCLDBCQUFlaDhDLElBQWYsRUFBcUI7QUFDbkI2aEMsa0JBQUs4WSxRQUFRbUIsTUFETTtBQUVuQkcsb0JBQU90QjtBQUZZLFlBQXJCO0FBSUQsVUFORCxNQU1PLElBQUkzckMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hEdXJDLG9CQUNFLGlFQUNBLDhDQURBLEdBRUEsc0NBSEY7QUFLRDtBQUNGO0FBQ0QsV0FBSUgsaUJBQWlCLENBQUNLLFFBQVFLLFNBQTlCLEVBQXlDO0FBQ3ZDLGFBQUlMLFFBQVFtQixNQUFSLElBQWtCbkIsUUFBUW9CLElBQTlCLEVBQW9DO0FBQ2xDRywrQkFBb0J2QixPQUFwQixFQUE2QkwsYUFBN0I7QUFDRCxVQUZELE1BRU8sSUFBSUssUUFBUXdCLFNBQVosRUFBdUI7QUFBRTtBQUM5QjdCLHlCQUFjaUIsS0FBZCxHQUFzQixLQUF0QjtBQUNBLGVBQUl0NUMsT0FBTzA0QyxRQUFReUIsVUFBUixJQUFzQixXQUFqQyxDQUE2QyxDQUFDOUIsY0FBY3B5QixXQUFkLEtBQThCb3lCLGNBQWNweUIsV0FBZCxHQUE0QixFQUExRCxDQUFELEVBQWdFam1CLElBQWhFLElBQXdFMDRDLE9BQXhFO0FBQzlDLFVBSE0sTUFHQTtBQUNMTCx5QkFBY3Q3QixRQUFkLENBQXVCMU0sSUFBdkIsQ0FBNEJxb0MsT0FBNUI7QUFDQUEsbUJBQVFoaEMsTUFBUixHQUFpQjJnQyxhQUFqQjtBQUNEO0FBQ0Y7QUFDRCxXQUFJLENBQUNwQixLQUFMLEVBQVk7QUFDVm9CLHlCQUFnQkssT0FBaEI7QUFDQWpELGVBQU1wbEMsSUFBTixDQUFXcW9DLE9BQVg7QUFDRCxRQUhELE1BR087QUFDTEQsZ0JBQU9DLE9BQVA7QUFDRDtBQUNEO0FBQ0EsWUFBSyxJQUFJMEIsTUFBTSxDQUFmLEVBQWtCQSxNQUFNckMsZUFBZXI0QyxNQUF2QyxFQUErQzA2QyxLQUEvQyxFQUFzRDtBQUNwRHJDLHdCQUFlcUMsR0FBZixFQUFvQjFCLE9BQXBCLEVBQTZCbHBDLE9BQTdCO0FBQ0Q7QUFDRixNQXBJaUI7O0FBc0lsQjg1QixVQUFLLFNBQVNBLEdBQVQsR0FBZ0I7QUFDbkI7QUFDQSxXQUFJb1AsVUFBVWpELE1BQU1BLE1BQU0vMUMsTUFBTixHQUFlLENBQXJCLENBQWQ7QUFDQSxXQUFJMjZDLFdBQVczQixRQUFRMzdCLFFBQVIsQ0FBaUIyN0IsUUFBUTM3QixRQUFSLENBQWlCcmQsTUFBakIsR0FBMEIsQ0FBM0MsQ0FBZjtBQUNBLFdBQUkyNkMsWUFBWUEsU0FBUzFoQyxJQUFULEtBQWtCLENBQTlCLElBQW1DMGhDLFNBQVNyOUIsSUFBVCxLQUFrQixHQUFyRCxJQUE0RCxDQUFDMmMsS0FBakUsRUFBd0U7QUFDdEUrZSxpQkFBUTM3QixRQUFSLENBQWlCbEksR0FBakI7QUFDRDtBQUNEO0FBQ0E0Z0MsYUFBTS8xQyxNQUFOLElBQWdCLENBQWhCO0FBQ0EyNEMsdUJBQWdCNUMsTUFBTUEsTUFBTS8xQyxNQUFOLEdBQWUsQ0FBckIsQ0FBaEI7QUFDQSs0QyxjQUFPQyxPQUFQO0FBQ0QsTUFqSmlCOztBQW1KbEJoQyxZQUFPLFNBQVNBLEtBQVQsQ0FBZ0IxNUIsSUFBaEIsRUFBc0I7QUFDM0IsV0FBSSxDQUFDcTdCLGFBQUwsRUFBb0I7QUFDbEIsYUFBSXRyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsZUFBSStQLFNBQVNzSSxRQUFiLEVBQXVCO0FBQ3JCa3pCLHNCQUNFLG9FQURGO0FBR0QsWUFKRCxNQUlPLElBQUt4N0IsT0FBT0EsS0FBS3VqQixJQUFMLEVBQVosRUFBMEI7QUFDL0JpWSxzQkFDRyxZQUFZeDdCLElBQVosR0FBbUIsMENBRHRCO0FBR0Q7QUFDRjtBQUNEO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsV0FBSW5NLFFBQ0Z3bkMsY0FBY3Y4QixHQUFkLEtBQXNCLFVBRHBCLElBRUZ1OEIsY0FBY3pXLFFBQWQsQ0FBdUJ1TixXQUF2QixLQUF1Q255QixJQUZ6QyxFQUdFO0FBQ0E7QUFDRDtBQUNELFdBQUlELFdBQVdzN0IsY0FBY3Q3QixRQUE3QjtBQUNBQyxjQUFPMmMsU0FBUzNjLEtBQUt1akIsSUFBTCxFQUFULEdBQ0grWixVQUFVakMsYUFBVixJQUEyQnI3QixJQUEzQixHQUFrQzI2QixpQkFBaUIzNkIsSUFBakI7QUFDcEM7QUFGSyxTQUdIbzdCLHNCQUFzQnI3QixTQUFTcmQsTUFBL0IsR0FBd0MsR0FBeEMsR0FBOEMsRUFIbEQ7QUFJQSxXQUFJc2QsSUFBSixFQUFVO0FBQ1IsYUFBSTBLLFVBQUo7QUFDQSxhQUFJLENBQUM0d0IsTUFBRCxJQUFXdDdCLFNBQVMsR0FBcEIsS0FBNEIwSyxhQUFhaXJCLFVBQVUzMUIsSUFBVixFQUFnQncxQixVQUFoQixDQUF6QyxDQUFKLEVBQTJFO0FBQ3pFejFCLG9CQUFTMU0sSUFBVCxDQUFjO0FBQ1pzSSxtQkFBTSxDQURNO0FBRVorTyx5QkFBWUEsVUFGQTtBQUdaMUssbUJBQU1BO0FBSE0sWUFBZDtBQUtELFVBTkQsTUFNTyxJQUFJQSxTQUFTLEdBQVQsSUFBZ0IsQ0FBQ0QsU0FBU3JkLE1BQTFCLElBQW9DcWQsU0FBU0EsU0FBU3JkLE1BQVQsR0FBa0IsQ0FBM0IsRUFBOEJzZCxJQUE5QixLQUF1QyxHQUEvRSxFQUFvRjtBQUN6RkQsb0JBQVMxTSxJQUFULENBQWM7QUFDWnNJLG1CQUFNLENBRE07QUFFWnFFLG1CQUFNQTtBQUZNLFlBQWQ7QUFJRDtBQUNGO0FBQ0YsTUE5TGlCO0FBK0xsQjIzQixjQUFTLFNBQVNBLE9BQVQsQ0FBa0IzM0IsSUFBbEIsRUFBd0I7QUFDL0JxN0IscUJBQWN0N0IsUUFBZCxDQUF1QjFNLElBQXZCLENBQTRCO0FBQzFCc0ksZUFBTSxDQURvQjtBQUUxQnFFLGVBQU1BLElBRm9CO0FBRzFCVyxvQkFBVztBQUhlLFFBQTVCO0FBS0Q7QUFyTWlCLElBQXBCO0FBdU1BLFVBQU81ZixJQUFQO0FBQ0Q7O0FBRUQsVUFBU2k3QyxVQUFULENBQXFCeGhDLEVBQXJCLEVBQXlCO0FBQ3ZCLE9BQUlrcUIsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE9BQXJCLEtBQWlDLElBQXJDLEVBQTJDO0FBQ3pDQSxRQUFHdWlCLEdBQUgsR0FBUyxJQUFUO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTa2YsZUFBVCxDQUEwQnpoQyxFQUExQixFQUE4QjtBQUM1QixPQUFJaE4sSUFBSWdOLEdBQUdxcUIsU0FBSCxDQUFhbmlDLE1BQXJCO0FBQ0EsT0FBSThLLENBQUosRUFBTztBQUNMLFNBQUlzVixRQUFRdEksR0FBR3NJLEtBQUgsR0FBVyxJQUFJalYsS0FBSixDQUFVTCxDQUFWLENBQXZCO0FBQ0EsVUFBSyxJQUFJL0ssSUFBSSxDQUFiLEVBQWdCQSxJQUFJK0ssQ0FBcEIsRUFBdUIvSyxHQUF2QixFQUE0QjtBQUMxQnFnQixhQUFNcmdCLENBQU4sSUFBVztBQUNUTyxlQUFNd1gsR0FBR3FxQixTQUFILENBQWFwaUMsQ0FBYixFQUFnQk8sSUFEYjtBQUVUb0gsZ0JBQU9hLEtBQUtDLFNBQUwsQ0FBZXNQLEdBQUdxcUIsU0FBSCxDQUFhcGlDLENBQWIsRUFBZ0IySCxLQUEvQjtBQUZFLFFBQVg7QUFJRDtBQUNGLElBUkQsTUFRTyxJQUFJLENBQUNvUSxHQUFHdWlCLEdBQVIsRUFBYTtBQUNsQjtBQUNBdmlCLFFBQUc4aEMsS0FBSCxHQUFXLElBQVg7QUFDRDtBQUNGOztBQUVELFVBQVNELFVBQVQsQ0FBcUI3aEMsRUFBckIsRUFBeUI7QUFDdkIsT0FBSW9vQixNQUFNMkIsZUFBZS9wQixFQUFmLEVBQW1CLEtBQW5CLENBQVY7QUFDQSxPQUFJb29CLEdBQUosRUFBUztBQUNQLFNBQUk3eUIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDdUssR0FBR3NFLEdBQUgsS0FBVyxVQUF4RCxFQUFvRTtBQUNsRTg3QixjQUFPLHFFQUFQO0FBQ0Q7QUFDRHBnQyxRQUFHbE8sR0FBSCxHQUFTczJCLEdBQVQ7QUFDRDtBQUNGOztBQUVELFVBQVMyWixVQUFULENBQXFCL2hDLEVBQXJCLEVBQXlCO0FBQ3ZCLE9BQUlxWixNQUFNMFEsZUFBZS9wQixFQUFmLEVBQW1CLEtBQW5CLENBQVY7QUFDQSxPQUFJcVosR0FBSixFQUFTO0FBQ1ByWixRQUFHcVosR0FBSCxHQUFTQSxHQUFUO0FBQ0FyWixRQUFHbWhCLFFBQUgsR0FBYzRoQixXQUFXL2lDLEVBQVgsQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzBoQyxVQUFULENBQXFCMWhDLEVBQXJCLEVBQXlCO0FBQ3ZCLE9BQUlvb0IsR0FBSjtBQUNBLE9BQUtBLE1BQU04QixpQkFBaUJscUIsRUFBakIsRUFBcUIsT0FBckIsQ0FBWCxFQUEyQztBQUN6QyxTQUFJZ2pDLFVBQVU1YSxJQUFJOXZCLEtBQUosQ0FBVXduQyxVQUFWLENBQWQ7QUFDQSxTQUFJLENBQUNrRCxPQUFMLEVBQWM7QUFDWnp0QyxlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMycUMsT0FDdEMsK0JBQStCaFksR0FETyxDQUF6QztBQUdBO0FBQ0Q7QUFDRHBvQixRQUFHaWpDLEdBQUgsR0FBU0QsUUFBUSxDQUFSLEVBQVdqYSxJQUFYLEVBQVQ7QUFDQSxTQUFJbWEsUUFBUUYsUUFBUSxDQUFSLEVBQVdqYSxJQUFYLEVBQVo7QUFDQSxTQUFJb2EsZ0JBQWdCRCxNQUFNNXFDLEtBQU4sQ0FBWXluQyxhQUFaLENBQXBCO0FBQ0EsU0FBSW9ELGFBQUosRUFBbUI7QUFDakJuakMsVUFBR2tqQyxLQUFILEdBQVdDLGNBQWMsQ0FBZCxFQUFpQnBhLElBQWpCLEVBQVg7QUFDQS9vQixVQUFHb2pDLFNBQUgsR0FBZUQsY0FBYyxDQUFkLEVBQWlCcGEsSUFBakIsRUFBZjtBQUNBLFdBQUlvYSxjQUFjLENBQWQsQ0FBSixFQUFzQjtBQUNwQm5qQyxZQUFHcWpDLFNBQUgsR0FBZUYsY0FBYyxDQUFkLEVBQWlCcGEsSUFBakIsRUFBZjtBQUNEO0FBQ0YsTUFORCxNQU1PO0FBQ0wvb0IsVUFBR2tqQyxLQUFILEdBQVdBLEtBQVg7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU3ZCLFNBQVQsQ0FBb0IzaEMsRUFBcEIsRUFBd0I7QUFDdEIsT0FBSW9vQixNQUFNOEIsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE1BQXJCLENBQVY7QUFDQSxPQUFJb29CLEdBQUosRUFBUztBQUNQcG9CLFFBQUdvaUMsRUFBSCxHQUFRaGEsR0FBUjtBQUNBbWEsb0JBQWV2aUMsRUFBZixFQUFtQjtBQUNqQm9vQixZQUFLQSxHQURZO0FBRWpCb2EsY0FBT3hpQztBQUZVLE1BQW5CO0FBSUQsSUFORCxNQU1PO0FBQ0wsU0FBSWtxQixpQkFBaUJscUIsRUFBakIsRUFBcUIsUUFBckIsS0FBa0MsSUFBdEMsRUFBNEM7QUFDMUNBLFVBQUdzaUMsSUFBSCxHQUFVLElBQVY7QUFDRDtBQUNELFNBQUlELFNBQVNuWSxpQkFBaUJscUIsRUFBakIsRUFBcUIsV0FBckIsQ0FBYjtBQUNBLFNBQUlxaUMsTUFBSixFQUFZO0FBQ1ZyaUMsVUFBR3FpQyxNQUFILEdBQVlBLE1BQVo7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU0ksbUJBQVQsQ0FBOEJ6aUMsRUFBOUIsRUFBa0NFLE1BQWxDLEVBQTBDO0FBQ3hDLE9BQUkyb0IsT0FBT3lhLGdCQUFnQnBqQyxPQUFPcUYsUUFBdkIsQ0FBWDtBQUNBLE9BQUlzakIsUUFBUUEsS0FBS3VaLEVBQWpCLEVBQXFCO0FBQ25CRyxvQkFBZTFaLElBQWYsRUFBcUI7QUFDbkJULFlBQUtwb0IsR0FBR3FpQyxNQURXO0FBRW5CRyxjQUFPeGlDO0FBRlksTUFBckI7QUFJRCxJQUxELE1BS08sSUFBSXpLLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRDJxQyxZQUNFLFFBQVFwZ0MsR0FBR3FpQyxNQUFILEdBQWEsY0FBY3JpQyxHQUFHcWlDLE1BQWpCLEdBQTBCLEdBQXZDLEdBQThDLE1BQXRELElBQWdFLEdBQWhFLEdBQ0EsbUJBREEsR0FDdUJyaUMsR0FBR3NFLEdBRDFCLEdBQ2lDLCtCQUZuQztBQUlEO0FBQ0Y7O0FBRUQsVUFBU2cvQixlQUFULENBQTBCLzlCLFFBQTFCLEVBQW9DO0FBQ2xDLE9BQUl0ZCxJQUFJc2QsU0FBU3JkLE1BQWpCO0FBQ0EsVUFBT0QsR0FBUCxFQUFZO0FBQ1YsU0FBSXNkLFNBQVN0ZCxDQUFULEVBQVlrWixJQUFaLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGNBQU9vRSxTQUFTdGQsQ0FBVCxDQUFQO0FBQ0QsTUFGRCxNQUVPO0FBQ0wsV0FBSXNOLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzhQLFNBQVN0ZCxDQUFULEVBQVl1ZCxJQUFaLEtBQXFCLEdBQWxFLEVBQXVFO0FBQ3JFNDZCLGdCQUNFLFlBQWE3NkIsU0FBU3RkLENBQVQsRUFBWXVkLElBQVosQ0FBaUJ1akIsSUFBakIsRUFBYixHQUF3QyxrQ0FBeEMsR0FDQSxrQkFGRjtBQUlEO0FBQ0R4akIsZ0JBQVNsSSxHQUFUO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVNrbEMsY0FBVCxDQUF5QnZpQyxFQUF6QixFQUE2QnVqQyxTQUE3QixFQUF3QztBQUN0QyxPQUFJLENBQUN2akMsR0FBR3dqQyxZQUFSLEVBQXNCO0FBQ3BCeGpDLFFBQUd3akMsWUFBSCxHQUFrQixFQUFsQjtBQUNEO0FBQ0R4akMsTUFBR3dqQyxZQUFILENBQWdCM3FDLElBQWhCLENBQXFCMHFDLFNBQXJCO0FBQ0Q7O0FBRUQsVUFBUzNCLFdBQVQsQ0FBc0I1aEMsRUFBdEIsRUFBMEI7QUFDeEIsT0FBSW9ILFVBQVU4aUIsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLFFBQXJCLENBQWQ7QUFDQSxPQUFJb0gsV0FBVyxJQUFmLEVBQXFCO0FBQ25CcEgsUUFBR2xMLElBQUgsR0FBVSxJQUFWO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTa3RDLFdBQVQsQ0FBc0JoaUMsRUFBdEIsRUFBMEI7QUFDeEIsT0FBSUEsR0FBR3NFLEdBQUgsS0FBVyxNQUFmLEVBQXVCO0FBQ3JCdEUsUUFBR3lqQyxRQUFILEdBQWMxWixlQUFlL3BCLEVBQWYsRUFBbUIsTUFBbkIsQ0FBZDtBQUNBLFNBQUl6SyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUN1SyxHQUFHbE8sR0FBaEQsRUFBcUQ7QUFDbkRzdUMsY0FDRSxzRUFDQSxrREFEQSxHQUVBLDRDQUhGO0FBS0Q7QUFDRixJQVRELE1BU087QUFDTCxTQUFJdUMsYUFBYTVZLGVBQWUvcEIsRUFBZixFQUFtQixNQUFuQixDQUFqQjtBQUNBLFNBQUkyaUMsVUFBSixFQUFnQjtBQUNkM2lDLFVBQUcyaUMsVUFBSCxHQUFnQkEsZUFBZSxJQUFmLEdBQXNCLFdBQXRCLEdBQW9DQSxVQUFwRDtBQUNEO0FBQ0QsU0FBSTNpQyxHQUFHc0UsR0FBSCxLQUFXLFVBQWYsRUFBMkI7QUFDekJ0RSxVQUFHMGlDLFNBQUgsR0FBZXhZLGlCQUFpQmxxQixFQUFqQixFQUFxQixPQUFyQixDQUFmO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVNpaUMsZ0JBQVQsQ0FBMkJqaUMsRUFBM0IsRUFBK0I7QUFDN0IsT0FBSSsxQixPQUFKO0FBQ0EsT0FBS0EsVUFBVWhNLGVBQWUvcEIsRUFBZixFQUFtQixJQUFuQixDQUFmLEVBQTBDO0FBQ3hDQSxRQUFHa0ssU0FBSCxHQUFlNnJCLE9BQWY7QUFDRDtBQUNELE9BQUk3TCxpQkFBaUJscUIsRUFBakIsRUFBcUIsaUJBQXJCLEtBQTJDLElBQS9DLEVBQXFEO0FBQ25EQSxRQUFHdVcsY0FBSCxHQUFvQixJQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzJyQixZQUFULENBQXVCbGlDLEVBQXZCLEVBQTJCO0FBQ3pCLE9BQUk3TyxPQUFPNk8sR0FBR3FxQixTQUFkO0FBQ0EsT0FBSXBpQyxDQUFKLEVBQU8rSyxDQUFQLEVBQVV4SyxJQUFWLEVBQWdCMitCLE9BQWhCLEVBQXlCdjNCLEtBQXpCLEVBQWdDcTNCLFNBQWhDLEVBQTJDeWMsTUFBM0M7QUFDQSxRQUFLejdDLElBQUksQ0FBSixFQUFPK0ssSUFBSTdCLEtBQUtqSixNQUFyQixFQUE2QkQsSUFBSStLLENBQWpDLEVBQW9DL0ssR0FBcEMsRUFBeUM7QUFDdkNPLFlBQU8yK0IsVUFBVWgyQixLQUFLbEosQ0FBTCxFQUFRTyxJQUF6QjtBQUNBb0gsYUFBUXVCLEtBQUtsSixDQUFMLEVBQVEySCxLQUFoQjtBQUNBLFNBQUlpd0MsTUFBTTFvQyxJQUFOLENBQVczTyxJQUFYLENBQUosRUFBc0I7QUFDcEI7QUFDQXdYLFVBQUcyakMsV0FBSCxHQUFpQixJQUFqQjtBQUNBO0FBQ0ExYyxtQkFBWTJjLGVBQWVwN0MsSUFBZixDQUFaO0FBQ0EsV0FBSXkrQixTQUFKLEVBQWU7QUFDYnorQixnQkFBT0EsS0FBSzhKLE9BQUwsQ0FBYTR0QyxVQUFiLEVBQXlCLEVBQXpCLENBQVA7QUFDRDtBQUNELFdBQUlELE9BQU85b0MsSUFBUCxDQUFZM08sSUFBWixDQUFKLEVBQXVCO0FBQUU7QUFDdkJBLGdCQUFPQSxLQUFLOEosT0FBTCxDQUFhMnRDLE1BQWIsRUFBcUIsRUFBckIsQ0FBUDtBQUNBcndDLGlCQUFRdTRCLGFBQWF2NEIsS0FBYixDQUFSO0FBQ0E4ekMsa0JBQVMsS0FBVDtBQUNBLGFBQUl6YyxTQUFKLEVBQWU7QUFDYixlQUFJQSxVQUFVbGtCLElBQWQsRUFBb0I7QUFDbEIyZ0Msc0JBQVMsSUFBVDtBQUNBbDdDLG9CQUFPNkosU0FBUzdKLElBQVQsQ0FBUDtBQUNBLGlCQUFJQSxTQUFTLFdBQWIsRUFBMEI7QUFBRUEsc0JBQU8sV0FBUDtBQUFxQjtBQUNsRDtBQUNELGVBQUl5K0IsVUFBVTRjLEtBQWQsRUFBcUI7QUFDbkJyN0Msb0JBQU82SixTQUFTN0osSUFBVCxDQUFQO0FBQ0Q7QUFDRCxlQUFJeStCLFVBQVVuZCxJQUFkLEVBQW9CO0FBQ2xCMGYsd0JBQ0V4cEIsRUFERixFQUVHLFlBQWEzTixTQUFTN0osSUFBVCxDQUZoQixFQUdFbWlDLGtCQUFrQi82QixLQUFsQixFQUF5QixRQUF6QixDQUhGO0FBS0Q7QUFDRjtBQUNELGFBQUk4ekMsVUFDRixDQUFDMWpDLEdBQUdrSyxTQUFKLElBQWlCdTJCLG9CQUFvQnpnQyxHQUFHc0UsR0FBdkIsRUFBNEJ0RSxHQUFHb3FCLFFBQUgsQ0FBWWpwQixJQUF4QyxFQUE4QzNZLElBQTlDLENBRG5CLEVBRUc7QUFDRDRnQyxtQkFBUXBwQixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCb0gsS0FBbEI7QUFDRCxVQUpELE1BSU87QUFDTHk1QixtQkFBUXJwQixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCb0gsS0FBbEI7QUFDRDtBQUNGLFFBNUJELE1BNEJPLElBQUlnd0MsS0FBS3pvQyxJQUFMLENBQVUzTyxJQUFWLENBQUosRUFBcUI7QUFBRTtBQUM1QkEsZ0JBQU9BLEtBQUs4SixPQUFMLENBQWFzdEMsSUFBYixFQUFtQixFQUFuQixDQUFQO0FBQ0FwVyxvQkFBV3hwQixFQUFYLEVBQWV4WCxJQUFmLEVBQXFCb0gsS0FBckIsRUFBNEJxM0IsU0FBNUIsRUFBdUMsS0FBdkMsRUFBOENtWixNQUE5QztBQUNELFFBSE0sTUFHQTtBQUFFO0FBQ1A1M0MsZ0JBQU9BLEtBQUs4SixPQUFMLENBQWF1dEMsS0FBYixFQUFvQixFQUFwQixDQUFQO0FBQ0E7QUFDQSxhQUFJaUUsV0FBV3Q3QyxLQUFLOFAsS0FBTCxDQUFXMG5DLEtBQVgsQ0FBZjtBQUNBLGFBQUl6VyxNQUFNdWEsWUFBWUEsU0FBUyxDQUFULENBQXRCO0FBQ0EsYUFBSXZhLEdBQUosRUFBUztBQUNQL2dDLGtCQUFPQSxLQUFLcUIsS0FBTCxDQUFXLENBQVgsRUFBYyxFQUFFMC9CLElBQUlyaEMsTUFBSixHQUFhLENBQWYsQ0FBZCxDQUFQO0FBQ0Q7QUFDRG9oQyxzQkFBYXRwQixFQUFiLEVBQWlCeFgsSUFBakIsRUFBdUIyK0IsT0FBdkIsRUFBZ0N2M0IsS0FBaEMsRUFBdUMyNUIsR0FBdkMsRUFBNEN0QyxTQUE1QztBQUNBLGFBQUkxeEIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDak4sU0FBUyxPQUF0RCxFQUErRDtBQUM3RHU3Qyw4QkFBbUIvakMsRUFBbkIsRUFBdUJwUSxLQUF2QjtBQUNEO0FBQ0Y7QUFDRixNQXBERCxNQW9ETztBQUNMO0FBQ0EsV0FBSTJGLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxhQUFJeWEsYUFBYWlyQixVQUFVdnJDLEtBQVYsRUFBaUJvckMsVUFBakIsQ0FBakI7QUFDQSxhQUFJOXFCLFVBQUosRUFBZ0I7QUFDZGt3QixrQkFDRTUzQyxPQUFPLEtBQVAsR0FBZW9ILEtBQWYsR0FBdUIsTUFBdkIsR0FDQSxvREFEQSxHQUVBLDBEQUZBLEdBR0EsdURBSkY7QUFNRDtBQUNGO0FBQ0R5NUIsZUFBUXJwQixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCaUksS0FBS0MsU0FBTCxDQUFlZCxLQUFmLENBQWxCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVNtekMsVUFBVCxDQUFxQi9pQyxFQUFyQixFQUF5QjtBQUN2QixPQUFJRSxTQUFTRixFQUFiO0FBQ0EsVUFBT0UsTUFBUCxFQUFlO0FBQ2IsU0FBSUEsT0FBTytpQyxHQUFQLEtBQWVwN0MsU0FBbkIsRUFBOEI7QUFDNUIsY0FBTyxJQUFQO0FBQ0Q7QUFDRHFZLGNBQVNBLE9BQU9BLE1BQWhCO0FBQ0Q7QUFDRCxVQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFTMGpDLGNBQVQsQ0FBeUJwN0MsSUFBekIsRUFBK0I7QUFDN0IsT0FBSThQLFFBQVE5UCxLQUFLOFAsS0FBTCxDQUFXNG5DLFVBQVgsQ0FBWjtBQUNBLE9BQUk1bkMsS0FBSixFQUFXO0FBQ1QsU0FBSWxGLE1BQU0sRUFBVjtBQUNBa0YsV0FBTXZKLE9BQU4sQ0FBYyxVQUFVaUYsQ0FBVixFQUFhO0FBQUVaLFdBQUlZLEVBQUVuSyxLQUFGLENBQVEsQ0FBUixDQUFKLElBQWtCLElBQWxCO0FBQXlCLE1BQXREO0FBQ0EsWUFBT3VKLEdBQVA7QUFDRDtBQUNGOztBQUVELFVBQVNpdUMsWUFBVCxDQUF1Qi80QixLQUF2QixFQUE4QjtBQUM1QixPQUFJclgsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJaEosSUFBSSxDQUFSLEVBQVcrSyxJQUFJc1YsTUFBTXBnQixNQUExQixFQUFrQ0QsSUFBSStLLENBQXRDLEVBQXlDL0ssR0FBekMsRUFBOEM7QUFDNUMsU0FDRXNOLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUNBeEUsSUFBSXFYLE1BQU1yZ0IsQ0FBTixFQUFTTyxJQUFiLENBREEsSUFDc0IsQ0FBQzZRLElBRHZCLElBQytCLENBQUNFLE1BRmxDLEVBR0U7QUFDQTZtQyxjQUFPLDBCQUEwQjkzQixNQUFNcmdCLENBQU4sRUFBU08sSUFBMUM7QUFDRDtBQUNEeUksU0FBSXFYLE1BQU1yZ0IsQ0FBTixFQUFTTyxJQUFiLElBQXFCOGYsTUFBTXJnQixDQUFOLEVBQVMySCxLQUE5QjtBQUNEO0FBQ0QsVUFBT3FCLEdBQVA7QUFDRDs7QUFFRDtBQUNBLFVBQVM2eEMsU0FBVCxDQUFvQjlpQyxFQUFwQixFQUF3QjtBQUN0QixVQUFPQSxHQUFHc0UsR0FBSCxLQUFXLFFBQVgsSUFBdUJ0RSxHQUFHc0UsR0FBSCxLQUFXLE9BQXpDO0FBQ0Q7O0FBRUQsVUFBU2c5QixjQUFULENBQXlCdGhDLEVBQXpCLEVBQTZCO0FBQzNCLFVBQ0VBLEdBQUdzRSxHQUFILEtBQVcsT0FBWCxJQUNDdEUsR0FBR3NFLEdBQUgsS0FBVyxRQUFYLEtBQ0MsQ0FBQ3RFLEdBQUdvcUIsUUFBSCxDQUFZanBCLElBQWIsSUFDQW5CLEdBQUdvcUIsUUFBSCxDQUFZanBCLElBQVosS0FBcUIsaUJBRnRCLENBRkg7QUFPRDs7QUFFRCxLQUFJNmlDLFVBQVUsY0FBZDtBQUNBLEtBQUlDLGFBQWEsU0FBakI7O0FBRUE7QUFDQSxVQUFTN0MsYUFBVCxDQUF3Qjk0QixLQUF4QixFQUErQjtBQUM3QixPQUFJdmIsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJOUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJcWdCLE1BQU1wZ0IsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3JDLFNBQUlpMkIsT0FBTzVWLE1BQU1yZ0IsQ0FBTixDQUFYO0FBQ0EsU0FBSSxDQUFDKzdDLFFBQVE3c0MsSUFBUixDQUFhK21CLEtBQUsxMUIsSUFBbEIsQ0FBTCxFQUE4QjtBQUM1QjAxQixZQUFLMTFCLElBQUwsR0FBWTAxQixLQUFLMTFCLElBQUwsQ0FBVThKLE9BQVYsQ0FBa0IyeEMsVUFBbEIsRUFBOEIsRUFBOUIsQ0FBWjtBQUNBbDNDLFdBQUk4TCxJQUFKLENBQVNxbEIsSUFBVDtBQUNEO0FBQ0Y7QUFDRCxVQUFPbnhCLEdBQVA7QUFDRDs7QUFFRCxVQUFTZzNDLGtCQUFULENBQTZCL2pDLEVBQTdCLEVBQWlDcFEsS0FBakMsRUFBd0M7QUFDdEMsT0FBSXMwQyxNQUFNbGtDLEVBQVY7QUFDQSxVQUFPa2tDLEdBQVAsRUFBWTtBQUNWLFNBQUlBLElBQUlqQixHQUFKLElBQVdpQixJQUFJaEIsS0FBSixLQUFjdHpDLEtBQTdCLEVBQW9DO0FBQ2xDd3dDLGNBQ0UsTUFBT3BnQyxHQUFHc0UsR0FBVixHQUFpQixhQUFqQixHQUFpQzFVLEtBQWpDLEdBQXlDLE9BQXpDLEdBQ0EsK0RBREEsR0FFQSxpRUFGQSxHQUdBLG9FQUhBLEdBSUEsbUZBTEY7QUFPRDtBQUNEczBDLFdBQU1BLElBQUloa0MsTUFBVjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSWlrQyxXQUFKO0FBQ0EsS0FBSUMscUJBQUo7O0FBRUEsS0FBSUMsc0JBQXNCdHlDLE9BQU91eUMsZUFBUCxDQUExQjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxVQUFTQyxRQUFULENBQW1CaCtDLElBQW5CLEVBQXlCeVIsT0FBekIsRUFBa0M7QUFDaEMsT0FBSSxDQUFDelIsSUFBTCxFQUFXO0FBQUU7QUFBUTtBQUNyQjQ5QyxpQkFBY0Usb0JBQW9CcnNDLFFBQVE5RCxVQUFSLElBQXNCLEVBQTFDLENBQWQ7QUFDQWt3QywyQkFBd0Jwc0MsUUFBUWhDLGFBQVIsSUFBeUJyQyxFQUFqRDtBQUNBO0FBQ0E2d0MsZ0JBQWFqK0MsSUFBYjtBQUNBO0FBQ0FrK0MsbUJBQWdCbCtDLElBQWhCLEVBQXNCLEtBQXRCO0FBQ0Q7O0FBRUQsVUFBUys5QyxlQUFULENBQTBCeDFDLElBQTFCLEVBQWdDO0FBQzlCLFVBQU9nQyxRQUNMLDZEQUNDaEMsT0FBTyxNQUFNQSxJQUFiLEdBQW9CLEVBRHJCLENBREssQ0FBUDtBQUlEOztBQUVELFVBQVMwMUMsWUFBVCxDQUF1Qjc5QixJQUF2QixFQUE2QjtBQUMzQkEsUUFBSys5QixNQUFMLEdBQWN6K0IsU0FBU1UsSUFBVCxDQUFkO0FBQ0EsT0FBSUEsS0FBS3hGLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUNFLENBQUNpakMsc0JBQXNCejlCLEtBQUtyQyxHQUEzQixDQUFELElBQ0FxQyxLQUFLckMsR0FBTCxLQUFhLE1BRGIsSUFFQXFDLEtBQUt5akIsUUFBTCxDQUFjLGlCQUFkLEtBQW9DLElBSHRDLEVBSUU7QUFDQTtBQUNEO0FBQ0QsVUFBSyxJQUFJbmlDLElBQUksQ0FBUixFQUFXK0ssSUFBSTJULEtBQUtwQixRQUFMLENBQWNyZCxNQUFsQyxFQUEwQ0QsSUFBSStLLENBQTlDLEVBQWlEL0ssR0FBakQsRUFBc0Q7QUFDcEQsV0FBSWtZLFFBQVF3RyxLQUFLcEIsUUFBTCxDQUFjdGQsQ0FBZCxDQUFaO0FBQ0F1OEMsb0JBQWFya0MsS0FBYjtBQUNBLFdBQUksQ0FBQ0EsTUFBTXVrQyxNQUFYLEVBQW1CO0FBQ2pCLzlCLGNBQUsrOUIsTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGO0FBQ0QsU0FBSS85QixLQUFLNjhCLFlBQVQsRUFBdUI7QUFDckIsWUFBSyxJQUFJbjRCLE1BQU0sQ0FBVixFQUFhczVCLE1BQU1oK0IsS0FBSzY4QixZQUFMLENBQWtCdDdDLE1BQTFDLEVBQWtEbWpCLE1BQU1zNUIsR0FBeEQsRUFBNkR0NUIsS0FBN0QsRUFBb0U7QUFDbEUsYUFBSW0zQixRQUFRNzdCLEtBQUs2OEIsWUFBTCxDQUFrQm40QixHQUFsQixFQUF1Qm0zQixLQUFuQztBQUNBZ0Msc0JBQWFoQyxLQUFiO0FBQ0EsYUFBSSxDQUFDQSxNQUFNa0MsTUFBWCxFQUFtQjtBQUNqQi85QixnQkFBSys5QixNQUFMLEdBQWMsS0FBZDtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsVUFBU0QsZUFBVCxDQUEwQjk5QixJQUExQixFQUFnQzRSLE9BQWhDLEVBQXlDO0FBQ3ZDLE9BQUk1UixLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLFNBQUl3RixLQUFLKzlCLE1BQUwsSUFBZS85QixLQUFLN1IsSUFBeEIsRUFBOEI7QUFDNUI2UixZQUFLaStCLFdBQUwsR0FBbUJyc0IsT0FBbkI7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBLFNBQUk1UixLQUFLKzlCLE1BQUwsSUFBZS85QixLQUFLcEIsUUFBTCxDQUFjcmQsTUFBN0IsSUFBdUMsRUFDekN5ZSxLQUFLcEIsUUFBTCxDQUFjcmQsTUFBZCxLQUF5QixDQUF6QixJQUNBeWUsS0FBS3BCLFFBQUwsQ0FBYyxDQUFkLEVBQWlCcEUsSUFBakIsS0FBMEIsQ0FGZSxDQUEzQyxFQUdHO0FBQ0R3RixZQUFLaytCLFVBQUwsR0FBa0IsSUFBbEI7QUFDQTtBQUNELE1BTkQsTUFNTztBQUNMbCtCLFlBQUtrK0IsVUFBTCxHQUFrQixLQUFsQjtBQUNEO0FBQ0QsU0FBSWwrQixLQUFLcEIsUUFBVCxFQUFtQjtBQUNqQixZQUFLLElBQUl0ZCxJQUFJLENBQVIsRUFBVytLLElBQUkyVCxLQUFLcEIsUUFBTCxDQUFjcmQsTUFBbEMsRUFBMENELElBQUkrSyxDQUE5QyxFQUFpRC9LLEdBQWpELEVBQXNEO0FBQ3BEdzhDLHlCQUFnQjk5QixLQUFLcEIsUUFBTCxDQUFjdGQsQ0FBZCxDQUFoQixFQUFrQ3N3QixXQUFXLENBQUMsQ0FBQzVSLEtBQUtzOEIsR0FBcEQ7QUFDRDtBQUNGO0FBQ0QsU0FBSXQ4QixLQUFLNjhCLFlBQVQsRUFBdUI7QUFDckIsWUFBSyxJQUFJbjRCLE1BQU0sQ0FBVixFQUFhczVCLE1BQU1oK0IsS0FBSzY4QixZQUFMLENBQWtCdDdDLE1BQTFDLEVBQWtEbWpCLE1BQU1zNUIsR0FBeEQsRUFBNkR0NUIsS0FBN0QsRUFBb0U7QUFDbEVvNUIseUJBQWdCOTlCLEtBQUs2OEIsWUFBTCxDQUFrQm40QixHQUFsQixFQUF1Qm0zQixLQUF2QyxFQUE4Q2pxQixPQUE5QztBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVN0UyxRQUFULENBQW1CVSxJQUFuQixFQUF5QjtBQUN2QixPQUFJQSxLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQUU7QUFDckIsWUFBTyxLQUFQO0FBQ0Q7QUFDRCxPQUFJd0YsS0FBS3hGLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUFFO0FBQ3JCLFlBQU8sSUFBUDtBQUNEO0FBQ0QsVUFBTyxDQUFDLEVBQUV3RixLQUFLNGIsR0FBTCxJQUNSLENBQUM1YixLQUFLZzlCLFdBQU4sSUFBcUI7QUFDckIsSUFBQ2g5QixLQUFLeTdCLEVBRE4sSUFDWSxDQUFDejdCLEtBQUtzOEIsR0FEbEIsSUFDeUI7QUFDekIsSUFBQzN4QyxhQUFhcVYsS0FBS3JDLEdBQWxCLENBRkQsSUFFMkI7QUFDM0I4L0IseUJBQXNCejlCLEtBQUtyQyxHQUEzQixDQUhBLElBR21DO0FBQ25DLElBQUN3Z0MsMkJBQTJCbitCLElBQTNCLENBSkQsSUFLQTlYLE9BQU9DLElBQVAsQ0FBWTZYLElBQVosRUFBa0JqUyxLQUFsQixDQUF3Qnl2QyxXQUF4QixDQU5NLENBQVI7QUFRRDs7QUFFRCxVQUFTVywwQkFBVCxDQUFxQ24rQixJQUFyQyxFQUEyQztBQUN6QyxVQUFPQSxLQUFLekcsTUFBWixFQUFvQjtBQUNsQnlHLFlBQU9BLEtBQUt6RyxNQUFaO0FBQ0EsU0FBSXlHLEtBQUtyQyxHQUFMLEtBQWEsVUFBakIsRUFBNkI7QUFDM0IsY0FBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFJcUMsS0FBS3M4QixHQUFULEVBQWM7QUFDWixjQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsS0FBSThCLFVBQVUsOENBQWQ7QUFDQSxLQUFJQyxlQUFlLDhGQUFuQjs7QUFFQTtBQUNBLEtBQUlqdkMsV0FBVztBQUNia3ZDLFFBQUssRUFEUTtBQUViMTRDLFFBQUssQ0FGUTtBQUdieW1DLFVBQU8sRUFITTtBQUlia1MsVUFBTyxFQUpNO0FBS2JDLE9BQUksRUFMUztBQU1iaEwsU0FBTSxFQU5PO0FBT2JpTCxVQUFPLEVBUE07QUFRYkMsU0FBTSxFQVJPO0FBU2IsYUFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBVEcsRUFBZjs7QUFZQTtBQUNBO0FBQ0E7QUFDQSxLQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVS9CLFNBQVYsRUFBcUI7QUFBRSxVQUFRLFFBQVFBLFNBQVIsR0FBb0IsZUFBNUI7QUFBK0MsRUFBckY7O0FBRUEsS0FBSWdDLGVBQWU7QUFDakJDLFNBQU0sMkJBRFc7QUFFakI5YixZQUFTLDBCQUZRO0FBR2pCL2dDLFNBQU0yOEMsU0FBUyx3Q0FBVCxDQUhXO0FBSWpCRyxTQUFNSCxTQUFTLGlCQUFULENBSlc7QUFLakJJLFVBQU9KLFNBQVMsa0JBQVQsQ0FMVTtBQU1qQkssUUFBS0wsU0FBUyxnQkFBVCxDQU5ZO0FBT2pCTSxTQUFNTixTQUFTLGlCQUFULENBUFc7QUFRakJuTCxTQUFNbUwsU0FBUywyQ0FBVCxDQVJXO0FBU2pCTyxXQUFRUCxTQUFTLDJDQUFULENBVFM7QUFVakJGLFVBQU9FLFNBQVMsMkNBQVQ7QUFWVSxFQUFuQjs7QUFhQSxVQUFTUSxXQUFULENBQ0VuYyxNQURGLEVBRUVydkIsUUFGRixFQUdFakQsSUFIRixFQUlFO0FBQ0EsT0FBSXRLLE1BQU11TixXQUFXLFlBQVgsR0FBMEIsTUFBcEM7QUFDQSxRQUFLLElBQUk5UixJQUFULElBQWlCbWhDLE1BQWpCLEVBQXlCO0FBQ3ZCLFNBQUlyVyxVQUFVcVcsT0FBT25oQyxJQUFQLENBQWQ7QUFDQTtBQUNBLFNBQUkrTSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFDRmpOLFNBQVMsT0FEUCxJQUVGOHFCLE9BRkUsSUFFU0EsUUFBUTJULFNBRmpCLElBRThCM1QsUUFBUTJULFNBQVIsQ0FBa0JtZSxLQUZwRCxFQUdFO0FBQ0EvdEMsWUFDRSx1RUFDQSx3Q0FGRjtBQUlEO0FBQ0R0SyxZQUFPLE9BQU92RSxJQUFQLEdBQWMsS0FBZCxHQUF1QnU5QyxXQUFXdjlDLElBQVgsRUFBaUI4cUIsT0FBakIsQ0FBdkIsR0FBb0QsR0FBM0Q7QUFDRDtBQUNELFVBQU92bUIsSUFBSWxELEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLElBQW1CLEdBQTFCO0FBQ0Q7O0FBRUQsVUFBU2s4QyxVQUFULENBQ0V2OUMsSUFERixFQUVFOHFCLE9BRkYsRUFHRTtBQUNBLE9BQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1osWUFBTyxjQUFQO0FBQ0Q7O0FBRUQsT0FBSWpnQixNQUFNbUIsT0FBTixDQUFjOGUsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFlBQVEsTUFBT0EsUUFBUXJpQixHQUFSLENBQVksVUFBVXFpQixPQUFWLEVBQW1CO0FBQUUsY0FBT3l5QixXQUFXdjlDLElBQVgsRUFBaUI4cUIsT0FBakIsQ0FBUDtBQUFtQyxNQUFwRSxFQUFzRW5mLElBQXRFLENBQTJFLEdBQTNFLENBQVAsR0FBMEYsR0FBbEc7QUFDRDs7QUFFRCxPQUFJNnhDLGVBQWVoQixhQUFhN3RDLElBQWIsQ0FBa0JtYyxRQUFRMWpCLEtBQTFCLENBQW5CO0FBQ0EsT0FBSXEyQyx1QkFBdUJsQixRQUFRNXRDLElBQVIsQ0FBYW1jLFFBQVExakIsS0FBckIsQ0FBM0I7O0FBRUEsT0FBSSxDQUFDMGpCLFFBQVEyVCxTQUFiLEVBQXdCO0FBQ3RCLFlBQU8rZSxnQkFBZ0JDLG9CQUFoQixHQUNIM3lCLFFBQVExakIsS0FETCxHQUVGLHNCQUF1QjBqQixRQUFRMWpCLEtBQS9CLEdBQXdDLEdBRjdDLENBRHNCLENBRzRCO0FBQ25ELElBSkQsTUFJTztBQUNMLFNBQUk2OEIsT0FBTyxFQUFYO0FBQ0EsU0FBSXlaLGtCQUFrQixFQUF0QjtBQUNBLFNBQUlwM0MsT0FBTyxFQUFYO0FBQ0EsVUFBSyxJQUFJZ0QsR0FBVCxJQUFnQndoQixRQUFRMlQsU0FBeEIsRUFBbUM7QUFDakMsV0FBSXNlLGFBQWF6ekMsR0FBYixDQUFKLEVBQXVCO0FBQ3JCbzBDLDRCQUFtQlgsYUFBYXp6QyxHQUFiLENBQW5CO0FBQ0E7QUFDQSxhQUFJaUUsU0FBU2pFLEdBQVQsQ0FBSixFQUFtQjtBQUNqQmhELGdCQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNEO0FBQ0YsUUFORCxNQU1PO0FBQ0xoRCxjQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNEO0FBQ0Y7QUFDRCxTQUFJaEQsS0FBSzVHLE1BQVQsRUFBaUI7QUFDZnVrQyxlQUFRMFosYUFBYXIzQyxJQUFiLENBQVI7QUFDRDtBQUNEO0FBQ0EsU0FBSW8zQyxlQUFKLEVBQXFCO0FBQ25CelosZUFBUXlaLGVBQVI7QUFDRDtBQUNELFNBQUlFLGNBQWNKLGVBQ2QxeUIsUUFBUTFqQixLQUFSLEdBQWdCLFVBREYsR0FFZHEyQyx1QkFDRyxNQUFPM3lCLFFBQVExakIsS0FBZixHQUF3QixXQUQzQixHQUVFMGpCLFFBQVExakIsS0FKZDtBQUtBLFlBQVEsc0JBQXNCNjhCLElBQXRCLEdBQTZCMlosV0FBN0IsR0FBMkMsR0FBbkQ7QUFDRDtBQUNGOztBQUVELFVBQVNELFlBQVQsQ0FBdUJyM0MsSUFBdkIsRUFBNkI7QUFDM0IsVUFBUSwrQkFBZ0NBLEtBQUttQyxHQUFMLENBQVNvMUMsYUFBVCxFQUF3Qmx5QyxJQUF4QixDQUE2QixJQUE3QixDQUFoQyxHQUFzRSxlQUE5RTtBQUNEOztBQUVELFVBQVNreUMsYUFBVCxDQUF3QnYwQyxHQUF4QixFQUE2QjtBQUMzQixPQUFJdzBDLFNBQVNDLFNBQVN6MEMsR0FBVCxFQUFjLEVBQWQsQ0FBYjtBQUNBLE9BQUl3MEMsTUFBSixFQUFZO0FBQ1YsWUFBUSxzQkFBc0JBLE1BQTlCO0FBQ0Q7QUFDRCxPQUFJcEQsUUFBUW50QyxTQUFTakUsR0FBVCxDQUFaO0FBQ0EsVUFBUSx1QkFBd0JyQixLQUFLQyxTQUFMLENBQWVvQixHQUFmLENBQXhCLElBQWdEb3hDLFFBQVEsTUFBTXp5QyxLQUFLQyxTQUFMLENBQWV3eUMsS0FBZixDQUFkLEdBQXNDLEVBQXRGLElBQTRGLEdBQXBHO0FBQ0Q7O0FBRUQ7O0FBRUEsVUFBU3Y3QixFQUFULENBQWEzSCxFQUFiLEVBQWlCNG1CLEdBQWpCLEVBQXNCO0FBQ3BCLE9BQUlyeEIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDbXhCLElBQUlLLFNBQWpELEVBQTREO0FBQzFENXZCLFVBQUssbURBQUw7QUFDRDtBQUNEMkksTUFBR3dtQyxhQUFILEdBQW1CLFVBQVUvWixJQUFWLEVBQWdCO0FBQUUsWUFBUSxRQUFRQSxJQUFSLEdBQWUsR0FBZixHQUFzQjdGLElBQUloM0IsS0FBMUIsR0FBbUMsR0FBM0M7QUFBa0QsSUFBdkY7QUFDRDs7QUFFRDs7QUFFQSxVQUFTNjJDLE1BQVQsQ0FBaUJ6bUMsRUFBakIsRUFBcUI0bUIsR0FBckIsRUFBMEI7QUFDeEI1bUIsTUFBRzBtQyxRQUFILEdBQWMsVUFBVWphLElBQVYsRUFBZ0I7QUFDNUIsWUFBUSxRQUFRQSxJQUFSLEdBQWUsSUFBZixHQUF1QnpzQixHQUFHc0UsR0FBMUIsR0FBaUMsSUFBakMsR0FBeUNzaUIsSUFBSWgzQixLQUE3QyxHQUFzRCxHQUF0RCxJQUE2RGczQixJQUFJSyxTQUFKLElBQWlCTCxJQUFJSyxTQUFKLENBQWNsa0IsSUFBL0IsR0FBc0MsTUFBdEMsR0FBK0MsT0FBNUcsS0FBd0g2akIsSUFBSUssU0FBSixJQUFpQkwsSUFBSUssU0FBSixDQUFjbmQsSUFBL0IsR0FBc0MsT0FBdEMsR0FBZ0QsRUFBeEssSUFBOEssR0FBdEw7QUFDRCxJQUZEO0FBR0Q7O0FBRUQ7O0FBRUEsS0FBSTY4QixpQkFBaUI7QUFDbkJoL0IsT0FBSUEsRUFEZTtBQUVuQnZnQixTQUFNcS9DLE1BRmE7QUFHbkJHLFVBQU8vL0M7QUFIWSxFQUFyQjs7QUFNQTs7QUFFQSxLQUFJZ2dELGVBQWUsU0FBU0EsWUFBVCxDQUF1Qjd1QyxPQUF2QixFQUFnQztBQUNqRCxRQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxRQUFLWCxJQUFMLEdBQVlXLFFBQVFYLElBQVIsSUFBZ0I2eEIsUUFBNUI7QUFDQSxRQUFLbVgsVUFBTCxHQUFrQmxYLG9CQUFvQm54QixRQUFRbEUsT0FBNUIsRUFBcUMsZUFBckMsQ0FBbEI7QUFDQSxRQUFLZ3pDLFVBQUwsR0FBa0IzZCxvQkFBb0JueEIsUUFBUWxFLE9BQTVCLEVBQXFDLFNBQXJDLENBQWxCO0FBQ0EsUUFBS21PLFVBQUwsR0FBa0IzTyxPQUFPQSxPQUFPLEVBQVAsRUFBV3F6QyxjQUFYLENBQVAsRUFBbUMzdUMsUUFBUWlLLFVBQTNDLENBQWxCO0FBQ0EsT0FBSWpNLGdCQUFnQmdDLFFBQVFoQyxhQUFSLElBQXlCckMsRUFBN0M7QUFDQSxRQUFLb3pDLGNBQUwsR0FBc0IsVUFBVS9tQyxFQUFWLEVBQWM7QUFBRSxZQUFPLENBQUNoSyxjQUFjZ0ssR0FBR3NFLEdBQWpCLENBQVI7QUFBZ0MsSUFBdEU7QUFDQSxRQUFLMGlDLE1BQUwsR0FBYyxDQUFkO0FBQ0EsUUFBS3h3QixlQUFMLEdBQXVCLEVBQXZCO0FBQ0QsRUFWRDs7QUFjQSxVQUFTeXdCLFFBQVQsQ0FDRUMsR0FERixFQUVFbHZDLE9BRkYsRUFHRTtBQUNBLE9BQUltdkMsUUFBUSxJQUFJTixZQUFKLENBQWlCN3VDLE9BQWpCLENBQVo7QUFDQSxPQUFJeTBCLE9BQU95YSxNQUFNRSxXQUFXRixHQUFYLEVBQWdCQyxLQUFoQixDQUFOLEdBQStCLFdBQTFDO0FBQ0EsVUFBTztBQUNMaGlDLGFBQVMsdUJBQXVCc25CLElBQXZCLEdBQThCLEdBRGxDO0FBRUxqVyxzQkFBaUIyd0IsTUFBTTN3QjtBQUZsQixJQUFQO0FBSUQ7O0FBRUQsVUFBUzR3QixVQUFULENBQXFCcG5DLEVBQXJCLEVBQXlCbW5DLEtBQXpCLEVBQWdDO0FBQzlCLE9BQUlubkMsR0FBRzZrQyxVQUFILElBQWlCLENBQUM3a0MsR0FBR3FuQyxlQUF6QixFQUEwQztBQUN4QyxZQUFPQyxVQUFVdG5DLEVBQVYsRUFBY21uQyxLQUFkLENBQVA7QUFDRCxJQUZELE1BRU8sSUFBSW5uQyxHQUFHbEwsSUFBSCxJQUFXLENBQUNrTCxHQUFHdW5DLGFBQW5CLEVBQWtDO0FBQ3ZDLFlBQU9DLFFBQVF4bkMsRUFBUixFQUFZbW5DLEtBQVosQ0FBUDtBQUNELElBRk0sTUFFQSxJQUFJbm5DLEdBQUdpakMsR0FBSCxJQUFVLENBQUNqakMsR0FBR3luQyxZQUFsQixFQUFnQztBQUNyQyxZQUFPQyxPQUFPMW5DLEVBQVAsRUFBV21uQyxLQUFYLENBQVA7QUFDRCxJQUZNLE1BRUEsSUFBSW5uQyxHQUFHb2lDLEVBQUgsSUFBUyxDQUFDcGlDLEdBQUcybkMsV0FBakIsRUFBOEI7QUFDbkMsWUFBT0MsTUFBTTVuQyxFQUFOLEVBQVVtbkMsS0FBVixDQUFQO0FBQ0QsSUFGTSxNQUVBLElBQUlubkMsR0FBR3NFLEdBQUgsS0FBVyxVQUFYLElBQXlCLENBQUN0RSxHQUFHMmlDLFVBQWpDLEVBQTZDO0FBQ2xELFlBQU9rRixZQUFZN25DLEVBQVosRUFBZ0JtbkMsS0FBaEIsS0FBMEIsUUFBakM7QUFDRCxJQUZNLE1BRUEsSUFBSW5uQyxHQUFHc0UsR0FBSCxLQUFXLE1BQWYsRUFBdUI7QUFDNUIsWUFBT3dqQyxRQUFROW5DLEVBQVIsRUFBWW1uQyxLQUFaLENBQVA7QUFDRCxJQUZNLE1BRUE7QUFDTDtBQUNBLFNBQUkxYSxJQUFKO0FBQ0EsU0FBSXpzQixHQUFHa0ssU0FBUCxFQUFrQjtBQUNoQnVpQixjQUFPc2IsYUFBYS9uQyxHQUFHa0ssU0FBaEIsRUFBMkJsSyxFQUEzQixFQUErQm1uQyxLQUEvQixDQUFQO0FBQ0QsTUFGRCxNQUVPO0FBQ0wsV0FBSTM1QyxPQUFPd1MsR0FBRzhoQyxLQUFILEdBQVdqNkMsU0FBWCxHQUF1Qm1nRCxVQUFVaG9DLEVBQVYsRUFBY21uQyxLQUFkLENBQWxDOztBQUVBLFdBQUk1aEMsV0FBV3ZGLEdBQUd1VyxjQUFILEdBQW9CLElBQXBCLEdBQTJCc3hCLFlBQVk3bkMsRUFBWixFQUFnQm1uQyxLQUFoQixFQUF1QixJQUF2QixDQUExQztBQUNBMWEsY0FBTyxTQUFVenNCLEdBQUdzRSxHQUFiLEdBQW9CLEdBQXBCLElBQTJCOVcsT0FBUSxNQUFNQSxJQUFkLEdBQXNCLEVBQWpELEtBQXdEK1gsV0FBWSxNQUFNQSxRQUFsQixHQUE4QixFQUF0RixJQUE0RixHQUFuRztBQUNEO0FBQ0Q7QUFDQSxVQUFLLElBQUl0ZCxJQUFJLENBQWIsRUFBZ0JBLElBQUlrL0MsTUFBTTlHLFVBQU4sQ0FBaUJuNEMsTUFBckMsRUFBNkNELEdBQTdDLEVBQWtEO0FBQ2hEd2tDLGNBQU8wYSxNQUFNOUcsVUFBTixDQUFpQnA0QyxDQUFqQixFQUFvQitYLEVBQXBCLEVBQXdCeXNCLElBQXhCLENBQVA7QUFDRDtBQUNELFlBQU9BLElBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0EsVUFBUzZhLFNBQVQsQ0FBb0J0bkMsRUFBcEIsRUFBd0JtbkMsS0FBeEIsRUFBK0I7QUFDN0JubkMsTUFBR3FuQyxlQUFILEdBQXFCLElBQXJCO0FBQ0FGLFNBQU0zd0IsZUFBTixDQUFzQjNkLElBQXRCLENBQTRCLHVCQUF3QnV1QyxXQUFXcG5DLEVBQVgsRUFBZW1uQyxLQUFmLENBQXhCLEdBQWlELEdBQTdFO0FBQ0EsVUFBUSxTQUFTQSxNQUFNM3dCLGVBQU4sQ0FBc0J0dUIsTUFBdEIsR0FBK0IsQ0FBeEMsS0FBOEM4WCxHQUFHNGtDLFdBQUgsR0FBaUIsT0FBakIsR0FBMkIsRUFBekUsSUFBK0UsR0FBdkY7QUFDRDs7QUFFRDtBQUNBLFVBQVM0QyxPQUFULENBQWtCeG5DLEVBQWxCLEVBQXNCbW5DLEtBQXRCLEVBQTZCO0FBQzNCbm5DLE1BQUd1bkMsYUFBSCxHQUFtQixJQUFuQjtBQUNBLE9BQUl2bkMsR0FBR29pQyxFQUFILElBQVMsQ0FBQ3BpQyxHQUFHMm5DLFdBQWpCLEVBQThCO0FBQzVCLFlBQU9DLE1BQU01bkMsRUFBTixFQUFVbW5DLEtBQVYsQ0FBUDtBQUNELElBRkQsTUFFTyxJQUFJbm5DLEdBQUc0a0MsV0FBUCxFQUFvQjtBQUN6QixTQUFJOXlDLE1BQU0sRUFBVjtBQUNBLFNBQUlvTyxTQUFTRixHQUFHRSxNQUFoQjtBQUNBLFlBQU9BLE1BQVAsRUFBZTtBQUNiLFdBQUlBLE9BQU8raUMsR0FBWCxFQUFnQjtBQUNkbnhDLGVBQU1vTyxPQUFPcE8sR0FBYjtBQUNBO0FBQ0Q7QUFDRG9PLGdCQUFTQSxPQUFPQSxNQUFoQjtBQUNEO0FBQ0QsU0FBSSxDQUFDcE8sR0FBTCxFQUFVO0FBQ1J5RCxlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMweEMsTUFBTTl2QyxJQUFOLENBQ3ZDLHNEQUR1QyxDQUF6QztBQUdBLGNBQU8rdkMsV0FBV3BuQyxFQUFYLEVBQWVtbkMsS0FBZixDQUFQO0FBQ0Q7QUFDRCxZQUFRLFFBQVNDLFdBQVdwbkMsRUFBWCxFQUFlbW5DLEtBQWYsQ0FBVCxHQUFrQyxHQUFsQyxHQUF5Q0EsTUFBTUgsTUFBTixFQUF6QyxJQUE0RGwxQyxNQUFPLE1BQU1BLEdBQWIsR0FBb0IsRUFBaEYsSUFBc0YsR0FBOUY7QUFDRCxJQWpCTSxNQWlCQTtBQUNMLFlBQU93MUMsVUFBVXRuQyxFQUFWLEVBQWNtbkMsS0FBZCxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTUyxLQUFULENBQ0U1bkMsRUFERixFQUVFbW5DLEtBRkYsRUFHRWMsTUFIRixFQUlFQyxRQUpGLEVBS0U7QUFDQWxvQyxNQUFHMm5DLFdBQUgsR0FBaUIsSUFBakIsQ0FEQSxDQUN1QjtBQUN2QixVQUFPUSxnQkFBZ0Jub0MsR0FBR3dqQyxZQUFILENBQWdCMzVDLEtBQWhCLEVBQWhCLEVBQXlDczlDLEtBQXpDLEVBQWdEYyxNQUFoRCxFQUF3REMsUUFBeEQsQ0FBUDtBQUNEOztBQUVELFVBQVNDLGVBQVQsQ0FDRUMsVUFERixFQUVFakIsS0FGRixFQUdFYyxNQUhGLEVBSUVDLFFBSkYsRUFLRTtBQUNBLE9BQUksQ0FBQ0UsV0FBV2xnRCxNQUFoQixFQUF3QjtBQUN0QixZQUFPZ2dELFlBQVksTUFBbkI7QUFDRDs7QUFFRCxPQUFJM0UsWUFBWTZFLFdBQVcxQyxLQUFYLEVBQWhCO0FBQ0EsT0FBSW5DLFVBQVVuYixHQUFkLEVBQW1CO0FBQ2pCLFlBQVEsTUFBT21iLFVBQVVuYixHQUFqQixHQUF3QixJQUF4QixHQUFnQ2lnQixjQUFjOUUsVUFBVWYsS0FBeEIsQ0FBaEMsR0FBa0UsR0FBbEUsR0FBeUUyRixnQkFBZ0JDLFVBQWhCLEVBQTRCakIsS0FBNUIsRUFBbUNjLE1BQW5DLEVBQTJDQyxRQUEzQyxDQUFqRjtBQUNELElBRkQsTUFFTztBQUNMLFlBQVEsS0FBTUcsY0FBYzlFLFVBQVVmLEtBQXhCLENBQWQ7QUFDRDs7QUFFRDtBQUNBLFlBQVM2RixhQUFULENBQXdCcm9DLEVBQXhCLEVBQTRCO0FBQzFCLFlBQU9pb0MsU0FDSEEsT0FBT2pvQyxFQUFQLEVBQVdtbkMsS0FBWCxDQURHLEdBRUhubkMsR0FBR2xMLElBQUgsR0FDRTB5QyxRQUFReG5DLEVBQVIsRUFBWW1uQyxLQUFaLENBREYsR0FFRUMsV0FBV3BuQyxFQUFYLEVBQWVtbkMsS0FBZixDQUpOO0FBS0Q7QUFDRjs7QUFFRCxVQUFTTyxNQUFULENBQ0UxbkMsRUFERixFQUVFbW5DLEtBRkYsRUFHRWMsTUFIRixFQUlFSyxTQUpGLEVBS0U7QUFDQSxPQUFJbGdCLE1BQU1wb0IsR0FBR2lqQyxHQUFiO0FBQ0EsT0FBSUMsUUFBUWxqQyxHQUFHa2pDLEtBQWY7QUFDQSxPQUFJRSxZQUFZcGpDLEdBQUdvakMsU0FBSCxHQUFnQixNQUFPcGpDLEdBQUdvakMsU0FBMUIsR0FBd0MsRUFBeEQ7QUFDQSxPQUFJQyxZQUFZcmpDLEdBQUdxakMsU0FBSCxHQUFnQixNQUFPcmpDLEdBQUdxakMsU0FBMUIsR0FBd0MsRUFBeEQ7O0FBRUEsT0FBSTl0QyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFDRjB4QyxNQUFNSixjQUFOLENBQXFCL21DLEVBQXJCLENBREUsSUFFRkEsR0FBR3NFLEdBQUgsS0FBVyxNQUZULElBR0Z0RSxHQUFHc0UsR0FBSCxLQUFXLFVBSFQsSUFJRixDQUFDdEUsR0FBR2xPLEdBSk4sRUFLRTtBQUNBcTFDLFdBQU05dkMsSUFBTixDQUNFLE1BQU8ySSxHQUFHc0UsR0FBVixHQUFpQixXQUFqQixHQUErQjQrQixLQUEvQixHQUF1QyxNQUF2QyxHQUFnRDlhLEdBQWhELEdBQXNELHFDQUF0RCxHQUNBLG1DQURBLEdBRUEsMERBSEYsRUFJRSxJQUpGLENBSU87QUFKUDtBQU1EOztBQUVEcG9CLE1BQUd5bkMsWUFBSCxHQUFrQixJQUFsQixDQXBCQSxDQW9Cd0I7QUFDeEIsVUFBTyxDQUFDYSxhQUFhLElBQWQsSUFBc0IsSUFBdEIsR0FBNkJsZ0IsR0FBN0IsR0FBbUMsSUFBbkMsR0FDTCxXQURLLEdBQ1M4YSxLQURULEdBQ2lCRSxTQURqQixHQUM2QkMsU0FEN0IsR0FDeUMsSUFEekMsR0FFSCxTQUZHLEdBRVUsQ0FBQzRFLFVBQVViLFVBQVgsRUFBdUJwbkMsRUFBdkIsRUFBMkJtbkMsS0FBM0IsQ0FGVixHQUdMLElBSEY7QUFJRDs7QUFFRCxVQUFTYSxTQUFULENBQW9CaG9DLEVBQXBCLEVBQXdCbW5DLEtBQXhCLEVBQStCO0FBQzdCLE9BQUkzNUMsT0FBTyxHQUFYOztBQUVBO0FBQ0E7QUFDQSxPQUFJd1UsT0FBT3VtQyxjQUFjdm9DLEVBQWQsRUFBa0JtbkMsS0FBbEIsQ0FBWDtBQUNBLE9BQUlubEMsSUFBSixFQUFVO0FBQUV4VSxhQUFRd1UsT0FBTyxHQUFmO0FBQXFCOztBQUVqQztBQUNBLE9BQUloQyxHQUFHbE8sR0FBUCxFQUFZO0FBQ1Z0RSxhQUFRLFNBQVV3UyxHQUFHbE8sR0FBYixHQUFvQixHQUE1QjtBQUNEO0FBQ0Q7QUFDQSxPQUFJa08sR0FBR3FaLEdBQVAsRUFBWTtBQUNWN3JCLGFBQVEsU0FBVXdTLEdBQUdxWixHQUFiLEdBQW9CLEdBQTVCO0FBQ0Q7QUFDRCxPQUFJclosR0FBR21oQixRQUFQLEVBQWlCO0FBQ2YzekIsYUFBUSxnQkFBUjtBQUNEO0FBQ0Q7QUFDQSxPQUFJd1MsR0FBR3VpQixHQUFQLEVBQVk7QUFDVi8wQixhQUFRLFdBQVI7QUFDRDtBQUNEO0FBQ0EsT0FBSXdTLEdBQUdrSyxTQUFQLEVBQWtCO0FBQ2hCMWMsYUFBUSxXQUFZd1MsR0FBR3NFLEdBQWYsR0FBc0IsS0FBOUI7QUFDRDtBQUNEO0FBQ0EsUUFBSyxJQUFJcmMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJay9DLE1BQU1MLFVBQU4sQ0FBaUI1K0MsTUFBckMsRUFBNkNELEdBQTdDLEVBQWtEO0FBQ2hEdUYsYUFBUTI1QyxNQUFNTCxVQUFOLENBQWlCNytDLENBQWpCLEVBQW9CK1gsRUFBcEIsQ0FBUjtBQUNEO0FBQ0Q7QUFDQSxPQUFJQSxHQUFHc0ksS0FBUCxFQUFjO0FBQ1o5YSxhQUFRLFlBQWFnN0MsU0FBU3hvQyxHQUFHc0ksS0FBWixDQUFiLEdBQW1DLElBQTNDO0FBQ0Q7QUFDRDtBQUNBLE9BQUl0SSxHQUFHb0IsS0FBUCxFQUFjO0FBQ1o1VCxhQUFRLGVBQWdCZzdDLFNBQVN4b0MsR0FBR29CLEtBQVosQ0FBaEIsR0FBc0MsSUFBOUM7QUFDRDtBQUNEO0FBQ0EsT0FBSXBCLEdBQUcycEIsTUFBUCxFQUFlO0FBQ2JuOEIsYUFBU3M0QyxZQUFZOWxDLEdBQUcycEIsTUFBZixFQUF1QixLQUF2QixFQUE4QndkLE1BQU05dkMsSUFBcEMsQ0FBRCxHQUE4QyxHQUF0RDtBQUNEO0FBQ0QsT0FBSTJJLEdBQUc2cEIsWUFBUCxFQUFxQjtBQUNuQnI4QixhQUFTczRDLFlBQVk5bEMsR0FBRzZwQixZQUFmLEVBQTZCLElBQTdCLEVBQW1Dc2QsTUFBTTl2QyxJQUF6QyxDQUFELEdBQW1ELEdBQTNEO0FBQ0Q7QUFDRDtBQUNBLE9BQUkySSxHQUFHMmlDLFVBQVAsRUFBbUI7QUFDakJuMUMsYUFBUSxVQUFXd1MsR0FBRzJpQyxVQUFkLEdBQTRCLEdBQXBDO0FBQ0Q7QUFDRDtBQUNBLE9BQUkzaUMsR0FBR3lPLFdBQVAsRUFBb0I7QUFDbEJqaEIsYUFBU2k3QyxlQUFlem9DLEdBQUd5TyxXQUFsQixFQUErQjA0QixLQUEvQixDQUFELEdBQTBDLEdBQWxEO0FBQ0Q7QUFDRDtBQUNBLE9BQUlubkMsR0FBR2dXLEtBQVAsRUFBYztBQUNaeG9CLGFBQVEsa0JBQW1Cd1MsR0FBR2dXLEtBQUgsQ0FBU3BtQixLQUE1QixHQUFxQyxZQUFyQyxHQUFxRG9RLEdBQUdnVyxLQUFILENBQVNjLFFBQTlELEdBQTBFLGNBQTFFLEdBQTRGOVcsR0FBR2dXLEtBQUgsQ0FBUzlGLFVBQXJHLEdBQW1ILElBQTNIO0FBQ0Q7QUFDRDtBQUNBLE9BQUlsUSxHQUFHdVcsY0FBUCxFQUF1QjtBQUNyQixTQUFJQSxpQkFBaUJteUIsa0JBQWtCMW9DLEVBQWxCLEVBQXNCbW5DLEtBQXRCLENBQXJCO0FBQ0EsU0FBSTV3QixjQUFKLEVBQW9CO0FBQ2xCL29CLGVBQVErb0IsaUJBQWlCLEdBQXpCO0FBQ0Q7QUFDRjtBQUNEL29CLFVBQU9BLEtBQUs4RSxPQUFMLENBQWEsSUFBYixFQUFtQixFQUFuQixJQUF5QixHQUFoQztBQUNBO0FBQ0EsT0FBSTBOLEdBQUcwbUMsUUFBUCxFQUFpQjtBQUNmbDVDLFlBQU93UyxHQUFHMG1DLFFBQUgsQ0FBWWw1QyxJQUFaLENBQVA7QUFDRDtBQUNEO0FBQ0EsT0FBSXdTLEdBQUd3bUMsYUFBUCxFQUFzQjtBQUNwQmg1QyxZQUFPd1MsR0FBR3dtQyxhQUFILENBQWlCaDVDLElBQWpCLENBQVA7QUFDRDtBQUNELFVBQU9BLElBQVA7QUFDRDs7QUFFRCxVQUFTKzZDLGFBQVQsQ0FBd0J2b0MsRUFBeEIsRUFBNEJtbkMsS0FBNUIsRUFBbUM7QUFDakMsT0FBSW5sQyxPQUFPaEMsR0FBR2lDLFVBQWQ7QUFDQSxPQUFJLENBQUNELElBQUwsRUFBVztBQUFFO0FBQVE7QUFDckIsT0FBSWpWLE1BQU0sY0FBVjtBQUNBLE9BQUk0N0MsYUFBYSxLQUFqQjtBQUNBLE9BQUkxZ0QsQ0FBSixFQUFPK0ssQ0FBUCxFQUFVNHpCLEdBQVYsRUFBZWdpQixXQUFmO0FBQ0EsUUFBSzNnRCxJQUFJLENBQUosRUFBTytLLElBQUlnUCxLQUFLOVosTUFBckIsRUFBNkJELElBQUkrSyxDQUFqQyxFQUFvQy9LLEdBQXBDLEVBQXlDO0FBQ3ZDMitCLFdBQU01a0IsS0FBSy9aLENBQUwsQ0FBTjtBQUNBMmdELG1CQUFjLElBQWQ7QUFDQSxTQUFJQyxNQUFNMUIsTUFBTWxsQyxVQUFOLENBQWlCMmtCLElBQUlwK0IsSUFBckIsQ0FBVjtBQUNBLFNBQUlxZ0QsR0FBSixFQUFTO0FBQ1A7QUFDQTtBQUNBRCxxQkFBYyxDQUFDLENBQUNDLElBQUk3b0MsRUFBSixFQUFRNG1CLEdBQVIsRUFBYXVnQixNQUFNOXZDLElBQW5CLENBQWhCO0FBQ0Q7QUFDRCxTQUFJdXhDLFdBQUosRUFBaUI7QUFDZkQsb0JBQWEsSUFBYjtBQUNBNTdDLGNBQU8sYUFBYzY1QixJQUFJcCtCLElBQWxCLEdBQTBCLGVBQTFCLEdBQTZDbytCLElBQUlPLE9BQWpELEdBQTRELElBQTVELElBQW9FUCxJQUFJaDNCLEtBQUosR0FBYSxhQUFjZzNCLElBQUloM0IsS0FBbEIsR0FBMkIsZUFBM0IsR0FBOENhLEtBQUtDLFNBQUwsQ0FBZWsyQixJQUFJaDNCLEtBQW5CLENBQTNELEdBQXlGLEVBQTdKLEtBQW9LZzNCLElBQUkyQyxHQUFKLEdBQVcsWUFBYTNDLElBQUkyQyxHQUFqQixHQUF3QixJQUFuQyxHQUEyQyxFQUEvTSxLQUFzTjNDLElBQUlLLFNBQUosR0FBaUIsZ0JBQWlCeDJCLEtBQUtDLFNBQUwsQ0FBZWsyQixJQUFJSyxTQUFuQixDQUFsQyxHQUFvRSxFQUExUixJQUFnUyxJQUF2UztBQUNEO0FBQ0Y7QUFDRCxPQUFJMGhCLFVBQUosRUFBZ0I7QUFDZCxZQUFPNTdDLElBQUlsRCxLQUFKLENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxJQUFtQixHQUExQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzYrQyxpQkFBVCxDQUE0QjFvQyxFQUE1QixFQUFnQ21uQyxLQUFoQyxFQUF1QztBQUNyQyxPQUFJRCxNQUFNbG5DLEdBQUd1RixRQUFILENBQVksQ0FBWixDQUFWO0FBQ0EsT0FBSWhRLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixLQUNGdUssR0FBR3VGLFFBQUgsQ0FBWXJkLE1BQVosR0FBcUIsQ0FBckIsSUFBMEJnL0MsSUFBSS9sQyxJQUFKLEtBQWEsQ0FEckMsQ0FBSixFQUVHO0FBQ0RnbUMsV0FBTTl2QyxJQUFOLENBQVcsaUVBQVg7QUFDRDtBQUNELE9BQUk2dkMsSUFBSS9sQyxJQUFKLEtBQWEsQ0FBakIsRUFBb0I7QUFDbEIsU0FBSTJuQyxrQkFBa0I3QixTQUFTQyxHQUFULEVBQWNDLE1BQU1udkMsT0FBcEIsQ0FBdEI7QUFDQSxZQUFRLHVDQUF3Qzh3QyxnQkFBZ0IzakMsTUFBeEQsR0FBa0UscUJBQWxFLEdBQTJGMmpDLGdCQUFnQnR5QixlQUFoQixDQUFnQ3ZsQixHQUFoQyxDQUFvQyxVQUFVdzdCLElBQVYsRUFBZ0I7QUFBRSxjQUFRLGdCQUFnQkEsSUFBaEIsR0FBdUIsR0FBL0I7QUFBc0MsTUFBNUYsRUFBOEZ0NEIsSUFBOUYsQ0FBbUcsR0FBbkcsQ0FBM0YsR0FBc00sSUFBOU07QUFDRDtBQUNGOztBQUVELFVBQVNzMEMsY0FBVCxDQUNFLzhCLEtBREYsRUFFRXk3QixLQUZGLEVBR0U7QUFDQSxVQUFRLHFCQUFzQnQ0QyxPQUFPQyxJQUFQLENBQVk0YyxLQUFaLEVBQW1CemEsR0FBbkIsQ0FBdUIsVUFBVWEsR0FBVixFQUFlO0FBQ2hFLFlBQU9pM0MsY0FBY2ozQyxHQUFkLEVBQW1CNFosTUFBTTVaLEdBQU4sQ0FBbkIsRUFBK0JxMUMsS0FBL0IsQ0FBUDtBQUNELElBRjJCLEVBRXpCaHpDLElBRnlCLENBRXBCLEdBRm9CLENBQXRCLEdBRVUsSUFGbEI7QUFHRDs7QUFFRCxVQUFTNDBDLGFBQVQsQ0FDRWozQyxHQURGLEVBRUVrTyxFQUZGLEVBR0VtbkMsS0FIRixFQUlFO0FBQ0EsT0FBSW5uQyxHQUFHaWpDLEdBQUgsSUFBVSxDQUFDampDLEdBQUd5bkMsWUFBbEIsRUFBZ0M7QUFDOUIsWUFBT3VCLGlCQUFpQmwzQyxHQUFqQixFQUFzQmtPLEVBQXRCLEVBQTBCbW5DLEtBQTFCLENBQVA7QUFDRDtBQUNELFVBQU8sVUFBVXIxQyxHQUFWLEdBQWdCLGVBQWhCLEdBQW1DbkIsT0FBT3FQLEdBQUdvcUIsUUFBSCxDQUFZNmUsS0FBbkIsQ0FBbkMsR0FBZ0UsSUFBaEUsR0FDTCxTQURLLElBQ1FqcEMsR0FBR3NFLEdBQUgsS0FBVyxVQUFYLEdBQ1R1akMsWUFBWTduQyxFQUFaLEVBQWdCbW5DLEtBQWhCLEtBQTBCLFFBRGpCLEdBRVRDLFdBQVdwbkMsRUFBWCxFQUFlbW5DLEtBQWYsQ0FIQyxJQUd3QixJQUgvQjtBQUlEOztBQUVELFVBQVM2QixnQkFBVCxDQUNFbDNDLEdBREYsRUFFRWtPLEVBRkYsRUFHRW1uQyxLQUhGLEVBSUU7QUFDQSxPQUFJL2UsTUFBTXBvQixHQUFHaWpDLEdBQWI7QUFDQSxPQUFJQyxRQUFRbGpDLEdBQUdrakMsS0FBZjtBQUNBLE9BQUlFLFlBQVlwakMsR0FBR29qQyxTQUFILEdBQWdCLE1BQU9wakMsR0FBR29qQyxTQUExQixHQUF3QyxFQUF4RDtBQUNBLE9BQUlDLFlBQVlyakMsR0FBR3FqQyxTQUFILEdBQWdCLE1BQU9yakMsR0FBR3FqQyxTQUExQixHQUF3QyxFQUF4RDtBQUNBcmpDLE1BQUd5bkMsWUFBSCxHQUFrQixJQUFsQixDQUxBLENBS3dCO0FBQ3hCLFVBQU8sU0FBU3JmLEdBQVQsR0FBZSxJQUFmLEdBQ0wsV0FESyxHQUNTOGEsS0FEVCxHQUNpQkUsU0FEakIsR0FDNkJDLFNBRDdCLEdBQ3lDLElBRHpDLEdBRUgsU0FGRyxHQUVVMEYsY0FBY2ozQyxHQUFkLEVBQW1Ca08sRUFBbkIsRUFBdUJtbkMsS0FBdkIsQ0FGVixHQUdMLElBSEY7QUFJRDs7QUFFRCxVQUFTVSxXQUFULENBQ0U3bkMsRUFERixFQUVFbW5DLEtBRkYsRUFHRStCLFNBSEYsRUFJRUMsYUFKRixFQUtFQyxVQUxGLEVBTUU7QUFDQSxPQUFJN2pDLFdBQVd2RixHQUFHdUYsUUFBbEI7QUFDQSxPQUFJQSxTQUFTcmQsTUFBYixFQUFxQjtBQUNuQixTQUFJbWhELE9BQU85akMsU0FBUyxDQUFULENBQVg7QUFDQTtBQUNBLFNBQUlBLFNBQVNyZCxNQUFULEtBQW9CLENBQXBCLElBQ0ZtaEQsS0FBS3BHLEdBREgsSUFFRm9HLEtBQUsva0MsR0FBTCxLQUFhLFVBRlgsSUFHRitrQyxLQUFLL2tDLEdBQUwsS0FBYSxNQUhmLEVBSUU7QUFDQSxjQUFPLENBQUM2a0MsaUJBQWlCL0IsVUFBbEIsRUFBOEJpQyxJQUE5QixFQUFvQ2xDLEtBQXBDLENBQVA7QUFDRDtBQUNELFNBQUlsd0Isb0JBQW9CaXlCLFlBQ3BCSSxxQkFBcUIvakMsUUFBckIsRUFBK0I0aEMsTUFBTUosY0FBckMsQ0FEb0IsR0FFcEIsQ0FGSjtBQUdBLFNBQUk4QixNQUFNTyxjQUFjRyxPQUF4QjtBQUNBLFlBQVEsTUFBT2hrQyxTQUFTdFUsR0FBVCxDQUFhLFVBQVV1QixDQUFWLEVBQWE7QUFBRSxjQUFPcTJDLElBQUlyMkMsQ0FBSixFQUFPMjBDLEtBQVAsQ0FBUDtBQUF1QixNQUFuRCxFQUFxRGh6QyxJQUFyRCxDQUEwRCxHQUExRCxDQUFQLEdBQXlFLEdBQXpFLElBQWdGOGlCLG9CQUFxQixNQUFNQSxpQkFBM0IsR0FBZ0QsRUFBaEksQ0FBUjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTcXlCLG9CQUFULENBQ0UvakMsUUFERixFQUVFd2hDLGNBRkYsRUFHRTtBQUNBLE9BQUloNkMsTUFBTSxDQUFWO0FBQ0EsUUFBSyxJQUFJOUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc2QsU0FBU3JkLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4QyxTQUFJK1gsS0FBS3VGLFNBQVN0ZCxDQUFULENBQVQ7QUFDQSxTQUFJK1gsR0FBR21CLElBQUgsS0FBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNEO0FBQ0QsU0FBSXFvQyxtQkFBbUJ4cEMsRUFBbkIsS0FDQ0EsR0FBR3dqQyxZQUFILElBQW1CeGpDLEdBQUd3akMsWUFBSCxDQUFnQmpOLElBQWhCLENBQXFCLFVBQVUvakMsQ0FBVixFQUFhO0FBQUUsY0FBT2czQyxtQkFBbUJoM0MsRUFBRWd3QyxLQUFyQixDQUFQO0FBQXFDLE1BQXpFLENBRHhCLEVBQ3FHO0FBQ25HejFDLGFBQU0sQ0FBTjtBQUNBO0FBQ0Q7QUFDRCxTQUFJZzZDLGVBQWUvbUMsRUFBZixLQUNDQSxHQUFHd2pDLFlBQUgsSUFBbUJ4akMsR0FBR3dqQyxZQUFILENBQWdCak4sSUFBaEIsQ0FBcUIsVUFBVS9qQyxDQUFWLEVBQWE7QUFBRSxjQUFPdTBDLGVBQWV2MEMsRUFBRWd3QyxLQUFqQixDQUFQO0FBQWlDLE1BQXJFLENBRHhCLEVBQ2lHO0FBQy9GejFDLGFBQU0sQ0FBTjtBQUNEO0FBQ0Y7QUFDRCxVQUFPQSxHQUFQO0FBQ0Q7O0FBRUQsVUFBU3k4QyxrQkFBVCxDQUE2QnhwQyxFQUE3QixFQUFpQztBQUMvQixVQUFPQSxHQUFHaWpDLEdBQUgsS0FBV3A3QyxTQUFYLElBQXdCbVksR0FBR3NFLEdBQUgsS0FBVyxVQUFuQyxJQUFpRHRFLEdBQUdzRSxHQUFILEtBQVcsTUFBbkU7QUFDRDs7QUFFRCxVQUFTaWxDLE9BQVQsQ0FBa0I1aUMsSUFBbEIsRUFBd0J3Z0MsS0FBeEIsRUFBK0I7QUFDN0IsT0FBSXhnQyxLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLFlBQU9pbUMsV0FBV3pnQyxJQUFYLEVBQWlCd2dDLEtBQWpCLENBQVA7QUFDRCxJQUFDLElBQUl4Z0MsS0FBS3hGLElBQUwsS0FBYyxDQUFkLElBQW1Cd0YsS0FBS1IsU0FBNUIsRUFBdUM7QUFDdkMsWUFBT3NqQyxXQUFXOWlDLElBQVgsQ0FBUDtBQUNELElBRkMsTUFFSztBQUNMLFlBQU8raUMsUUFBUS9pQyxJQUFSLENBQVA7QUFDRDtBQUNGOztBQUVELFVBQVMraUMsT0FBVCxDQUFrQmxrQyxJQUFsQixFQUF3QjtBQUN0QixVQUFRLFNBQVNBLEtBQUtyRSxJQUFMLEtBQWMsQ0FBZCxHQUNicUUsS0FBSzBLLFVBRFEsQ0FDRztBQURILEtBRWJ5NUIseUJBQXlCbDVDLEtBQUtDLFNBQUwsQ0FBZThVLEtBQUtBLElBQXBCLENBQXpCLENBRkksSUFFbUQsR0FGM0Q7QUFHRDs7QUFFRCxVQUFTaWtDLFVBQVQsQ0FBcUJ0TSxPQUFyQixFQUE4QjtBQUM1QixVQUFRLFFBQVMxc0MsS0FBS0MsU0FBTCxDQUFleXNDLFFBQVEzM0IsSUFBdkIsQ0FBVCxHQUF5QyxHQUFqRDtBQUNEOztBQUVELFVBQVNzaUMsT0FBVCxDQUFrQjluQyxFQUFsQixFQUFzQm1uQyxLQUF0QixFQUE2QjtBQUMzQixPQUFJMUQsV0FBV3pqQyxHQUFHeWpDLFFBQUgsSUFBZSxXQUE5QjtBQUNBLE9BQUlsK0IsV0FBV3NpQyxZQUFZN25DLEVBQVosRUFBZ0JtbkMsS0FBaEIsQ0FBZjtBQUNBLE9BQUlwNkMsTUFBTSxRQUFRMDJDLFFBQVIsSUFBb0JsK0IsV0FBWSxNQUFNQSxRQUFsQixHQUE4QixFQUFsRCxDQUFWO0FBQ0EsT0FBSStDLFFBQVF0SSxHQUFHc0ksS0FBSCxJQUFhLE1BQU90SSxHQUFHc0ksS0FBSCxDQUFTclgsR0FBVCxDQUFhLFVBQVU4QixDQUFWLEVBQWE7QUFBRSxZQUFTVixTQUFTVSxFQUFFdkssSUFBWCxDQUFELEdBQXFCLEdBQXJCLEdBQTRCdUssRUFBRW5ELEtBQXRDO0FBQWdELElBQTVFLEVBQThFdUUsSUFBOUUsQ0FBbUYsR0FBbkYsQ0FBUCxHQUFrRyxHQUEzSDtBQUNBLE9BQUl5MUMsVUFBVTVwQyxHQUFHb3FCLFFBQUgsQ0FBWSxRQUFaLENBQWQ7QUFDQSxPQUFJLENBQUM5aEIsU0FBU3NoQyxPQUFWLEtBQXNCLENBQUNya0MsUUFBM0IsRUFBcUM7QUFDbkN4WSxZQUFPLE9BQVA7QUFDRDtBQUNELE9BQUl1YixLQUFKLEVBQVc7QUFDVHZiLFlBQU8sTUFBTXViLEtBQWI7QUFDRDtBQUNELE9BQUlzaEMsT0FBSixFQUFhO0FBQ1g3OEMsWUFBTyxDQUFDdWIsUUFBUSxFQUFSLEdBQWEsT0FBZCxJQUF5QixHQUF6QixHQUErQnNoQyxPQUF0QztBQUNEO0FBQ0QsVUFBTzc4QyxNQUFNLEdBQWI7QUFDRDs7QUFFRDtBQUNBLFVBQVNnN0MsWUFBVCxDQUNFOEIsYUFERixFQUVFN3BDLEVBRkYsRUFHRW1uQyxLQUhGLEVBSUU7QUFDQSxPQUFJNWhDLFdBQVd2RixHQUFHdVcsY0FBSCxHQUFvQixJQUFwQixHQUEyQnN4QixZQUFZN25DLEVBQVosRUFBZ0JtbkMsS0FBaEIsRUFBdUIsSUFBdkIsQ0FBMUM7QUFDQSxVQUFRLFFBQVEwQyxhQUFSLEdBQXdCLEdBQXhCLEdBQStCN0IsVUFBVWhvQyxFQUFWLEVBQWNtbkMsS0FBZCxDQUEvQixJQUF3RDVoQyxXQUFZLE1BQU1BLFFBQWxCLEdBQThCLEVBQXRGLElBQTRGLEdBQXBHO0FBQ0Q7O0FBRUQsVUFBU2lqQyxRQUFULENBQW1CcG5DLEtBQW5CLEVBQTBCO0FBQ3hCLE9BQUlyVSxNQUFNLEVBQVY7QUFDQSxRQUFLLElBQUk5RSxJQUFJLENBQWIsRUFBZ0JBLElBQUltWixNQUFNbFosTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3JDLFNBQUk4YSxPQUFPM0IsTUFBTW5aLENBQU4sQ0FBWDtBQUNBOEUsWUFBTyxPQUFRZ1csS0FBS3ZhLElBQWIsR0FBcUIsS0FBckIsR0FBOEJtaEQseUJBQXlCNW1DLEtBQUtuVCxLQUE5QixDQUE5QixHQUFzRSxHQUE3RTtBQUNEO0FBQ0QsVUFBTzdDLElBQUlsRCxLQUFKLENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFTOC9DLHdCQUFULENBQW1DbmtDLElBQW5DLEVBQXlDO0FBQ3ZDLFVBQU9BLEtBQ0psVCxPQURJLENBQ0ksU0FESixFQUNlLFNBRGYsRUFFSkEsT0FGSSxDQUVJLFNBRkosRUFFZSxTQUZmLENBQVA7QUFHRDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSXczQyxzQkFBc0IsSUFBSWx0QixNQUFKLENBQVcsUUFBUSxDQUMzQyw0RUFDQSxxRUFEQSxHQUVBLHNEQUgyQyxFQUkzQ3hyQixLQUoyQyxDQUlyQyxHQUpxQyxFQUloQytDLElBSmdDLENBSTNCLFNBSjJCLENBQVIsR0FJTixLQUpMLENBQTFCOztBQU1BO0FBQ0EsS0FBSTQxQyxtQkFBbUIsSUFBSW50QixNQUFKLENBQVcsUUFDaEMsb0JBRHdDLENBRXhDeHJCLEtBRndDLENBRWxDLEdBRmtDLEVBRTdCK0MsSUFGNkIsQ0FFeEIsdUJBRndCLENBQVIsR0FFVyxtQkFGdEIsQ0FBdkI7O0FBSUE7QUFDQSxLQUFJNjFDLFVBQVUsa0JBQWQ7O0FBRUE7QUFDQSxLQUFJQyxnQkFBZ0IsZ0dBQXBCOztBQUVBO0FBQ0EsVUFBU0MsWUFBVCxDQUF1QmhELEdBQXZCLEVBQTRCO0FBQzFCLE9BQUlpRCxTQUFTLEVBQWI7QUFDQSxPQUFJakQsR0FBSixFQUFTO0FBQ1BrRCxlQUFVbEQsR0FBVixFQUFlaUQsTUFBZjtBQUNEO0FBQ0QsVUFBT0EsTUFBUDtBQUNEOztBQUVELFVBQVNDLFNBQVQsQ0FBb0J6akMsSUFBcEIsRUFBMEJ3akMsTUFBMUIsRUFBa0M7QUFDaEMsT0FBSXhqQyxLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLFVBQUssSUFBSTNZLElBQVQsSUFBaUJtZSxLQUFLeWpCLFFBQXRCLEVBQWdDO0FBQzlCLFdBQUl5VixNQUFNMW9DLElBQU4sQ0FBVzNPLElBQVgsQ0FBSixFQUFzQjtBQUNwQixhQUFJb0gsUUFBUStXLEtBQUt5akIsUUFBTCxDQUFjNWhDLElBQWQsQ0FBWjtBQUNBLGFBQUlvSCxLQUFKLEVBQVc7QUFDVCxlQUFJcEgsU0FBUyxPQUFiLEVBQXNCO0FBQ3BCNmhELHNCQUFTMWpDLElBQVQsRUFBZ0IsYUFBYS9XLEtBQWIsR0FBcUIsSUFBckMsRUFBNEN1NkMsTUFBNUM7QUFDRCxZQUZELE1BRU8sSUFBSXZLLEtBQUt6b0MsSUFBTCxDQUFVM08sSUFBVixDQUFKLEVBQXFCO0FBQzFCOGhELHdCQUFXMTZDLEtBQVgsRUFBbUJwSCxPQUFPLEtBQVAsR0FBZW9ILEtBQWYsR0FBdUIsSUFBMUMsRUFBaUR1NkMsTUFBakQ7QUFDRCxZQUZNLE1BRUE7QUFDTEksNkJBQWdCMzZDLEtBQWhCLEVBQXdCcEgsT0FBTyxLQUFQLEdBQWVvSCxLQUFmLEdBQXVCLElBQS9DLEVBQXNEdTZDLE1BQXREO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxTQUFJeGpDLEtBQUtwQixRQUFULEVBQW1CO0FBQ2pCLFlBQUssSUFBSXRkLElBQUksQ0FBYixFQUFnQkEsSUFBSTBlLEtBQUtwQixRQUFMLENBQWNyZCxNQUFsQyxFQUEwQ0QsR0FBMUMsRUFBK0M7QUFDN0NtaUQsbUJBQVV6akMsS0FBS3BCLFFBQUwsQ0FBY3RkLENBQWQsQ0FBVixFQUE0QmtpRCxNQUE1QjtBQUNEO0FBQ0Y7QUFDRixJQXBCRCxNQW9CTyxJQUFJeGpDLEtBQUt4RixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDMUJvcEMscUJBQWdCNWpDLEtBQUt1SixVQUFyQixFQUFpQ3ZKLEtBQUtuQixJQUF0QyxFQUE0QzJrQyxNQUE1QztBQUNEO0FBQ0Y7O0FBRUQsVUFBU0csVUFBVCxDQUFxQmxpQixHQUFyQixFQUEwQjVpQixJQUExQixFQUFnQzJrQyxNQUFoQyxFQUF3QztBQUN0QyxPQUFJSyxVQUFVcGlCLElBQUk5MUIsT0FBSixDQUFZMjNDLGFBQVosRUFBMkIsRUFBM0IsQ0FBZDtBQUNBLE9BQUlRLGVBQWVELFFBQVFseUMsS0FBUixDQUFjeXhDLGdCQUFkLENBQW5CO0FBQ0EsT0FBSVUsZ0JBQWdCRCxRQUFROTNDLE1BQVIsQ0FBZSszQyxhQUFheCtDLEtBQWIsR0FBcUIsQ0FBcEMsTUFBMkMsR0FBL0QsRUFBb0U7QUFDbEVrK0MsWUFBT3R4QyxJQUFQLENBQ0UsNkRBQ0EsSUFEQSxHQUNRNHhDLGFBQWEsQ0FBYixDQURSLEdBQzJCLG1CQUQzQixHQUNrRGpsQyxLQUFLdWpCLElBQUwsRUFGcEQ7QUFJRDtBQUNEd2hCLG1CQUFnQm5pQixHQUFoQixFQUFxQjVpQixJQUFyQixFQUEyQjJrQyxNQUEzQjtBQUNEOztBQUVELFVBQVNFLFFBQVQsQ0FBbUIxakMsSUFBbkIsRUFBeUJuQixJQUF6QixFQUErQjJrQyxNQUEvQixFQUF1QztBQUNyQ0ksbUJBQWdCNWpDLEtBQUtzOEIsR0FBTCxJQUFZLEVBQTVCLEVBQWdDejlCLElBQWhDLEVBQXNDMmtDLE1BQXRDO0FBQ0FPLG1CQUFnQi9qQyxLQUFLdThCLEtBQXJCLEVBQTRCLGFBQTVCLEVBQTJDMTlCLElBQTNDLEVBQWlEMmtDLE1BQWpEO0FBQ0FPLG1CQUFnQi9qQyxLQUFLeThCLFNBQXJCLEVBQWdDLGdCQUFoQyxFQUFrRDU5QixJQUFsRCxFQUF3RDJrQyxNQUF4RDtBQUNBTyxtQkFBZ0IvakMsS0FBSzA4QixTQUFyQixFQUFnQyxnQkFBaEMsRUFBa0Q3OUIsSUFBbEQsRUFBd0Qya0MsTUFBeEQ7QUFDRDs7QUFFRCxVQUFTTyxlQUFULENBQTBCQyxLQUExQixFQUFpQ3hwQyxJQUFqQyxFQUF1Q3FFLElBQXZDLEVBQTZDMmtDLE1BQTdDLEVBQXFEO0FBQ25ELE9BQUksT0FBT1EsS0FBUCxLQUFpQixRQUFqQixJQUE2QixDQUFDWCxRQUFRN3lDLElBQVIsQ0FBYXd6QyxLQUFiLENBQWxDLEVBQXVEO0FBQ3JEUixZQUFPdHhDLElBQVAsQ0FBYSxhQUFhc0ksSUFBYixHQUFvQixLQUFwQixHQUE0QndwQyxLQUE1QixHQUFvQyxvQkFBcEMsR0FBNERubEMsS0FBS3VqQixJQUFMLEVBQXpFO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTd2hCLGVBQVQsQ0FBMEJuaUIsR0FBMUIsRUFBK0I1aUIsSUFBL0IsRUFBcUMya0MsTUFBckMsRUFBNkM7QUFDM0MsT0FBSTtBQUNGLFNBQUk5aUQsUUFBSixDQUFjLFlBQVkrZ0MsR0FBMUI7QUFDRCxJQUZELENBRUUsT0FBTzVnQyxDQUFQLEVBQVU7QUFDVixTQUFJaWpELGVBQWVyaUIsSUFBSTkxQixPQUFKLENBQVkyM0MsYUFBWixFQUEyQixFQUEzQixFQUErQjN4QyxLQUEvQixDQUFxQ3d4QyxtQkFBckMsQ0FBbkI7QUFDQSxTQUFJVyxZQUFKLEVBQWtCO0FBQ2hCTixjQUFPdHhDLElBQVAsQ0FDRSxzREFDQSxJQURBLEdBQ1E0eEMsYUFBYSxDQUFiLENBRFIsR0FDMkIsbUJBRDNCLEdBQ2tEamxDLEtBQUt1akIsSUFBTCxFQUZwRDtBQUlELE1BTEQsTUFLTztBQUNMb2hCLGNBQU90eEMsSUFBUCxDQUFhLHlCQUEwQjJNLEtBQUt1akIsSUFBTCxFQUF2QztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxVQUFTNmhCLGNBQVQsQ0FBeUJuZSxJQUF6QixFQUErQjBkLE1BQS9CLEVBQXVDO0FBQ3JDLE9BQUk7QUFDRixZQUFPLElBQUk5aUQsUUFBSixDQUFhb2xDLElBQWIsQ0FBUDtBQUNELElBRkQsQ0FFRSxPQUFPMXpCLEdBQVAsRUFBWTtBQUNab3hDLFlBQU90eEMsSUFBUCxDQUFZLEVBQUVFLEtBQUtBLEdBQVAsRUFBWTB6QixNQUFNQSxJQUFsQixFQUFaO0FBQ0EsWUFBTzVsQyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTZ2tELHlCQUFULENBQW9DQyxPQUFwQyxFQUE2QztBQUMzQyxPQUFJNzRDLFFBQVFwRCxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBWjs7QUFFQSxVQUFPLFNBQVM2NUMsa0JBQVQsQ0FDTGo5QixRQURLLEVBRUw5VixPQUZLLEVBR0xKLEVBSEssRUFJTDtBQUNBSSxlQUFVQSxXQUFXLEVBQXJCOztBQUVBO0FBQ0EsU0FBSXpDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBLFdBQUk7QUFDRixhQUFJcE8sUUFBSixDQUFhLFVBQWI7QUFDRCxRQUZELENBRUUsT0FBT0csQ0FBUCxFQUFVO0FBQ1YsYUFBSUEsRUFBRXVJLFFBQUYsR0FBYXVJLEtBQWIsQ0FBbUIsaUJBQW5CLENBQUosRUFBMkM7QUFDekNqQixnQkFDRSxpRUFDQSx1RUFEQSxHQUVBLGtFQUZBLEdBR0EsaUVBSEEsR0FJQSxrQ0FMRjtBQU9EO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBLFNBQUl2RixNQUFNa0csUUFBUWdqQyxVQUFSLEdBQ05ycUMsT0FBT3FILFFBQVFnakMsVUFBZixJQUE2Qmx0QixRQUR2QixHQUVOQSxRQUZKO0FBR0EsU0FBSTdiLE1BQU1ILEdBQU4sQ0FBSixFQUFnQjtBQUNkLGNBQU9HLE1BQU1ILEdBQU4sQ0FBUDtBQUNEOztBQUVEO0FBQ0EsU0FBSWs1QyxXQUFXRixRQUFRaDlCLFFBQVIsRUFBa0I5VixPQUFsQixDQUFmOztBQUVBO0FBQ0EsU0FBSXpDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJdTFDLFNBQVNiLE1BQVQsSUFBbUJhLFNBQVNiLE1BQVQsQ0FBZ0JqaUQsTUFBdkMsRUFBK0M7QUFDN0NtUCxjQUNFLGtDQUFrQ3lXLFFBQWxDLEdBQTZDLE1BQTdDLEdBQ0FrOUIsU0FBU2IsTUFBVCxDQUFnQmw1QyxHQUFoQixDQUFvQixVQUFVekosQ0FBVixFQUFhO0FBQUUsa0JBQVEsT0FBT0EsQ0FBZjtBQUFvQixVQUF2RCxFQUF5RDJNLElBQXpELENBQThELElBQTlELENBREEsR0FDc0UsSUFGeEUsRUFHRXlELEVBSEY7QUFLRDtBQUNELFdBQUlvekMsU0FBU0MsSUFBVCxJQUFpQkQsU0FBU0MsSUFBVCxDQUFjL2lELE1BQW5DLEVBQTJDO0FBQ3pDOGlELGtCQUFTQyxJQUFULENBQWNsOEMsT0FBZCxDQUFzQixVQUFVNEksR0FBVixFQUFlO0FBQUUsa0JBQU9MLElBQUlLLEdBQUosRUFBU0MsRUFBVCxDQUFQO0FBQXNCLFVBQTdEO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFNBQUk3SyxNQUFNLEVBQVY7QUFDQSxTQUFJbStDLGNBQWMsRUFBbEI7QUFDQW4rQyxTQUFJb1ksTUFBSixHQUFheWxDLGVBQWVJLFNBQVM3bEMsTUFBeEIsRUFBZ0MrbEMsV0FBaEMsQ0FBYjtBQUNBbitDLFNBQUl5cEIsZUFBSixHQUFzQncwQixTQUFTeDBCLGVBQVQsQ0FBeUJ2bEIsR0FBekIsQ0FBNkIsVUFBVXc3QixJQUFWLEVBQWdCO0FBQ2pFLGNBQU9tZSxlQUFlbmUsSUFBZixFQUFxQnllLFdBQXJCLENBQVA7QUFDRCxNQUZxQixDQUF0Qjs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUkzMUMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFdBQUksQ0FBQyxDQUFDdTFDLFNBQVNiLE1BQVYsSUFBb0IsQ0FBQ2EsU0FBU2IsTUFBVCxDQUFnQmppRCxNQUF0QyxLQUFpRGdqRCxZQUFZaGpELE1BQWpFLEVBQXlFO0FBQ3ZFbVAsY0FDRSw0Q0FDQTZ6QyxZQUFZajZDLEdBQVosQ0FBZ0IsVUFBVW9vQixHQUFWLEVBQWU7QUFDN0IsZUFBSXRnQixNQUFNc2dCLElBQUl0Z0IsR0FBZDtBQUNBLGVBQUkwekIsT0FBT3BULElBQUlvVCxJQUFmOztBQUVBLGtCQUFTMXpCLElBQUloSixRQUFKLEVBQUQsR0FBbUIsU0FBbkIsR0FBK0IwOEIsSUFBL0IsR0FBc0MsSUFBOUM7QUFDSCxVQUxDLEVBS0N0NEIsSUFMRCxDQUtNLElBTE4sQ0FGRixFQVFFeUQsRUFSRjtBQVVEO0FBQ0Y7O0FBRUQsWUFBUTNGLE1BQU1ILEdBQU4sSUFBYS9FLEdBQXJCO0FBQ0QsSUE5RUQ7QUErRUQ7O0FBRUQ7O0FBRUEsVUFBU28rQyxxQkFBVCxDQUFnQ0MsV0FBaEMsRUFBNkM7QUFDM0MsVUFBTyxTQUFTQyxjQUFULENBQXlCaFAsV0FBekIsRUFBc0M7QUFDM0MsY0FBU3lPLE9BQVQsQ0FDRWg5QixRQURGLEVBRUU5VixPQUZGLEVBR0U7QUFDQSxXQUFJc3pDLGVBQWV6OEMsT0FBT3FDLE1BQVAsQ0FBY21yQyxXQUFkLENBQW5CO0FBQ0EsV0FBSThOLFNBQVMsRUFBYjtBQUNBLFdBQUljLE9BQU8sRUFBWDtBQUNBSyxvQkFBYWowQyxJQUFiLEdBQW9CLFVBQVVNLEdBQVYsRUFBZUwsR0FBZixFQUFvQjtBQUN0QyxVQUFDQSxNQUFNMnpDLElBQU4sR0FBYWQsTUFBZCxFQUFzQnR4QyxJQUF0QixDQUEyQmxCLEdBQTNCO0FBQ0QsUUFGRDs7QUFJQSxXQUFJSyxPQUFKLEVBQWE7QUFDWDtBQUNBLGFBQUlBLFFBQVFsRSxPQUFaLEVBQXFCO0FBQ25CdzNDLHdCQUFheDNDLE9BQWIsR0FDRSxDQUFDdW9DLFlBQVl2b0MsT0FBWixJQUF1QixFQUF4QixFQUE0QkcsTUFBNUIsQ0FBbUMrRCxRQUFRbEUsT0FBM0MsQ0FERjtBQUVEO0FBQ0Q7QUFDQSxhQUFJa0UsUUFBUWlLLFVBQVosRUFBd0I7QUFDdEJxcEMsd0JBQWFycEMsVUFBYixHQUEwQjNPLE9BQ3hCekUsT0FBT3FDLE1BQVAsQ0FBY21yQyxZQUFZcDZCLFVBQTFCLENBRHdCLEVBRXhCakssUUFBUWlLLFVBRmdCLENBQTFCO0FBSUQ7QUFDRDtBQUNBLGNBQUssSUFBSW5RLEdBQVQsSUFBZ0JrRyxPQUFoQixFQUF5QjtBQUN2QixlQUFJbEcsUUFBUSxTQUFSLElBQXFCQSxRQUFRLFlBQWpDLEVBQStDO0FBQzdDdzVDLDBCQUFheDVDLEdBQWIsSUFBb0JrRyxRQUFRbEcsR0FBUixDQUFwQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFJazVDLFdBQVdJLFlBQVl0OUIsUUFBWixFQUFzQnc5QixZQUF0QixDQUFmO0FBQ0EsV0FBSS8xQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMwMEMsZ0JBQU90eEMsSUFBUCxDQUFZcFIsS0FBWixDQUFrQjBpRCxNQUFsQixFQUEwQkQsYUFBYWMsU0FBUzlELEdBQXRCLENBQTFCO0FBQ0Q7QUFDRDhELGdCQUFTYixNQUFULEdBQWtCQSxNQUFsQjtBQUNBYSxnQkFBU0MsSUFBVCxHQUFnQkEsSUFBaEI7QUFDQSxjQUFPRCxRQUFQO0FBQ0Q7O0FBRUQsWUFBTztBQUNMRixnQkFBU0EsT0FESjtBQUVMQywyQkFBb0JGLDBCQUEwQkMsT0FBMUI7QUFGZixNQUFQO0FBSUQsSUE5Q0Q7QUErQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSU8saUJBQWlCRixzQkFBc0IsU0FBU0MsV0FBVCxDQUN6Q3Q5QixRQUR5QyxFQUV6QzlWLE9BRnlDLEVBR3pDO0FBQ0EsT0FBSWt2QyxNQUFNdkcsTUFBTTd5QixTQUFTaWIsSUFBVCxFQUFOLEVBQXVCL3dCLE9BQXZCLENBQVY7QUFDQXVzQyxZQUFTMkMsR0FBVCxFQUFjbHZDLE9BQWQ7QUFDQSxPQUFJeTBCLE9BQU93YSxTQUFTQyxHQUFULEVBQWNsdkMsT0FBZCxDQUFYO0FBQ0EsVUFBTztBQUNMa3ZDLFVBQUtBLEdBREE7QUFFTC9oQyxhQUFRc25CLEtBQUt0bkIsTUFGUjtBQUdMcVIsc0JBQWlCaVcsS0FBS2pXO0FBSGpCLElBQVA7QUFLRCxFQVpvQixDQUFyQjs7QUFjQTs7QUFFQSxLQUFJKzBCLFFBQVFGLGVBQWVoUCxXQUFmLENBQVo7QUFDQSxLQUFJME8scUJBQXFCUSxNQUFNUixrQkFBL0I7O0FBRUE7O0FBRUEsS0FBSVMsZUFBZXo1QyxPQUFPLFVBQVVsRixFQUFWLEVBQWM7QUFDdEMsT0FBSW1ULEtBQUt2VCxNQUFNSSxFQUFOLENBQVQ7QUFDQSxVQUFPbVQsTUFBTUEsR0FBRzI2QixTQUFoQjtBQUNELEVBSGtCLENBQW5COztBQUtBLEtBQUk4USxRQUFRbHdCLE1BQU1qMEIsU0FBTixDQUFnQjh0QixNQUE1QjtBQUNBbUcsT0FBTWowQixTQUFOLENBQWdCOHRCLE1BQWhCLEdBQXlCLFVBQ3ZCcFYsRUFEdUIsRUFFdkI2TSxTQUZ1QixFQUd2QjtBQUNBN00sUUFBS0EsTUFBTXZULE1BQU11VCxFQUFOLENBQVg7O0FBRUE7QUFDQSxPQUFJQSxPQUFPM1csU0FBUyt2QyxJQUFoQixJQUF3QnA1QixPQUFPM1csU0FBU3FpRCxlQUE1QyxFQUE2RDtBQUMzRG4yQyxhQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2QywwRUFEdUMsQ0FBekM7QUFHQSxZQUFPLElBQVA7QUFDRDs7QUFFRCxPQUFJVyxVQUFVLEtBQUtFLFFBQW5CO0FBQ0E7QUFDQSxPQUFJLENBQUNGLFFBQVFtTixNQUFiLEVBQXFCO0FBQ25CLFNBQUkySSxXQUFXOVYsUUFBUThWLFFBQXZCO0FBQ0EsU0FBSUEsUUFBSixFQUFjO0FBQ1osV0FBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLGFBQUlBLFNBQVNwYixNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQTNCLEVBQWdDO0FBQzlCb2Isc0JBQVcwOUIsYUFBYTE5QixRQUFiLENBQVg7QUFDQTtBQUNBLGVBQUl2WSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQ3FZLFFBQTlDLEVBQXdEO0FBQ3REelcsa0JBQ0csNkNBQThDVyxRQUFROFYsUUFEekQsRUFFRSxJQUZGO0FBSUQ7QUFDRjtBQUNGLFFBWEQsTUFXTyxJQUFJQSxTQUFTMlgsUUFBYixFQUF1QjtBQUM1QjNYLG9CQUFXQSxTQUFTNnNCLFNBQXBCO0FBQ0QsUUFGTSxNQUVBO0FBQ0wsYUFBSXBsQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM0QixnQkFBSyw2QkFBNkJ5VyxRQUFsQyxFQUE0QyxJQUE1QztBQUNEO0FBQ0QsZ0JBQU8sSUFBUDtBQUNEO0FBQ0YsTUFwQkQsTUFvQk8sSUFBSTlOLEVBQUosRUFBUTtBQUNiOE4sa0JBQVc2OUIsYUFBYTNyQyxFQUFiLENBQVg7QUFDRDtBQUNELFNBQUk4TixRQUFKLEVBQWM7QUFDWjtBQUNBLFdBQUl2WSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkVBLGNBQUssU0FBTDtBQUNEOztBQUVELFdBQUlvVixNQUFNMHhCLG1CQUFtQmo5QixRQUFuQixFQUE2QjtBQUNyQzhzQiwrQkFBc0JBLG9CQURlO0FBRXJDSSxxQkFBWWhqQyxRQUFRZ2pDLFVBRmlCO0FBR3JDbUcsbUJBQVVucEMsUUFBUW1wQztBQUhtQixRQUE3QixFQUlQLElBSk8sQ0FBVjtBQUtBLFdBQUloOEIsU0FBU2tVLElBQUlsVSxNQUFqQjtBQUNBLFdBQUlxUixrQkFBa0I2QyxJQUFJN0MsZUFBMUI7QUFDQXhlLGVBQVFtTixNQUFSLEdBQWlCQSxNQUFqQjtBQUNBbk4sZUFBUXdlLGVBQVIsR0FBMEJBLGVBQTFCOztBQUVBO0FBQ0EsV0FBSWpoQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkVBLGNBQUssYUFBTDtBQUNBQyxpQkFBVSxLQUFLOEosS0FBTixHQUFlLFVBQXhCLEVBQXFDLFNBQXJDLEVBQWdELGFBQWhEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsVUFBT3k5QixNQUFNbGtELElBQU4sQ0FBVyxJQUFYLEVBQWlCeVksRUFBakIsRUFBcUI2TSxTQUFyQixDQUFQO0FBQ0QsRUFqRUQ7O0FBbUVBOzs7O0FBSUEsVUFBUzgrQixZQUFULENBQXVCM3JDLEVBQXZCLEVBQTJCO0FBQ3pCLE9BQUlBLEdBQUc0ckMsU0FBUCxFQUFrQjtBQUNoQixZQUFPNXJDLEdBQUc0ckMsU0FBVjtBQUNELElBRkQsTUFFTztBQUNMLFNBQUlDLFlBQVl4aUQsU0FBU3VyQixhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FpM0IsZUFBVWxyQixXQUFWLENBQXNCM2dCLEdBQUcrNUIsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxZQUFPOFIsVUFBVWxSLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRHBmLE9BQU11dkIsT0FBTixHQUFnQkMsa0JBQWhCOzttQkFFZXh2QixLOzs7Ozs7Ozs7QUNwMlRmO0FBQ0EsS0FBSWhtQixVQUFVN08sT0FBT0MsT0FBUCxHQUFpQixFQUEvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJbWxELGdCQUFKO0FBQ0EsS0FBSUMsa0JBQUo7O0FBRUEsVUFBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsV0FBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIO0FBQ0QsVUFBU0MsbUJBQVQsR0FBZ0M7QUFDNUIsV0FBTSxJQUFJRCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNIO0FBQ0EsY0FBWTtBQUNULFNBQUk7QUFDQSxhQUFJLE9BQU81d0MsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNsQ3l3QyxnQ0FBbUJ6d0MsVUFBbkI7QUFDSCxVQUZELE1BRU87QUFDSHl3QyxnQ0FBbUJFLGdCQUFuQjtBQUNIO0FBQ0osTUFORCxDQU1FLE9BQU94a0QsQ0FBUCxFQUFVO0FBQ1Jza0QsNEJBQW1CRSxnQkFBbkI7QUFDSDtBQUNELFNBQUk7QUFDQSxhQUFJLE9BQU9HLFlBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDcENKLGtDQUFxQkksWUFBckI7QUFDSCxVQUZELE1BRU87QUFDSEosa0NBQXFCRyxtQkFBckI7QUFDSDtBQUNKLE1BTkQsQ0FNRSxPQUFPMWtELENBQVAsRUFBVTtBQUNSdWtELDhCQUFxQkcsbUJBQXJCO0FBQ0g7QUFDSixFQW5CQSxHQUFEO0FBb0JBLFVBQVNFLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3JCLFNBQUlQLHFCQUFxQnp3QyxVQUF6QixFQUFxQztBQUNqQztBQUNBLGdCQUFPQSxXQUFXZ3hDLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxTQUFJLENBQUNQLHFCQUFxQkUsZ0JBQXJCLElBQXlDLENBQUNGLGdCQUEzQyxLQUFnRXp3QyxVQUFwRSxFQUFnRjtBQUM1RXl3Qyw0QkFBbUJ6d0MsVUFBbkI7QUFDQSxnQkFBT0EsV0FBV2d4QyxHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNELFNBQUk7QUFDQTtBQUNBLGdCQUFPUCxpQkFBaUJPLEdBQWpCLEVBQXNCLENBQXRCLENBQVA7QUFDSCxNQUhELENBR0UsT0FBTTdrRCxDQUFOLEVBQVE7QUFDTixhQUFJO0FBQ0E7QUFDQSxvQkFBT3NrRCxpQkFBaUJ2a0QsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEI4a0QsR0FBNUIsRUFBaUMsQ0FBakMsQ0FBUDtBQUNILFVBSEQsQ0FHRSxPQUFNN2tELENBQU4sRUFBUTtBQUNOO0FBQ0Esb0JBQU9za0QsaUJBQWlCdmtELElBQWpCLENBQXNCLElBQXRCLEVBQTRCOGtELEdBQTVCLEVBQWlDLENBQWpDLENBQVA7QUFDSDtBQUNKO0FBR0o7QUFDRCxVQUFTQyxlQUFULENBQXlCQyxNQUF6QixFQUFpQztBQUM3QixTQUFJUix1QkFBdUJJLFlBQTNCLEVBQXlDO0FBQ3JDO0FBQ0EsZ0JBQU9BLGFBQWFJLE1BQWIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxTQUFJLENBQUNSLHVCQUF1QkcsbUJBQXZCLElBQThDLENBQUNILGtCQUFoRCxLQUF1RUksWUFBM0UsRUFBeUY7QUFDckZKLDhCQUFxQkksWUFBckI7QUFDQSxnQkFBT0EsYUFBYUksTUFBYixDQUFQO0FBQ0g7QUFDRCxTQUFJO0FBQ0E7QUFDQSxnQkFBT1IsbUJBQW1CUSxNQUFuQixDQUFQO0FBQ0gsTUFIRCxDQUdFLE9BQU8va0QsQ0FBUCxFQUFTO0FBQ1AsYUFBSTtBQUNBO0FBQ0Esb0JBQU91a0QsbUJBQW1CeGtELElBQW5CLENBQXdCLElBQXhCLEVBQThCZ2xELE1BQTlCLENBQVA7QUFDSCxVQUhELENBR0UsT0FBTy9rRCxDQUFQLEVBQVM7QUFDUDtBQUNBO0FBQ0Esb0JBQU91a0QsbUJBQW1CeGtELElBQW5CLENBQXdCLElBQXhCLEVBQThCZ2xELE1BQTlCLENBQVA7QUFDSDtBQUNKO0FBSUo7QUFDRCxLQUFJaDlCLFFBQVEsRUFBWjtBQUNBLEtBQUlpOUIsV0FBVyxLQUFmO0FBQ0EsS0FBSUMsWUFBSjtBQUNBLEtBQUlDLGFBQWEsQ0FBQyxDQUFsQjs7QUFFQSxVQUFTQyxlQUFULEdBQTJCO0FBQ3ZCLFNBQUksQ0FBQ0gsUUFBRCxJQUFhLENBQUNDLFlBQWxCLEVBQWdDO0FBQzVCO0FBQ0g7QUFDREQsZ0JBQVcsS0FBWDtBQUNBLFNBQUlDLGFBQWF2a0QsTUFBakIsRUFBeUI7QUFDckJxbkIsaUJBQVFrOUIsYUFBYXg0QyxNQUFiLENBQW9Cc2IsS0FBcEIsQ0FBUjtBQUNILE1BRkQsTUFFTztBQUNIbTlCLHNCQUFhLENBQUMsQ0FBZDtBQUNIO0FBQ0QsU0FBSW45QixNQUFNcm5CLE1BQVYsRUFBa0I7QUFDZDBrRDtBQUNIO0FBQ0o7O0FBRUQsVUFBU0EsVUFBVCxHQUFzQjtBQUNsQixTQUFJSixRQUFKLEVBQWM7QUFDVjtBQUNIO0FBQ0QsU0FBSXBpQyxVQUFVZ2lDLFdBQVdPLGVBQVgsQ0FBZDtBQUNBSCxnQkFBVyxJQUFYOztBQUVBLFNBQUk3dUMsTUFBTTRSLE1BQU1ybkIsTUFBaEI7QUFDQSxZQUFNeVYsR0FBTixFQUFXO0FBQ1A4dUMsd0JBQWVsOUIsS0FBZjtBQUNBQSxpQkFBUSxFQUFSO0FBQ0EsZ0JBQU8sRUFBRW05QixVQUFGLEdBQWUvdUMsR0FBdEIsRUFBMkI7QUFDdkIsaUJBQUk4dUMsWUFBSixFQUFrQjtBQUNkQSw4QkFBYUMsVUFBYixFQUF5QjE4QixHQUF6QjtBQUNIO0FBQ0o7QUFDRDA4QixzQkFBYSxDQUFDLENBQWQ7QUFDQS91QyxlQUFNNFIsTUFBTXJuQixNQUFaO0FBQ0g7QUFDRHVrRCxvQkFBZSxJQUFmO0FBQ0FELGdCQUFXLEtBQVg7QUFDQUYscUJBQWdCbGlDLE9BQWhCO0FBQ0g7O0FBRUQ3VSxTQUFRcUYsUUFBUixHQUFtQixVQUFVeXhDLEdBQVYsRUFBZTtBQUM5QixTQUFJM3VDLE9BQU8sSUFBSXJLLEtBQUosQ0FBVTNMLFVBQVVRLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBLFNBQUlSLFVBQVVRLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsY0FBSyxJQUFJRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlQLFVBQVVRLE1BQTlCLEVBQXNDRCxHQUF0QyxFQUEyQztBQUN2Q3lWLGtCQUFLelYsSUFBSSxDQUFULElBQWNQLFVBQVVPLENBQVYsQ0FBZDtBQUNIO0FBQ0o7QUFDRHNuQixXQUFNMVcsSUFBTixDQUFXLElBQUlnMEMsSUFBSixDQUFTUixHQUFULEVBQWMzdUMsSUFBZCxDQUFYO0FBQ0EsU0FBSTZSLE1BQU1ybkIsTUFBTixLQUFpQixDQUFqQixJQUFzQixDQUFDc2tELFFBQTNCLEVBQXFDO0FBQ2pDSixvQkFBV1EsVUFBWDtBQUNIO0FBQ0osRUFYRDs7QUFhQTtBQUNBLFVBQVNDLElBQVQsQ0FBY1IsR0FBZCxFQUFtQlMsS0FBbkIsRUFBMEI7QUFDdEIsVUFBS1QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsVUFBS1MsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7QUFDREQsTUFBS3ZsRCxTQUFMLENBQWUwb0IsR0FBZixHQUFxQixZQUFZO0FBQzdCLFVBQUtxOEIsR0FBTCxDQUFTNWtELEtBQVQsQ0FBZSxJQUFmLEVBQXFCLEtBQUtxbEQsS0FBMUI7QUFDSCxFQUZEO0FBR0F2M0MsU0FBUXczQyxLQUFSLEdBQWdCLFNBQWhCO0FBQ0F4M0MsU0FBUXkzQyxPQUFSLEdBQWtCLElBQWxCO0FBQ0F6M0MsU0FBUUMsR0FBUixHQUFjLEVBQWQ7QUFDQUQsU0FBUTAzQyxJQUFSLEdBQWUsRUFBZjtBQUNBMTNDLFNBQVF5b0IsT0FBUixHQUFrQixFQUFsQixDLENBQXNCO0FBQ3RCem9CLFNBQVEyM0MsUUFBUixHQUFtQixFQUFuQjs7QUFFQSxVQUFTcm1ELElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIwTyxTQUFRb1MsRUFBUixHQUFhOWdCLElBQWI7QUFDQTBPLFNBQVFqSixXQUFSLEdBQXNCekYsSUFBdEI7QUFDQTBPLFNBQVFULElBQVIsR0FBZWpPLElBQWY7QUFDQTBPLFNBQVE0M0MsR0FBUixHQUFjdG1ELElBQWQ7QUFDQTBPLFNBQVE2M0MsY0FBUixHQUF5QnZtRCxJQUF6QjtBQUNBME8sU0FBUTgzQyxrQkFBUixHQUE2QnhtRCxJQUE3QjtBQUNBME8sU0FBUWdiLElBQVIsR0FBZTFwQixJQUFmO0FBQ0EwTyxTQUFRKzNDLGVBQVIsR0FBMEJ6bUQsSUFBMUI7QUFDQTBPLFNBQVFnNEMsbUJBQVIsR0FBOEIxbUQsSUFBOUI7O0FBRUEwTyxTQUFRa1YsU0FBUixHQUFvQixVQUFVamlCLElBQVYsRUFBZ0I7QUFBRSxZQUFPLEVBQVA7QUFBVyxFQUFqRDs7QUFFQStNLFNBQVF3Z0MsT0FBUixHQUFrQixVQUFVdnRDLElBQVYsRUFBZ0I7QUFDOUIsV0FBTSxJQUFJeWpELEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsRUFGRDs7QUFJQTEyQyxTQUFRaTRDLEdBQVIsR0FBYyxZQUFZO0FBQUUsWUFBTyxHQUFQO0FBQVksRUFBeEM7QUFDQWo0QyxTQUFRazRDLEtBQVIsR0FBZ0IsVUFBVTdtQixHQUFWLEVBQWU7QUFDM0IsV0FBTSxJQUFJcWxCLEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQ0gsRUFGRDtBQUdBMTJDLFNBQVFtNEMsS0FBUixHQUFnQixZQUFXO0FBQUUsWUFBTyxDQUFQO0FBQVcsRUFBeEMsQzs7Ozs7Ozs7OztBQ3ZMQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsRUFBQyxVQUFVbG5ELFVBQVYsRUFBc0I7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0EsU0FBSSxPQUFPbW5ELFNBQVAsS0FBcUIsVUFBekIsRUFBcUM7QUFDakNBLG1CQUFVLFNBQVYsRUFBcUJubkQsVUFBckI7O0FBRUo7QUFDQyxNQUpELE1BSU8sSUFBSSxnQ0FBT0csT0FBUCxPQUFtQixRQUFuQixJQUErQixnQ0FBT0QsTUFBUCxPQUFrQixRQUFyRCxFQUErRDtBQUNsRUEsZ0JBQU9DLE9BQVAsR0FBaUJILFlBQWpCOztBQUVKO0FBQ0MsTUFKTSxNQUlBLElBQUksSUFBSixFQUFnRDtBQUNuREMsU0FBQSxvQ0FBT0QsVUFBUDs7QUFFSjtBQUNDLE1BSk0sTUFJQSxJQUFJLE9BQU9vbkQsR0FBUCxLQUFlLFdBQW5CLEVBQWdDO0FBQ25DLGFBQUksQ0FBQ0EsSUFBSUMsRUFBSixFQUFMLEVBQWU7QUFDWDtBQUNILFVBRkQsTUFFTztBQUNIRCxpQkFBSUUsS0FBSixHQUFZdG5ELFVBQVo7QUFDSDs7QUFFTDtBQUNDLE1BUk0sTUFRQSxJQUFJLE9BQU8wQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDLE9BQU9QLElBQVAsS0FBZ0IsV0FBckQsRUFBa0U7QUFDckU7QUFDQTtBQUNBLGFBQUl3UixTQUFTLE9BQU9qUixNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5Q1AsSUFBdEQ7O0FBRUE7QUFDQTtBQUNBLGFBQUlvbEQsWUFBWTV6QyxPQUFPNnpDLENBQXZCO0FBQ0E3ekMsZ0JBQU82ekMsQ0FBUCxHQUFXeG5ELFlBQVg7O0FBRUE7QUFDQTtBQUNBMlQsZ0JBQU82ekMsQ0FBUCxDQUFTbGpELFVBQVQsR0FBc0IsWUFBWTtBQUM5QnFQLG9CQUFPNnpDLENBQVAsR0FBV0QsU0FBWDtBQUNBLG9CQUFPLElBQVA7QUFDSCxVQUhEO0FBS0gsTUFqQk0sTUFpQkE7QUFDSCxlQUFNLElBQUk5QixLQUFKLENBQVUsK0RBQVYsQ0FBTjtBQUNIO0FBRUosRUFsREQsRUFrREcsWUFBWTtBQUNmOztBQUVBLFNBQUlnQyxZQUFZLEtBQWhCO0FBQ0EsU0FBSTtBQUNBLGVBQU0sSUFBSWhDLEtBQUosRUFBTjtBQUNILE1BRkQsQ0FFRSxPQUFPemtELENBQVAsRUFBVTtBQUNSeW1ELHFCQUFZLENBQUMsQ0FBQ3ptRCxFQUFFeTJDLEtBQWhCO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLFNBQUlpUSxnQkFBZ0JDLGFBQXBCO0FBQ0EsU0FBSUMsU0FBSjs7QUFFQTs7QUFFQTtBQUNBLFNBQUl2bkQsT0FBTyxTQUFQQSxJQUFPLEdBQVksQ0FBRSxDQUF6Qjs7QUFFQTtBQUNBO0FBQ0EsU0FBSStULFdBQVcsWUFBWTtBQUN2QjtBQUNBLGFBQUl5ekMsT0FBTyxFQUFDQyxNQUFNLEtBQUssQ0FBWixFQUFlampCLE1BQU0sSUFBckIsRUFBWDtBQUNBLGFBQUlrakIsT0FBT0YsSUFBWDtBQUNBLGFBQUkxK0IsV0FBVyxLQUFmO0FBQ0EsYUFBSTYrQixjQUFjLEtBQUssQ0FBdkI7QUFDQSxhQUFJQyxXQUFXLEtBQWY7QUFDQTtBQUNBLGFBQUlDLGFBQWEsRUFBakI7O0FBRUEsa0JBQVNDLEtBQVQsR0FBaUI7QUFDYjtBQUNBLGlCQUFJTCxJQUFKLEVBQVVNLE1BQVY7O0FBRUEsb0JBQU9QLEtBQUtoakIsSUFBWixFQUFrQjtBQUNkZ2pCLHdCQUFPQSxLQUFLaGpCLElBQVo7QUFDQWlqQix3QkFBT0QsS0FBS0MsSUFBWjtBQUNBRCxzQkFBS0MsSUFBTCxHQUFZLEtBQUssQ0FBakI7QUFDQU0sMEJBQVNQLEtBQUtPLE1BQWQ7O0FBRUEscUJBQUlBLE1BQUosRUFBWTtBQUNSUCwwQkFBS08sTUFBTCxHQUFjLEtBQUssQ0FBbkI7QUFDQUEsNEJBQU81YixLQUFQO0FBQ0g7QUFDRDZiLDJCQUFVUCxJQUFWLEVBQWdCTSxNQUFoQjtBQUVIO0FBQ0Qsb0JBQU9GLFdBQVd4bUQsTUFBbEIsRUFBMEI7QUFDdEJvbUQsd0JBQU9JLFdBQVdyeEMsR0FBWCxFQUFQO0FBQ0F3eEMsMkJBQVVQLElBQVY7QUFDSDtBQUNEMytCLHdCQUFXLEtBQVg7QUFDSDtBQUNEO0FBQ0Esa0JBQVNrL0IsU0FBVCxDQUFtQlAsSUFBbkIsRUFBeUJNLE1BQXpCLEVBQWlDO0FBQzdCLGlCQUFJO0FBQ0FOO0FBRUgsY0FIRCxDQUdFLE9BQU85bUQsQ0FBUCxFQUFVO0FBQ1IscUJBQUlpbkQsUUFBSixFQUFjO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBSUcsTUFBSixFQUFZO0FBQ1JBLGdDQUFPRSxJQUFQO0FBQ0g7QUFDRHp6QyxnQ0FBV3N6QyxLQUFYLEVBQWtCLENBQWxCO0FBQ0EseUJBQUlDLE1BQUosRUFBWTtBQUNSQSxnQ0FBTzViLEtBQVA7QUFDSDs7QUFFRCwyQkFBTXhyQyxDQUFOO0FBRUgsa0JBakJELE1BaUJPO0FBQ0g7QUFDQTtBQUNBNlQsZ0NBQVcsWUFBWTtBQUNuQiwrQkFBTTdULENBQU47QUFDSCxzQkFGRCxFQUVHLENBRkg7QUFHSDtBQUNKOztBQUVELGlCQUFJb25ELE1BQUosRUFBWTtBQUNSQSx3QkFBT0UsSUFBUDtBQUNIO0FBQ0o7O0FBRURsMEMsb0JBQVcsa0JBQVUwekMsSUFBVixFQUFnQjtBQUN2QkMsb0JBQU9BLEtBQUtsakIsSUFBTCxHQUFZO0FBQ2ZpakIsdUJBQU1BLElBRFM7QUFFZk0seUJBQVFILFlBQVlsNUMsUUFBUXE1QyxNQUZiO0FBR2Z2akIsdUJBQU07QUFIUyxjQUFuQjs7QUFNQSxpQkFBSSxDQUFDMWIsUUFBTCxFQUFlO0FBQ1hBLDRCQUFXLElBQVg7QUFDQTYrQjtBQUNIO0FBQ0osVUFYRDs7QUFhQSxhQUFJLFFBQU9qNUMsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUNBQSxRQUFReEYsUUFBUixPQUF1QixrQkFEdkIsSUFDNkN3RixRQUFRcUYsUUFEekQsRUFDbUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBNnpDLHdCQUFXLElBQVg7O0FBRUFELDJCQUFjLHVCQUFZO0FBQ3RCajVDLHlCQUFRcUYsUUFBUixDQUFpQit6QyxLQUFqQjtBQUNILGNBRkQ7QUFJSCxVQWhCRCxNQWdCTyxJQUFJLE9BQU9JLFlBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDM0M7QUFDQSxpQkFBSSxPQUFPN2xELE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDL0JzbEQsK0JBQWNPLGFBQWEzbkQsSUFBYixDQUFrQjhCLE1BQWxCLEVBQTBCeWxELEtBQTFCLENBQWQ7QUFDSCxjQUZELE1BRU87QUFDSEgsK0JBQWMsdUJBQVk7QUFDdEJPLGtDQUFhSixLQUFiO0FBQ0gsa0JBRkQ7QUFHSDtBQUVKLFVBVk0sTUFVQSxJQUFJLE9BQU9LLGNBQVAsS0FBMEIsV0FBOUIsRUFBMkM7QUFDOUM7QUFDQTtBQUNBLGlCQUFJQyxVQUFVLElBQUlELGNBQUosRUFBZDtBQUNBO0FBQ0E7QUFDQUMscUJBQVFDLEtBQVIsQ0FBY0MsU0FBZCxHQUEwQixZQUFZO0FBQ2xDWCwrQkFBY1ksZUFBZDtBQUNBSCx5QkFBUUMsS0FBUixDQUFjQyxTQUFkLEdBQTBCUixLQUExQjtBQUNBQTtBQUNILGNBSkQ7QUFLQSxpQkFBSVMsa0JBQWtCLFNBQWxCQSxlQUFrQixHQUFZO0FBQzlCO0FBQ0E7QUFDQUgseUJBQVFJLEtBQVIsQ0FBY0MsV0FBZCxDQUEwQixDQUExQjtBQUNILGNBSkQ7QUFLQWQsMkJBQWMsdUJBQVk7QUFDdEJuekMsNEJBQVdzekMsS0FBWCxFQUFrQixDQUFsQjtBQUNBUztBQUNILGNBSEQ7QUFLSCxVQXJCTSxNQXFCQTtBQUNIO0FBQ0FaLDJCQUFjLHVCQUFZO0FBQ3RCbnpDLDRCQUFXc3pDLEtBQVgsRUFBa0IsQ0FBbEI7QUFDSCxjQUZEO0FBR0g7QUFDRDtBQUNBO0FBQ0E7QUFDQS96QyxrQkFBUzIwQyxRQUFULEdBQW9CLFVBQVVqQixJQUFWLEVBQWdCO0FBQ2hDSSx3QkFBVzcxQyxJQUFYLENBQWdCeTFDLElBQWhCO0FBQ0EsaUJBQUksQ0FBQzMrQixRQUFMLEVBQWU7QUFDWEEsNEJBQVcsSUFBWDtBQUNBNitCO0FBQ0g7QUFDSixVQU5EO0FBT0EsZ0JBQU81ekMsUUFBUDtBQUNILE1BbkphLEVBQWQ7O0FBcUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBSXJULE9BQU9GLFNBQVNFLElBQXBCO0FBQ0EsY0FBU2lvRCxXQUFULENBQXFCblcsQ0FBckIsRUFBd0I7QUFDcEIsZ0JBQU8sWUFBWTtBQUNmLG9CQUFPOXhDLEtBQUtFLEtBQUwsQ0FBVzR4QyxDQUFYLEVBQWMzeEMsU0FBZCxDQUFQO0FBQ0gsVUFGRDtBQUdIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLFNBQUkrbkQsY0FBY0QsWUFBWW44QyxNQUFNL0wsU0FBTixDQUFnQnVDLEtBQTVCLENBQWxCOztBQUVBLFNBQUk2bEQsZUFBZUYsWUFDZm44QyxNQUFNL0wsU0FBTixDQUFnQnlNLE1BQWhCLElBQTBCLFVBQVUraUIsUUFBVixFQUFvQjY0QixLQUFwQixFQUEyQjtBQUNqRCxhQUFJMWpELFFBQVEsQ0FBWjtBQUFBLGFBQ0kvRCxTQUFTLEtBQUtBLE1BRGxCO0FBRUE7QUFDQSxhQUFJUixVQUFVUSxNQUFWLEtBQXFCLENBQXpCLEVBQTRCO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBRztBQUNDLHFCQUFJK0QsU0FBUyxJQUFiLEVBQW1CO0FBQ2YwakQsNkJBQVEsS0FBSzFqRCxPQUFMLENBQVI7QUFDQTtBQUNIO0FBQ0QscUJBQUksRUFBRUEsS0FBRixJQUFXL0QsTUFBZixFQUF1QjtBQUNuQiwyQkFBTSxJQUFJeUMsU0FBSixFQUFOO0FBQ0g7QUFDSixjQVJELFFBUVMsQ0FSVDtBQVNIO0FBQ0Q7QUFDQSxnQkFBT3NCLFFBQVEvRCxNQUFmLEVBQXVCK0QsT0FBdkIsRUFBZ0M7QUFDNUI7QUFDQSxpQkFBSUEsU0FBUyxJQUFiLEVBQW1CO0FBQ2YwakQseUJBQVE3NEIsU0FBUzY0QixLQUFULEVBQWdCLEtBQUsxakQsS0FBTCxDQUFoQixFQUE2QkEsS0FBN0IsQ0FBUjtBQUNIO0FBQ0o7QUFDRCxnQkFBTzBqRCxLQUFQO0FBQ0gsTUExQmMsQ0FBbkI7O0FBNkJBLFNBQUlDLGdCQUFnQkosWUFDaEJuOEMsTUFBTS9MLFNBQU4sQ0FBZ0JxQyxPQUFoQixJQUEyQixVQUFVaUcsS0FBVixFQUFpQjtBQUN4QztBQUNBLGNBQUssSUFBSTNILElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLQyxNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDbEMsaUJBQUksS0FBS0EsQ0FBTCxNQUFZMkgsS0FBaEIsRUFBdUI7QUFDbkIsd0JBQU8zSCxDQUFQO0FBQ0g7QUFDSjtBQUNELGdCQUFPLENBQUMsQ0FBUjtBQUNILE1BVGUsQ0FBcEI7O0FBWUEsU0FBSTRuRCxZQUFZTCxZQUNabjhDLE1BQU0vTCxTQUFOLENBQWdCMkosR0FBaEIsSUFBdUIsVUFBVTZsQixRQUFWLEVBQW9CZzVCLEtBQXBCLEVBQTJCO0FBQzlDLGFBQUlubkQsT0FBTyxJQUFYO0FBQ0EsYUFBSW9uRCxVQUFVLEVBQWQ7QUFDQUwsc0JBQWEvbUQsSUFBYixFQUFtQixVQUFVZCxTQUFWLEVBQXFCK0gsS0FBckIsRUFBNEIzRCxLQUE1QixFQUFtQztBQUNsRDhqRCxxQkFBUWwzQyxJQUFSLENBQWFpZSxTQUFTdnZCLElBQVQsQ0FBY3VvRCxLQUFkLEVBQXFCbGdELEtBQXJCLEVBQTRCM0QsS0FBNUIsRUFBbUN0RCxJQUFuQyxDQUFiO0FBQ0gsVUFGRCxFQUVHLEtBQUssQ0FGUjtBQUdBLGdCQUFPb25ELE9BQVA7QUFDSCxNQVJXLENBQWhCOztBQVdBLFNBQUlDLGdCQUFnQm5oRCxPQUFPcUMsTUFBUCxJQUFpQixVQUFVNUosU0FBVixFQUFxQjtBQUN0RCxrQkFBUzJvRCxJQUFULEdBQWdCLENBQUc7QUFDbkJBLGNBQUszb0QsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxnQkFBTyxJQUFJMm9ELElBQUosRUFBUDtBQUNILE1BSkQ7O0FBTUEsU0FBSUMsd0JBQXdCcmhELE9BQU9nSSxjQUFQLElBQXlCLFVBQVU1UCxHQUFWLEVBQWU4YixJQUFmLEVBQXFCb3RDLFVBQXJCLEVBQWlDO0FBQ2xGbHBELGFBQUk4YixJQUFKLElBQVlvdEMsV0FBV3ZnRCxLQUF2QjtBQUNBLGdCQUFPM0ksR0FBUDtBQUNILE1BSEQ7O0FBS0EsU0FBSW1wRCx3QkFBd0JaLFlBQVkzZ0QsT0FBT3ZILFNBQVAsQ0FBaUJzSyxjQUE3QixDQUE1Qjs7QUFFQSxTQUFJeStDLGNBQWN4aEQsT0FBT0MsSUFBUCxJQUFlLFVBQVV3aEQsTUFBVixFQUFrQjtBQUMvQyxhQUFJeGhELE9BQU8sRUFBWDtBQUNBLGNBQUssSUFBSWdELEdBQVQsSUFBZ0J3K0MsTUFBaEIsRUFBd0I7QUFDcEIsaUJBQUlGLHNCQUFzQkUsTUFBdEIsRUFBOEJ4K0MsR0FBOUIsQ0FBSixFQUF3QztBQUNwQ2hELHNCQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNIO0FBQ0o7QUFDRCxnQkFBT2hELElBQVA7QUFDSCxNQVJEOztBQVVBLFNBQUl5aEQsa0JBQWtCZixZQUFZM2dELE9BQU92SCxTQUFQLENBQWlCeUksUUFBN0IsQ0FBdEI7O0FBRUEsY0FBU0YsUUFBVCxDQUFrQkQsS0FBbEIsRUFBeUI7QUFDckIsZ0JBQU9BLFVBQVVmLE9BQU9lLEtBQVAsQ0FBakI7QUFDSDs7QUFFRDs7QUFFQTtBQUNBLGNBQVM0Z0QsZUFBVCxDQUF5QkMsU0FBekIsRUFBb0M7QUFDaEMsZ0JBQ0lGLGdCQUFnQkUsU0FBaEIsTUFBK0Isd0JBQS9CLElBQ0FBLHFCQUFxQkMsWUFGekI7QUFJSDs7QUFFRDtBQUNBO0FBQ0EsU0FBSUEsWUFBSjtBQUNBLFNBQUksT0FBT0MsV0FBUCxLQUF1QixXQUEzQixFQUF3QztBQUNwQ0Qsd0JBQWVDLFdBQWY7QUFDSCxNQUZELE1BRU87QUFDSEQsd0JBQWUsc0JBQVU5Z0QsS0FBVixFQUFpQjtBQUM1QixrQkFBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0gsVUFGRDtBQUdIOztBQUVEOztBQUVBLFNBQUlnaEQsdUJBQXVCLHNCQUEzQjs7QUFFQSxjQUFTQyxrQkFBVCxDQUE0QjlpRCxLQUE1QixFQUFtQ1csT0FBbkMsRUFBNEM7QUFDeEM7QUFDQTtBQUNBLGFBQUl1L0MsYUFDQXYvQyxRQUFRdXZDLEtBRFIsSUFFQSxRQUFPbHdDLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFGakIsSUFHQUEsVUFBVSxJQUhWLElBSUFBLE1BQU1rd0MsS0FKVixFQUtFO0FBQ0UsaUJBQUk2UyxTQUFTLEVBQWI7QUFDQSxrQkFBSyxJQUFJMzFDLElBQUl6TSxPQUFiLEVBQXNCLENBQUMsQ0FBQ3lNLENBQXhCLEVBQTJCQSxJQUFJQSxFQUFFb1osTUFBakMsRUFBeUM7QUFDckMscUJBQUlwWixFQUFFOGlDLEtBQUYsS0FBWSxDQUFDbHdDLE1BQU1nakQsdUJBQVAsSUFBa0NoakQsTUFBTWdqRCx1QkFBTixHQUFnQzUxQyxFQUFFNjFDLFlBQWhGLENBQUosRUFBbUc7QUFDL0ZkLDJDQUFzQm5pRCxLQUF0QixFQUE2Qix5QkFBN0IsRUFBd0QsRUFBQzZCLE9BQU91TCxFQUFFNjFDLFlBQVYsRUFBd0JqNkMsY0FBYyxJQUF0QyxFQUF4RDtBQUNBKzVDLDRCQUFPbDFCLE9BQVAsQ0FBZXpnQixFQUFFOGlDLEtBQWpCO0FBQ0g7QUFDSjtBQUNENlMsb0JBQU9sMUIsT0FBUCxDQUFlN3RCLE1BQU1rd0MsS0FBckI7O0FBRUEsaUJBQUlnVCxpQkFBaUJILE9BQU8zOEMsSUFBUCxDQUFZLE9BQU95OEMsb0JBQVAsR0FBOEIsSUFBMUMsQ0FBckI7QUFDQSxpQkFBSTNTLFFBQVFpVCxrQkFBa0JELGNBQWxCLENBQVo7QUFDQWYsbUNBQXNCbmlELEtBQXRCLEVBQTZCLE9BQTdCLEVBQXNDLEVBQUM2QixPQUFPcXVDLEtBQVIsRUFBZWxuQyxjQUFjLElBQTdCLEVBQXRDO0FBQ0g7QUFDSjs7QUFFRCxjQUFTbTZDLGlCQUFULENBQTJCQyxXQUEzQixFQUF3QztBQUNwQyxhQUFJQyxRQUFRRCxZQUFZLy9DLEtBQVosQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBLGFBQUlpZ0QsZUFBZSxFQUFuQjtBQUNBLGNBQUssSUFBSXBwRCxJQUFJLENBQWIsRUFBZ0JBLElBQUltcEQsTUFBTWxwRCxNQUExQixFQUFrQyxFQUFFRCxDQUFwQyxFQUF1QztBQUNuQyxpQkFBSXFwRCxPQUFPRixNQUFNbnBELENBQU4sQ0FBWDs7QUFFQSxpQkFBSSxDQUFDc3BELGdCQUFnQkQsSUFBaEIsQ0FBRCxJQUEwQixDQUFDRSxZQUFZRixJQUFaLENBQTNCLElBQWdEQSxJQUFwRCxFQUEwRDtBQUN0REQsOEJBQWF4NEMsSUFBYixDQUFrQnk0QyxJQUFsQjtBQUNIO0FBQ0o7QUFDRCxnQkFBT0QsYUFBYWw5QyxJQUFiLENBQWtCLElBQWxCLENBQVA7QUFDSDs7QUFFRCxjQUFTcTlDLFdBQVQsQ0FBcUJDLFNBQXJCLEVBQWdDO0FBQzVCLGdCQUFPQSxVQUFVOW5ELE9BQVYsQ0FBa0IsYUFBbEIsTUFBcUMsQ0FBQyxDQUF0QyxJQUNBOG5ELFVBQVU5bkQsT0FBVixDQUFrQixXQUFsQixNQUFtQyxDQUFDLENBRDNDO0FBRUg7O0FBRUQsY0FBUytuRCx3QkFBVCxDQUFrQ0QsU0FBbEMsRUFBNkM7QUFDekM7QUFDQTtBQUNBLGFBQUlFLFdBQVcsZ0NBQWdDL25ELElBQWhDLENBQXFDNm5ELFNBQXJDLENBQWY7QUFDQSxhQUFJRSxRQUFKLEVBQWM7QUFDVixvQkFBTyxDQUFDQSxTQUFTLENBQVQsQ0FBRCxFQUFjNWUsT0FBTzRlLFNBQVMsQ0FBVCxDQUFQLENBQWQsQ0FBUDtBQUNIOztBQUVEO0FBQ0EsYUFBSUMsV0FBVyw0QkFBNEJob0QsSUFBNUIsQ0FBaUM2bkQsU0FBakMsQ0FBZjtBQUNBLGFBQUlHLFFBQUosRUFBYztBQUNWLG9CQUFPLENBQUNBLFNBQVMsQ0FBVCxDQUFELEVBQWM3ZSxPQUFPNmUsU0FBUyxDQUFULENBQVAsQ0FBZCxDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxhQUFJQyxXQUFXLGlCQUFpQmpvRCxJQUFqQixDQUFzQjZuRCxTQUF0QixDQUFmO0FBQ0EsYUFBSUksUUFBSixFQUFjO0FBQ1Ysb0JBQU8sQ0FBQ0EsU0FBUyxDQUFULENBQUQsRUFBYzllLE9BQU84ZSxTQUFTLENBQVQsQ0FBUCxDQUFkLENBQVA7QUFDSDtBQUNKOztBQUVELGNBQVNOLGVBQVQsQ0FBeUJFLFNBQXpCLEVBQW9DO0FBQ2hDLGFBQUlLLHdCQUF3QkoseUJBQXlCRCxTQUF6QixDQUE1Qjs7QUFFQSxhQUFJLENBQUNLLHFCQUFMLEVBQTRCO0FBQ3hCLG9CQUFPLEtBQVA7QUFDSDs7QUFFRCxhQUFJQyxXQUFXRCxzQkFBc0IsQ0FBdEIsQ0FBZjtBQUNBLGFBQUlFLGFBQWFGLHNCQUFzQixDQUF0QixDQUFqQjs7QUFFQSxnQkFBT0MsYUFBYTNELFNBQWIsSUFDSDRELGNBQWM5RCxhQURYLElBRUg4RCxjQUFjQyxXQUZsQjtBQUdIOztBQUVEO0FBQ0E7QUFDQSxjQUFTOUQsV0FBVCxHQUF1QjtBQUNuQixhQUFJLENBQUNGLFNBQUwsRUFBZ0I7QUFDWjtBQUNIOztBQUVELGFBQUk7QUFDQSxtQkFBTSxJQUFJaEMsS0FBSixFQUFOO0FBQ0gsVUFGRCxDQUVFLE9BQU96a0QsQ0FBUCxFQUFVO0FBQ1IsaUJBQUk0cEQsUUFBUTVwRCxFQUFFeTJDLEtBQUYsQ0FBUTdzQyxLQUFSLENBQWMsSUFBZCxDQUFaO0FBQ0EsaUJBQUk4Z0QsWUFBWWQsTUFBTSxDQUFOLEVBQVN6bkQsT0FBVCxDQUFpQixHQUFqQixJQUF3QixDQUF4QixHQUE0QnluRCxNQUFNLENBQU4sQ0FBNUIsR0FBdUNBLE1BQU0sQ0FBTixDQUF2RDtBQUNBLGlCQUFJVSx3QkFBd0JKLHlCQUF5QlEsU0FBekIsQ0FBNUI7QUFDQSxpQkFBSSxDQUFDSixxQkFBTCxFQUE0QjtBQUN4QjtBQUNIOztBQUVEMUQseUJBQVkwRCxzQkFBc0IsQ0FBdEIsQ0FBWjtBQUNBLG9CQUFPQSxzQkFBc0IsQ0FBdEIsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsY0FBU0ssU0FBVCxDQUFtQnI3QixRQUFuQixFQUE2QnR1QixJQUE3QixFQUFtQzRwRCxXQUFuQyxFQUFnRDtBQUM1QyxnQkFBTyxZQUFZO0FBQ2YsaUJBQUksT0FBT3hxRCxPQUFQLEtBQW1CLFdBQW5CLElBQ0EsT0FBT0EsUUFBUXlQLElBQWYsS0FBd0IsVUFENUIsRUFDd0M7QUFDcEN6UCx5QkFBUXlQLElBQVIsQ0FBYTdPLE9BQU8sc0JBQVAsR0FBZ0M0cEQsV0FBaEMsR0FDQSxXQURiLEVBQzBCLElBQUluRyxLQUFKLENBQVUsRUFBVixFQUFjaE8sS0FEeEM7QUFFSDtBQUNELG9CQUFPbm5CLFNBQVNydkIsS0FBVCxDQUFlcXZCLFFBQWYsRUFBeUJwdkIsU0FBekIsQ0FBUDtBQUNILFVBUEQ7QUFRSDs7QUFFRDtBQUNBOztBQUVBOzs7OztBQUtBLGNBQVNzbUQsQ0FBVCxDQUFXcCtDLEtBQVgsRUFBa0I7QUFDZDtBQUNBO0FBQ0E7QUFDQSxhQUFJQSxpQkFBaUJzTCxPQUFyQixFQUE4QjtBQUMxQixvQkFBT3RMLEtBQVA7QUFDSDs7QUFFRDtBQUNBLGFBQUl5aUQsZUFBZXppRCxLQUFmLENBQUosRUFBMkI7QUFDdkIsb0JBQU8waUQsT0FBTzFpRCxLQUFQLENBQVA7QUFDSCxVQUZELE1BRU87QUFDSCxvQkFBTzJpRCxRQUFRM2lELEtBQVIsQ0FBUDtBQUNIO0FBQ0o7QUFDRG8rQyxPQUFFei9DLE9BQUYsR0FBWXkvQyxDQUFaOztBQUVBOzs7O0FBSUFBLE9BQUVwekMsUUFBRixHQUFhQSxRQUFiOztBQUVBOzs7QUFHQW96QyxPQUFFd0UsZ0JBQUYsR0FBcUIsS0FBckI7O0FBRUE7Ozs7OztBQU1BLFNBQUlDLG1CQUFtQixDQUF2Qjs7QUFFQTtBQUNBLFNBQUksUUFBT2w5QyxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQStCQSxPQUEvQixJQUEwQ0EsUUFBUUMsR0FBbEQsSUFBeURELFFBQVFDLEdBQVIsQ0FBWWs5QyxPQUF6RSxFQUFrRjtBQUM5RTFFLFdBQUV3RSxnQkFBRixHQUFxQixJQUFyQjtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUF4RSxPQUFFNS9DLEtBQUYsR0FBVUEsS0FBVjtBQUNBLGNBQVNBLEtBQVQsR0FBaUI7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFJdWtELFdBQVcsRUFBZjtBQUFBLGFBQW1CQyxvQkFBb0IsRUFBdkM7QUFBQSxhQUEyQ0MsZUFBM0M7O0FBRUEsYUFBSUMsV0FBVzlDLGNBQWM1aEQsTUFBTTlHLFNBQXBCLENBQWY7QUFDQSxhQUFJb0gsVUFBVXNoRCxjQUFjOTBDLFFBQVE1VCxTQUF0QixDQUFkOztBQUVBb0gsaUJBQVFxa0QsZUFBUixHQUEwQixVQUFVeGtELE9BQVYsRUFBbUJ5a0QsRUFBbkIsRUFBdUJDLFFBQXZCLEVBQWlDO0FBQ3ZELGlCQUFJdjFDLE9BQU8reEMsWUFBWS9uRCxTQUFaLENBQVg7QUFDQSxpQkFBSWlyRCxRQUFKLEVBQWM7QUFDVkEsMEJBQVM5NUMsSUFBVCxDQUFjNkUsSUFBZDtBQUNBLHFCQUFJczFDLE9BQU8sTUFBUCxJQUFpQkMsU0FBUyxDQUFULENBQXJCLEVBQWtDO0FBQUU7QUFDaENMLHVDQUFrQi81QyxJQUFsQixDQUF1Qm82QyxTQUFTLENBQVQsQ0FBdkI7QUFDSDtBQUNKLGNBTEQsTUFLTztBQUNIakYsbUJBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkJpNEMscUNBQWdCRSxlQUFoQixDQUFnQ3RyRCxLQUFoQyxDQUFzQ29yRCxlQUF0QyxFQUF1RG4xQyxJQUF2RDtBQUNILGtCQUZEO0FBR0g7QUFDSixVQVpEOztBQWNBO0FBQ0FoUCxpQkFBUXdrRCxPQUFSLEdBQWtCLFlBQVk7QUFDMUIsaUJBQUlQLFFBQUosRUFBYztBQUNWLHdCQUFPamtELE9BQVA7QUFDSDtBQUNELGlCQUFJeWtELGNBQWNDLE9BQU9QLGVBQVAsQ0FBbEI7QUFDQSxpQkFBSVEsVUFBVUYsV0FBVixDQUFKLEVBQTRCO0FBQ3hCTixtQ0FBa0JNLFdBQWxCLENBRHdCLENBQ087QUFDbEM7QUFDRCxvQkFBT0EsV0FBUDtBQUNILFVBVEQ7O0FBV0F6a0QsaUJBQVE0a0QsT0FBUixHQUFrQixZQUFZO0FBQzFCLGlCQUFJLENBQUNULGVBQUwsRUFBc0I7QUFDbEIsd0JBQU8sRUFBRTFMLE9BQU8sU0FBVCxFQUFQO0FBQ0g7QUFDRCxvQkFBTzBMLGdCQUFnQlMsT0FBaEIsRUFBUDtBQUNILFVBTEQ7O0FBT0EsYUFBSXRGLEVBQUV3RSxnQkFBRixJQUFzQnZFLFNBQTFCLEVBQXFDO0FBQ2pDLGlCQUFJO0FBQ0EsdUJBQU0sSUFBSWhDLEtBQUosRUFBTjtBQUNILGNBRkQsQ0FFRSxPQUFPemtELENBQVAsRUFBVTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBa0gseUJBQVF1dkMsS0FBUixHQUFnQnoyQyxFQUFFeTJDLEtBQUYsQ0FBUXhTLFNBQVIsQ0FBa0Jqa0MsRUFBRXkyQyxLQUFGLENBQVF0MEMsT0FBUixDQUFnQixJQUFoQixJQUF3QixDQUExQyxDQUFoQjtBQUNBK0UseUJBQVFzaUQsWUFBUixHQUF1QnlCLGtCQUF2QjtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGtCQUFTYyxNQUFULENBQWdCQyxVQUFoQixFQUE0QjtBQUN4QlgsK0JBQWtCVyxVQUFsQjs7QUFFQSxpQkFBSXhGLEVBQUV3RSxnQkFBRixJQUFzQnZFLFNBQTFCLEVBQXFDO0FBQ2pDO0FBQ0E7QUFDQXYvQyx5QkFBUTZsQixNQUFSLEdBQWlCaS9CLFVBQWpCO0FBQ0g7O0FBRUQ5RCwwQkFBYWlELFFBQWIsRUFBdUIsVUFBVTlxRCxTQUFWLEVBQXFCNHJELE9BQXJCLEVBQThCO0FBQ2pEekYsbUJBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkI0NEMsZ0NBQVdULGVBQVgsQ0FBMkJ0ckQsS0FBM0IsQ0FBaUMrckQsVUFBakMsRUFBNkNDLE9BQTdDO0FBQ0gsa0JBRkQ7QUFHSCxjQUpELEVBSUcsS0FBSyxDQUpSOztBQU1BZCx3QkFBVyxLQUFLLENBQWhCO0FBQ0FDLGlDQUFvQixLQUFLLENBQXpCO0FBQ0g7O0FBRURFLGtCQUFTcGtELE9BQVQsR0FBbUJBLE9BQW5CO0FBQ0Fva0Qsa0JBQVN2a0QsT0FBVCxHQUFtQixVQUFVcUIsS0FBVixFQUFpQjtBQUNoQyxpQkFBSWlqRCxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRURVLG9CQUFPdkYsRUFBRXArQyxLQUFGLENBQVA7QUFDSCxVQU5EOztBQVFBa2pELGtCQUFTUCxPQUFULEdBQW1CLFVBQVUzaUQsS0FBVixFQUFpQjtBQUNoQyxpQkFBSWlqRCxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRURVLG9CQUFPaEIsUUFBUTNpRCxLQUFSLENBQVA7QUFDSCxVQU5EO0FBT0FrakQsa0JBQVNya0QsTUFBVCxHQUFrQixVQUFVd2IsTUFBVixFQUFrQjtBQUNoQyxpQkFBSTRvQyxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRURVLG9CQUFPOWtELE9BQU93YixNQUFQLENBQVA7QUFDSCxVQU5EO0FBT0E2b0Msa0JBQVMvMUMsTUFBVCxHQUFrQixVQUFVMjJDLFFBQVYsRUFBb0I7QUFDbEMsaUJBQUliLGVBQUosRUFBcUI7QUFDakI7QUFDSDs7QUFFRG5ELDBCQUFha0QsaUJBQWIsRUFBZ0MsVUFBVS9xRCxTQUFWLEVBQXFCOHJELGdCQUFyQixFQUF1QztBQUNuRTNGLG1CQUFFcHpDLFFBQUYsQ0FBVyxZQUFZO0FBQ25CKzRDLHNDQUFpQkQsUUFBakI7QUFDSCxrQkFGRDtBQUdILGNBSkQsRUFJRyxLQUFLLENBSlI7QUFLSCxVQVZEOztBQVlBLGdCQUFPWixRQUFQO0FBQ0g7O0FBRUQ7Ozs7O0FBS0Exa0QsV0FBTTlHLFNBQU4sQ0FBZ0Jzc0QsZ0JBQWhCLEdBQW1DLFlBQVk7QUFDM0MsYUFBSWpyRCxPQUFPLElBQVg7QUFDQSxnQkFBTyxVQUFVb0YsS0FBVixFQUFpQjZCLEtBQWpCLEVBQXdCO0FBQzNCLGlCQUFJN0IsS0FBSixFQUFXO0FBQ1BwRixzQkFBSzhGLE1BQUwsQ0FBWVYsS0FBWjtBQUNILGNBRkQsTUFFTyxJQUFJckcsVUFBVVEsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUM3QlMsc0JBQUs0RixPQUFMLENBQWFraEQsWUFBWS9uRCxTQUFaLEVBQXVCLENBQXZCLENBQWI7QUFDSCxjQUZNLE1BRUE7QUFDSGlCLHNCQUFLNEYsT0FBTCxDQUFhcUIsS0FBYjtBQUNIO0FBQ0osVUFSRDtBQVNILE1BWEQ7O0FBYUE7Ozs7OztBQU1BbytDLE9BQUU5eUMsT0FBRixHQUFZeE0sT0FBWixDQXZtQmUsQ0F1bUJNO0FBQ3JCcy9DLE9BQUV0L0MsT0FBRixHQUFZQSxPQUFaO0FBQ0EsY0FBU0EsT0FBVCxDQUFpQm1sRCxRQUFqQixFQUEyQjtBQUN2QixhQUFJLE9BQU9BLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDaEMsbUJBQU0sSUFBSWxwRCxTQUFKLENBQWMsOEJBQWQsQ0FBTjtBQUNIO0FBQ0QsYUFBSW1vRCxXQUFXMWtELE9BQWY7QUFDQSxhQUFJO0FBQ0F5bEQsc0JBQVNmLFNBQVN2a0QsT0FBbEIsRUFBMkJ1a0QsU0FBU3JrRCxNQUFwQyxFQUE0Q3FrRCxTQUFTLzFDLE1BQXJEO0FBQ0gsVUFGRCxDQUVFLE9BQU9rTixNQUFQLEVBQWU7QUFDYjZvQyxzQkFBU3JrRCxNQUFULENBQWdCd2IsTUFBaEI7QUFDSDtBQUNELGdCQUFPNm9DLFNBQVNwa0QsT0FBaEI7QUFDSDs7QUFFREEsYUFBUW9sRCxJQUFSLEdBQWVBLElBQWYsQ0F0bkJlLENBc25CTTtBQUNyQnBsRCxhQUFRNndDLEdBQVIsR0FBY0EsR0FBZCxDQXZuQmUsQ0F1bkJJO0FBQ25CN3dDLGFBQVFELE1BQVIsR0FBaUJBLE1BQWpCLENBeG5CZSxDQXduQlU7QUFDekJDLGFBQVFILE9BQVIsR0FBa0J5L0MsQ0FBbEIsQ0F6bkJlLENBeW5CTTs7QUFFckI7QUFDQTtBQUNBO0FBQ0FBLE9BQUUrRixVQUFGLEdBQWUsVUFBVXpELE1BQVYsRUFBa0I7QUFDN0I7QUFDQTtBQUNBLGdCQUFPQSxNQUFQO0FBQ0gsTUFKRDs7QUFNQXAxQyxhQUFRNVQsU0FBUixDQUFrQnlzRCxVQUFsQixHQUErQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBTyxJQUFQO0FBQ0gsTUFKRDs7QUFNQTs7Ozs7Ozs7O0FBU0EvRixPQUFFNzVDLElBQUYsR0FBUyxVQUFVNi9DLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUNyQixnQkFBT2pHLEVBQUVnRyxDQUFGLEVBQUs3L0MsSUFBTCxDQUFVOC9DLENBQVYsQ0FBUDtBQUNILE1BRkQ7O0FBSUEvNEMsYUFBUTVULFNBQVIsQ0FBa0I2TSxJQUFsQixHQUF5QixVQUFVKy9DLElBQVYsRUFBZ0I7QUFDckMsZ0JBQU9sRyxFQUFFLENBQUMsSUFBRCxFQUFPa0csSUFBUCxDQUFGLEVBQWdCQyxNQUFoQixDQUF1QixVQUFVSCxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDMUMsaUJBQUlELE1BQU1DLENBQVYsRUFBYTtBQUNUO0FBQ0Esd0JBQU9ELENBQVA7QUFDSCxjQUhELE1BR087QUFDSCx1QkFBTSxJQUFJL0gsS0FBSixDQUFVLGlDQUFpQytILENBQWpDLEdBQXFDLEdBQXJDLEdBQTJDQyxDQUFyRCxDQUFOO0FBQ0g7QUFDSixVQVBNLENBQVA7QUFRSCxNQVREOztBQVdBOzs7OztBQUtBakcsT0FBRThGLElBQUYsR0FBU0EsSUFBVDtBQUNBLGNBQVNBLElBQVQsQ0FBY00sUUFBZCxFQUF3QjtBQUNwQixnQkFBTzFsRCxRQUFRLFVBQVVILE9BQVYsRUFBbUJFLE1BQW5CLEVBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBSyxJQUFJeEcsSUFBSSxDQUFSLEVBQVcwVixNQUFNeTJDLFNBQVNsc0QsTUFBL0IsRUFBdUNELElBQUkwVixHQUEzQyxFQUFnRDFWLEdBQWhELEVBQXFEO0FBQ2pEK2xELG1CQUFFb0csU0FBU25zRCxDQUFULENBQUYsRUFBZXdGLElBQWYsQ0FBb0JjLE9BQXBCLEVBQTZCRSxNQUE3QjtBQUNIO0FBQ0osVUFUTSxDQUFQO0FBVUg7O0FBRUR5TSxhQUFRNVQsU0FBUixDQUFrQndzRCxJQUFsQixHQUF5QixZQUFZO0FBQ2pDLGdCQUFPLEtBQUtybUQsSUFBTCxDQUFVdWdELEVBQUU4RixJQUFaLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7Ozs7Ozs7OztBQVdBOUYsT0FBRXFHLFdBQUYsR0FBZ0JuNUMsT0FBaEI7QUFDQSxjQUFTQSxPQUFULENBQWlCaTFDLFVBQWpCLEVBQTZCMzRCLFFBQTdCLEVBQXVDODdCLE9BQXZDLEVBQWdEO0FBQzVDLGFBQUk5N0IsYUFBYSxLQUFLLENBQXRCLEVBQXlCO0FBQ3JCQSx3QkFBVyxrQkFBVXc3QixFQUFWLEVBQWM7QUFDckIsd0JBQU92a0QsT0FBTyxJQUFJdzlDLEtBQUosQ0FDVix5Q0FBeUMrRyxFQUQvQixDQUFQLENBQVA7QUFHSCxjQUpEO0FBS0g7QUFDRCxhQUFJTSxZQUFZLEtBQUssQ0FBckIsRUFBd0I7QUFDcEJBLHVCQUFVLG1CQUFZO0FBQ2xCLHdCQUFPLEVBQUNuTSxPQUFPLFNBQVIsRUFBUDtBQUNILGNBRkQ7QUFHSDs7QUFFRCxhQUFJejRDLFVBQVVzaEQsY0FBYzkwQyxRQUFRNVQsU0FBdEIsQ0FBZDs7QUFFQW9ILGlCQUFRcWtELGVBQVIsR0FBMEIsVUFBVXhrRCxPQUFWLEVBQW1CeWtELEVBQW5CLEVBQXVCdDFDLElBQXZCLEVBQTZCO0FBQ25ELGlCQUFJRSxNQUFKO0FBQ0EsaUJBQUk7QUFDQSxxQkFBSXV5QyxXQUFXNkMsRUFBWCxDQUFKLEVBQW9CO0FBQ2hCcDFDLDhCQUFTdXlDLFdBQVc2QyxFQUFYLEVBQWV2ckQsS0FBZixDQUFxQmlILE9BQXJCLEVBQThCZ1AsSUFBOUIsQ0FBVDtBQUNILGtCQUZELE1BRU87QUFDSEUsOEJBQVM0WixTQUFTandCLElBQVQsQ0FBY21ILE9BQWQsRUFBdUJza0QsRUFBdkIsRUFBMkJ0MUMsSUFBM0IsQ0FBVDtBQUNIO0FBQ0osY0FORCxDQU1FLE9BQU8reUMsU0FBUCxFQUFrQjtBQUNoQjd5QywwQkFBU25QLE9BQU9naUQsU0FBUCxDQUFUO0FBQ0g7QUFDRCxpQkFBSWxpRCxPQUFKLEVBQWE7QUFDVEEseUJBQVFxUCxNQUFSO0FBQ0g7QUFDSixVQWREOztBQWdCQWxQLGlCQUFRNGtELE9BQVIsR0FBa0JBLE9BQWxCOztBQUVBO0FBQ0EsYUFBSUEsT0FBSixFQUFhO0FBQ1QsaUJBQUlnQixZQUFZaEIsU0FBaEI7QUFDQSxpQkFBSWdCLFVBQVVuTixLQUFWLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2hDejRDLHlCQUFRK2hELFNBQVIsR0FBb0I2RCxVQUFVcnFDLE1BQTlCO0FBQ0g7O0FBRUR2YixxQkFBUXdrRCxPQUFSLEdBQWtCLFlBQVk7QUFDMUIscUJBQUlvQixZQUFZaEIsU0FBaEI7QUFDQSxxQkFBSWdCLFVBQVVuTixLQUFWLEtBQW9CLFNBQXBCLElBQ0FtTixVQUFVbk4sS0FBVixLQUFvQixVQUR4QixFQUNvQztBQUNoQyw0QkFBT3o0QyxPQUFQO0FBQ0g7QUFDRCx3QkFBTzRsRCxVQUFVMWtELEtBQWpCO0FBQ0gsY0FQRDtBQVFIOztBQUVELGdCQUFPbEIsT0FBUDtBQUNIOztBQUVEd00sYUFBUTVULFNBQVIsQ0FBa0J5SSxRQUFsQixHQUE2QixZQUFZO0FBQ3JDLGdCQUFPLGtCQUFQO0FBQ0gsTUFGRDs7QUFJQW1MLGFBQVE1VCxTQUFSLENBQWtCbUcsSUFBbEIsR0FBeUIsVUFBVThtRCxTQUFWLEVBQXFCQyxRQUFyQixFQUErQkMsVUFBL0IsRUFBMkM7QUFDaEUsYUFBSTlyRCxPQUFPLElBQVg7QUFDQSxhQUFJbXFELFdBQVcxa0QsT0FBZjtBQUNBLGFBQUlzbUQsT0FBTyxLQUFYLENBSGdFLENBRzVDO0FBQ0E7O0FBRXBCLGtCQUFTQyxVQUFULENBQW9CL2tELEtBQXBCLEVBQTJCO0FBQ3ZCLGlCQUFJO0FBQ0Esd0JBQU8sT0FBTzJrRCxTQUFQLEtBQXFCLFVBQXJCLEdBQWtDQSxVQUFVM2tELEtBQVYsQ0FBbEMsR0FBcURBLEtBQTVEO0FBQ0gsY0FGRCxDQUVFLE9BQU82Z0QsU0FBUCxFQUFrQjtBQUNoQix3QkFBT2hpRCxPQUFPZ2lELFNBQVAsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsa0JBQVNtRSxTQUFULENBQW1CbkUsU0FBbkIsRUFBOEI7QUFDMUIsaUJBQUksT0FBTytELFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDaEMzRCxvQ0FBbUJKLFNBQW5CLEVBQThCOW5ELElBQTlCO0FBQ0EscUJBQUk7QUFDQSw0QkFBTzZyRCxTQUFTL0QsU0FBVCxDQUFQO0FBQ0gsa0JBRkQsQ0FFRSxPQUFPb0UsWUFBUCxFQUFxQjtBQUNuQiw0QkFBT3BtRCxPQUFPb21ELFlBQVAsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxvQkFBT3BtRCxPQUFPZ2lELFNBQVAsQ0FBUDtBQUNIOztBQUVELGtCQUFTcUUsV0FBVCxDQUFxQmxsRCxLQUFyQixFQUE0QjtBQUN4QixvQkFBTyxPQUFPNmtELFVBQVAsS0FBc0IsVUFBdEIsR0FBbUNBLFdBQVc3a0QsS0FBWCxDQUFuQyxHQUF1REEsS0FBOUQ7QUFDSDs7QUFFRG8rQyxXQUFFcHpDLFFBQUYsQ0FBVyxZQUFZO0FBQ25CalMsa0JBQUtvcUQsZUFBTCxDQUFxQixVQUFVbmpELEtBQVYsRUFBaUI7QUFDbEMscUJBQUk4a0QsSUFBSixFQUFVO0FBQ047QUFDSDtBQUNEQSx3QkFBTyxJQUFQOztBQUVBNUIsMEJBQVN2a0QsT0FBVCxDQUFpQm9tRCxXQUFXL2tELEtBQVgsQ0FBakI7QUFDSCxjQVBELEVBT0csTUFQSCxFQU9XLENBQUMsVUFBVTZnRCxTQUFWLEVBQXFCO0FBQzdCLHFCQUFJaUUsSUFBSixFQUFVO0FBQ047QUFDSDtBQUNEQSx3QkFBTyxJQUFQOztBQUVBNUIsMEJBQVN2a0QsT0FBVCxDQUFpQnFtRCxVQUFVbkUsU0FBVixDQUFqQjtBQUNILGNBUFUsQ0FQWDtBQWVILFVBaEJEOztBQWtCQTtBQUNBOW5ELGNBQUtvcUQsZUFBTCxDQUFxQixLQUFLLENBQTFCLEVBQTZCLE1BQTdCLEVBQXFDLENBQUMsS0FBSyxDQUFOLEVBQVMsVUFBVW5qRCxLQUFWLEVBQWlCO0FBQzNELGlCQUFJbWxELFFBQUo7QUFDQSxpQkFBSUMsUUFBUSxLQUFaO0FBQ0EsaUJBQUk7QUFDQUQsNEJBQVdELFlBQVlsbEQsS0FBWixDQUFYO0FBQ0gsY0FGRCxDQUVFLE9BQU9wSSxDQUFQLEVBQVU7QUFDUnd0RCx5QkFBUSxJQUFSO0FBQ0EscUJBQUloSCxFQUFFaUgsT0FBTixFQUFlO0FBQ1hqSCx1QkFBRWlILE9BQUYsQ0FBVXp0RCxDQUFWO0FBQ0gsa0JBRkQsTUFFTztBQUNILDJCQUFNQSxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxpQkFBSSxDQUFDd3RELEtBQUwsRUFBWTtBQUNSbEMsMEJBQVMvMUMsTUFBVCxDQUFnQmc0QyxRQUFoQjtBQUNIO0FBQ0osVUFqQm9DLENBQXJDOztBQW1CQSxnQkFBT2pDLFNBQVNwa0QsT0FBaEI7QUFDSCxNQXJFRDs7QUF1RUFzL0MsT0FBRWtILEdBQUYsR0FBUSxVQUFVeG1ELE9BQVYsRUFBbUJvb0IsUUFBbkIsRUFBNkI7QUFDakMsZ0JBQU9rM0IsRUFBRXQvQyxPQUFGLEVBQVd3bUQsR0FBWCxDQUFlcCtCLFFBQWYsQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7Ozs7Ozs7OztBQVlBNWIsYUFBUTVULFNBQVIsQ0FBa0I0dEQsR0FBbEIsR0FBd0IsVUFBVXArQixRQUFWLEVBQW9CO0FBQ3hDQSxvQkFBV2szQixFQUFFbDNCLFFBQUYsQ0FBWDs7QUFFQSxnQkFBTyxLQUFLcnBCLElBQUwsQ0FBVSxVQUFVbUMsS0FBVixFQUFpQjtBQUM5QixvQkFBT2tuQixTQUFTcStCLEtBQVQsQ0FBZXZsRCxLQUFmLEVBQXNCd2xELFdBQXRCLENBQWtDeGxELEtBQWxDLENBQVA7QUFDSCxVQUZNLENBQVA7QUFHSCxNQU5EOztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBbytDLE9BQUVxSCxJQUFGLEdBQVNBLElBQVQ7QUFDQSxjQUFTQSxJQUFULENBQWN6bEQsS0FBZCxFQUFxQjJrRCxTQUFyQixFQUFnQ0MsUUFBaEMsRUFBMENDLFVBQTFDLEVBQXNEO0FBQ2xELGdCQUFPekcsRUFBRXArQyxLQUFGLEVBQVNuQyxJQUFULENBQWM4bUQsU0FBZCxFQUF5QkMsUUFBekIsRUFBbUNDLFVBQW5DLENBQVA7QUFDSDs7QUFFRHY1QyxhQUFRNVQsU0FBUixDQUFrQjh0RCxXQUFsQixHQUFnQyxVQUFVeGxELEtBQVYsRUFBaUI7QUFDN0MsZ0JBQU8sS0FBS25DLElBQUwsQ0FBVSxZQUFZO0FBQUUsb0JBQU9tQyxLQUFQO0FBQWUsVUFBdkMsQ0FBUDtBQUNILE1BRkQ7O0FBSUFvK0MsT0FBRW9ILFdBQUYsR0FBZ0IsVUFBVTFtRCxPQUFWLEVBQW1Ca0IsS0FBbkIsRUFBMEI7QUFDdEMsZ0JBQU9vK0MsRUFBRXQvQyxPQUFGLEVBQVcwbUQsV0FBWCxDQUF1QnhsRCxLQUF2QixDQUFQO0FBQ0gsTUFGRDs7QUFJQXNMLGFBQVE1VCxTQUFSLENBQWtCZ3VELFVBQWxCLEdBQStCLFVBQVVyckMsTUFBVixFQUFrQjtBQUM3QyxnQkFBTyxLQUFLeGMsSUFBTCxDQUFVLFlBQVk7QUFBRSxtQkFBTXdjLE1BQU47QUFBZSxVQUF2QyxDQUFQO0FBQ0gsTUFGRDs7QUFJQStqQyxPQUFFc0gsVUFBRixHQUFlLFVBQVU1bUQsT0FBVixFQUFtQnViLE1BQW5CLEVBQTJCO0FBQ3RDLGdCQUFPK2pDLEVBQUV0L0MsT0FBRixFQUFXNG1ELFVBQVgsQ0FBc0JyckMsTUFBdEIsQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBK2pDLE9BQUVvRixNQUFGLEdBQVdBLE1BQVg7QUFDQSxjQUFTQSxNQUFULENBQWdCeGpELEtBQWhCLEVBQXVCO0FBQ25CLGFBQUl5akQsVUFBVXpqRCxLQUFWLENBQUosRUFBc0I7QUFDbEIsaUJBQUkwa0QsWUFBWTFrRCxNQUFNMGpELE9BQU4sRUFBaEI7QUFDQSxpQkFBSWdCLFVBQVVuTixLQUFWLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ2pDLHdCQUFPbU4sVUFBVTFrRCxLQUFqQjtBQUNIO0FBQ0o7QUFDRCxnQkFBT0EsS0FBUDtBQUNIOztBQUVEOzs7O0FBSUFvK0MsT0FBRXFGLFNBQUYsR0FBY0EsU0FBZDtBQUNBLGNBQVNBLFNBQVQsQ0FBbUIvQyxNQUFuQixFQUEyQjtBQUN2QixnQkFBT0Esa0JBQWtCcDFDLE9BQXpCO0FBQ0g7O0FBRUQ4eUMsT0FBRXFFLGNBQUYsR0FBbUJBLGNBQW5CO0FBQ0EsY0FBU0EsY0FBVCxDQUF3Qi9CLE1BQXhCLEVBQWdDO0FBQzVCLGdCQUFPemdELFNBQVN5Z0QsTUFBVCxLQUFvQixPQUFPQSxPQUFPN2lELElBQWQsS0FBdUIsVUFBbEQ7QUFDSDs7QUFFRDs7OztBQUlBdWdELE9BQUV1SCxTQUFGLEdBQWNBLFNBQWQ7QUFDQSxjQUFTQSxTQUFULENBQW1CakYsTUFBbkIsRUFBMkI7QUFDdkIsZ0JBQU8rQyxVQUFVL0MsTUFBVixLQUFxQkEsT0FBT2dELE9BQVAsR0FBaUJuTSxLQUFqQixLQUEyQixTQUF2RDtBQUNIOztBQUVEanNDLGFBQVE1VCxTQUFSLENBQWtCaXVELFNBQWxCLEdBQThCLFlBQVk7QUFDdEMsZ0JBQU8sS0FBS2pDLE9BQUwsR0FBZW5NLEtBQWYsS0FBeUIsU0FBaEM7QUFDSCxNQUZEOztBQUlBOzs7O0FBSUE2RyxPQUFFd0gsV0FBRixHQUFnQkEsV0FBaEI7QUFDQSxjQUFTQSxXQUFULENBQXFCbEYsTUFBckIsRUFBNkI7QUFDekIsZ0JBQU8sQ0FBQytDLFVBQVUvQyxNQUFWLENBQUQsSUFBc0JBLE9BQU9nRCxPQUFQLEdBQWlCbk0sS0FBakIsS0FBMkIsV0FBeEQ7QUFDSDs7QUFFRGpzQyxhQUFRNVQsU0FBUixDQUFrQmt1RCxXQUFsQixHQUFnQyxZQUFZO0FBQ3hDLGdCQUFPLEtBQUtsQyxPQUFMLEdBQWVuTSxLQUFmLEtBQXlCLFdBQWhDO0FBQ0gsTUFGRDs7QUFJQTs7O0FBR0E2RyxPQUFFeUgsVUFBRixHQUFlQSxVQUFmO0FBQ0EsY0FBU0EsVUFBVCxDQUFvQm5GLE1BQXBCLEVBQTRCO0FBQ3hCLGdCQUFPK0MsVUFBVS9DLE1BQVYsS0FBcUJBLE9BQU9nRCxPQUFQLEdBQWlCbk0sS0FBakIsS0FBMkIsVUFBdkQ7QUFDSDs7QUFFRGpzQyxhQUFRNVQsU0FBUixDQUFrQm11RCxVQUFsQixHQUErQixZQUFZO0FBQ3ZDLGdCQUFPLEtBQUtuQyxPQUFMLEdBQWVuTSxLQUFmLEtBQXlCLFVBQWhDO0FBQ0gsTUFGRDs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUl1TyxtQkFBbUIsRUFBdkI7QUFDQSxTQUFJQyxzQkFBc0IsRUFBMUI7QUFDQSxTQUFJQyw4QkFBOEIsRUFBbEM7QUFDQSxTQUFJQywyQkFBMkIsSUFBL0I7O0FBRUEsY0FBU0Msd0JBQVQsR0FBb0M7QUFDaENKLDBCQUFpQnh0RCxNQUFqQixHQUEwQixDQUExQjtBQUNBeXRELDZCQUFvQnp0RCxNQUFwQixHQUE2QixDQUE3Qjs7QUFFQSxhQUFJLENBQUMydEQsd0JBQUwsRUFBK0I7QUFDM0JBLHdDQUEyQixJQUEzQjtBQUNIO0FBQ0o7O0FBRUQsY0FBU0UsY0FBVCxDQUF3QnJuRCxPQUF4QixFQUFpQ3ViLE1BQWpDLEVBQXlDO0FBQ3JDLGFBQUksQ0FBQzRyQyx3QkFBTCxFQUErQjtBQUMzQjtBQUNIO0FBQ0QsYUFBSSxRQUFPdGdELE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsT0FBT0EsUUFBUWdiLElBQWYsS0FBd0IsVUFBM0QsRUFBdUU7QUFDbkV5OUIsZUFBRXB6QyxRQUFGLENBQVcyMEMsUUFBWCxDQUFvQixZQUFZO0FBQzVCLHFCQUFJSyxjQUFjK0YsbUJBQWQsRUFBbUNqbkQsT0FBbkMsTUFBZ0QsQ0FBQyxDQUFyRCxFQUF3RDtBQUNwRDZHLDZCQUFRZ2IsSUFBUixDQUFhLG9CQUFiLEVBQW1DdEcsTUFBbkMsRUFBMkN2YixPQUEzQztBQUNBa25ELGlEQUE0Qi84QyxJQUE1QixDQUFpQ25LLE9BQWpDO0FBQ0g7QUFDSixjQUxEO0FBTUg7O0FBRURpbkQsNkJBQW9COThDLElBQXBCLENBQXlCbkssT0FBekI7QUFDQSxhQUFJdWIsVUFBVSxPQUFPQSxPQUFPZzBCLEtBQWQsS0FBd0IsV0FBdEMsRUFBbUQ7QUFDL0N5WCw4QkFBaUI3OEMsSUFBakIsQ0FBc0JvUixPQUFPZzBCLEtBQTdCO0FBQ0gsVUFGRCxNQUVPO0FBQ0h5WCw4QkFBaUI3OEMsSUFBakIsQ0FBc0IsZ0JBQWdCb1IsTUFBdEM7QUFDSDtBQUNKOztBQUVELGNBQVMrckMsZ0JBQVQsQ0FBMEJ0bkQsT0FBMUIsRUFBbUM7QUFDL0IsYUFBSSxDQUFDbW5ELHdCQUFMLEVBQStCO0FBQzNCO0FBQ0g7O0FBRUQsYUFBSUksS0FBS3JHLGNBQWMrRixtQkFBZCxFQUFtQ2puRCxPQUFuQyxDQUFUO0FBQ0EsYUFBSXVuRCxPQUFPLENBQUMsQ0FBWixFQUFlO0FBQ1gsaUJBQUksUUFBTzFnRCxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQStCLE9BQU9BLFFBQVFnYixJQUFmLEtBQXdCLFVBQTNELEVBQXVFO0FBQ25FeTlCLG1CQUFFcHpDLFFBQUYsQ0FBVzIwQyxRQUFYLENBQW9CLFlBQVk7QUFDNUIseUJBQUkyRyxXQUFXdEcsY0FBY2dHLDJCQUFkLEVBQTJDbG5ELE9BQTNDLENBQWY7QUFDQSx5QkFBSXduRCxhQUFhLENBQUMsQ0FBbEIsRUFBcUI7QUFDakIzZ0QsaUNBQVFnYixJQUFSLENBQWEsa0JBQWIsRUFBaUNtbEMsaUJBQWlCTyxFQUFqQixDQUFqQyxFQUF1RHZuRCxPQUF2RDtBQUNBa25ELHFEQUE0QmprRCxNQUE1QixDQUFtQ3VrRCxRQUFuQyxFQUE2QyxDQUE3QztBQUNIO0FBQ0osa0JBTkQ7QUFPSDtBQUNEUCxpQ0FBb0Joa0QsTUFBcEIsQ0FBMkJza0QsRUFBM0IsRUFBK0IsQ0FBL0I7QUFDQVAsOEJBQWlCL2pELE1BQWpCLENBQXdCc2tELEVBQXhCLEVBQTRCLENBQTVCO0FBQ0g7QUFDSjs7QUFFRGpJLE9BQUU4SCx3QkFBRixHQUE2QkEsd0JBQTdCOztBQUVBOUgsT0FBRW1JLG1CQUFGLEdBQXdCLFlBQVk7QUFDaEM7QUFDQSxnQkFBT1QsaUJBQWlCN3JELEtBQWpCLEVBQVA7QUFDSCxNQUhEOztBQUtBbWtELE9BQUVvSSw4QkFBRixHQUFtQyxZQUFZO0FBQzNDTjtBQUNBRCxvQ0FBMkIsS0FBM0I7QUFDSCxNQUhEOztBQUtBQzs7QUFFQTs7QUFFQTs7OztBQUlBOUgsT0FBRXYvQyxNQUFGLEdBQVdBLE1BQVg7QUFDQSxjQUFTQSxNQUFULENBQWdCd2IsTUFBaEIsRUFBd0I7QUFDcEIsYUFBSW9zQyxZQUFZbjdDLFFBQVE7QUFDcEIscUJBQVEsY0FBVXM1QyxRQUFWLEVBQW9CO0FBQ3hCO0FBQ0EscUJBQUlBLFFBQUosRUFBYztBQUNWd0Isc0NBQWlCLElBQWpCO0FBQ0g7QUFDRCx3QkFBT3hCLFdBQVdBLFNBQVN2cUMsTUFBVCxDQUFYLEdBQThCLElBQXJDO0FBQ0g7QUFQbUIsVUFBUixFQVFiLFNBQVN1TixRQUFULEdBQW9CO0FBQ25CLG9CQUFPLElBQVA7QUFDSCxVQVZlLEVBVWIsU0FBUzg3QixPQUFULEdBQW1CO0FBQ2xCLG9CQUFPLEVBQUVuTSxPQUFPLFVBQVQsRUFBcUJsOUIsUUFBUUEsTUFBN0IsRUFBUDtBQUNILFVBWmUsQ0FBaEI7O0FBY0E7QUFDQThyQyx3QkFBZU0sU0FBZixFQUEwQnBzQyxNQUExQjs7QUFFQSxnQkFBT29zQyxTQUFQO0FBQ0g7O0FBRUQ7Ozs7QUFJQXJJLE9BQUV1RSxPQUFGLEdBQVlBLE9BQVo7QUFDQSxjQUFTQSxPQUFULENBQWlCM2lELEtBQWpCLEVBQXdCO0FBQ3BCLGdCQUFPc0wsUUFBUTtBQUNYLHFCQUFRLGdCQUFZO0FBQ2hCLHdCQUFPdEwsS0FBUDtBQUNILGNBSFU7QUFJWCxvQkFBTyxhQUFVcEgsSUFBVixFQUFnQjtBQUNuQix3QkFBT29ILE1BQU1wSCxJQUFOLENBQVA7QUFDSCxjQU5VO0FBT1gsb0JBQU8sYUFBVUEsSUFBVixFQUFnQjh0RCxHQUFoQixFQUFxQjtBQUN4QjFtRCx1QkFBTXBILElBQU4sSUFBYzh0RCxHQUFkO0FBQ0gsY0FUVTtBQVVYLHVCQUFVLGlCQUFVOXRELElBQVYsRUFBZ0I7QUFDdEIsd0JBQU9vSCxNQUFNcEgsSUFBTixDQUFQO0FBQ0gsY0FaVTtBQWFYLHFCQUFRLGNBQVVBLElBQVYsRUFBZ0JrVixJQUFoQixFQUFzQjtBQUMxQjtBQUNBO0FBQ0EscUJBQUlsVixTQUFTLElBQVQsSUFBaUJBLFNBQVMsS0FBSyxDQUFuQyxFQUFzQztBQUNsQyw0QkFBT29ILE1BQU1uSSxLQUFOLENBQVksS0FBSyxDQUFqQixFQUFvQmlXLElBQXBCLENBQVA7QUFDSCxrQkFGRCxNQUVPO0FBQ0gsNEJBQU85TixNQUFNcEgsSUFBTixFQUFZZixLQUFaLENBQWtCbUksS0FBbEIsRUFBeUI4TixJQUF6QixDQUFQO0FBQ0g7QUFDSixjQXJCVTtBQXNCWCxzQkFBUyxlQUFVb3lDLEtBQVYsRUFBaUJweUMsSUFBakIsRUFBdUI7QUFDNUIsd0JBQU85TixNQUFNbkksS0FBTixDQUFZcW9ELEtBQVosRUFBbUJweUMsSUFBbkIsQ0FBUDtBQUNILGNBeEJVO0FBeUJYLHFCQUFRLGdCQUFZO0FBQ2hCLHdCQUFPMnlDLFlBQVl6Z0QsS0FBWixDQUFQO0FBQ0g7QUEzQlUsVUFBUixFQTRCSixLQUFLLENBNUJELEVBNEJJLFNBQVMwakQsT0FBVCxHQUFtQjtBQUMxQixvQkFBTyxFQUFFbk0sT0FBTyxXQUFULEVBQXNCdjNDLE9BQU9BLEtBQTdCLEVBQVA7QUFDSCxVQTlCTSxDQUFQO0FBK0JIOztBQUVEOzs7OztBQUtBLGNBQVMwaUQsTUFBVCxDQUFnQjVqRCxPQUFoQixFQUF5QjtBQUNyQixhQUFJb2tELFdBQVcxa0QsT0FBZjtBQUNBNC9DLFdBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkIsaUJBQUk7QUFDQWxNLHlCQUFRakIsSUFBUixDQUFhcWxELFNBQVN2a0QsT0FBdEIsRUFBK0J1a0QsU0FBU3JrRCxNQUF4QyxFQUFnRHFrRCxTQUFTLzFDLE1BQXpEO0FBQ0gsY0FGRCxDQUVFLE9BQU8wekMsU0FBUCxFQUFrQjtBQUNoQnFDLDBCQUFTcmtELE1BQVQsQ0FBZ0JnaUQsU0FBaEI7QUFDSDtBQUNKLFVBTkQ7QUFPQSxnQkFBT3FDLFNBQVNwa0QsT0FBaEI7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0FzL0MsT0FBRXVJLE1BQUYsR0FBV0EsTUFBWDtBQUNBLGNBQVNBLE1BQVQsQ0FBZ0JqRyxNQUFoQixFQUF3QjtBQUNwQixnQkFBT3AxQyxRQUFRO0FBQ1gsc0JBQVMsaUJBQVksQ0FBRTtBQURaLFVBQVIsRUFFSixTQUFTc2MsUUFBVCxDQUFrQnc3QixFQUFsQixFQUFzQnQxQyxJQUF0QixFQUE0QjtBQUMzQixvQkFBTzg0QyxTQUFTbEcsTUFBVCxFQUFpQjBDLEVBQWpCLEVBQXFCdDFDLElBQXJCLENBQVA7QUFDSCxVQUpNLEVBSUosWUFBWTtBQUNYLG9CQUFPc3dDLEVBQUVzQyxNQUFGLEVBQVVnRCxPQUFWLEVBQVA7QUFDSCxVQU5NLENBQVA7QUFPSDs7QUFFRDs7Ozs7Ozs7OztBQVVBdEYsT0FBRW1HLE1BQUYsR0FBV0EsTUFBWDtBQUNBLGNBQVNBLE1BQVQsQ0FBZ0J2a0QsS0FBaEIsRUFBdUIya0QsU0FBdkIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQ3hDLGdCQUFPeEcsRUFBRXArQyxLQUFGLEVBQVN1a0QsTUFBVCxDQUFnQkksU0FBaEIsRUFBMkJDLFFBQTNCLENBQVA7QUFDSDs7QUFFRHQ1QyxhQUFRNVQsU0FBUixDQUFrQjZzRCxNQUFsQixHQUEyQixVQUFVSSxTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtBQUN0RCxnQkFBTyxLQUFLalYsR0FBTCxHQUFXOXhDLElBQVgsQ0FBZ0IsVUFBVXEvQyxLQUFWLEVBQWlCO0FBQ3BDLG9CQUFPeUgsVUFBVTlzRCxLQUFWLENBQWdCLEtBQUssQ0FBckIsRUFBd0JxbEQsS0FBeEIsQ0FBUDtBQUNILFVBRk0sRUFFSjBILFFBRkksQ0FBUDtBQUdILE1BSkQ7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBeEcsT0FBRXlJLEtBQUYsR0FBVUEsS0FBVjtBQUNBLGNBQVNBLEtBQVQsQ0FBZUMsYUFBZixFQUE4QjtBQUMxQixnQkFBTyxZQUFZO0FBQ2Y7QUFDQTtBQUNBLHNCQUFTQyxTQUFULENBQW1CQyxJQUFuQixFQUF5QnJ0QixHQUF6QixFQUE4QjtBQUMxQixxQkFBSTNyQixNQUFKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFJLE9BQU9pNUMsYUFBUCxLQUF5QixXQUE3QixFQUEwQztBQUN0QztBQUNBLHlCQUFJO0FBQ0FqNUMsa0NBQVNrNUMsVUFBVUYsSUFBVixFQUFnQnJ0QixHQUFoQixDQUFUO0FBQ0gsc0JBRkQsQ0FFRSxPQUFPa25CLFNBQVAsRUFBa0I7QUFDaEIsZ0NBQU9oaUQsT0FBT2dpRCxTQUFQLENBQVA7QUFDSDtBQUNELHlCQUFJN3lDLE9BQU84MkMsSUFBWCxFQUFpQjtBQUNiLGdDQUFPMUcsRUFBRXB3QyxPQUFPaE8sS0FBVCxDQUFQO0FBQ0gsc0JBRkQsTUFFTztBQUNILGdDQUFPeWxELEtBQUt6M0MsT0FBT2hPLEtBQVosRUFBbUJrbkIsUUFBbkIsRUFBNkJpZ0MsT0FBN0IsQ0FBUDtBQUNIO0FBQ0osa0JBWkQsTUFZTztBQUNIO0FBQ0E7QUFDQSx5QkFBSTtBQUNBbjVDLGtDQUFTazVDLFVBQVVGLElBQVYsRUFBZ0JydEIsR0FBaEIsQ0FBVDtBQUNILHNCQUZELENBRUUsT0FBT2tuQixTQUFQLEVBQWtCO0FBQ2hCLDZCQUFJRCxnQkFBZ0JDLFNBQWhCLENBQUosRUFBZ0M7QUFDNUIsb0NBQU96QyxFQUFFeUMsVUFBVTdnRCxLQUFaLENBQVA7QUFDSCwwQkFGRCxNQUVPO0FBQ0gsb0NBQU9uQixPQUFPZ2lELFNBQVAsQ0FBUDtBQUNIO0FBQ0o7QUFDRCw0QkFBTzRFLEtBQUt6M0MsTUFBTCxFQUFha1osUUFBYixFQUF1QmlnQyxPQUF2QixDQUFQO0FBQ0g7QUFDSjtBQUNELGlCQUFJRCxZQUFZSixjQUFjanZELEtBQWQsQ0FBb0IsSUFBcEIsRUFBMEJDLFNBQTFCLENBQWhCO0FBQ0EsaUJBQUlvdkIsV0FBVzYvQixVQUFVdnZELElBQVYsQ0FBZXV2RCxTQUFmLEVBQTBCLE1BQTFCLENBQWY7QUFDQSxpQkFBSUksVUFBVUosVUFBVXZ2RCxJQUFWLENBQWV1dkQsU0FBZixFQUEwQixPQUExQixDQUFkO0FBQ0Esb0JBQU83L0IsVUFBUDtBQUNILFVBN0NEO0FBOENIOztBQUVEOzs7Ozs7O0FBT0FrM0IsT0FBRWdKLEtBQUYsR0FBVUEsS0FBVjtBQUNBLGNBQVNBLEtBQVQsQ0FBZU4sYUFBZixFQUE4QjtBQUMxQjFJLFdBQUUwRyxJQUFGLENBQU8xRyxFQUFFeUksS0FBRixDQUFRQyxhQUFSLEdBQVA7QUFDSDs7QUFFRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkExSSxPQUFFLFFBQUYsSUFBY2lKLE9BQWQ7QUFDQSxjQUFTQSxPQUFULENBQWlCcm5ELEtBQWpCLEVBQXdCO0FBQ3BCLGVBQU0sSUFBSThnRCxZQUFKLENBQWlCOWdELEtBQWpCLENBQU47QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBZUFvK0MsT0FBRWtKLFFBQUYsR0FBYUEsUUFBYjtBQUNBLGNBQVNBLFFBQVQsQ0FBa0JwZ0MsUUFBbEIsRUFBNEI7QUFDeEIsZ0JBQU8sWUFBWTtBQUNmLG9CQUFPcTlCLE9BQU8sQ0FBQyxJQUFELEVBQU81VSxJQUFJNzNDLFNBQUosQ0FBUCxDQUFQLEVBQStCLFVBQVVpQixJQUFWLEVBQWdCK1UsSUFBaEIsRUFBc0I7QUFDeEQsd0JBQU9vWixTQUFTcnZCLEtBQVQsQ0FBZWtCLElBQWYsRUFBcUIrVSxJQUFyQixDQUFQO0FBQ0gsY0FGTSxDQUFQO0FBR0gsVUFKRDtBQUtIOztBQUVEOzs7Ozs7O0FBT0Fzd0MsT0FBRXdJLFFBQUYsR0FBYUEsUUFBYjtBQUNBLGNBQVNBLFFBQVQsQ0FBa0JsRyxNQUFsQixFQUEwQjBDLEVBQTFCLEVBQThCdDFDLElBQTlCLEVBQW9DO0FBQ2hDLGdCQUFPc3dDLEVBQUVzQyxNQUFGLEVBQVVrRyxRQUFWLENBQW1CeEQsRUFBbkIsRUFBdUJ0MUMsSUFBdkIsQ0FBUDtBQUNIOztBQUVEeEMsYUFBUTVULFNBQVIsQ0FBa0JrdkQsUUFBbEIsR0FBNkIsVUFBVXhELEVBQVYsRUFBY3QxQyxJQUFkLEVBQW9CO0FBQzdDLGFBQUkvVSxPQUFPLElBQVg7QUFDQSxhQUFJbXFELFdBQVcxa0QsT0FBZjtBQUNBNC9DLFdBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkJqUyxrQkFBS29xRCxlQUFMLENBQXFCRCxTQUFTdmtELE9BQTlCLEVBQXVDeWtELEVBQXZDLEVBQTJDdDFDLElBQTNDO0FBQ0gsVUFGRDtBQUdBLGdCQUFPbzFDLFNBQVNwa0QsT0FBaEI7QUFDSCxNQVBEOztBQVNBOzs7Ozs7QUFNQXMvQyxPQUFFajBDLEdBQUYsR0FBUSxVQUFVdTJDLE1BQVYsRUFBa0J4K0MsR0FBbEIsRUFBdUI7QUFDM0IsZ0JBQU9rOEMsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsS0FBbkIsRUFBMEIsQ0FBQzFrRCxHQUFELENBQTFCLENBQVA7QUFDSCxNQUZEOztBQUlBb0osYUFBUTVULFNBQVIsQ0FBa0J5UyxHQUFsQixHQUF3QixVQUFVakksR0FBVixFQUFlO0FBQ25DLGdCQUFPLEtBQUswa0QsUUFBTCxDQUFjLEtBQWQsRUFBcUIsQ0FBQzFrRCxHQUFELENBQXJCLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7Ozs7O0FBT0FrOEMsT0FBRTl4QyxHQUFGLEdBQVEsVUFBVW8wQyxNQUFWLEVBQWtCeCtDLEdBQWxCLEVBQXVCbEMsS0FBdkIsRUFBOEI7QUFDbEMsZ0JBQU9vK0MsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsS0FBbkIsRUFBMEIsQ0FBQzFrRCxHQUFELEVBQU1sQyxLQUFOLENBQTFCLENBQVA7QUFDSCxNQUZEOztBQUlBc0wsYUFBUTVULFNBQVIsQ0FBa0I0VSxHQUFsQixHQUF3QixVQUFVcEssR0FBVixFQUFlbEMsS0FBZixFQUFzQjtBQUMxQyxnQkFBTyxLQUFLNG1ELFFBQUwsQ0FBYyxLQUFkLEVBQXFCLENBQUMxa0QsR0FBRCxFQUFNbEMsS0FBTixDQUFyQixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7Ozs7O0FBTUFvK0MsT0FBRWx1QyxHQUFGLEdBQVE7QUFDUmt1QyxPQUFFLFFBQUYsSUFBYyxVQUFVc0MsTUFBVixFQUFrQngrQyxHQUFsQixFQUF1QjtBQUNqQyxnQkFBT2s4QyxFQUFFc0MsTUFBRixFQUFVa0csUUFBVixDQUFtQixRQUFuQixFQUE2QixDQUFDMWtELEdBQUQsQ0FBN0IsQ0FBUDtBQUNILE1BSEQ7O0FBS0FvSixhQUFRNVQsU0FBUixDQUFrQndZLEdBQWxCLEdBQXdCO0FBQ3hCNUUsYUFBUTVULFNBQVIsQ0FBa0IsUUFBbEIsSUFBOEIsVUFBVXdLLEdBQVYsRUFBZTtBQUN6QyxnQkFBTyxLQUFLMGtELFFBQUwsQ0FBYyxRQUFkLEVBQXdCLENBQUMxa0QsR0FBRCxDQUF4QixDQUFQO0FBQ0gsTUFIRDs7QUFLQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQWs4QyxPQUFFbUosTUFBRixHQUFXO0FBQ1huSixPQUFFb0osSUFBRixHQUFTLFVBQVU5RyxNQUFWLEVBQWtCOW5ELElBQWxCLEVBQXdCa1YsSUFBeEIsRUFBOEI7QUFDbkMsZ0JBQU9zd0MsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsTUFBbkIsRUFBMkIsQ0FBQ2h1RCxJQUFELEVBQU9rVixJQUFQLENBQTNCLENBQVA7QUFDSCxNQUhEOztBQUtBeEMsYUFBUTVULFNBQVIsQ0FBa0I2dkQsTUFBbEIsR0FBMkI7QUFDM0JqOEMsYUFBUTVULFNBQVIsQ0FBa0I4dkQsSUFBbEIsR0FBeUIsVUFBVTV1RCxJQUFWLEVBQWdCa1YsSUFBaEIsRUFBc0I7QUFDM0MsZ0JBQU8sS0FBSzg0QyxRQUFMLENBQWMsTUFBZCxFQUFzQixDQUFDaHVELElBQUQsRUFBT2tWLElBQVAsQ0FBdEIsQ0FBUDtBQUNILE1BSEQ7O0FBS0E7Ozs7Ozs7QUFPQXN3QyxPQUFFcUosSUFBRixHQUFTO0FBQ1RySixPQUFFc0osS0FBRixHQUFVO0FBQ1Z0SixPQUFFdUosTUFBRixHQUFXLFVBQVVqSCxNQUFWLEVBQWtCOW5ELElBQWxCLENBQXVCLFdBQXZCLEVBQW9DO0FBQzNDLGdCQUFPd2xELEVBQUVzQyxNQUFGLEVBQVVrRyxRQUFWLENBQW1CLE1BQW5CLEVBQTJCLENBQUNodUQsSUFBRCxFQUFPaW5ELFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFQLENBQTNCLENBQVA7QUFDSCxNQUpEOztBQU1Bd1QsYUFBUTVULFNBQVIsQ0FBa0IrdkQsSUFBbEIsR0FBeUI7QUFDekJuOEMsYUFBUTVULFNBQVIsQ0FBa0Jnd0QsS0FBbEIsR0FBMEI7QUFDMUJwOEMsYUFBUTVULFNBQVIsQ0FBa0Jpd0QsTUFBbEIsR0FBMkIsVUFBVS91RCxJQUFWLENBQWUsV0FBZixFQUE0QjtBQUNuRCxnQkFBTyxLQUFLZ3VELFFBQUwsQ0FBYyxNQUFkLEVBQXNCLENBQUNodUQsSUFBRCxFQUFPaW5ELFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFQLENBQXRCLENBQVA7QUFDSCxNQUpEOztBQU1BOzs7OztBQUtBc21ELE9BQUV3SixNQUFGLEdBQVcsVUFBVWxILE1BQVYsRUFBa0I1eUMsSUFBbEIsRUFBd0I7QUFDL0IsZ0JBQU9zd0MsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsT0FBbkIsRUFBNEIsQ0FBQyxLQUFLLENBQU4sRUFBUzk0QyxJQUFULENBQTVCLENBQVA7QUFDSCxNQUZEOztBQUlBeEMsYUFBUTVULFNBQVIsQ0FBa0Jrd0QsTUFBbEIsR0FBMkIsVUFBVTk1QyxJQUFWLEVBQWdCO0FBQ3ZDLGdCQUFPLEtBQUs4NEMsUUFBTCxDQUFjLE9BQWQsRUFBdUIsQ0FBQyxLQUFLLENBQU4sRUFBUzk0QyxJQUFULENBQXZCLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7OztBQUtBc3dDLE9BQUUsS0FBRixJQUNBQSxFQUFFbUgsS0FBRixHQUFVLFVBQVU3RSxNQUFWLENBQWlCLFlBQWpCLEVBQStCO0FBQ3JDLGdCQUFPdEMsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsT0FBbkIsRUFBNEIsQ0FBQyxLQUFLLENBQU4sRUFBUy9HLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFULENBQTVCLENBQVA7QUFDSCxNQUhEOztBQUtBd1QsYUFBUTVULFNBQVIsQ0FBa0I2dEQsS0FBbEIsR0FBMEIsWUFBVSxXQUFhO0FBQzdDLGdCQUFPLEtBQUtxQixRQUFMLENBQWMsT0FBZCxFQUF1QixDQUFDLEtBQUssQ0FBTixFQUFTL0csWUFBWS9uRCxTQUFaLENBQVQsQ0FBdkIsQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7OztBQU1Bc21ELE9BQUV5SixLQUFGLEdBQVUsVUFBVW5ILE1BQVYsQ0FBaUIsV0FBakIsRUFBOEI7QUFDcEMsYUFBSTVoRCxVQUFVcy9DLEVBQUVzQyxNQUFGLENBQWQ7QUFDQSxhQUFJNXlDLE9BQU8reEMsWUFBWS9uRCxTQUFaLEVBQXVCLENBQXZCLENBQVg7QUFDQSxnQkFBTyxTQUFTZ3dELE1BQVQsR0FBa0I7QUFDckIsb0JBQU9ocEQsUUFBUThuRCxRQUFSLENBQWlCLE9BQWpCLEVBQTBCLENBQzdCLElBRDZCLEVBRTdCOTRDLEtBQUt6SixNQUFMLENBQVl3N0MsWUFBWS9uRCxTQUFaLENBQVosQ0FGNkIsQ0FBMUIsQ0FBUDtBQUlILFVBTEQ7QUFNSCxNQVREO0FBVUF3VCxhQUFRNVQsU0FBUixDQUFrQm13RCxLQUFsQixHQUEwQixZQUFVLFdBQWE7QUFDN0MsYUFBSS9vRCxVQUFVLElBQWQ7QUFDQSxhQUFJZ1AsT0FBTyt4QyxZQUFZL25ELFNBQVosQ0FBWDtBQUNBLGdCQUFPLFNBQVNnd0QsTUFBVCxHQUFrQjtBQUNyQixvQkFBT2hwRCxRQUFROG5ELFFBQVIsQ0FBaUIsT0FBakIsRUFBMEIsQ0FDN0IsSUFENkIsRUFFN0I5NEMsS0FBS3pKLE1BQUwsQ0FBWXc3QyxZQUFZL25ELFNBQVosQ0FBWixDQUY2QixDQUExQixDQUFQO0FBSUgsVUFMRDtBQU1ILE1BVEQ7O0FBV0E7Ozs7OztBQU1Bc21ELE9BQUVsL0MsSUFBRixHQUFTLFVBQVV3aEQsTUFBVixFQUFrQjtBQUN2QixnQkFBT3RDLEVBQUVzQyxNQUFGLEVBQVVrRyxRQUFWLENBQW1CLE1BQW5CLEVBQTJCLEVBQTNCLENBQVA7QUFDSCxNQUZEOztBQUlBdDdDLGFBQVE1VCxTQUFSLENBQWtCd0gsSUFBbEIsR0FBeUIsWUFBWTtBQUNqQyxnQkFBTyxLQUFLMG5ELFFBQUwsQ0FBYyxNQUFkLEVBQXNCLEVBQXRCLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBeEksT0FBRXpPLEdBQUYsR0FBUUEsR0FBUjtBQUNBLGNBQVNBLEdBQVQsQ0FBYW9ZLFFBQWIsRUFBdUI7QUFDbkIsZ0JBQU90QyxLQUFLc0MsUUFBTCxFQUFlLFVBQVVBLFFBQVYsRUFBb0I7QUFDdEMsaUJBQUlDLGVBQWUsQ0FBbkI7QUFDQSxpQkFBSTlFLFdBQVcxa0QsT0FBZjtBQUNBc2hELDBCQUFhaUksUUFBYixFQUF1QixVQUFVOXZELFNBQVYsRUFBcUI2RyxPQUFyQixFQUE4QnpDLEtBQTlCLEVBQXFDO0FBQ3hELHFCQUFJNHJELFFBQUo7QUFDQSxxQkFDSXhFLFVBQVUza0QsT0FBVixLQUNBLENBQUNtcEQsV0FBV25wRCxRQUFRNGtELE9BQVIsRUFBWixFQUErQm5NLEtBQS9CLEtBQXlDLFdBRjdDLEVBR0U7QUFDRXdRLDhCQUFTMXJELEtBQVQsSUFBa0I0ckQsU0FBU2pvRCxLQUEzQjtBQUNILGtCQUxELE1BS087QUFDSCx1QkFBRWdvRCxZQUFGO0FBQ0F2QywwQkFDSTNtRCxPQURKLEVBRUksVUFBVWtCLEtBQVYsRUFBaUI7QUFDYituRCxrQ0FBUzFyRCxLQUFULElBQWtCMkQsS0FBbEI7QUFDQSw2QkFBSSxFQUFFZ29ELFlBQUYsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEI5RSxzQ0FBU3ZrRCxPQUFULENBQWlCb3BELFFBQWpCO0FBQ0g7QUFDSixzQkFQTCxFQVFJN0UsU0FBU3JrRCxNQVJiLEVBU0ksVUFBVWlsRCxRQUFWLEVBQW9CO0FBQ2hCWixrQ0FBUy8xQyxNQUFULENBQWdCLEVBQUU5USxPQUFPQSxLQUFULEVBQWdCMkQsT0FBTzhqRCxRQUF2QixFQUFoQjtBQUNILHNCQVhMO0FBYUg7QUFDSixjQXZCRCxFQXVCRyxLQUFLLENBdkJSO0FBd0JBLGlCQUFJa0UsaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3BCOUUsMEJBQVN2a0QsT0FBVCxDQUFpQm9wRCxRQUFqQjtBQUNIO0FBQ0Qsb0JBQU83RSxTQUFTcGtELE9BQWhCO0FBQ0gsVUEvQk0sQ0FBUDtBQWdDSDs7QUFFRHdNLGFBQVE1VCxTQUFSLENBQWtCaTRDLEdBQWxCLEdBQXdCLFlBQVk7QUFDaEMsZ0JBQU9BLElBQUksSUFBSixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7Ozs7OztBQU9BeU8sT0FBRThKLEdBQUYsR0FBUUEsR0FBUjs7QUFFQSxjQUFTQSxHQUFULENBQWFILFFBQWIsRUFBdUI7QUFDbkIsYUFBSUEsU0FBU3p2RCxNQUFULEtBQW9CLENBQXhCLEVBQTJCO0FBQ3ZCLG9CQUFPOGxELEVBQUV6L0MsT0FBRixFQUFQO0FBQ0g7O0FBRUQsYUFBSXVrRCxXQUFXOUUsRUFBRTUvQyxLQUFGLEVBQWY7QUFDQSxhQUFJd3BELGVBQWUsQ0FBbkI7QUFDQWxJLHNCQUFhaUksUUFBYixFQUF1QixVQUFVOXVCLElBQVYsRUFBZ0I1TCxPQUFoQixFQUF5Qmh4QixLQUF6QixFQUFnQztBQUNuRCxpQkFBSXlDLFVBQVVpcEQsU0FBUzFyRCxLQUFULENBQWQ7O0FBRUEyckQ7O0FBRUF2QyxrQkFBSzNtRCxPQUFMLEVBQWNxcEQsV0FBZCxFQUEyQkMsVUFBM0IsRUFBdUNDLFVBQXZDO0FBQ0Esc0JBQVNGLFdBQVQsQ0FBcUJuNkMsTUFBckIsRUFBNkI7QUFDekJrMUMsMEJBQVN2a0QsT0FBVCxDQUFpQnFQLE1BQWpCO0FBQ0g7QUFDRCxzQkFBU282QyxVQUFULENBQW9Cai9DLEdBQXBCLEVBQXlCO0FBQ3JCNitDO0FBQ0EscUJBQUlBLGlCQUFpQixDQUFyQixFQUF3QjtBQUNwQjcrQyx5QkFBSTA2QyxPQUFKLEdBQWUseURBQ1gsOENBRFcsR0FDc0MxNkMsSUFBSTA2QyxPQUR6RDtBQUVBWCw4QkFBU3JrRCxNQUFULENBQWdCc0ssR0FBaEI7QUFDSDtBQUNKO0FBQ0Qsc0JBQVNrL0MsVUFBVCxDQUFvQnZFLFFBQXBCLEVBQThCO0FBQzFCWiwwQkFBUy8xQyxNQUFULENBQWdCO0FBQ1o5USw0QkFBT0EsS0FESztBQUVaMkQsNEJBQU84akQ7QUFGSyxrQkFBaEI7QUFJSDtBQUNKLFVBdkJELEVBdUJHN3JELFNBdkJIOztBQXlCQSxnQkFBT2lyRCxTQUFTcGtELE9BQWhCO0FBQ0g7O0FBRUR3TSxhQUFRNVQsU0FBUixDQUFrQnd3RCxHQUFsQixHQUF3QixZQUFZO0FBQ2hDLGdCQUFPQSxJQUFJLElBQUosQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7Ozs7OztBQVNBOUosT0FBRWtLLFdBQUYsR0FBZ0IvRixVQUFVK0YsV0FBVixFQUF1QixhQUF2QixFQUFzQyxZQUF0QyxDQUFoQjtBQUNBLGNBQVNBLFdBQVQsQ0FBcUJQLFFBQXJCLEVBQStCO0FBQzNCLGdCQUFPdEMsS0FBS3NDLFFBQUwsRUFBZSxVQUFVQSxRQUFWLEVBQW9CO0FBQ3RDQSx3QkFBVzlILFVBQVU4SCxRQUFWLEVBQW9CM0osQ0FBcEIsQ0FBWDtBQUNBLG9CQUFPcUgsS0FBSzlWLElBQUlzUSxVQUFVOEgsUUFBVixFQUFvQixVQUFVanBELE9BQVYsRUFBbUI7QUFDbkQsd0JBQU8ybUQsS0FBSzNtRCxPQUFMLEVBQWM3SCxJQUFkLEVBQW9CQSxJQUFwQixDQUFQO0FBQ0gsY0FGZSxDQUFKLENBQUwsRUFFRixZQUFZO0FBQ2Isd0JBQU84d0QsUUFBUDtBQUNILGNBSk0sQ0FBUDtBQUtILFVBUE0sQ0FBUDtBQVFIOztBQUVEejhDLGFBQVE1VCxTQUFSLENBQWtCNHdELFdBQWxCLEdBQWdDLFlBQVk7QUFDeEMsZ0JBQU9BLFlBQVksSUFBWixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7O0FBR0FsSyxPQUFFbUssVUFBRixHQUFlQSxVQUFmO0FBQ0EsY0FBU0EsVUFBVCxDQUFvQlIsUUFBcEIsRUFBOEI7QUFDMUIsZ0JBQU8zSixFQUFFMkosUUFBRixFQUFZUSxVQUFaLEVBQVA7QUFDSDs7QUFFRDs7Ozs7OztBQU9BajlDLGFBQVE1VCxTQUFSLENBQWtCNndELFVBQWxCLEdBQStCLFlBQVk7QUFDdkMsZ0JBQU8sS0FBSzFxRCxJQUFMLENBQVUsVUFBVWtxRCxRQUFWLEVBQW9CO0FBQ2pDLG9CQUFPcFksSUFBSXNRLFVBQVU4SCxRQUFWLEVBQW9CLFVBQVVqcEQsT0FBVixFQUFtQjtBQUM5Q0EsMkJBQVVzL0MsRUFBRXQvQyxPQUFGLENBQVY7QUFDQSwwQkFBUzBwRCxVQUFULEdBQXNCO0FBQ2xCLDRCQUFPMXBELFFBQVE0a0QsT0FBUixFQUFQO0FBQ0g7QUFDRCx3QkFBTzVrRCxRQUFRakIsSUFBUixDQUFhMnFELFVBQWIsRUFBeUJBLFVBQXpCLENBQVA7QUFDSCxjQU5VLENBQUosQ0FBUDtBQU9ILFVBUk0sQ0FBUDtBQVNILE1BVkQ7O0FBWUE7Ozs7Ozs7OztBQVNBcEssT0FBRXFLLElBQUYsR0FBUztBQUNUckssT0FBRSxPQUFGLElBQWEsVUFBVXNDLE1BQVYsRUFBa0JrRSxRQUFsQixFQUE0QjtBQUNyQyxnQkFBT3hHLEVBQUVzQyxNQUFGLEVBQVU3aUQsSUFBVixDQUFlLEtBQUssQ0FBcEIsRUFBdUIrbUQsUUFBdkIsQ0FBUDtBQUNILE1BSEQ7O0FBS0F0NUMsYUFBUTVULFNBQVIsQ0FBa0Ird0QsSUFBbEIsR0FBeUI7QUFDekJuOUMsYUFBUTVULFNBQVIsQ0FBa0IsT0FBbEIsSUFBNkIsVUFBVWt0RCxRQUFWLEVBQW9CO0FBQzdDLGdCQUFPLEtBQUsvbUQsSUFBTCxDQUFVLEtBQUssQ0FBZixFQUFrQittRCxRQUFsQixDQUFQO0FBQ0gsTUFIRDs7QUFLQTs7Ozs7Ozs7QUFRQXhHLE9BQUUwRixRQUFGLEdBQWFBLFFBQWI7QUFDQSxjQUFTQSxRQUFULENBQWtCcEQsTUFBbEIsRUFBMEJtRSxVQUExQixFQUFzQztBQUNsQyxnQkFBT3pHLEVBQUVzQyxNQUFGLEVBQVU3aUQsSUFBVixDQUFlLEtBQUssQ0FBcEIsRUFBdUIsS0FBSyxDQUE1QixFQUErQmduRCxVQUEvQixDQUFQO0FBQ0g7O0FBRUR2NUMsYUFBUTVULFNBQVIsQ0FBa0Jvc0QsUUFBbEIsR0FBNkIsVUFBVWUsVUFBVixFQUFzQjtBQUMvQyxnQkFBTyxLQUFLaG5ELElBQUwsQ0FBVSxLQUFLLENBQWYsRUFBa0IsS0FBSyxDQUF2QixFQUEwQmduRCxVQUExQixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7Ozs7Ozs7Ozs7QUFXQXpHLE9BQUVzSyxHQUFGLEdBQVE7QUFDUnRLLE9BQUUsU0FBRixJQUFlLFVBQVVzQyxNQUFWLEVBQWtCeDVCLFFBQWxCLEVBQTRCO0FBQ3ZDLGdCQUFPazNCLEVBQUVzQyxNQUFGLEVBQVUsU0FBVixFQUFxQng1QixRQUFyQixDQUFQO0FBQ0gsTUFIRDs7QUFLQTViLGFBQVE1VCxTQUFSLENBQWtCZ3hELEdBQWxCLEdBQXdCO0FBQ3hCcDlDLGFBQVE1VCxTQUFSLENBQWtCLFNBQWxCLElBQStCLFVBQVV3dkIsUUFBVixFQUFvQjtBQUMvQyxhQUFJLENBQUNBLFFBQUQsSUFBYSxPQUFPQSxTQUFTcnZCLEtBQWhCLEtBQTBCLFVBQTNDLEVBQXVEO0FBQ25ELG1CQUFNLElBQUl3a0QsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSDtBQUNEbjFCLG9CQUFXazNCLEVBQUVsM0IsUUFBRixDQUFYO0FBQ0EsZ0JBQU8sS0FBS3JwQixJQUFMLENBQVUsVUFBVW1DLEtBQVYsRUFBaUI7QUFDOUIsb0JBQU9rbkIsU0FBU3ErQixLQUFULEdBQWlCMW5ELElBQWpCLENBQXNCLFlBQVk7QUFDckMsd0JBQU9tQyxLQUFQO0FBQ0gsY0FGTSxDQUFQO0FBR0gsVUFKTSxFQUlKLFVBQVVxYSxNQUFWLEVBQWtCO0FBQ2pCO0FBQ0Esb0JBQU82TSxTQUFTcStCLEtBQVQsR0FBaUIxbkQsSUFBakIsQ0FBc0IsWUFBWTtBQUNyQyx1QkFBTXdjLE1BQU47QUFDSCxjQUZNLENBQVA7QUFHSCxVQVRNLENBQVA7QUFVSCxNQWhCRDs7QUFrQkE7Ozs7OztBQU1BK2pDLE9BQUUwRyxJQUFGLEdBQVMsVUFBVXBFLE1BQVYsRUFBa0JpRSxTQUFsQixFQUE2QkMsUUFBN0IsRUFBdUNkLFFBQXZDLEVBQWlEO0FBQ3RELGdCQUFPMUYsRUFBRXNDLE1BQUYsRUFBVW9FLElBQVYsQ0FBZUgsU0FBZixFQUEwQkMsUUFBMUIsRUFBb0NkLFFBQXBDLENBQVA7QUFDSCxNQUZEOztBQUlBeDRDLGFBQVE1VCxTQUFSLENBQWtCb3RELElBQWxCLEdBQXlCLFVBQVVILFNBQVYsRUFBcUJDLFFBQXJCLEVBQStCZCxRQUEvQixFQUF5QztBQUM5RCxhQUFJNkUsbUJBQW1CLDBCQUFVeHFELEtBQVYsRUFBaUI7QUFDcEM7QUFDQTtBQUNBaWdELGVBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkJpMkMsb0NBQW1COWlELEtBQW5CLEVBQTBCVyxPQUExQjtBQUNBLHFCQUFJcy9DLEVBQUVpSCxPQUFOLEVBQWU7QUFDWGpILHVCQUFFaUgsT0FBRixDQUFVbG5ELEtBQVY7QUFDSCxrQkFGRCxNQUVPO0FBQ0gsMkJBQU1BLEtBQU47QUFDSDtBQUNKLGNBUEQ7QUFRSCxVQVhEOztBQWFBO0FBQ0EsYUFBSVcsVUFBVTZsRCxhQUFhQyxRQUFiLElBQXlCZCxRQUF6QixHQUNWLEtBQUtqbUQsSUFBTCxDQUFVOG1ELFNBQVYsRUFBcUJDLFFBQXJCLEVBQStCZCxRQUEvQixDQURVLEdBRVYsSUFGSjs7QUFJQSxhQUFJLFFBQU9uK0MsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUErQkEsT0FBL0IsSUFBMENBLFFBQVFxNUMsTUFBdEQsRUFBOEQ7QUFDMUQySixnQ0FBbUJoakQsUUFBUXE1QyxNQUFSLENBQWV4bkQsSUFBZixDQUFvQm14RCxnQkFBcEIsQ0FBbkI7QUFDSDs7QUFFRDdwRCxpQkFBUWpCLElBQVIsQ0FBYSxLQUFLLENBQWxCLEVBQXFCOHFELGdCQUFyQjtBQUNILE1BeEJEOztBQTBCQTs7Ozs7Ozs7O0FBU0F2SyxPQUFFNWpDLE9BQUYsR0FBWSxVQUFVa21DLE1BQVYsRUFBa0JrSSxFQUFsQixFQUFzQnpxRCxLQUF0QixFQUE2QjtBQUNyQyxnQkFBT2lnRCxFQUFFc0MsTUFBRixFQUFVbG1DLE9BQVYsQ0FBa0JvdUMsRUFBbEIsRUFBc0J6cUQsS0FBdEIsQ0FBUDtBQUNILE1BRkQ7O0FBSUFtTixhQUFRNVQsU0FBUixDQUFrQjhpQixPQUFsQixHQUE0QixVQUFVb3VDLEVBQVYsRUFBY3pxRCxLQUFkLEVBQXFCO0FBQzdDLGFBQUkra0QsV0FBVzFrRCxPQUFmO0FBQ0EsYUFBSXFxRCxZQUFZcDlDLFdBQVcsWUFBWTtBQUNuQyxpQkFBSSxDQUFDdE4sS0FBRCxJQUFVLGFBQWEsT0FBT0EsS0FBbEMsRUFBeUM7QUFDckNBLHlCQUFRLElBQUlrK0MsS0FBSixDQUFVbCtDLFNBQVMscUJBQXFCeXFELEVBQXJCLEdBQTBCLEtBQTdDLENBQVI7QUFDQXpxRCx1QkFBTTArQixJQUFOLEdBQWEsV0FBYjtBQUNIO0FBQ0RxbUIsc0JBQVNya0QsTUFBVCxDQUFnQlYsS0FBaEI7QUFDSCxVQU5lLEVBTWJ5cUQsRUFOYSxDQUFoQjs7QUFRQSxjQUFLL3FELElBQUwsQ0FBVSxVQUFVbUMsS0FBVixFQUFpQjtBQUN2QnU4QywwQkFBYXNNLFNBQWI7QUFDQTNGLHNCQUFTdmtELE9BQVQsQ0FBaUJxQixLQUFqQjtBQUNILFVBSEQsRUFHRyxVQUFVNmdELFNBQVYsRUFBcUI7QUFDcEJ0RSwwQkFBYXNNLFNBQWI7QUFDQTNGLHNCQUFTcmtELE1BQVQsQ0FBZ0JnaUQsU0FBaEI7QUFDSCxVQU5ELEVBTUdxQyxTQUFTLzFDLE1BTlo7O0FBUUEsZ0JBQU8rMUMsU0FBU3BrRCxPQUFoQjtBQUNILE1BbkJEOztBQXFCQTs7Ozs7Ozs7O0FBU0FzL0MsT0FBRTdqQyxLQUFGLEdBQVUsVUFBVW1tQyxNQUFWLEVBQWtCbG1DLE9BQWxCLEVBQTJCO0FBQ2pDLGFBQUlBLFlBQVksS0FBSyxDQUFyQixFQUF3QjtBQUNwQkEsdUJBQVVrbUMsTUFBVjtBQUNBQSxzQkFBUyxLQUFLLENBQWQ7QUFDSDtBQUNELGdCQUFPdEMsRUFBRXNDLE1BQUYsRUFBVW5tQyxLQUFWLENBQWdCQyxPQUFoQixDQUFQO0FBQ0gsTUFORDs7QUFRQWxQLGFBQVE1VCxTQUFSLENBQWtCNmlCLEtBQWxCLEdBQTBCLFVBQVVDLE9BQVYsRUFBbUI7QUFDekMsZ0JBQU8sS0FBSzNjLElBQUwsQ0FBVSxVQUFVbUMsS0FBVixFQUFpQjtBQUM5QixpQkFBSWtqRCxXQUFXMWtELE9BQWY7QUFDQWlOLHdCQUFXLFlBQVk7QUFDbkJ5M0MsMEJBQVN2a0QsT0FBVCxDQUFpQnFCLEtBQWpCO0FBQ0gsY0FGRCxFQUVHd2EsT0FGSDtBQUdBLG9CQUFPMG9DLFNBQVNwa0QsT0FBaEI7QUFDSCxVQU5NLENBQVA7QUFPSCxNQVJEOztBQVVBOzs7Ozs7Ozs7QUFTQXMvQyxPQUFFMEssT0FBRixHQUFZLFVBQVU1aEMsUUFBVixFQUFvQnBaLElBQXBCLEVBQTBCO0FBQ2xDLGdCQUFPc3dDLEVBQUVsM0IsUUFBRixFQUFZNGhDLE9BQVosQ0FBb0JoN0MsSUFBcEIsQ0FBUDtBQUNILE1BRkQ7O0FBSUF4QyxhQUFRNVQsU0FBUixDQUFrQm94RCxPQUFsQixHQUE0QixVQUFVaDdDLElBQVYsRUFBZ0I7QUFDeEMsYUFBSW8xQyxXQUFXMWtELE9BQWY7QUFDQSxhQUFJdXFELFdBQVdsSixZQUFZL3hDLElBQVosQ0FBZjtBQUNBaTdDLGtCQUFTOS9DLElBQVQsQ0FBY2k2QyxTQUFTYyxnQkFBVCxFQUFkO0FBQ0EsY0FBSzRELE1BQUwsQ0FBWW1CLFFBQVosRUFBc0JOLElBQXRCLENBQTJCdkYsU0FBU3JrRCxNQUFwQztBQUNBLGdCQUFPcWtELFNBQVNwa0QsT0FBaEI7QUFDSCxNQU5EOztBQVFBOzs7Ozs7Ozs7QUFTQXMvQyxPQUFFNEssTUFBRixHQUFXLFVBQVU5aEMsUUFBVixDQUFtQixXQUFuQixFQUFnQztBQUN2QyxhQUFJcFosT0FBTyt4QyxZQUFZL25ELFNBQVosRUFBdUIsQ0FBdkIsQ0FBWDtBQUNBLGdCQUFPc21ELEVBQUVsM0IsUUFBRixFQUFZNGhDLE9BQVosQ0FBb0JoN0MsSUFBcEIsQ0FBUDtBQUNILE1BSEQ7O0FBS0F4QyxhQUFRNVQsU0FBUixDQUFrQnN4RCxNQUFsQixHQUEyQixZQUFVLFdBQWE7QUFDOUMsYUFBSUQsV0FBV2xKLFlBQVkvbkQsU0FBWixDQUFmO0FBQ0EsYUFBSW9yRCxXQUFXMWtELE9BQWY7QUFDQXVxRCxrQkFBUzkvQyxJQUFULENBQWNpNkMsU0FBU2MsZ0JBQVQsRUFBZDtBQUNBLGNBQUs0RCxNQUFMLENBQVltQixRQUFaLEVBQXNCTixJQUF0QixDQUEyQnZGLFNBQVNya0QsTUFBcEM7QUFDQSxnQkFBT3FrRCxTQUFTcGtELE9BQWhCO0FBQ0gsTUFORDs7QUFRQTs7Ozs7Ozs7QUFRQXMvQyxPQUFFNkssTUFBRixHQUNBN0ssRUFBRThLLFNBQUYsR0FBYyxVQUFVaGlDLFFBQVYsQ0FBbUIsV0FBbkIsRUFBZ0M7QUFDMUMsYUFBSUEsYUFBYWp2QixTQUFqQixFQUE0QjtBQUN4QixtQkFBTSxJQUFJb2tELEtBQUosQ0FBVSxvQ0FBVixDQUFOO0FBQ0g7QUFDRCxhQUFJOE0sV0FBV3RKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsZ0JBQU8sWUFBWTtBQUNmLGlCQUFJaXhELFdBQVdJLFNBQVM5a0QsTUFBVCxDQUFnQnc3QyxZQUFZL25ELFNBQVosQ0FBaEIsQ0FBZjtBQUNBLGlCQUFJb3JELFdBQVcxa0QsT0FBZjtBQUNBdXFELHNCQUFTOS9DLElBQVQsQ0FBY2k2QyxTQUFTYyxnQkFBVCxFQUFkO0FBQ0E1RixlQUFFbDNCLFFBQUYsRUFBWTBnQyxNQUFaLENBQW1CbUIsUUFBbkIsRUFBNkJOLElBQTdCLENBQWtDdkYsU0FBU3JrRCxNQUEzQztBQUNBLG9CQUFPcWtELFNBQVNwa0QsT0FBaEI7QUFDSCxVQU5EO0FBT0gsTUFiRDs7QUFlQXdNLGFBQVE1VCxTQUFSLENBQWtCdXhELE1BQWxCLEdBQ0EzOUMsUUFBUTVULFNBQVIsQ0FBa0J3eEQsU0FBbEIsR0FBOEIsWUFBVSxXQUFhO0FBQ2pELGFBQUlwN0MsT0FBTyt4QyxZQUFZL25ELFNBQVosQ0FBWDtBQUNBZ1csY0FBS2tlLE9BQUwsQ0FBYSxJQUFiO0FBQ0EsZ0JBQU9veUIsRUFBRThLLFNBQUYsQ0FBWXJ4RCxLQUFaLENBQWtCLEtBQUssQ0FBdkIsRUFBMEJpVyxJQUExQixDQUFQO0FBQ0gsTUFMRDs7QUFPQXN3QyxPQUFFZ0wsS0FBRixHQUFVLFVBQVVsaUMsUUFBVixFQUFvQmc1QixLQUFwQixDQUEwQixXQUExQixFQUF1QztBQUM3QyxhQUFJaUosV0FBV3RKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsZ0JBQU8sWUFBWTtBQUNmLGlCQUFJaXhELFdBQVdJLFNBQVM5a0QsTUFBVCxDQUFnQnc3QyxZQUFZL25ELFNBQVosQ0FBaEIsQ0FBZjtBQUNBLGlCQUFJb3JELFdBQVcxa0QsT0FBZjtBQUNBdXFELHNCQUFTOS9DLElBQVQsQ0FBY2k2QyxTQUFTYyxnQkFBVCxFQUFkO0FBQ0Esc0JBQVNxRixLQUFULEdBQWlCO0FBQ2Isd0JBQU9uaUMsU0FBU3J2QixLQUFULENBQWVxb0QsS0FBZixFQUFzQnBvRCxTQUF0QixDQUFQO0FBQ0g7QUFDRHNtRCxlQUFFaUwsS0FBRixFQUFTekIsTUFBVCxDQUFnQm1CLFFBQWhCLEVBQTBCTixJQUExQixDQUErQnZGLFNBQVNya0QsTUFBeEM7QUFDQSxvQkFBT3FrRCxTQUFTcGtELE9BQWhCO0FBQ0gsVUFURDtBQVVILE1BWkQ7O0FBY0F3TSxhQUFRNVQsU0FBUixDQUFrQjB4RCxLQUFsQixHQUEwQixZQUFVLGtCQUFvQjtBQUNwRCxhQUFJdDdDLE9BQU8reEMsWUFBWS9uRCxTQUFaLEVBQXVCLENBQXZCLENBQVg7QUFDQWdXLGNBQUtrZSxPQUFMLENBQWEsSUFBYjtBQUNBLGdCQUFPb3lCLEVBQUVnTCxLQUFGLENBQVF2eEQsS0FBUixDQUFjLEtBQUssQ0FBbkIsRUFBc0JpVyxJQUF0QixDQUFQO0FBQ0gsTUFKRDs7QUFNQTs7Ozs7Ozs7O0FBU0Fzd0MsT0FBRWtMLE9BQUYsR0FBWTtBQUNabEwsT0FBRW1MLEtBQUYsR0FBVSxVQUFVN0ksTUFBVixFQUFrQjluRCxJQUFsQixFQUF3QmtWLElBQXhCLEVBQThCO0FBQ3BDLGdCQUFPc3dDLEVBQUVzQyxNQUFGLEVBQVU2SSxLQUFWLENBQWdCM3dELElBQWhCLEVBQXNCa1YsSUFBdEIsQ0FBUDtBQUNILE1BSEQ7O0FBS0F4QyxhQUFRNVQsU0FBUixDQUFrQjR4RCxPQUFsQixHQUE0QjtBQUM1QmgrQyxhQUFRNVQsU0FBUixDQUFrQjZ4RCxLQUFsQixHQUEwQixVQUFVM3dELElBQVYsRUFBZ0JrVixJQUFoQixFQUFzQjtBQUM1QyxhQUFJaTdDLFdBQVdsSixZQUFZL3hDLFFBQVEsRUFBcEIsQ0FBZjtBQUNBLGFBQUlvMUMsV0FBVzFrRCxPQUFmO0FBQ0F1cUQsa0JBQVM5L0MsSUFBVCxDQUFjaTZDLFNBQVNjLGdCQUFULEVBQWQ7QUFDQSxjQUFLNEMsUUFBTCxDQUFjLE1BQWQsRUFBc0IsQ0FBQ2h1RCxJQUFELEVBQU9td0QsUUFBUCxDQUF0QixFQUF3Q04sSUFBeEMsQ0FBNkN2RixTQUFTcmtELE1BQXREO0FBQ0EsZ0JBQU9xa0QsU0FBU3BrRCxPQUFoQjtBQUNILE1BUEQ7O0FBU0E7Ozs7Ozs7Ozs7QUFVQXMvQyxPQUFFb0wsS0FBRixHQUFVO0FBQ1ZwTCxPQUFFcUwsTUFBRixHQUFXO0FBQ1hyTCxPQUFFc0wsT0FBRixHQUFZLFVBQVVoSixNQUFWLEVBQWtCOW5ELElBQWxCLENBQXVCLFdBQXZCLEVBQW9DO0FBQzVDLGFBQUltd0QsV0FBV2xKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsYUFBSW9yRCxXQUFXMWtELE9BQWY7QUFDQXVxRCxrQkFBUzkvQyxJQUFULENBQWNpNkMsU0FBU2MsZ0JBQVQsRUFBZDtBQUNBNUYsV0FBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsTUFBbkIsRUFBMkIsQ0FBQ2h1RCxJQUFELEVBQU9td0QsUUFBUCxDQUEzQixFQUE2Q04sSUFBN0MsQ0FBa0R2RixTQUFTcmtELE1BQTNEO0FBQ0EsZ0JBQU9xa0QsU0FBU3BrRCxPQUFoQjtBQUNILE1BUkQ7O0FBVUF3TSxhQUFRNVQsU0FBUixDQUFrQjh4RCxLQUFsQixHQUEwQjtBQUMxQmwrQyxhQUFRNVQsU0FBUixDQUFrQit4RCxNQUFsQixHQUEyQjtBQUMzQm4rQyxhQUFRNVQsU0FBUixDQUFrQmd5RCxPQUFsQixHQUE0QixVQUFVOXdELElBQVYsQ0FBZSxXQUFmLEVBQTRCO0FBQ3BELGFBQUltd0QsV0FBV2xKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsYUFBSW9yRCxXQUFXMWtELE9BQWY7QUFDQXVxRCxrQkFBUzkvQyxJQUFULENBQWNpNkMsU0FBU2MsZ0JBQVQsRUFBZDtBQUNBLGNBQUs0QyxRQUFMLENBQWMsTUFBZCxFQUFzQixDQUFDaHVELElBQUQsRUFBT213RCxRQUFQLENBQXRCLEVBQXdDTixJQUF4QyxDQUE2Q3ZGLFNBQVNya0QsTUFBdEQ7QUFDQSxnQkFBT3FrRCxTQUFTcGtELE9BQWhCO0FBQ0gsTUFSRDs7QUFVQTs7Ozs7Ozs7OztBQVVBcy9DLE9BQUV1TCxPQUFGLEdBQVlBLE9BQVo7QUFDQSxjQUFTQSxPQUFULENBQWlCakosTUFBakIsRUFBeUJrSixRQUF6QixFQUFtQztBQUMvQixnQkFBT3hMLEVBQUVzQyxNQUFGLEVBQVVpSixPQUFWLENBQWtCQyxRQUFsQixDQUFQO0FBQ0g7O0FBRUR0K0MsYUFBUTVULFNBQVIsQ0FBa0JpeUQsT0FBbEIsR0FBNEIsVUFBVUMsUUFBVixFQUFvQjtBQUM1QyxhQUFJQSxRQUFKLEVBQWM7QUFDVixrQkFBSy9yRCxJQUFMLENBQVUsVUFBVW1DLEtBQVYsRUFBaUI7QUFDdkJvK0MsbUJBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkI0K0MsOEJBQVMsSUFBVCxFQUFlNXBELEtBQWY7QUFDSCxrQkFGRDtBQUdILGNBSkQsRUFJRyxVQUFVN0IsS0FBVixFQUFpQjtBQUNoQmlnRCxtQkFBRXB6QyxRQUFGLENBQVcsWUFBWTtBQUNuQjQrQyw4QkFBU3pyRCxLQUFUO0FBQ0gsa0JBRkQ7QUFHSCxjQVJEO0FBU0gsVUFWRCxNQVVPO0FBQ0gsb0JBQU8sSUFBUDtBQUNIO0FBQ0osTUFkRDs7QUFnQkFpZ0QsT0FBRWxqRCxVQUFGLEdBQWUsWUFBVztBQUN0QixlQUFNLElBQUltaEQsS0FBSixDQUFVLG9EQUFWLENBQU47QUFDSCxNQUZEOztBQUlBO0FBQ0EsU0FBSWdHLGNBQWM5RCxhQUFsQjs7QUFFQSxZQUFPSCxDQUFQO0FBRUMsRUE1L0RELEU7Ozs7Ozs7OztBQzVCQSxLQUFJdm1ELFFBQVFKLFNBQVNDLFNBQVQsQ0FBbUJHLEtBQS9COztBQUVBOztBQUVBZCxTQUFRMFUsVUFBUixHQUFxQixZQUFXO0FBQzlCLFVBQU8sSUFBSW8rQyxPQUFKLENBQVloeUQsTUFBTUYsSUFBTixDQUFXOFQsVUFBWCxFQUF1Qm5TLE1BQXZCLEVBQStCeEIsU0FBL0IsQ0FBWixFQUF1RHlrRCxZQUF2RCxDQUFQO0FBQ0QsRUFGRDtBQUdBeGxELFNBQVEreUQsV0FBUixHQUFzQixZQUFXO0FBQy9CLFVBQU8sSUFBSUQsT0FBSixDQUFZaHlELE1BQU1GLElBQU4sQ0FBV215RCxXQUFYLEVBQXdCeHdELE1BQXhCLEVBQWdDeEIsU0FBaEMsQ0FBWixFQUF3RGl5RCxhQUF4RCxDQUFQO0FBQ0QsRUFGRDtBQUdBaHpELFNBQVF3bEQsWUFBUixHQUNBeGxELFFBQVFnekQsYUFBUixHQUF3QixVQUFTdnZDLE9BQVQsRUFBa0I7QUFDeEMsT0FBSUEsT0FBSixFQUFhO0FBQ1hBLGFBQVE4d0IsS0FBUjtBQUNEO0FBQ0YsRUFMRDs7QUFPQSxVQUFTdWUsT0FBVCxDQUFpQjVzRCxFQUFqQixFQUFxQitzRCxPQUFyQixFQUE4QjtBQUM1QixRQUFLQyxHQUFMLEdBQVdodEQsRUFBWDtBQUNBLFFBQUtpdEQsUUFBTCxHQUFnQkYsT0FBaEI7QUFDRDtBQUNESCxTQUFRbnlELFNBQVIsQ0FBa0J5eUQsS0FBbEIsR0FBMEJOLFFBQVFueUQsU0FBUixDQUFrQit4QixHQUFsQixHQUF3QixZQUFXLENBQUUsQ0FBL0Q7QUFDQW9nQyxTQUFRbnlELFNBQVIsQ0FBa0I0ekMsS0FBbEIsR0FBMEIsWUFBVztBQUNuQyxRQUFLNGUsUUFBTCxDQUFjdnlELElBQWQsQ0FBbUIyQixNQUFuQixFQUEyQixLQUFLMndELEdBQWhDO0FBQ0QsRUFGRDs7QUFJQTtBQUNBbHpELFNBQVFxekQsTUFBUixHQUFpQixVQUFTdG9ELElBQVQsRUFBZXVvRCxLQUFmLEVBQXNCO0FBQ3JDOU4sZ0JBQWF6NkMsS0FBS3dvRCxjQUFsQjtBQUNBeG9ELFFBQUt5b0QsWUFBTCxHQUFvQkYsS0FBcEI7QUFDRCxFQUhEOztBQUtBdHpELFNBQVF5ekQsUUFBUixHQUFtQixVQUFTMW9ELElBQVQsRUFBZTtBQUNoQ3k2QyxnQkFBYXo2QyxLQUFLd29ELGNBQWxCO0FBQ0F4b0QsUUFBS3lvRCxZQUFMLEdBQW9CLENBQUMsQ0FBckI7QUFDRCxFQUhEOztBQUtBeHpELFNBQVEwekQsWUFBUixHQUF1QjF6RCxRQUFRK0YsTUFBUixHQUFpQixVQUFTZ0YsSUFBVCxFQUFlO0FBQ3JEeTZDLGdCQUFhejZDLEtBQUt3b0QsY0FBbEI7O0FBRUEsT0FBSUQsUUFBUXZvRCxLQUFLeW9ELFlBQWpCO0FBQ0EsT0FBSUYsU0FBUyxDQUFiLEVBQWdCO0FBQ2R2b0QsVUFBS3dvRCxjQUFMLEdBQXNCNytDLFdBQVcsU0FBU2kvQyxTQUFULEdBQXFCO0FBQ3BELFdBQUk1b0QsS0FBSzZvRCxVQUFULEVBQ0U3b0QsS0FBSzZvRCxVQUFMO0FBQ0gsTUFIcUIsRUFHbkJOLEtBSG1CLENBQXRCO0FBSUQ7QUFDRixFQVZEOztBQVlBO0FBQ0Esb0JBQUFPLENBQVEsRUFBUjtBQUNBN3pELFNBQVFvb0QsWUFBUixHQUF1QkEsWUFBdkI7QUFDQXBvRCxTQUFROHpELGNBQVIsR0FBeUJBLGNBQXpCLEM7Ozs7Ozs7O0FDcERDLFlBQVV0Z0QsTUFBVixFQUFrQnRTLFNBQWxCLEVBQTZCO0FBQzFCOztBQUVBLFNBQUlzUyxPQUFPNDBDLFlBQVgsRUFBeUI7QUFDckI7QUFDSDs7QUFFRCxTQUFJMkwsYUFBYSxDQUFqQixDQVAwQixDQU9OO0FBQ3BCLFNBQUlDLGdCQUFnQixFQUFwQjtBQUNBLFNBQUlDLHdCQUF3QixLQUE1QjtBQUNBLFNBQUlDLE1BQU0xZ0QsT0FBTzlRLFFBQWpCO0FBQ0EsU0FBSXl4RCxpQkFBSjs7QUFFQSxjQUFTL0wsWUFBVCxDQUFzQmo0QixRQUF0QixFQUFnQztBQUM5QjtBQUNBLGFBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0Esd0JBQVcsSUFBSXp2QixRQUFKLENBQWEsS0FBS3l2QixRQUFsQixDQUFYO0FBQ0Q7QUFDRDtBQUNBLGFBQUlwWixPQUFPLElBQUlySyxLQUFKLENBQVUzTCxVQUFVUSxNQUFWLEdBQW1CLENBQTdCLENBQVg7QUFDQSxjQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSXlWLEtBQUt4VixNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDbEN5VixrQkFBS3pWLENBQUwsSUFBVVAsVUFBVU8sSUFBSSxDQUFkLENBQVY7QUFDSDtBQUNEO0FBQ0EsYUFBSXFtRCxPQUFPLEVBQUV4M0IsVUFBVUEsUUFBWixFQUFzQnBaLE1BQU1BLElBQTVCLEVBQVg7QUFDQWk5Qyx1QkFBY0QsVUFBZCxJQUE0QnBNLElBQTVCO0FBQ0F3TSwyQkFBa0JKLFVBQWxCO0FBQ0EsZ0JBQU9BLFlBQVA7QUFDRDs7QUFFRCxjQUFTRCxjQUFULENBQXdCTSxNQUF4QixFQUFnQztBQUM1QixnQkFBT0osY0FBY0ksTUFBZCxDQUFQO0FBQ0g7O0FBRUQsY0FBUy9xQyxHQUFULENBQWFzK0IsSUFBYixFQUFtQjtBQUNmLGFBQUl4M0IsV0FBV3czQixLQUFLeDNCLFFBQXBCO0FBQ0EsYUFBSXBaLE9BQU80d0MsS0FBSzV3QyxJQUFoQjtBQUNBLGlCQUFRQSxLQUFLeFYsTUFBYjtBQUNBLGtCQUFLLENBQUw7QUFDSTR1QjtBQUNBO0FBQ0osa0JBQUssQ0FBTDtBQUNJQSwwQkFBU3BaLEtBQUssQ0FBTCxDQUFUO0FBQ0E7QUFDSixrQkFBSyxDQUFMO0FBQ0lvWiwwQkFBU3BaLEtBQUssQ0FBTCxDQUFULEVBQWtCQSxLQUFLLENBQUwsQ0FBbEI7QUFDQTtBQUNKLGtCQUFLLENBQUw7QUFDSW9aLDBCQUFTcFosS0FBSyxDQUFMLENBQVQsRUFBa0JBLEtBQUssQ0FBTCxDQUFsQixFQUEyQkEsS0FBSyxDQUFMLENBQTNCO0FBQ0E7QUFDSjtBQUNJb1osMEJBQVNydkIsS0FBVCxDQUFlSSxTQUFmLEVBQTBCNlYsSUFBMUI7QUFDQTtBQWZKO0FBaUJIOztBQUVELGNBQVNzOUMsWUFBVCxDQUFzQkQsTUFBdEIsRUFBOEI7QUFDMUI7QUFDQTtBQUNBLGFBQUlILHFCQUFKLEVBQTJCO0FBQ3ZCO0FBQ0E7QUFDQXYvQyx3QkFBVzIvQyxZQUFYLEVBQXlCLENBQXpCLEVBQTRCRCxNQUE1QjtBQUNILFVBSkQsTUFJTztBQUNILGlCQUFJek0sT0FBT3FNLGNBQWNJLE1BQWQsQ0FBWDtBQUNBLGlCQUFJek0sSUFBSixFQUFVO0FBQ05zTSx5Q0FBd0IsSUFBeEI7QUFDQSxxQkFBSTtBQUNBNXFDLHlCQUFJcytCLElBQUo7QUFDSCxrQkFGRCxTQUVVO0FBQ05tTSxvQ0FBZU0sTUFBZjtBQUNBSCw2Q0FBd0IsS0FBeEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxjQUFTSyw2QkFBVCxHQUF5QztBQUNyQ0gsNkJBQW9CLDJCQUFTQyxNQUFULEVBQWlCO0FBQ2pDeGxELHFCQUFRcUYsUUFBUixDQUFpQixZQUFZO0FBQUVvZ0QsOEJBQWFELE1BQWI7QUFBdUIsY0FBdEQ7QUFDSCxVQUZEO0FBR0g7O0FBRUQsY0FBU0csaUJBQVQsR0FBNkI7QUFDekI7QUFDQTtBQUNBLGFBQUkvZ0QsT0FBT20xQyxXQUFQLElBQXNCLENBQUNuMUMsT0FBT2doRCxhQUFsQyxFQUFpRDtBQUM3QyxpQkFBSUMsNEJBQTRCLElBQWhDO0FBQ0EsaUJBQUlDLGVBQWVsaEQsT0FBT2cxQyxTQUExQjtBQUNBaDFDLG9CQUFPZzFDLFNBQVAsR0FBbUIsWUFBVztBQUMxQmlNLDZDQUE0QixLQUE1QjtBQUNILGNBRkQ7QUFHQWpoRCxvQkFBT20xQyxXQUFQLENBQW1CLEVBQW5CLEVBQXVCLEdBQXZCO0FBQ0FuMUMsb0JBQU9nMUMsU0FBUCxHQUFtQmtNLFlBQW5CO0FBQ0Esb0JBQU9ELHlCQUFQO0FBQ0g7QUFDSjs7QUFFRCxjQUFTRSxnQ0FBVCxHQUE0QztBQUN4QztBQUNBO0FBQ0E7O0FBRUEsYUFBSUMsZ0JBQWdCLGtCQUFrQmpyRCxLQUFLa3JELE1BQUwsRUFBbEIsR0FBa0MsR0FBdEQ7QUFDQSxhQUFJQyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVN4dEQsS0FBVCxFQUFnQjtBQUNsQyxpQkFBSUEsTUFBTXNtQixNQUFOLEtBQWlCcGEsTUFBakIsSUFDQSxPQUFPbE0sTUFBTVQsSUFBYixLQUFzQixRQUR0QixJQUVBUyxNQUFNVCxJQUFOLENBQVc3RCxPQUFYLENBQW1CNHhELGFBQW5CLE1BQXNDLENBRjFDLEVBRTZDO0FBQ3pDUCw4QkFBYSxDQUFDL3NELE1BQU1ULElBQU4sQ0FBVzNELEtBQVgsQ0FBaUIweEQsY0FBY3J6RCxNQUEvQixDQUFkO0FBQ0g7QUFDSixVQU5EOztBQVFBLGFBQUlpUyxPQUFPSCxnQkFBWCxFQUE2QjtBQUN6Qkcsb0JBQU9ILGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DeWhELGVBQW5DLEVBQW9ELEtBQXBEO0FBQ0gsVUFGRCxNQUVPO0FBQ0h0aEQsb0JBQU91aEQsV0FBUCxDQUFtQixXQUFuQixFQUFnQ0QsZUFBaEM7QUFDSDs7QUFFRFgsNkJBQW9CLDJCQUFTQyxNQUFULEVBQWlCO0FBQ2pDNWdELG9CQUFPbTFDLFdBQVAsQ0FBbUJpTSxnQkFBZ0JSLE1BQW5DLEVBQTJDLEdBQTNDO0FBQ0gsVUFGRDtBQUdIOztBQUVELGNBQVNZLG1DQUFULEdBQStDO0FBQzNDLGFBQUkxTSxVQUFVLElBQUlELGNBQUosRUFBZDtBQUNBQyxpQkFBUUMsS0FBUixDQUFjQyxTQUFkLEdBQTBCLFVBQVNsaEQsS0FBVCxFQUFnQjtBQUN0QyxpQkFBSThzRCxTQUFTOXNELE1BQU1ULElBQW5CO0FBQ0F3dEQsMEJBQWFELE1BQWI7QUFDSCxVQUhEOztBQUtBRCw2QkFBb0IsMkJBQVNDLE1BQVQsRUFBaUI7QUFDakM5TCxxQkFBUUksS0FBUixDQUFjQyxXQUFkLENBQTBCeUwsTUFBMUI7QUFDSCxVQUZEO0FBR0g7O0FBRUQsY0FBU2EscUNBQVQsR0FBaUQ7QUFDN0MsYUFBSTVmLE9BQU82ZSxJQUFJblAsZUFBZjtBQUNBb1AsNkJBQW9CLDJCQUFTQyxNQUFULEVBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBSWMsU0FBU2hCLElBQUlqbUMsYUFBSixDQUFrQixRQUFsQixDQUFiO0FBQ0FpbkMsb0JBQU9DLGtCQUFQLEdBQTRCLFlBQVk7QUFDcENkLDhCQUFhRCxNQUFiO0FBQ0FjLHdCQUFPQyxrQkFBUCxHQUE0QixJQUE1QjtBQUNBOWYsc0JBQUt0YixXQUFMLENBQWlCbTdCLE1BQWpCO0FBQ0FBLDBCQUFTLElBQVQ7QUFDSCxjQUxEO0FBTUE3ZixrQkFBS3JiLFdBQUwsQ0FBaUJrN0IsTUFBakI7QUFDSCxVQVhEO0FBWUg7O0FBRUQsY0FBU0UsK0JBQVQsR0FBMkM7QUFDdkNqQiw2QkFBb0IsMkJBQVNDLE1BQVQsRUFBaUI7QUFDakMxL0Msd0JBQVcyL0MsWUFBWCxFQUF5QixDQUF6QixFQUE0QkQsTUFBNUI7QUFDSCxVQUZEO0FBR0g7O0FBRUQ7QUFDQSxTQUFJaUIsV0FBV250RCxPQUFPb3RELGNBQVAsSUFBeUJwdEQsT0FBT290RCxjQUFQLENBQXNCOWhELE1BQXRCLENBQXhDO0FBQ0E2aEQsZ0JBQVdBLFlBQVlBLFNBQVMzZ0QsVUFBckIsR0FBa0MyZ0QsUUFBbEMsR0FBNkM3aEQsTUFBeEQ7O0FBRUE7QUFDQSxTQUFJLEdBQUdwSyxRQUFILENBQVl4SSxJQUFaLENBQWlCNFMsT0FBTzVFLE9BQXhCLE1BQXFDLGtCQUF6QyxFQUE2RDtBQUN6RDtBQUNBMGxEO0FBRUgsTUFKRCxNQUlPLElBQUlDLG1CQUFKLEVBQXlCO0FBQzVCO0FBQ0FJO0FBRUgsTUFKTSxNQUlBLElBQUluaEQsT0FBTzYwQyxjQUFYLEVBQTJCO0FBQzlCO0FBQ0EyTTtBQUVILE1BSk0sTUFJQSxJQUFJZCxPQUFPLHdCQUF3QkEsSUFBSWptQyxhQUFKLENBQWtCLFFBQWxCLENBQW5DLEVBQWdFO0FBQ25FO0FBQ0FnbkM7QUFFSCxNQUpNLE1BSUE7QUFDSDtBQUNBRztBQUNIOztBQUVEQyxjQUFTak4sWUFBVCxHQUF3QkEsWUFBeEI7QUFDQWlOLGNBQVN2QixjQUFULEdBQTBCQSxjQUExQjtBQUNILEVBekxBLEVBeUxDLE9BQU85eEQsSUFBUCxLQUFnQixXQUFoQixHQUE4QixPQUFPd1IsTUFBUCxLQUFrQixXQUFsQixlQUF1Q0EsTUFBckUsR0FBOEV4UixJQXpML0UsQ0FBRCxDOzs7Ozs7Ozs7QUNBQWpDLFFBQU9DLE9BQVAsR0FBaUIsVUFBU0QsTUFBVCxFQUFpQjtBQUNqQyxNQUFHLENBQUNBLE9BQU93MUQsZUFBWCxFQUE0QjtBQUMzQngxRCxVQUFPeXJELFNBQVAsR0FBbUIsWUFBVyxDQUFFLENBQWhDO0FBQ0F6ckQsVUFBT3kxRCxLQUFQLEdBQWUsRUFBZjtBQUNBO0FBQ0F6MUQsVUFBTzZlLFFBQVAsR0FBa0IsRUFBbEI7QUFDQTdlLFVBQU93MUQsZUFBUCxHQUF5QixDQUF6QjtBQUNBO0FBQ0QsU0FBT3gxRCxNQUFQO0FBQ0EsRUFURCxDOzs7Ozs7Ozs7Ozs7QUNBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLG9CQUFJc0QsUUFBSixDQUFhLE9BQWI7O0FBRUEsS0FBTW95RCxlQUFlLFNBQWZBLFlBQWUsQ0FBU3JyRCxHQUFULEVBQWM7QUFDakMsVUFBT0EsSUFBSXVCLE9BQUosQ0FBWSxxQ0FBWixFQUFtRCxNQUFuRCxDQUFQO0FBQ0QsRUFGRDs7QUFJQSxLQUFNK3BELFNBQVM7QUFDYnhnQyxVQURhLG1CQUNMM1EsR0FESyxFQUNBbFQsT0FEQSxFQUNTO0FBQ3BCLHdCQUFJdEssS0FBSixDQUFVc0ssT0FBVjtBQUNBLFNBQU1za0QsZ0JBQWdCLDZCQUFRdGtELFFBQVFqTSxLQUFoQixFQUF1QmlNLFFBQVFoTSxNQUEvQixFQUF1QztBQUMzRHV3RCxpQkFBVTtBQURpRCxNQUF2QyxDQUF0QjtBQUdBLFNBQU1DLGVBQWVGLGNBQWNHLFNBQWQsQ0FBd0J6a0QsUUFBUS9MLEtBQWhDLENBQXJCOztBQUVBLFNBQU15d0QsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTQyxNQUFULEVBQWlCO0FBQ3RDLFdBQU14dUQsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQW91RCxvQkFBYUksVUFBYjtBQUNBSixvQkFBYUssTUFBYixDQUFvQkYsTUFBcEIsRUFBNEIsVUFBU24xRCxDQUFULEVBQVlnekMsT0FBWixFQUFxQjtBQUMvQyxhQUFJaHpDLENBQUosRUFBTztBQUNMLDhCQUFJa0csS0FBSixDQUFVbEcsQ0FBVjtBQUNBMkcsYUFBRU0sTUFBRixDQUFTakgsQ0FBVDtBQUNELFVBSEQsTUFHTztBQUNMczFELDhCQUFtQnRpQixRQUFRdWlCLElBQTNCLEVBQ0N0dkQsSUFERCxDQUNNLFlBQVc7QUFDZitzQyxxQkFBUXVpQixJQUFSLENBQWFodUQsT0FBYixDQUFxQixVQUFTb0QsR0FBVCxFQUFjO0FBQ2pDLG1CQUFJLENBQUNBLElBQUk2cUQsV0FBVCxFQUFzQjdxRCxJQUFJNnFELFdBQUosR0FBa0I3cUQsSUFBSThxRCxRQUFKLElBQWdCOXFELElBQUlxVCxJQUF0QztBQUN0QixzQkFBT3JULElBQUk4cUQsUUFBWDtBQUNBLHNCQUFPOXFELElBQUlxVCxJQUFYO0FBQ0QsY0FKRDtBQUtBclgsZUFBRUksT0FBRixDQUFVaXNDLFFBQVF1aUIsSUFBbEI7QUFDRCxZQVJEO0FBU0Q7QUFDRixRQWZEO0FBZ0JBLGNBQU81dUQsRUFBRU8sT0FBVDtBQUNELE1BcEJEOztBQXNCQSxTQUFNVSxjQUFjLFNBQWRBLFdBQWMsQ0FBUzh0RCxNQUFULEVBQWlCQyxVQUFqQixFQUE2QkMsV0FBN0IsRUFBMEM7QUFDNUQsV0FBTWp2RCxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBLFdBQU11dUQsU0FBUztBQUNibHdELGdCQUFPMHdELFVBRE07QUFFYnIwQixrQkFBU28wQixPQUFPaDFELE1BQVAsR0FBZ0IsYUFBYWcxRCxNQUE3QixHQUFzQyxFQUZsQztBQUdiRSxzQkFBYUEsZUFBZTtBQUhmLFFBQWY7QUFLQSwwQkFBSTF2RCxLQUFKLENBQVVpdkQsTUFBVjtBQUNBRCxzQkFBZUMsTUFBZixFQUNDbHZELElBREQsQ0FDTSxVQUFTc3ZELElBQVQsRUFBZTtBQUNuQiw0QkFBSXJ2RCxLQUFKLENBQVVxdkQsSUFBVjtBQUNBNXVELFdBQUVJLE9BQUYsQ0FBVXd1RCxJQUFWO0FBQ0QsUUFKRCxFQUlHanZELEtBSkgsQ0FJUyxVQUFTdEcsQ0FBVCxFQUFZO0FBQ25CMkcsV0FBRU0sTUFBRixDQUFTakgsQ0FBVDtBQUNELFFBTkQ7QUFPQSxjQUFPMkcsRUFBRU8sT0FBVDtBQUNELE1BaEJEOztBQWtCQSxTQUFNb3VELHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQVNPLEtBQVQsRUFBZ0I7QUFDekMsV0FBTWx2RCxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBLFdBQU16RixPQUFPLElBQWI7QUFDQSxXQUFNZ3ZELFdBQVcsRUFBakI7QUFDQTBGLGFBQU10dUQsT0FBTixDQUFjLFVBQVN1dUQsSUFBVCxFQUFlO0FBQzNCQSxjQUFLQyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsYUFBSUQsS0FBS0UsU0FBVCxFQUFvQjtBQUNsQkYsZ0JBQUtFLFNBQUwsQ0FBZXp1RCxPQUFmLENBQXVCLFVBQVMrQyxHQUFULEVBQWM7QUFDbkNsSyxxQkFBUWhCLEdBQVIsQ0FBWWtMLEdBQVo7QUFDQSxpQkFBTXFKLElBQUksWUFBRS9NLEtBQUYsRUFBVjtBQUNBcXZELHFCQUFRM3JELEdBQVIsRUFIbUMsQ0FHdEI7QUFDYjtBQUNELFlBTEQ7QUFNRDtBQUNGLFFBVkQ7QUFXQSwwQkFBSXBFLEtBQUosQ0FBVWlxRCxRQUFWO0FBQ0EsbUJBQUVRLFVBQUYsQ0FBYVIsUUFBYixFQUNDbHFELElBREQsQ0FDTSxVQUFTNEIsT0FBVCxFQUFrQjtBQUN0QnpILGlCQUFRaEIsR0FBUixDQUFZeUksT0FBWjtBQUNBekgsaUJBQVFoQixHQUFSLENBQVl5MkQsS0FBWjtBQUNBbHZELFdBQUVJLE9BQUYsQ0FBVWMsT0FBVjtBQUNELFFBTEQsRUFLR3ZCLEtBTEgsQ0FLUyxVQUFTdEcsQ0FBVCxFQUFZO0FBQ25CLDRCQUFJa0csS0FBSixDQUFVbEcsQ0FBVjtBQUNBMkcsV0FBRU0sTUFBRixDQUFTakgsQ0FBVDtBQUNELFFBUkQ7QUFTQSxjQUFPMkcsRUFBRU8sT0FBVDtBQUNELE1BMUJEOztBQTRCQSxTQUFNK3VELFVBQVUsU0FBVkEsT0FBVSxDQUFTQyxRQUFULEVBQW1CO0FBQ2pDLFdBQU12dkQsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQW91RCxvQkFBYW1CLFNBQWIsQ0FBdUJELFFBQXZCLEVBQWlDLFVBQVNsMkQsQ0FBVCxFQUFZZ3pDLE9BQVosRUFBcUI7QUFDcEQsYUFBSWh6QyxDQUFKLEVBQU87QUFDTCw4QkFBSWtHLEtBQUosQ0FBVWxHLENBQVY7QUFDQTJHLGFBQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxVQUhELE1BR087QUFDTDJHLGFBQUVJLE9BQUYsQ0FBVWlzQyxPQUFWO0FBQ0Q7QUFDRixRQVBEO0FBUUEsY0FBT3JzQyxFQUFFTyxPQUFUO0FBQ0QsTUFYRDs7QUFhQSxTQUFNa3ZELGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBU1YsTUFBVCxFQUFpQkMsVUFBakIsRUFBNkI7QUFDbEQsV0FBTWh2RCxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBLFdBQU15dkQsWUFBWSxHQUFsQjtBQUNBLFdBQU1DLGtCQUFrQixFQUF4QjtBQUNBLFdBQU1WLGNBQWM5c0QsS0FBS3l0RCxHQUFMLENBQVN6dEQsS0FBS3VQLEdBQUwsQ0FBU3ZQLEtBQUswdEQsSUFBTCxDQUFVLE1BQU1iLFdBQVdqMUQsTUFBWCxHQUFvQjIxRCxTQUExQixDQUFWLENBQVQsRUFBMEQsQ0FBMUQsQ0FBVCxFQUF1RSxFQUF2RSxDQUFwQjtBQUNBLFlBQUssSUFBSTUxRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlrMUQsV0FBV2oxRCxNQUEvQixFQUF1Q0QsS0FBSzQxRCxTQUE1QyxFQUF1RDtBQUNyREMseUJBQWdCamxELElBQWhCLENBQXFCc2tELFdBQVcxeEIsU0FBWCxDQUFxQnhqQyxDQUFyQixFQUF3QkEsSUFBRTQxRCxTQUExQixDQUFyQjtBQUNEO0FBQ0QsV0FBTWxHLFdBQVdtRyxnQkFBZ0I3c0QsR0FBaEIsQ0FBb0IsVUFBU2d0RCxDQUFULEVBQVk1dUMsQ0FBWixFQUFlO0FBQ2xELGdCQUFPamdCLFlBQVk4dEQsTUFBWixFQUFvQmUsQ0FBcEIsRUFBdUJiLFdBQXZCLENBQVA7QUFDRCxRQUZnQixDQUFqQjtBQUdBLG1CQUFFakYsVUFBRixDQUFhUixRQUFiLEVBQ0NscUQsSUFERCxDQUNNLFVBQVM0QixPQUFULEVBQWtCO0FBQ3RCLGFBQUlBLFVBQVUsR0FBRzRFLE1BQUgsQ0FBVXhNLEtBQVYsQ0FBZ0IsRUFBaEIsRUFBb0I0SCxRQUFRNEIsR0FBUixDQUFZLFVBQVNpdEQsQ0FBVCxFQUFZO0FBQUMsa0JBQU9BLEVBQUV0dUQsS0FBVDtBQUFlLFVBQXhDLENBQXBCLENBQWQ7QUFDQVAsbUJBQVU4dUQsaUJBQWlCOXVELE9BQWpCLEVBQTBCLFVBQTFCLENBQVY7QUFDQSw0QkFBSTNCLEtBQUosQ0FBVTJCLE9BQVY7QUFDQWxCLFdBQUVJLE9BQUYsQ0FBVWMsT0FBVjtBQUNELFFBTkQsRUFPQ3ZCLEtBUEQsQ0FPTyxVQUFTdEcsQ0FBVCxFQUFZO0FBQ2pCLDRCQUFJa0csS0FBSixDQUFVbEcsQ0FBVjtBQUNELFFBVEQ7QUFVQSxjQUFPMkcsRUFBRU8sT0FBVDtBQUNELE1BdEJEOztBQXdCQSxTQUFNeXZELG1CQUFtQixTQUFuQkEsZ0JBQW1CLENBQVNDLGFBQVQsRUFBd0JDLE1BQXhCLEVBQWdDO0FBQ3ZELFdBQUlDLGVBQWUsRUFBbkI7QUFBQSxXQUF1QkMsU0FBUyxFQUFoQztBQUFBLFdBQW9DM3VELEtBQXBDO0FBQ0EsWUFBSSxJQUFJM0gsSUFBSSxDQUFaLEVBQWVBLElBQUltMkQsY0FBY2wyRCxNQUFqQyxFQUF5Q0QsR0FBekMsRUFBOEM7QUFDNUMySCxpQkFBUXd1RCxjQUFjbjJELENBQWQsRUFBaUJvMkQsTUFBakIsQ0FBUjtBQUNBLGFBQUdFLE9BQU81MEQsT0FBUCxDQUFlaUcsS0FBZixNQUEwQixDQUFDLENBQTlCLEVBQWlDO0FBQy9CMHVELHdCQUFhemxELElBQWIsQ0FBa0J1bEQsY0FBY24yRCxDQUFkLENBQWxCO0FBQ0FzMkQsa0JBQU8xbEQsSUFBUCxDQUFZakosS0FBWjtBQUNEO0FBQ0Y7QUFDRCxjQUFPMHVELFlBQVA7QUFDRCxNQVZEOztBQVlBLFNBQU1FLGVBQWUsU0FBZkEsWUFBZSxDQUFTN3ZELFFBQVQsRUFBbUJVLE9BQW5CLEVBQTRCO0FBQy9DO0FBQ0EsV0FBTW92RCxjQUFjLENBQ2xCLFdBRGtCLEVBRWxCLE9BRmtCLEVBR2xCLE1BSGtCLEVBSWxCLE1BSmtCLEVBS2xCLE1BTGtCLEVBTWxCLE1BTmtCLEVBT2xCLE1BUGtCLEVBUWxCLE1BUmtCLEVBU2xCLEtBVGtCLEVBVWxCLEtBVmtCLEVBV2xCLElBWGtCLEVBWWxCLElBWmtCLEVBYWxCLElBYmtCLENBQXBCO0FBZUEsV0FBTTFCLE9BQU8sRUFBYjtBQUNBMXRELGVBQVFOLE9BQVIsQ0FBZ0IsVUFBUzZPLE1BQVQsRUFBaUIzVixDQUFqQixFQUFvQjtBQUNsQyw0QkFBSXlGLEtBQUosQ0FBVSxLQUFWO0FBQ0EsNEJBQUlBLEtBQUosQ0FBVXpGLENBQVY7QUFDQSxhQUFJeTJELFFBQVEsRUFBWjtBQUNBOWdELGdCQUFPOEgsT0FBUCxDQUFlM1csT0FBZixDQUF1QixVQUFTeUQsQ0FBVCxFQUFZO0FBQ2pDLGVBQUk3RCxTQUFTZ3dELFFBQVQsQ0FBa0JoMUQsT0FBbEIsQ0FBMEI2SSxFQUFFNUMsS0FBNUIsSUFBcUMsQ0FBQyxDQUF0QyxJQUNEbXRELEtBQUtwekQsT0FBTCxDQUFhaVUsT0FBTzgvQyxRQUFwQixLQUFpQyxDQUFDLENBRGpDLElBRURsckQsRUFBRTVDLEtBRkQsSUFFVTRDLEVBQUU1QyxLQUFGLENBQVExSCxNQUFSLEdBQWlCLENBRjNCLElBR0R1MkQsWUFBWTkwRCxPQUFaLENBQW9CNkksRUFBRTVDLEtBQXRCLEtBQWdDLENBQUMsQ0FIaEMsSUFJRDh1RCxNQUFNLzBELE9BQU4sQ0FBYzZJLEVBQUU1QyxLQUFoQixLQUEwQixDQUFDLENBSjlCLEVBSWlDO0FBQy9CLGdDQUFJbEMsS0FBSixDQUFVOEUsRUFBRTVDLEtBQVo7QUFDQTh1RCxtQkFBTTdsRCxJQUFOLENBQVdyRyxFQUFFNUMsS0FBYjtBQUNBLGNBQUM0QyxFQUFFNUMsS0FBRixDQUFRMEksS0FBUixDQUFjLElBQWQsS0FBdUIsRUFBeEIsRUFBNEJ2SixPQUE1QixDQUFvQyxZQUFXO0FBQzdDMnZELHFCQUFNN2xELElBQU4sQ0FBV3JHLEVBQUU1QyxLQUFiO0FBQ0QsY0FGRDtBQUdEO0FBQ0YsVUFaRDtBQWFBLGFBQUk4dUQsTUFBTXgyRCxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsOEJBQUl3RixLQUFKLENBQVVrUSxPQUFPcS9DLFFBQWpCO0FBQ0FGLGdCQUFLbGtELElBQUwsQ0FBVStFLE1BQVY7QUFDRDtBQUNELDRCQUFJbFEsS0FBSixDQUFVLEtBQVY7QUFDRCxRQXRCRDs7QUF3QkE7QUFDQTtBQUNBLGNBQU8sRUFBUDtBQUNELE1BN0NEOztBQStDQSxTQUFNa3hELG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVMxQixNQUFULEVBQWlCdnVELFFBQWpCLEVBQTJCO0FBQ25ELFdBQU1SLElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0EsMEJBQUlWLEtBQUosQ0FBVWlCLFFBQVY7QUFDQSxXQUFNa3dELFVBQVVsd0QsU0FBU213RCxPQUFULENBQWlCeHNELE9BQWpCLENBQXlCLE1BQXpCLEVBQWdDLEVBQWhDLEVBQW9DQSxPQUFwQyxDQUE0QyxRQUE1QyxFQUFxRCxFQUFyRCxFQUF5REEsT0FBekQsQ0FBaUUsTUFBakUsRUFBd0UsRUFBeEUsQ0FBaEI7QUFDQSxXQUFNcXFELFNBQVM7QUFDYmx3RCxnQkFBTyxFQURNO0FBRWJxOEIsa0JBQVMsYUFBYW8wQixNQUFiLEdBQXNCLG9CQUF0QixHQUE2QzJCLE9BQTdDLEdBQXVELGtCQUF2RCxHQUE0RUEsT0FBNUUsR0FBc0Ysc0JBQXRGLEdBQStHQSxPQUEvRyxHQUF5SCx3QkFBekgsR0FBb0pBLE9BQXBKLEdBQThKLHNCQUE5SixHQUF1TEEsT0FBdkwsR0FBaU0sa0JBQWpNLEdBQXNOQSxPQUF0TixHQUFnTyxzQkFBaE8sR0FBeVBBLE9BQXpQLEdBQW1RLHdCQUFuUSxHQUE4UkEsT0FBOVIsR0FBd1M7QUFGcFMsUUFBZjtBQUlBLDBCQUFJbnhELEtBQUosQ0FBVSxRQUFWO0FBQ0EsMEJBQUlBLEtBQUosQ0FBVWl2RCxNQUFWO0FBQ0FELHNCQUFlQyxNQUFmLEVBQ0NsdkQsSUFERCxDQUNNLFVBQVNzeEQsU0FBVCxFQUFvQjtBQUN4Qiw0QkFBSXJ4RCxLQUFKLENBQVUsV0FBVjtBQUNBLDRCQUFJQSxLQUFKLENBQVVxeEQsU0FBVjtBQUNBNXdELFdBQUVJLE9BQUYsQ0FBVXd3RCxTQUFWO0FBQ0QsUUFMRCxFQUtHanhELEtBTEgsQ0FLUyxVQUFTdEcsQ0FBVCxFQUFZO0FBQ25CMkcsV0FBRU0sTUFBRixDQUFTakgsQ0FBVDtBQUNELFFBUEQ7QUFRQSxjQUFPMkcsRUFBRU8sT0FBVDtBQUNELE1BbkJEOztBQXFCQSxTQUFNZCxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVNzdkQsTUFBVCxFQUFpQnZ1RCxRQUFqQixFQUEyQnF3RCxZQUEzQixFQUF5QztBQUM5RCxXQUFNN3dELElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0E7QUFDQSxXQUFNNndELGNBQWM7QUFDbEJsQyxlQUFNLEVBRFk7QUFFbEJnQyxvQkFBVyxFQUZPO0FBR2xCRyxnQkFBTyxFQUhXO0FBSWxCQyxtQkFBVTtBQUpRLFFBQXBCO0FBTUEsMEJBQUl6eEQsS0FBSixDQUFVd3ZELE1BQVYsRUFBa0J2dUQsUUFBbEI7QUFDQSxXQUFNeXdELHFCQUFxQixDQUN6QixpQkFEeUIsRUFFekIsT0FGeUIsRUFHekIscUJBSHlCLEVBSXpCLFFBSnlCLEVBS3pCLE1BTHlCLEVBTXpCLFNBTnlCLEVBT3pCLFFBUHlCLEVBUXpCLE9BUnlCLEVBU3pCLFNBVHlCLEVBVXpCLFdBVnlCLEVBV3pCLFFBWHlCLEVBWXpCLE1BWnlCLEVBYXpCLHlDQWJ5QixFQWN6QixRQWR5QixFQWV6QixRQWZ5QixFQWdCekIsV0FoQnlCLEVBaUJ6QixNQWpCeUIsRUFrQnpCLGdDQWxCeUIsRUFtQnpCLElBbkJ5QixFQW9CekIsU0FwQnlCLEVBcUJ6QixRQXJCeUIsRUFzQnpCLGtCQXRCeUIsRUF1QnpCLG1CQXZCeUIsRUF3QnpCLHdCQXhCeUIsRUF5QnpCLFVBekJ5QixFQTBCekIsV0ExQnlCLEVBMkJ6QixTQTNCeUIsQ0FBM0I7QUE2QkFBLDBCQUFtQnJ3RCxPQUFuQixDQUEyQixVQUFTc3dELE1BQVQsRUFBaUI7QUFDMUMxd0Qsa0JBQVNnd0QsUUFBVCxHQUFvQmh3RCxTQUFTZ3dELFFBQVQsQ0FBa0Jyc0QsT0FBbEIsQ0FBMEIrc0QsTUFBMUIsRUFBa0MsRUFBbEMsQ0FBcEI7QUFDRCxRQUZEO0FBR0EsV0FBTVosY0FBYyxDQUNsQixHQURrQixFQUVsQixHQUZrQixFQUdsQixJQUhrQixFQUlsQixJQUprQixFQUtsQixJQUxrQixFQU1sQixJQU5rQixFQU9sQixJQVBrQixFQVFsQixJQVJrQixFQVNsQixLQVRrQixFQVVsQixLQVZrQixFQVdsQixLQVhrQixFQVlsQixLQVprQixFQWFsQixLQWJrQixFQWNsQixLQWRrQixFQWVsQixLQWZrQixFQWdCbEIsTUFoQmtCLEVBaUJsQixNQWpCa0IsRUFrQmxCLE1BbEJrQixFQW1CbEIsTUFuQmtCLEVBb0JsQixNQXBCa0IsRUFxQmxCLE9BckJrQixFQXNCbEIsV0F0QmtCLENBQXBCOztBQXlCQSxXQUFJO0FBQ0YsYUFBTWEsV0FBVyxFQUFqQjtBQUNBTixzQkFBYWp3RCxPQUFiLENBQXFCLFVBQVN1dUQsSUFBVCxFQUFlO0FBQ2xDLGVBQUlpQyxRQUFRLENBQVo7QUFDQWpDLGdCQUFLNTNDLE9BQUwsQ0FBYTNXLE9BQWIsQ0FBcUIsVUFBU3l3RCxNQUFULEVBQWlCO0FBQ3BDLGlCQUFNcnZELE1BQU1RLE9BQU82dUQsT0FBTzV2RCxLQUFkLENBQVo7QUFDQSxpQkFBSTZ1RCxZQUFZOTBELE9BQVosQ0FBb0J3RyxJQUFJa0IsV0FBSixFQUFwQixLQUEwQyxDQUFDLENBQTNDLElBQWdEbEIsSUFBSWpJLE1BQUosR0FBYSxDQUFqRSxFQUFvRTtBQUNsRSxtQkFBTXUzRCxNQUFNLElBQUk3aUMsTUFBSixDQUFXdy9CLGFBQWFqc0QsR0FBYixDQUFYLEVBQThCLElBQTlCLENBQVo7QUFDQSxtQkFBTXV2RCxTQUFTLENBQUMvd0QsU0FBU2d3RCxRQUFULENBQWtCcm1ELEtBQWxCLENBQXdCbW5ELEdBQXhCLEtBQWdDLEVBQWpDLEVBQXFDdjNELE1BQXJDLEdBQThDaUksSUFBSWpJLE1BQWpFO0FBQ0FxM0Qsd0JBQVNHLE1BQVQ7QUFDQSxtQkFBSUEsTUFBSixFQUFZO0FBQ1YscUJBQUlKLFNBQVMzMUQsT0FBVCxDQUFpQndHLEdBQWpCLEtBQXlCLENBQUMsQ0FBOUIsRUFBaUNtdkQsU0FBU3ptRCxJQUFULENBQWMxSSxHQUFkO0FBQ2xDO0FBQ0Y7QUFDRixZQVZEO0FBV0EsZUFBSW92RCxRQUFRLEdBQVosRUFBaUI7QUFDZk4seUJBQVlsQyxJQUFaLENBQWlCbGtELElBQWpCLENBQXNCeWtELElBQXRCO0FBQ0QsWUFGRCxNQUVPLElBQUlpQyxRQUFRLENBQVosRUFBZTtBQUNwQk4seUJBQVlFLFFBQVosQ0FBcUJ0bUQsSUFBckIsQ0FBMEJ5a0QsSUFBMUI7QUFDRDtBQUNGLFVBbEJEO0FBbUJBLDRCQUFJbDFELEtBQUosQ0FBVWszRCxRQUFWOztBQUVBTCxxQkFBWUYsU0FBWixHQUF3QkMsYUFBYS92RCxNQUFiLENBQW9CLFVBQVNxdUQsSUFBVCxFQUFlO0FBQ3pELGVBQU11QixVQUFVbHdELFNBQVNtd0QsT0FBVCxDQUFpQnhzRCxPQUFqQixDQUF5QixNQUF6QixFQUFnQyxFQUFoQyxFQUFvQ0EsT0FBcEMsQ0FBNEMsUUFBNUMsRUFBcUQsRUFBckQsRUFBeURBLE9BQXpELENBQWlFLE1BQWpFLEVBQXdFLEVBQXhFLENBQWhCO0FBQ0EsOEJBQUl0RixJQUFKLENBQVNzd0QsS0FBS3FDLFVBQWQ7QUFDQSxrQkFBT3JDLEtBQUtxQyxVQUFMLEtBQW9CckMsS0FBS3FDLFVBQUwsQ0FBZ0JoMkQsT0FBaEIsQ0FBd0JrMUQsT0FBeEIsSUFBbUMsQ0FBQyxDQUFwQyxJQUF5Q3ZCLEtBQUtxQyxVQUFMLENBQWdCaDJELE9BQWhCLENBQXdCazFELE9BQXhCLElBQW1DLENBQUMsQ0FBakcsQ0FBUDtBQUNELFVBSnVCLENBQXhCO0FBS0FJLHFCQUFZQyxLQUFaLEdBQW9CRCxZQUFZRixTQUFoQyxDQTVCRSxDQTRCd0M7QUFDMUNFLHFCQUFZQyxLQUFaLENBQWtCbndELE9BQWxCLENBQTBCLFVBQVM2d0QsSUFBVCxFQUFlO0FBQUVBLGdCQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQXVCLFVBQWxFO0FBQ0E7QUFDQVoscUJBQVlFLFFBQVosR0FBdUJoQixpQkFBaUJjLFlBQVlFLFFBQTdCLEVBQXVDLFVBQXZDLENBQXZCO0FBQ0EsNEJBQUkvMkQsS0FBSixDQUFVNjJELFdBQVY7QUFDQTl3RCxXQUFFSSxPQUFGLENBQVUwd0QsV0FBVjtBQUNELFFBbENELENBa0NFLE9BQU16M0QsQ0FBTixFQUFTO0FBQ1QsNEJBQUl1RyxLQUFKLENBQVV2RyxDQUFWO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFPMkcsRUFBRU8sT0FBVDtBQUNELE1BdElEOztBQXdJQSxVQUFLZ3VELGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0EsVUFBS3R0RCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLFVBQUt3dUQsY0FBTCxHQUFzQkEsY0FBdEI7QUFDQSxVQUFLaHdELGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0Q7QUE3VVksRUFBZjs7bUJBaVZleXVELE07Ozs7OztBQzNWZjs7QUFFQSxLQUFJeUQsZ0JBQWdCLG1CQUFBdEYsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsS0FBSXVGLHNCQUFzQixtQkFBQXZGLENBQVEsRUFBUixDQUExQjs7QUFFQTl6RCxRQUFPQyxPQUFQLEdBQWlCbzVELG9CQUFvQkQsYUFBcEIsQ0FBakIsQzs7Ozs7Ozs7OztBQ0xBcDVELFFBQU9DLE9BQVAsR0FBaUJtNUQsYUFBakI7O0FBRUEsS0FBSUUsUUFBUSxtQkFBQXhGLENBQVEsRUFBUixDQUFaO0FBQ0EsS0FBSXJJLFlBQVksbUJBQUFxSSxDQUFRLEVBQVIsQ0FBaEI7QUFDQSxLQUFJeUYsb0JBQW9CLG1CQUFBekYsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsS0FBSTBGLG9CQUFvQixtQkFBQTFGLENBQVEsRUFBUixDQUF4QjtBQUNBLEtBQUkyRixXQUFXLG1CQUFBM0YsQ0FBUSxFQUFSLENBQWY7QUFDQSxLQUFJclEsU0FBUyxtQkFBQXFRLENBQVEsRUFBUixDQUFiOztBQUVBLFVBQVNzRixhQUFULEdBQXlCO0FBQ3ZCSSxxQkFBa0J6NEQsS0FBbEIsQ0FBd0IsSUFBeEIsRUFBOEJDLFNBQTlCO0FBQ0Q7O0FBRUR5NEQsVUFBU0wsYUFBVCxFQUF3QkksaUJBQXhCOztBQUVBOzs7Ozs7OztBQVFBSixlQUFjeDRELFNBQWQsQ0FBd0I4NEQsV0FBeEIsR0FBc0MsVUFBU0MsU0FBVCxFQUFvQnZwQyxRQUFwQixFQUE4QjtBQUNsRSxVQUFPLEtBQUt3cEMsWUFBTCxDQUFrQjtBQUN2Qm41RCxhQUFRLFFBRGU7QUFFdkJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQjgyRCxTQUFuQixDQUZFO0FBR3ZCRSxlQUFVLE9BSGE7QUFJdkJ6cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUFQRDs7QUFTQTs7Ozs7Ozs7O0FBU0FncEMsZUFBY3g0RCxTQUFkLENBQXdCazVELFNBQXhCLEdBQW9DLFVBQVNDLFlBQVQsRUFBdUJDLFlBQXZCLEVBQXFDNXBDLFFBQXJDLEVBQStDO0FBQ2pGLE9BQUk2cEMsVUFBVTtBQUNaQyxnQkFBVyxNQURDLEVBQ09DLGFBQWFIO0FBRHBCLElBQWQ7QUFHQSxVQUFPLEtBQUtKLFlBQUwsQ0FBa0I7QUFDdkJuNUQsYUFBUSxNQURlO0FBRXZCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJrM0QsWUFBbkIsQ0FBaEIsR0FBbUQsWUFGakM7QUFHdkJybkIsV0FBTXVuQixPQUhpQjtBQUl2QkosZUFBVSxPQUphO0FBS3ZCenBDLGVBQVVBO0FBTGEsSUFBbEIsQ0FBUDtBQU9ELEVBWEQ7O0FBYUE7Ozs7Ozs7OztBQVNBZ3BDLGVBQWN4NEQsU0FBZCxDQUF3Qnc1RCxTQUF4QixHQUFvQyxVQUFTTCxZQUFULEVBQXVCQyxZQUF2QixFQUFxQzVwQyxRQUFyQyxFQUErQztBQUNqRixPQUFJNnBDLFVBQVU7QUFDWkMsZ0JBQVcsTUFEQyxFQUNPQyxhQUFhSDtBQURwQixJQUFkO0FBR0EsVUFBTyxLQUFLSixZQUFMLENBQWtCO0FBQ3ZCbjVELGFBQVEsTUFEZTtBQUV2Qm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CazNELFlBQW5CLENBQWhCLEdBQW1ELFlBRmpDO0FBR3ZCcm5CLFdBQU11bkIsT0FIaUI7QUFJdkJKLGVBQVUsT0FKYTtBQUt2QnpwQyxlQUFVQTtBQUxhLElBQWxCLENBQVA7QUFPRCxFQVhEOztBQWFBOzs7Ozs7Ozs7OztBQVdBZ3BDLGVBQWN4NEQsU0FBZCxDQUF3Qnk1RCxPQUF4QixHQUFrQyxVQUFTQyxNQUFULEVBQWlCOTRELE1BQWpCLEVBQXlCNHVCLFFBQXpCLEVBQW1DO0FBQ25FLE9BQUlnakIsUUFBUSxtQkFBQTBnQixDQUFRLEVBQVIsQ0FBWjtBQUNBLE9BQUltQyxTQUFTLEVBQWI7QUFDQSxPQUFJLFFBQU9xRSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDO0FBQzlCO0FBQ0FyRSxjQUFTN2lCLE1BQU1rbkIsTUFBTixDQUFUO0FBQ0FscUMsZ0JBQVc1dUIsTUFBWDtBQUNELElBSkQsTUFJTyxJQUFJUixVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU84NEQsTUFBUCxLQUFrQixVQUFoRCxFQUE0RDtBQUNqRTtBQUNBbHFDLGdCQUFXa3FDLE1BQVg7QUFDRCxJQUhNLE1BR0EsSUFBSXQ1RCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU9BLE1BQVAsS0FBa0IsVUFBaEQsRUFBNEQ7QUFDakU7QUFDQTR1QixnQkFBVzV1QixNQUFYO0FBQ0F5MEQsWUFBT3FFLE1BQVAsR0FBZ0JBLE1BQWhCO0FBQ0QsSUFKTSxNQUlBO0FBQ0w7QUFDQXJFLFlBQU9xRSxNQUFQLEdBQWdCQSxNQUFoQjtBQUNBckUsWUFBT3owRCxNQUFQLEdBQWdCQSxNQUFoQjtBQUNEOztBQUVELE9BQUl5MEQsT0FBT3FFLE1BQVAsS0FBa0JuNUQsU0FBdEIsRUFBaUM4MEQsT0FBT3FFLE1BQVAsR0FBZ0IsQ0FBaEI7QUFDakMsT0FBSXJFLE9BQU96MEQsTUFBUCxLQUFrQkwsU0FBdEIsRUFBaUM4MEQsT0FBT3owRCxNQUFQLEdBQWdCLEVBQWhCOztBQUVqQyxVQUFPLEtBQUtvNEQsWUFBTCxDQUFrQjtBQUN2Qm41RCxhQUFRLEtBRGU7QUFFdkJtRyxVQUFLLGFBQWEsS0FBSzJ6RCxnQkFBTCxDQUFzQnRFLE1BQXRCLEVBQThCLEVBQTlCLENBRks7QUFHdkI0RCxlQUFVLE1BSGE7QUFJdkJ6cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUE3QkQ7O0FBK0JBOzs7Ozs7OztBQVFBZ3BDLGVBQWN4NEQsU0FBZCxDQUF3QjQ1RCxXQUF4QixHQUFzQyxVQUFTQyxJQUFULEVBQWVycUMsUUFBZixFQUF5QjtBQUM3RCxPQUFJNmxDLFNBQVMsRUFBYjs7QUFFQSxPQUFJd0UsU0FBU3Q1RCxTQUFULElBQXNCLE9BQU9zNUQsSUFBUCxLQUFnQixVQUExQyxFQUFzRDtBQUNwRHJxQyxnQkFBV3FxQyxJQUFYO0FBQ0QsSUFGRCxNQUVPO0FBQ0x4RSxjQUFTLFdBQVd3RSxJQUFwQjtBQUNEOztBQUVELFVBQU8sS0FBS2IsWUFBTCxDQUFrQjtBQUN2Qm41RCxhQUFRLEtBRGU7QUFFdkJtRyxVQUFLLGVBQWVxdkQsTUFGRztBQUd2QjRELGVBQVUsTUFIYTtBQUl2QnpwQyxlQUFVQTtBQUphLElBQWxCLENBQVA7QUFNRCxFQWZEOztBQWlCQTs7Ozs7O0FBTUFncEMsZUFBY3g0RCxTQUFkLENBQXdCbTFELFNBQXhCLEdBQW9DLFVBQVM0RCxTQUFULEVBQW9CO0FBQ3RELFVBQU8sSUFBSUwsS0FBSixDQUFVLElBQVYsRUFBZ0JLLFNBQWhCLENBQVA7QUFDRCxFQUZEOztBQUlBOzs7QUFHQVAsZUFBY3g0RCxTQUFkLENBQXdCODVELFlBQXhCLEdBQXVDalAsVUFBVSxVQUFTcjdCLFFBQVQsRUFBbUI7QUFDbEUsVUFBTyxLQUFLdXFDLFdBQUwsQ0FBaUJ2cUMsUUFBakIsQ0FBUDtBQUNELEVBRnNDLEVBRXBDbXBDLGtCQUFrQix1QkFBbEIsRUFBMkMsc0JBQTNDLENBRm9DLENBQXZDOztBQUlBOzs7Ozs7O0FBT0FILGVBQWN4NEQsU0FBZCxDQUF3Qis1RCxXQUF4QixHQUFzQyxVQUFTdnFDLFFBQVQsRUFBbUI7QUFDdkQsVUFBTyxLQUFLd3BDLFlBQUwsQ0FBa0I7QUFDdkJuNUQsYUFBUSxLQURlO0FBRXZCbUcsVUFBSyxTQUZrQjtBQUd2Qml6RCxlQUFVLE1BSGE7QUFJdkJ6cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUFQRDs7QUFTQTs7O0FBR0FncEMsZUFBY3g0RCxTQUFkLENBQXdCZzZELGFBQXhCLEdBQXdDblAsVUFBVSxVQUFTcmdELEdBQVQsRUFBY2dsQixRQUFkLEVBQXdCO0FBQ3hFLFVBQU8sS0FBS3lxQyxTQUFMLENBQWV6dkQsR0FBZixFQUFvQmdsQixRQUFwQixDQUFQO0FBQ0QsRUFGdUMsRUFFckNtcEMsa0JBQWtCLHdCQUFsQixFQUE0QyxvQkFBNUMsQ0FGcUMsQ0FBeEM7O0FBSUE7Ozs7Ozs7O0FBUUFILGVBQWN4NEQsU0FBZCxDQUF3Qmk2RCxTQUF4QixHQUFvQyxVQUFTenZELEdBQVQsRUFBY2dsQixRQUFkLEVBQXdCO0FBQzFELFVBQU8sS0FBS3dwQyxZQUFMLENBQWtCO0FBQ3ZCbjVELGFBQVEsS0FEZTtBQUV2Qm1HLFVBQUssYUFBYXdFLEdBRks7QUFHdkJ5dUQsZUFBVSxNQUhhO0FBSXZCenBDLGVBQVVBO0FBSmEsSUFBbEIsQ0FBUDtBQU1ELEVBUEQ7O0FBU0E7OztBQUdBZ3BDLGVBQWN4NEQsU0FBZCxDQUF3Qms2RCxhQUF4QixHQUF3Q3JQLFVBQVUsVUFBU3JnRCxHQUFULEVBQWNnbEIsUUFBZCxFQUF3QjtBQUN4RSxVQUFPLEtBQUsycUMsWUFBTCxDQUFrQjN2RCxHQUFsQixFQUF1QmdsQixRQUF2QixDQUFQO0FBQ0QsRUFGdUMsRUFFckNtcEMsa0JBQWtCLHdCQUFsQixFQUE0Qyx1QkFBNUMsQ0FGcUMsQ0FBeEM7O0FBSUE7Ozs7Ozs7QUFPQUgsZUFBY3g0RCxTQUFkLENBQXdCbTZELFlBQXhCLEdBQXVDLFVBQVMzdkQsR0FBVCxFQUFjZ2xCLFFBQWQsRUFBd0I7QUFDN0QsVUFBTyxLQUFLd3BDLFlBQUwsQ0FBa0I7QUFDdkJuNUQsYUFBUSxRQURlO0FBRXZCbUcsVUFBSyxhQUFhd0UsR0FGSztBQUd2Qnl1RCxlQUFVLE9BSGE7QUFJdkJ6cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUFQRDs7QUFTQTs7O0FBR0FncEMsZUFBY3g0RCxTQUFkLENBQXdCbzZELFVBQXhCLEdBQXFDdlAsVUFBVSxVQUFTd1AsSUFBVCxFQUFlaEYsTUFBZixFQUF1QjdsQyxRQUF2QixFQUFpQztBQUM5RSxVQUFPLEtBQUs4cUMsU0FBTCxDQUFlRCxJQUFmLEVBQXFCaEYsTUFBckIsRUFBNkI3bEMsUUFBN0IsQ0FBUDtBQUNELEVBRm9DLEVBRWxDbXBDLGtCQUFrQixxQkFBbEIsRUFBeUMsb0JBQXpDLENBRmtDLENBQXJDOztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBSCxlQUFjeDRELFNBQWQsQ0FBd0JzNkQsU0FBeEIsR0FBb0MsVUFBU0QsSUFBVCxFQUFlaEYsTUFBZixFQUF1QjdsQyxRQUF2QixFQUFpQztBQUNuRSxPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJcUgsUUFBUSwwREFBWjs7QUFFQSxPQUFJLENBQUNydEQsUUFBUW10RCxJQUFSLENBQUwsRUFBb0I7QUFDbEIsV0FBTSxJQUFJMVYsS0FBSixDQUFVNFYsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsT0FBSW42RCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU95MEQsTUFBUCxLQUFrQixVQUFoRCxFQUE0RDtBQUMxRDdsQyxnQkFBVzZsQyxNQUFYO0FBQ0FBLGNBQVMsSUFBVDtBQUNEOztBQUVELE9BQUlnRSxVQUFVO0FBQ1ptQixVQUFLSDtBQURPLElBQWQ7O0FBSUEsT0FBSWhGLE1BQUosRUFBWTtBQUNWZ0UsYUFBUW9CLFFBQVIsR0FBbUJwRixPQUFPb0YsUUFBMUI7QUFDQXBCLGFBQVFxQixzQkFBUixHQUFpQ3JGLE9BQU9xRixzQkFBeEM7QUFDQXJCLGFBQVFzQixlQUFSLEdBQTBCdEYsT0FBT3NGLGVBQWpDO0FBQ0F0QixhQUFRdUIsT0FBUixHQUFrQnZGLE9BQU91RixPQUF6QjtBQUNBdkIsYUFBUTNELFdBQVIsR0FBc0JMLE9BQU9LLFdBQTdCOztBQUVBLFNBQUlMLE9BQU93RixlQUFYLEVBQTRCO0FBQzFCeEIsZUFBUXdCLGVBQVIsR0FBMEIsS0FBS2xCLGdCQUFMLENBQXNCdEUsT0FBT3dGLGVBQTdCLEVBQThDLEVBQTlDLENBQTFCO0FBQ0Q7O0FBRUR4QixhQUFReUIsUUFBUixHQUFtQnpGLE9BQU95RixRQUExQjtBQUNEOztBQUVELFVBQU8sS0FBSzlCLFlBQUwsQ0FBa0I7QUFDdkJuNUQsYUFBUSxNQURlO0FBRXZCbUcsVUFBSyxTQUZrQjtBQUd2QjhyQyxXQUFNdW5CLE9BSGlCO0FBSXZCSixlQUFVLE9BSmE7QUFLdkJ6cEMsZUFBVUE7QUFMYSxJQUFsQixDQUFQO0FBT0QsRUF0Q0Q7O0FBd0NBOzs7QUFHQWdwQyxlQUFjeDRELFNBQWQsQ0FBd0IrNkQsc0JBQXhCLEdBQWlEbFEsVUFBVSxVQUFTd1AsSUFBVCxFQUFlaEYsTUFBZixFQUF1QjdsQyxRQUF2QixFQUFpQztBQUMxRixVQUFPLEtBQUs4cUMsU0FBTCxDQUFlRCxJQUFmLEVBQXFCaEYsTUFBckIsRUFBNkI3bEMsUUFBN0IsQ0FBUDtBQUNELEVBRmdELEVBRTlDbXBDLGtCQUFrQixpQ0FBbEIsRUFBcUQsb0JBQXJELENBRjhDLENBQWpEOztBQUlBOzs7QUFHQUgsZUFBY3g0RCxTQUFkLENBQXdCZzdELGFBQXhCLEdBQXdDblEsVUFBVSxVQUFTcmdELEdBQVQsRUFBYzZ2RCxJQUFkLEVBQW9CaEYsTUFBcEIsRUFBNEI3bEMsUUFBNUIsRUFBc0M7QUFDdEYsVUFBTyxLQUFLeXJDLFlBQUwsQ0FBa0J6d0QsR0FBbEIsRUFBdUI2dkQsSUFBdkIsRUFBNkJoRixNQUE3QixFQUFxQzdsQyxRQUFyQyxDQUFQO0FBQ0QsRUFGdUMsRUFFckNtcEMsa0JBQWtCLHdCQUFsQixFQUE0Qyx1QkFBNUMsQ0FGcUMsQ0FBeEM7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0FILGVBQWN4NEQsU0FBZCxDQUF3Qmk3RCxZQUF4QixHQUF1QyxVQUFTendELEdBQVQsRUFBYzZ2RCxJQUFkLEVBQW9CaEYsTUFBcEIsRUFBNEI3bEMsUUFBNUIsRUFBc0M7QUFDM0UsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXFILFFBQVEsa0VBQVo7O0FBRUEsT0FBSSxDQUFDcnRELFFBQVFtdEQsSUFBUixDQUFMLEVBQW9CO0FBQ2xCLFdBQU0sSUFBSTFWLEtBQUosQ0FBVTRWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUluNkQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPeTBELE1BQVAsS0FBa0IsVUFBaEQsRUFBNEQ7QUFDMUQ3bEMsZ0JBQVc2bEMsTUFBWDtBQUNBQSxjQUFTLElBQVQ7QUFDRDs7QUFFRCxPQUFJNkYsU0FBUztBQUNYVixVQUFLSDtBQURNLElBQWI7O0FBSUEsT0FBSWhGLE1BQUosRUFBWTtBQUNWNkYsWUFBT1QsUUFBUCxHQUFrQnBGLE9BQU9vRixRQUF6QjtBQUNBUyxZQUFPUixzQkFBUCxHQUFnQ3JGLE9BQU9xRixzQkFBdkM7QUFDQVEsWUFBT1AsZUFBUCxHQUF5QnRGLE9BQU9zRixlQUFoQztBQUNBTyxZQUFPTixPQUFQLEdBQWlCdkYsT0FBT3VGLE9BQXhCO0FBQ0FNLFlBQU94RixXQUFQLEdBQXFCTCxPQUFPSyxXQUE1Qjs7QUFFQSxTQUFJTCxPQUFPd0YsZUFBWCxFQUE0QjtBQUMxQkssY0FBT0wsZUFBUCxHQUF5QixLQUFLbEIsZ0JBQUwsQ0FBc0J0RSxPQUFPd0YsZUFBN0IsRUFBOEMsRUFBOUMsQ0FBekI7QUFDRDs7QUFFREssWUFBT0osUUFBUCxHQUFrQnpGLE9BQU95RixRQUF6QjtBQUNEOztBQUVELFVBQU8sS0FBSzlCLFlBQUwsQ0FBa0I7QUFDdkJuNUQsYUFBUSxLQURlO0FBRXZCbUcsVUFBSyxhQUFhd0UsR0FGSztBQUd2QnNuQyxXQUFNb3BCLE1BSGlCO0FBSXZCakMsZUFBVSxPQUphO0FBS3ZCenBDLGVBQVVBO0FBTGEsSUFBbEIsQ0FBUDtBQU9ELEVBdENEOztBQXdDQTs7OztBQUlBZ3BDLGVBQWN4NEQsU0FBZCxDQUF3Qm03RCxpQkFBeEIsR0FBNEN0USxVQUFVLFNBQVN1USwyQkFBVCxHQUF1QztBQUMzRixRQUFLQyxNQUFMLEdBQWMsRUFBZDtBQUNELEVBRjJDLEVBRXpDMUMsa0JBQWtCLDRCQUFsQixFQUFnRCxpQkFBaEQsQ0FGeUMsQ0FBNUM7O0FBSUE7Ozs7QUFJQUgsZUFBY3g0RCxTQUFkLENBQXdCczdELGVBQXhCLEdBQTBDelEsVUFBVSxTQUFTMFEseUJBQVQsQ0FBbUN4QyxTQUFuQyxFQUE4QzV6RCxLQUE5QyxFQUFxRGlSLElBQXJELEVBQTJEO0FBQzdHLFFBQUtpbEQsTUFBTCxDQUFZOXBELElBQVosQ0FBaUI7QUFDZnduRCxnQkFBV0EsU0FESTtBQUVmNXpELFlBQU9BLEtBRlE7QUFHZmt3RCxhQUFRai9DO0FBSE8sSUFBakI7QUFLRCxFQU55QyxFQU12Q3VpRCxrQkFBa0IsMEJBQWxCLEVBQThDLGlCQUE5QyxDQU51QyxDQUExQzs7QUFRQTs7OztBQUlBSCxlQUFjeDRELFNBQWQsQ0FBd0J3N0QsZ0JBQXhCLEdBQTJDM1EsVUFBVSxTQUFTNFEsMEJBQVQsQ0FBb0Nqc0MsUUFBcEMsRUFBOEM7QUFDakcsVUFBTyxLQUFLK2xDLE1BQUwsQ0FBWSxLQUFLOEYsTUFBakIsRUFBeUI3ckMsUUFBekIsQ0FBUDtBQUNELEVBRjBDLEVBRXhDbXBDLGtCQUFrQiwyQkFBbEIsRUFBK0MsaUJBQS9DLENBRndDLENBQTNDOztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0FILGVBQWN4NEQsU0FBZCxDQUF3QjA3RCxLQUF4QixHQUFnQyxVQUFTQyxVQUFULEVBQXFCbnNDLFFBQXJCLEVBQStCO0FBQzdELE9BQUl0aUIsVUFBVSxtQkFBQWdtRCxDQUFRLEVBQVIsQ0FBZDtBQUNBLE9BQUlxSCxRQUFRLDZDQUFaOztBQUVBLE9BQUksQ0FBQ3J0RCxRQUFReXVELFVBQVIsQ0FBTCxFQUEwQjtBQUN4QixXQUFNLElBQUloWCxLQUFKLENBQVU0VixLQUFWLENBQU47QUFDRDs7QUFFRCxVQUFPLEtBQUt2QixZQUFMLENBQWtCO0FBQ3ZCbjVELGFBQVEsTUFEZTtBQUV2Qm1HLFVBQUssb0JBRmtCO0FBR3ZCOHJDLFdBQU07QUFDSjhwQixpQkFBVUQ7QUFETixNQUhpQjtBQU12QjFDLGVBQVUsT0FOYTtBQU92QnpwQyxlQUFVQTtBQVBhLElBQWxCLENBQVA7QUFTRCxFQWpCRDs7QUFtQkE7QUFDQWdwQyxlQUFjeDRELFNBQWQsQ0FBd0JvdUIsT0FBeEIsR0FBa0N5dEMsY0FBbEM7QUFDQXJELGVBQWN4NEQsU0FBZCxDQUF3Qjg3RCxzQkFBeEIsR0FBaURELGNBQWpEO0FBQ0FyRCxlQUFjeDRELFNBQWQsQ0FBd0IrN0QsdUJBQXhCLEdBQWtERixjQUFsRDtBQUNBckQsZUFBY3g0RCxTQUFkLENBQXdCZzhELGdCQUF4QixHQUEyQ0gsY0FBM0M7QUFDQXJELGVBQWN4NEQsU0FBZCxDQUF3Qmk4RCxvQkFBeEIsR0FBK0NKLGNBQS9DO0FBQ0FyRCxlQUFjeDRELFNBQWQsQ0FBd0JrOEQscUJBQXhCLEdBQWdETCxjQUFoRDs7QUFFQSxVQUFTQSxjQUFULEdBQTBCO0FBQ3hCLE9BQUkxUCxVQUFVLDJDQUNaLDZEQURGOztBQUdBLFNBQU0sSUFBSXRKLE9BQU9zWixrQkFBWCxDQUE4QmhRLE9BQTlCLENBQU47QUFDRCxFOzs7Ozs7Ozs7O0FDM2VELEtBQUkwTSxXQUFXLG1CQUFBM0YsQ0FBUSxFQUFSLENBQWY7QUFDQSxLQUFJa0osWUFBWSxtQkFBQWxKLENBQVEsRUFBUixDQUFoQjtBQUNBLEtBQUlySSxZQUFZLG1CQUFBcUksQ0FBUSxFQUFSLENBQWhCO0FBQ0EsS0FBSXlGLG9CQUFvQixtQkFBQXpGLENBQVEsRUFBUixDQUF4QjtBQUNBLEtBQUltSixjQUFjLG1CQUFBbkosQ0FBUSxFQUFSLENBQWxCO0FBQ0EsS0FBSXJRLFNBQVMsbUJBQUFxUSxDQUFRLEVBQVIsQ0FBYjs7QUFFQSxLQUFJb0osMkJBQTJCelIsVUFDN0IsWUFBVyxDQUFFLENBRGdCLEVBRTdCOE4sa0JBQWtCLGlCQUFsQixFQUFxQyxtQkFBckMsQ0FGNkIsQ0FBL0I7O0FBS0F2NUQsUUFBT0MsT0FBUCxHQUFpQnE1RCxLQUFqQjs7QUFFQSxVQUFTQSxLQUFULEdBQWlCO0FBQ2YwRCxhQUFVajhELEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0JDLFNBQXRCO0FBQ0Q7O0FBRUR5NEQsVUFBU0gsS0FBVCxFQUFnQjBELFNBQWhCOztBQUVBOzs7Ozs7Ozs7O0FBVUExRCxPQUFNMTRELFNBQU4sQ0FBZ0J1OEQsU0FBaEIsR0FBNEIsVUFBU3JwQixPQUFULEVBQWtCa2pCLFFBQWxCLEVBQTRCNW1DLFFBQTVCLEVBQXNDO0FBQ2hFLE9BQUlndEMsV0FBVyxJQUFmOztBQUVBLE9BQUlwOEQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPdzFELFFBQVAsS0FBb0IsVUFBbEQsRUFBOEQ7QUFDNUQ1bUMsZ0JBQVc0bUMsUUFBWDtBQUNBQSxnQkFBVzcxRCxTQUFYO0FBQ0Q7O0FBRUQsVUFBTyxLQUFLazhELEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUXUyRCxhQUFhNzFELFNBQWIsR0FDUixLQURRLEdBQ0E7QUFDUixXQUgwQixFQUdsQjtBQUNSeUYsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBU3pELFNBQTVCLENBQWhCLEtBQXlEO0FBQzdEM0Msa0JBQWE3MUQsU0FBYixHQUF5QixNQUFNMEIsbUJBQW1CbTBELFFBQW5CLENBQS9CLEdBQThELEVBRDFELENBSnFCLEVBSzBDO0FBQ3BFdGtCLFdBQU1vQixPQU5vQjtBQU8xQitsQixlQUFVLE9BUGdCO0FBUTFCenBDLGVBQVVBO0FBUmdCLElBQXJCLENBQVA7QUFVRCxFQWxCRDs7QUFvQkE7Ozs7Ozs7O0FBUUFrcEMsT0FBTTE0RCxTQUFOLENBQWdCMDhELFVBQWhCLEdBQTZCLFVBQVNDLE9BQVQsRUFBa0JudEMsUUFBbEIsRUFBNEI7QUFDdkQsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXFILFFBQVEscURBQVo7O0FBRUEsT0FBSSxDQUFDcnRELFFBQVF5dkQsT0FBUixDQUFMLEVBQXVCO0FBQ3JCLFdBQU0sSUFBSWhZLEtBQUosQ0FBVTRWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUlpQyxXQUFXLElBQWY7QUFDQSxPQUFJbkQsVUFBVTtBQUNadUMsZUFBVTtBQURFLElBQWQ7QUFHQSxRQUFLLElBQUlqN0QsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZzhELFFBQVEvN0QsTUFBNUIsRUFBb0MsRUFBRUQsQ0FBdEMsRUFBeUM7QUFDdkMsU0FBSWtGLFVBQVU7QUFDWkwsZUFBUSxXQURJO0FBRVpzc0MsYUFBTTZxQixRQUFRaDhELENBQVI7QUFGTSxNQUFkO0FBSUEwNEQsYUFBUXVDLFFBQVIsQ0FBaUJycUQsSUFBakIsQ0FBc0IxTCxPQUF0QjtBQUNEO0FBQ0QsVUFBTyxLQUFLNDJELEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCxRQUZwQztBQUcxQmpuQixXQUFNdW5CLE9BSG9CO0FBSTFCSixlQUFVLE9BSmdCO0FBSzFCenBDLGVBQVVBO0FBTGdCLElBQXJCLENBQVA7QUFPRCxFQTFCRDs7QUE0QkE7Ozs7Ozs7Ozs7QUFVQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0I0OEQsbUJBQWhCLEdBQXNDLFVBQVNDLGFBQVQsRUFBd0JDLGlCQUF4QixFQUEyQ3R0QyxRQUEzQyxFQUFxRDtBQUN6RixPQUFJcHZCLFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBT2s4RCxpQkFBUCxLQUE2QixVQUEzRCxFQUF1RTtBQUNyRXR0QyxnQkFBV3N0QyxpQkFBWDtBQUNBQSx5QkFBb0J2OEQsU0FBcEI7QUFDRDs7QUFFRCxPQUFJaThELFdBQVcsSUFBZjtBQUNBLE9BQUl4MkQsTUFBTSxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBU3pELFNBQTVCLENBQWhCLEdBQXlELEdBQXpELEdBQStEOTJELG1CQUFtQjQ2RCxjQUFjekcsUUFBakMsQ0FBL0QsR0FBNEcsVUFBdEg7QUFDQSxPQUFJMEcsc0JBQXNCLEtBQTFCLEVBQWlDO0FBQy9COTJELFlBQU8sMEJBQVA7QUFDRDs7QUFFRCxVQUFPLEtBQUt5MkQsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBS0EsR0FGcUI7QUFHMUI4ckMsV0FBTStxQixhQUhvQjtBQUkxQjVELGVBQVUsT0FKZ0I7QUFLMUJ6cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBbkJEOztBQXFCQTs7Ozs7Ozs7QUFRQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0IrOEQsb0JBQWhCLEdBQXVDLFVBQVNKLE9BQVQsRUFBa0JHLGlCQUFsQixFQUFxQ3R0QyxRQUFyQyxFQUErQztBQUNwRixPQUFJcHZCLFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBT2s4RCxpQkFBUCxLQUE2QixVQUEzRCxFQUF1RTtBQUNyRXR0QyxnQkFBV3N0QyxpQkFBWDtBQUNBQSx5QkFBb0IsSUFBcEI7QUFDRDs7QUFFRCxPQUFJNXZELFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJcUgsUUFBUSwrREFBWjs7QUFFQSxPQUFJLENBQUNydEQsUUFBUXl2RCxPQUFSLENBQUwsRUFBdUI7QUFDckIsV0FBTSxJQUFJaFksS0FBSixDQUFVNFYsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsT0FBSWlDLFdBQVcsSUFBZjtBQUNBLE9BQUluRCxVQUFVO0FBQ1p1QyxlQUFVO0FBREUsSUFBZDtBQUdBLFFBQUssSUFBSWo3RCxJQUFJLENBQWIsRUFBZ0JBLElBQUlnOEQsUUFBUS83RCxNQUE1QixFQUFvQyxFQUFFRCxDQUF0QyxFQUF5QztBQUN2QyxTQUFJa0YsVUFBVTtBQUNaTCxlQUFRczNELHNCQUFzQixJQUF0QixHQUE2QixxQkFBN0IsR0FBcUQsNkJBRGpEO0FBRVoxRyxpQkFBVXVHLFFBQVFoOEQsQ0FBUixFQUFXeTFELFFBRlQ7QUFHWnRrQixhQUFNNnFCLFFBQVFoOEQsQ0FBUjtBQUhNLE1BQWQ7QUFLQTA0RCxhQUFRdUMsUUFBUixDQUFpQnJxRCxJQUFqQixDQUFzQjFMLE9BQXRCO0FBQ0Q7QUFDRCxVQUFPLEtBQUs0MkQsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBU3pELFNBQTVCLENBQWhCLEdBQXlELFFBRnBDO0FBRzFCam5CLFdBQU11bkIsT0FIb0I7QUFJMUJKLGVBQVUsT0FKZ0I7QUFLMUJ6cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBaENEOztBQWtDQTs7Ozs7Ozs7QUFRQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0JnOUQsVUFBaEIsR0FBNkIsVUFBU2hVLE1BQVQsRUFBaUJ4NUIsUUFBakIsRUFBMkI7QUFDdEQsT0FBSWd0QyxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCxHQUF6RCxHQUErRDkyRCxtQkFBbUIrbUQsT0FBT29OLFFBQTFCLENBRjFDO0FBRzFCdGtCLFdBQU1rWCxNQUhvQjtBQUkxQmlRLGVBQVUsT0FKZ0I7QUFLMUJ6cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBVEQ7O0FBV0E7Ozs7Ozs7O0FBUUFrcEMsT0FBTTE0RCxTQUFOLENBQWdCaTlELFdBQWhCLEdBQThCLFVBQVNOLE9BQVQsRUFBa0JudEMsUUFBbEIsRUFBNEI7QUFDeEQsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXFILFFBQVEsc0RBQVo7O0FBRUEsT0FBSSxDQUFDcnRELFFBQVF5dkQsT0FBUixDQUFMLEVBQXVCO0FBQ3JCLFdBQU0sSUFBSWhZLEtBQUosQ0FBVTRWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUlpQyxXQUFXLElBQWY7QUFDQSxPQUFJbkQsVUFBVTtBQUNadUMsZUFBVTtBQURFLElBQWQ7QUFHQSxRQUFLLElBQUlqN0QsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZzhELFFBQVEvN0QsTUFBNUIsRUFBb0MsRUFBRUQsQ0FBdEMsRUFBeUM7QUFDdkMsU0FBSWtGLFVBQVU7QUFDWkwsZUFBUSxjQURJO0FBRVo0d0QsaUJBQVV1RyxRQUFRaDhELENBQVIsRUFBV3kxRCxRQUZUO0FBR1p0a0IsYUFBTTZxQixRQUFRaDhELENBQVI7QUFITSxNQUFkO0FBS0EwNEQsYUFBUXVDLFFBQVIsQ0FBaUJycUQsSUFBakIsQ0FBc0IxTCxPQUF0QjtBQUNEO0FBQ0QsVUFBTyxLQUFLNDJELEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCxRQUZwQztBQUcxQmpuQixXQUFNdW5CLE9BSG9CO0FBSTFCSixlQUFVLE9BSmdCO0FBSzFCenBDLGVBQVVBO0FBTGdCLElBQXJCLENBQVA7QUFPRCxFQTNCRDs7QUE2QkE7Ozs7Ozs7O0FBUUFrcEMsT0FBTTE0RCxTQUFOLENBQWdCazlELFlBQWhCLEdBQStCLFVBQVM5RyxRQUFULEVBQW1CNW1DLFFBQW5CLEVBQTZCO0FBQzFELE9BQUksT0FBTzRtQyxRQUFQLEtBQW9CLFVBQXBCLElBQWtDLE9BQU9BLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0MsT0FBT0EsUUFBUCxLQUFvQixRQUExRixFQUFvRztBQUNsRyxTQUFJM2tELE1BQU0sSUFBSW94QyxPQUFPc1osa0JBQVgsQ0FBOEIsNkNBQTlCLENBQVY7QUFDQTNzQyxnQkFBVzRtQyxRQUFYO0FBQ0EsU0FBSSxPQUFPNW1DLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsY0FBT0EsU0FBUy9kLEdBQVQsQ0FBUDtBQUNEOztBQUVELFlBQU8sS0FBS2dyRCxFQUFMLENBQVFVLFFBQVIsQ0FBaUJoMkQsTUFBakIsQ0FBd0JzSyxHQUF4QixDQUFQO0FBQ0Q7O0FBRUQsT0FBSStxRCxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxRQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCxHQUF6RCxHQUErRDkyRCxtQkFBbUJtMEQsUUFBbkIsQ0FGMUM7QUFHMUI2QyxlQUFVLE9BSGdCO0FBSTFCenBDLGVBQVVBO0FBSmdCLElBQXJCLENBQVA7QUFNRCxFQWxCRDs7QUFvQkE7Ozs7Ozs7O0FBUUFrcEMsT0FBTTE0RCxTQUFOLENBQWdCbzlELGFBQWhCLEdBQWdDLFVBQVNDLFNBQVQsRUFBb0I3dEMsUUFBcEIsRUFBOEI7QUFDNUQsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXZwRCxNQUFNLG1CQUFBdXBELENBQVEsRUFBUixDQUFWOztBQUVBLE9BQUlxSCxRQUFRLDBEQUFaOztBQUVBLE9BQUksQ0FBQ3J0RCxRQUFRbXdELFNBQVIsQ0FBTCxFQUF5QjtBQUN2QixXQUFNLElBQUkxWSxLQUFKLENBQVU0VixLQUFWLENBQU47QUFDRDs7QUFFRCxPQUFJaUMsV0FBVyxJQUFmO0FBQ0EsT0FBSW5ELFVBQVU7QUFDWnVDLGVBQVVqeUQsSUFBSTB6RCxTQUFKLEVBQWUsU0FBU0MsY0FBVCxDQUF3QmxILFFBQXhCLEVBQWtDO0FBQ3pELGNBQU87QUFDTDV3RCxpQkFBUSxjQURIO0FBRUw0d0QsbUJBQVVBLFFBRkw7QUFHTHRrQixlQUFNO0FBQ0pza0IscUJBQVVBO0FBRE47QUFIRCxRQUFQO0FBT0QsTUFSUztBQURFLElBQWQ7O0FBWUEsVUFBTyxLQUFLcUcsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBU3pELFNBQTVCLENBQWhCLEdBQXlELFFBRnBDO0FBRzFCam5CLFdBQU11bkIsT0FIb0I7QUFJMUJKLGVBQVUsT0FKZ0I7QUFLMUJ6cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBOUJEOztBQWdDQTs7Ozs7Ozs7QUFRQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0J1OUQsYUFBaEIsR0FBZ0MsVUFBU3A0RCxLQUFULEVBQWdCa3dELE1BQWhCLEVBQXdCN2xDLFFBQXhCLEVBQWtDO0FBQ2hFLE9BQUlnakIsUUFBUSxtQkFBQTBnQixDQUFRLEVBQVIsQ0FBWjtBQUNBLE9BQUl2cEQsTUFBTSxtQkFBQXVwRCxDQUFRLEVBQVIsQ0FBVjs7QUFFQSxPQUFJc0osV0FBVyxJQUFmO0FBQ0EsT0FBSWdCLFNBQVNoQixTQUFTQyxFQUF0Qjs7QUFFQSxPQUFJcjhELFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBT3kwRCxNQUFQLEtBQWtCLFVBQWhELEVBQTREO0FBQzFEN2xDLGdCQUFXNmxDLE1BQVg7QUFDQUEsY0FBUyxFQUFUO0FBQ0QsSUFIRCxNQUdPO0FBQ0xBLGNBQVM3aUIsTUFBTTZpQixNQUFOLENBQVQ7QUFDRDs7QUFFREEsVUFBT29JLG9CQUFQLEdBQThCLFVBQTlCO0FBQ0FwSSxVQUFPUyxXQUFQLEdBQXFCLElBQXJCO0FBQ0FULFVBQU9xSSxRQUFQLEdBQWtCLEtBQWxCOztBQUVBO0FBQ0E7QUFDQSxRQUFLcEksVUFBTDs7QUFFQTtBQUNBO0FBQ0EsT0FBSWx1RCxVQUFVLEtBQ2JtdUQsTUFEYSxDQUNOcHdELEtBRE0sRUFDQ2t3RCxNQURELEVBRWJsdkQsSUFGYSxDQUVSdzNELFlBRlEsQ0FBZDs7QUFJQSxZQUFTQSxZQUFULENBQXNCQyxhQUF0QixFQUFxQztBQUNuQztBQUNBLFNBQUlBLGNBQWNDLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFDOUI7QUFDQSxjQUFPRCxhQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFJUCxZQUFZMXpELElBQUlpMEQsY0FBY25JLElBQWxCLEVBQXdCLFNBQVNxSSxXQUFULENBQXFCOVUsTUFBckIsRUFBNkI7QUFDbkUsY0FBT0EsT0FBT29OLFFBQWQ7QUFDRCxNQUZlLENBQWhCOztBQUlBLFlBQU9vRyxTQUNOWSxhQURNLENBQ1FDLFNBRFIsRUFFTmwzRCxJQUZNLENBRUQ0M0QsUUFGQyxFQUdONTNELElBSE0sQ0FHRDYzRCxlQUhDLENBQVA7QUFJRDs7QUFFRCxZQUFTRCxRQUFULENBQWtCRSxvQkFBbEIsRUFBd0M7QUFDdEMsWUFBT3pCLFNBQVN1QixRQUFULENBQWtCRSxxQkFBcUJDLE1BQXZDLENBQVA7QUFDRDs7QUFFRCxZQUFTRixlQUFULEdBQTJCO0FBQ3pCLFlBQU94QixTQUFTZSxhQUFULENBQXVCcDRELEtBQXZCLEVBQThCa3dELE1BQTlCLENBQVA7QUFDRDs7QUFFRCxPQUFJLENBQUM3bEMsUUFBTCxFQUFlO0FBQ2IsWUFBT3BvQixPQUFQO0FBQ0Q7O0FBRURBLFdBQVFqQixJQUFSLENBQWFnNEQsT0FBYixFQUFzQkMsT0FBdEI7O0FBRUEsWUFBU0QsT0FBVCxHQUFtQjtBQUNqQjlCLGlCQUFZLFNBQVM3VSxJQUFULEdBQWdCO0FBQzFCaDRCLGdCQUFTLElBQVQ7QUFDRCxNQUZELEVBRUdndUMsT0FBT2EsV0FBUCxJQUFzQnRxRCxVQUZ6QjtBQUdEOztBQUVELFlBQVNxcUQsT0FBVCxDQUFpQjNzRCxHQUFqQixFQUFzQjtBQUNwQjRxRCxpQkFBWSxTQUFTN1UsSUFBVCxHQUFnQjtBQUMxQmg0QixnQkFBUy9kLEdBQVQ7QUFDRCxNQUZELEVBRUcrckQsT0FBT2EsV0FBUCxJQUFzQnRxRCxVQUZ6QjtBQUdEO0FBQ0YsRUF2RUQ7O0FBeUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0Eya0QsT0FBTTE0RCxTQUFOLENBQWdCcytELFNBQWhCLEdBQTRCLFVBQVNuNUQsS0FBVCxFQUFnQjAxRCxlQUFoQixFQUFpQztBQUMzRCxPQUFJLFFBQU8xMUQsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFyQixFQUErQjtBQUM3QjAxRCx1QkFBa0IxMUQsS0FBbEI7QUFDQUEsYUFBUTVFLFNBQVI7QUFDRDs7QUFFRCxPQUFJZytELFFBQVEsbUJBQUFyTCxDQUFRLEVBQVIsQ0FBWjs7QUFFQSxPQUFJc0wsZUFBZSxtQkFBQXRMLENBQVEsRUFBUixDQUFuQjs7QUFFQSxPQUFJeE4sVUFBVSxJQUFJOFksWUFBSixFQUFkO0FBQ0EsT0FBSWhCLFNBQVMsS0FBS2YsRUFBbEI7QUFDQSxPQUFJOTNELFFBQVEsSUFBWjtBQUNBLE9BQUkwd0QsU0FBU21JLE9BQU83RCxnQkFBUCxDQUNYNEUsTUFBTSxFQUFOLEVBQVUxRCxtQkFBbUIsRUFBN0IsRUFBaUM7QUFDL0IxMUQsWUFBT0E7QUFEd0IsSUFBakMsQ0FEVyxFQUdQLEVBSE8sQ0FBYjs7QUFNQTtBQUNBczVEOztBQUVBLFlBQVNBLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCO0FBQzFCLFNBQUloWixRQUFRaVosUUFBWixFQUFzQjtBQUNwQjtBQUNEOztBQUVELFNBQUk3c0IsSUFBSjs7QUFFQSxTQUFJNHNCLFdBQVduK0QsU0FBZixFQUEwQjtBQUN4QnV4QyxjQUFPO0FBQ0w0c0IsaUJBQVFBO0FBREgsUUFBUDtBQUdELE1BSkQsTUFJTztBQUNMNXNCLGNBQU87QUFDTHVqQixpQkFBUUE7QUFESCxRQUFQO0FBR0Q7O0FBRURtSSxZQUFPeEUsWUFBUCxDQUFvQjtBQUNsQm41RCxlQUFRLE1BRFU7QUFFbEJtRyxZQUFLLGdCQUFnQi9ELG1CQUFtQjBDLE1BQU1vMEQsU0FBekIsQ0FBaEIsR0FBc0QsU0FGekM7QUFHbEJFLGlCQUFVLE1BSFE7QUFJbEJubkIsYUFBTUEsSUFKWTtBQUtsQnRpQixpQkFBVW92QztBQUxRLE1BQXBCO0FBT0Q7O0FBRUQsWUFBU0EsY0FBVCxDQUF3Qm50RCxHQUF4QixFQUE2QnloQyxPQUE3QixFQUFzQztBQUNwQyxTQUFJd1MsUUFBUWlaLFFBQVosRUFBc0I7QUFDcEI7QUFDRDs7QUFFRCxTQUFJbHRELEdBQUosRUFBUztBQUNQaTBDLGVBQVFtWixNQUFSLENBQWVwdEQsR0FBZjtBQUNBO0FBQ0Q7O0FBRURpMEMsYUFBUW9aLE9BQVIsQ0FBZ0I1ckIsT0FBaEI7O0FBRUE7QUFDQSxTQUFJQSxRQUFRd3JCLE1BQVIsS0FBbUJuK0QsU0FBdkIsRUFBa0M7QUFDaENtbEQsZUFBUXFaLElBQVI7QUFDQTtBQUNEOztBQUVETixnQkFBV3ZyQixRQUFRd3JCLE1BQW5CO0FBQ0Q7O0FBRUQsVUFBT2haLE9BQVA7QUFDRCxFQXRFRDs7QUF3RUE7Ozs7QUFJQWdULE9BQU0xNEQsU0FBTixDQUFnQmcvRCxTQUFoQixHQUE0Qm5VLFVBQVUsVUFBU3dLLE1BQVQsRUFBaUI7QUFDckQsT0FBSWgwRCxPQUFPLElBQVg7QUFDQSxVQUFPLFNBQVMyOUQsU0FBVCxDQUFtQjc1RCxLQUFuQixFQUEwQjg1RCxNQUExQixFQUFrQ0MsT0FBbEMsRUFBMkM7QUFDaEQsU0FBSTFxRCxFQUFKOztBQUVBLFNBQUksT0FBTzBxRCxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2pDO0FBQ0ExcUQsWUFBSzBxRCxPQUFMO0FBQ0QsTUFIRCxNQUdPO0FBQ0w7QUFDQTFxRCxZQUFLeXFELE1BQUw7QUFDRDs7QUFFRDU5RCxVQUFLazBELE1BQUwsQ0FBWXB3RCxLQUFaLEVBQW1Ca3dELE1BQW5CLEVBQTJCLFNBQVM4SixVQUFULENBQW9CMXRELEdBQXBCLEVBQXlCeWhDLE9BQXpCLEVBQWtDO0FBQzNELFdBQUl6aEMsR0FBSixFQUFTO0FBQ1ArQyxZQUFHL0MsR0FBSDtBQUNBO0FBQ0Q7O0FBRUQrQyxVQUFHMCtCLFFBQVF1aUIsSUFBWDtBQUNELE1BUEQ7QUFRRCxJQW5CRDtBQW9CRCxFQXRCMkIsRUF1QjVCLGtGQUNBLDZFQXhCNEIsQ0FBNUI7O0FBMEJBOzs7Ozs7Ozs7QUFTQWlELE9BQU0xNEQsU0FBTixDQUFnQis5RCxRQUFoQixHQUEyQixVQUFTRyxNQUFULEVBQWlCMXVDLFFBQWpCLEVBQTJCO0FBQ3BEO0FBQ0EsT0FBSTR2QyxZQUFZLEdBQWhCO0FBQ0E7QUFDQSxPQUFJQyxXQUFXLElBQWY7QUFDQSxPQUFJL3pDLE9BQU8sQ0FBWDs7QUFFQTtBQUNBO0FBQ0EsT0FBSWt4QyxXQUFXLElBQWY7QUFDQSxPQUFJZ0IsU0FBU2hCLFNBQVNDLEVBQXRCOztBQUVBLE9BQUlyMUQsVUFBVWs0RCxXQUFkOztBQUVBLFlBQVNBLFNBQVQsR0FBcUI7QUFDbkIsWUFBTzlCLE9BQU94RSxZQUFQLENBQW9CO0FBQ3pCbjVELGVBQVEsS0FEaUI7QUFFekJvNUQsaUJBQVUsTUFGZTtBQUd6Qmp6RCxZQUFLLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTekQsU0FBNUIsQ0FBaEIsR0FBeUQsUUFBekQsR0FBb0VtRjtBQUhoRCxNQUFwQixFQUlKLzNELElBSkksQ0FJQyxTQUFTZzRELE9BQVQsQ0FBaUJqckIsT0FBakIsRUFBMEI7QUFDaEM1bkI7QUFDQSxXQUFJekksUUFBUXU4QyxZQUFZOXpDLElBQVosR0FBbUJBLElBQS9CO0FBQ0EsV0FBSXpJLFFBQVF3OEMsUUFBWixFQUFzQjtBQUNwQng4QyxpQkFBUXc4QyxRQUFSO0FBQ0Q7O0FBRUQsV0FBSW5zQixRQUFRcXNCLE1BQVIsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbEMsZ0JBQU8vQixPQUFPTCxRQUFQLENBQWdCdDZDLEtBQWhCLENBQXNCQSxLQUF0QixFQUE2QjFjLElBQTdCLENBQWtDbTVELFNBQWxDLENBQVA7QUFDRDs7QUFFRCxjQUFPcHNCLE9BQVA7QUFDRCxNQWhCTSxDQUFQO0FBaUJEOztBQUVELE9BQUksQ0FBQzFqQixRQUFMLEVBQWU7QUFDYixZQUFPcG9CLE9BQVA7QUFDRDs7QUFFREEsV0FBUWpCLElBQVIsQ0FBYXE1RCxTQUFiLEVBQXdCQyxTQUF4Qjs7QUFFQSxZQUFTRCxTQUFULENBQW1CdHNCLE9BQW5CLEVBQTRCO0FBQzFCbXBCLGlCQUFZLFNBQVM3VSxJQUFULEdBQWdCO0FBQzFCaDRCLGdCQUFTLElBQVQsRUFBZTBqQixPQUFmO0FBQ0QsTUFGRCxFQUVHc3FCLE9BQU9hLFdBQVAsSUFBc0J0cUQsVUFGekI7QUFHRDs7QUFFRCxZQUFTMHJELFNBQVQsQ0FBbUJodUQsR0FBbkIsRUFBd0I7QUFDdEI0cUQsaUJBQVksU0FBUzdVLElBQVQsR0FBZ0I7QUFDMUJoNEIsZ0JBQVMvZCxHQUFUO0FBQ0QsTUFGRCxFQUVHK3JELE9BQU9hLFdBQVAsSUFBc0J0cUQsVUFGekI7QUFHRDtBQUNGLEVBbkREOztBQXFEQTs7Ozs7OztBQU9BMmtELE9BQU0xNEQsU0FBTixDQUFnQjAvRCxVQUFoQixHQUE2QixVQUFTbHdDLFFBQVQsRUFBbUI7QUFDOUMsT0FBSWd0QyxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCxRQUZwQztBQUcxQkUsZUFBVSxPQUhnQjtBQUkxQnpwQyxlQUFVQTtBQUpnQixJQUFyQixDQUFQO0FBTUQsRUFSRDs7QUFVQTs7Ozs7OztBQU9Ba3BDLE9BQU0xNEQsU0FBTixDQUFnQjIvRCxXQUFoQixHQUE4QixVQUFTbndDLFFBQVQsRUFBbUI7QUFDL0MsT0FBSWd0QyxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCx3QkFGcEM7QUFHMUJFLGVBQVUsTUFIZ0I7QUFJMUJ6cEMsZUFBVUE7QUFKZ0IsSUFBckIsQ0FBUDtBQU1ELEVBUkQ7O0FBVUFrcEMsT0FBTTE0RCxTQUFOLENBQWdCNC9ELGNBQWhCLEdBQWlDLFVBQVN2SyxNQUFULEVBQWlCN2xDLFFBQWpCLEVBQTJCO0FBQzFELE9BQUksT0FBTzZsQyxNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQ2hDN2xDLGdCQUFXNmxDLE1BQVg7QUFDQUEsY0FBUyxFQUFUO0FBQ0QsSUFIRCxNQUdPLElBQUlBLFdBQVc5MEQsU0FBZixFQUEwQjtBQUMvQjgwRCxjQUFTLEVBQVQ7QUFDRDs7QUFFRCxVQUFPLEtBQUtvSCxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELGtCQUZoQztBQUcxQmpuQixXQUFNdWpCLE1BSG9CO0FBSTFCNEQsZUFBVSxNQUpnQjtBQUsxQnpwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFmRDs7QUFpQkFrcEMsT0FBTTE0RCxTQUFOLENBQWdCNi9ELFdBQWhCLEdBQThCLFVBQVNDLE9BQVQsRUFBa0J0dEQsSUFBbEIsRUFBd0JnZCxRQUF4QixFQUFrQztBQUM5RCxPQUFJLE9BQU9oZCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCZ2QsZ0JBQVdoZCxJQUFYO0FBQ0FBLFlBQU8sRUFBUDtBQUNELElBSEQsTUFHTyxJQUFJQSxTQUFTalMsU0FBYixFQUF3QjtBQUM3QmlTLFlBQU8sRUFBUDtBQUNEOztBQUVELE9BQUlBLEtBQUt1dEQsZUFBTCxLQUF5QngvRCxTQUE3QixFQUF3Qys3RDtBQUN4QyxPQUFJMEQsb0JBQXFCeHRELEtBQUt1dEQsZUFBTCxJQUF3QnZ0RCxLQUFLd3RELGlCQUE5QixHQUFtRCxNQUFuRCxHQUE0RCxPQUFwRjs7QUFFQSxVQUFPLEtBQUt2RCxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsS0FEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELFlBQXJELEdBQW9FOTJELG1CQUFtQjY5RCxRQUFRMUosUUFBM0IsQ0FBcEUsR0FDSCxxQkFERyxHQUNxQjRKLGlCQUhBO0FBSTFCbHVCLFdBQU1ndUIsT0FKb0I7QUFLMUI3RyxlQUFVLE9BTGdCO0FBTTFCenBDLGVBQVVBO0FBTmdCLElBQXJCLENBQVA7QUFRRCxFQW5CRDs7QUFxQkFrcEMsT0FBTTE0RCxTQUFOLENBQWdCaWdFLFVBQWhCLEdBQTZCLFVBQVM3SixRQUFULEVBQW1CNW1DLFFBQW5CLEVBQTZCO0FBQ3hELFVBQU8sS0FBS2l0QyxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsS0FEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELFlBQXJELEdBQW9FOTJELG1CQUFtQm0wRCxRQUFuQixDQUYvQztBQUcxQjZDLGVBQVUsTUFIZ0I7QUFJMUJ6cEMsZUFBVUE7QUFKZ0IsSUFBckIsQ0FBUDtBQU1ELEVBUEQ7O0FBU0FrcEMsT0FBTTE0RCxTQUFOLENBQWdCa2dFLGFBQWhCLEdBQWdDLFVBQVM5SixRQUFULEVBQW1CNWpELElBQW5CLEVBQXlCZ2QsUUFBekIsRUFBbUM7QUFDakUsT0FBSSxPQUFPaGQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJQSxLQUFLdXRELGVBQUwsS0FBeUJ4L0QsU0FBN0IsRUFBd0MrN0Q7QUFDeEMsT0FBSTBELG9CQUFxQnh0RCxLQUFLdXRELGVBQUwsSUFBd0J2dEQsS0FBS3d0RCxpQkFBOUIsR0FBbUQsTUFBbkQsR0FBNEQsT0FBcEY7O0FBRUEsVUFBTyxLQUFLdkQsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLFFBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzgyRCxTQUF4QixDQUFoQixHQUFxRCxZQUFyRCxHQUFvRTkyRCxtQkFBbUJtMEQsUUFBbkIsQ0FBcEUsR0FDSCxxQkFERyxHQUNxQjRKLGlCQUhBO0FBSTFCL0csZUFBVSxPQUpnQjtBQUsxQnpwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFsQkQ7O0FBb0JBa3BDLE9BQU0xNEQsU0FBTixDQUFnQm1nRSxhQUFoQixHQUFnQyxVQUFTM3RELElBQVQsRUFBZWdkLFFBQWYsRUFBeUI7QUFDdkQsT0FBSSxPQUFPaGQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJQSxLQUFLdXRELGVBQUwsS0FBeUJ4L0QsU0FBN0IsRUFBd0MrN0Q7QUFDeEMsT0FBSTBELG9CQUFxQnh0RCxLQUFLdXRELGVBQUwsSUFBd0J2dEQsS0FBS3d0RCxpQkFBOUIsR0FBbUQsTUFBbkQsR0FBNEQsT0FBcEY7O0FBRUEsVUFBTyxLQUFLdkQsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzgyRCxTQUF4QixDQUFoQixHQUFxRCxpQkFBckQsR0FDSCxxQkFERyxHQUNxQmlILGlCQUhBO0FBSTFCL0csZUFBVSxPQUpnQjtBQUsxQnpwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFsQkQ7O0FBb0JBa3BDLE9BQU0xNEQsU0FBTixDQUFnQm9nRSxhQUFoQixHQUFnQyxVQUFTQyxRQUFULEVBQW1CN3RELElBQW5CLEVBQXlCZ2QsUUFBekIsRUFBbUM7QUFDakUsT0FBSSxPQUFPaGQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJQSxLQUFLdXRELGVBQUwsS0FBeUJ4L0QsU0FBN0IsRUFBd0MrN0Q7QUFDeEMsT0FBSTBELG9CQUFxQnh0RCxLQUFLdXRELGVBQUwsSUFBd0J2dEQsS0FBS3d0RCxpQkFBOUIsR0FBbUQsTUFBbkQsR0FBNEQsT0FBcEY7O0FBRUEsVUFBTyxLQUFLdkQsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzgyRCxTQUF4QixDQUFoQixHQUFxRCxpQkFBckQsR0FDSCxxQkFERyxHQUNxQmlILGlCQURyQixHQUVILDJCQUZHLElBRTRCeHRELEtBQUs4dEQsdUJBQUwsR0FBK0IsTUFBL0IsR0FBd0MsT0FGcEUsQ0FGcUI7QUFLMUJySCxlQUFVLE9BTGdCO0FBTTFCbm5CLFdBQU11dUIsUUFOb0I7QUFPMUI3d0MsZUFBVUE7QUFQZ0IsSUFBckIsQ0FBUDtBQVNELEVBcEJEOztBQXNCQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0J1Z0UsV0FBaEIsR0FBOEIsVUFBU2xMLE1BQVQsRUFBaUI3bEMsUUFBakIsRUFBMkI7QUFDdkQsT0FBSSxPQUFPNmxDLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDaEM3bEMsZ0JBQVc2bEMsTUFBWDtBQUNBQSxjQUFTLEVBQVQ7QUFDRCxJQUhELE1BR08sSUFBSUEsV0FBVzkwRCxTQUFmLEVBQTBCO0FBQy9CODBELGNBQVMsRUFBVDtBQUNEOztBQUVELFVBQU8sS0FBS29ILEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs4MkQsU0FBeEIsQ0FBaEIsR0FBcUQsZUFGaEM7QUFHMUJqbkIsV0FBTXVqQixNQUhvQjtBQUkxQjRELGVBQVUsTUFKZ0I7QUFLMUJ6cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBZkQ7O0FBaUJBa3BDLE9BQU0xNEQsU0FBTixDQUFnQndnRSxRQUFoQixHQUEyQixVQUFTQyxJQUFULEVBQWVqdUQsSUFBZixFQUFxQmdkLFFBQXJCLEVBQStCO0FBQ3hELE9BQUksT0FBT2hkLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUJnZCxnQkFBV2hkLElBQVg7QUFDQUEsWUFBTyxFQUFQO0FBQ0QsSUFIRCxNQUdPLElBQUlBLFNBQVNqUyxTQUFiLEVBQXdCO0FBQzdCaVMsWUFBTyxFQUFQO0FBQ0Q7O0FBRUQsT0FBSXd0RCxvQkFBb0J4dEQsS0FBS3d0RCxpQkFBTCxLQUEyQixJQUEzQixHQUFrQyxNQUFsQyxHQUEyQyxPQUFuRTs7QUFFQSxVQUFPLEtBQUt2RCxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsS0FEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELFNBQXJELEdBQWlFOTJELG1CQUFtQncrRCxLQUFLckssUUFBeEIsQ0FBakUsR0FDSCxxQkFERyxHQUNxQjRKLGlCQUhBO0FBSTFCbHVCLFdBQU0ydUIsSUFKb0I7QUFLMUJ4SCxlQUFVLE9BTGdCO0FBTTFCenBDLGVBQVVBO0FBTmdCLElBQXJCLENBQVA7QUFRRCxFQWxCRDs7QUFvQkFrcEMsT0FBTTE0RCxTQUFOLENBQWdCMGdFLE9BQWhCLEdBQTBCLFVBQVN0SyxRQUFULEVBQW1CNW1DLFFBQW5CLEVBQTZCO0FBQ3JELFVBQU8sS0FBS2l0QyxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsS0FEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELFNBQXJELEdBQWlFOTJELG1CQUFtQm0wRCxRQUFuQixDQUY1QztBQUcxQjZDLGVBQVUsTUFIZ0I7QUFJMUJ6cEMsZUFBVUE7QUFKZ0IsSUFBckIsQ0FBUDtBQU1ELEVBUEQ7O0FBU0FrcEMsT0FBTTE0RCxTQUFOLENBQWdCMmdFLFVBQWhCLEdBQTZCLFVBQVN2SyxRQUFULEVBQW1CNWpELElBQW5CLEVBQXlCZ2QsUUFBekIsRUFBbUM7QUFDOUQsT0FBSSxPQUFPaGQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJd3RELG9CQUFvQnh0RCxLQUFLd3RELGlCQUFMLEtBQTJCLElBQTNCLEdBQWtDLE1BQWxDLEdBQTJDLE9BQW5FOztBQUVBLFVBQU8sS0FBS3ZELEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxRQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs4MkQsU0FBeEIsQ0FBaEIsR0FBcUQsU0FBckQsR0FBaUU5MkQsbUJBQW1CbTBELFFBQW5CLENBQWpFLEdBQ0gscUJBREcsR0FDcUI0SixpQkFIQTtBQUkxQi9HLGVBQVUsT0FKZ0I7QUFLMUJ6cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBakJEOztBQW1CQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0I0Z0UsVUFBaEIsR0FBNkIsVUFBU3B1RCxJQUFULEVBQWVnZCxRQUFmLEVBQXlCO0FBQ3BELE9BQUksT0FBT2hkLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUJnZCxnQkFBV2hkLElBQVg7QUFDQUEsWUFBTyxFQUFQO0FBQ0QsSUFIRCxNQUdPLElBQUlBLFNBQVNqUyxTQUFiLEVBQXdCO0FBQzdCaVMsWUFBTyxFQUFQO0FBQ0Q7O0FBRUQsT0FBSXd0RCxvQkFBb0J4dEQsS0FBS3d0RCxpQkFBTCxLQUEyQixJQUEzQixHQUFrQyxNQUFsQyxHQUEyQyxPQUFuRTs7QUFFQSxVQUFPLEtBQUt2RCxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELGNBQXJELEdBQ0gscUJBREcsR0FDcUJpSCxpQkFIQTtBQUkxQi9HLGVBQVUsT0FKZ0I7QUFLMUJ6cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBakJEOztBQW1CQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0I2Z0UsVUFBaEIsR0FBNkIsVUFBU0MsS0FBVCxFQUFnQnR1RCxJQUFoQixFQUFzQmdkLFFBQXRCLEVBQWdDO0FBQzNELE9BQUksT0FBT2hkLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUJnZCxnQkFBV2hkLElBQVg7QUFDQUEsWUFBTyxFQUFQO0FBQ0QsSUFIRCxNQUdPLElBQUlBLFNBQVNqUyxTQUFiLEVBQXdCO0FBQzdCaVMsWUFBTyxFQUFQO0FBQ0Q7O0FBRUQsT0FBSXd0RCxvQkFBb0J4dEQsS0FBS3d0RCxpQkFBTCxLQUEyQixJQUEzQixHQUFrQyxNQUFsQyxHQUEyQyxPQUFuRTs7QUFFQSxVQUFPLEtBQUt2RCxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELGNBQXJELEdBQ0gscUJBREcsR0FDcUJpSCxpQkFEckIsR0FFSCxzQkFGRyxJQUV1Qnh0RCxLQUFLdXVELGtCQUFMLEtBQTRCLElBQTVCLEdBQW1DLE1BQW5DLEdBQTRDLE9BRm5FLENBRnFCO0FBSzFCOUgsZUFBVSxPQUxnQjtBQU0xQm5uQixXQUFNZ3ZCLEtBTm9CO0FBTzFCdHhDLGVBQVVBO0FBUGdCLElBQXJCLENBQVA7QUFTRCxFQW5CRDs7QUFxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUVBa3BDLE9BQU0xNEQsU0FBTixDQUFnQmdoRSxXQUFoQixHQUE4QixVQUFTQyxRQUFULEVBQW1CenVELElBQW5CLEVBQXlCZ2QsUUFBekIsRUFBbUM7QUFDL0QsT0FBSXB2QixVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU80UixJQUFQLEtBQWdCLFVBQTlDLEVBQTBEO0FBQ3hEZ2QsZ0JBQVdoZCxJQUFYO0FBQ0FBLFlBQU8sRUFBUDtBQUNEOztBQUVELE9BQUlBLEtBQUt1dEQsZUFBTCxLQUF5QngvRCxTQUE3QixFQUF3Qys3RDtBQUN4QyxPQUFJMEQsb0JBQXFCeHRELEtBQUt1dEQsZUFBTCxJQUF3QnZ0RCxLQUFLd3RELGlCQUE5QixHQUFtRCxNQUFuRCxHQUE0RCxPQUFwRjs7QUFFQSxPQUFJeEQsV0FBVyxJQUFmO0FBQ0EsVUFBTyxLQUFLQyxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsS0FEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTekQsU0FBNUIsQ0FBaEIsR0FBeUQsOEJBQXpELEdBQ0RpSCxpQkFIc0I7QUFJMUIvRyxlQUFVLE9BSmdCO0FBSzFCbm5CLFdBQU1tdkIsUUFMb0I7QUFNMUJ6eEMsZUFBVUE7QUFOZ0IsSUFBckIsQ0FBUDtBQVFELEVBbEJEOztBQW9CQTs7O0FBR0FrcEMsT0FBTTE0RCxTQUFOLENBQWdCODVELFlBQWhCLEdBQStCalAsVUFBVSxVQUFTcjdCLFFBQVQsRUFBbUI7QUFDMUQsVUFBTyxLQUFLdXFDLFdBQUwsQ0FBaUJ2cUMsUUFBakIsQ0FBUDtBQUNELEVBRjhCLEVBRTVCbXBDLGtCQUFrQixzQkFBbEIsRUFBMEMscUJBQTFDLENBRjRCLENBQS9COztBQUlBOzs7Ozs7O0FBT0FELE9BQU0xNEQsU0FBTixDQUFnQis1RCxXQUFoQixHQUE4QixVQUFTdnFDLFFBQVQsRUFBbUI7QUFDL0MsT0FBSWd0QyxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCxPQUZwQztBQUcxQkUsZUFBVSxNQUhnQjtBQUkxQnpwQyxlQUFVQTtBQUpnQixJQUFyQixDQUFQO0FBTUQsRUFSRDs7QUFVQTs7O0FBR0FrcEMsT0FBTTE0RCxTQUFOLENBQWdCZzZELGFBQWhCLEdBQWdDblAsVUFBVSxVQUFTcmdELEdBQVQsRUFBY2dsQixRQUFkLEVBQXdCO0FBQ2hFLFVBQU8sS0FBS3lxQyxTQUFMLENBQWV6dkQsR0FBZixFQUFvQmdsQixRQUFwQixDQUFQO0FBQ0QsRUFGK0IsRUFFN0JtcEMsa0JBQWtCLHVCQUFsQixFQUEyQyxtQkFBM0MsQ0FGNkIsQ0FBaEM7O0FBS0E7Ozs7Ozs7O0FBUUFELE9BQU0xNEQsU0FBTixDQUFnQmk2RCxTQUFoQixHQUE0QixVQUFTenZELEdBQVQsRUFBY2dsQixRQUFkLEVBQXdCO0FBQ2xELE9BQUlndEMsV0FBVyxJQUFmO0FBQ0EsVUFBTyxLQUFLQyxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsS0FEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTekQsU0FBNUIsQ0FBaEIsR0FBeUQsUUFBekQsR0FBb0V2dUQsR0FGL0M7QUFHMUJ5dUQsZUFBVSxNQUhnQjtBQUkxQnpwQyxlQUFVQTtBQUpnQixJQUFyQixDQUFQO0FBTUQsRUFSRDs7QUFVQTs7O0FBR0FrcEMsT0FBTTE0RCxTQUFOLENBQWdCazZELGFBQWhCLEdBQWdDclAsVUFBVSxVQUFTcmdELEdBQVQsRUFBY2dsQixRQUFkLEVBQXdCO0FBQ2hFLFVBQU8sS0FBSzJxQyxZQUFMLENBQWtCM3ZELEdBQWxCLEVBQXVCZ2xCLFFBQXZCLENBQVA7QUFDRCxFQUYrQixFQUU3Qm1wQyxrQkFBa0IsdUJBQWxCLEVBQTJDLHNCQUEzQyxDQUY2QixDQUFoQzs7QUFJQTs7Ozs7Ozs7QUFRQUQsT0FBTTE0RCxTQUFOLENBQWdCbTZELFlBQWhCLEdBQStCLFVBQVMzdkQsR0FBVCxFQUFjZ2xCLFFBQWQsRUFBd0I7QUFDckQsT0FBSWd0QyxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxRQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVN6RCxTQUE1QixDQUFoQixHQUF5RCxRQUF6RCxHQUFvRXZ1RCxHQUYvQztBQUcxQnl1RCxlQUFVLE9BSGdCO0FBSTFCenBDLGVBQVVBO0FBSmdCLElBQXJCLENBQVA7QUFNRCxFQVJEOztBQVVBOzs7QUFHQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0JvNkQsVUFBaEIsR0FBNkJ2UCxVQUFVLFVBQVN3UCxJQUFULEVBQWVoRixNQUFmLEVBQXVCN2xDLFFBQXZCLEVBQWlDO0FBQ3RFLFVBQU8sS0FBSzhxQyxTQUFMLENBQWVELElBQWYsRUFBcUJoRixNQUFyQixFQUE2QjdsQyxRQUE3QixDQUFQO0FBQ0QsRUFGNEIsRUFFMUJtcEMsa0JBQWtCLG9CQUFsQixFQUF3QyxtQkFBeEMsQ0FGMEIsQ0FBN0I7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQUQsT0FBTTE0RCxTQUFOLENBQWdCczZELFNBQWhCLEdBQTRCLFVBQVNELElBQVQsRUFBZWhGLE1BQWYsRUFBdUI3bEMsUUFBdkIsRUFBaUM7QUFDM0QsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXFILFFBQVEseURBQVo7O0FBRUEsT0FBSSxDQUFDcnRELFFBQVFtdEQsSUFBUixDQUFMLEVBQW9CO0FBQ2xCLFdBQU0sSUFBSTFWLEtBQUosQ0FBVTRWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUluNkQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPeTBELE1BQVAsS0FBa0IsVUFBaEQsRUFBNEQ7QUFDMUQ3bEMsZ0JBQVc2bEMsTUFBWDtBQUNBQSxjQUFTLElBQVQ7QUFDRDs7QUFFRCxPQUFJZ0UsVUFBVTtBQUNabUIsVUFBS0g7QUFETyxJQUFkOztBQUlBLE9BQUloRixNQUFKLEVBQVk7QUFDVmdFLGFBQVFvQixRQUFSLEdBQW1CcEYsT0FBT29GLFFBQTFCO0FBQ0FwQixhQUFRcUIsc0JBQVIsR0FBaUNyRixPQUFPcUYsc0JBQXhDO0FBQ0FyQixhQUFRc0IsZUFBUixHQUEwQnRGLE9BQU9zRixlQUFqQztBQUNBdEIsYUFBUTNELFdBQVIsR0FBc0JMLE9BQU9LLFdBQTdCOztBQUVBLFNBQUlMLE9BQU93RixlQUFYLEVBQTRCO0FBQzFCeEIsZUFBUXdCLGVBQVIsR0FBMEIsS0FBSzRCLEVBQUwsQ0FBUTlDLGdCQUFSLENBQXlCdEUsT0FBT3dGLGVBQWhDLEVBQWlELEVBQWpELENBQTFCO0FBQ0Q7O0FBRUR4QixhQUFReUIsUUFBUixHQUFtQnpGLE9BQU95RixRQUExQjtBQUNEOztBQUVELFVBQU8sS0FBSzJCLEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs4MkQsU0FBeEIsQ0FBaEIsR0FBcUQsT0FGaEM7QUFHMUJqbkIsV0FBTXVuQixPQUhvQjtBQUkxQkosZUFBVSxPQUpnQjtBQUsxQnpwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFyQ0Q7O0FBdUNBOzs7QUFHQWtwQyxPQUFNMTRELFNBQU4sQ0FBZ0IrNkQsc0JBQWhCLEdBQXlDbFEsVUFBVSxTQUFTcVcsZ0NBQVQsQ0FBMEM3RyxJQUExQyxFQUFnRGhGLE1BQWhELEVBQXdEN2xDLFFBQXhELEVBQWtFO0FBQ25ILFVBQU8sS0FBSzhxQyxTQUFMLENBQWVELElBQWYsRUFBcUJoRixNQUFyQixFQUE2QjdsQyxRQUE3QixDQUFQO0FBQ0QsRUFGd0MsRUFFdENtcEMsa0JBQWtCLGdDQUFsQixFQUFvRCxtQkFBcEQsQ0FGc0MsQ0FBekM7O0FBSUE7OztBQUdBRCxPQUFNMTRELFNBQU4sQ0FBZ0JnN0QsYUFBaEIsR0FBZ0NuUSxVQUFVLFVBQVNyZ0QsR0FBVCxFQUFjNnZELElBQWQsRUFBb0JoRixNQUFwQixFQUE0QjdsQyxRQUE1QixFQUFzQztBQUM5RSxVQUFPLEtBQUt5ckMsWUFBTCxDQUFrQnp3RCxHQUFsQixFQUF1QjZ2RCxJQUF2QixFQUE2QmhGLE1BQTdCLEVBQXFDN2xDLFFBQXJDLENBQVA7QUFDRCxFQUYrQixFQUU3Qm1wQyxrQkFBa0IsdUJBQWxCLEVBQTJDLHNCQUEzQyxDQUY2QixDQUFoQzs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBRCxPQUFNMTRELFNBQU4sQ0FBZ0JpN0QsWUFBaEIsR0FBK0IsVUFBU3p3RCxHQUFULEVBQWM2dkQsSUFBZCxFQUFvQmhGLE1BQXBCLEVBQTRCN2xDLFFBQTVCLEVBQXNDO0FBQ25FLE9BQUl0aUIsVUFBVSxtQkFBQWdtRCxDQUFRLEVBQVIsQ0FBZDtBQUNBLE9BQUlxSCxRQUFRLGlFQUFaOztBQUVBLE9BQUksQ0FBQ3J0RCxRQUFRbXRELElBQVIsQ0FBTCxFQUFvQjtBQUNsQixXQUFNLElBQUkxVixLQUFKLENBQVU0VixLQUFWLENBQU47QUFDRDs7QUFFRCxPQUFJbjZELFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBT3kwRCxNQUFQLEtBQWtCLFVBQWhELEVBQTREO0FBQzFEN2xDLGdCQUFXNmxDLE1BQVg7QUFDQUEsY0FBUyxJQUFUO0FBQ0Q7O0FBRUQsT0FBSTZGLFNBQVM7QUFDWFYsVUFBS0g7QUFETSxJQUFiOztBQUlBLE9BQUloRixNQUFKLEVBQVk7QUFDVjZGLFlBQU9ULFFBQVAsR0FBa0JwRixPQUFPb0YsUUFBekI7QUFDQVMsWUFBT1Isc0JBQVAsR0FBZ0NyRixPQUFPcUYsc0JBQXZDO0FBQ0FRLFlBQU9QLGVBQVAsR0FBeUJ0RixPQUFPc0YsZUFBaEM7QUFDQU8sWUFBT3hGLFdBQVAsR0FBcUJMLE9BQU9LLFdBQTVCOztBQUVBLFNBQUlMLE9BQU93RixlQUFYLEVBQTRCO0FBQzFCSyxjQUFPTCxlQUFQLEdBQXlCLEtBQUs0QixFQUFMLENBQVE5QyxnQkFBUixDQUF5QnRFLE9BQU93RixlQUFoQyxFQUFpRCxFQUFqRCxDQUF6QjtBQUNEOztBQUVESyxZQUFPSixRQUFQLEdBQWtCekYsT0FBT3lGLFFBQXpCO0FBQ0Q7O0FBRUQsVUFBTyxLQUFLMkIsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLEtBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzgyRCxTQUF4QixDQUFoQixHQUFxRCxRQUFyRCxHQUFnRXZ1RCxHQUYzQztBQUcxQnNuQyxXQUFNb3BCLE1BSG9CO0FBSTFCakMsZUFBVSxPQUpnQjtBQUsxQnpwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFyQ0QsQzs7Ozs7Ozs7QUNubENBLEtBQUksT0FBT2pvQixPQUFPcUMsTUFBZCxLQUF5QixVQUE3QixFQUF5QztBQUN2QztBQUNBeEssVUFBT0MsT0FBUCxHQUFpQixTQUFTdzVELFFBQVQsQ0FBa0JzSSxJQUFsQixFQUF3QkMsU0FBeEIsRUFBbUM7QUFDbERELFVBQUtFLE1BQUwsR0FBY0QsU0FBZDtBQUNBRCxVQUFLbmhFLFNBQUwsR0FBaUJ1SCxPQUFPcUMsTUFBUCxDQUFjdzNELFVBQVVwaEUsU0FBeEIsRUFBbUM7QUFDbERzUixvQkFBYTtBQUNYaEosZ0JBQU82NEQsSUFESTtBQUVYN3hELHFCQUFZLEtBRkQ7QUFHWEUsbUJBQVUsSUFIQztBQUlYQyx1QkFBYztBQUpIO0FBRHFDLE1BQW5DLENBQWpCO0FBUUQsSUFWRDtBQVdELEVBYkQsTUFhTztBQUNMO0FBQ0FyUSxVQUFPQyxPQUFQLEdBQWlCLFNBQVN3NUQsUUFBVCxDQUFrQnNJLElBQWxCLEVBQXdCQyxTQUF4QixFQUFtQztBQUNsREQsVUFBS0UsTUFBTCxHQUFjRCxTQUFkO0FBQ0EsU0FBSUUsV0FBVyxTQUFYQSxRQUFXLEdBQVksQ0FBRSxDQUE3QjtBQUNBQSxjQUFTdGhFLFNBQVQsR0FBcUJvaEUsVUFBVXBoRSxTQUEvQjtBQUNBbWhFLFVBQUtuaEUsU0FBTCxHQUFpQixJQUFJc2hFLFFBQUosRUFBakI7QUFDQUgsVUFBS25oRSxTQUFMLENBQWVzUixXQUFmLEdBQTZCNnZELElBQTdCO0FBQ0QsSUFORDtBQU9ELEU7Ozs7Ozs7Ozs7QUN0QkQsS0FBSUksb0JBQW9CLG1CQUFBck8sQ0FBUSxFQUFSLENBQXhCO0FBQ0EsS0FBSXJJLFlBQVksbUJBQUFxSSxDQUFRLEVBQVIsQ0FBaEI7QUFDQSxLQUFJeUYsb0JBQW9CLG1CQUFBekYsQ0FBUSxFQUFSLENBQXhCOztBQUVBOXpELFFBQU9DLE9BQVAsR0FBaUIrOEQsU0FBakI7O0FBRUE7Ozs7QUFJQSxVQUFTQSxTQUFULENBQW1Cb0YsYUFBbkIsRUFBa0N6SSxTQUFsQyxFQUE2QztBQUMzQyxRQUFLQSxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFFBQUswRCxFQUFMLEdBQVUrRSxhQUFWO0FBQ0EsUUFBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNBLFFBQUtDLG9CQUFMLEdBQTRCLElBQTVCOztBQUVBO0FBQ0EsUUFBSy8yRCxLQUFMLEdBQWEsRUFBYjtBQUNEOztBQUVEOzs7QUFHQXl4RCxXQUFVcDhELFNBQVYsQ0FBb0JzMUQsVUFBcEIsR0FBaUMsWUFBVztBQUMxQyxRQUFLM3FELEtBQUwsR0FBYSxFQUFiO0FBQ0QsRUFGRDs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErRkF5eEQsV0FBVXA4RCxTQUFWLENBQW9CdTFELE1BQXBCLEdBQTZCZ00sa0JBQWtCLE9BQWxCLENBQTdCOztBQUVBOzs7Ozs7Ozs7O0FBVUFuRixXQUFVcDhELFNBQVYsQ0FBb0IyaEUsYUFBcEIsR0FBb0NKLGtCQUFrQixjQUFsQixDQUFwQzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkFuRixXQUFVcDhELFNBQVYsQ0FBb0I0aEUsTUFBcEIsR0FBNkIsVUFBU3o4RCxLQUFULEVBQWdCMDFELGVBQWhCLEVBQWlDcnJDLFFBQWpDLEVBQTJDO0FBQ3RFLE9BQUkrdUMsUUFBUSxtQkFBQXJMLENBQVEsRUFBUixDQUFaOztBQUVBLE9BQUlzSixXQUFXLElBQWY7O0FBRUEsT0FBSTNDLElBQUo7QUFDQSxPQUFJL0QsV0FBSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFJMTFELFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEJSLFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBT1IsVUFBVSxDQUFWLENBQVAsS0FBd0IsVUFBaEYsRUFBNEY7QUFDMUZ5NUQsWUFBTyxDQUFQO0FBQ0FycUMsZ0JBQVdwdkIsVUFBVSxDQUFWLENBQVg7QUFDQStFLGFBQVE1RSxTQUFSO0FBQ0QsSUFKRCxNQUlPLElBQUksT0FBT0gsVUFBVSxDQUFWLENBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDM0M7QUFDQXk1RCxZQUFPejVELFVBQVUsQ0FBVixDQUFQO0FBQ0EsU0FBSSxPQUFPQSxVQUFVLENBQVYsQ0FBUCxLQUF3QixRQUE1QixFQUFzQztBQUNwQzAxRCxxQkFBYzExRCxVQUFVLENBQVYsQ0FBZDtBQUNELE1BRkQsTUFFTyxJQUFJLE9BQU9BLFVBQVUsQ0FBVixDQUFQLEtBQXdCLFVBQTVCLEVBQXdDO0FBQzdDb3ZCLGtCQUFXcHZCLFVBQVUsQ0FBVixDQUFYO0FBQ0EwMUQscUJBQWN2MUQsU0FBZDtBQUNEO0FBQ0Q0RSxhQUFRNUUsU0FBUjtBQUNBczZELHVCQUFrQnQ2RCxTQUFsQjtBQUNELElBWE0sTUFXQSxJQUFJLFFBQU9ILFVBQVUsQ0FBVixDQUFQLE1BQXdCLFFBQTVCLEVBQXNDO0FBQzNDO0FBQ0EsU0FBSSxPQUFPQSxVQUFVLENBQVYsQ0FBUCxLQUF3QixVQUE1QixFQUF3QztBQUN0Q292QixrQkFBV3B2QixVQUFVLENBQVYsQ0FBWDtBQUNEO0FBQ0R5NkQsdUJBQWtCejZELFVBQVUsQ0FBVixDQUFsQjtBQUNBK0UsYUFBUTVFLFNBQVI7QUFDRCxJQVBNLE1BT0EsSUFBSSxPQUFPSCxVQUFVLENBQVYsQ0FBUCxLQUF3QixRQUF4QixJQUFvQyxPQUFPQSxVQUFVLENBQVYsQ0FBUCxLQUF3QixVQUFoRSxFQUE0RTtBQUNqRjtBQUNBb3ZCLGdCQUFXcHZCLFVBQVUsQ0FBVixDQUFYO0FBQ0F5NkQsdUJBQWtCdDZELFNBQWxCO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBczZELHFCQUFrQjBELE1BQU0sRUFBTixFQUFVMUQsbUJBQW1CLEVBQTdCLEVBQWlDO0FBQ2pEaEIsV0FBTUEsSUFEMkM7QUFFakQvRCxrQkFBYUEsV0FGb0M7QUFHakQzd0QsWUFBT0E7QUFIMEMsSUFBakMsQ0FBbEI7O0FBTUEsT0FBSWt3RCxTQUFTLEtBQUtvSCxFQUFMLENBQVE5QyxnQkFBUixDQUF5QmtCLGVBQXpCLEVBQTBDLEVBQTFDLENBQWI7O0FBRUEsVUFBTyxLQUFLNEIsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBU3pELFNBQTVCLENBQWhCLEdBQXlELFNBRnBDO0FBRzFCam5CLFdBQU0sRUFBQ3VqQixRQUFRQSxNQUFULEVBSG9CO0FBSTFCNEQsZUFBVSxNQUpnQjtBQUsxQnpwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUExREQ7O0FBNERBOzs7Ozs7Ozs7Ozs7O0FBYUE0c0MsV0FBVXA4RCxTQUFWLENBQW9CNmhFLFVBQXBCLEdBQWlDLFVBQVNuRCxNQUFULEVBQWlCbHZDLFFBQWpCLEVBQTJCO0FBQzFELFVBQU8sS0FBS2l0QyxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELFNBRmhDO0FBRzFCam5CLFdBQU0sRUFBQzRzQixRQUFRQSxNQUFULEVBSG9CO0FBSTFCekYsZUFBVSxNQUpnQjtBQUsxQnpwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFSRDs7QUFVQTs7Ozs7Ozs7Ozs7O0FBWUE0c0MsV0FBVXA4RCxTQUFWLENBQW9COGhFLG9CQUFwQixHQUEyQyxVQUFTek0sTUFBVCxFQUFpQjdsQyxRQUFqQixFQUEyQjtBQUNwRSxPQUFJZ2pCLFFBQVEsbUJBQUEwZ0IsQ0FBUSxFQUFSLENBQVo7QUFDQSxPQUFJNk8sT0FBTyxtQkFBQTdPLENBQVEsRUFBUixDQUFYO0FBQ0EsT0FBSXFILFFBQVEsbUZBQVo7O0FBRUEsT0FBSWxGLE9BQU8yTSxTQUFQLEtBQXFCemhFLFNBQXJCLElBQWtDODBELE9BQU80TSxVQUFQLEtBQXNCMWhFLFNBQTVELEVBQXVFO0FBQ3JFLFdBQU0sSUFBSW9rRCxLQUFKLENBQVU0VixLQUFWLENBQU47QUFDRDs7QUFFRCxPQUFJeUgsWUFBWTNNLE9BQU8yTSxTQUF2QjtBQUNBLE9BQUlFLGlCQUFpQkgsS0FBS3Z2QixNQUFNNmlCLE1BQU4sQ0FBTCxFQUFvQixVQUFTOE0sT0FBVCxFQUFrQjtBQUN6RCxZQUFPQSxZQUFZLFdBQW5CO0FBQ0QsSUFGb0IsQ0FBckI7QUFHQSxPQUFJQyxtQkFBbUIsS0FBSzNGLEVBQUwsQ0FBUTlDLGdCQUFSLENBQXlCdUksY0FBekIsRUFBeUMsRUFBekMsQ0FBdkI7O0FBRUEsVUFBTyxLQUFLekYsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFDSC9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBREcsR0FDa0MsVUFEbEMsR0FDK0M5MkQsbUJBQW1CKy9ELFNBQW5CLENBRC9DLEdBQytFLFFBSDFEO0FBSTFCL0ksZUFBVSxNQUpnQjtBQUsxQm5uQixXQUFNLEVBQUN1akIsUUFBUStNLGdCQUFULEVBTG9CO0FBTTFCNXlDLGVBQVVBO0FBTmdCLElBQXJCLENBQVA7QUFRRCxFQXZCRDs7QUF5QkE0c0MsV0FBVXA4RCxTQUFWLENBQW9CcWlFLFdBQXBCLEdBQWtDeFgsVUFBVSxVQUFTd0ssTUFBVCxFQUFpQjdsQyxRQUFqQixFQUEyQjtBQUNyRSxVQUFPLEtBQUtzeUMsb0JBQUwsQ0FBMEJ6TSxNQUExQixFQUFrQzdsQyxRQUFsQyxDQUFQO0FBQ0QsRUFGaUMsRUFFL0JtcEMsa0JBQ0QsdUNBREMsRUFFRCxnREFGQyxDQUYrQixDQUFsQzs7QUFPQXlELFdBQVVwOEQsU0FBVixDQUFvQnNpRSxPQUFwQixHQUE4QixVQUFTak4sTUFBVCxFQUFpQnJ2RCxHQUFqQixFQUFzQndwQixRQUF0QixFQUFnQyt5QyxZQUFoQyxFQUE4QztBQUMxRSxVQUFPLEtBQUs5RixFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCcnVELFlBQU8sS0FBS0EsS0FEYztBQUUxQjlLLGFBQVEsTUFGa0I7QUFHMUJtRyxVQUFLQSxPQUFPLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBQWhCLEdBQXFELFFBSHZDO0FBSTFCam5CLFdBQU0sRUFBQ3VqQixRQUFRQSxNQUFULEVBSm9CO0FBSzFCNEQsZUFBVSxNQUxnQjtBQU0xQi9vQyxlQUFVO0FBQ1Jyd0IsZUFBUSxLQURBO0FBRVJtRyxZQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLODJELFNBQXhCLENBRmI7QUFHUmpuQixhQUFNLEVBQUN1akIsUUFBUUEsTUFBVDtBQUhFLE1BTmdCO0FBVzFCN2xDLGVBQVVBLFFBWGdCO0FBWTFCK3lDLG1CQUFjQTtBQVpZLElBQXJCLENBQVA7QUFjRCxFQWZEOztBQWlCQTs7Ozs7Ozs7O0FBU0FuRyxXQUFVcDhELFNBQVYsQ0FBb0JxMkQsU0FBcEIsR0FBZ0MsVUFBU0QsUUFBVCxFQUFtQnAxQyxLQUFuQixFQUEwQndPLFFBQTFCLEVBQW9DO0FBQ2xFLE9BQUlndEMsV0FBVyxJQUFmOztBQUVBLE9BQUlwOEQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPb2dCLEtBQVAsS0FBaUIsVUFBL0MsRUFBMkQ7QUFDekR3TyxnQkFBV3hPLEtBQVg7QUFDQUEsYUFBUXpnQixTQUFSO0FBQ0Q7O0FBRUQsT0FBSTgwRCxTQUFTLEVBQWI7QUFDQSxPQUFJcjBDLFVBQVV6Z0IsU0FBZCxFQUF5QjtBQUN2QjgwRCxjQUFTLGNBQVQ7QUFDQSxVQUFLLElBQUkxMEQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJcWdCLE1BQU1wZ0IsTUFBMUIsRUFBa0MsRUFBRUQsQ0FBcEMsRUFBdUM7QUFDckMsV0FBSUEsTUFBTSxDQUFWLEVBQWE7QUFDWDAwRCxtQkFBVSxHQUFWO0FBQ0Q7QUFDREEsaUJBQVVyMEMsTUFBTXJnQixDQUFOLENBQVY7QUFDRDtBQUNGOztBQUVELFVBQU8sS0FBSzg3RCxFQUFMLENBQVF6RCxZQUFSLENBQXFCO0FBQzFCbjVELGFBQVEsS0FEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTekQsU0FBNUIsQ0FBaEIsR0FBeUQsR0FBekQsR0FBK0Q5MkQsbUJBQW1CbTBELFFBQW5CLENBQS9ELEdBQThGZixNQUZ6RTtBQUcxQjRELGVBQVUsTUFIZ0I7QUFJMUJ6cEMsZUFBVUE7QUFKZ0IsSUFBckIsQ0FBUDtBQU1ELEVBekJEOztBQTJCQTs7Ozs7QUFLQTRzQyxXQUFVcDhELFNBQVYsQ0FBb0J3aUUsVUFBcEIsR0FBaUMsVUFBU25GLFNBQVQsRUFBb0JJLG9CQUFwQixFQUEwQ2p1QyxRQUExQyxFQUFvRDtBQUNuRixPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJdnBELE1BQU0sbUJBQUF1cEQsQ0FBUSxFQUFSLENBQVY7O0FBRUEsT0FBSXFILFFBQVEsdURBQVo7O0FBRUEsT0FBSSxDQUFDcnRELFFBQVFtd0QsU0FBUixDQUFMLEVBQXlCO0FBQ3ZCLFdBQU0sSUFBSTFZLEtBQUosQ0FBVTRWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUlpQyxXQUFXLElBQWY7O0FBRUEsT0FBSXA4RCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU82OEQsb0JBQVAsS0FBZ0MsVUFBOUQsRUFBMEU7QUFDeEVqdUMsZ0JBQVdpdUMsb0JBQVg7QUFDQUEsNEJBQXVCbDlELFNBQXZCO0FBQ0Q7O0FBRUQsT0FBSXV4QyxPQUFPO0FBQ1Q4cEIsZUFBVWp5RCxJQUFJMHpELFNBQUosRUFBZSxTQUFTQyxjQUFULENBQXdCbEgsUUFBeEIsRUFBa0M7QUFDekQsV0FBSXZ3RCxVQUFVO0FBQ1prekQsb0JBQVd5RCxTQUFTekQsU0FEUjtBQUVaM0MsbUJBQVVBO0FBRkUsUUFBZDs7QUFLQSxXQUFJcUgsb0JBQUosRUFBMEI7QUFDeEI1M0QsaUJBQVE0M0Qsb0JBQVIsR0FBK0JBLHFCQUFxQjV3RCxJQUFyQixDQUEwQixHQUExQixDQUEvQjtBQUNEOztBQUVELGNBQU9oSCxPQUFQO0FBQ0QsTUFYUztBQURELElBQVg7O0FBZUEsVUFBTyxLQUFLNDJELEVBQUwsQ0FBUXpELFlBQVIsQ0FBcUI7QUFDMUJuNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssc0JBRnFCO0FBRzFCaXpELGVBQVUsTUFIZ0I7QUFJMUJubkIsV0FBTUEsSUFKb0I7QUFLMUJ0aUIsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBdkNEOztBQXlDQTRzQyxXQUFVcDhELFNBQVYsQ0FBb0J5OEQsRUFBcEIsR0FBeUIsSUFBekI7QUFDQUwsV0FBVXA4RCxTQUFWLENBQW9CKzRELFNBQXBCLEdBQWdDLElBQWhDO0FBQ0FxRCxXQUFVcDhELFNBQVYsQ0FBb0J5aEUsYUFBcEIsR0FBb0MsSUFBcEM7QUFDQXJGLFdBQVVwOEQsU0FBVixDQUFvQjBoRSxvQkFBcEIsR0FBMkMsSUFBM0MsQzs7Ozs7Ozs7OztBQzlYQXRpRSxRQUFPQyxPQUFQLEdBQWlCa2lFLGlCQUFqQjs7QUFFQSxLQUFJMWUsU0FBUyxtQkFBQXFRLENBQVEsRUFBUixDQUFiOztBQUVBOzs7Ozs7QUFNQSxVQUFTcU8saUJBQVQsQ0FBMkJrQixVQUEzQixFQUF1Q3o4RCxHQUF2QyxFQUE0QztBQUMxQzs7Ozs7OztBQU9BLFVBQU8sU0FBU3V2RCxNQUFULENBQWdCcHdELEtBQWhCLEVBQXVCaVIsSUFBdkIsRUFBNkJvWixRQUE3QixFQUF1QztBQUM1QztBQUNBLFNBQUksT0FBT3JxQixLQUFQLEtBQWlCLFVBQWpCLElBQStCLFFBQU9pUixJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQS9DLElBQ0YsUUFBT29aLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFEdEIsRUFDZ0M7QUFDOUI7QUFDQTtBQUNBLGFBQU0sSUFBSXF6QixPQUFPc1osa0JBQVgsQ0FBOEIsdURBQTlCLENBQU47QUFDRDs7QUFFRDtBQUNBLFNBQUkvN0QsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPdUUsS0FBUCxLQUFpQixVQUEvQyxFQUEyRDtBQUN6RDtBQUNBcXFCLGtCQUFXcnFCLEtBQVg7QUFDQUEsZUFBUSxFQUFSO0FBQ0QsTUFKRCxNQUlPLElBQUkvRSxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU93VixJQUFQLEtBQWdCLFVBQTlDLEVBQTBEO0FBQy9EO0FBQ0FvWixrQkFBV3BaLElBQVg7QUFDQUEsY0FBTzdWLFNBQVA7QUFDRDtBQUNEOztBQUVBO0FBQ0EsU0FBSSxRQUFPNEUsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFqQixJQUE2QkEsVUFBVSxJQUEzQyxFQUFpRDtBQUMvQ2lSLGNBQU9qUixLQUFQO0FBQ0FBLGVBQVE1RSxTQUFSO0FBQ0QsTUFIRCxNQUdPLElBQUk0RSxVQUFVNUUsU0FBVixJQUF1QjRFLFVBQVUsSUFBckMsRUFBMkM7QUFBRTtBQUNsREEsZUFBUSxFQUFSO0FBQ0Q7O0FBRUQsU0FBSWt3RCxTQUFTLEVBQWI7O0FBRUEsU0FBSWx3RCxVQUFVNUUsU0FBZCxFQUF5QjtBQUN2QjgwRCxpQkFBVW9OLGFBQWEsR0FBYixHQUFtQnhnRSxtQkFBbUJrRCxLQUFuQixDQUE3QjtBQUNEOztBQUVELFNBQUlvOUQsWUFBSjtBQUNBLFNBQUluc0QsU0FBUzdWLFNBQWIsRUFBd0I7QUFDdEIsV0FBSTZWLEtBQUttc0QsWUFBVCxFQUF1QjtBQUNyQkEsd0JBQWVuc0QsS0FBS21zRCxZQUFwQjtBQUNBLGdCQUFPbnNELEtBQUttc0QsWUFBWjtBQUNEO0FBQ0Q7QUFDQWxOLGdCQUFTLEtBQUtvSCxFQUFMLENBQVE5QyxnQkFBUixDQUF5QnZqRCxJQUF6QixFQUErQmkvQyxNQUEvQixDQUFUO0FBQ0Q7O0FBR0QsWUFBTyxLQUFLaU4sT0FBTCxDQUFhak4sTUFBYixFQUFxQnJ2RCxHQUFyQixFQUEwQndwQixRQUExQixFQUFvQyt5QyxZQUFwQyxDQUFQO0FBQ0QsSUEvQ0Q7QUFnREQsRTs7Ozs7O0FDbEVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJMUosV0FBVyxtQkFBQTNGLENBQVEsRUFBUixDQUFmOztBQUVBLFVBQVNpSixrQkFBVCxDQUE0QmhRLE9BQTVCLEVBQXFDdVcsZUFBckMsRUFBc0Q7QUFDcEQsT0FBSWo3RCxVQUFVLG1CQUFBeXJELENBQVEsRUFBUixDQUFkOztBQUVBLE9BQUl6c0QsUUFBUSxJQUFaOztBQUVBO0FBQ0EsT0FBSSxPQUFPaytDLE1BQU1nZSxpQkFBYixLQUFtQyxVQUF2QyxFQUFtRDtBQUNqRGhlLFdBQU1nZSxpQkFBTixDQUF3QixJQUF4QixFQUE4QixLQUFLcnhELFdBQW5DO0FBQ0QsSUFGRCxNQUVPO0FBQ0w3SyxXQUFNa3dDLEtBQU4sR0FBZSxJQUFJZ08sS0FBSixFQUFELENBQWNoTyxLQUFkLElBQXVCLDZDQUFyQztBQUNEOztBQUVELFFBQUt6MUMsSUFBTCxHQUFZLG9CQUFaO0FBQ0EsUUFBS2lyRCxPQUFMLEdBQWVBLFdBQVcsZUFBMUI7O0FBRUEsT0FBSXVXLGVBQUosRUFBcUI7QUFDbkJqN0QsYUFBUWk3RCxlQUFSLEVBQXlCLFNBQVNFLGdCQUFULENBQTBCdDZELEtBQTFCLEVBQWlDa0MsR0FBakMsRUFBc0M7QUFDN0QvRCxhQUFNK0QsR0FBTixJQUFhbEMsS0FBYjtBQUNELE1BRkQ7QUFHRDtBQUNGOztBQUVEdXdELFVBQVNzRCxrQkFBVCxFQUE2QnhYLEtBQTdCOztBQUVBLFVBQVNrZSxpQkFBVCxDQUEyQjNoRSxJQUEzQixFQUFpQ2lyRCxPQUFqQyxFQUEwQztBQUN4QyxZQUFTMlcsd0JBQVQsR0FBb0M7QUFDbEMsU0FBSTFzRCxPQUFPckssTUFBTS9MLFNBQU4sQ0FBZ0J1QyxLQUFoQixDQUFzQnRDLElBQXRCLENBQTJCRyxTQUEzQixFQUFzQyxDQUF0QyxDQUFYOztBQUVBO0FBQ0EsU0FBSSxPQUFPZ1csS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0JBLFlBQUtrZSxPQUFMLENBQWE2M0IsT0FBYjtBQUNEOztBQUVEZ1Esd0JBQW1CaDhELEtBQW5CLENBQXlCLElBQXpCLEVBQStCaVcsSUFBL0I7QUFDQSxVQUFLbFYsSUFBTCxHQUFZLGtCQUFrQkEsSUFBbEIsR0FBeUIsT0FBckM7QUFDRDs7QUFFRDIzRCxZQUFTaUssd0JBQVQsRUFBbUMzRyxrQkFBbkM7O0FBRUEsVUFBTzJHLHdCQUFQO0FBQ0Q7O0FBRUQ7QUFDQTFqRSxRQUFPQyxPQUFQLEdBQWlCO0FBQ2Y4OEQsdUJBQW9CQSxrQkFETDtBQUVmNEcsbUJBQWdCRixrQkFDZCxnQkFEYyxFQUVkLHlFQUZjLENBRkQ7QUFNZkcsbUJBQWdCSCxrQkFDZCxnQkFEYyxFQUVkLDRDQUZjLENBTkQ7QUFVZkksWUFBU0osa0JBQ1AsU0FETyxFQUVQLHlDQUZPLENBVk07QUFjZkssb0JBQWlCTCxrQkFDZixpQkFEZSxFQUVmLDREQUZlLENBZEY7QUFrQmZNLHFCQUFrQk4sa0JBQ2hCLGtCQURnQixFQUVoQix1REFGZ0IsQ0FsQkg7QUFzQmZPLFlBQVNQLGtCQUNQLFNBRE8sRUFFUCx1QkFGTztBQXRCTSxFQUFqQixDOzs7Ozs7OztBQ2xEQSxLQUFJdDRELFNBQVNoRCxPQUFPdkgsU0FBUCxDQUFpQnNLLGNBQTlCO0FBQ0EsS0FBSTdCLFdBQVdsQixPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWhDOztBQUVBckosUUFBT0MsT0FBUCxHQUFpQixTQUFTb0ksT0FBVCxDQUFrQjlILEdBQWxCLEVBQXVCK0ssRUFBdkIsRUFBMkJhLEdBQTNCLEVBQWdDO0FBQzdDLFNBQUk5QyxTQUFTeEksSUFBVCxDQUFjeUssRUFBZCxNQUFzQixtQkFBMUIsRUFBK0M7QUFDM0MsZUFBTSxJQUFJckgsU0FBSixDQUFjLDZCQUFkLENBQU47QUFDSDtBQUNELFNBQUlxSSxJQUFJL0wsSUFBSWlCLE1BQVo7QUFDQSxTQUFJOEssTUFBTSxDQUFDQSxDQUFYLEVBQWM7QUFDVixjQUFLLElBQUkvSyxJQUFJLENBQWIsRUFBZ0JBLElBQUkrSyxDQUFwQixFQUF1Qi9LLEdBQXZCLEVBQTRCO0FBQ3hCK0osZ0JBQUd6SyxJQUFILENBQVFzTCxHQUFSLEVBQWE1TCxJQUFJZ0IsQ0FBSixDQUFiLEVBQXFCQSxDQUFyQixFQUF3QmhCLEdBQXhCO0FBQ0g7QUFDSixNQUpELE1BSU87QUFDSCxjQUFLLElBQUkwakUsQ0FBVCxJQUFjMWpFLEdBQWQsRUFBbUI7QUFDZixpQkFBSTRLLE9BQU90SyxJQUFQLENBQVlOLEdBQVosRUFBaUIwakUsQ0FBakIsQ0FBSixFQUF5QjtBQUNyQjM0RCxvQkFBR3pLLElBQUgsQ0FBUXNMLEdBQVIsRUFBYTVMLElBQUkwakUsQ0FBSixDQUFiLEVBQXFCQSxDQUFyQixFQUF3QjFqRSxHQUF4QjtBQUNIO0FBQ0o7QUFDSjtBQUNKLEVBaEJELEM7Ozs7Ozs7O0FDSkFQLFFBQU9DLE9BQVAsR0FBaUIsU0FBU3dyRCxTQUFULENBQW1CbmdELEVBQW5CLEVBQXVCeWhELE9BQXZCLEVBQWdDO0FBQy9DLE9BQUkxUyxTQUFTLEtBQWI7O0FBRUEsWUFBUzZwQixVQUFULEdBQXNCO0FBQ3BCLFNBQUksQ0FBQzdwQixNQUFMLEVBQWE7QUFDWDtBQUNBbjVDLGVBQVF5UCxJQUFSLENBQWFvOEMsT0FBYjtBQUNBMVMsZ0JBQVMsSUFBVDtBQUNEOztBQUVELFlBQU8vdUMsR0FBR3ZLLEtBQUgsQ0FBUyxJQUFULEVBQWVDLFNBQWYsQ0FBUDtBQUNEOztBQUVELFVBQU9rakUsVUFBUDtBQUNELEVBZEQsQzs7Ozs7Ozs7QUNBQWxrRSxRQUFPQyxPQUFQLEdBQWlCLFNBQVNzNUQsaUJBQVQsQ0FBMkI0SyxhQUEzQixFQUEwQ0MsUUFBMUMsRUFBb0Q7QUFDbkUsT0FBSUMsbUJBQW1CRixjQUFjeDVELFdBQWQsR0FDcEJpQixPQURvQixDQUNaLFdBRFksRUFDQyxFQURELENBQXZCOztBQUdBLFVBQU8scUJBQXFCdTRELGFBQXJCLEdBQXFDLHFCQUFyQyxHQUE2REMsUUFBN0QsR0FDTCwyRkFESyxHQUN5RkMsZ0JBRGhHO0FBRUQsRUFORCxDOzs7Ozs7Ozs7O0FDQUEsS0FBSUMsVUFBVSxtQkFBQXhRLENBQVEsRUFBUixDQUFkOztBQUVBOXpELFFBQU9DLE9BQVAsR0FBaUIsU0FBU2svRCxLQUFULENBQWVoRixXQUFmLENBQTBCLGVBQTFCLEVBQTJDO0FBQzFELE9BQUlvSyxVQUFVNTNELE1BQU0vTCxTQUFOLENBQWdCdUMsS0FBaEIsQ0FBc0J0QyxJQUF0QixDQUEyQkcsU0FBM0IsQ0FBZDs7QUFFQXNqRSxXQUFRQyxPQUFSLEVBQWlCLFVBQVMxMkMsTUFBVCxFQUFpQjtBQUNoQyxVQUFLLElBQUlrMUMsT0FBVCxJQUFvQmwxQyxNQUFwQixFQUE0QjtBQUMxQixXQUFJQSxPQUFPM2lCLGNBQVAsQ0FBc0I2M0QsT0FBdEIsQ0FBSixFQUFvQztBQUNsQyxhQUFJLFFBQU81SSxZQUFZNEksT0FBWixDQUFQLE1BQWdDLFFBQWhDLElBQTRDLFFBQU9sMUMsT0FBT2sxQyxPQUFQLENBQVAsTUFBMkIsUUFBM0UsRUFBcUY7QUFDbkY1SSx1QkFBWTRJLE9BQVosSUFBdUI1RCxNQUFNLEVBQU4sRUFBVWhGLFlBQVk0SSxPQUFaLENBQVYsRUFBZ0NsMUMsT0FBT2sxQyxPQUFQLENBQWhDLENBQXZCO0FBQ0QsVUFGRCxNQUVPLElBQUlsMUMsT0FBT2sxQyxPQUFQLE1BQW9CNWhFLFNBQXhCLEVBQW1DO0FBQ3hDZzVELHVCQUFZNEksT0FBWixJQUF1QmwxQyxPQUFPazFDLE9BQVAsQ0FBdkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixJQVZEOztBQVlBLFVBQU81SSxXQUFQO0FBQ0QsRUFoQkQsQzs7Ozs7Ozs7QUNGQW42RCxRQUFPQyxPQUFQLEdBQWlCLFNBQVNtekMsS0FBVCxDQUFlN3lDLEdBQWYsRUFBb0I7QUFDbkMsVUFBT3dKLEtBQUtrd0MsS0FBTCxDQUFXbHdDLEtBQUtDLFNBQUwsQ0FBZXpKLEdBQWYsQ0FBWCxDQUFQO0FBQ0QsRUFGRCxDOzs7Ozs7OztBQ0FBUCxRQUFPQyxPQUFQLEdBQWlCLFNBQVMwaUUsSUFBVCxDQUFjcGlFLEdBQWQsRUFBbUJrUSxJQUFuQixFQUF5QjtBQUN4QyxPQUFJckksT0FBTyxtQkFBQTByRCxDQUFRLEVBQVIsQ0FBWDtBQUNBLE9BQUl3USxVQUFVLG1CQUFBeFEsQ0FBUSxFQUFSLENBQWQ7O0FBRUEsT0FBSTBRLFdBQVcsRUFBZjs7QUFFQUYsV0FBUWw4RCxLQUFLN0gsR0FBTCxDQUFSLEVBQW1CLFNBQVNra0UsUUFBVCxDQUFrQjFCLE9BQWxCLEVBQTJCO0FBQzVDLFNBQUl0eUQsS0FBS3N5RCxPQUFMLE1BQWtCLElBQXRCLEVBQTRCO0FBQzFCeUIsZ0JBQVN6QixPQUFULElBQW9CeGlFLElBQUl3aUUsT0FBSixDQUFwQjtBQUNEO0FBQ0YsSUFKRDs7QUFNQSxVQUFPeUIsUUFBUDtBQUNELEVBYkQsQzs7Ozs7O0FDQUE7O0FBRUE7Ozs7QUFDQSxLQUFJL3VELE1BQU10TixPQUFPdkgsU0FBUCxDQUFpQnNLLGNBQTNCO0FBQ0EsS0FBSXc1RCxRQUFRdjhELE9BQU92SCxTQUFQLENBQWlCeUksUUFBN0I7QUFDQSxLQUFJbEcsUUFBUXdKLE1BQU0vTCxTQUFOLENBQWdCdUMsS0FBNUI7QUFDQSxLQUFJd2hFLFNBQVMsbUJBQUE3USxDQUFRLEVBQVIsQ0FBYjtBQUNBLEtBQUk4USxlQUFlejhELE9BQU92SCxTQUFQLENBQWlCaWtFLG9CQUFwQztBQUNBLEtBQUlDLGlCQUFpQixDQUFDRixhQUFhL2pFLElBQWIsQ0FBa0IsRUFBRXdJLFVBQVUsSUFBWixFQUFsQixFQUFzQyxVQUF0QyxDQUF0QjtBQUNBLEtBQUkwN0Qsa0JBQWtCSCxhQUFhL2pFLElBQWIsQ0FBa0IsWUFBWSxDQUFFLENBQWhDLEVBQWtDLFdBQWxDLENBQXRCO0FBQ0EsS0FBSW1rRSxZQUFZLENBQ2YsVUFEZSxFQUVmLGdCQUZlLEVBR2YsU0FIZSxFQUlmLGdCQUplLEVBS2YsZUFMZSxFQU1mLHNCQU5lLEVBT2YsYUFQZSxDQUFoQjtBQVNBLEtBQUlDLDZCQUE2QixTQUE3QkEsMEJBQTZCLENBQVVuMUIsQ0FBVixFQUFhO0FBQzdDLE1BQUlpeUIsT0FBT2p5QixFQUFFNTlCLFdBQWI7QUFDQSxTQUFPNnZELFFBQVFBLEtBQUtuaEUsU0FBTCxLQUFtQmt2QyxDQUFsQztBQUNBLEVBSEQ7QUFJQSxLQUFJbzFCLGVBQWU7QUFDbEJDLFlBQVUsSUFEUTtBQUVsQkMsYUFBVyxJQUZPO0FBR2xCQyxVQUFRLElBSFU7QUFJbEJDLGlCQUFlLElBSkc7QUFLbEJDLFdBQVMsSUFMUztBQU1sQkMsZ0JBQWMsSUFOSTtBQU9sQkMsZUFBYSxJQVBLO0FBUWxCQyxnQkFBYyxJQVJJO0FBU2xCQyxlQUFhLElBVEs7QUFVbEJDLGdCQUFjLElBVkk7QUFXbEJDLGdCQUFjLElBWEk7QUFZbEIvekQsV0FBUyxJQVpTO0FBYWxCZzBELGVBQWEsSUFiSztBQWNsQkMsY0FBWSxJQWRNO0FBZWxCQyxZQUFVLElBZlE7QUFnQmxCQyxZQUFVLElBaEJRO0FBaUJsQkMsU0FBTyxJQWpCVztBQWtCbEJDLG9CQUFrQixJQWxCQTtBQW1CbEJDLHNCQUFvQixJQW5CRjtBQW9CbEJDLFdBQVM7QUFwQlMsRUFBbkI7QUFzQkEsS0FBSUMsMkJBQTRCLFlBQVk7QUFDM0M7QUFDQSxNQUFJLE9BQU85akUsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUFFLFVBQU8sS0FBUDtBQUFlO0FBQ3BELE9BQUssSUFBSXloRSxDQUFULElBQWN6aEUsTUFBZCxFQUFzQjtBQUNyQixPQUFJO0FBQ0gsUUFBSSxDQUFDMGlFLGFBQWEsTUFBTWpCLENBQW5CLENBQUQsSUFBMEJ4dUQsSUFBSTVVLElBQUosQ0FBUzJCLE1BQVQsRUFBaUJ5aEUsQ0FBakIsQ0FBMUIsSUFBaUR6aEUsT0FBT3loRSxDQUFQLE1BQWMsSUFBL0QsSUFBdUUsUUFBT3poRSxPQUFPeWhFLENBQVAsQ0FBUCxNQUFxQixRQUFoRyxFQUEwRztBQUN6RyxTQUFJO0FBQ0hnQixpQ0FBMkJ6aUUsT0FBT3loRSxDQUFQLENBQTNCO0FBQ0EsTUFGRCxDQUVFLE9BQU9uakUsQ0FBUCxFQUFVO0FBQ1gsYUFBTyxJQUFQO0FBQ0E7QUFDRDtBQUNELElBUkQsQ0FRRSxPQUFPQSxDQUFQLEVBQVU7QUFDWCxXQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0EsRUFqQitCLEVBQWhDO0FBa0JBLEtBQUl5bEUsdUNBQXVDLFNBQXZDQSxvQ0FBdUMsQ0FBVXoyQixDQUFWLEVBQWE7QUFDdkQ7QUFDQSxNQUFJLE9BQU90dEMsTUFBUCxLQUFrQixXQUFsQixJQUFpQyxDQUFDOGpFLHdCQUF0QyxFQUFnRTtBQUMvRCxVQUFPckIsMkJBQTJCbjFCLENBQTNCLENBQVA7QUFDQTtBQUNELE1BQUk7QUFDSCxVQUFPbTFCLDJCQUEyQm4xQixDQUEzQixDQUFQO0FBQ0EsR0FGRCxDQUVFLE9BQU9odkMsQ0FBUCxFQUFVO0FBQ1gsVUFBTyxLQUFQO0FBQ0E7QUFDRCxFQVZEOztBQVlBLEtBQUkwbEUsV0FBVyxTQUFTcCtELElBQVQsQ0FBY3doRCxNQUFkLEVBQXNCO0FBQ3BDLE1BQUl6Z0QsV0FBV3lnRCxXQUFXLElBQVgsSUFBbUIsUUFBT0EsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFwRDtBQUNBLE1BQUk2YyxhQUFhL0IsTUFBTTdqRSxJQUFOLENBQVcrb0QsTUFBWCxNQUF1QixtQkFBeEM7QUFDQSxNQUFJOGMsY0FBYy9CLE9BQU8vYSxNQUFQLENBQWxCO0FBQ0EsTUFBSStjLFdBQVd4OUQsWUFBWXU3RCxNQUFNN2pFLElBQU4sQ0FBVytvRCxNQUFYLE1BQXVCLGlCQUFsRDtBQUNBLE1BQUlnZCxVQUFVLEVBQWQ7O0FBRUEsTUFBSSxDQUFDejlELFFBQUQsSUFBYSxDQUFDczlELFVBQWQsSUFBNEIsQ0FBQ0MsV0FBakMsRUFBOEM7QUFDN0MsU0FBTSxJQUFJemlFLFNBQUosQ0FBYyxvQ0FBZCxDQUFOO0FBQ0E7O0FBRUQsTUFBSTRpRSxZQUFZOUIsbUJBQW1CMEIsVUFBbkM7QUFDQSxNQUFJRSxZQUFZL2MsT0FBT3BvRCxNQUFQLEdBQWdCLENBQTVCLElBQWlDLENBQUNpVSxJQUFJNVUsSUFBSixDQUFTK29ELE1BQVQsRUFBaUIsQ0FBakIsQ0FBdEMsRUFBMkQ7QUFDMUQsUUFBSyxJQUFJcm9ELElBQUksQ0FBYixFQUFnQkEsSUFBSXFvRCxPQUFPcG9ELE1BQTNCLEVBQW1DLEVBQUVELENBQXJDLEVBQXdDO0FBQ3ZDcWxFLFlBQVF6MEQsSUFBUixDQUFhbEksT0FBTzFJLENBQVAsQ0FBYjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSW1sRSxlQUFlOWMsT0FBT3BvRCxNQUFQLEdBQWdCLENBQW5DLEVBQXNDO0FBQ3JDLFFBQUssSUFBSW1uQixJQUFJLENBQWIsRUFBZ0JBLElBQUlpaEMsT0FBT3BvRCxNQUEzQixFQUFtQyxFQUFFbW5CLENBQXJDLEVBQXdDO0FBQ3ZDaStDLFlBQVF6MEQsSUFBUixDQUFhbEksT0FBTzBlLENBQVAsQ0FBYjtBQUNBO0FBQ0QsR0FKRCxNQUlPO0FBQ04sUUFBSyxJQUFJN21CLElBQVQsSUFBaUI4bkQsTUFBakIsRUFBeUI7QUFDeEIsUUFBSSxFQUFFaWQsYUFBYS9rRSxTQUFTLFdBQXhCLEtBQXdDMlQsSUFBSTVVLElBQUosQ0FBUytvRCxNQUFULEVBQWlCOW5ELElBQWpCLENBQTVDLEVBQW9FO0FBQ25FOGtFLGFBQVF6MEQsSUFBUixDQUFhbEksT0FBT25JLElBQVAsQ0FBYjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxNQUFJZ2pFLGNBQUosRUFBb0I7QUFDbkIsT0FBSWdDLGtCQUFrQlAscUNBQXFDM2MsTUFBckMsQ0FBdEI7O0FBRUEsUUFBSyxJQUFJcWEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZSxVQUFVeGpFLE1BQTlCLEVBQXNDLEVBQUV5aUUsQ0FBeEMsRUFBMkM7QUFDMUMsUUFBSSxFQUFFNkMsbUJBQW1COUIsVUFBVWYsQ0FBVixNQUFpQixhQUF0QyxLQUF3RHh1RCxJQUFJNVUsSUFBSixDQUFTK29ELE1BQVQsRUFBaUJvYixVQUFVZixDQUFWLENBQWpCLENBQTVELEVBQTRGO0FBQzNGMkMsYUFBUXowRCxJQUFSLENBQWE2eUQsVUFBVWYsQ0FBVixDQUFiO0FBQ0E7QUFDRDtBQUNEO0FBQ0QsU0FBTzJDLE9BQVA7QUFDQSxFQXhDRDs7QUEwQ0FKLFVBQVNPLElBQVQsR0FBZ0IsU0FBU0MsY0FBVCxHQUEwQjtBQUN6QyxNQUFJNytELE9BQU9DLElBQVgsRUFBaUI7QUFDaEIsT0FBSTYrRCx5QkFBMEIsWUFBWTtBQUN6QztBQUNBLFdBQU8sQ0FBQzkrRCxPQUFPQyxJQUFQLENBQVlwSCxTQUFaLEtBQTBCLEVBQTNCLEVBQStCUSxNQUEvQixLQUEwQyxDQUFqRDtBQUNBLElBSDZCLENBRzVCLENBSDRCLEVBR3pCLENBSHlCLENBQTlCO0FBSUEsT0FBSSxDQUFDeWxFLHNCQUFMLEVBQTZCO0FBQzVCLFFBQUlDLGVBQWUvK0QsT0FBT0MsSUFBMUI7QUFDQUQsV0FBT0MsSUFBUCxHQUFjLFNBQVNBLElBQVQsQ0FBY3doRCxNQUFkLEVBQXNCO0FBQ25DLFNBQUkrYSxPQUFPL2EsTUFBUCxDQUFKLEVBQW9CO0FBQ25CLGFBQU9zZCxhQUFhL2pFLE1BQU10QyxJQUFOLENBQVcrb0QsTUFBWCxDQUFiLENBQVA7QUFDQSxNQUZELE1BRU87QUFDTixhQUFPc2QsYUFBYXRkLE1BQWIsQ0FBUDtBQUNBO0FBQ0QsS0FORDtBQU9BO0FBQ0QsR0FmRCxNQWVPO0FBQ056aEQsVUFBT0MsSUFBUCxHQUFjbytELFFBQWQ7QUFDQTtBQUNELFNBQU9yK0QsT0FBT0MsSUFBUCxJQUFlbytELFFBQXRCO0FBQ0EsRUFwQkQ7O0FBc0JBeG1FLFFBQU9DLE9BQVAsR0FBaUJ1bUUsUUFBakIsQzs7Ozs7O0FDM0lBOzs7O0FBRUEsS0FBSTlCLFFBQVF2OEQsT0FBT3ZILFNBQVAsQ0FBaUJ5SSxRQUE3Qjs7QUFFQXJKLFFBQU9DLE9BQVAsR0FBaUIsU0FBU3ltRSxXQUFULENBQXFCeDlELEtBQXJCLEVBQTRCO0FBQzVDLE1BQUltQixNQUFNcTZELE1BQU03akUsSUFBTixDQUFXcUksS0FBWCxDQUFWO0FBQ0EsTUFBSXk3RCxTQUFTdDZELFFBQVEsb0JBQXJCO0FBQ0EsTUFBSSxDQUFDczZELE1BQUwsRUFBYTtBQUNaQSxZQUFTdDZELFFBQVEsZ0JBQVIsSUFDUm5CLFVBQVUsSUFERixJQUVSLFFBQU9BLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFGVCxJQUdSLE9BQU9BLE1BQU0xSCxNQUFiLEtBQXdCLFFBSGhCLElBSVIwSCxNQUFNMUgsTUFBTixJQUFnQixDQUpSLElBS1JrakUsTUFBTTdqRSxJQUFOLENBQVdxSSxNQUFNaStELE1BQWpCLE1BQTZCLG1CQUw5QjtBQU1BO0FBQ0QsU0FBT3hDLE1BQVA7QUFDQSxFQVpELEM7Ozs7Ozs7O0FDSkEsS0FBSXQ3RCxXQUFXLEdBQUdBLFFBQWxCOztBQUVBckosUUFBT0MsT0FBUCxHQUFpQjBNLE1BQU1tQixPQUFOLElBQWlCLFVBQVUvQyxHQUFWLEVBQWU7QUFDL0MsVUFBTzFCLFNBQVN4SSxJQUFULENBQWNrSyxHQUFkLEtBQXNCLGdCQUE3QjtBQUNELEVBRkQsQzs7Ozs7Ozs7QUNGQSxLQUFJdTVELFVBQVUsbUJBQUF4USxDQUFRLEVBQVIsQ0FBZDs7QUFFQTl6RCxRQUFPQyxPQUFQLEdBQWlCLFNBQVNzSyxHQUFULENBQWFRLEdBQWIsRUFBa0JPLEVBQWxCLEVBQXNCO0FBQ3JDLE9BQUk4N0QsU0FBUyxFQUFiO0FBQ0E5QyxXQUFRdjVELEdBQVIsRUFBYSxVQUFTQyxJQUFULEVBQWVxOEQsU0FBZixFQUEwQjtBQUNyQ0QsWUFBT2oxRCxJQUFQLENBQVk3RyxHQUFHTixJQUFILEVBQVNxOEQsU0FBVCxFQUFvQnQ4RCxHQUFwQixDQUFaO0FBQ0QsSUFGRDtBQUdBLFVBQU9xOEQsTUFBUDtBQUNELEVBTkQsQzs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBcG5FLFFBQU9DLE9BQVAsR0FBaUIsU0FBU2c5RCxXQUFULENBQXFCM3hELEVBQXJCLEVBQXlCMnpELFdBQXpCLEVBQXNDO0FBQ3JEQSxlQUFZM3pELEVBQVosRUFBZ0IsQ0FBaEI7QUFDRCxFQUZELEM7Ozs7OztBQ0pBOztBQUVBOztBQUVBdEwsUUFBT0MsT0FBUCxHQUFpQm0vRCxZQUFqQjs7QUFFQSxLQUFJM0YsV0FBVyxtQkFBQTNGLENBQVEsRUFBUixDQUFmO0FBQ0EsS0FBSXdULGVBQWUsbUJBQUF4VCxDQUFRLEVBQVIsRUFBa0J3VCxZQUFyQzs7QUFFQSxVQUFTbEksWUFBVCxHQUF3QixDQUN2Qjs7QUFFRDNGLFVBQVMyRixZQUFULEVBQXVCa0ksWUFBdkI7O0FBRUFsSSxjQUFheCtELFNBQWIsQ0FBdUJrK0MsSUFBdkIsR0FBOEIsWUFBVztBQUN2QyxRQUFLeWdCLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxRQUFLZ0ksTUFBTDtBQUNELEVBSEQ7O0FBS0FuSSxjQUFheCtELFNBQWIsQ0FBdUIrK0QsSUFBdkIsR0FBOEIsWUFBVztBQUN2QyxRQUFLOTFDLElBQUwsQ0FBVSxLQUFWO0FBQ0EsUUFBSzA5QyxNQUFMO0FBQ0QsRUFIRDs7QUFLQW5JLGNBQWF4K0QsU0FBYixDQUF1QjYrRCxNQUF2QixHQUFnQyxVQUFTcHRELEdBQVQsRUFBYztBQUM1QyxRQUFLd1gsSUFBTCxDQUFVLE9BQVYsRUFBbUJ4WCxHQUFuQjtBQUNBLFFBQUtrMUQsTUFBTDtBQUNELEVBSEQ7O0FBS0FuSSxjQUFheCtELFNBQWIsQ0FBdUI4K0QsT0FBdkIsR0FBaUMsVUFBUzVyQixPQUFULEVBQWtCO0FBQ2pELFFBQUtqcUIsSUFBTCxDQUFVLFFBQVYsRUFBb0JpcUIsT0FBcEI7QUFDRCxFQUZEOztBQUlBc3JCLGNBQWF4K0QsU0FBYixDQUF1QjJtRSxNQUF2QixHQUFnQyxZQUFXO0FBQ3pDLFFBQUs1Z0Isa0JBQUwsQ0FBd0IsTUFBeEI7QUFDQSxRQUFLQSxrQkFBTCxDQUF3QixLQUF4QjtBQUNBLFFBQUtBLGtCQUFMLENBQXdCLE9BQXhCO0FBQ0EsUUFBS0Esa0JBQUwsQ0FBd0IsUUFBeEI7QUFDRCxFQUxELEM7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTMmdCLFlBQVQsR0FBd0I7QUFDdEIsUUFBS3pqRCxPQUFMLEdBQWUsS0FBS0EsT0FBTCxJQUFnQixFQUEvQjtBQUNBLFFBQUsyakQsYUFBTCxHQUFxQixLQUFLQSxhQUFMLElBQXNCcm1FLFNBQTNDO0FBQ0Q7QUFDRG5CLFFBQU9DLE9BQVAsR0FBaUJxbkUsWUFBakI7O0FBRUE7QUFDQUEsY0FBYUEsWUFBYixHQUE0QkEsWUFBNUI7O0FBRUFBLGNBQWExbUUsU0FBYixDQUF1QmlqQixPQUF2QixHQUFpQzFpQixTQUFqQztBQUNBbW1FLGNBQWExbUUsU0FBYixDQUF1QjRtRSxhQUF2QixHQUF1Q3JtRSxTQUF2Qzs7QUFFQTtBQUNBO0FBQ0FtbUUsY0FBYUcsbUJBQWIsR0FBbUMsRUFBbkM7O0FBRUE7QUFDQTtBQUNBSCxjQUFhMW1FLFNBQWIsQ0FBdUI4bUUsZUFBdkIsR0FBeUMsVUFBU2grRCxDQUFULEVBQVk7QUFDbkQsT0FBSSxDQUFDaStELFNBQVNqK0QsQ0FBVCxDQUFELElBQWdCQSxJQUFJLENBQXBCLElBQXlCUyxNQUFNVCxDQUFOLENBQTdCLEVBQ0UsTUFBTXpGLFVBQVUsNkJBQVYsQ0FBTjtBQUNGLFFBQUt1akUsYUFBTCxHQUFxQjk5RCxDQUFyQjtBQUNBLFVBQU8sSUFBUDtBQUNELEVBTEQ7O0FBT0E0OUQsY0FBYTFtRSxTQUFiLENBQXVCaXBCLElBQXZCLEdBQThCLFVBQVNwUCxJQUFULEVBQWU7QUFDM0MsT0FBSW10RCxFQUFKLEVBQVFoN0MsT0FBUixFQUFpQjNWLEdBQWpCLEVBQXNCRCxJQUF0QixFQUE0QnpWLENBQTVCLEVBQStCd2lCLFNBQS9COztBQUVBLE9BQUksQ0FBQyxLQUFLRixPQUFWLEVBQ0UsS0FBS0EsT0FBTCxHQUFlLEVBQWY7O0FBRUY7QUFDQSxPQUFJcEosU0FBUyxPQUFiLEVBQXNCO0FBQ3BCLFNBQUksQ0FBQyxLQUFLb0osT0FBTCxDQUFheGMsS0FBZCxJQUNDOEIsU0FBUyxLQUFLMGEsT0FBTCxDQUFheGMsS0FBdEIsS0FBZ0MsQ0FBQyxLQUFLd2MsT0FBTCxDQUFheGMsS0FBYixDQUFtQjdGLE1BRHpELEVBQ2tFO0FBQ2hFb21FLFlBQUs1bUUsVUFBVSxDQUFWLENBQUw7QUFDQSxXQUFJNG1FLGNBQWNyaUIsS0FBbEIsRUFBeUI7QUFDdkIsZUFBTXFpQixFQUFOLENBRHVCLENBQ2I7QUFDWCxRQUZELE1BRU87QUFDTDtBQUNBLGFBQUl2MUQsTUFBTSxJQUFJa3pDLEtBQUosQ0FBVSwyQ0FBMkNxaUIsRUFBM0MsR0FBZ0QsR0FBMUQsQ0FBVjtBQUNBdjFELGFBQUkyTSxPQUFKLEdBQWM0b0QsRUFBZDtBQUNBLGVBQU12MUQsR0FBTjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRHVhLGFBQVUsS0FBSy9JLE9BQUwsQ0FBYXBKLElBQWIsQ0FBVjs7QUFFQSxPQUFJb3RELFlBQVlqN0MsT0FBWixDQUFKLEVBQ0UsT0FBTyxLQUFQOztBQUVGLE9BQUk2NUMsV0FBVzc1QyxPQUFYLENBQUosRUFBeUI7QUFDdkIsYUFBUTVyQixVQUFVUSxNQUFsQjtBQUNFO0FBQ0EsWUFBSyxDQUFMO0FBQ0VvckIsaUJBQVEvckIsSUFBUixDQUFhLElBQWI7QUFDQTtBQUNGLFlBQUssQ0FBTDtBQUNFK3JCLGlCQUFRL3JCLElBQVIsQ0FBYSxJQUFiLEVBQW1CRyxVQUFVLENBQVYsQ0FBbkI7QUFDQTtBQUNGLFlBQUssQ0FBTDtBQUNFNHJCLGlCQUFRL3JCLElBQVIsQ0FBYSxJQUFiLEVBQW1CRyxVQUFVLENBQVYsQ0FBbkIsRUFBaUNBLFVBQVUsQ0FBVixDQUFqQztBQUNBO0FBQ0Y7QUFDQTtBQUNFZ1csZ0JBQU9ySyxNQUFNL0wsU0FBTixDQUFnQnVDLEtBQWhCLENBQXNCdEMsSUFBdEIsQ0FBMkJHLFNBQTNCLEVBQXNDLENBQXRDLENBQVA7QUFDQTRyQixpQkFBUTdyQixLQUFSLENBQWMsSUFBZCxFQUFvQmlXLElBQXBCO0FBZEo7QUFnQkQsSUFqQkQsTUFpQk8sSUFBSTdOLFNBQVN5akIsT0FBVCxDQUFKLEVBQXVCO0FBQzVCNVYsWUFBT3JLLE1BQU0vTCxTQUFOLENBQWdCdUMsS0FBaEIsQ0FBc0J0QyxJQUF0QixDQUEyQkcsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBUDtBQUNBK2lCLGlCQUFZNkksUUFBUXpwQixLQUFSLEVBQVo7QUFDQThULFdBQU04TSxVQUFVdmlCLE1BQWhCO0FBQ0EsVUFBS0QsSUFBSSxDQUFULEVBQVlBLElBQUkwVixHQUFoQixFQUFxQjFWLEdBQXJCO0FBQ0V3aUIsaUJBQVV4aUIsQ0FBVixFQUFhUixLQUFiLENBQW1CLElBQW5CLEVBQXlCaVcsSUFBekI7QUFERjtBQUVEOztBQUVELFVBQU8sSUFBUDtBQUNELEVBckREOztBQXVEQXN3RCxjQUFhMW1FLFNBQWIsQ0FBdUJnRixXQUF2QixHQUFxQyxVQUFTNlUsSUFBVCxFQUFlcXRELFFBQWYsRUFBeUI7QUFDNUQsT0FBSXg2RCxDQUFKOztBQUVBLE9BQUksQ0FBQ201RCxXQUFXcUIsUUFBWCxDQUFMLEVBQ0UsTUFBTTdqRSxVQUFVLDZCQUFWLENBQU47O0FBRUYsT0FBSSxDQUFDLEtBQUs0ZixPQUFWLEVBQ0UsS0FBS0EsT0FBTCxHQUFlLEVBQWY7O0FBRUY7QUFDQTtBQUNBLE9BQUksS0FBS0EsT0FBTCxDQUFha2tELFdBQWpCLEVBQ0UsS0FBS2wrQyxJQUFMLENBQVUsYUFBVixFQUF5QnBQLElBQXpCLEVBQ1Vnc0QsV0FBV3FCLFNBQVNBLFFBQXBCLElBQ0FBLFNBQVNBLFFBRFQsR0FDb0JBLFFBRjlCOztBQUlGLE9BQUksQ0FBQyxLQUFLamtELE9BQUwsQ0FBYXBKLElBQWIsQ0FBTDtBQUNFO0FBQ0EsVUFBS29KLE9BQUwsQ0FBYXBKLElBQWIsSUFBcUJxdEQsUUFBckIsQ0FGRixLQUdLLElBQUkzK0QsU0FBUyxLQUFLMGEsT0FBTCxDQUFhcEosSUFBYixDQUFULENBQUo7QUFDSDtBQUNBLFVBQUtvSixPQUFMLENBQWFwSixJQUFiLEVBQW1CdEksSUFBbkIsQ0FBd0IyMUQsUUFBeEIsRUFGRztBQUlIO0FBQ0EsVUFBS2prRCxPQUFMLENBQWFwSixJQUFiLElBQXFCLENBQUMsS0FBS29KLE9BQUwsQ0FBYXBKLElBQWIsQ0FBRCxFQUFxQnF0RCxRQUFyQixDQUFyQjs7QUFFRjtBQUNBLE9BQUkzK0QsU0FBUyxLQUFLMGEsT0FBTCxDQUFhcEosSUFBYixDQUFULEtBQWdDLENBQUMsS0FBS29KLE9BQUwsQ0FBYXBKLElBQWIsRUFBbUI0L0IsTUFBeEQsRUFBZ0U7QUFDOUQsU0FBSSxDQUFDd3RCLFlBQVksS0FBS0wsYUFBakIsQ0FBTCxFQUFzQztBQUNwQ2w2RCxXQUFJLEtBQUtrNkQsYUFBVDtBQUNELE1BRkQsTUFFTztBQUNMbDZELFdBQUlnNkQsYUFBYUcsbUJBQWpCO0FBQ0Q7O0FBRUQsU0FBSW42RCxLQUFLQSxJQUFJLENBQVQsSUFBYyxLQUFLdVcsT0FBTCxDQUFhcEosSUFBYixFQUFtQmpaLE1BQW5CLEdBQTRCOEwsQ0FBOUMsRUFBaUQ7QUFDL0MsWUFBS3VXLE9BQUwsQ0FBYXBKLElBQWIsRUFBbUI0L0IsTUFBbkIsR0FBNEIsSUFBNUI7QUFDQW41QyxlQUFRbUcsS0FBUixDQUFjLGtEQUNBLHFDQURBLEdBRUEsa0RBRmQsRUFHYyxLQUFLd2MsT0FBTCxDQUFhcEosSUFBYixFQUFtQmpaLE1BSGpDO0FBSUEsV0FBSSxPQUFPTixRQUFROEYsS0FBZixLQUF5QixVQUE3QixFQUF5QztBQUN2QztBQUNBOUYsaUJBQVE4RixLQUFSO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQU8sSUFBUDtBQUNELEVBaEREOztBQWtEQXNnRSxjQUFhMW1FLFNBQWIsQ0FBdUJxZ0IsRUFBdkIsR0FBNEJxbUQsYUFBYTFtRSxTQUFiLENBQXVCZ0YsV0FBbkQ7O0FBRUEwaEUsY0FBYTFtRSxTQUFiLENBQXVCd04sSUFBdkIsR0FBOEIsVUFBU3FNLElBQVQsRUFBZXF0RCxRQUFmLEVBQXlCO0FBQ3JELE9BQUksQ0FBQ3JCLFdBQVdxQixRQUFYLENBQUwsRUFDRSxNQUFNN2pFLFVBQVUsNkJBQVYsQ0FBTjs7QUFFRixPQUFJK2pFLFFBQVEsS0FBWjs7QUFFQSxZQUFTcHhCLENBQVQsR0FBYTtBQUNYLFVBQUs4UCxjQUFMLENBQW9CanNDLElBQXBCLEVBQTBCbThCLENBQTFCOztBQUVBLFNBQUksQ0FBQ294QixLQUFMLEVBQVk7QUFDVkEsZUFBUSxJQUFSO0FBQ0FGLGdCQUFTL21FLEtBQVQsQ0FBZSxJQUFmLEVBQXFCQyxTQUFyQjtBQUNEO0FBQ0Y7O0FBRUQ0MUMsS0FBRWt4QixRQUFGLEdBQWFBLFFBQWI7QUFDQSxRQUFLN21ELEVBQUwsQ0FBUXhHLElBQVIsRUFBY204QixDQUFkOztBQUVBLFVBQU8sSUFBUDtBQUNELEVBbkJEOztBQXFCQTtBQUNBMHdCLGNBQWExbUUsU0FBYixDQUF1QjhsRCxjQUF2QixHQUF3QyxVQUFTanNDLElBQVQsRUFBZXF0RCxRQUFmLEVBQXlCO0FBQy9ELE9BQUlyOUQsSUFBSixFQUFVdzlELFFBQVYsRUFBb0J6bUUsTUFBcEIsRUFBNEJELENBQTVCOztBQUVBLE9BQUksQ0FBQ2tsRSxXQUFXcUIsUUFBWCxDQUFMLEVBQ0UsTUFBTTdqRSxVQUFVLDZCQUFWLENBQU47O0FBRUYsT0FBSSxDQUFDLEtBQUs0ZixPQUFOLElBQWlCLENBQUMsS0FBS0EsT0FBTCxDQUFhcEosSUFBYixDQUF0QixFQUNFLE9BQU8sSUFBUDs7QUFFRmhRLFVBQU8sS0FBS29aLE9BQUwsQ0FBYXBKLElBQWIsQ0FBUDtBQUNBalosWUFBU2lKLEtBQUtqSixNQUFkO0FBQ0F5bUUsY0FBVyxDQUFDLENBQVo7O0FBRUEsT0FBSXg5RCxTQUFTcTlELFFBQVQsSUFDQ3JCLFdBQVdoOEQsS0FBS3E5RCxRQUFoQixLQUE2QnI5RCxLQUFLcTlELFFBQUwsS0FBa0JBLFFBRHBELEVBQytEO0FBQzdELFlBQU8sS0FBS2prRCxPQUFMLENBQWFwSixJQUFiLENBQVA7QUFDQSxTQUFJLEtBQUtvSixPQUFMLENBQWE2aUMsY0FBakIsRUFDRSxLQUFLNzhCLElBQUwsQ0FBVSxnQkFBVixFQUE0QnBQLElBQTVCLEVBQWtDcXRELFFBQWxDO0FBRUgsSUFORCxNQU1PLElBQUkzK0QsU0FBU3NCLElBQVQsQ0FBSixFQUFvQjtBQUN6QixVQUFLbEosSUFBSUMsTUFBVCxFQUFpQkQsTUFBTSxDQUF2QixHQUEyQjtBQUN6QixXQUFJa0osS0FBS2xKLENBQUwsTUFBWXVtRSxRQUFaLElBQ0NyOUQsS0FBS2xKLENBQUwsRUFBUXVtRSxRQUFSLElBQW9CcjlELEtBQUtsSixDQUFMLEVBQVF1bUUsUUFBUixLQUFxQkEsUUFEOUMsRUFDeUQ7QUFDdkRHLG9CQUFXMW1FLENBQVg7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsU0FBSTBtRSxXQUFXLENBQWYsRUFDRSxPQUFPLElBQVA7O0FBRUYsU0FBSXg5RCxLQUFLakosTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQmlKLFlBQUtqSixNQUFMLEdBQWMsQ0FBZDtBQUNBLGNBQU8sS0FBS3FpQixPQUFMLENBQWFwSixJQUFiLENBQVA7QUFDRCxNQUhELE1BR087QUFDTGhRLFlBQUtRLE1BQUwsQ0FBWWc5RCxRQUFaLEVBQXNCLENBQXRCO0FBQ0Q7O0FBRUQsU0FBSSxLQUFLcGtELE9BQUwsQ0FBYTZpQyxjQUFqQixFQUNFLEtBQUs3OEIsSUFBTCxDQUFVLGdCQUFWLEVBQTRCcFAsSUFBNUIsRUFBa0NxdEQsUUFBbEM7QUFDSDs7QUFFRCxVQUFPLElBQVA7QUFDRCxFQTNDRDs7QUE2Q0FSLGNBQWExbUUsU0FBYixDQUF1QitsRCxrQkFBdkIsR0FBNEMsVUFBU2xzQyxJQUFULEVBQWU7QUFDekQsT0FBSXJQLEdBQUosRUFBUzJZLFNBQVQ7O0FBRUEsT0FBSSxDQUFDLEtBQUtGLE9BQVYsRUFDRSxPQUFPLElBQVA7O0FBRUY7QUFDQSxPQUFJLENBQUMsS0FBS0EsT0FBTCxDQUFhNmlDLGNBQWxCLEVBQWtDO0FBQ2hDLFNBQUkxbEQsVUFBVVEsTUFBVixLQUFxQixDQUF6QixFQUNFLEtBQUtxaUIsT0FBTCxHQUFlLEVBQWYsQ0FERixLQUVLLElBQUksS0FBS0EsT0FBTCxDQUFhcEosSUFBYixDQUFKLEVBQ0gsT0FBTyxLQUFLb0osT0FBTCxDQUFhcEosSUFBYixDQUFQO0FBQ0YsWUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFJelosVUFBVVEsTUFBVixLQUFxQixDQUF6QixFQUE0QjtBQUMxQixVQUFLNEosR0FBTCxJQUFZLEtBQUt5WSxPQUFqQixFQUEwQjtBQUN4QixXQUFJelksUUFBUSxnQkFBWixFQUE4QjtBQUM5QixZQUFLdTdDLGtCQUFMLENBQXdCdjdDLEdBQXhCO0FBQ0Q7QUFDRCxVQUFLdTdDLGtCQUFMLENBQXdCLGdCQUF4QjtBQUNBLFVBQUs5aUMsT0FBTCxHQUFlLEVBQWY7QUFDQSxZQUFPLElBQVA7QUFDRDs7QUFFREUsZUFBWSxLQUFLRixPQUFMLENBQWFwSixJQUFiLENBQVo7O0FBRUEsT0FBSWdzRCxXQUFXMWlELFNBQVgsQ0FBSixFQUEyQjtBQUN6QixVQUFLMmlDLGNBQUwsQ0FBb0Jqc0MsSUFBcEIsRUFBMEJzSixTQUExQjtBQUNELElBRkQsTUFFTyxJQUFJQSxTQUFKLEVBQWU7QUFDcEI7QUFDQSxZQUFPQSxVQUFVdmlCLE1BQWpCO0FBQ0UsWUFBS2tsRCxjQUFMLENBQW9CanNDLElBQXBCLEVBQTBCc0osVUFBVUEsVUFBVXZpQixNQUFWLEdBQW1CLENBQTdCLENBQTFCO0FBREY7QUFFRDtBQUNELFVBQU8sS0FBS3FpQixPQUFMLENBQWFwSixJQUFiLENBQVA7O0FBRUEsVUFBTyxJQUFQO0FBQ0QsRUF0Q0Q7O0FBd0NBNnNELGNBQWExbUUsU0FBYixDQUF1Qm1qQixTQUF2QixHQUFtQyxVQUFTdEosSUFBVCxFQUFlO0FBQ2hELE9BQUkvTixHQUFKO0FBQ0EsT0FBSSxDQUFDLEtBQUttWCxPQUFOLElBQWlCLENBQUMsS0FBS0EsT0FBTCxDQUFhcEosSUFBYixDQUF0QixFQUNFL04sTUFBTSxFQUFOLENBREYsS0FFSyxJQUFJKzVELFdBQVcsS0FBSzVpRCxPQUFMLENBQWFwSixJQUFiLENBQVgsQ0FBSixFQUNIL04sTUFBTSxDQUFDLEtBQUttWCxPQUFMLENBQWFwSixJQUFiLENBQUQsQ0FBTixDQURHLEtBR0gvTixNQUFNLEtBQUttWCxPQUFMLENBQWFwSixJQUFiLEVBQW1CdFgsS0FBbkIsRUFBTjtBQUNGLFVBQU91SixHQUFQO0FBQ0QsRUFURDs7QUFXQTQ2RCxjQUFhMW1FLFNBQWIsQ0FBdUJzbkUsYUFBdkIsR0FBdUMsVUFBU3p0RCxJQUFULEVBQWU7QUFDcEQsT0FBSSxLQUFLb0osT0FBVCxFQUFrQjtBQUNoQixTQUFJc2tELGFBQWEsS0FBS3RrRCxPQUFMLENBQWFwSixJQUFiLENBQWpCOztBQUVBLFNBQUlnc0QsV0FBVzBCLFVBQVgsQ0FBSixFQUNFLE9BQU8sQ0FBUCxDQURGLEtBRUssSUFBSUEsVUFBSixFQUNILE9BQU9BLFdBQVczbUUsTUFBbEI7QUFDSDtBQUNELFVBQU8sQ0FBUDtBQUNELEVBVkQ7O0FBWUE4bEUsY0FBYVksYUFBYixHQUE2QixVQUFTRSxPQUFULEVBQWtCM3RELElBQWxCLEVBQXdCO0FBQ25ELFVBQU8ydEQsUUFBUUYsYUFBUixDQUFzQnp0RCxJQUF0QixDQUFQO0FBQ0QsRUFGRDs7QUFJQSxVQUFTZ3NELFVBQVQsQ0FBb0I1akMsR0FBcEIsRUFBeUI7QUFDdkIsVUFBTyxPQUFPQSxHQUFQLEtBQWUsVUFBdEI7QUFDRDs7QUFFRCxVQUFTOGtDLFFBQVQsQ0FBa0I5a0MsR0FBbEIsRUFBdUI7QUFDckIsVUFBTyxPQUFPQSxHQUFQLEtBQWUsUUFBdEI7QUFDRDs7QUFFRCxVQUFTMTVCLFFBQVQsQ0FBa0IwNUIsR0FBbEIsRUFBdUI7QUFDckIsVUFBTyxRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBZixJQUEyQkEsUUFBUSxJQUExQztBQUNEOztBQUVELFVBQVNnbEMsV0FBVCxDQUFxQmhsQyxHQUFyQixFQUEwQjtBQUN4QixVQUFPQSxRQUFRLEtBQUssQ0FBcEI7QUFDRCxFOzs7Ozs7OztBQzdTRDdpQyxRQUFPQyxPQUFQLEdBQWlCdTVELGlCQUFqQjs7QUFFQSxLQUFJL1YsU0FBUyxtQkFBQXFRLENBQVEsRUFBUixDQUFiO0FBQ0EsS0FBSW1KLGNBQWMsbUJBQUFuSixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxLQUFJa0osWUFBWSxtQkFBQWxKLENBQVEsRUFBUixDQUFoQjtBQUNBLEtBQUl1VSxRQUFRLG1CQUFBdlUsQ0FBUSxFQUFSLENBQVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSXdVLHFCQUFxQixHQUF6QjtBQUNBLEtBQUlDLHVCQUNGMTVELFFBQVFDLEdBQVIsQ0FBWXk1RCxvQkFBWixJQUFvQzFvQixTQUFTaHhDLFFBQVFDLEdBQVIsQ0FBWXk1RCxvQkFBckIsRUFBMkMsRUFBM0MsQ0FBcEMsSUFDQSxLQUFLLENBQUwsR0FBUyxJQUZYLEMsQ0FFaUI7O0FBRWpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLFVBQVMvTyxpQkFBVCxDQUEyQmdQLGFBQTNCLEVBQTBDbGpFLE1BQTFDLEVBQWtEOE4sSUFBbEQsRUFBd0Q7QUFDdEQsT0FBSTFSLFFBQVEsbUJBQUFveUQsQ0FBUSxFQUFSLEVBQWlCLGVBQWpCLENBQVo7O0FBRUEsT0FBSTFnQixRQUFRLG1CQUFBMGdCLENBQVEsRUFBUixDQUFaO0FBQ0EsT0FBSWhtRCxVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXZwRCxNQUFNLG1CQUFBdXBELENBQVEsRUFBUixDQUFWOztBQUVBLE9BQUlxSCxRQUFRLG1EQUFaOztBQUVBLE9BQUkvbkQsS0FBS3ExRCxzQkFBTCxLQUFnQyxJQUFoQyxJQUF3QyxDQUFDRCxhQUE3QyxFQUE0RDtBQUMxRCxXQUFNLElBQUkva0IsT0FBT3NaLGtCQUFYLENBQThCLHVDQUF1QzVCLEtBQXJFLENBQU47QUFDRDs7QUFFRCxPQUFJL25ELEtBQUtxMUQsc0JBQUwsS0FBZ0MsSUFBaEMsSUFBd0MsQ0FBQ25qRSxNQUE3QyxFQUFxRDtBQUNuRCxXQUFNLElBQUltK0MsT0FBT3NaLGtCQUFYLENBQThCLGdDQUFnQzVCLEtBQTlELENBQU47QUFDRDs7QUFFRCxRQUFLcU4sYUFBTCxHQUFxQkEsYUFBckI7QUFDQSxRQUFLbGpFLE1BQUwsR0FBY0EsTUFBZDs7QUFFQSxRQUFLb2pFLEtBQUwsR0FBYTtBQUNYQyxXQUFNLEVBREs7QUFFWEMsWUFBTztBQUZJLElBQWI7O0FBS0F4MUQsVUFBT0EsUUFBUSxFQUFmOztBQUVBLE9BQUl5aUQsV0FBV3ppRCxLQUFLeWlELFFBQUwsSUFBaUIsUUFBaEM7QUFDQSxRQUFLZ1QsU0FBTCxHQUFpQnoxRCxLQUFLMDFELFFBQUwsSUFBaUI7QUFDaENDLGNBQVMsSUFBSSxJQURtQixFQUNiO0FBQ25CSixXQUFNLElBQUksSUFGc0I7QUFHaENDLFlBQU8sS0FBSztBQUhvQixJQUFsQzs7QUFNQTtBQUNBLE9BQUl4MUQsS0FBS3NRLE9BQVQsRUFBa0I7QUFDaEIsVUFBS21sRCxTQUFMLENBQWVFLE9BQWYsR0FBeUIsS0FBS0YsU0FBTCxDQUFlRixJQUFmLEdBQXNCLEtBQUtFLFNBQUwsQ0FBZUQsS0FBZixHQUF1QngxRCxLQUFLc1EsT0FBM0U7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsT0FBSSxDQUFDLEtBQUtqVCxJQUFMLENBQVVvbEQsUUFBVixDQUFMLEVBQTBCO0FBQ3hCQSxnQkFBV0EsV0FBVyxHQUF0QjtBQUNEOztBQUVELE9BQUl6aUQsS0FBS3lpRCxRQUFMLEtBQWtCLE9BQWxCLElBQTZCemlELEtBQUt5aUQsUUFBTCxLQUFrQixRQUFuRCxFQUE2RDtBQUMzRCxXQUFNLElBQUlwUyxPQUFPc1osa0JBQVgsQ0FBOEIsZ0RBQWdEM3BELEtBQUt5aUQsUUFBckQsR0FBZ0UsSUFBOUYsQ0FBTjtBQUNEOztBQUVELFFBQUttVCxlQUFMOztBQUVBLE9BQUksQ0FBQzUxRCxLQUFLczFELEtBQVYsRUFBaUI7QUFDZixTQUFJTyxlQUFlMStELElBQUksS0FBSzIrRCxjQUFULEVBQXlCLFVBQVNDLFVBQVQsRUFBcUI7QUFDL0QsY0FBT1gsZ0JBQWdCLEdBQWhCLEdBQXNCVyxVQUF0QixHQUFtQyxpQkFBMUM7QUFDRCxNQUZrQixDQUFuQjs7QUFJQTtBQUNBLFVBQUtULEtBQUwsQ0FBV0MsSUFBWCxHQUFrQixDQUFDLEtBQUtILGFBQUwsR0FBcUIsa0JBQXRCLEVBQTBDajdELE1BQTFDLENBQWlEMDdELFlBQWpELENBQWxCO0FBQ0EsVUFBS1AsS0FBTCxDQUFXRSxLQUFYLEdBQW1CLENBQUMsS0FBS0osYUFBTCxHQUFxQixjQUF0QixFQUFzQ2o3RCxNQUF0QyxDQUE2QzA3RCxZQUE3QyxDQUFuQjtBQUNELElBUkQsTUFRTyxJQUFJbjdELFFBQVFzRixLQUFLczFELEtBQWIsQ0FBSixFQUF5QjtBQUM5QjtBQUNBO0FBQ0EsVUFBS0EsS0FBTCxDQUFXQyxJQUFYLEdBQWtCdjFCLE1BQU1oZ0MsS0FBS3MxRCxLQUFYLENBQWxCO0FBQ0EsVUFBS0EsS0FBTCxDQUFXRSxLQUFYLEdBQW1CeDFCLE1BQU1oZ0MsS0FBS3MxRCxLQUFYLENBQW5CO0FBQ0QsSUFMTSxNQUtBO0FBQ0wsVUFBS0EsS0FBTCxDQUFXQyxJQUFYLEdBQWtCdjFCLE1BQU1oZ0MsS0FBS3MxRCxLQUFMLENBQVdDLElBQWpCLENBQWxCO0FBQ0EsVUFBS0QsS0FBTCxDQUFXRSxLQUFYLEdBQW1CeDFCLE1BQU1oZ0MsS0FBS3MxRCxLQUFMLENBQVdFLEtBQWpCLENBQW5CO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFLRixLQUFMLENBQVdDLElBQVgsR0FBa0JwK0QsSUFBSSxLQUFLbStELEtBQUwsQ0FBV0MsSUFBZixFQUFxQlMsWUFBWXZULFFBQVosQ0FBckIsQ0FBbEI7QUFDQSxRQUFLNlMsS0FBTCxDQUFXRSxLQUFYLEdBQW1CcitELElBQUksS0FBS20rRCxLQUFMLENBQVdFLEtBQWYsRUFBc0JRLFlBQVl2VCxRQUFaLENBQXRCLENBQW5COztBQUVBLFFBQUt3VCxZQUFMLEdBQW9CLEVBQXBCOztBQUVBO0FBQ0EsUUFBSzk5RCxLQUFMLEdBQWE2SCxLQUFLazJELE1BQUwsSUFBZSxFQUE1Qjs7QUFFQSxRQUFLQyxHQUFMLEdBQVduMkQsS0FBS20yRCxHQUFoQjtBQUNBLFFBQUtDLFNBQUwsR0FBaUJwMkQsS0FBS28yRCxTQUFMLEtBQW1Ccm9FLFNBQW5CLElBQWdDaVMsS0FBS2syRCxNQUFyQyxHQUE4QyxJQUE5QyxHQUFxRGwyRCxLQUFLbzJELFNBQTNFO0FBQ0EsUUFBS0MsWUFBTCxHQUFvQnIyRCxLQUFLczJELFdBQUwsS0FBcUJ2b0UsU0FBckIsR0FBaUMsSUFBakMsR0FBd0NpUyxLQUFLczJELFdBQWpFOztBQUVBLFFBQUt6SyxXQUFMLEdBQW1CN3JELEtBQUs2ckQsV0FBeEI7O0FBRUF2OUQsU0FBTSxlQUFOLEVBQXVCLElBQXZCO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BODNELG1CQUFrQjU0RCxTQUFsQixDQUE0Qm0xRCxTQUE1QixHQUF3QyxVQUFTNEQsU0FBVCxFQUFvQjtBQUMxRCxVQUFPLElBQUlxRCxTQUFKLENBQWMsSUFBZCxFQUFvQnJELFNBQXBCLENBQVA7QUFDRCxFQUZEOztBQUlBOzs7Ozs7QUFNQUgsbUJBQWtCNTRELFNBQWxCLENBQTRCK29FLGNBQTVCLEdBQTZDLFVBQVM3bkUsSUFBVCxFQUFlb0gsS0FBZixFQUFzQjtBQUNqRSxRQUFLbWdFLFlBQUwsQ0FBa0J2bkUsS0FBSzZJLFdBQUwsRUFBbEIsSUFBd0N6QixLQUF4QztBQUNELEVBRkQ7O0FBSUE7Ozs7O0FBS0Fzd0QsbUJBQWtCNTRELFNBQWxCLENBQTRCZ3BFLGNBQTVCLEdBQTZDLFVBQVM5bkUsSUFBVCxFQUFlO0FBQzFELFVBQU8sS0FBS3VuRSxZQUFMLENBQWtCdm5FLEtBQUs2SSxXQUFMLEVBQWxCLENBQVA7QUFDRCxFQUZEOztBQUlBOzs7OztBQUtBNnVELG1CQUFrQjU0RCxTQUFsQixDQUE0QmlwRSxnQkFBNUIsR0FBK0MsVUFBUy9uRSxJQUFULEVBQWU7QUFDNUQsVUFBTyxLQUFLdW5FLFlBQUwsQ0FBa0J2bkUsS0FBSzZJLFdBQUwsRUFBbEIsQ0FBUDtBQUNELEVBRkQ7O0FBSUE7Ozs7OztBQU1BNnVELG1CQUFrQjU0RCxTQUFsQixDQUE0QmtwRSxlQUE1QixHQUE4QyxVQUFTQyxZQUFULEVBQXVCO0FBQ25FLE9BQUksS0FBS1IsR0FBTCxDQUFTdG1FLE9BQVQsQ0FBaUIsTUFBTThtRSxZQUF2QixNQUF5QyxDQUFDLENBQTlDLEVBQWlEO0FBQy9DLFVBQUtSLEdBQUwsSUFBWSxNQUFNUSxZQUFsQjtBQUNEO0FBQ0YsRUFKRDs7QUFNQTs7O0FBR0F2USxtQkFBa0I1NEQsU0FBbEIsQ0FBNEJnNUQsWUFBNUIsR0FBMkMsVUFBU29RLFdBQVQsRUFBc0I7QUFDL0QsUUFBS2hCLGVBQUw7O0FBRUEsT0FBSWlCLGVBQWUsbUJBQUFuVyxDQUFRLEVBQVIsRUFBaUIsbUJBQW1Ca1csWUFBWXBqRSxHQUFoRCxDQUFuQjs7QUFFQSxPQUFJOHJDLElBQUo7QUFDQSxPQUFJeXdCLGVBQWU2RyxZQUFZN0csWUFBWixJQUE0QixFQUEvQztBQUNBLE9BQUk1M0QsUUFBUXkrRCxZQUFZeitELEtBQXhCO0FBQ0EsT0FBSTZ5RCxTQUFTLElBQWI7QUFDQSxPQUFJOEwsUUFBUSxDQUFaO0FBQ0EsT0FBSUMsZ0JBQWdCLEtBQXBCO0FBQ0EsT0FBSUMsY0FBY2hNLE9BQU9xTCxZQUFQLElBQXVCckwsT0FBT2lNLFFBQVAsQ0FBZ0J2NUMsUUFBdkMsSUFBbURrNUMsWUFBWWw1QyxRQUFqRjtBQUNBLE9BQUl3NUMsT0FBSjs7QUFFQSxPQUNFLEtBQUtobEUsTUFBTCxDQUFZOUQsTUFBWixHQUFxQjhtRSxrQkFBckIsSUFDQTBCLFlBQVl0M0IsSUFBWixLQUFxQnZ4QyxTQURyQixLQUVDNm9FLFlBQVl0M0IsSUFBWixDQUFpQnVqQixNQUFqQixLQUE0QjkwRCxTQUE1QixJQUF5QztBQUMxQzZvRSxlQUFZdDNCLElBQVosQ0FBaUI4cEIsUUFBakIsS0FBOEJyN0QsU0FIOUIsQ0FERixDQUkyQztBQUozQyxLQUtFO0FBQ0E2b0UsbUJBQVl0M0IsSUFBWixDQUFpQnB0QyxNQUFqQixHQUEwQixLQUFLQSxNQUEvQjtBQUNBZ2xFLGlCQUFVLEtBQUtDLHNCQUFMLENBQTRCcEgsWUFBNUIsRUFBMEMsS0FBMUMsQ0FBVjtBQUNELE1BUkQsTUFRTztBQUNMbUgsZUFBVSxLQUFLQyxzQkFBTCxDQUE0QnBILFlBQTVCLENBQVY7QUFDRDs7QUFFRCxPQUFJNkcsWUFBWXQzQixJQUFaLEtBQXFCdnhDLFNBQXpCLEVBQW9DO0FBQ2xDdXhDLFlBQU84M0Isa0JBQWtCUixZQUFZdDNCLElBQTlCLENBQVA7QUFDRDs7QUFFRHUzQixnQkFBYSxlQUFiO0FBQ0EsT0FBSVEsWUFBWSxFQUFoQjs7QUFFQSxZQUFTQyxTQUFULENBQW1CQyxTQUFuQixFQUE4QkMsT0FBOUIsRUFBdUM7QUFDckN4TSxZQUFPNEssZUFBUDs7QUFFQSxTQUFJNkIsWUFBWSxJQUFJcGlFLElBQUosRUFBaEI7QUFDQSxTQUFJcWlFLE9BQUo7O0FBRUEsU0FBSTFNLE9BQU9vTCxTQUFYLEVBQXNCO0FBQ3BCc0IsaUJBQVVkLFlBQVlwakUsR0FBdEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsU0FBSXczRCxPQUFPb0wsU0FBUCxJQUFvQjkyQixJQUF4QixFQUE4QjtBQUM1Qm80QixrQkFBVyxXQUFXRixRQUFRbDRCLElBQTlCO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFJMHJCLE9BQU9vTCxTQUFQLElBQW9CaitELEtBQXBCLElBQTZCQSxNQUFNdS9ELE9BQU4sTUFBbUIzcEUsU0FBcEQsRUFBK0Q7QUFDN0Q4b0Usb0JBQWEsNkJBQWI7QUFDQSxjQUFPN0wsT0FBT0wsUUFBUCxDQUFnQmwyRCxPQUFoQixDQUF3QmtDLEtBQUtrd0MsS0FBTCxDQUFXMXVDLE1BQU11L0QsT0FBTixDQUFYLENBQXhCLENBQVA7QUFDRDs7QUFFRDtBQUNBLFNBQUlaLFNBQVM5TCxPQUFPc0ssS0FBUCxDQUFhc0IsWUFBWW5RLFFBQXpCLEVBQW1DcjRELE1BQWhELEVBQXdEO0FBQ3RELFdBQUksQ0FBQzRvRSxXQUFELElBQWdCRCxhQUFwQixFQUFtQztBQUNqQ0Ysc0JBQWEsNEJBQWI7QUFDQTtBQUNBLGdCQUFPN0wsT0FBT0wsUUFBUCxDQUFnQmgyRCxNQUFoQixDQUF1QixJQUFJMDdDLE9BQU9zWixrQkFBWCxDQUM1Qiw2Q0FDQSx3RUFEQSxHQUVBLHVCQUZBLEdBRTBCcUIsT0FBT29LLGFBSEwsRUFHb0IsRUFBQ2lDLFdBQVdBLFNBQVosRUFIcEIsQ0FBdkIsQ0FBUDtBQUtEOztBQUVEUixvQkFBYSx1QkFBYjs7QUFFQTtBQUNBQyxlQUFRLENBQVI7O0FBRUE7QUFDQVUsZUFBUW5xRSxNQUFSLEdBQWlCdXBFLFlBQVlsNUMsUUFBWixDQUFxQnJ3QixNQUF0QztBQUNBbXFFLGVBQVFoa0UsR0FBUixHQUFjb2pFLFlBQVlsNUMsUUFBWixDQUFxQmxxQixHQUFuQztBQUNBZ2tFLGVBQVFHLFFBQVIsR0FBbUJmLFlBQVlsNUMsUUFBWixDQUFxQjRoQixJQUF4QztBQUNBLFdBQUlrNEIsUUFBUUcsUUFBWixFQUFzQjtBQUNwQkgsaUJBQVFsNEIsSUFBUixHQUFlODNCLGtCQUFrQkksUUFBUUcsUUFBMUIsQ0FBZjtBQUNEO0FBQ0Q7QUFDQVQsaUJBQVVsTSxPQUFPbU0sc0JBQVAsQ0FBOEJwSCxZQUE5QixDQUFWOztBQUVBeUgsZUFBUTlCLFFBQVIsR0FBbUIxSyxPQUFPNE0sc0JBQVAsQ0FBOEJoQixZQUFZblEsUUFBMUMsQ0FBbkI7QUFDQXVFLGNBQU82TSxtQkFBUCxDQUEyQixDQUEzQixFQUE4QmpCLFlBQVluUSxRQUExQztBQUNBc1EsdUJBQWdCLElBQWhCLENBNUJzRCxDQTRCaEM7QUFDdEIsY0FBT08sVUFBVXRNLE9BQU9pTSxRQUFQLENBQWdCdjVDLFFBQTFCLEVBQW9DODVDLE9BQXBDLENBQVA7QUFDRDs7QUFFRCxTQUFJTSxjQUFjOU0sT0FBTytNLGNBQVAsQ0FBc0JuQixZQUFZblEsUUFBbEMsQ0FBbEI7O0FBRUEsU0FBSWp6RCxNQUFNc2tFLGNBQWNOLFFBQVFoa0UsR0FBaEM7QUFDQSxTQUFJMEssVUFBVTtBQUNab2hDLGFBQU1rNEIsUUFBUWw0QixJQURGO0FBRVpxNEIsaUJBQVVILFFBQVFHLFFBRk47QUFHWnRxRSxlQUFRbXFFLFFBQVFucUUsTUFISjtBQUlaNnBFLGdCQUFTQSxPQUpHO0FBS1p4QixpQkFBVThCLFFBQVE5QixRQUxOO0FBTVpwbkUsY0FBT3VvRTtBQU5LLE1BQWQ7O0FBU0FBLGtCQUFhLGdEQUFiLEVBQ0UzNEQsUUFBUTdRLE1BRFYsRUFDa0JtRyxHQURsQixFQUN1QjBLLFFBQVFnNUQsT0FEL0IsRUFDd0NoNUQsUUFBUXczRCxRQURoRDs7QUFHQSxTQUFJNkIsY0FBY3ZNLE9BQU9pTSxRQUFQLENBQWdCdjVDLFFBQWxDLEVBQTRDO0FBQzFDbTVDLG9CQUFhLGdCQUFiO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFlBQU9VLFVBQVU5cEUsSUFBVixDQUFldTlELE1BQWYsRUFBdUJ4M0QsR0FBdkIsRUFBNEIwSyxPQUE1QixFQUFxQ3ZLLElBQXJDLENBQTBDZzRELE9BQTFDLEVBQW1EcU0sV0FBbkQsQ0FBUDs7QUFFQSxjQUFTck0sT0FBVCxDQUFpQnNNLFlBQWpCLEVBQStCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFJbEwsU0FBU2tMLGdCQUFnQkEsYUFBYTM0QixJQUE3QixJQUFxQzI0QixhQUFhMzRCLElBQWIsQ0FBa0JxYSxPQUF2RCxJQUFrRXNlLGFBQWEzNEIsSUFBYixDQUFrQnl0QixNQUFwRjs7QUFFWDtBQUNBO0FBQ0E7QUFDQWtMLG9CQUFhQyxVQUxGOztBQU9YO0FBQ0E7QUFDQTtBQUNBRCx1QkFBZ0JBLGFBQWEzNEIsSUFBN0IsSUFBcUMsR0FWdkM7O0FBWUF1M0Isb0JBQWEseUVBQWIsRUFDRW9CLGFBQWFDLFVBRGYsRUFDMkJuTCxNQUQzQixFQUNtQ2tMLGFBQWFmLE9BRGhEOztBQUdBLFdBQUlpQixpQkFBaUIzaEUsS0FBS0MsS0FBTCxDQUFXczJELFNBQVMsR0FBcEIsTUFBNkIsQ0FBbEQ7O0FBRUEsV0FBSXFMLFVBQVUsSUFBSS9pRSxJQUFKLEVBQWQ7QUFDQWdpRSxpQkFBVXQ0RCxJQUFWLENBQWU7QUFDYis0RCxzQkFBYUEsV0FEQTtBQUViWixrQkFBU21CLGtCQUFrQm5CLE9BQWxCLENBRkk7QUFHYngyQixrQkFBU3BCLFFBQVEsSUFISjtBQUliZzVCLHdCQUFlaDVCLFNBQVN2eEMsU0FBVCxHQUFxQnV4QyxLQUFLbHhDLE1BQTFCLEdBQW1DLElBSnJDO0FBS2JmLGlCQUFRbXFFLFFBQVFucUUsTUFMSDtBQU1icW9FLG1CQUFVOEIsUUFBUTlCLFFBTkw7QUFPYmxpRSxjQUFLZ2tFLFFBQVFoa0UsR0FQQTtBQVFiaWtFLG9CQUFXQSxTQVJFO0FBU2JXLGtCQUFTQSxPQVRJO0FBVWJwK0IsbUJBQVVvK0IsVUFBVVgsU0FWUDtBQVdiUyxxQkFBWW5MO0FBWEMsUUFBZjs7QUFjQSxXQUFJb0wsY0FBSixFQUFvQjtBQUNsQixhQUFJbk4sT0FBT29MLFNBQVAsSUFBb0JqK0QsS0FBeEIsRUFBK0I7QUFDN0JBLGlCQUFNdS9ELE9BQU4sSUFBaUJPLGFBQWFNLFlBQTlCO0FBQ0Q7O0FBRUQsZ0JBQU9OLGFBQWEzNEIsSUFBcEI7QUFDRDs7QUFFRCxXQUFJazVCLGNBQWNoaUUsS0FBS0MsS0FBTCxDQUFXczJELFNBQVMsR0FBcEIsTUFBNkIsQ0FBL0M7O0FBRUEsV0FBSXlMLFdBQUosRUFBaUI7QUFDZjFCLGtCQUFTLENBQVQ7QUFDQSxnQkFBTzJCLGNBQVA7QUFDRDs7QUFFRDVCLG9CQUFhLHFCQUFiOztBQUVBO0FBQ0EsV0FBSTZCLHFCQUFxQixJQUFJcm9CLE9BQU9zWixrQkFBWCxDQUN2QnNPLGFBQWEzNEIsSUFBYixJQUFxQjI0QixhQUFhMzRCLElBQWIsQ0FBa0JxYSxPQURoQixFQUN5QixFQUFDMGQsV0FBV0EsU0FBWixFQUF1QmEsWUFBWW5MLE1BQW5DLEVBRHpCLENBQXpCOztBQUlBLGNBQU8vQixPQUFPTCxRQUFQLENBQWdCaDJELE1BQWhCLENBQXVCK2pFLGtCQUF2QixDQUFQO0FBQ0Q7O0FBRUQsY0FBU1YsV0FBVCxDQUFxQi80RCxHQUFyQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBNDNELG9CQUFhLHNCQUFiLEVBQXFDNTNELElBQUkwNkMsT0FBekMsRUFBa0QxNkMsSUFBSWtsQyxLQUF0RDs7QUFFQSxXQUFJaTBCLFVBQVUsSUFBSS9pRSxJQUFKLEVBQWQ7QUFDQWdpRSxpQkFBVXQ0RCxJQUFWLENBQWU7QUFDYis0RCxzQkFBYUEsV0FEQTtBQUViWixrQkFBU21CLGtCQUFrQm5CLE9BQWxCLENBRkk7QUFHYngyQixrQkFBU3BCLFFBQVEsSUFISjtBQUliZzVCLHdCQUFlaDVCLFNBQVN2eEMsU0FBVCxHQUFxQnV4QyxLQUFLbHhDLE1BQTFCLEdBQW1DLElBSnJDO0FBS2JmLGlCQUFRbXFFLFFBQVFucUUsTUFMSDtBQU1icW9FLG1CQUFVOEIsUUFBUTlCLFFBTkw7QUFPYmxpRSxjQUFLZ2tFLFFBQVFoa0UsR0FQQTtBQVFiaWtFLG9CQUFXQSxTQVJFO0FBU2JXLGtCQUFTQSxPQVRJO0FBVWJwK0IsbUJBQVVvK0IsVUFBVVg7QUFWUCxRQUFmOztBQWFBLFdBQUksRUFBRXg0RCxlQUFlb3hDLE9BQU9zWixrQkFBeEIsQ0FBSixFQUFpRDtBQUMvQzFxRCxlQUFNLElBQUlveEMsT0FBT3VnQixPQUFYLENBQW1CM3hELE9BQU9BLElBQUkwNkMsT0FBOUIsRUFBdUMxNkMsR0FBdkMsQ0FBTjtBQUNEOztBQUVENjNELGdCQUFTLENBQVQ7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTczRCxzQkFBZW94QyxPQUFPdWdCLE9BQXRCOztBQUVBO0FBQ0EzeEQsc0JBQWVveEMsT0FBT2tnQixjQUh0Qjs7QUFLQTtBQUNBdUcsZ0JBQVM5TCxPQUFPc0ssS0FBUCxDQUFhc0IsWUFBWW5RLFFBQXpCLEVBQW1DcjRELE1BQTVDLEtBQ0Myb0UsaUJBQWlCLENBQUNDLFdBRG5CLENBVEYsRUFVbUM7QUFDakM7QUFDQS8zRCxhQUFJbzRELFNBQUosR0FBZ0JBLFNBQWhCO0FBQ0EsZ0JBQU9yTSxPQUFPTCxRQUFQLENBQWdCaDJELE1BQWhCLENBQXVCc0ssR0FBdkIsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsV0FBSUEsZUFBZW94QyxPQUFPbWdCLGNBQTFCLEVBQTBDO0FBQ3hDLGdCQUFPbUksK0JBQVA7QUFDRDs7QUFFRCxjQUFPRixjQUFQO0FBQ0Q7O0FBRUQsY0FBU0EsWUFBVCxHQUF3QjtBQUN0QjVCLG9CQUFhLGtCQUFiO0FBQ0E3TCxjQUFPNE4sbUJBQVAsQ0FBMkJoQyxZQUFZblEsUUFBdkM7QUFDQSxjQUFPNlEsVUFBVUMsU0FBVixFQUFxQkMsT0FBckIsQ0FBUDtBQUNEOztBQUVELGNBQVNtQiw2QkFBVCxHQUF5QztBQUN2QzlCLG9CQUFhLHNDQUFiO0FBQ0E3TCxjQUFPNE4sbUJBQVAsQ0FBMkJoQyxZQUFZblEsUUFBdkM7QUFDQXVFLGNBQU82TiwwQkFBUDtBQUNBckIsZUFBUTlCLFFBQVIsR0FBbUIxSyxPQUFPNE0sc0JBQVAsQ0FBOEJoQixZQUFZblEsUUFBMUMsQ0FBbkI7QUFDQSxjQUFPNlEsVUFBVUMsU0FBVixFQUFxQkMsT0FBckIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsT0FBSTVpRSxVQUFVMGlFLFVBQ1p0TSxPQUFPaU0sUUFESyxFQUNLO0FBQ2Z6akUsVUFBS29qRSxZQUFZcGpFLEdBREY7QUFFZm5HLGFBQVF1cEUsWUFBWXZwRSxNQUZMO0FBR2ZpeUMsV0FBTUEsSUFIUztBQUlmcTRCLGVBQVVmLFlBQVl0M0IsSUFKUDtBQUtmbzJCLGVBQVUxSyxPQUFPNE0sc0JBQVAsQ0FBOEJoQixZQUFZblEsUUFBMUM7QUFMSyxJQURMLENBQWQ7O0FBVUE7QUFDQTtBQUNBLE9BQUksT0FBT21RLFlBQVk1NUMsUUFBbkIsS0FBZ0MsVUFBcEMsRUFBZ0Q7QUFDOUNwb0IsYUFBUWpCLElBQVIsQ0FBYSxTQUFTbWxFLElBQVQsQ0FBY3A0QixPQUFkLEVBQXVCO0FBQ2xDbXBCLG1CQUFZLFlBQVc7QUFDckIrTSxxQkFBWTU1QyxRQUFaLENBQXFCLElBQXJCLEVBQTJCMGpCLE9BQTNCO0FBQ0QsUUFGRCxFQUVHc3FCLE9BQU9hLFdBQVAsSUFBc0J0cUQsVUFGekI7QUFHRCxNQUpELEVBSUcsU0FBU3czRCxNQUFULENBQWdCOTVELEdBQWhCLEVBQXFCO0FBQ3RCNHFELG1CQUFZLFlBQVc7QUFDckIrTSxxQkFBWTU1QyxRQUFaLENBQXFCL2QsR0FBckI7QUFDRCxRQUZELEVBRUcrckQsT0FBT2EsV0FBUCxJQUFzQnRxRCxVQUZ6QjtBQUdELE1BUkQ7QUFTRCxJQVZELE1BVU87QUFDTCxZQUFPM00sT0FBUDtBQUNEO0FBQ0YsRUFuUkQ7O0FBcVJBOzs7Ozs7QUFNQXd4RCxtQkFBa0I1NEQsU0FBbEIsQ0FBNEIyNUQsZ0JBQTVCLEdBQStDLFVBQVN2akQsSUFBVCxFQUFlaS9DLE1BQWYsRUFBdUI7QUFDcEUsT0FBSWovQyxTQUFTN1YsU0FBVCxJQUFzQjZWLFNBQVMsSUFBbkMsRUFBeUM7QUFDdkMsWUFBT2kvQyxNQUFQO0FBQ0Q7QUFDRCxRQUFLLElBQUk3cUQsR0FBVCxJQUFnQjRMLElBQWhCLEVBQXNCO0FBQ3BCLFNBQUk1TCxRQUFRLElBQVIsSUFBZ0I0TCxLQUFLNUwsR0FBTCxNQUFjakssU0FBOUIsSUFBMkM2VixLQUFLOUwsY0FBTCxDQUFvQkUsR0FBcEIsQ0FBL0MsRUFBeUU7QUFDdkU2cUQsaUJBQVVBLFdBQVcsRUFBWCxHQUFnQixFQUFoQixHQUFxQixHQUEvQjtBQUNBQSxpQkFBVTdxRCxNQUFNLEdBQU4sR0FBWXZJLG1CQUFtQnNGLE9BQU92SCxTQUFQLENBQWlCeUksUUFBakIsQ0FBMEJ4SSxJQUExQixDQUErQm1XLEtBQUs1TCxHQUFMLENBQS9CLE1BQThDLGdCQUE5QyxHQUFpRW8vRCxrQkFBa0J4ekQsS0FBSzVMLEdBQUwsQ0FBbEIsQ0FBakUsR0FBZ0c0TCxLQUFLNUwsR0FBTCxDQUFuSCxDQUF0QjtBQUNEO0FBQ0Y7QUFDRCxVQUFPNnFELE1BQVA7QUFDRCxFQVhEOztBQWFBdUQsbUJBQWtCNTRELFNBQWxCLENBQTRCMnBFLHNCQUE1QixHQUFxRCxVQUFTcEgsWUFBVCxFQUF1QmlKLFVBQXZCLEVBQW1DO0FBQ3RGLE9BQUkvakUsVUFBVSxtQkFBQXlyRCxDQUFRLEVBQVIsQ0FBZDs7QUFFQSxPQUFJdVksS0FBS2xKLGVBQ1AsS0FBS29HLEdBQUwsR0FBVyxHQUFYLEdBQWlCcEcsWUFEVixHQUVQLEtBQUtvRyxHQUZQOztBQUlBLE9BQUkrQyxpQkFBaUI7QUFDbkIsd0JBQW1CRCxFQURBO0FBRW5CLGlDQUE0QixLQUFLN0Q7QUFGZCxJQUFyQjs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQUk0RCxlQUFlLEtBQW5CLEVBQTBCO0FBQ3hCRSxvQkFBZSxtQkFBZixJQUFzQyxLQUFLaG5FLE1BQTNDO0FBQ0Q7O0FBRUQsT0FBSSxLQUFLaW5FLFNBQVQsRUFBb0I7QUFDbEJELG9CQUFlLHFCQUFmLElBQXdDLEtBQUtDLFNBQTdDO0FBQ0Q7O0FBRUQsT0FBSSxLQUFLQyxZQUFULEVBQXVCO0FBQ3JCRixvQkFBZSxzQkFBZixJQUF5QyxLQUFLRSxZQUE5QztBQUNEOztBQUVEbmtFLFdBQVEsS0FBS2doRSxZQUFiLEVBQTJCLFNBQVNvRCxtQkFBVCxDQUE2QnZqRSxLQUE3QixFQUFvQ2tDLEdBQXBDLEVBQXlDO0FBQ2xFa2hFLG9CQUFlbGhFLEdBQWYsSUFBc0JsQyxLQUF0QjtBQUNELElBRkQ7O0FBSUEsVUFBT29qRSxjQUFQO0FBQ0QsRUFqQ0Q7O0FBbUNBOzs7Ozs7Ozs7QUFTQTlTLG1CQUFrQjU0RCxTQUFsQixDQUE0QnUxRCxNQUE1QixHQUFxQyxVQUFTdVcsT0FBVCxFQUFrQnQ1RCxJQUFsQixFQUF3QmdkLFFBQXhCLEVBQWtDO0FBQ3JFLE9BQUl0aUIsVUFBVSxtQkFBQWdtRCxDQUFRLEVBQVIsQ0FBZDtBQUNBLE9BQUl2cEQsTUFBTSxtQkFBQXVwRCxDQUFRLEVBQVIsQ0FBVjs7QUFFQSxPQUFJcUgsUUFBUSxrREFBWjs7QUFFQSxPQUFJLENBQUNydEQsUUFBUTQrRCxPQUFSLENBQUwsRUFBdUI7QUFDckIsV0FBTSxJQUFJbm5CLEtBQUosQ0FBVTRWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUksT0FBTy9uRCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCZ2QsZ0JBQVdoZCxJQUFYO0FBQ0FBLFlBQU8sRUFBUDtBQUNELElBSEQsTUFHTyxJQUFJQSxTQUFTalMsU0FBYixFQUF3QjtBQUM3QmlTLFlBQU8sRUFBUDtBQUNEOztBQUVELE9BQUlnckQsU0FBUyxJQUFiOztBQUVBLE9BQUluRSxVQUFVO0FBQ1p1QyxlQUFVanlELElBQUltaUUsT0FBSixFQUFhLFNBQVN4TyxjQUFULENBQXdCbjRELEtBQXhCLEVBQStCO0FBQ3BELFdBQUlrd0QsU0FBUyxFQUFiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQUlsd0QsTUFBTUEsS0FBTixLQUFnQjVFLFNBQXBCLEVBQStCO0FBQzdCODBELG1CQUFVLFdBQVdwekQsbUJBQW1Ca0QsTUFBTUEsS0FBekIsQ0FBckI7QUFDRDs7QUFFRCxjQUFPO0FBQ0w0ekQsb0JBQVc1ekQsTUFBTTR6RCxTQURaO0FBRUwxRCxpQkFBUW1JLE9BQU83RCxnQkFBUCxDQUF3QngwRCxNQUFNa3dELE1BQTlCLEVBQXNDQSxNQUF0QztBQUZILFFBQVA7QUFJRCxNQWRTO0FBREUsSUFBZDs7QUFrQkEsT0FBSTBXLGNBQWNwaUUsSUFBSTB2RCxRQUFRdUMsUUFBWixFQUFzQixTQUFTb1Esa0JBQVQsQ0FBNEJubUUsT0FBNUIsRUFBcUNvbUUsU0FBckMsRUFBZ0Q7QUFDdEYsWUFBT0EsWUFBWSxHQUFaLEdBQ0xocUUsbUJBQ0UsZ0JBQWdCQSxtQkFBbUI0RCxRQUFRa3pELFNBQTNCLENBQWhCLEdBQXdELEdBQXhELEdBQ0FsekQsUUFBUXd2RCxNQUZWLENBREY7QUFLRCxJQU5pQixFQU1meG9ELElBTmUsQ0FNVixHQU5VLENBQWxCOztBQVFBLE9BQUk3RyxNQUFNLHNCQUFWOztBQUVBLE9BQUl3TSxLQUFLMDVELFFBQUwsS0FBa0IzckUsU0FBdEIsRUFBaUM7QUFDL0J5RixZQUFPLGVBQWV3TSxLQUFLMDVELFFBQTNCO0FBQ0Q7O0FBRUQsVUFBTyxLQUFLbFQsWUFBTCxDQUFrQjtBQUN2QnJ1RCxZQUFPLEtBQUtBLEtBRFc7QUFFdkI5SyxhQUFRLE1BRmU7QUFHdkJtRyxVQUFLQSxHQUhrQjtBQUl2QjhyQyxXQUFNdW5CLE9BSmlCO0FBS3ZCSixlQUFVLE1BTGE7QUFNdkIvb0MsZUFBVTtBQUNScndCLGVBQVEsS0FEQTtBQUVSbUcsWUFBSyxjQUZHO0FBR1I4ckMsYUFBTTtBQUNKdWpCLGlCQUFRMFc7QUFESjtBQUhFLE1BTmE7QUFhdkJ2OEMsZUFBVUE7QUFiYSxJQUFsQixDQUFQO0FBZUQsRUFsRUQ7O0FBb0VBOzs7O0FBSUFvcEMsbUJBQWtCNTRELFNBQWxCLENBQTRCbXNFLGVBQTVCLEdBQThDLFVBQVNDLElBQVQsRUFBZTtBQUMzRCxPQUFJN2tFLE9BQU92SCxTQUFQLENBQWlCeUksUUFBakIsQ0FBMEJ4SSxJQUExQixDQUErQm1zRSxJQUEvQixNQUF5QyxnQkFBN0MsRUFBK0Q7QUFDN0QsU0FBSUMsVUFBVSxFQUFkO0FBQ0EsVUFBSyxJQUFJMXJFLElBQUksQ0FBYixFQUFnQkEsSUFBSXlyRSxLQUFLeHJFLE1BQXpCLEVBQWlDLEVBQUVELENBQW5DLEVBQXNDO0FBQ3BDLFdBQUk0RyxPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpCLENBQTBCeEksSUFBMUIsQ0FBK0Jtc0UsS0FBS3pyRSxDQUFMLENBQS9CLE1BQTRDLGdCQUFoRCxFQUFrRTtBQUNoRSxhQUFJMnJFLFdBQVcsRUFBZjtBQUNBLGNBQUssSUFBSXZrRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlxa0QsS0FBS3pyRSxDQUFMLEVBQVFDLE1BQTVCLEVBQW9DLEVBQUVtbkIsQ0FBdEMsRUFBeUM7QUFDdkN1a0Qsb0JBQVMvNkQsSUFBVCxDQUFjNjZELEtBQUt6ckUsQ0FBTCxFQUFRb25CLENBQVIsQ0FBZDtBQUNEO0FBQ0Rza0QsaUJBQVE5NkQsSUFBUixDQUFhLE1BQU0rNkQsU0FBU3ovRCxJQUFULENBQWMsR0FBZCxDQUFOLEdBQTJCLEdBQXhDO0FBQ0QsUUFORCxNQU1PO0FBQ0x3L0QsaUJBQVE5NkQsSUFBUixDQUFhNjZELEtBQUt6ckUsQ0FBTCxDQUFiO0FBQ0Q7QUFDRjtBQUNEeXJFLFlBQU9DLFFBQVF4L0QsSUFBUixDQUFhLEdBQWIsQ0FBUDtBQUNEOztBQUVELFFBQUsrK0QsWUFBTCxHQUFvQlEsSUFBcEI7QUFDRCxFQWxCRDs7QUFvQkE7Ozs7QUFJQXhULG1CQUFrQjU0RCxTQUFsQixDQUE0QnVzRSxZQUE1QixHQUEyQyxVQUFTWixTQUFULEVBQW9CO0FBQzdELFFBQUtBLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0QsRUFGRDs7QUFJQTs7OztBQUlBL1MsbUJBQWtCNTRELFNBQWxCLENBQTRCczFELFVBQTVCLEdBQXlDLFlBQVc7QUFDbEQsUUFBSzNxRCxLQUFMLEdBQWEsRUFBYjtBQUNELEVBRkQ7O0FBSUE7Ozs7O0FBS0FpdUQsbUJBQWtCNTRELFNBQWxCLENBQTRCd3NFLGlCQUE1QixHQUFnRCxVQUFTQyxZQUFULEVBQXVCO0FBQ3JFLE9BQUlBLFlBQUosRUFBa0I7QUFDaEIsVUFBS3hFLFNBQUwsQ0FBZUUsT0FBZixHQUF5QixLQUFLRixTQUFMLENBQWVGLElBQWYsR0FBc0IsS0FBS0UsU0FBTCxDQUFlRCxLQUFmLEdBQXVCeUUsWUFBdEU7QUFDRDtBQUNGLEVBSkQ7O0FBTUE7Ozs7QUFJQTdULG1CQUFrQjU0RCxTQUFsQixDQUE0QjBzRSxXQUE1QixHQUEwQyxVQUFTeEUsUUFBVCxFQUFtQjtBQUMzRCxRQUFLRCxTQUFMLEdBQWlCQyxRQUFqQjtBQUNELEVBRkQ7O0FBSUE7Ozs7QUFJQXRQLG1CQUFrQjU0RCxTQUFsQixDQUE0QjJzRSxXQUE1QixHQUEwQyxZQUFXO0FBQ25ELFVBQU8sS0FBSzFFLFNBQVo7QUFDRCxFQUZEOztBQUlBclAsbUJBQWtCNTRELFNBQWxCLENBQTRCNHNFLGFBQTVCLEdBQTRDLFlBQVc7QUFDckQsT0FBSTFtRSxPQUFPdWhFLE1BQU1oMUQsR0FBTixDQUFVLEtBQUttMUQsYUFBZixDQUFYO0FBQ0EsT0FBSTFoRSxTQUFTLElBQWIsRUFBbUIsS0FBSzJtRSxlQUFMLENBQXFCM21FLElBQXJCO0FBQ25CLFVBQU9BLElBQVA7QUFDRCxFQUpEOztBQU1BMHlELG1CQUFrQjU0RCxTQUFsQixDQUE0QjhzRSxhQUE1QixHQUE0QyxVQUFTNW1FLElBQVQsRUFBZTtBQUN6REEsUUFBSzZtRSxVQUFMLEdBQW1CLElBQUlsbEUsSUFBSixFQUFELENBQWFtbEUsT0FBYixFQUFsQjtBQUNBLFFBQUtILGVBQUwsQ0FBcUIzbUUsSUFBckI7QUFDQSxVQUFPdWhFLE1BQU03eUQsR0FBTixDQUFVLEtBQUtnekQsYUFBZixFQUE4QjFoRSxJQUE5QixDQUFQO0FBQ0QsRUFKRDs7QUFNQTB5RCxtQkFBa0I1NEQsU0FBbEIsQ0FBNEJvb0UsZUFBNUIsR0FBOEMsWUFBVztBQUN2RCxPQUFJbGlFLE9BQU8sS0FBSzBtRSxhQUFMLEVBQVg7QUFDQSxPQUFJaGxFLE1BQU8sSUFBSUMsSUFBSixFQUFELENBQWFtbEUsT0FBYixFQUFWO0FBQ0EsT0FBSTltRSxTQUFTLElBQVQsSUFBaUIwQixNQUFNMUIsS0FBSzZtRSxVQUFYLEdBQXdCcEYsb0JBQTdDLEVBQW1FO0FBQ2pFLFlBQU8sS0FBS3NGLHNCQUFMLENBQTRCL21FLElBQTVCLENBQVA7QUFDRDs7QUFFRCxVQUFPQSxJQUFQO0FBQ0QsRUFSRDs7QUFVQTB5RCxtQkFBa0I1NEQsU0FBbEIsQ0FBNEJpdEUsc0JBQTVCLEdBQXFELFVBQVMvbUUsSUFBVCxFQUFlO0FBQ2xFLE9BQUlxbUIsVUFBVXJtQixRQUFRLEVBQXRCO0FBQ0FxbUIsV0FBUTJnRCxXQUFSLEdBQXNCLEVBQUNuRixNQUFNLENBQVAsRUFBVUMsT0FBTyxDQUFqQixFQUF0QjtBQUNBejdDLFdBQVE0Z0QsaUJBQVIsR0FBNEIsQ0FBNUI7QUFDQTVnRCxXQUFRNmdELGFBQVIsR0FBd0I3Z0QsUUFBUTZnRCxhQUFSLElBQXlCQyxRQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVIsQ0FBakQ7QUFDQSxVQUFPLEtBQUtQLGFBQUwsQ0FBbUJ2Z0QsT0FBbkIsQ0FBUDtBQUNELEVBTkQ7O0FBUUFxc0MsbUJBQWtCNTRELFNBQWxCLENBQTRCNnNFLGVBQTVCLEdBQThDLFVBQVMzbUUsSUFBVCxFQUFlO0FBQzNELFFBQUtvbkUsWUFBTCxHQUFvQnBuRSxLQUFLZ25FLFdBQXpCO0FBQ0EsUUFBS0ssa0JBQUwsR0FBMEJybkUsS0FBS2luRSxpQkFBL0I7QUFDQSxRQUFLN0UsY0FBTCxHQUFzQnBpRSxLQUFLa25FLGFBQTNCO0FBQ0QsRUFKRDs7QUFNQXhVLG1CQUFrQjU0RCxTQUFsQixDQUE0Qnd0RSx1QkFBNUIsR0FBc0QsVUFBU2poRCxPQUFULEVBQWtCO0FBQ3RFLE9BQUltM0MsVUFBVSxtQkFBQXhRLENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXVhLGNBQWMsS0FBS2IsYUFBTCxFQUFsQjtBQUNBbEosV0FBUW4zQyxPQUFSLEVBQWlCLFVBQVNqa0IsS0FBVCxFQUFnQmtDLEdBQWhCLEVBQXFCO0FBQ3BDaWpFLGlCQUFZampFLEdBQVosSUFBbUJsQyxLQUFuQjtBQUNELElBRkQ7O0FBSUEsVUFBTyxLQUFLd2tFLGFBQUwsQ0FBbUJXLFdBQW5CLENBQVA7QUFDRCxFQVJEOztBQVVBN1UsbUJBQWtCNTRELFNBQWxCLENBQTRCdXFFLGNBQTVCLEdBQTZDLFVBQVN0UixRQUFULEVBQW1CO0FBQzlELFVBQU8sS0FBSzZPLEtBQUwsQ0FBVzdPLFFBQVgsRUFBcUIsS0FBS3lVLG1CQUFMLENBQXlCelUsUUFBekIsQ0FBckIsQ0FBUDtBQUNELEVBRkQ7O0FBSUFMLG1CQUFrQjU0RCxTQUFsQixDQUE0QjJ0RSxxQkFBNUIsR0FBb0QsWUFBVztBQUM3RCxVQUFPLEtBQUtKLGtCQUFaO0FBQ0QsRUFGRDs7QUFJQTNVLG1CQUFrQjU0RCxTQUFsQixDQUE0QjB0RSxtQkFBNUIsR0FBa0QsVUFBU3pVLFFBQVQsRUFBbUI7QUFDbkUsVUFBTyxLQUFLcVUsWUFBTCxDQUFrQnJVLFFBQWxCLENBQVA7QUFDRCxFQUZEOztBQUlBTCxtQkFBa0I1NEQsU0FBbEIsQ0FBNEJxcUUsbUJBQTVCLEdBQWtELFVBQVN1RCxTQUFULEVBQW9CM1UsUUFBcEIsRUFBOEI7QUFDOUUsT0FBSXptQixRQUFRLG1CQUFBMGdCLENBQVEsRUFBUixDQUFaO0FBQ0EsT0FBSTJhLGlCQUFpQnI3QixNQUFNLEtBQUs4NkIsWUFBWCxDQUFyQjtBQUNBTyxrQkFBZTVVLFFBQWYsSUFBMkIyVSxTQUEzQjtBQUNBLFFBQUtKLHVCQUFMLENBQTZCLEVBQUNOLGFBQWFXLGNBQWQsRUFBN0I7QUFDQSxVQUFPRCxTQUFQO0FBQ0QsRUFORDs7QUFRQWhWLG1CQUFrQjU0RCxTQUFsQixDQUE0Qm9yRSxtQkFBNUIsR0FBa0QsVUFBU25TLFFBQVQsRUFBbUI7QUFDbkUsVUFBTyxLQUFLb1IsbUJBQUwsQ0FDTCxDQUFDLEtBQUtxRCxtQkFBTCxDQUF5QnpVLFFBQXpCLElBQXFDLENBQXRDLElBQTJDLEtBQUs2TyxLQUFMLENBQVc3TyxRQUFYLEVBQXFCcjRELE1BRDNELEVBQ21FcTRELFFBRG5FLENBQVA7QUFHRCxFQUpEOztBQU1BTCxtQkFBa0I1NEQsU0FBbEIsQ0FBNEJxckUsMEJBQTVCLEdBQXlELFlBQVc7QUFDbEUsT0FBSThCLG9CQUFvQm5rRSxLQUFLdVAsR0FBTCxDQUFTLEtBQUtnMUQsa0JBQUwsR0FBMEIsQ0FBbkMsRUFBc0MsQ0FBdEMsQ0FBeEI7QUFDQSxVQUFPLEtBQUtDLHVCQUFMLENBQTZCLEVBQUNMLG1CQUFtQkEsaUJBQXBCLEVBQTdCLENBQVA7QUFDRCxFQUhEOztBQUtBdlUsbUJBQWtCNTRELFNBQWxCLENBQTRCb3FFLHNCQUE1QixHQUFxRCxVQUFTblIsUUFBVCxFQUFtQjtBQUN0RSxVQUFPO0FBQ0xrUCxjQUFTLEtBQUtGLFNBQUwsQ0FBZUUsT0FBZixHQUF5QixLQUFLb0Ysa0JBRGxDO0FBRUxPLGVBQVUsS0FBSzdGLFNBQUwsQ0FBZWhQLFFBQWYsSUFBMkIsS0FBS3NVO0FBRnJDLElBQVA7QUFJRCxFQUxEOztBQU9BLFVBQVMvRSxXQUFULENBQXFCdlQsUUFBckIsRUFBK0I7QUFDN0IsVUFBTyxTQUFTOFksT0FBVCxDQUFpQkMsSUFBakIsRUFBdUI7QUFDNUIsWUFBTy9ZLFdBQVcsSUFBWCxHQUFrQitZLEtBQUtqa0UsV0FBTCxFQUF6QjtBQUNELElBRkQ7QUFHRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM2L0QsaUJBQVQsQ0FBMkJqcUUsR0FBM0IsRUFBZ0M7QUFDOUI7O0FBRUEsT0FBSW9NLE1BQU0vTCxTQUFOLENBQWdCaXVFLE1BQWhCLEtBQTJCMXRFLFNBQS9CLEVBQTBDO0FBQ3hDLFlBQU80SSxLQUFLQyxTQUFMLENBQWV6SixHQUFmLENBQVA7QUFDRDs7QUFFRCxPQUFJc3VFLFNBQVNsaUUsTUFBTS9MLFNBQU4sQ0FBZ0JpdUUsTUFBN0I7QUFDQSxVQUFPbGlFLE1BQU0vTCxTQUFOLENBQWdCaXVFLE1BQXZCO0FBQ0EsT0FBSUMsTUFBTS9rRSxLQUFLQyxTQUFMLENBQWV6SixHQUFmLENBQVY7QUFDQW9NLFNBQU0vTCxTQUFOLENBQWdCaXVFLE1BQWhCLEdBQXlCQSxNQUF6Qjs7QUFFQSxVQUFPQyxHQUFQO0FBQ0Q7O0FBRUQsVUFBU2IsT0FBVCxDQUFpQjduQixLQUFqQixFQUF3QjtBQUN0QixPQUFJMm9CLGVBQWUzb0IsTUFBTTVrRCxNQUF6QjtBQUNBLE9BQUl3dEUsY0FBSjtBQUNBLE9BQUlDLFdBQUo7O0FBRUE7QUFDQSxVQUFPRixpQkFBaUIsQ0FBeEIsRUFBMkI7QUFDekI7QUFDQUUsbUJBQWNybEUsS0FBS0MsS0FBTCxDQUFXRCxLQUFLa3JELE1BQUwsS0FBZ0JpYSxZQUEzQixDQUFkO0FBQ0FBLHFCQUFnQixDQUFoQjs7QUFFQTtBQUNBQyxzQkFBaUI1b0IsTUFBTTJvQixZQUFOLENBQWpCO0FBQ0Ezb0IsV0FBTTJvQixZQUFOLElBQXNCM29CLE1BQU02b0IsV0FBTixDQUF0QjtBQUNBN29CLFdBQU02b0IsV0FBTixJQUFxQkQsY0FBckI7QUFDRDs7QUFFRCxVQUFPNW9CLEtBQVA7QUFDRDs7QUFFRCxVQUFTcWxCLGlCQUFULENBQTJCbkIsT0FBM0IsRUFBb0M7QUFDbEMsT0FBSTRFLGFBQWEsRUFBakI7O0FBRUEsUUFBSyxJQUFJQyxVQUFULElBQXVCN0UsT0FBdkIsRUFBZ0M7QUFDOUIsU0FBSW5pRSxPQUFPdkgsU0FBUCxDQUFpQnNLLGNBQWpCLENBQWdDckssSUFBaEMsQ0FBcUN5cEUsT0FBckMsRUFBOEM2RSxVQUE5QyxDQUFKLEVBQStEO0FBQzdELFdBQUlqbUUsS0FBSjs7QUFFQSxXQUFJaW1FLGVBQWUsbUJBQWYsSUFBc0NBLGVBQWUsMEJBQXpELEVBQXFGO0FBQ25Gam1FLGlCQUFRLGtDQUFSO0FBQ0QsUUFGRCxNQUVPO0FBQ0xBLGlCQUFRb2hFLFFBQVE2RSxVQUFSLENBQVI7QUFDRDs7QUFFREQsa0JBQVdDLFVBQVgsSUFBeUJqbUUsS0FBekI7QUFDRDtBQUNGOztBQUVELFVBQU9nbUUsVUFBUDtBQUNELEU7Ozs7Ozs7OztBQ3J5QkQsS0FBSXh0RSxRQUFRLG1CQUFBb3lELENBQVEsRUFBUixFQUFpQixxQ0FBakIsQ0FBWjtBQUNBLEtBQUlzYix3QkFBd0IseUJBQTVCOztBQUVBLEtBQUkvRyxLQUFKO0FBQ0EsS0FBSWdILGNBQWM7QUFDaEI1dUIsVUFBTyxFQURTO0FBRWhCanJDLFFBQUssYUFBU3BLLEdBQVQsRUFBY3RFLElBQWQsRUFBb0I7QUFDdkIsVUFBSzI1QyxLQUFMLENBQVdyMUMsR0FBWCxJQUFrQnRFLElBQWxCO0FBQ0EsWUFBTyxLQUFLMjVDLEtBQUwsQ0FBV3IxQyxHQUFYLENBQVA7QUFDRCxJQUxlO0FBTWhCaUksUUFBSyxhQUFTakksR0FBVCxFQUFjO0FBQ2pCLFlBQU8sS0FBS3ExQyxLQUFMLENBQVdyMUMsR0FBWCxLQUFtQixJQUExQjtBQUNEO0FBUmUsRUFBbEI7O0FBV0EsS0FBSWtrRSxvQkFBb0I7QUFDdEI5NUQsUUFBSyxhQUFTcEssR0FBVCxFQUFjdEUsSUFBZCxFQUFvQjtBQUN2QnVvRSxpQkFBWTc1RCxHQUFaLENBQWdCcEssR0FBaEIsRUFBcUJ0RSxJQUFyQixFQUR1QixDQUNLOztBQUU1QixTQUFJO0FBQ0YsV0FBSTZ5QixZQUFZNXZCLEtBQUtrd0MsS0FBTCxDQUFXeG1DLE9BQU9oUixZQUFQLENBQW9CMnNFLHFCQUFwQixDQUFYLENBQWhCO0FBQ0F6MUMsaUJBQVV2dUIsR0FBVixJQUFpQnRFLElBQWpCO0FBQ0EyTSxjQUFPaFIsWUFBUCxDQUFvQjJzRSxxQkFBcEIsSUFBNkNybEUsS0FBS0MsU0FBTCxDQUFlMnZCLFNBQWYsQ0FBN0M7QUFDQSxjQUFPQSxVQUFVdnVCLEdBQVYsQ0FBUDtBQUNELE1BTEQsQ0FLRSxPQUFPdEssQ0FBUCxFQUFVO0FBQ1YsY0FBT3l1RSxvQkFBb0Jua0UsR0FBcEIsRUFBeUJ0SyxDQUF6QixDQUFQO0FBQ0Q7QUFDRixJQVpxQjtBQWF0QnVTLFFBQUssYUFBU2pJLEdBQVQsRUFBYztBQUNqQixTQUFJO0FBQ0YsY0FBT3JCLEtBQUtrd0MsS0FBTCxDQUFXeG1DLE9BQU9oUixZQUFQLENBQW9CMnNFLHFCQUFwQixDQUFYLEVBQXVEaGtFLEdBQXZELEtBQStELElBQXRFO0FBQ0QsTUFGRCxDQUVFLE9BQU90SyxDQUFQLEVBQVU7QUFDVixjQUFPeXVFLG9CQUFvQm5rRSxHQUFwQixFQUF5QnRLLENBQXpCLENBQVA7QUFDRDtBQUNGO0FBbkJxQixFQUF4Qjs7QUFzQkEsVUFBU3l1RSxtQkFBVCxDQUE2Qm5rRSxHQUE3QixFQUFrQ3RLLENBQWxDLEVBQXFDO0FBQ25DWSxTQUFNLDBCQUFOLEVBQWtDWixDQUFsQztBQUNBMHVFO0FBQ0FuSCxXQUFRZ0gsV0FBUjtBQUNBLFVBQU9oSCxNQUFNaDFELEdBQU4sQ0FBVWpJLEdBQVYsQ0FBUDtBQUNEOztBQUVEaTlELFNBQVFvSCx5QkFBeUJILGlCQUF6QixHQUE2Q0QsV0FBckQ7O0FBRUFydkUsUUFBT0MsT0FBUCxHQUFpQjtBQUNmb1QsUUFBS3E4RCxRQURVO0FBRWZsNkQsUUFBS2s2RCxRQUZVO0FBR2ZELHlCQUFzQkE7QUFIUCxFQUFqQjs7QUFNQSxVQUFTQyxRQUFULENBQWtCdGtFLEdBQWxCLEVBQXVCdEUsSUFBdkIsRUFBNkI7QUFDM0IsT0FBSTlGLFVBQVVRLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsWUFBTzZtRSxNQUFNaDFELEdBQU4sQ0FBVWpJLEdBQVYsQ0FBUDtBQUNEOztBQUVELFVBQU9pOUQsTUFBTTd5RCxHQUFOLENBQVVwSyxHQUFWLEVBQWV0RSxJQUFmLENBQVA7QUFDRDs7QUFFRCxVQUFTMm9FLG9CQUFULEdBQWdDO0FBQzlCLE9BQUk7QUFDRixTQUFJLGtCQUFrQmg4RCxNQUFsQixJQUNGQSxPQUFPaFIsWUFBUCxLQUF3QixJQUQxQixFQUNnQztBQUM5QixXQUFJLENBQUNnUixPQUFPaFIsWUFBUCxDQUFvQjJzRSxxQkFBcEIsQ0FBTCxFQUFpRDtBQUMvQztBQUNBMzdELGdCQUFPaFIsWUFBUCxDQUFvQmt0RSxPQUFwQixDQUE0QlAscUJBQTVCLEVBQW1EcmxFLEtBQUtDLFNBQUwsQ0FBZSxFQUFmLENBQW5EO0FBQ0Q7QUFDRCxjQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFPLEtBQVA7QUFDRCxJQVhELENBV0UsT0FBTzZCLENBQVAsRUFBVTtBQUNWLFlBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLFVBQVMyakUsT0FBVCxHQUFtQjtBQUNqQixPQUFJO0FBQ0YvN0QsWUFBT2hSLFlBQVAsQ0FBb0JtdEUsVUFBcEIsQ0FBK0JSLHFCQUEvQjtBQUNELElBRkQsQ0FFRSxPQUFPdmpFLENBQVAsRUFBVTtBQUNWO0FBQ0Q7QUFDRixFOzs7Ozs7Ozs7OztBQ3JGRDs7Ozs7O0FBTUE1TCxXQUFVRCxPQUFPQyxPQUFQLEdBQWlCLG1CQUFBNnpELENBQVEsRUFBUixDQUEzQjtBQUNBN3pELFNBQVFDLEdBQVIsR0FBY0EsR0FBZDtBQUNBRCxTQUFRNHZFLFVBQVIsR0FBcUJBLFVBQXJCO0FBQ0E1dkUsU0FBUTZ2RSxJQUFSLEdBQWVBLElBQWY7QUFDQTd2RSxTQUFROHZFLElBQVIsR0FBZUEsSUFBZjtBQUNBOXZFLFNBQVErdkUsU0FBUixHQUFvQkEsU0FBcEI7QUFDQS92RSxTQUFRZ3dFLE9BQVIsR0FBa0IsZUFBZSxPQUFPeHFFLE1BQXRCLElBQ0EsZUFBZSxPQUFPQSxPQUFPd3FFLE9BRDdCLEdBRUV4cUUsT0FBT3dxRSxPQUFQLENBQWVwckUsS0FGakIsR0FHRXFyRSxjQUhwQjs7QUFLQTs7OztBQUlBandFLFNBQVFrd0UsTUFBUixHQUFpQixDQUNmLGVBRGUsRUFFZixhQUZlLEVBR2YsV0FIZSxFQUlmLFlBSmUsRUFLZixZQUxlLEVBTWYsU0FOZSxDQUFqQjs7QUFTQTs7Ozs7Ozs7QUFRQSxVQUFTSCxTQUFULEdBQXFCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLE9BQUksT0FBT3h0RSxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPcU0sT0FBeEMsSUFBbURyTSxPQUFPcU0sT0FBUCxDQUFlNEwsSUFBZixLQUF3QixVQUEvRSxFQUEyRjtBQUN6RixZQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsVUFBUSxPQUFPOVgsUUFBUCxLQUFvQixXQUFwQixJQUFtQ0EsU0FBU3FpRCxlQUE1QyxJQUErRHJpRCxTQUFTcWlELGVBQVQsQ0FBeUJ0ZCxLQUF4RixJQUFpRy9rQyxTQUFTcWlELGVBQVQsQ0FBeUJ0ZCxLQUF6QixDQUErQjBvQyxnQkFBakk7QUFDTDtBQUNDLFVBQU81dEUsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT3RCLE9BQXhDLEtBQW9Ec0IsT0FBT3RCLE9BQVAsQ0FBZW12RSxPQUFmLElBQTJCN3RFLE9BQU90QixPQUFQLENBQWU2b0QsU0FBZixJQUE0QnZuRCxPQUFPdEIsT0FBUCxDQUFlb3ZFLEtBQTFILENBRkk7QUFHTDtBQUNBO0FBQ0MsVUFBTzc5RCxTQUFQLEtBQXFCLFdBQXJCLElBQW9DQSxVQUFVQyxTQUE5QyxJQUEyREQsVUFBVUMsU0FBVixDQUFvQi9ILFdBQXBCLEdBQWtDaUgsS0FBbEMsQ0FBd0MsZ0JBQXhDLENBQTNELElBQXdIaXVDLFNBQVMzcEIsT0FBT3E2QyxFQUFoQixFQUFvQixFQUFwQixLQUEyQixFQUwvSTtBQU1MO0FBQ0MsVUFBTzk5RCxTQUFQLEtBQXFCLFdBQXJCLElBQW9DQSxVQUFVQyxTQUE5QyxJQUEyREQsVUFBVUMsU0FBVixDQUFvQi9ILFdBQXBCLEdBQWtDaUgsS0FBbEMsQ0FBd0Msb0JBQXhDLENBUDlEO0FBUUQ7O0FBRUQ7Ozs7QUFJQTNSLFNBQVF1d0UsVUFBUixDQUFtQjduRCxDQUFuQixHQUF1QixVQUFTOWYsQ0FBVCxFQUFZO0FBQ2pDLE9BQUk7QUFDRixZQUFPa0IsS0FBS0MsU0FBTCxDQUFlbkIsQ0FBZixDQUFQO0FBQ0QsSUFGRCxDQUVFLE9BQU93SixHQUFQLEVBQVk7QUFDWixZQUFPLGlDQUFpQ0EsSUFBSTA2QyxPQUE1QztBQUNEO0FBQ0YsRUFORDs7QUFTQTs7Ozs7O0FBTUEsVUFBUzhpQixVQUFULENBQW9CNzRELElBQXBCLEVBQTBCO0FBQ3hCLE9BQUlnNUQsWUFBWSxLQUFLQSxTQUFyQjs7QUFFQWg1RCxRQUFLLENBQUwsSUFBVSxDQUFDZzVELFlBQVksSUFBWixHQUFtQixFQUFwQixJQUNOLEtBQUtyMkMsU0FEQyxJQUVMcTJDLFlBQVksS0FBWixHQUFvQixHQUZmLElBR05oNUQsS0FBSyxDQUFMLENBSE0sSUFJTGc1RCxZQUFZLEtBQVosR0FBb0IsR0FKZixJQUtOLEdBTE0sR0FLQS92RSxRQUFRd3dFLFFBQVIsQ0FBaUIsS0FBS0MsSUFBdEIsQ0FMVjs7QUFPQSxPQUFJLENBQUNWLFNBQUwsRUFBZ0I7O0FBRWhCLE9BQUlsa0UsSUFBSSxZQUFZLEtBQUs2a0UsS0FBekI7QUFDQTM1RCxRQUFLL0wsTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCYSxDQUFsQixFQUFxQixnQkFBckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBSXZHLFFBQVEsQ0FBWjtBQUNBLE9BQUlxckUsUUFBUSxDQUFaO0FBQ0E1NUQsUUFBSyxDQUFMLEVBQVFwTCxPQUFSLENBQWdCLGFBQWhCLEVBQStCLFVBQVNnRyxLQUFULEVBQWdCO0FBQzdDLFNBQUksU0FBU0EsS0FBYixFQUFvQjtBQUNwQnJNO0FBQ0EsU0FBSSxTQUFTcU0sS0FBYixFQUFvQjtBQUNsQjtBQUNBO0FBQ0FnL0QsZUFBUXJyRSxLQUFSO0FBQ0Q7QUFDRixJQVJEOztBQVVBeVIsUUFBSy9MLE1BQUwsQ0FBWTJsRSxLQUFaLEVBQW1CLENBQW5CLEVBQXNCOWtFLENBQXRCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxVQUFTNUwsR0FBVCxHQUFlO0FBQ2I7QUFDQTtBQUNBLFVBQU8scUJBQW9CZ0IsT0FBcEIseUNBQW9CQSxPQUFwQixNQUNGQSxRQUFRaEIsR0FETixJQUVGUyxTQUFTQyxTQUFULENBQW1CRyxLQUFuQixDQUF5QkYsSUFBekIsQ0FBOEJLLFFBQVFoQixHQUF0QyxFQUEyQ2dCLE9BQTNDLEVBQW9ERixTQUFwRCxDQUZMO0FBR0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxVQUFTOHVFLElBQVQsQ0FBY2UsVUFBZCxFQUEwQjtBQUN4QixPQUFJO0FBQ0YsU0FBSSxRQUFRQSxVQUFaLEVBQXdCO0FBQ3RCNXdFLGVBQVFnd0UsT0FBUixDQUFnQkwsVUFBaEIsQ0FBMkIsT0FBM0I7QUFDRCxNQUZELE1BRU87QUFDTDN2RSxlQUFRZ3dFLE9BQVIsQ0FBZ0J2dUUsS0FBaEIsR0FBd0JtdkUsVUFBeEI7QUFDRDtBQUNGLElBTkQsQ0FNRSxPQUFNL3ZFLENBQU4sRUFBUyxDQUFFO0FBQ2Q7O0FBRUQ7Ozs7Ozs7QUFPQSxVQUFTaXZFLElBQVQsR0FBZ0I7QUFDZCxPQUFJdlksQ0FBSjtBQUNBLE9BQUk7QUFDRkEsU0FBSXYzRCxRQUFRZ3dFLE9BQVIsQ0FBZ0J2dUUsS0FBcEI7QUFDRCxJQUZELENBRUUsT0FBTVosQ0FBTixFQUFTLENBQUU7O0FBRWI7QUFDQSxPQUFJLENBQUMwMkQsQ0FBRCxJQUFNLE9BQU8zb0QsT0FBUCxLQUFtQixXQUF6QixJQUF3QyxTQUFTQSxPQUFyRCxFQUE4RDtBQUM1RDJvRCxTQUFJM29ELFFBQVFDLEdBQVIsQ0FBWWdpRSxLQUFoQjtBQUNEOztBQUVELFVBQU90WixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQXYzRCxTQUFROHdFLE1BQVIsQ0FBZWhCLE1BQWY7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsVUFBU0csWUFBVCxHQUF3QjtBQUN0QixPQUFJO0FBQ0YsWUFBTzF0RSxPQUFPQyxZQUFkO0FBQ0QsSUFGRCxDQUVFLE9BQU8zQixDQUFQLEVBQVUsQ0FBRTtBQUNmLEU7Ozs7Ozs7OztBQ3ZMRDs7Ozs7OztBQU9BYixXQUFVRCxPQUFPQyxPQUFQLEdBQWlCK3dFLFlBQVl0dkUsS0FBWixHQUFvQnN2RSxZQUFZLFNBQVosSUFBeUJBLFdBQXhFO0FBQ0Evd0UsU0FBUTJyRCxNQUFSLEdBQWlCQSxNQUFqQjtBQUNBM3JELFNBQVFneEUsT0FBUixHQUFrQkEsT0FBbEI7QUFDQWh4RSxTQUFROHdFLE1BQVIsR0FBaUJBLE1BQWpCO0FBQ0E5d0UsU0FBUWl4RSxPQUFSLEdBQWtCQSxPQUFsQjtBQUNBanhFLFNBQVF3d0UsUUFBUixHQUFtQixtQkFBQTNjLENBQVEsRUFBUixDQUFuQjs7QUFFQTs7OztBQUlBN3pELFNBQVFreEUsS0FBUixHQUFnQixFQUFoQjtBQUNBbHhFLFNBQVFteEUsS0FBUixHQUFnQixFQUFoQjs7QUFFQTs7Ozs7O0FBTUFueEUsU0FBUXV3RSxVQUFSLEdBQXFCLEVBQXJCOztBQUVBOzs7O0FBSUEsS0FBSWEsUUFBSjs7QUFFQTs7Ozs7OztBQU9BLFVBQVNDLFdBQVQsQ0FBcUIzM0MsU0FBckIsRUFBZ0M7QUFDOUIsT0FBSTNYLE9BQU8sQ0FBWDtBQUFBLE9BQWN6Z0IsQ0FBZDs7QUFFQSxRQUFLQSxDQUFMLElBQVVvNEIsU0FBVixFQUFxQjtBQUNuQjNYLFlBQVMsQ0FBQ0EsUUFBUSxDQUFULElBQWNBLElBQWYsR0FBdUIyWCxVQUFVM3BCLFVBQVYsQ0FBcUJ6TyxDQUFyQixDQUEvQjtBQUNBeWdCLGFBQVEsQ0FBUixDQUZtQixDQUVSO0FBQ1o7O0FBRUQsVUFBTy9oQixRQUFRa3dFLE1BQVIsQ0FBZXZtRSxLQUFLMm5FLEdBQUwsQ0FBU3Z2RCxJQUFULElBQWlCL2hCLFFBQVFrd0UsTUFBUixDQUFlM3VFLE1BQS9DLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxVQUFTd3ZFLFdBQVQsQ0FBcUJyM0MsU0FBckIsRUFBZ0M7O0FBRTlCLFlBQVNqNEIsS0FBVCxHQUFpQjtBQUNmO0FBQ0EsU0FBSSxDQUFDQSxNQUFNd3ZFLE9BQVgsRUFBb0I7O0FBRXBCLFNBQUlqdkUsT0FBT1AsS0FBWDs7QUFFQTtBQUNBLFNBQUk4dkUsT0FBTyxDQUFDLElBQUkvb0UsSUFBSixFQUFaO0FBQ0EsU0FBSXFwRCxLQUFLMGYsUUFBUUgsWUFBWUcsSUFBcEIsQ0FBVDtBQUNBdnZFLFVBQUt5dUUsSUFBTCxHQUFZNWUsRUFBWjtBQUNBN3ZELFVBQUtrZ0MsSUFBTCxHQUFZa3ZDLFFBQVo7QUFDQXB2RSxVQUFLdXZFLElBQUwsR0FBWUEsSUFBWjtBQUNBSCxnQkFBV0csSUFBWDs7QUFFQTtBQUNBLFNBQUl4NkQsT0FBTyxJQUFJckssS0FBSixDQUFVM0wsVUFBVVEsTUFBcEIsQ0FBWDtBQUNBLFVBQUssSUFBSUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeVYsS0FBS3hWLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztBQUNwQ3lWLFlBQUt6VixDQUFMLElBQVVQLFVBQVVPLENBQVYsQ0FBVjtBQUNEOztBQUVEeVYsVUFBSyxDQUFMLElBQVUvVyxRQUFRMnJELE1BQVIsQ0FBZTUwQyxLQUFLLENBQUwsQ0FBZixDQUFWOztBQUVBLFNBQUksYUFBYSxPQUFPQSxLQUFLLENBQUwsQ0FBeEIsRUFBaUM7QUFDL0I7QUFDQUEsWUFBS2tlLE9BQUwsQ0FBYSxJQUFiO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFJM3ZCLFFBQVEsQ0FBWjtBQUNBeVIsVUFBSyxDQUFMLElBQVVBLEtBQUssQ0FBTCxFQUFRcEwsT0FBUixDQUFnQixlQUFoQixFQUFpQyxVQUFTZ0csS0FBVCxFQUFnQjYvRCxNQUFoQixFQUF3QjtBQUNqRTtBQUNBLFdBQUk3L0QsVUFBVSxJQUFkLEVBQW9CLE9BQU9BLEtBQVA7QUFDcEJyTTtBQUNBLFdBQUltc0UsWUFBWXp4RSxRQUFRdXdFLFVBQVIsQ0FBbUJpQixNQUFuQixDQUFoQjtBQUNBLFdBQUksZUFBZSxPQUFPQyxTQUExQixFQUFxQztBQUNuQyxhQUFJam9FLE1BQU11TixLQUFLelIsS0FBTCxDQUFWO0FBQ0FxTSxpQkFBUTgvRCxVQUFVN3dFLElBQVYsQ0FBZW9CLElBQWYsRUFBcUJ3SCxHQUFyQixDQUFSOztBQUVBO0FBQ0F1TixjQUFLL0wsTUFBTCxDQUFZMUYsS0FBWixFQUFtQixDQUFuQjtBQUNBQTtBQUNEO0FBQ0QsY0FBT3FNLEtBQVA7QUFDRCxNQWRTLENBQVY7O0FBZ0JBO0FBQ0EzUixhQUFRNHZFLFVBQVIsQ0FBbUJodkUsSUFBbkIsQ0FBd0JvQixJQUF4QixFQUE4QitVLElBQTlCOztBQUVBLFNBQUkyNkQsUUFBUWp3RSxNQUFNeEIsR0FBTixJQUFhRCxRQUFRQyxHQUFyQixJQUE0QmdCLFFBQVFoQixHQUFSLENBQVlRLElBQVosQ0FBaUJRLE9BQWpCLENBQXhDO0FBQ0F5d0UsV0FBTTV3RSxLQUFOLENBQVlrQixJQUFaLEVBQWtCK1UsSUFBbEI7QUFDRDs7QUFFRHRWLFNBQU1pNEIsU0FBTixHQUFrQkEsU0FBbEI7QUFDQWo0QixTQUFNd3ZFLE9BQU4sR0FBZ0JqeEUsUUFBUWl4RSxPQUFSLENBQWdCdjNDLFNBQWhCLENBQWhCO0FBQ0FqNEIsU0FBTXN1RSxTQUFOLEdBQWtCL3ZFLFFBQVErdkUsU0FBUixFQUFsQjtBQUNBdHVFLFNBQU1pdkUsS0FBTixHQUFjVyxZQUFZMzNDLFNBQVosQ0FBZDs7QUFFQTtBQUNBLE9BQUksZUFBZSxPQUFPMTVCLFFBQVFxdUIsSUFBbEMsRUFBd0M7QUFDdENydUIsYUFBUXF1QixJQUFSLENBQWE1c0IsS0FBYjtBQUNEOztBQUVELFVBQU9BLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxVQUFTcXZFLE1BQVQsQ0FBZ0JGLFVBQWhCLEVBQTRCO0FBQzFCNXdFLFdBQVE2dkUsSUFBUixDQUFhZSxVQUFiOztBQUVBNXdFLFdBQVFreEUsS0FBUixHQUFnQixFQUFoQjtBQUNBbHhFLFdBQVFteEUsS0FBUixHQUFnQixFQUFoQjs7QUFFQSxPQUFJMW1FLFFBQVEsQ0FBQyxPQUFPbW1FLFVBQVAsS0FBc0IsUUFBdEIsR0FBaUNBLFVBQWpDLEdBQThDLEVBQS9DLEVBQW1Ebm1FLEtBQW5ELENBQXlELFFBQXpELENBQVo7QUFDQSxPQUFJdU0sTUFBTXZNLE1BQU1sSixNQUFoQjs7QUFFQSxRQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSTBWLEdBQXBCLEVBQXlCMVYsR0FBekIsRUFBOEI7QUFDNUIsU0FBSSxDQUFDbUosTUFBTW5KLENBQU4sQ0FBTCxFQUFlLFNBRGEsQ0FDSDtBQUN6QnN2RSxrQkFBYW5tRSxNQUFNbkosQ0FBTixFQUFTcUssT0FBVCxDQUFpQixLQUFqQixFQUF3QixLQUF4QixDQUFiO0FBQ0EsU0FBSWlsRSxXQUFXLENBQVgsTUFBa0IsR0FBdEIsRUFBMkI7QUFDekI1d0UsZUFBUW14RSxLQUFSLENBQWNqL0QsSUFBZCxDQUFtQixJQUFJK2pCLE1BQUosQ0FBVyxNQUFNMjZDLFdBQVdlLE1BQVgsQ0FBa0IsQ0FBbEIsQ0FBTixHQUE2QixHQUF4QyxDQUFuQjtBQUNELE1BRkQsTUFFTztBQUNMM3hFLGVBQVFreEUsS0FBUixDQUFjaC9ELElBQWQsQ0FBbUIsSUFBSStqQixNQUFKLENBQVcsTUFBTTI2QyxVQUFOLEdBQW1CLEdBQTlCLENBQW5CO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7QUFNQSxVQUFTSSxPQUFULEdBQW1CO0FBQ2pCaHhFLFdBQVE4d0UsTUFBUixDQUFlLEVBQWY7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxVQUFTRyxPQUFULENBQWlCcHZFLElBQWpCLEVBQXVCO0FBQ3JCLE9BQUlQLENBQUosRUFBTzBWLEdBQVA7QUFDQSxRQUFLMVYsSUFBSSxDQUFKLEVBQU8wVixNQUFNaFgsUUFBUW14RSxLQUFSLENBQWM1dkUsTUFBaEMsRUFBd0NELElBQUkwVixHQUE1QyxFQUFpRDFWLEdBQWpELEVBQXNEO0FBQ3BELFNBQUl0QixRQUFRbXhFLEtBQVIsQ0FBYzd2RSxDQUFkLEVBQWlCa1AsSUFBakIsQ0FBc0IzTyxJQUF0QixDQUFKLEVBQWlDO0FBQy9CLGNBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxRQUFLUCxJQUFJLENBQUosRUFBTzBWLE1BQU1oWCxRQUFRa3hFLEtBQVIsQ0FBYzN2RSxNQUFoQyxFQUF3Q0QsSUFBSTBWLEdBQTVDLEVBQWlEMVYsR0FBakQsRUFBc0Q7QUFDcEQsU0FBSXRCLFFBQVFreEUsS0FBUixDQUFjNXZFLENBQWQsRUFBaUJrUCxJQUFqQixDQUFzQjNPLElBQXRCLENBQUosRUFBaUM7QUFDL0IsY0FBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQU8sS0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFVBQVM4cEQsTUFBVCxDQUFnQm5pRCxHQUFoQixFQUFxQjtBQUNuQixPQUFJQSxlQUFlODdDLEtBQW5CLEVBQTBCLE9BQU85N0MsSUFBSTh0QyxLQUFKLElBQWE5dEMsSUFBSXNqRCxPQUF4QjtBQUMxQixVQUFPdGpELEdBQVA7QUFDRCxFOzs7Ozs7Ozs7O0FDek1EOzs7O0FBSUEsS0FBSTJpQyxJQUFJLElBQVI7QUFDQSxLQUFJOStCLElBQUk4K0IsSUFBSSxFQUFaO0FBQ0EsS0FBSW5lLElBQUkzZ0IsSUFBSSxFQUFaO0FBQ0EsS0FBSTdGLElBQUl3bUIsSUFBSSxFQUFaO0FBQ0EsS0FBSXMvQixJQUFJOWxELElBQUksTUFBWjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFjQXpILFFBQU9DLE9BQVAsR0FBaUIsVUFBU3dKLEdBQVQsRUFBYzZILE9BQWQsRUFBdUI7QUFDdENBLGFBQVVBLFdBQVcsRUFBckI7QUFDQSxPQUFJbUosY0FBY2hSLEdBQWQseUNBQWNBLEdBQWQsQ0FBSjtBQUNBLE9BQUlnUixTQUFTLFFBQVQsSUFBcUJoUixJQUFJakksTUFBSixHQUFhLENBQXRDLEVBQXlDO0FBQ3ZDLFlBQU95NEMsTUFBTXh3QyxHQUFOLENBQVA7QUFDRCxJQUZELE1BRU8sSUFBSWdSLFNBQVMsUUFBVCxJQUFxQnRRLE1BQU1WLEdBQU4sTUFBZSxLQUF4QyxFQUErQztBQUNwRCxZQUFPNkgsUUFBUXVnRSxJQUFSLEdBQWVDLFFBQVFyb0UsR0FBUixDQUFmLEdBQThCc29FLFNBQVN0b0UsR0FBVCxDQUFyQztBQUNEO0FBQ0QsU0FBTSxJQUFJODdDLEtBQUosQ0FDSiwwREFDRXg3QyxLQUFLQyxTQUFMLENBQWVQLEdBQWYsQ0FGRSxDQUFOO0FBSUQsRUFaRDs7QUFjQTs7Ozs7Ozs7QUFRQSxVQUFTd3dDLEtBQVQsQ0FBZTV2QyxHQUFmLEVBQW9CO0FBQ2xCQSxTQUFNSixPQUFPSSxHQUFQLENBQU47QUFDQSxPQUFJQSxJQUFJN0ksTUFBSixHQUFhLEdBQWpCLEVBQXNCO0FBQ3BCO0FBQ0Q7QUFDRCxPQUFJb1EsUUFBUSx3SEFBd0gxTyxJQUF4SCxDQUNWbUgsR0FEVSxDQUFaO0FBR0EsT0FBSSxDQUFDdUgsS0FBTCxFQUFZO0FBQ1Y7QUFDRDtBQUNELE9BQUlsSSxJQUFJQyxXQUFXaUksTUFBTSxDQUFOLENBQVgsQ0FBUjtBQUNBLE9BQUk2SSxPQUFPLENBQUM3SSxNQUFNLENBQU4sS0FBWSxJQUFiLEVBQW1CakgsV0FBbkIsRUFBWDtBQUNBLFdBQVE4UCxJQUFSO0FBQ0UsVUFBSyxPQUFMO0FBQ0EsVUFBSyxNQUFMO0FBQ0EsVUFBSyxLQUFMO0FBQ0EsVUFBSyxJQUFMO0FBQ0EsVUFBSyxHQUFMO0FBQ0UsY0FBTy9RLElBQUk2akQsQ0FBWDtBQUNGLFVBQUssTUFBTDtBQUNBLFVBQUssS0FBTDtBQUNBLFVBQUssR0FBTDtBQUNFLGNBQU83akQsSUFBSWpDLENBQVg7QUFDRixVQUFLLE9BQUw7QUFDQSxVQUFLLE1BQUw7QUFDQSxVQUFLLEtBQUw7QUFDQSxVQUFLLElBQUw7QUFDQSxVQUFLLEdBQUw7QUFDRSxjQUFPaUMsSUFBSXVrQixDQUFYO0FBQ0YsVUFBSyxTQUFMO0FBQ0EsVUFBSyxRQUFMO0FBQ0EsVUFBSyxNQUFMO0FBQ0EsVUFBSyxLQUFMO0FBQ0EsVUFBSyxHQUFMO0FBQ0UsY0FBT3ZrQixJQUFJNEQsQ0FBWDtBQUNGLFVBQUssU0FBTDtBQUNBLFVBQUssUUFBTDtBQUNBLFVBQUssTUFBTDtBQUNBLFVBQUssS0FBTDtBQUNBLFVBQUssR0FBTDtBQUNFLGNBQU81RCxJQUFJMGlDLENBQVg7QUFDRixVQUFLLGNBQUw7QUFDQSxVQUFLLGFBQUw7QUFDQSxVQUFLLE9BQUw7QUFDQSxVQUFLLE1BQUw7QUFDQSxVQUFLLElBQUw7QUFDRSxjQUFPMWlDLENBQVA7QUFDRjtBQUNFLGNBQU92SSxTQUFQO0FBcENKO0FBc0NEOztBQUVEOzs7Ozs7OztBQVFBLFVBQVM0d0UsUUFBVCxDQUFrQmpnQixFQUFsQixFQUFzQjtBQUNwQixPQUFJQSxNQUFNcnFELENBQVYsRUFBYTtBQUNYLFlBQU9tQyxLQUFLb29FLEtBQUwsQ0FBV2xnQixLQUFLcnFELENBQWhCLElBQXFCLEdBQTVCO0FBQ0Q7QUFDRCxPQUFJcXFELE1BQU03akMsQ0FBVixFQUFhO0FBQ1gsWUFBT3JrQixLQUFLb29FLEtBQUwsQ0FBV2xnQixLQUFLN2pDLENBQWhCLElBQXFCLEdBQTVCO0FBQ0Q7QUFDRCxPQUFJNmpDLE1BQU14a0QsQ0FBVixFQUFhO0FBQ1gsWUFBTzFELEtBQUtvb0UsS0FBTCxDQUFXbGdCLEtBQUt4a0QsQ0FBaEIsSUFBcUIsR0FBNUI7QUFDRDtBQUNELE9BQUl3a0QsTUFBTTFsQixDQUFWLEVBQWE7QUFDWCxZQUFPeGlDLEtBQUtvb0UsS0FBTCxDQUFXbGdCLEtBQUsxbEIsQ0FBaEIsSUFBcUIsR0FBNUI7QUFDRDtBQUNELFVBQU8wbEIsS0FBSyxJQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsVUFBU2dnQixPQUFULENBQWlCaGdCLEVBQWpCLEVBQXFCO0FBQ25CLFVBQU9tZ0IsT0FBT25nQixFQUFQLEVBQVdycUQsQ0FBWCxFQUFjLEtBQWQsS0FDTHdxRSxPQUFPbmdCLEVBQVAsRUFBVzdqQyxDQUFYLEVBQWMsTUFBZCxDQURLLElBRUxna0QsT0FBT25nQixFQUFQLEVBQVd4a0QsQ0FBWCxFQUFjLFFBQWQsQ0FGSyxJQUdMMmtFLE9BQU9uZ0IsRUFBUCxFQUFXMWxCLENBQVgsRUFBYyxRQUFkLENBSEssSUFJTDBsQixLQUFLLEtBSlA7QUFLRDs7QUFFRDs7OztBQUlBLFVBQVNtZ0IsTUFBVCxDQUFnQm5nQixFQUFoQixFQUFvQnBvRCxDQUFwQixFQUF1QjVILElBQXZCLEVBQTZCO0FBQzNCLE9BQUlnd0QsS0FBS3BvRCxDQUFULEVBQVk7QUFDVjtBQUNEO0FBQ0QsT0FBSW9vRCxLQUFLcG9ELElBQUksR0FBYixFQUFrQjtBQUNoQixZQUFPRSxLQUFLQyxLQUFMLENBQVdpb0QsS0FBS3BvRCxDQUFoQixJQUFxQixHQUFyQixHQUEyQjVILElBQWxDO0FBQ0Q7QUFDRCxVQUFPOEgsS0FBSzB0RCxJQUFMLENBQVV4RixLQUFLcG9ELENBQWYsSUFBb0IsR0FBcEIsR0FBMEI1SCxJQUExQixHQUFpQyxHQUF4QztBQUNELEU7Ozs7OztBQ3ZKRDs7QUFFQSxLQUFJMlIsU0FBUyxtQkFBQXFnRCxDQUFRLEVBQVIsQ0FBYjtBQUNBLEtBQUl0L0MsVUFBVWYsT0FBT2UsT0FBUCxJQUFrQixtQkFBQXMvQyxDQUFRLEVBQVIsRUFBdUJ0L0MsT0FBdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0F4VSxRQUFPQyxPQUFQLEdBQWlCLFNBQVNvNUQsbUJBQVQsQ0FBNkJELGFBQTdCLEVBQTRDOFksUUFBNUMsRUFBc0Q7QUFDckUsT0FBSXpZLFdBQVcsbUJBQUEzRixDQUFRLEVBQVIsQ0FBZjtBQUNBLE9BQUlyUSxTQUFTLG1CQUFBcVEsQ0FBUSxFQUFSLENBQWI7QUFDQSxPQUFJcWUsZ0JBQWdCLG1CQUFBcmUsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsT0FBSXNlLGVBQWUsbUJBQUF0ZSxDQUFRLEVBQVIsQ0FBbkI7QUFDQSxPQUFJdWUsU0FBUyxtQkFBQXZlLENBQVEsRUFBUixDQUFiO0FBQ0FvZSxjQUFXQSxZQUFZLEVBQXZCOztBQUVBLE9BQUlyakUsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLE9BQTdCLEVBQXNDO0FBQ3BDK2tELEtBQUEsbUJBQUFBLENBQVEsRUFBUixFQUFpQmlkLE1BQWpCLENBQXdCLGdCQUF4QjtBQUNEOztBQUVELFlBQVMzTyxhQUFULENBQXVCb0csYUFBdkIsRUFBc0NsakUsTUFBdEMsRUFBOEM4TixJQUE5QyxFQUFvRDtBQUNsRCxTQUFJay9ELFlBQVksbUJBQUF4ZSxDQUFRLEVBQVIsQ0FBaEI7O0FBRUEsU0FBSXllLHNCQUFzQixtQkFBQXplLENBQVEsRUFBUixDQUExQjs7QUFFQTFnRCxZQUFPay9ELFVBQVVsL0QsUUFBUSxFQUFsQixDQUFQOztBQUVBLFNBQUlBLEtBQUt5aUQsUUFBTCxLQUFrQjEwRCxTQUF0QixFQUFpQztBQUMvQmlTLFlBQUt5aUQsUUFBTCxHQUFnQjBjLHFCQUFoQjtBQUNEOztBQUVEbi9ELFVBQUttMkQsR0FBTCxHQUFXbjJELEtBQUttMkQsR0FBTCxJQUFZbkgsY0FBY2lLLEVBQXJDOztBQUVBLFlBQU8sSUFBSW1HLG9CQUFKLENBQXlCaEssYUFBekIsRUFBd0NsakUsTUFBeEMsRUFBZ0Q4TixJQUFoRCxDQUFQO0FBQ0Q7O0FBRURndkQsaUJBQWM5cUMsT0FBZCxHQUF3QixtQkFBQXc4QixDQUFRLEVBQVIsQ0FBeEI7QUFDQXNPLGlCQUFjaUssRUFBZCxHQUFtQixvQ0FBb0M2RixRQUFwQyxHQUErQzlQLGNBQWM5cUMsT0FBaEY7QUFDQThxQyxpQkFBY3FRLFVBQWQsR0FBMkJKLE9BQU9qUSxhQUFQLENBQTNCOztBQUVBO0FBQ0E7QUFDQTN1RCxVQUFPaS9ELFNBQVAsR0FBbUI7QUFDakJoeEUsWUFBTyxtQkFBQW95RCxDQUFRLEVBQVIsQ0FEVTtBQUVqQnNPLG9CQUFlQTtBQUZFLElBQW5COztBQUtBLE9BQUl1USxVQUFVO0FBQ1pDLHdCQUFtQixvQkFBb0JuL0QsTUFEM0I7QUFFWm8vRCx3QkFBbUIsb0JBQW9CcC9EO0FBRjNCLElBQWQ7O0FBS0EsT0FBSWsvRCxRQUFRQyxpQkFBWixFQUErQjtBQUM3QkQsYUFBUUcsSUFBUixHQUFlLHFCQUFxQixJQUFJQyxjQUFKLEVBQXBDO0FBQ0Q7O0FBRUQsWUFBU1Asb0JBQVQsR0FBZ0M7QUFDOUI7QUFDQXBaLG1CQUFjcjRELEtBQWQsQ0FBb0IsSUFBcEIsRUFBMEJDLFNBQTFCO0FBQ0Q7O0FBRUR5NEQsWUFBUytZLG9CQUFULEVBQStCcFosYUFBL0I7O0FBRUFvWix3QkFBcUI1eEUsU0FBckIsQ0FBK0J5cEUsUUFBL0IsR0FBMEMsU0FBUzVqRSxPQUFULENBQWlCRyxHQUFqQixFQUFzQndNLElBQXRCLEVBQTRCO0FBQ3BFLFlBQU8sSUFBSW9CLE9BQUosQ0FBWSxTQUFTdytELFdBQVQsQ0FBcUJuckUsT0FBckIsRUFBOEJFLE1BQTlCLEVBQXNDO0FBQ3ZEO0FBQ0EsV0FBSSxDQUFDNHFFLFFBQVFHLElBQVQsSUFBaUIsQ0FBQ0gsUUFBUUUsaUJBQTlCLEVBQWlEO0FBQy9DO0FBQ0E5cUUsZ0JBQU8sSUFBSTA3QyxPQUFPb2dCLE9BQVgsQ0FBbUIsb0JBQW5CLENBQVA7QUFDQTtBQUNEOztBQUVEajlELGFBQU11ckUsY0FBY3ZyRSxHQUFkLEVBQW1Cd00sS0FBS2szRCxPQUF4QixDQUFOOztBQUVBLFdBQUk1M0IsT0FBT3QvQixLQUFLcy9CLElBQWhCO0FBQ0EsV0FBSXVnQyxNQUFNTixRQUFRRyxJQUFSLEdBQWUsSUFBSUMsY0FBSixFQUFmLEdBQXNDLElBQUlHLGNBQUosRUFBaEQ7QUFDQSxXQUFJQyxVQUFKO0FBQ0EsV0FBSUMsUUFBSjtBQUNBLFdBQUlDLFlBQVksS0FBaEI7O0FBRUFGLG9CQUFheCtELFdBQVdpL0MsU0FBWCxFQUFzQnhnRCxLQUFLMDFELFFBQUwsQ0FBY0MsT0FBcEMsQ0FBYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWtLLFdBQUlLLFVBQUosR0FBaUIvaEIsVUFBakI7QUFDQSxXQUFJLHdCQUF3QjBoQixHQUE1QixFQUFpQ0EsSUFBSTdkLGtCQUFKLEdBQXlCbWUsa0JBQXpCO0FBQ2pDTixXQUFJTyxNQUFKLEdBQWFDLE1BQWI7QUFDQVIsV0FBSTFrQixPQUFKLEdBQWNtbEIsT0FBZDs7QUFFQTtBQUNBO0FBQ0EsV0FBSVQsZUFBZUYsY0FBbkIsRUFBbUM7QUFDakNFLGFBQUkxK0IsSUFBSixDQUFTbmhDLEtBQUszUyxNQUFkLEVBQXNCbUcsR0FBdEIsRUFBMkIsSUFBM0I7QUFDRCxRQUZELE1BRU87QUFDTHFzRSxhQUFJMStCLElBQUosQ0FBU25oQyxLQUFLM1MsTUFBZCxFQUFzQm1HLEdBQXRCO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFJK3JFLFFBQVFHLElBQVosRUFBa0I7QUFDaEIsYUFBSXBnQyxJQUFKLEVBQVU7QUFDUixlQUFJdC9CLEtBQUszUyxNQUFMLEtBQWdCLE1BQXBCLEVBQTRCO0FBQzFCO0FBQ0F3eUUsaUJBQUlVLGdCQUFKLENBQXFCLGNBQXJCLEVBQXFDLG1DQUFyQztBQUNELFlBSEQsTUFHTztBQUNMVixpQkFBSVUsZ0JBQUosQ0FBcUIsY0FBckIsRUFBcUMsa0JBQXJDO0FBQ0Q7QUFDRjtBQUNEVixhQUFJVSxnQkFBSixDQUFxQixRQUFyQixFQUErQixrQkFBL0I7QUFDRDs7QUFFRFYsV0FBSXRpQixJQUFKLENBQVNqZSxJQUFUOztBQUVBO0FBQ0E7QUFDQSxnQkFBUytnQyxNQUFULEdBQWdCLFdBQWE7QUFDM0I7QUFDQTtBQUNBLGFBQUlMLFFBQUosRUFBYztBQUNaO0FBQ0Q7O0FBRUQzdEIsc0JBQWEwdEIsVUFBYjs7QUFFQSxhQUFJckUsR0FBSjs7QUFFQSxhQUFJO0FBQ0ZBLGlCQUFNO0FBQ0pwOEIsbUJBQU0zb0MsS0FBS2t3QyxLQUFMLENBQVdnNUIsSUFBSXRILFlBQWYsQ0FERjtBQUVKQSwyQkFBY3NILElBQUl0SCxZQUZkO0FBR0pMLHlCQUFZMkgsSUFBSTlTLE1BSFo7QUFJSjtBQUNBbUssc0JBQVMySSxJQUFJVyxxQkFBSixJQUE2QlgsSUFBSVcscUJBQUosRUFBN0IsSUFBNEQ7QUFMakUsWUFBTjtBQU9ELFVBUkQsQ0FRRSxPQUFPOXlFLENBQVAsRUFBVTtBQUNWZ3VFLGlCQUFNLElBQUlyckIsT0FBT2tnQixjQUFYLENBQTBCO0FBQzlCa1EsbUJBQU1aLElBQUl0SDtBQURvQixZQUExQixDQUFOO0FBR0Q7O0FBRUQsYUFBSW1ELGVBQWVyckIsT0FBT2tnQixjQUExQixFQUEwQztBQUN4QzU3RCxrQkFBTyttRSxHQUFQO0FBQ0QsVUFGRCxNQUVPO0FBQ0xqbkUsbUJBQVFpbkUsR0FBUjtBQUNEO0FBQ0Y7O0FBRUQsZ0JBQVM0RSxPQUFULENBQWlCbnNFLEtBQWpCLEVBQXdCO0FBQ3RCLGFBQUk2ckUsUUFBSixFQUFjO0FBQ1o7QUFDRDs7QUFFRDN0QixzQkFBYTB0QixVQUFiOztBQUVBO0FBQ0E7QUFDQTtBQUNBcHJFLGdCQUNFLElBQUkwN0MsT0FBT29nQixPQUFYLENBQW1CO0FBQ2pCZ1EsaUJBQU10c0U7QUFEVyxVQUFuQixDQURGO0FBS0Q7O0FBRUQsZ0JBQVNxc0QsU0FBVCxHQUFxQjtBQUNuQndmLG9CQUFXLElBQVg7QUFDQUgsYUFBSWEsS0FBSjs7QUFFQS9yRSxnQkFBTyxJQUFJMDdDLE9BQU9tZ0IsY0FBWCxFQUFQO0FBQ0Q7O0FBRUQsZ0JBQVNtUSxTQUFULEdBQXFCO0FBQ25CVixxQkFBWSxJQUFaO0FBQ0E1dEIsc0JBQWEwdEIsVUFBYjtBQUNBQSxzQkFBYXgrRCxXQUFXaS9DLFNBQVgsRUFBc0J4Z0QsS0FBSzAxRCxRQUFMLENBQWM0RixRQUFwQyxDQUFiO0FBQ0Q7O0FBRUQsZ0JBQVNuZCxVQUFULEdBQXNCO0FBQ3BCLGFBQUksQ0FBQzhoQixTQUFMLEVBQWdCVTtBQUNqQjs7QUFFRCxnQkFBU1Isa0JBQVQsR0FBOEI7QUFDNUIsYUFBSSxDQUFDRixTQUFELElBQWNKLElBQUllLFVBQUosR0FBaUIsQ0FBbkMsRUFBc0NEO0FBQ3ZDO0FBQ0YsTUF6SE0sQ0FBUDtBQTBIRCxJQTNIRDs7QUE2SEF2Qix3QkFBcUI1eEUsU0FBckIsQ0FBK0J5cEUsUUFBL0IsQ0FBd0N2NUMsUUFBeEMsR0FBbUQsU0FBU21qRCxlQUFULENBQXlCcnRFLEdBQXpCLEVBQThCd00sSUFBOUIsRUFBb0M7QUFDckZ4TSxXQUFNdXJFLGNBQWN2ckUsR0FBZCxFQUFtQndNLEtBQUtrM0QsT0FBeEIsQ0FBTjs7QUFFQSxZQUFPLElBQUk5MUQsT0FBSixDQUFZLFNBQVMwL0QsZ0JBQVQsQ0FBMEJyc0UsT0FBMUIsRUFBbUNFLE1BQW5DLEVBQTJDO0FBQzVEcXFFLG9CQUFheHJFLEdBQWIsRUFBa0J3TSxJQUFsQixFQUF3QixTQUFTK2dFLGdCQUFULENBQTBCOWhFLEdBQTFCLEVBQStCeWhDLE9BQS9CLEVBQXdDO0FBQzlELGFBQUl6aEMsR0FBSixFQUFTO0FBQ1B0SyxrQkFBT3NLLEdBQVA7QUFDQTtBQUNEOztBQUVEeEssaUJBQVFpc0MsT0FBUjtBQUNELFFBUEQ7QUFRRCxNQVRNLENBQVA7QUFVRCxJQWJEOztBQWVBMCtCLHdCQUFxQjV4RSxTQUFyQixDQUErQm05RCxRQUEvQixHQUEwQztBQUN4Q2gyRCxhQUFRLFNBQVNxc0UsYUFBVCxDQUF1QjNxRSxHQUF2QixFQUE0QjtBQUNsQyxjQUFPK0ssUUFBUXpNLE1BQVIsQ0FBZTBCLEdBQWYsQ0FBUDtBQUNELE1BSHVDO0FBSXhDNUIsY0FBUyxTQUFTd3NFLGNBQVQsQ0FBd0I1cUUsR0FBeEIsRUFBNkI7QUFDcEMsY0FBTytLLFFBQVEzTSxPQUFSLENBQWdCNEIsR0FBaEIsQ0FBUDtBQUNELE1BTnVDO0FBT3hDZ2EsWUFBTyxTQUFTNndELFlBQVQsQ0FBc0J4aUIsRUFBdEIsRUFBMEI7QUFDL0IsY0FBTyxJQUFJdDlDLE9BQUosQ0FBWSxTQUFTKy9ELGdCQUFULENBQTBCMXNFLE9BQTFCLENBQWlDLGFBQWpDLEVBQWdEO0FBQ2pFOE0sb0JBQVc5TSxPQUFYLEVBQW9CaXFELEVBQXBCO0FBQ0QsUUFGTSxDQUFQO0FBR0Q7QUFYdUMsSUFBMUM7O0FBY0EsVUFBT3NRLGFBQVA7QUFDRCxFQWxORCxDOzs7Ozs7Ozs7QUNSQSxLQUFJb1MsR0FBSjs7QUFFQSxLQUFJLE9BQU9oeUUsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUMvQmd5RSxXQUFNaHlFLE1BQU47QUFDSCxFQUZELE1BRU8sSUFBSSxPQUFPaVIsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUN0QytnRSxXQUFNL2dFLE1BQU47QUFDSCxFQUZNLE1BRUEsSUFBSSxPQUFPeFIsSUFBUCxLQUFnQixXQUFwQixFQUFnQztBQUNuQ3V5RSxXQUFNdnlFLElBQU47QUFDSCxFQUZNLE1BRUE7QUFDSHV5RSxXQUFNLEVBQU47QUFDSDs7QUFFRHgwRSxRQUFPQyxPQUFQLEdBQWlCdTBFLEdBQWpCLEM7Ozs7Ozs7Ozs7O0FDWkE7Ozs7Ozs7O0FBUUMsWUFBVS9nRSxNQUFWLEVBQWtCelIsT0FBbEIsRUFBMkI7QUFDM0IsbUNBQU8vQixPQUFQLE9BQW1CLFFBQW5CLElBQStCLE9BQU9ELE1BQVAsS0FBa0IsV0FBakQsR0FBK0RBLE9BQU9DLE9BQVAsR0FBaUIrQixTQUFoRixHQUNBLFFBQTZDLG9DQUFPQSxPQUFQLG1UQUE3QyxHQUNDeVIsT0FBT2doRSxVQUFQLEdBQW9CenlFLFNBRnJCO0FBR0EsRUFKQSxhQUlRLFlBQVk7QUFBRTs7QUFFdkIsWUFBUzB5RSxnQkFBVCxDQUEwQnBuQixDQUExQixFQUE2QjtBQUMzQixTQUFJN3lDLGNBQWM2eUMsQ0FBZCx5Q0FBY0EsQ0FBZCxDQUFKO0FBQ0EsWUFBT0EsTUFBTSxJQUFOLEtBQWU3eUMsU0FBUyxRQUFULElBQXFCQSxTQUFTLFVBQTdDLENBQVA7QUFDRDs7QUFFRCxZQUFTZ3NELFVBQVQsQ0FBb0JuWixDQUFwQixFQUF1QjtBQUNyQixZQUFPLE9BQU9BLENBQVAsS0FBYSxVQUFwQjtBQUNEOztBQUVELE9BQUlxbkIsV0FBV3h6RSxTQUFmO0FBQ0EsT0FBSXdMLE1BQU1tQixPQUFWLEVBQW1CO0FBQ2pCNm1FLGdCQUFXaG9FLE1BQU1tQixPQUFqQjtBQUNELElBRkQsTUFFTztBQUNMNm1FLGdCQUFXLGtCQUFVcm5CLENBQVYsRUFBYTtBQUN0QixjQUFPbmxELE9BQU92SCxTQUFQLENBQWlCeUksUUFBakIsQ0FBMEJ4SSxJQUExQixDQUErQnlzRCxDQUEvQixNQUFzQyxnQkFBN0M7QUFDRCxNQUZEO0FBR0Q7O0FBRUQsT0FBSXgvQyxVQUFVNm1FLFFBQWQ7O0FBRUEsT0FBSTE5RCxNQUFNLENBQVY7QUFDQSxPQUFJMjlELFlBQVl6ekUsU0FBaEI7QUFDQSxPQUFJMHpFLG9CQUFvQjF6RSxTQUF4Qjs7QUFFQSxPQUFJMnpFLE9BQU8sU0FBU0EsSUFBVCxDQUFjMWtELFFBQWQsRUFBd0J5UyxHQUF4QixFQUE2QjtBQUN0Q2hhLFdBQU01UixHQUFOLElBQWFtWixRQUFiO0FBQ0F2SCxXQUFNNVIsTUFBTSxDQUFaLElBQWlCNHJCLEdBQWpCO0FBQ0E1ckIsWUFBTyxDQUFQO0FBQ0EsU0FBSUEsUUFBUSxDQUFaLEVBQWU7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFJNDlELGlCQUFKLEVBQXVCO0FBQ3JCQSwyQkFBa0I1c0IsS0FBbEI7QUFDRCxRQUZELE1BRU87QUFDTDhzQjtBQUNEO0FBQ0Y7QUFDRixJQWREOztBQWdCQSxZQUFTQyxZQUFULENBQXNCQyxVQUF0QixFQUFrQztBQUNoQ0oseUJBQW9CSSxVQUFwQjtBQUNEOztBQUVELFlBQVNDLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCO0FBQ3ZCTCxZQUFPSyxNQUFQO0FBQ0Q7O0FBRUQsT0FBSUMsZ0JBQWdCLE9BQU81eUUsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUNyQixTQUE3RDtBQUNBLE9BQUlrMEUsZ0JBQWdCRCxpQkFBaUIsRUFBckM7QUFDQSxPQUFJRSwwQkFBMEJELGNBQWN6Z0UsZ0JBQWQsSUFBa0N5Z0UsY0FBY0Usc0JBQTlFO0FBQ0EsT0FBSUMsU0FBUyxPQUFPdnpFLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0IsT0FBTzRNLE9BQVAsS0FBbUIsV0FBbEQsSUFBa0UsRUFBRCxDQUFLeEYsUUFBTCxDQUFjeEksSUFBZCxDQUFtQmdPLE9BQW5CLE1BQWdDLGtCQUE5Rzs7QUFFQTtBQUNBLE9BQUk0bUUsV0FBVyxPQUFPQyxpQkFBUCxLQUE2QixXQUE3QixJQUE0QyxPQUFPamhCLGFBQVAsS0FBeUIsV0FBckUsSUFBb0YsT0FBT25NLGNBQVAsS0FBMEIsV0FBN0g7O0FBRUE7QUFDQSxZQUFTcXRCLFdBQVQsR0FBdUI7QUFDckI7QUFDQTtBQUNBLFlBQU8sWUFBWTtBQUNqQixjQUFPOW1FLFFBQVFxRixRQUFSLENBQWlCK3pDLEtBQWpCLENBQVA7QUFDRCxNQUZEO0FBR0Q7O0FBRUQ7QUFDQSxZQUFTMnRCLGFBQVQsR0FBeUI7QUFDdkIsU0FBSSxPQUFPaEIsU0FBUCxLQUFxQixXQUF6QixFQUFzQztBQUNwQyxjQUFPLFlBQVk7QUFDakJBLG1CQUFVM3NCLEtBQVY7QUFDRCxRQUZEO0FBR0Q7O0FBRUQsWUFBTzR0QixlQUFQO0FBQ0Q7O0FBRUQsWUFBU0MsbUJBQVQsR0FBK0I7QUFDN0IsU0FBSUMsYUFBYSxDQUFqQjtBQUNBLFNBQUlqaEUsV0FBVyxJQUFJd2dFLHVCQUFKLENBQTRCcnRCLEtBQTVCLENBQWY7QUFDQSxTQUFJaG9DLE9BQU90ZCxTQUFTcVMsY0FBVCxDQUF3QixFQUF4QixDQUFYO0FBQ0FGLGNBQVNHLE9BQVQsQ0FBaUJnTCxJQUFqQixFQUF1QixFQUFFL0ssZUFBZSxJQUFqQixFQUF2Qjs7QUFFQSxZQUFPLFlBQVk7QUFDakIrSyxZQUFLblosSUFBTCxHQUFZaXZFLGFBQWEsRUFBRUEsVUFBRixHQUFlLENBQXhDO0FBQ0QsTUFGRDtBQUdEOztBQUVEO0FBQ0EsWUFBU0MsaUJBQVQsR0FBNkI7QUFDM0IsU0FBSXp0QixVQUFVLElBQUlELGNBQUosRUFBZDtBQUNBQyxhQUFRQyxLQUFSLENBQWNDLFNBQWQsR0FBMEJSLEtBQTFCO0FBQ0EsWUFBTyxZQUFZO0FBQ2pCLGNBQU9NLFFBQVFJLEtBQVIsQ0FBY0MsV0FBZCxDQUEwQixDQUExQixDQUFQO0FBQ0QsTUFGRDtBQUdEOztBQUVELFlBQVNpdEIsYUFBVCxHQUF5QjtBQUN2QjtBQUNBO0FBQ0EsU0FBSUksbUJBQW1CdGhFLFVBQXZCO0FBQ0EsWUFBTyxZQUFZO0FBQ2pCLGNBQU9zaEUsaUJBQWlCaHVCLEtBQWpCLEVBQXdCLENBQXhCLENBQVA7QUFDRCxNQUZEO0FBR0Q7O0FBRUQsT0FBSXAvQixRQUFRLElBQUlsYyxLQUFKLENBQVUsSUFBVixDQUFaO0FBQ0EsWUFBU3M3QyxLQUFULEdBQWlCO0FBQ2YsVUFBSyxJQUFJMW1ELElBQUksQ0FBYixFQUFnQkEsSUFBSTBWLEdBQXBCLEVBQXlCMVYsS0FBSyxDQUE5QixFQUFpQztBQUMvQixXQUFJNnVCLFdBQVd2SCxNQUFNdG5CLENBQU4sQ0FBZjtBQUNBLFdBQUlzaEMsTUFBTWhhLE1BQU10bkIsSUFBSSxDQUFWLENBQVY7O0FBRUE2dUIsZ0JBQVN5UyxHQUFUOztBQUVBaGEsYUFBTXRuQixDQUFOLElBQVdKLFNBQVg7QUFDQTBuQixhQUFNdG5CLElBQUksQ0FBVixJQUFlSixTQUFmO0FBQ0Q7O0FBRUQ4VixXQUFNLENBQU47QUFDRDs7QUFFRCxZQUFTaS9ELFlBQVQsR0FBd0I7QUFDdEIsU0FBSTtBQUNGLFdBQUkxZSxJQUFJMUQsT0FBUjtBQUNBLFdBQUlxaUIsUUFBUSxtQkFBQTNlLENBQUUsRUFBRixDQUFaO0FBQ0FvZCxtQkFBWXVCLE1BQU1DLFNBQU4sSUFBbUJELE1BQU1FLFlBQXJDO0FBQ0EsY0FBT1QsZUFBUDtBQUNELE1BTEQsQ0FLRSxPQUFPOTBFLENBQVAsRUFBVTtBQUNWLGNBQU8rMEUsZUFBUDtBQUNEO0FBQ0Y7O0FBRUQsT0FBSWQsZ0JBQWdCNXpFLFNBQXBCO0FBQ0E7QUFDQSxPQUFJcTBFLE1BQUosRUFBWTtBQUNWVCxxQkFBZ0JZLGFBQWhCO0FBQ0QsSUFGRCxNQUVPLElBQUlMLHVCQUFKLEVBQTZCO0FBQ2xDUCxxQkFBZ0JlLHFCQUFoQjtBQUNELElBRk0sTUFFQSxJQUFJTCxRQUFKLEVBQWM7QUFDbkJWLHFCQUFnQmlCLG1CQUFoQjtBQUNELElBRk0sTUFFQSxJQUFJWixrQkFBa0JqMEUsU0FBbEIsSUFBK0IsZUFBbUIsVUFBdEQsRUFBa0U7QUFDdkU0ekUscUJBQWdCbUIsY0FBaEI7QUFDRCxJQUZNLE1BRUE7QUFDTG5CLHFCQUFnQmMsZUFBaEI7QUFDRDs7QUFFRCxZQUFTOXVFLElBQVQsQ0FBY3V2RSxhQUFkLEVBQTZCQyxXQUE3QixFQUEwQztBQUN4QyxTQUFJQyxhQUFheDFFLFNBQWpCOztBQUVBLFNBQUl3WSxTQUFTLElBQWI7O0FBRUEsU0FBSUMsUUFBUSxJQUFJLEtBQUt2SCxXQUFULENBQXFCL1IsSUFBckIsQ0FBWjs7QUFFQSxTQUFJc1osTUFBTWc5RCxVQUFOLE1BQXNCdDFFLFNBQTFCLEVBQXFDO0FBQ25Dd3NELG1CQUFZbDBDLEtBQVo7QUFDRDs7QUFFRCxTQUFJaTlELFNBQVNsOUQsT0FBT2s5RCxNQUFwQjs7QUFFQSxTQUFJQSxNQUFKLEVBQVk7QUFDVixRQUFDLFlBQVk7QUFDWCxhQUFJdG1ELFdBQVdvbUQsV0FBV0UsU0FBUyxDQUFwQixDQUFmO0FBQ0E1QixjQUFLLFlBQVk7QUFDZixrQkFBTzZCLGVBQWVELE1BQWYsRUFBdUJqOUQsS0FBdkIsRUFBOEIyVyxRQUE5QixFQUF3QzVXLE9BQU9rbUQsT0FBL0MsQ0FBUDtBQUNELFVBRkQ7QUFHRCxRQUxEO0FBTUQsTUFQRCxNQU9PO0FBQ0xrWCxpQkFBVXA5RCxNQUFWLEVBQWtCQyxLQUFsQixFQUF5QjY4RCxhQUF6QixFQUF3Q0MsV0FBeEM7QUFDRDs7QUFFRCxZQUFPOThELEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQSxZQUFTbzlELFNBQVQsQ0FBbUJqdEIsTUFBbkIsRUFBMkI7QUFDekI7QUFDQSxTQUFJa3RCLGNBQWMsSUFBbEI7O0FBRUEsU0FBSWx0QixVQUFVLFFBQU9BLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBNUIsSUFBd0NBLE9BQU8xM0MsV0FBUCxLQUF1QjRrRSxXQUFuRSxFQUFnRjtBQUM5RSxjQUFPbHRCLE1BQVA7QUFDRDs7QUFFRCxTQUFJNWhELFVBQVUsSUFBSTh1RSxXQUFKLENBQWdCMzJFLElBQWhCLENBQWQ7QUFDQTBILGFBQVFHLE9BQVIsRUFBaUI0aEQsTUFBakI7QUFDQSxZQUFPNWhELE9BQVA7QUFDRDs7QUFFRCxPQUFJeXVFLGFBQWE3c0UsS0FBS2tyRCxNQUFMLEdBQWN6ckQsUUFBZCxDQUF1QixFQUF2QixFQUEyQjA3QixTQUEzQixDQUFxQyxFQUFyQyxDQUFqQjs7QUFFQSxZQUFTNWtDLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsT0FBSTQyRSxVQUFVLEtBQUssQ0FBbkI7QUFDQSxPQUFJQyxZQUFZLENBQWhCO0FBQ0EsT0FBSUMsV0FBVyxDQUFmOztBQUVBLE9BQUlDLGlCQUFpQixJQUFJQyxXQUFKLEVBQXJCOztBQUVBLFlBQVNDLGVBQVQsR0FBMkI7QUFDekIsWUFBTyxJQUFJbnpFLFNBQUosQ0FBYywwQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQsWUFBU296RSxlQUFULEdBQTJCO0FBQ3pCLFlBQU8sSUFBSXB6RSxTQUFKLENBQWMsc0RBQWQsQ0FBUDtBQUNEOztBQUVELFlBQVNxekUsT0FBVCxDQUFpQnR2RSxPQUFqQixFQUEwQjtBQUN4QixTQUFJO0FBQ0YsY0FBT0EsUUFBUWpCLElBQWY7QUFDRCxNQUZELENBRUUsT0FBT00sS0FBUCxFQUFjO0FBQ2Q2dkUsc0JBQWU3dkUsS0FBZixHQUF1QkEsS0FBdkI7QUFDQSxjQUFPNnZFLGNBQVA7QUFDRDtBQUNGOztBQUVELFlBQVNLLE9BQVQsQ0FBaUJDLE9BQWpCLEVBQTBCdHVFLEtBQTFCLEVBQWlDdXVFLGtCQUFqQyxFQUFxREMsZ0JBQXJELEVBQXVFO0FBQ3JFLFNBQUk7QUFDRkYsZUFBUTMyRSxJQUFSLENBQWFxSSxLQUFiLEVBQW9CdXVFLGtCQUFwQixFQUF3Q0MsZ0JBQXhDO0FBQ0QsTUFGRCxDQUVFLE9BQU81MkUsQ0FBUCxFQUFVO0FBQ1YsY0FBT0EsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsWUFBUzYyRSxxQkFBVCxDQUErQjN2RSxPQUEvQixFQUF3QzR2RSxRQUF4QyxFQUFrREosT0FBbEQsRUFBMkQ7QUFDekQxQyxVQUFLLFVBQVU5c0UsT0FBVixFQUFtQjtBQUN0QixXQUFJMHNCLFNBQVMsS0FBYjtBQUNBLFdBQUlydEIsUUFBUWt3RSxRQUFRQyxPQUFSLEVBQWlCSSxRQUFqQixFQUEyQixVQUFVMXVFLEtBQVYsRUFBaUI7QUFDdEQsYUFBSXdyQixNQUFKLEVBQVk7QUFDVjtBQUNEO0FBQ0RBLGtCQUFTLElBQVQ7QUFDQSxhQUFJa2pELGFBQWExdUUsS0FBakIsRUFBd0I7QUFDdEJyQixtQkFBUUcsT0FBUixFQUFpQmtCLEtBQWpCO0FBQ0QsVUFGRCxNQUVPO0FBQ0wyaUQsbUJBQVE3akQsT0FBUixFQUFpQmtCLEtBQWpCO0FBQ0Q7QUFDRixRQVZXLEVBVVQsVUFBVXFhLE1BQVYsRUFBa0I7QUFDbkIsYUFBSW1SLE1BQUosRUFBWTtBQUNWO0FBQ0Q7QUFDREEsa0JBQVMsSUFBVDs7QUFFQTNzQixnQkFBT0MsT0FBUCxFQUFnQnViLE1BQWhCO0FBQ0QsUUFqQlcsRUFpQlQsY0FBY3ZiLFFBQVE2dkUsTUFBUixJQUFrQixrQkFBaEMsQ0FqQlMsQ0FBWjs7QUFtQkEsV0FBSSxDQUFDbmpELE1BQUQsSUFBV3J0QixLQUFmLEVBQXNCO0FBQ3BCcXRCLGtCQUFTLElBQVQ7QUFDQTNzQixnQkFBT0MsT0FBUCxFQUFnQlgsS0FBaEI7QUFDRDtBQUNGLE1BekJELEVBeUJHVyxPQXpCSDtBQTBCRDs7QUFFRCxZQUFTOHZFLGlCQUFULENBQTJCOXZFLE9BQTNCLEVBQW9DNHZFLFFBQXBDLEVBQThDO0FBQzVDLFNBQUlBLFNBQVNsQixNQUFULEtBQW9CTSxTQUF4QixFQUFtQztBQUNqQ25yQixlQUFRN2pELE9BQVIsRUFBaUI0dkUsU0FBU2xZLE9BQTFCO0FBQ0QsTUFGRCxNQUVPLElBQUlrWSxTQUFTbEIsTUFBVCxLQUFvQk8sUUFBeEIsRUFBa0M7QUFDdkNsdkUsY0FBT0MsT0FBUCxFQUFnQjR2RSxTQUFTbFksT0FBekI7QUFDRCxNQUZNLE1BRUE7QUFDTGtYLGlCQUFVZ0IsUUFBVixFQUFvQnoyRSxTQUFwQixFQUErQixVQUFVK0gsS0FBVixFQUFpQjtBQUM5QyxnQkFBT3JCLFFBQVFHLE9BQVIsRUFBaUJrQixLQUFqQixDQUFQO0FBQ0QsUUFGRCxFQUVHLFVBQVVxYSxNQUFWLEVBQWtCO0FBQ25CLGdCQUFPeGIsT0FBT0MsT0FBUCxFQUFnQnViLE1BQWhCLENBQVA7QUFDRCxRQUpEO0FBS0Q7QUFDRjs7QUFFRCxZQUFTdzBELG1CQUFULENBQTZCL3ZFLE9BQTdCLEVBQXNDZ3dFLGFBQXRDLEVBQXFEUixPQUFyRCxFQUE4RDtBQUM1RCxTQUFJUSxjQUFjOWxFLFdBQWQsS0FBOEJsSyxRQUFRa0ssV0FBdEMsSUFBcURzbEUsWUFBWXp3RSxJQUFqRSxJQUF5RWl4RSxjQUFjOWxFLFdBQWQsQ0FBMEJySyxPQUExQixLQUFzQ2d2RSxTQUFuSCxFQUE4SDtBQUM1SGlCLHlCQUFrQjl2RSxPQUFsQixFQUEyQmd3RSxhQUEzQjtBQUNELE1BRkQsTUFFTztBQUNMLFdBQUlSLFlBQVlOLGNBQWhCLEVBQWdDO0FBQzlCbnZFLGdCQUFPQyxPQUFQLEVBQWdCa3ZFLGVBQWU3dkUsS0FBL0I7QUFDQTZ2RSx3QkFBZTd2RSxLQUFmLEdBQXVCLElBQXZCO0FBQ0QsUUFIRCxNQUdPLElBQUltd0UsWUFBWXIyRSxTQUFoQixFQUEyQjtBQUNoQzBxRCxpQkFBUTdqRCxPQUFSLEVBQWlCZ3dFLGFBQWpCO0FBQ0QsUUFGTSxNQUVBLElBQUl2UixXQUFXK1EsT0FBWCxDQUFKLEVBQXlCO0FBQzlCRywrQkFBc0IzdkUsT0FBdEIsRUFBK0Jnd0UsYUFBL0IsRUFBOENSLE9BQTlDO0FBQ0QsUUFGTSxNQUVBO0FBQ0wzckIsaUJBQVE3akQsT0FBUixFQUFpQmd3RSxhQUFqQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFTbndFLE9BQVQsQ0FBaUJHLE9BQWpCLEVBQTBCa0IsS0FBMUIsRUFBaUM7QUFDL0IsU0FBSWxCLFlBQVlrQixLQUFoQixFQUF1QjtBQUNyQm5CLGNBQU9DLE9BQVAsRUFBZ0JvdkUsaUJBQWhCO0FBQ0QsTUFGRCxNQUVPLElBQUkxQyxpQkFBaUJ4ckUsS0FBakIsQ0FBSixFQUE2QjtBQUNsQzZ1RSwyQkFBb0IvdkUsT0FBcEIsRUFBNkJrQixLQUE3QixFQUFvQ291RSxRQUFRcHVFLEtBQVIsQ0FBcEM7QUFDRCxNQUZNLE1BRUE7QUFDTDJpRCxlQUFRN2pELE9BQVIsRUFBaUJrQixLQUFqQjtBQUNEO0FBQ0Y7O0FBRUQsWUFBUyt1RSxnQkFBVCxDQUEwQmp3RSxPQUExQixFQUFtQztBQUNqQyxTQUFJQSxRQUFRa3dFLFFBQVosRUFBc0I7QUFDcEJsd0UsZUFBUWt3RSxRQUFSLENBQWlCbHdFLFFBQVEwM0QsT0FBekI7QUFDRDs7QUFFRHlZLGFBQVFud0UsT0FBUjtBQUNEOztBQUVELFlBQVM2akQsT0FBVCxDQUFpQjdqRCxPQUFqQixFQUEwQmtCLEtBQTFCLEVBQWlDO0FBQy9CLFNBQUlsQixRQUFRMHVFLE1BQVIsS0FBbUJLLE9BQXZCLEVBQWdDO0FBQzlCO0FBQ0Q7O0FBRUQvdUUsYUFBUTAzRCxPQUFSLEdBQWtCeDJELEtBQWxCO0FBQ0FsQixhQUFRMHVFLE1BQVIsR0FBaUJNLFNBQWpCOztBQUVBLFNBQUlodkUsUUFBUW93RSxZQUFSLENBQXFCNTJFLE1BQXJCLEtBQWdDLENBQXBDLEVBQXVDO0FBQ3JDc3pFLFlBQUtxRCxPQUFMLEVBQWNud0UsT0FBZDtBQUNEO0FBQ0Y7O0FBRUQsWUFBU0QsTUFBVCxDQUFnQkMsT0FBaEIsRUFBeUJ1YixNQUF6QixFQUFpQztBQUMvQixTQUFJdmIsUUFBUTB1RSxNQUFSLEtBQW1CSyxPQUF2QixFQUFnQztBQUM5QjtBQUNEO0FBQ0QvdUUsYUFBUTB1RSxNQUFSLEdBQWlCTyxRQUFqQjtBQUNBanZFLGFBQVEwM0QsT0FBUixHQUFrQm44QyxNQUFsQjs7QUFFQXV4RCxVQUFLbUQsZ0JBQUwsRUFBdUJqd0UsT0FBdkI7QUFDRDs7QUFFRCxZQUFTNHVFLFNBQVQsQ0FBbUJwOUQsTUFBbkIsRUFBMkJDLEtBQTNCLEVBQWtDNjhELGFBQWxDLEVBQWlEQyxXQUFqRCxFQUE4RDtBQUM1RCxTQUFJNkIsZUFBZTUrRCxPQUFPNCtELFlBQTFCO0FBQ0EsU0FBSTUyRSxTQUFTNDJFLGFBQWE1MkUsTUFBMUI7O0FBRUFnWSxZQUFPMCtELFFBQVAsR0FBa0IsSUFBbEI7O0FBRUFFLGtCQUFhNTJFLE1BQWIsSUFBdUJpWSxLQUF2QjtBQUNBMitELGtCQUFhNTJFLFNBQVN3MUUsU0FBdEIsSUFBbUNWLGFBQW5DO0FBQ0E4QixrQkFBYTUyRSxTQUFTeTFFLFFBQXRCLElBQWtDVixXQUFsQzs7QUFFQSxTQUFJLzBFLFdBQVcsQ0FBWCxJQUFnQmdZLE9BQU9rOUQsTUFBM0IsRUFBbUM7QUFDakM1QixZQUFLcUQsT0FBTCxFQUFjMytELE1BQWQ7QUFDRDtBQUNGOztBQUVELFlBQVMyK0QsT0FBVCxDQUFpQm53RSxPQUFqQixFQUEwQjtBQUN4QixTQUFJcXdFLGNBQWNyd0UsUUFBUW93RSxZQUExQjtBQUNBLFNBQUlFLFVBQVV0d0UsUUFBUTB1RSxNQUF0Qjs7QUFFQSxTQUFJMkIsWUFBWTcyRSxNQUFaLEtBQXVCLENBQTNCLEVBQThCO0FBQzVCO0FBQ0Q7O0FBRUQsU0FBSWlZLFFBQVF0WSxTQUFaO0FBQUEsU0FDSWl2QixXQUFXanZCLFNBRGY7QUFBQSxTQUVJbzNFLFNBQVN2d0UsUUFBUTAzRCxPQUZyQjs7QUFJQSxVQUFLLElBQUluK0QsSUFBSSxDQUFiLEVBQWdCQSxJQUFJODJFLFlBQVk3MkUsTUFBaEMsRUFBd0NELEtBQUssQ0FBN0MsRUFBZ0Q7QUFDOUNrWSxlQUFRNCtELFlBQVk5MkUsQ0FBWixDQUFSO0FBQ0E2dUIsa0JBQVdpb0QsWUFBWTkyRSxJQUFJKzJFLE9BQWhCLENBQVg7O0FBRUEsV0FBSTcrRCxLQUFKLEVBQVc7QUFDVGs5RCx3QkFBZTJCLE9BQWYsRUFBd0I3K0QsS0FBeEIsRUFBK0IyVyxRQUEvQixFQUF5Q21vRCxNQUF6QztBQUNELFFBRkQsTUFFTztBQUNMbm9ELGtCQUFTbW9ELE1BQVQ7QUFDRDtBQUNGOztBQUVEdndFLGFBQVFvd0UsWUFBUixDQUFxQjUyRSxNQUFyQixHQUE4QixDQUE5QjtBQUNEOztBQUVELFlBQVMyMUUsV0FBVCxHQUF1QjtBQUNyQixVQUFLOXZFLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7O0FBRUQsT0FBSW14RSxrQkFBa0IsSUFBSXJCLFdBQUosRUFBdEI7O0FBRUEsWUFBU3NCLFFBQVQsQ0FBa0Jyb0QsUUFBbEIsRUFBNEJtb0QsTUFBNUIsRUFBb0M7QUFDbEMsU0FBSTtBQUNGLGNBQU9ub0QsU0FBU21vRCxNQUFULENBQVA7QUFDRCxNQUZELENBRUUsT0FBT3ozRSxDQUFQLEVBQVU7QUFDVjAzRSx1QkFBZ0JueEUsS0FBaEIsR0FBd0J2RyxDQUF4QjtBQUNBLGNBQU8wM0UsZUFBUDtBQUNEO0FBQ0Y7O0FBRUQsWUFBUzdCLGNBQVQsQ0FBd0IyQixPQUF4QixFQUFpQ3R3RSxPQUFqQyxFQUEwQ29vQixRQUExQyxFQUFvRG1vRCxNQUFwRCxFQUE0RDtBQUMxRCxTQUFJRyxjQUFjalMsV0FBV3IyQyxRQUFYLENBQWxCO0FBQUEsU0FDSWxuQixRQUFRL0gsU0FEWjtBQUFBLFNBRUlrRyxRQUFRbEcsU0FGWjtBQUFBLFNBR0l3M0UsWUFBWXgzRSxTQUhoQjtBQUFBLFNBSUl5M0UsU0FBU3ozRSxTQUpiOztBQU1BLFNBQUl1M0UsV0FBSixFQUFpQjtBQUNmeHZFLGVBQVF1dkUsU0FBU3JvRCxRQUFULEVBQW1CbW9ELE1BQW5CLENBQVI7O0FBRUEsV0FBSXJ2RSxVQUFVc3ZFLGVBQWQsRUFBK0I7QUFDN0JJLGtCQUFTLElBQVQ7QUFDQXZ4RSxpQkFBUTZCLE1BQU03QixLQUFkO0FBQ0E2QixlQUFNN0IsS0FBTixHQUFjLElBQWQ7QUFDRCxRQUpELE1BSU87QUFDTHN4RSxxQkFBWSxJQUFaO0FBQ0Q7O0FBRUQsV0FBSTN3RSxZQUFZa0IsS0FBaEIsRUFBdUI7QUFDckJuQixnQkFBT0MsT0FBUCxFQUFnQnF2RSxpQkFBaEI7QUFDQTtBQUNEO0FBQ0YsTUFmRCxNQWVPO0FBQ0xudUUsZUFBUXF2RSxNQUFSO0FBQ0FJLG1CQUFZLElBQVo7QUFDRDs7QUFFRCxTQUFJM3dFLFFBQVEwdUUsTUFBUixLQUFtQkssT0FBdkIsRUFBZ0M7QUFDOUI7QUFDRCxNQUZELE1BRU8sSUFBSTJCLGVBQWVDLFNBQW5CLEVBQThCO0FBQ2pDOXdFLGVBQVFHLE9BQVIsRUFBaUJrQixLQUFqQjtBQUNELE1BRkksTUFFRSxJQUFJMHZFLE1BQUosRUFBWTtBQUNqQjd3RSxjQUFPQyxPQUFQLEVBQWdCWCxLQUFoQjtBQUNELE1BRk0sTUFFQSxJQUFJaXhFLFlBQVl0QixTQUFoQixFQUEyQjtBQUNoQ25yQixlQUFRN2pELE9BQVIsRUFBaUJrQixLQUFqQjtBQUNELE1BRk0sTUFFQSxJQUFJb3ZFLFlBQVlyQixRQUFoQixFQUEwQjtBQUMvQmx2RSxjQUFPQyxPQUFQLEVBQWdCa0IsS0FBaEI7QUFDRDtBQUNKOztBQUVELFlBQVMydkUsaUJBQVQsQ0FBMkI3d0UsT0FBM0IsRUFBb0NtbEQsUUFBcEMsRUFBOEM7QUFDNUMsU0FBSTtBQUNGQSxnQkFBUyxTQUFTa25CLGNBQVQsQ0FBd0JuckUsS0FBeEIsRUFBK0I7QUFDdENyQixpQkFBUUcsT0FBUixFQUFpQmtCLEtBQWpCO0FBQ0QsUUFGRCxFQUVHLFNBQVNrckUsYUFBVCxDQUF1Qjd3RCxNQUF2QixFQUErQjtBQUNoQ3hiLGdCQUFPQyxPQUFQLEVBQWdCdWIsTUFBaEI7QUFDRCxRQUpEO0FBS0QsTUFORCxDQU1FLE9BQU96aUIsQ0FBUCxFQUFVO0FBQ1ZpSCxjQUFPQyxPQUFQLEVBQWdCbEgsQ0FBaEI7QUFDRDtBQUNGOztBQUVELE9BQUlxRixLQUFLLENBQVQ7QUFDQSxZQUFTMnlFLE1BQVQsR0FBa0I7QUFDaEIsWUFBTzN5RSxJQUFQO0FBQ0Q7O0FBRUQsWUFBU3duRCxXQUFULENBQXFCM2xELE9BQXJCLEVBQThCO0FBQzVCQSxhQUFReXVFLFVBQVIsSUFBc0J0d0UsSUFBdEI7QUFDQTZCLGFBQVEwdUUsTUFBUixHQUFpQnYxRSxTQUFqQjtBQUNBNkcsYUFBUTAzRCxPQUFSLEdBQWtCditELFNBQWxCO0FBQ0E2RyxhQUFRb3dFLFlBQVIsR0FBdUIsRUFBdkI7QUFDRDs7QUFFRCxZQUFTVyxZQUFULENBQXNCakMsV0FBdEIsRUFBbUNrQyxLQUFuQyxFQUEwQztBQUN4QyxVQUFLQyxvQkFBTCxHQUE0Qm5DLFdBQTVCO0FBQ0EsVUFBSzl1RSxPQUFMLEdBQWUsSUFBSTh1RSxXQUFKLENBQWdCMzJFLElBQWhCLENBQWY7O0FBRUEsU0FBSSxDQUFDLEtBQUs2SCxPQUFMLENBQWF5dUUsVUFBYixDQUFMLEVBQStCO0FBQzdCOW9CLG1CQUFZLEtBQUszbEQsT0FBakI7QUFDRDs7QUFFRCxTQUFJOEYsUUFBUWtyRSxLQUFSLENBQUosRUFBb0I7QUFDbEIsWUFBS3gzRSxNQUFMLEdBQWN3M0UsTUFBTXgzRSxNQUFwQjtBQUNBLFlBQUswM0UsVUFBTCxHQUFrQkYsTUFBTXgzRSxNQUF4Qjs7QUFFQSxZQUFLaytELE9BQUwsR0FBZSxJQUFJL3lELEtBQUosQ0FBVSxLQUFLbkwsTUFBZixDQUFmOztBQUVBLFdBQUksS0FBS0EsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQnFxRCxpQkFBUSxLQUFLN2pELE9BQWIsRUFBc0IsS0FBSzAzRCxPQUEzQjtBQUNELFFBRkQsTUFFTztBQUNMLGNBQUtsK0QsTUFBTCxHQUFjLEtBQUtBLE1BQUwsSUFBZSxDQUE3QjtBQUNBLGNBQUsyM0UsVUFBTCxDQUFnQkgsS0FBaEI7QUFDQSxhQUFJLEtBQUtFLFVBQUwsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekJydEIsbUJBQVEsS0FBSzdqRCxPQUFiLEVBQXNCLEtBQUswM0QsT0FBM0I7QUFDRDtBQUNGO0FBQ0YsTUFmRCxNQWVPO0FBQ0wzM0QsY0FBTyxLQUFLQyxPQUFaLEVBQXFCb3hFLGlCQUFyQjtBQUNEO0FBQ0Y7O0FBRUQsWUFBU0EsZUFBVCxHQUEyQjtBQUN6QixZQUFPLElBQUk3ekIsS0FBSixDQUFVLHlDQUFWLENBQVA7QUFDRDs7QUFFRHd6QixnQkFBYW40RSxTQUFiLENBQXVCdTRFLFVBQXZCLEdBQW9DLFVBQVVILEtBQVYsRUFBaUI7QUFDbkQsVUFBSyxJQUFJejNFLElBQUksQ0FBYixFQUFnQixLQUFLbTFFLE1BQUwsS0FBZ0JLLE9BQWhCLElBQTJCeDFFLElBQUl5M0UsTUFBTXgzRSxNQUFyRCxFQUE2REQsR0FBN0QsRUFBa0U7QUFDaEUsWUFBSzgzRSxVQUFMLENBQWdCTCxNQUFNejNFLENBQU4sQ0FBaEIsRUFBMEJBLENBQTFCO0FBQ0Q7QUFDRixJQUpEOztBQU1BdzNFLGdCQUFhbjRFLFNBQWIsQ0FBdUJ5NEUsVUFBdkIsR0FBb0MsVUFBVUMsS0FBVixFQUFpQi8zRSxDQUFqQixFQUFvQjtBQUN0RCxTQUFJdUssSUFBSSxLQUFLbXRFLG9CQUFiO0FBQ0EsU0FBSU0sYUFBYXp0RSxFQUFFakUsT0FBbkI7O0FBRUEsU0FBSTB4RSxlQUFlMUMsU0FBbkIsRUFBOEI7QUFDNUIsV0FBSTJDLFFBQVFsQyxRQUFRZ0MsS0FBUixDQUFaOztBQUVBLFdBQUlFLFVBQVV6eUUsSUFBVixJQUFrQnV5RSxNQUFNNUMsTUFBTixLQUFpQkssT0FBdkMsRUFBZ0Q7QUFDOUMsY0FBSzBDLFVBQUwsQ0FBZ0JILE1BQU01QyxNQUF0QixFQUE4Qm4xRSxDQUE5QixFQUFpQyszRSxNQUFNNVosT0FBdkM7QUFDRCxRQUZELE1BRU8sSUFBSSxPQUFPOFosS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUN0QyxjQUFLTixVQUFMO0FBQ0EsY0FBS3haLE9BQUwsQ0FBYW4rRCxDQUFiLElBQWtCKzNFLEtBQWxCO0FBQ0QsUUFITSxNQUdBLElBQUl4dEUsTUFBTTR0RSxTQUFWLEVBQXFCO0FBQzFCLGFBQUkxeEUsVUFBVSxJQUFJOEQsQ0FBSixDQUFNM0wsSUFBTixDQUFkO0FBQ0E0M0UsNkJBQW9CL3ZFLE9BQXBCLEVBQTZCc3hFLEtBQTdCLEVBQW9DRSxLQUFwQztBQUNBLGNBQUtHLGFBQUwsQ0FBbUIzeEUsT0FBbkIsRUFBNEJ6RyxDQUE1QjtBQUNELFFBSk0sTUFJQTtBQUNMLGNBQUtvNEUsYUFBTCxDQUFtQixJQUFJN3RFLENBQUosQ0FBTSxVQUFVeXRFLFVBQVYsRUFBc0I7QUFDN0Msa0JBQU9BLFdBQVdELEtBQVgsQ0FBUDtBQUNELFVBRmtCLENBQW5CLEVBRUkvM0UsQ0FGSjtBQUdEO0FBQ0YsTUFqQkQsTUFpQk87QUFDTCxZQUFLbzRFLGFBQUwsQ0FBbUJKLFdBQVdELEtBQVgsQ0FBbkIsRUFBc0MvM0UsQ0FBdEM7QUFDRDtBQUNGLElBeEJEOztBQTBCQXczRSxnQkFBYW40RSxTQUFiLENBQXVCNjRFLFVBQXZCLEdBQW9DLFVBQVVoNUIsS0FBVixFQUFpQmwvQyxDQUFqQixFQUFvQjJILEtBQXBCLEVBQTJCO0FBQzdELFNBQUlsQixVQUFVLEtBQUtBLE9BQW5COztBQUVBLFNBQUlBLFFBQVEwdUUsTUFBUixLQUFtQkssT0FBdkIsRUFBZ0M7QUFDOUIsWUFBS21DLFVBQUw7O0FBRUEsV0FBSXo0QixVQUFVdzJCLFFBQWQsRUFBd0I7QUFDdEJsdkUsZ0JBQU9DLE9BQVAsRUFBZ0JrQixLQUFoQjtBQUNELFFBRkQsTUFFTztBQUNMLGNBQUt3MkQsT0FBTCxDQUFhbitELENBQWIsSUFBa0IySCxLQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBSSxLQUFLZ3dFLFVBQUwsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekJydEIsZUFBUTdqRCxPQUFSLEVBQWlCLEtBQUswM0QsT0FBdEI7QUFDRDtBQUNGLElBaEJEOztBQWtCQXFaLGdCQUFhbjRFLFNBQWIsQ0FBdUIrNEUsYUFBdkIsR0FBdUMsVUFBVTN4RSxPQUFWLEVBQW1CekcsQ0FBbkIsRUFBc0I7QUFDM0QsU0FBSXE0RSxhQUFhLElBQWpCOztBQUVBaEQsZUFBVTV1RSxPQUFWLEVBQW1CN0csU0FBbkIsRUFBOEIsVUFBVStILEtBQVYsRUFBaUI7QUFDN0MsY0FBTzB3RSxXQUFXSCxVQUFYLENBQXNCekMsU0FBdEIsRUFBaUN6MUUsQ0FBakMsRUFBb0MySCxLQUFwQyxDQUFQO0FBQ0QsTUFGRCxFQUVHLFVBQVVxYSxNQUFWLEVBQWtCO0FBQ25CLGNBQU9xMkQsV0FBV0gsVUFBWCxDQUFzQnhDLFFBQXRCLEVBQWdDMTFFLENBQWhDLEVBQW1DZ2lCLE1BQW5DLENBQVA7QUFDRCxNQUpEO0FBS0QsSUFSRDs7QUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQ0EsWUFBU3MyRCxLQUFULENBQWVDLE9BQWYsRUFBd0I7QUFDdEIsWUFBTyxJQUFJZixZQUFKLENBQWlCLElBQWpCLEVBQXVCZSxPQUF2QixFQUFnQzl4RSxPQUF2QztBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlFQSxZQUFTK3hFLE1BQVQsQ0FBZ0JELE9BQWhCLEVBQXlCO0FBQ3ZCO0FBQ0EsU0FBSWhELGNBQWMsSUFBbEI7O0FBRUEsU0FBSSxDQUFDaHBFLFFBQVFnc0UsT0FBUixDQUFMLEVBQXVCO0FBQ3JCLGNBQU8sSUFBSWhELFdBQUosQ0FBZ0IsVUFBVWpyRSxDQUFWLEVBQWE5RCxNQUFiLEVBQXFCO0FBQzFDLGdCQUFPQSxPQUFPLElBQUk5RCxTQUFKLENBQWMsaUNBQWQsQ0FBUCxDQUFQO0FBQ0QsUUFGTSxDQUFQO0FBR0QsTUFKRCxNQUlPO0FBQ0wsY0FBTyxJQUFJNnlFLFdBQUosQ0FBZ0IsVUFBVWp2RSxPQUFWLEVBQW1CRSxNQUFuQixFQUEyQjtBQUNoRCxhQUFJdkcsU0FBU3M0RSxRQUFRdDRFLE1BQXJCO0FBQ0EsY0FBSyxJQUFJRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLE1BQXBCLEVBQTRCRCxHQUE1QixFQUFpQztBQUMvQnUxRSx1QkFBWWp2RSxPQUFaLENBQW9CaXlFLFFBQVF2NEUsQ0FBUixDQUFwQixFQUFnQ3dGLElBQWhDLENBQXFDYyxPQUFyQyxFQUE4Q0UsTUFBOUM7QUFDRDtBQUNGLFFBTE0sQ0FBUDtBQU1EO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0EsWUFBU2l5RSxRQUFULENBQWtCejJELE1BQWxCLEVBQTBCO0FBQ3hCO0FBQ0EsU0FBSXV6RCxjQUFjLElBQWxCO0FBQ0EsU0FBSTl1RSxVQUFVLElBQUk4dUUsV0FBSixDQUFnQjMyRSxJQUFoQixDQUFkO0FBQ0E0SCxZQUFPQyxPQUFQLEVBQWdCdWIsTUFBaEI7QUFDQSxZQUFPdmIsT0FBUDtBQUNEOztBQUVELFlBQVNpeUUsYUFBVCxHQUF5QjtBQUN2QixXQUFNLElBQUloMkUsU0FBSixDQUFjLG9GQUFkLENBQU47QUFDRDs7QUFFRCxZQUFTaTJFLFFBQVQsR0FBb0I7QUFDbEIsV0FBTSxJQUFJajJFLFNBQUosQ0FBYyx1SEFBZCxDQUFOO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1R0EsWUFBU3kxRSxTQUFULENBQW1CdnNCLFFBQW5CLEVBQTZCO0FBQzNCLFVBQUtzcEIsVUFBTCxJQUFtQnFDLFFBQW5CO0FBQ0EsVUFBS3BaLE9BQUwsR0FBZSxLQUFLZ1gsTUFBTCxHQUFjdjFFLFNBQTdCO0FBQ0EsVUFBS2kzRSxZQUFMLEdBQW9CLEVBQXBCOztBQUVBLFNBQUlqNEUsU0FBU2d0RCxRQUFiLEVBQXVCO0FBQ3JCLGNBQU9BLFFBQVAsS0FBb0IsVUFBcEIsSUFBa0M4c0IsZUFBbEM7QUFDQSx1QkFBZ0JQLFNBQWhCLEdBQTRCYixrQkFBa0IsSUFBbEIsRUFBd0IxckIsUUFBeEIsQ0FBNUIsR0FBZ0Urc0IsVUFBaEU7QUFDRDtBQUNGOztBQUVEUixhQUFVN2dDLEdBQVYsR0FBZ0JnaEMsS0FBaEI7QUFDQUgsYUFBVXRzQixJQUFWLEdBQWlCMnNCLE1BQWpCO0FBQ0FMLGFBQVU3eEUsT0FBVixHQUFvQmd2RSxTQUFwQjtBQUNBNkMsYUFBVTN4RSxNQUFWLEdBQW1CaXlFLFFBQW5CO0FBQ0FOLGFBQVVTLGFBQVYsR0FBMEJuRixZQUExQjtBQUNBMEUsYUFBVVUsUUFBVixHQUFxQmxGLE9BQXJCO0FBQ0F3RSxhQUFVVyxLQUFWLEdBQWtCdkYsSUFBbEI7O0FBRUE0RSxhQUFVOTRFLFNBQVYsR0FBc0I7QUFDcEJzUixrQkFBYXduRSxTQURPOztBQUdwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlNQTN5RSxXQUFNQSxJQXBNYzs7QUFzTXBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsY0FBUyxTQUFTdXpFLE1BQVQsQ0FBZ0IvRCxXQUFoQixFQUE2QjtBQUNwQyxjQUFPLEtBQUt4dkUsSUFBTCxDQUFVLElBQVYsRUFBZ0J3dkUsV0FBaEIsQ0FBUDtBQUNEO0FBbk9tQixJQUF0Qjs7QUFzT0E7QUFDQSxZQUFTZ0UsVUFBVCxHQUFzQjtBQUNsQixTQUFJMTFFLFFBQVExRCxTQUFaOztBQUVBLFNBQUksT0FBT3NTLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDL0I1TyxlQUFRNE8sTUFBUjtBQUNILE1BRkQsTUFFTyxJQUFJLE9BQU94UixJQUFQLEtBQWdCLFdBQXBCLEVBQWlDO0FBQ3BDNEMsZUFBUTVDLElBQVI7QUFDSCxNQUZNLE1BRUE7QUFDSCxXQUFJO0FBQ0E0QyxpQkFBUWxFLFNBQVMsYUFBVCxHQUFSO0FBQ0gsUUFGRCxDQUVFLE9BQU9HLENBQVAsRUFBVTtBQUNSLGVBQU0sSUFBSXlrRCxLQUFKLENBQVUsMEVBQVYsQ0FBTjtBQUNIO0FBQ0o7O0FBRUQsU0FBSWkxQixJQUFJMzFFLE1BQU0yUCxPQUFkOztBQUVBLFNBQUlnbUUsQ0FBSixFQUFPO0FBQ0gsV0FBSUMsa0JBQWtCLElBQXRCO0FBQ0EsV0FBSTtBQUNBQSwyQkFBa0J0eUUsT0FBT3ZILFNBQVAsQ0FBaUJ5SSxRQUFqQixDQUEwQnhJLElBQTFCLENBQStCMjVFLEVBQUUzeUUsT0FBRixFQUEvQixDQUFsQjtBQUNILFFBRkQsQ0FFRSxPQUFPL0csQ0FBUCxFQUFVO0FBQ1I7QUFDSDs7QUFFRCxXQUFJMjVFLG9CQUFvQixrQkFBcEIsSUFBMEMsQ0FBQ0QsRUFBRUUsSUFBakQsRUFBdUQ7QUFDbkQ7QUFDSDtBQUNKOztBQUVENzFFLFdBQU0yUCxPQUFOLEdBQWdCa2xFLFNBQWhCO0FBQ0g7O0FBRUQ7QUFDQUEsYUFBVWlCLFFBQVYsR0FBcUJKLFVBQXJCO0FBQ0FiLGFBQVVsbEUsT0FBVixHQUFvQmtsRSxTQUFwQjs7QUFFQSxVQUFPQSxTQUFQO0FBRUMsRUExbkNBLENBQUQ7O0FBNG5DQSxxQzs7Ozs7OztBQ3BvQ0EsZ0I7Ozs7OztBQ0FBOztBQUVBMTVFLFFBQU9DLE9BQVAsR0FBaUJreUUsYUFBakI7O0FBRUEsS0FBSXlJLFNBQVMsbUJBQUE5bUIsQ0FBUSxFQUFSLENBQWI7O0FBRUEsVUFBU3FlLGFBQVQsQ0FBdUJ2ckUsR0FBdkIsRUFBNEIwakUsT0FBNUIsRUFBcUM7QUFDbkMsT0FBSSxLQUFLNzVELElBQUwsQ0FBVTdKLEdBQVYsQ0FBSixFQUFvQjtBQUNsQkEsWUFBTyxHQUFQO0FBQ0QsSUFGRCxNQUVPO0FBQ0xBLFlBQU8sR0FBUDtBQUNEOztBQUVELFVBQU9BLE1BQU1nMEUsT0FBT3RRLE9BQVAsQ0FBYjtBQUNELEU7Ozs7OztBQ2REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFFQSxLQUFJdVEscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBU2h5RSxDQUFULEVBQVk7QUFDbkMsa0JBQWVBLENBQWYseUNBQWVBLENBQWY7QUFDRSxVQUFLLFFBQUw7QUFDRSxjQUFPQSxDQUFQOztBQUVGLFVBQUssU0FBTDtBQUNFLGNBQU9BLElBQUksTUFBSixHQUFhLE9BQXBCOztBQUVGLFVBQUssUUFBTDtBQUNFLGNBQU9pQixTQUFTakIsQ0FBVCxJQUFjQSxDQUFkLEdBQWtCLEVBQXpCOztBQUVGO0FBQ0UsY0FBTyxFQUFQO0FBWEo7QUFhRCxFQWREOztBQWdCQTdJLFFBQU9DLE9BQVAsR0FBaUIsVUFBU00sR0FBVCxFQUFjdTZFLEdBQWQsRUFBbUJDLEVBQW5CLEVBQXVCajVFLElBQXZCLEVBQTZCO0FBQzVDZzVFLFNBQU1BLE9BQU8sR0FBYjtBQUNBQyxRQUFLQSxNQUFNLEdBQVg7QUFDQSxPQUFJeDZFLFFBQVEsSUFBWixFQUFrQjtBQUNoQkEsV0FBTVksU0FBTjtBQUNEOztBQUVELE9BQUksUUFBT1osR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFlBQU9nSyxJQUFJeXdFLFdBQVd6NkUsR0FBWCxDQUFKLEVBQXFCLFVBQVMwakUsQ0FBVCxFQUFZO0FBQ3RDLFdBQUlnWCxLQUFLcDRFLG1CQUFtQmc0RSxtQkFBbUI1VyxDQUFuQixDQUFuQixJQUE0QzhXLEVBQXJEO0FBQ0EsV0FBSWp0RSxRQUFRdk4sSUFBSTBqRSxDQUFKLENBQVIsQ0FBSixFQUFxQjtBQUNuQixnQkFBTzE1RCxJQUFJaEssSUFBSTBqRSxDQUFKLENBQUosRUFBWSxVQUFTcDdELENBQVQsRUFBWTtBQUM3QixrQkFBT295RSxLQUFLcDRFLG1CQUFtQmc0RSxtQkFBbUJoeUUsQ0FBbkIsQ0FBbkIsQ0FBWjtBQUNELFVBRk0sRUFFSjRFLElBRkksQ0FFQ3F0RSxHQUZELENBQVA7QUFHRCxRQUpELE1BSU87QUFDTCxnQkFBT0csS0FBS3A0RSxtQkFBbUJnNEUsbUJBQW1CdDZFLElBQUkwakUsQ0FBSixDQUFuQixDQUFuQixDQUFaO0FBQ0Q7QUFDRixNQVRNLEVBU0p4MkQsSUFUSSxDQVNDcXRFLEdBVEQsQ0FBUDtBQVdEOztBQUVELE9BQUksQ0FBQ2g1RSxJQUFMLEVBQVcsT0FBTyxFQUFQO0FBQ1gsVUFBT2UsbUJBQW1CZzRFLG1CQUFtQi80RSxJQUFuQixDQUFuQixJQUErQ2k1RSxFQUEvQyxHQUNBbDRFLG1CQUFtQmc0RSxtQkFBbUJ0NkUsR0FBbkIsQ0FBbkIsQ0FEUDtBQUVELEVBeEJEOztBQTBCQSxLQUFJdU4sVUFBVW5CLE1BQU1tQixPQUFOLElBQWlCLFVBQVVvdEUsRUFBVixFQUFjO0FBQzNDLFVBQU8veUUsT0FBT3ZILFNBQVAsQ0FBaUJ5SSxRQUFqQixDQUEwQnhJLElBQTFCLENBQStCcTZFLEVBQS9CLE1BQXVDLGdCQUE5QztBQUNELEVBRkQ7O0FBSUEsVUFBUzN3RSxHQUFULENBQWMyd0UsRUFBZCxFQUFrQnZvQyxDQUFsQixFQUFxQjtBQUNuQixPQUFJdW9DLEdBQUczd0UsR0FBUCxFQUFZLE9BQU8yd0UsR0FBRzN3RSxHQUFILENBQU9vb0MsQ0FBUCxDQUFQO0FBQ1osT0FBSXRzQyxNQUFNLEVBQVY7QUFDQSxRQUFLLElBQUk5RSxJQUFJLENBQWIsRUFBZ0JBLElBQUkyNUUsR0FBRzE1RSxNQUF2QixFQUErQkQsR0FBL0IsRUFBb0M7QUFDbEM4RSxTQUFJOEwsSUFBSixDQUFTd2dDLEVBQUV1b0MsR0FBRzM1RSxDQUFILENBQUYsRUFBU0EsQ0FBVCxDQUFUO0FBQ0Q7QUFDRCxVQUFPOEUsR0FBUDtBQUNEOztBQUVELEtBQUkyMEUsYUFBYTd5RSxPQUFPQyxJQUFQLElBQWUsVUFBVTdILEdBQVYsRUFBZTtBQUM3QyxPQUFJOEYsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJK0UsR0FBVCxJQUFnQjdLLEdBQWhCLEVBQXFCO0FBQ25CLFNBQUk0SCxPQUFPdkgsU0FBUCxDQUFpQnNLLGNBQWpCLENBQWdDckssSUFBaEMsQ0FBcUNOLEdBQXJDLEVBQTBDNkssR0FBMUMsQ0FBSixFQUFvRC9FLElBQUk4TCxJQUFKLENBQVMvRyxHQUFUO0FBQ3JEO0FBQ0QsVUFBTy9FLEdBQVA7QUFDRCxFQU5ELEM7Ozs7OztBQzlFQTs7QUFFQXJHLFFBQU9DLE9BQVAsR0FBaUJteUUsWUFBakI7O0FBRUEsS0FBSTN1QixTQUFTLG1CQUFBcVEsQ0FBUSxFQUFSLENBQWI7O0FBRUEsS0FBSXFuQixlQUFlLENBQW5COztBQUVBLFVBQVMvSSxZQUFULENBQXNCeHJFLEdBQXRCLEVBQTJCd00sSUFBM0IsRUFBaUNnQyxFQUFqQyxFQUFxQztBQUNuQyxPQUFJaEMsS0FBSzNTLE1BQUwsS0FBZ0IsS0FBcEIsRUFBMkI7QUFDekIyVSxRQUFHLElBQUltd0MsS0FBSixDQUFVLFlBQVlueUMsS0FBSzNTLE1BQWpCLEdBQTBCLEdBQTFCLEdBQWdDbUcsR0FBaEMsR0FBc0MsNkJBQWhELENBQUg7QUFDQTtBQUNEOztBQUVEd00sUUFBSzFSLEtBQUwsQ0FBVyxjQUFYOztBQUVBLE9BQUkwNUUsV0FBVyxLQUFmO0FBQ0EsT0FBSWhJLFdBQVcsS0FBZjs7QUFFQStILG1CQUFnQixDQUFoQjtBQUNBLE9BQUl4ekIsT0FBT2hsRCxTQUFTMDRFLG9CQUFULENBQThCLE1BQTlCLEVBQXNDLENBQXRDLENBQVg7QUFDQSxPQUFJbG1CLFNBQVN4eUQsU0FBU3VyQixhQUFULENBQXVCLFFBQXZCLENBQWI7QUFDQSxPQUFJb3RELFNBQVMsa0JBQWtCSCxZQUEvQjtBQUNBLE9BQUludEIsT0FBTyxLQUFYOztBQUVBeHJELFVBQU84NEUsTUFBUCxJQUFpQixVQUFTeDBFLElBQVQsRUFBZTtBQUM5QnkwRTs7QUFFQSxTQUFJbkksUUFBSixFQUFjO0FBQ1poZ0UsWUFBSzFSLEtBQUwsQ0FBVyw4QkFBWDtBQUNBO0FBQ0Q7O0FBRUQwNUUsZ0JBQVcsSUFBWDs7QUFFQUk7O0FBRUFwbUUsUUFBRyxJQUFILEVBQVM7QUFDUHM5QixhQUFNNXJDLElBREMsQ0FDRzs7OztBQURILE1BQVQ7QUFNRCxJQWxCRDs7QUFvQkE7QUFDQUYsVUFBTyxlQUFlMDBFLE1BQXRCOztBQUVBO0FBQ0EsT0FBSWxvRSxLQUFLMjNELFFBQUwsSUFBaUIzM0QsS0FBSzIzRCxRQUFMLENBQWM5VSxNQUFuQyxFQUEyQztBQUN6Q3J2RCxZQUFPLE1BQU13TSxLQUFLMjNELFFBQUwsQ0FBYzlVLE1BQTNCO0FBQ0Q7O0FBRUQsT0FBSXdsQixZQUFZOW1FLFdBQVcrTyxPQUFYLEVBQW9CdFEsS0FBSzAxRCxRQUFMLENBQWM0RixRQUFsQyxDQUFoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQXZaLFVBQU9DLGtCQUFQLEdBQTRCc21CLGdCQUE1QjtBQUNBdm1CLFVBQU9xZSxNQUFQLEdBQWdCelUsT0FBaEI7QUFDQTVKLFVBQU81RyxPQUFQLEdBQWlCbG5ELEtBQWpCOztBQUVBOHRELFVBQU9wRixLQUFQLEdBQWUsSUFBZjtBQUNBb0YsVUFBT3p0RCxLQUFQLEdBQWUsSUFBZjtBQUNBeXRELFVBQU8vOEMsR0FBUCxHQUFheFIsR0FBYjtBQUNBK2dELFFBQUsxdEIsV0FBTCxDQUFpQms3QixNQUFqQjs7QUFFQSxZQUFTNEosT0FBVCxHQUFtQjtBQUNqQjNyRCxVQUFLMVIsS0FBTCxDQUFXLGdCQUFYOztBQUVBLFNBQUlzc0QsUUFBUW9sQixRQUFaLEVBQXNCO0FBQ3BCO0FBQ0Q7O0FBRURwbEIsWUFBTyxJQUFQOztBQUVBO0FBQ0EsU0FBSSxDQUFDb3RCLFFBQUwsRUFBZTtBQUNiaG9FLFlBQUsxUixLQUFMLENBQVcsMERBQVg7QUFDQTg1RTtBQUNBcG1FLFVBQUcsSUFBSXF1QyxPQUFPcWdCLGVBQVgsRUFBSDtBQUNEO0FBQ0Y7O0FBRUQsWUFBUzRYLGdCQUFULEdBQTRCO0FBQzFCLFNBQUksS0FBSzFILFVBQUwsS0FBb0IsUUFBcEIsSUFBZ0MsS0FBS0EsVUFBTCxLQUFvQixVQUF4RCxFQUFvRTtBQUNsRWpWO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTeWMsS0FBVCxHQUFpQjtBQUNmLzFCLGtCQUFhZzJCLFNBQWI7QUFDQXRtQixZQUFPcWUsTUFBUCxHQUFnQixJQUFoQjtBQUNBcmUsWUFBT0Msa0JBQVAsR0FBNEIsSUFBNUI7QUFDQUQsWUFBTzVHLE9BQVAsR0FBaUIsSUFBakI7QUFDQTVHLFVBQUszdEIsV0FBTCxDQUFpQm03QixNQUFqQjtBQUNEOztBQUVELFlBQVNvbUIsYUFBVCxHQUF5QjtBQUN2QixTQUFJO0FBQ0YsY0FBTy80RSxPQUFPODRFLE1BQVAsQ0FBUDtBQUNBLGNBQU85NEUsT0FBTzg0RSxTQUFTLFNBQWhCLENBQVA7QUFDRCxNQUhELENBR0UsT0FBT3g2RSxDQUFQLEVBQVU7QUFDVjBCLGNBQU84NEUsTUFBUCxJQUFpQjk0RSxPQUFPODRFLFNBQVMsU0FBaEIsSUFBNkJuNkUsU0FBOUM7QUFDRDtBQUNGOztBQUVELFlBQVN1aUIsT0FBVCxHQUFtQjtBQUNqQnRRLFVBQUsxUixLQUFMLENBQVcsdUJBQVg7QUFDQTB4RSxnQkFBVyxJQUFYO0FBQ0FvSTtBQUNBcG1FLFFBQUcsSUFBSXF1QyxPQUFPbWdCLGNBQVgsRUFBSDtBQUNEOztBQUVELFlBQVN2OEQsS0FBVCxHQUFpQjtBQUNmK0wsVUFBSzFSLEtBQUwsQ0FBVyxxQkFBWDs7QUFFQSxTQUFJc3NELFFBQVFvbEIsUUFBWixFQUFzQjtBQUNwQjtBQUNEOztBQUVEb0k7QUFDQXBtRSxRQUFHLElBQUlxdUMsT0FBT3NnQixnQkFBWCxFQUFIO0FBQ0Q7QUFDRixFOzs7Ozs7Ozs7O0FDNUhEL2pFLFFBQU9DLE9BQVAsR0FBaUIwN0Usa0JBQWpCOztBQUVBLEtBQUl4WixvQkFBb0IsbUJBQUFyTyxDQUFRLEVBQVIsQ0FBeEI7O0FBRUEsVUFBUzZuQixrQkFBVCxDQUE0QnZaLGFBQTVCLEVBQTJDO0FBQ3pDLFVBQU8sU0FBU2lRLE1BQVQsQ0FBZ0JodEUsS0FBaEIsRUFBdUJDLE1BQXZCLEVBQStCOE4sSUFBL0IsRUFBcUM7QUFDMUMsU0FBSWsvRCxZQUFZLG1CQUFBeGUsQ0FBUSxFQUFSLENBQWhCOztBQUVBMWdELFlBQU9BLFFBQVFrL0QsVUFBVWwvRCxJQUFWLENBQVIsSUFBMkIsRUFBbEM7QUFDQUEsVUFBS3MxRCxLQUFMLEdBQWF0MUQsS0FBS3MxRCxLQUFMLElBQWMsQ0FDekIsd0JBRHlCLEVBRXpCLHlCQUZ5QixFQUd6Qix5QkFIeUIsRUFJekIseUJBSnlCLENBQTNCOztBQU9BO0FBQ0EsU0FBSTFuRSxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLFFBQU82RCxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQTNDLElBQXVEQSxVQUFVbEUsU0FBckUsRUFBZ0Y7QUFDOUVrRSxlQUFRLEVBQVI7QUFDQUMsZ0JBQVMsRUFBVDtBQUNBOE4sWUFBS3ExRCxzQkFBTCxHQUE4QixJQUE5QjtBQUNEOztBQUVELFNBQUlySyxTQUFTZ0UsY0FBYy84RCxLQUFkLEVBQXFCQyxNQUFyQixFQUE2QjhOLElBQTdCLENBQWI7QUFDQSxTQUFJN04sUUFBUTY0RCxPQUFPckksU0FBUCxDQUFpQixRQUFqQixDQUFaO0FBQ0F4d0QsV0FBTTR3RCxNQUFOLEdBQWVnTSxrQkFBa0IsT0FBbEIsRUFBMkIsaUJBQTNCLENBQWY7QUFDQTU4RCxXQUFNMHhELFNBQU4sR0FBa0IsVUFBU0QsUUFBVCxFQUFtQjVtQyxRQUFuQixFQUE2QjtBQUM3QyxjQUFPLEtBQUtpdEMsRUFBTCxDQUFRekQsWUFBUixDQUFxQjtBQUMxQm41RCxpQkFBUSxLQURrQjtBQUUxQm1HLGNBQUssZUFBZS9ELG1CQUFtQm0wRCxRQUFuQixDQUZNO0FBRzFCNkMsbUJBQVUsTUFIZ0I7QUFJMUJ6cEMsbUJBQVVBO0FBSmdCLFFBQXJCLENBQVA7QUFNRCxNQVBEO0FBUUEsWUFBTzdxQixLQUFQO0FBQ0QsSUE5QkQ7QUErQkQsRTs7Ozs7O0FDcENEOztBQUVBdkYsUUFBT0MsT0FBUCxHQUFpQnN5RSxtQkFBakI7O0FBRUEsVUFBU0EsbUJBQVQsR0FBK0I7QUFDN0IsT0FBSTFjLFdBQVdyekQsT0FBT0csUUFBUCxDQUFnQkssUUFBaEIsQ0FBeUI2eUQsUUFBeEM7O0FBRUE7QUFDQSxPQUFJQSxhQUFhLE9BQWIsSUFBd0JBLGFBQWEsUUFBekMsRUFBbUQ7QUFDakRBLGdCQUFXLE9BQVg7QUFDRDs7QUFFRCxVQUFPQSxRQUFQO0FBQ0QsRTs7Ozs7O0FDYkQ7O0FBRUE3MUQsUUFBT0MsT0FBUCxHQUFpQixRQUFqQixDIiwiZmlsZSI6ImV2ZW50LXBhZ2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA5ZTE4N2FiMmViOTYyNmM4ZjNkYyIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJ1xuaW1wb3J0IFEgZnJvbSAncSdcblxuaW1wb3J0IEV4cGxhYWluU2VhcmNoIGZyb20gJy4uL3BsdWdpbnMvZXhwbGFhaW4tc2VhcmNoLmpzJztcblxubG9nLnNldExldmVsKCdkZWJ1ZycpXG5cbmNvbnN0IFVzZXJJRHMgPSB7XG4gIGxpdmU6IHtcbiAgICBKZXJlbXk6ICcxNjI3ODg4ODAwNTY5MzA5JyxcbiAgICBNYXR0OiAnMTQ1NTcwNzI0Nzg1MDA2OScsXG4gICAgQ2Fyb2w6ICcxNDU5MDY4OTkwODc4MDc3JyxcbiAgICBIYXJyaWV0OiAnMTQ3ODc3NjIzMjE2MTQ2OCcsXG4gICAgSm9ubnk6ICcxNTEzNTU0NDM4NzI5NzUzJyxcbiAgfSxcbiAgc3RhZ2luZzoge1xuICAgIEplcmVteTogJzEzNjY3NDYzNzAwODk1MjcnLFxuICAgIE1hdHQ6ICcxNTI4MTM0OTkwNTYzMjAyJyxcbiAgfSxcbiAgbG9jYWw6IHtcbiAgICBKZXJlbXk6ICcxMzAwMTIwODgwMTEwNzczJyxcbiAgICBNYXR0OiAnMTQyODQxOTEwMDUyODQzOCcsXG4gIH0sXG4gIGRyaXZlOiB7XG4gICAgSmVyZW15OiAnMTA0MzgwMTEwMjc5NjU4OTIwMTc1JyxcbiAgICBBQ01FOiAnMTAxMTE4Mzg3MzAxMjg2MjMyMjIyJ1xuICB9XG59XG5cbmNvbnN0IFVzZXJJRCA9IFVzZXJJRHMubGl2ZS5BQ01FXG52YXIgUGFnZVJlc3VsdHMgPSB7fVxudmFyIFVzZXJDYXJkcyA9IFtdXG52YXIgTGFzdFJlZnJlc2ggPSAwXG5cbmNvbnN0IGFsZ29saWFQYXJhbXMgPSB7IC8vIE5lZWQgdG8gc2VuZCB0aGVzZSB0byBhcHAudnVlIHRvIGF2b2lkIGR1cGxpY2F0aW9uIVxuICBhcHBJRDogJ0kyVktNTk5BWEknLFxuICBhcGlLZXk6ICcyYjg0MDZmODRjZDRjYzUwN2RhMTczMDMyYzQ2ZWU3YicsXG4gIGluZGV4OiAnRm9yZ2V0TWVOb3RfQ29udGV4dF9UZXN0J1xufVxuVnVlLnVzZShFeHBsYWFpblNlYXJjaCwgYWxnb2xpYVBhcmFtcylcblxuY2hyb21lLmJyb3dzZXJBY3Rpb24ub25DbGlja2VkLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHRhYikge1xuICBjaHJvbWUudGFicy5xdWVyeSh7YWN0aXZlOiB0cnVlLCBjdXJyZW50V2luZG93OiB0cnVlfSwgZnVuY3Rpb24odGFicyl7XG4gICAgY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UodGFic1swXS5pZCwge2FjdGlvbjogJ3RvZ2dsZURyYXdlcid9LCBmdW5jdGlvbihyZXMpIHtcbiAgICAgIGxvZy5pbmZvKHJlcylcbiAgICB9KVxuICB9KVxufSk7XG5cbmNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmdW5jdGlvbihyZXF1ZXN0LCBzZW5kZXIsIHNlbmRSZXNwb25zZSkge1xuICB0cnkge1xuICAgIGxvZy5kZWJ1Zygoc2VuZGVyLnRhYiA/IFwiRnJvbSBhIGNvbnRlbnQgc2NyaXB0OiBcIiArIHNlbmRlci50YWIudXJsIDogXCJGcm9tIHRoZSBleHRlbnNpb25cIiksIHJlcXVlc3QpXG5cbiAgICBpZihyZXF1ZXN0LmFjdGlvbiA9PSBcImdldFBhZ2VSZXN1bHRzXCIpe1xuICAgICAgZ2V0Q3VycmVudFBhZ2VSZXN1bHRzKHJlcXVlc3QuZGF0YSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBsb2cuZGVidWcocmVzKVxuICAgICAgICBzZW5kUmVzcG9uc2UocmVzKVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdC5hY3Rpb24gPT0gXCJjaGVja1BhZ2VcIikge1xuICAgICAgbG9nLnRyYWNlKHJlcXVlc3QuZGF0YSk7XG4gICAgICBjaGVja1JlZnJlc2goKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBFeHBsYWFpblNlYXJjaC5nZXRQYWdlUmVzdWx0cyhVc2VySUQsIHJlcXVlc3QuZGF0YSwgVXNlckNhcmRzKVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgYWRkVG9QYWdlUmVzdWx0cyhzZW5kZXIudGFiLmlkLCByZXMpXG4gICAgICAgIFBhZ2VSZXN1bHRzID0gcmVzO1xuICAgICAgICBzZW5kUmVzcG9uc2UocmVzKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbG9nLmVycm9yKGUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmKHJlcXVlc3QuYWN0aW9uID09IFwiZ2V0VXNlclwiKXtcbiAgICAgIHNlbmRSZXNwb25zZShVc2VySUQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmKHJlcXVlc3QuYWN0aW9uID09IFwicmVmcmVzaENhcmRzXCIpe1xuICAgICAgZ2V0QWxsVXNlckNhcmRzKClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZihyZXF1ZXN0LmV2ZW50ID09IFwicG9wdXBPcGVuZWRcIil7XG4gICAgICBjaHJvbWUudGFicy5xdWVyeSh7YWN0aXZlOiB0cnVlLCBjdXJyZW50V2luZG93OiB0cnVlfSwgZnVuY3Rpb24odGFicyl7XG4gICAgICAgIGNocm9tZS50YWJzLnNlbmRNZXNzYWdlKHRhYnNbMF0uaWQsIHtldmVudDogJ3BvcHVwT3BlbmVkJ30sIGZ1bmN0aW9uKHJlc3BvbnNlKSB7fSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7XG4gICAgbG9nLmVycm9yKGUpXG4gIH1cbn0pXG5cbmNvbnN0IGdldEN1cnJlbnRQYWdlUmVzdWx0cyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICB2YXIgdGFiSUQ7XG4gIGxvZy5kZWJ1ZygxKVxuICBjaGVja1JlZnJlc2goKVxuICAudGhlbihnZXRDdXJyZW50VGFiKVxuICAudGhlbihmdW5jdGlvbih0YWIpIHtcbiAgICBsb2cuZGVidWcodGFiLmlkKVxuICAgIHRhYklEID0gdGFiLmlkXG4gICAgbG9nLmRlYnVnKFBhZ2VSZXN1bHRzKVxuICAgIGlmIChQYWdlUmVzdWx0c1t0YWJJRF0pIHtcbiAgICAgIGQucmVzb2x2ZShQYWdlUmVzdWx0c1t0YWJJRF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZGF0YSkgZGF0YSA9IHt0YWJJRDogdGFiSUR9XG4gICAgICBsb2cuZGVidWcoZGF0YSlcbiAgICAgIGdldFBhZ2VEYXRhKGRhdGEpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgbG9nLmRlYnVnKHJlcylcbiAgICAgICAgcmV0dXJuIEV4cGxhYWluU2VhcmNoLmdldFBhZ2VSZXN1bHRzKFVzZXJJRCwgcmVzLCBVc2VyQ2FyZHMpXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBsb2cuZGVidWcocmVzKVxuICAgICAgICBhZGRUb1BhZ2VSZXN1bHRzKHRhYklELCByZXMpXG4gICAgICAgIGQucmVzb2x2ZShyZXMpXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGQucmVqZWN0KGUpXG4gICAgICB9KVxuICAgIH1cbiAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgIGQucmVqZWN0KGUpXG4gIH0pXG4gIHJldHVybiBkLnByb21pc2Vcbn1cblxuY29uc3QgZ2V0Q3VycmVudFRhYiA9IGZ1bmN0aW9uKCkge1xuICAvLyBOZWVkIGVycm9yIGNhdGNoaW5nIGhlcmVcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBjaHJvbWUudGFicy5xdWVyeSh7YWN0aXZlOiB0cnVlLCBjdXJyZW50V2luZG93OiB0cnVlfSwgZnVuY3Rpb24odGFicyl7XG4gICAgZC5yZXNvbHZlKHRhYnNbMF0pXG4gIH0pXG4gIHJldHVybiBkLnByb21pc2Vcbn1cblxuY29uc3QgZ2V0UGFnZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgaWYgKGRhdGEucGFnZURhdGEpIHtcbiAgICBkLnJlc29sdmUoZGF0YS5wYWdlRGF0YSlcbiAgfSBlbHNlIGlmIChkYXRhLnRhYklEKSB7XG4gICAgc2VuZE1lc3NhZ2VUb1RhYih0YWJJRCwge2FjdGlvbjogJ2dldFBhZ2VEYXRhJ30pXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICBkLnJlc29sdmUocmVzKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZC5yZWplY3QoKVxuICB9XG4gIHJldHVybiBkLnByb21pc2Vcbn1cblxuY29uc3Qgc2VuZE1lc3NhZ2VUb1RhYiA9IGZ1bmN0aW9uKHRhYklELCBkYXRhKSB7XG4gIC8vIE5lZWQgZXJyb3IgY2F0Y2hpbmcgaGVyZVxuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIGNocm9tZS50YWJzLnNlbmRNZXNzYWdlKHRhYklELCBkYXRhLCBmdW5jdGlvbihyZXMpIHtcbiAgICBsb2cuZGVidWcocmVzKVxuICAgIGQucmVzb2x2ZShyZXMpXG4gIH0pXG4gIHJldHVybiBkLnByb21pc2Vcbn1cblxuY29uc3QgYWRkVG9QYWdlUmVzdWx0cyA9IGZ1bmN0aW9uKHRhYklELCBkYXRhKSB7XG4gIFBhZ2VSZXN1bHRzW3RhYklEXSA9IGRhdGFcbiAgY2hyb21lLnRhYnMucXVlcnkoe2FjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZX0sIGZ1bmN0aW9uKHRhYnMpe1xuICAgIE9iamVjdC5rZXlzKFBhZ2VSZXN1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhZ2VUYWJJRCkge1xuICAgICAgaWYgKCB0YWJzLmZpbHRlcihmdW5jdGlvbih0YWIpIHtyZXR1cm4gdGFiLmlkID09IHBhZ2VUYWJJRH0pLmxlbmd0aCA9PSAwIClcbiAgICAgICAgZGVsZXRlIFBhZ2VSZXN1bHRzW3BhZ2VUYWJJRF1cbiAgICB9KVxuICAgIGxvZy5kZWJ1ZyhQYWdlUmVzdWx0cylcbiAgfSlcbn1cblxuY29uc3QgY2hlY2tSZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICBpZiAobm93IC0gTGFzdFJlZnJlc2ggPiAzMDAwMDApIHtcbiAgICBnZXRBbGxVc2VyQ2FyZHMoKVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgZC5yZXNvbHZlKClcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBsb2cuZXJyb3IoZSlcbiAgICAgIGQucmVqZWN0KGUpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBkLnJlc29sdmUoKVxuICB9XG4gIHJldHVybiBkLnByb21pc2Vcbn1cblxuY29uc3QgZ2V0QWxsVXNlckNhcmRzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgTGFzdFJlZnJlc2ggPSBuZXcgRGF0ZSgpXG4gIEV4cGxhYWluU2VhcmNoLnNlYXJjaENhcmRzKFVzZXJJRCwgJycsIDEwMDApXG4gIC50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICBVc2VyQ2FyZHMgPSByZXN1bHRzO1xuICAgIGxvZy5kZWJ1ZyhVc2VyQ2FyZHMpO1xuICAgIGQucmVzb2x2ZSgpXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICBsb2cuZXJyb3IoZSlcbiAgICBkLnJlamVjdChlKVxuICB9KVxuICByZXR1cm4gZC5wcm9taXNlXG59XG5nZXRBbGxVc2VyQ2FyZHMoKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL3NjcmlwdHMvZXZlbnQtcGFnZS5qcyIsIi8qIVxuICogVnVlLmpzIHYyLjQuMlxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChudWxsKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXG4gICAgICA/IHZtXG4gICAgICA6IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICAgID8gdm0ub3B0aW9ucy5uYW1lXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgICA6IHZtLm5hbWU7XG5cbiAgICB2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICB2YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gRmlyZWZpeCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWVcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbi5jYWxsKHRoaXMsIHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICAgIDogcmVzXG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0gaW5qZWN0W2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mdW5jdGlvbmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgKGxhc3QpLnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoY29tcC5fX2VzTW9kdWxlICYmIGNvbXAuZGVmYXVsdCkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UkJDEpIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGNoaWxkLmRhdGEgJiYgY2hpbGQuZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gY2hpbGQuZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbnNlcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YSAmJiBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzO1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja09wdGlvblR5cGUgKHZtLCBuYW1lKSB7XG4gIHZhciBvcHRpb24gPSB2bS4kb3B0aW9uc1tuYW1lXTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9wdGlvbikpIHtcbiAgICB3YXJuKFxuICAgICAgKFwiY29tcG9uZW50IG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIHNob3VsZCBiZSBhbiBvYmplY3QuXCIpLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGtleSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICdjb21wdXRlZCcpO1xuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyIHx8IG5vb3AsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ21ldGhvZHMnKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICd3YXRjaCcpO1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGtleU9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV07XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXNvdXJjZSkge1xuICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCB7fSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGxpc3RlbmVyczogZGF0YS5vbiB8fCB7fSxcbiAgICBpbmplY3Rpb25zOiByZXNvbHZlSW5qZWN0KEN0b3Iub3B0aW9ucy5pbmplY3QsIGNvbnRleHQpLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB2bm9kZS5mdW5jdGlvbmFsT3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IsIGNvbnRleHQpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiBpc1VuZGVmKGNoaWxkLm5zKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KG91cnMsIGV4aXN0aW5nKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycywgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycywgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gY2xvbmUgc2xvdCBub2RlcyBvbiByZS1yZW5kZXJzXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxuICAgICAgICAgID8gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKVxuICAgICAgICAgIDogdm0uX3Zub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcblxuICAvLyBpbnRlcm5hbCByZW5kZXIgaGVscGVycy5cbiAgLy8gdGhlc2UgYXJlIGV4cG9zZWQgb24gdGhlIGluc3RhbmNlIHByb3RvdHlwZSB0byByZWR1Y2UgZ2VuZXJhdGVkIHJlbmRlclxuICAvLyBjb2RlIHNpemUuXG4gIFZ1ZS5wcm90b3R5cGUuX28gPSBtYXJrT25jZTtcbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xuICBWdWUucHJvdG90eXBlLl9zID0gdG9TdHJpbmc7XG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuICBWdWUucHJvdG90eXBlLl90ID0gcmVuZGVyU2xvdDtcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSByZW5kZXJTdGF0aWM7XG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIFZ1ZS5wcm90b3R5cGUuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMSsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgY3VycmVudCwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIGlmIChjYWNoZWROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjQuMic7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbi8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgZHluYW1pY2FsbHkgY2hhbmdpbmcgdHlwZSBmb3IgPGlucHV0PlxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgaW5QcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluUHJlICYmXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuICAgICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHRhZylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGluUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSkgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV0gOiBudWxsO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBlbG1Ub01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICFiYWlsZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm5cbikge1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcbiAgICApO1xuICB9XG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9ICcmJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIHBhc3NpdmVcbiAgfVxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuICB2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9O1xuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKGVsLCBuYW1lKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgbW9kZWxScyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAobW9kZWxScy5pZHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCIkc2V0KFwiICsgKG1vZGVsUnMuZXhwKSArIFwiLCBcIiArIChtb2RlbFJzLmlkeCkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcbiAgICBpZHg6IHZhbC5zdWJzdHJpbmcoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgZHluYW1pY1R5cGUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPGlucHV0IDp0eXBlPVxcXCJcIiArIGR5bmFtaWNUeXBlICsgXCJcXFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OlxcblwiICtcbiAgICAgICAgXCJ2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBpbnB1dCB0eXBlcy4gVXNlIHYtaWYgYnJhbmNoZXMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBpZiAob25jZSQkMSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLm51bWJlcikge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2xleSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xuZnVuY3Rpb24gc2hvdWxkRGVjb2RlIChjb250ZW50LCBlbmNvZGVkKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBhPVxcXCJcIiArIGNvbnRlbnQgKyBcIlxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXg7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucy5qb2luKCcrJylcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8qIVxuICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIHNpbmdsZUF0dHJJZGVudGlmaWVyID0gLyhbXlxcc1wiJzw+Lz1dKykvO1xudmFyIHNpbmdsZUF0dHJBc3NpZ24gPSAvKD86PSkvO1xudmFyIHNpbmdsZUF0dHJWYWx1ZXMgPSBbXG4gIC8vIGF0dHIgdmFsdWUgZG91YmxlIHF1b3Rlc1xuICAvXCIoW15cIl0qKVwiKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBzaW5nbGUgcXVvdGVzXG4gIC8nKFteJ10qKScrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIG5vIHF1b3Rlc1xuICAvKFteXFxzXCInPTw+YF0rKS8uc291cmNlXG5dO1xudmFyIGF0dHJpYnV0ZSA9IG5ldyBSZWdFeHAoXG4gICdeXFxcXHMqJyArIHNpbmdsZUF0dHJJZGVudGlmaWVyLnNvdXJjZSArXG4gICcoPzpcXFxccyooJyArIHNpbmdsZUF0dHJBc3NpZ24uc291cmNlICsgJyknICtcbiAgJ1xcXFxzKig/OicgKyBzaW5nbGVBdHRyVmFsdWVzLmpvaW4oJ3wnKSArICcpKT8nXG4pO1xuXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gJygoPzonICsgbmNuYW1lICsgJ1xcXFw6KT8nICsgbmNuYW1lICsgJyknO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoJ148JyArIHFuYW1lQ2FwdHVyZSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoJ148XFxcXC8nICsgcW5hbWVDYXB0dXJlICsgJ1tePl0qPicpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbidcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwKTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc1xuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChleHByZXNzaW9uID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGVsLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGVsLnNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcbiAgICAvLyAjNTMzMDogd2FybiBjbGljay5yaWdodCwgc2luY2UgcmlnaHQgY2xpY2tzIGRvIG5vdCBhY3R1YWxseSBmaXJlIGNsaWNrIGV2ZW50cy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbmFtZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLm1vZGlmaWVycyAmJiBoYW5kbGVyLm1vZGlmaWVycy5yaWdodFxuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJVc2UgXFxcImNvbnRleHRtZW51XFxcIiBpbnN0ZWFkIG9mIFxcXCJjbGljay5yaWdodFxcXCIgc2luY2UgcmlnaHQgY2xpY2tzIFwiICtcbiAgICAgICAgXCJkbyBub3QgYWN0dWFsbHkgZmlyZSBcXFwiY2xpY2tcXFwiIGV2ZW50cy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICBzdGF0ZS53YXJuKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSwgc3RhdGUpXG4gICAgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpXG4gIH1cbiAgcmV0dXJuIFwie2tleTpcIiArIGtleSArIFwiLGZuOmZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5hdHRyc01hcC5zY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9fVwiXG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlblNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgcmV0dXJuIChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIGNoZWNrIHZhbGlkIGlkZW50aWZpZXIgZm9yIHYtZm9yXG52YXIgaWRlbnRSRSA9IC9bQS1aYS16XyRdW1xcdyRdKi87XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59KTtcblxuLyogICovXG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKCh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUvZGlzdC92dWUuZXNtLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiLy8gdmltOnRzPTQ6c3RzPTQ6c3c9NDpcbi8qIVxuICpcbiAqIENvcHlyaWdodCAyMDA5LTIwMTcgS3JpcyBLb3dhbCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVFxuICogbGljZW5zZSBmb3VuZCBhdCBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvYmxvYi92MS9MSUNFTlNFXG4gKlxuICogV2l0aCBwYXJ0cyBieSBUeWxlciBDbG9zZVxuICogQ29weXJpZ2h0IDIwMDctMjAwOSBUeWxlciBDbG9zZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBYIGxpY2Vuc2UgZm91bmRcbiAqIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UuaHRtbFxuICogRm9ya2VkIGF0IHJlZl9zZW5kLmpzIHZlcnNpb246IDIwMDktMDUtMTFcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IE1hcmsgTWlsbGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBUaGlzIGZpbGUgd2lsbCBmdW5jdGlvbiBwcm9wZXJseSBhcyBhIDxzY3JpcHQ+IHRhZywgb3IgYSBtb2R1bGVcbiAgICAvLyB1c2luZyBDb21tb25KUyBhbmQgTm9kZUpTIG9yIFJlcXVpcmVKUyBtb2R1bGUgZm9ybWF0cy4gIEluXG4gICAgLy8gQ29tbW9uL05vZGUvUmVxdWlyZUpTLCB0aGUgbW9kdWxlIGV4cG9ydHMgdGhlIFEgQVBJIGFuZCB3aGVuXG4gICAgLy8gZXhlY3V0ZWQgYXMgYSBzaW1wbGUgPHNjcmlwdD4sIGl0IGNyZWF0ZXMgYSBRIGdsb2JhbCBpbnN0ZWFkLlxuXG4gICAgLy8gTW9udGFnZSBSZXF1aXJlXG4gICAgaWYgKHR5cGVvZiBib290c3RyYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBib290c3RyYXAoXCJwcm9taXNlXCIsIGRlZmluaXRpb24pO1xuXG4gICAgLy8gQ29tbW9uSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAvLyBSZXF1aXJlSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcblxuICAgIC8vIFNFUyAoU2VjdXJlIEVjbWFTY3JpcHQpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICghc2VzLm9rKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcy5tYWtlUSA9IGRlZmluaXRpb247XG4gICAgICAgIH1cblxuICAgIC8vIDxzY3JpcHQ+XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFByZWZlciB3aW5kb3cgb3ZlciBzZWxmIGZvciBhZGQtb24gc2NyaXB0cy4gVXNlIHNlbGYgZm9yXG4gICAgICAgIC8vIG5vbi13aW5kb3dlZCBjb250ZXh0cy5cbiAgICAgICAgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBzZWxmO1xuXG4gICAgICAgIC8vIEdldCB0aGUgYHdpbmRvd2Agb2JqZWN0LCBzYXZlIHRoZSBwcmV2aW91cyBRIGdsb2JhbFxuICAgICAgICAvLyBhbmQgaW5pdGlhbGl6ZSBRIGFzIGEgZ2xvYmFsLlxuICAgICAgICB2YXIgcHJldmlvdXNRID0gZ2xvYmFsLlE7XG4gICAgICAgIGdsb2JhbC5RID0gZGVmaW5pdGlvbigpO1xuXG4gICAgICAgIC8vIEFkZCBhIG5vQ29uZmxpY3QgZnVuY3Rpb24gc28gUSBjYW4gYmUgcmVtb3ZlZCBmcm9tIHRoZVxuICAgICAgICAvLyBnbG9iYWwgbmFtZXNwYWNlLlxuICAgICAgICBnbG9iYWwuUS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ2xvYmFsLlEgPSBwcmV2aW91c1E7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZW52aXJvbm1lbnQgd2FzIG5vdCBhbnRpY2lwYXRlZCBieSBRLiBQbGVhc2UgZmlsZSBhIGJ1Zy5cIik7XG4gICAgfVxuXG59KShmdW5jdGlvbiAoKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhhc1N0YWNrcyA9IGZhbHNlO1xudHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTdGFja3MgPSAhIWUuc3RhY2s7XG59XG5cbi8vIEFsbCBjb2RlIGFmdGVyIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcyByZXBvcnRlZFxuLy8gYnkgUS5cbnZhciBxU3RhcnRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcbnZhciBxRmlsZU5hbWU7XG5cbi8vIHNoaW1zXG5cbi8vIHVzZWQgZm9yIGZhbGxiYWNrIGluIFwiYWxsUmVzb2x2ZWRcIlxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IHBvc3NpYmxlIG1lYW5zIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm5cbi8vIG9mIHRoZSBldmVudCBsb29wLlxudmFyIG5leHRUaWNrID0oZnVuY3Rpb24gKCkge1xuICAgIC8vIGxpbmtlZCBsaXN0IG9mIHRhc2tzIChzaW5nbGUsIHdpdGggaGVhZCBub2RlKVxuICAgIHZhciBoZWFkID0ge3Rhc2s6IHZvaWQgMCwgbmV4dDogbnVsbH07XG4gICAgdmFyIHRhaWwgPSBoZWFkO1xuICAgIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICAgIHZhciByZXF1ZXN0VGljayA9IHZvaWQgMDtcbiAgICB2YXIgaXNOb2RlSlMgPSBmYWxzZTtcbiAgICAvLyBxdWV1ZSBmb3IgbGF0ZSB0YXNrcywgdXNlZCBieSB1bmhhbmRsZWQgcmVqZWN0aW9uIHRyYWNraW5nXG4gICAgdmFyIGxhdGVyUXVldWUgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbiAgICAgICAgdmFyIHRhc2ssIGRvbWFpbjtcblxuICAgICAgICB3aGlsZSAoaGVhZC5uZXh0KSB7XG4gICAgICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgICAgICAgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaGVhZC5kb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5TaW5nbGUodGFzaywgZG9tYWluKTtcblxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsYXRlclF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFzayA9IGxhdGVyUXVldWUucG9wKCk7XG4gICAgICAgICAgICBydW5TaW5nbGUodGFzayk7XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gcnVucyBhIHNpbmdsZSBmdW5jdGlvbiBpbiB0aGUgYXN5bmMgcXVldWVcbiAgICBmdW5jdGlvbiBydW5TaW5nbGUodGFzaywgZG9tYWluKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXNrKCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gbm9kZSwgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgY29uc2lkZXJlZCBmYXRhbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb250aW51YXRpb24gaWYgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIFwidW5jYXVnaHRFeGNlcHRpb25cIiBldmVudHMgKGFzIGRvbWFpbnMgZG9lcykuXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBicm93c2VycywgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgc2xvdy1kb3ducy5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0VGljayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7XG4gICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBwcm9jZXNzLnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgICAgLy8gRW5zdXJlIFEgaXMgaW4gYSByZWFsIE5vZGUgZW52aXJvbm1lbnQsIHdpdGggYSBgcHJvY2Vzcy5uZXh0VGlja2AuXG4gICAgICAgIC8vIFRvIHNlZSB0aHJvdWdoIGZha2UgTm9kZSBlbnZpcm9ubWVudHM6XG4gICAgICAgIC8vICogTW9jaGEgdGVzdCBydW5uZXIgLSBleHBvc2VzIGEgYHByb2Nlc3NgIGdsb2JhbCB3aXRob3V0IGEgYG5leHRUaWNrYFxuICAgICAgICAvLyAqIEJyb3dzZXJpZnkgLSBleHBvc2VzIGEgYHByb2Nlc3MubmV4VGlja2AgZnVuY3Rpb24gdGhhdCB1c2VzXG4gICAgICAgIC8vICAgYHNldFRpbWVvdXRgLiBJbiB0aGlzIGNhc2UgYHNldEltbWVkaWF0ZWAgaXMgcHJlZmVycmVkIGJlY2F1c2VcbiAgICAgICAgLy8gICAgaXQgaXMgZmFzdGVyLiBCcm93c2VyaWZ5J3MgYHByb2Nlc3MudG9TdHJpbmcoKWAgeWllbGRzXG4gICAgICAgIC8vICAgXCJbb2JqZWN0IE9iamVjdF1cIiwgd2hpbGUgaW4gYSByZWFsIE5vZGUgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gICBgcHJvY2Vzcy50b1N0cmluZygpYCB5aWVsZHMgXCJbb2JqZWN0IHByb2Nlc3NdXCIuXG4gICAgICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gSW4gSUUxMCwgTm9kZS5qcyAwLjkrLCBvciBodHRwczovL2dpdGh1Yi5jb20vTm9ibGVKUy9zZXRJbW1lZGlhdGVcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIC8vIEF0IGxlYXN0IFNhZmFyaSBWZXJzaW9uIDYuMC41ICg4NTM2LjMwLjEpIGludGVybWl0dGVudGx5IGNhbm5vdCBjcmVhdGVcbiAgICAgICAgLy8gd29ya2luZyBtZXNzYWdlIHBvcnRzIHRoZSBmaXJzdCB0aW1lIGEgcGFnZSBsb2Fkcy5cbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHJlcXVlc3RQb3J0VGljaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdFBvcnRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT3BlcmEgcmVxdWlyZXMgdXMgdG8gcHJvdmlkZSBhIG1lc3NhZ2UgcGF5bG9hZCwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSB1c2UgaXQuXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgcmVxdWVzdFBvcnRUaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgYnJvd3NlcnNcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcnVucyBhIHRhc2sgYWZ0ZXIgYWxsIG90aGVyIHRhc2tzIGhhdmUgYmVlbiBydW5cbiAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgdW5oYW5kbGVkIHJlamVjdGlvbiB0cmFja2luZyB0aGF0IG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIGFsbCBgdGhlbmBkIHRhc2tzIGhhdmUgYmVlbiBydW4uXG4gICAgbmV4dFRpY2sucnVuQWZ0ZXIgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICBsYXRlclF1ZXVlLnB1c2godGFzayk7XG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBuZXh0VGljaztcbn0pKCk7XG5cbi8vIEF0dGVtcHQgdG8gbWFrZSBnZW5lcmljcyBzYWZlIGluIHRoZSBmYWNlIG9mIGRvd25zdHJlYW1cbi8vIG1vZGlmaWNhdGlvbnMuXG4vLyBUaGVyZSBpcyBubyBzaXR1YXRpb24gd2hlcmUgdGhpcyBpcyBuZWNlc3NhcnkuXG4vLyBJZiB5b3UgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSwgdGhlc2UgcHJpbW9yZGlhbHMgbmVlZCB0byBiZVxuLy8gZGVlcGx5IGZyb3plbiBhbnl3YXksIGFuZCBpZiB5b3UgZG9u4oCZdCBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLFxuLy8gdGhpcyBpcyBqdXN0IHBsYWluIHBhcmFub2lkLlxuLy8gSG93ZXZlciwgdGhpcyAqKm1pZ2h0KiogaGF2ZSB0aGUgbmljZSBzaWRlLWVmZmVjdCBvZiByZWR1Y2luZyB0aGUgc2l6ZSBvZlxuLy8gdGhlIG1pbmlmaWVkIGNvZGUgYnkgcmVkdWNpbmcgeC5jYWxsKCkgdG8gbWVyZWx5IHgoKVxuLy8gU2VlIE1hcmsgTWlsbGVy4oCZcyBleHBsYW5hdGlvbiBvZiB3aGF0IHRoaXMgZG9lcy5cbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWNvbnZlbnRpb25zOnNhZmVfbWV0YV9wcm9ncmFtbWluZ1xudmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYWxsLmFwcGx5KGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCwgYnV0IHNsb3dlcjpcbi8vIHVuY3VycnlUaGlzID0gRnVuY3Rpb25fYmluZC5iaW5kKEZ1bmN0aW9uX2JpbmQuY2FsbCk7XG4vLyBodHRwOi8vanNwZXJmLmNvbS91bmN1cnJ5dGhpc1xuXG52YXIgYXJyYXlfc2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheS5wcm90b3R5cGUuc2xpY2UpO1xuXG52YXIgYXJyYXlfcmVkdWNlID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIGJhc2lzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgLy8gY29uY2VybmluZyB0aGUgaW5pdGlhbCB2YWx1ZSwgaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gc2VlayB0byB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFycmF5LCBhY2NvdW50aW5nXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgaXMgaXMgYSBzcGFyc2UgYXJyYXlcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBiYXNpcyA9IHRoaXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVjZVxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSBhcnJheSBpcyBzcGFyc2VcbiAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgYmFzaXMgPSBjYWxsYmFjayhiYXNpcywgdGhpc1tpbmRleF0sIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzaXM7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X2luZGV4T2YgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbm90IGEgdmVyeSBnb29kIHNoaW0sIGJ1dCBnb29kIGVub3VnaCBmb3Igb3VyIG9uZSB1c2Ugb2YgaXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X21hcCA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xsZWN0ID0gW107XG4gICAgICAgIGFycmF5X3JlZHVjZShzZWxmLCBmdW5jdGlvbiAodW5kZWZpbmVkLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjYWxsYmFjay5jYWxsKHRoaXNwLCB2YWx1ZSwgaW5kZXgsIHNlbGYpKTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Q7XG4gICAgfVxuKTtcblxudmFyIG9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUpIHtcbiAgICBmdW5jdGlvbiBUeXBlKCkgeyB9XG4gICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgcmV0dXJuIG5ldyBUeXBlKCk7XG59O1xuXG52YXIgb2JqZWN0X2RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIHByb3AsIGRlc2NyaXB0b3IpIHtcbiAgICBvYmpbcHJvcF0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgb2JqZWN0X2hhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbnZhciBvYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdF9oYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcblxudmFyIG9iamVjdF90b1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gT2JqZWN0KHZhbHVlKTtcbn1cblxuLy8gZ2VuZXJhdG9yIHJlbGF0ZWQgc2hpbXNcblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbmZ1bmN0aW9uIGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBvYmplY3RfdG9TdHJpbmcoZXhjZXB0aW9uKSA9PT0gXCJbb2JqZWN0IFN0b3BJdGVyYXRpb25dXCIgfHxcbiAgICAgICAgZXhjZXB0aW9uIGluc3RhbmNlb2YgUVJldHVyblZhbHVlXG4gICAgKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGhlbHBlciBhbmQgUS5yZXR1cm4gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW5cbi8vIFNwaWRlck1vbmtleS5cbnZhciBRUmV0dXJuVmFsdWU7XG5pZiAodHlwZW9mIFJldHVyblZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUVJldHVyblZhbHVlID0gUmV0dXJuVmFsdWU7XG59IGVsc2Uge1xuICAgIFFSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbn1cblxuLy8gbG9uZyBzdGFjayB0cmFjZXNcblxudmFyIFNUQUNLX0pVTVBfU0VQQVJBVE9SID0gXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiO1xuXG5mdW5jdGlvbiBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgdHJhbnNmb3JtIHRoZSBlcnJvciBzdGFjayB0cmFjZSBieSByZW1vdmluZyBOb2RlIGFuZCBRXG4gICAgLy8gY3J1ZnQsIHRoZW4gY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBzdGFjayB0cmFjZSBvZiBgcHJvbWlzZWAuIFNlZSAjNTcuXG4gICAgaWYgKGhhc1N0YWNrcyAmJlxuICAgICAgICBwcm9taXNlLnN0YWNrICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFja1xuICAgICkge1xuICAgICAgICB2YXIgc3RhY2tzID0gW107XG4gICAgICAgIGZvciAodmFyIHAgPSBwcm9taXNlOyAhIXA7IHAgPSBwLnNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHAuc3RhY2sgJiYgKCFlcnJvci5fX21pbmltdW1TdGFja0NvdW50ZXJfXyB8fCBlcnJvci5fX21pbmltdW1TdGFja0NvdW50ZXJfXyA+IHAuc3RhY2tDb3VudGVyKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdF9kZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJfX21pbmltdW1TdGFja0NvdW50ZXJfX1wiLCB7dmFsdWU6IHAuc3RhY2tDb3VudGVyLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBzdGFja3MudW5zaGlmdChwLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja3MudW5zaGlmdChlcnJvci5zdGFjayk7XG5cbiAgICAgICAgdmFyIGNvbmNhdGVkU3RhY2tzID0gc3RhY2tzLmpvaW4oXCJcXG5cIiArIFNUQUNLX0pVTVBfU0VQQVJBVE9SICsgXCJcXG5cIik7XG4gICAgICAgIHZhciBzdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICAgICAgb2JqZWN0X2RlZmluZVByb3BlcnR5KGVycm9yLCBcInN0YWNrXCIsIHt2YWx1ZTogc3RhY2ssIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3RhY2tTdHJpbmcoc3RhY2tTdHJpbmcpIHtcbiAgICB2YXIgbGluZXMgPSBzdGFja1N0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgZGVzaXJlZExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgIGlmICghaXNJbnRlcm5hbEZyYW1lKGxpbmUpICYmICFpc05vZGVGcmFtZShsaW5lKSAmJiBsaW5lKSB7XG4gICAgICAgICAgICBkZXNpcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzaXJlZExpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUZyYW1lKHN0YWNrTGluZSkge1xuICAgIHJldHVybiBzdGFja0xpbmUuaW5kZXhPZihcIihtb2R1bGUuanM6XCIpICE9PSAtMSB8fFxuICAgICAgICAgICBzdGFja0xpbmUuaW5kZXhPZihcIihub2RlLmpzOlwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpIHtcbiAgICAvLyBOYW1lZCBmdW5jdGlvbnM6IFwiYXQgZnVuY3Rpb25OYW1lIChmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlcilcIlxuICAgIC8vIEluIElFMTAgZnVuY3Rpb24gbmFtZSBjYW4gaGF2ZSBzcGFjZXMgKFwiQW5vbnltb3VzIGZ1bmN0aW9uXCIpIE9fb1xuICAgIHZhciBhdHRlbXB0MSA9IC9hdCAuKyBcXCgoLispOihcXGQrKTooPzpcXGQrKVxcKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDEpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MVsxXSwgTnVtYmVyKGF0dGVtcHQxWzJdKV07XG4gICAgfVxuXG4gICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uczogXCJhdCBmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQyID0gL2F0IChbXiBdKyk6KFxcZCspOig/OlxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mikge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQyWzFdLCBOdW1iZXIoYXR0ZW1wdDJbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBGaXJlZm94IHN0eWxlOiBcImZ1bmN0aW9uQGZpbGVuYW1lOmxpbmVOdW1iZXIgb3IgQGZpbGVuYW1lOmxpbmVOdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MyA9IC8uKkAoLispOihcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDMpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0M1sxXSwgTnVtYmVyKGF0dGVtcHQzWzJdKV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybmFsRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpO1xuXG4gICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICB2YXIgbGluZU51bWJlciA9IGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcblxuICAgIHJldHVybiBmaWxlTmFtZSA9PT0gcUZpbGVOYW1lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPj0gcVN0YXJ0aW5nTGluZSAmJlxuICAgICAgICBsaW5lTnVtYmVyIDw9IHFFbmRpbmdMaW5lO1xufVxuXG4vLyBkaXNjb3ZlciBvd24gZmlsZSBuYW1lIGFuZCBsaW5lIG51bWJlciByYW5nZSBmb3IgZmlsdGVyaW5nIHN0YWNrXG4vLyB0cmFjZXNcbmZ1bmN0aW9uIGNhcHR1cmVMaW5lKCkge1xuICAgIGlmICghaGFzU3RhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lc1swXS5pbmRleE9mKFwiQFwiKSA+IDAgPyBsaW5lc1sxXSA6IGxpbmVzWzJdO1xuICAgICAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKGZpcnN0TGluZSk7XG4gICAgICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBxRmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgICAgIHJldHVybiBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUoY2FsbGJhY2ssIG5hbWUsIGFsdGVybmF0aXZlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCwgdXNlIFwiICsgYWx0ZXJuYXRpdmUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluc3RlYWQuXCIsIG5ldyBFcnJvcihcIlwiKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIGVuZCBvZiBzaGltc1xuLy8gYmVnaW5uaW5nIG9mIHJlYWwgd29ya1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLCBwYXNzZXMgcHJvbWlzZXMgdGhyb3VnaCwgb3JcbiAqIGNvZXJjZXMgcHJvbWlzZXMgZnJvbSBkaWZmZXJlbnQgc3lzdGVtcy5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlIG9yIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gUSh2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBhIFByb21pc2UsIHJldHVybiBpdCBkaXJlY3RseS4gIFRoaXMgZW5hYmxlc1xuICAgIC8vIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHRvIGJvdGggYmUgdXNlZCB0byBjcmVhdGVkIHJlZmVyZW5jZXMgZnJvbSBvYmplY3RzLFxuICAgIC8vIGJ1dCB0byB0b2xlcmFibHkgY29lcmNlIG5vbi1wcm9taXNlcyB0byBwcm9taXNlcy5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBhc3NpbWlsYXRlIHRoZW5hYmxlc1xuICAgIGlmIChpc1Byb21pc2VBbGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGwodmFsdWUpO1xuICAgIH1cbn1cblEucmVzb2x2ZSA9IFE7XG5cbi8qKlxuICogUGVyZm9ybXMgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrXG4gKi9cblEubmV4dFRpY2sgPSBuZXh0VGljaztcblxuLyoqXG4gKiBDb250cm9scyB3aGV0aGVyIG9yIG5vdCBsb25nIHN0YWNrIHRyYWNlcyB3aWxsIGJlIG9uXG4gKi9cblEubG9uZ1N0YWNrU3VwcG9ydCA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBjb3VudGVyIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzdG9wcGluZyBwb2ludCBmb3IgYnVpbGRpbmdcbiAqIGxvbmcgc3RhY2sgdHJhY2VzLiBJbiBtYWtlU3RhY2tUcmFjZUxvbmcgd2Ugd2FsayBiYWNrd2FyZHMgdGhyb3VnaFxuICogdGhlIGxpbmtlZCBsaXN0IG9mIHByb21pc2VzLCBvbmx5IHN0YWNrcyB3aGljaCB3ZXJlIGNyZWF0ZWQgYmVmb3JlXG4gKiB0aGUgcmVqZWN0aW9uIGFyZSBjb25jYXRlbmF0ZWQuXG4gKi9cbnZhciBsb25nU3RhY2tDb3VudGVyID0gMTtcblxuLy8gZW5hYmxlIGxvbmcgc3RhY2tzIGlmIFFfREVCVUcgaXMgc2V0XG5pZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5RX0RFQlVHKSB7XG4gICAgUS5sb25nU3RhY2tTdXBwb3J0ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gb2JqZWN0LlxuICpcbiAqIGByZXNvbHZlYCBpcyBhIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGEgbW9yZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhlXG4gKiBwcm9taXNlLiBUbyBmdWxmaWxsIHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYW55IHZhbHVlIHRoYXQgaXNcbiAqIG5vdCBhIHRoZW5hYmxlLiBUbyByZWplY3QgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhIHJlamVjdGVkXG4gKiB0aGVuYWJsZSwgb3IgaW52b2tlIGByZWplY3RgIHdpdGggdGhlIHJlYXNvbiBkaXJlY3RseS4gVG8gcmVzb2x2ZSB0aGVcbiAqIHByb21pc2UgdG8gYW5vdGhlciB0aGVuYWJsZSwgdGh1cyBwdXR0aW5nIGl0IGluIHRoZSBzYW1lIHN0YXRlLCBpbnZva2VcbiAqIGByZXNvbHZlYCB3aXRoIHRoYXQgb3RoZXIgdGhlbmFibGUuXG4gKi9cblEuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIGRlZmVyKCkge1xuICAgIC8vIGlmIFwibWVzc2FnZXNcIiBpcyBhbiBcIkFycmF5XCIsIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHByb21pc2UgaGFzIG5vdCB5ZXRcbiAgICAvLyBiZWVuIHJlc29sdmVkLiAgSWYgaXQgaXMgXCJ1bmRlZmluZWRcIiwgaXQgaGFzIGJlZW4gcmVzb2x2ZWQuICBFYWNoXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgbWVzc2FnZXMgYXJyYXkgaXMgaXRzZWxmIGFuIGFycmF5IG9mIGNvbXBsZXRlIGFyZ3VtZW50cyB0b1xuICAgIC8vIGZvcndhcmQgdG8gdGhlIHJlc29sdmVkIHByb21pc2UuICBXZSBjb2VyY2UgdGhlIHJlc29sdXRpb24gdmFsdWUgdG8gYVxuICAgIC8vIHByb21pc2UgdXNpbmcgdGhlIGByZXNvbHZlYCBmdW5jdGlvbiBiZWNhdXNlIGl0IGhhbmRsZXMgYm90aCBmdWxseVxuICAgIC8vIG5vbi10aGVuYWJsZSB2YWx1ZXMgYW5kIG90aGVyIHRoZW5hYmxlcyBncmFjZWZ1bGx5LlxuICAgIHZhciBtZXNzYWdlcyA9IFtdLCBwcm9ncmVzc0xpc3RlbmVycyA9IFtdLCByZXNvbHZlZFByb21pc2U7XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBvYmplY3RfY3JlYXRlKGRlZmVyLnByb3RvdHlwZSk7XG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBvcGVyYW5kcykge1xuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChhcmdzKTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJ3aGVuXCIgJiYgb3BlcmFuZHNbMV0pIHsgLy8gcHJvZ3Jlc3Mgb3BlcmFuZFxuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXJzLnB1c2gob3BlcmFuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShyZXNvbHZlZFByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gWFhYIGRlcHJlY2F0ZWRcbiAgICBwcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJlclZhbHVlID0gbmVhcmVyKHJlc29sdmVkUHJvbWlzZSk7XG4gICAgICAgIGlmIChpc1Byb21pc2UobmVhcmVyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZWFyZXJWYWx1ZTsgLy8gc2hvcnRlbiBjaGFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXJWYWx1ZTtcbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicGVuZGluZ1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTk9URTogZG9uJ3QgdHJ5IHRvIHVzZSBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgIG9yIHRyYW5zZmVyIHRoZVxuICAgICAgICAgICAgLy8gYWNjZXNzb3IgYXJvdW5kOyB0aGF0IGNhdXNlcyBtZW1vcnkgbGVha3MgYXMgcGVyIEdILTExMS4gSnVzdFxuICAgICAgICAgICAgLy8gcmVpZnkgdGhlIHN0YWNrIHRyYWNlIGFzIGEgc3RyaW5nIEFTQVAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSwgY3V0IG9mZiB0aGUgZmlyc3QgbGluZTsgaXQncyBhbHdheXMganVzdFxuICAgICAgICAgICAgLy8gXCJbb2JqZWN0IFByb21pc2VdXFxuXCIsIGFzIHBlciB0aGUgYHRvU3RyaW5nYC5cbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoXCJcXG5cIikgKyAxKTtcbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2tDb3VudGVyID0gbG9uZ1N0YWNrQ291bnRlcisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogd2UgZG8gdGhlIGNoZWNrcyBmb3IgYHJlc29sdmVkUHJvbWlzZWAgaW4gZWFjaCBtZXRob2QsIGluc3RlYWQgb2ZcbiAgICAvLyBjb25zb2xpZGF0aW5nIHRoZW0gaW50byBgYmVjb21lYCwgc2luY2Ugb3RoZXJ3aXNlIHdlJ2QgY3JlYXRlIG5ld1xuICAgIC8vIHByb21pc2VzIHdpdGggdGhlIGxpbmVzIGBiZWNvbWUod2hhdGV2ZXIodmFsdWUpKWAuIFNlZSBlLmcuIEdILTI1Mi5cblxuICAgIGZ1bmN0aW9uIGJlY29tZShuZXdQcm9taXNlKSB7XG4gICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5ld1Byb21pc2U7XG5cbiAgICAgICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgaG9sZCBhIHJlZmVyZW5jZSB0byB0aGUgbmV3IHByb21pc2UgaWYgbG9uZyBzdGFja3NcbiAgICAgICAgICAgIC8vIGFyZSBlbmFibGVkIHRvIHJlZHVjZSBtZW1vcnkgdXNhZ2VcbiAgICAgICAgICAgIHByb21pc2Uuc291cmNlID0gbmV3UHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5X3JlZHVjZShtZXNzYWdlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLlByb21pc2UgPSBwcm9taXNlOyAvLyBFUzZcblEucHJvbWlzZSA9IHByb21pc2U7XG5mdW5jdGlvbiBwcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5wcm9taXNlLnJhY2UgPSByYWNlOyAvLyBFUzZcbnByb21pc2UuYWxsID0gYWxsOyAvLyBFUzZcbnByb21pc2UucmVqZWN0ID0gcmVqZWN0OyAvLyBFUzZcbnByb21pc2UucmVzb2x2ZSA9IFE7IC8vIEVTNlxuXG4vLyBYWFggZXhwZXJpbWVudGFsLiAgVGhpcyBtZXRob2QgaXMgYSB3YXkgdG8gZGVub3RlIHRoYXQgYSBsb2NhbCB2YWx1ZSBpc1xuLy8gc2VyaWFsaXphYmxlIGFuZCBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGlzcGF0Y2hlZCB0byBhIHJlbW90ZSB1cG9uIHJlcXVlc3QsXG4vLyBpbnN0ZWFkIG9mIHBhc3NpbmcgYSByZWZlcmVuY2UuXG5RLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucGFzc0J5Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0d28gcHJvbWlzZXMgZXZlbnR1YWxseSBmdWxmaWxsIHRvIHRoZSBzYW1lIHZhbHVlLCBwcm9taXNlcyB0aGF0IHZhbHVlLFxuICogYnV0IG90aGVyd2lzZSByZWplY3RzLlxuICogQHBhcmFtIHgge0FueSp9XG4gKiBAcGFyYW0geSB7QW55Kn1cbiAqIEByZXR1cm5zIHtBbnkqfSBhIHByb21pc2UgZm9yIHggYW5kIHkgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGJ1dCBhIHJlamVjdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqL1xuUS5qb2luID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gUSh4KS5qb2luKHkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgcmV0dXJuIFEoW3RoaXMsIHRoYXRdKS5zcHJlYWQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFwiPT09XCIgc2hvdWxkIGJlIE9iamVjdC5pcyBvciBlcXVpdlxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRIGNhbid0IGpvaW46IG5vdCB0aGUgc2FtZTogXCIgKyB4ICsgXCIgXCIgKyB5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IG9mIGFuIGFycmF5IG9mIHByb21pc2VzIHRvIGJlY29tZSBzZXR0bGVkLlxuICogQHBhcmFtIGFuc3dlcnMge0FycmF5W0FueSpdfSBwcm9taXNlcyB0byByYWNlXG4gKiBAcmV0dXJucyB7QW55Kn0gdGhlIGZpcnN0IHByb21pc2UgdG8gYmUgc2V0dGxlZFxuICovXG5RLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShhbnN3ZXJQcykge1xuICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHRoaXMgb25jZSB3ZSBjYW4gYXNzdW1lIGF0IGxlYXN0IEVTNVxuICAgICAgICAvLyBhbnN3ZXJQcy5mb3JFYWNoKGZ1bmN0aW9uIChhbnN3ZXJQKSB7XG4gICAgICAgIC8vICAgICBRKGFuc3dlclApLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIFVzZSB0aGlzIGluIHRoZSBtZWFudGltZVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYW5zd2VyUHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIFEoYW5zd2VyUHNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oUS5yYWNlKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIFByb21pc2Ugd2l0aCBhIHByb21pc2UgZGVzY3JpcHRvciBvYmplY3QgYW5kIG9wdGlvbmFsIGZhbGxiYWNrXG4gKiBmdW5jdGlvbi4gIFRoZSBkZXNjcmlwdG9yIGNvbnRhaW5zIG1ldGhvZHMgbGlrZSB3aGVuKHJlamVjdGVkKSwgZ2V0KG5hbWUpLFxuICogc2V0KG5hbWUsIHZhbHVlKSwgcG9zdChuYW1lLCBhcmdzKSwgYW5kIGRlbGV0ZShuYW1lKSwgd2hpY2ggYWxsXG4gKiByZXR1cm4gZWl0aGVyIGEgdmFsdWUsIGEgcHJvbWlzZSBmb3IgYSB2YWx1ZSwgb3IgYSByZWplY3Rpb24uICBUaGUgZmFsbGJhY2tcbiAqIGFjY2VwdHMgdGhlIG9wZXJhdGlvbiBuYW1lLCBhIHJlc29sdmVyLCBhbmQgYW55IGZ1cnRoZXIgYXJndW1lbnRzIHRoYXQgd291bGRcbiAqIGhhdmUgYmVlbiBmb3J3YXJkZWQgdG8gdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBhYm92ZSBoYWQgYSBtZXRob2QgYmVlblxuICogcHJvdmlkZWQgd2l0aCB0aGUgcHJvcGVyIG5hbWUuICBUaGUgQVBJIG1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgdGhlIG5hdHVyZVxuICogb2YgdGhlIHJldHVybmVkIG9iamVjdCwgYXBhcnQgZnJvbSB0aGF0IGl0IGlzIHVzYWJsZSB3aGVyZWV2ZXIgcHJvbWlzZXMgYXJlXG4gKiBib3VnaHQgYW5kIHNvbGQuXG4gKi9cblEubWFrZVByb21pc2UgPSBQcm9taXNlO1xuZnVuY3Rpb24gUHJvbWlzZShkZXNjcmlwdG9yLCBmYWxsYmFjaywgaW5zcGVjdCkge1xuICAgIGlmIChmYWxsYmFjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZhbGxiYWNrID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlByb21pc2UgZG9lcyBub3Qgc3VwcG9ydCBvcGVyYXRpb246IFwiICsgb3BcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW5zcGVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXRlOiBcInVua25vd25cIn07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcltvcF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXNjcmlwdG9yW29wXS5hcHBseShwcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsbGJhY2suY2FsbChwcm9taXNlLCBvcCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBpbnNwZWN0O1xuXG4gICAgLy8gWFhYIGRlcHJlY2F0ZWQgYHZhbHVlT2ZgIGFuZCBgZXhjZXB0aW9uYCBzdXBwb3J0XG4gICAgaWYgKGluc3BlY3QpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICBwcm9taXNlLmV4Y2VwdGlvbiA9IGluc3BlY3RlZC5yZWFzb247XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJwZW5kaW5nXCIgfHxcbiAgICAgICAgICAgICAgICBpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTsgICAvLyBlbnN1cmUgdGhlIHVudHJ1c3RlZCBwcm9taXNlIG1ha2VzIGF0IG1vc3QgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNhbGwgdG8gb25lIG9mIHRoZSBjYWxsYmFja3NcblxuICAgIGZ1bmN0aW9uIF9mdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZnVsZmlsbGVkID09PSBcImZ1bmN0aW9uXCIgPyBmdWxmaWxsZWQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlamVjdGVkKGV4Y2VwdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHJlamVjdGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhleGNlcHRpb24sIHNlbGYpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKG5ld0V4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3RXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Byb2dyZXNzZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9ncmVzc2VkID09PSBcImZ1bmN0aW9uXCIgPyBwcm9ncmVzc2VkKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoX2Z1bGZpbGxlZCh2YWx1ZSkpO1xuICAgICAgICB9LCBcIndoZW5cIiwgW2Z1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoX3JlamVjdGVkKGV4Y2VwdGlvbikpO1xuICAgICAgICB9XSk7XG4gICAgfSk7XG5cbiAgICAvLyBQcm9ncmVzcyBwcm9wYWdhdG9yIG5lZWQgdG8gYmUgYXR0YWNoZWQgaW4gdGhlIGN1cnJlbnQgdGljay5cbiAgICBzZWxmLnByb21pc2VEaXNwYXRjaCh2b2lkIDAsIFwid2hlblwiLCBbdm9pZCAwLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlO1xuICAgICAgICB2YXIgdGhyZXcgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gX3Byb2dyZXNzZWQodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJldyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aHJldykge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUS50YXAgPSBmdW5jdGlvbiAocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50YXAoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBXb3JrcyBhbG1vc3QgbGlrZSBcImZpbmFsbHlcIiwgYnV0IG5vdCBjYWxsZWQgZm9yIHJlamVjdGlvbnMuXG4gKiBPcmlnaW5hbCByZXNvbHV0aW9uIHZhbHVlIGlzIHBhc3NlZCB0aHJvdWdoIGNhbGxiYWNrIHVuYWZmZWN0ZWQuXG4gKiBDYWxsYmFjayBtYXkgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgYXdhaXRlZCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge1EuUHJvbWlzZX1cbiAqIEBleGFtcGxlXG4gKiBkb1NvbWV0aGluZygpXG4gKiAgIC50aGVuKC4uLilcbiAqICAgLnRhcChjb25zb2xlLmxvZylcbiAqICAgLnRoZW4oLi4uKTtcbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUudGFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCh2YWx1ZSkudGhlblJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gb2JzZXJ2ZXIgb24gYSBwcm9taXNlLlxuICpcbiAqIEd1YXJhbnRlZXM6XG4gKlxuICogMS4gdGhhdCBmdWxmaWxsZWQgYW5kIHJlamVjdGVkIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZS5cbiAqIDIuIHRoYXQgZWl0aGVyIHRoZSBmdWxmaWxsZWQgY2FsbGJhY2sgb3IgdGhlIHJlamVjdGVkIGNhbGxiYWNrIHdpbGwgYmVcbiAqICAgIGNhbGxlZCwgYnV0IG5vdCBib3RoLlxuICogMy4gdGhhdCBmdWxmaWxsZWQgYW5kIHJlamVjdGVkIHdpbGwgbm90IGJlIGNhbGxlZCBpbiB0aGlzIHR1cm4uXG4gKlxuICogQHBhcmFtIHZhbHVlICAgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIHRvIG9ic2VydmVcbiAqIEBwYXJhbSBmdWxmaWxsZWQgIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqIEBwYXJhbSByZWplY3RlZCAgIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSByZWplY3Rpb24gZXhjZXB0aW9uXG4gKiBAcGFyYW0gcHJvZ3Jlc3NlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBpbnZva2VkIGNhbGxiYWNrXG4gKi9cblEud2hlbiA9IHdoZW47XG5mdW5jdGlvbiB3aGVuKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSk7XG59O1xuXG5RLnRoZW5SZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlc29sdmUodmFsdWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgcmVhc29uOyB9KTtcbn07XG5cblEudGhlblJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCByZWFzb24pIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVqZWN0KHJlYXNvbik7XG59O1xuXG4vKipcbiAqIElmIGFuIG9iamVjdCBpcyBub3QgYSBwcm9taXNlLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZS5cbiAqIElmIGEgcHJvbWlzZSBpcyByZWplY3RlZCwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUgdG9vLlxuICogSWYgaXTigJlzIGEgZnVsZmlsbGVkIHByb21pc2UsIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZWFyZXIuXG4gKiBJZiBpdOKAmXMgYSBkZWZlcnJlZCBwcm9taXNlIGFuZCB0aGUgZGVmZXJyZWQgaGFzIGJlZW4gcmVzb2x2ZWQsIHRoZVxuICogcmVzb2x1dGlvbiBpcyBcIm5lYXJlclwiLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgbW9zdCByZXNvbHZlZCAobmVhcmVzdCkgZm9ybSBvZiB0aGUgb2JqZWN0XG4gKi9cblxuLy8gWFhYIHNob3VsZCB3ZSByZS1kbyB0aGlzP1xuUS5uZWFyZXIgPSBuZWFyZXI7XG5mdW5jdGlvbiBuZWFyZXIodmFsdWUpIHtcbiAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gdmFsdWUuaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwcm9taXNlLlxuICogT3RoZXJ3aXNlIGl0IGlzIGEgZnVsZmlsbGVkIHZhbHVlLlxuICovXG5RLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgUHJvbWlzZTtcbn1cblxuUS5pc1Byb21pc2VBbGlrZSA9IGlzUHJvbWlzZUFsaWtlO1xuZnVuY3Rpb24gaXNQcm9taXNlQWxpa2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgJiYgdHlwZW9mIG9iamVjdC50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcGVuZGluZyBwcm9taXNlLCBtZWFuaW5nIG5vdFxuICogZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuICovXG5RLmlzUGVuZGluZyA9IGlzUGVuZGluZztcbmZ1bmN0aW9uIGlzUGVuZGluZyhvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB2YWx1ZSBvciBmdWxmaWxsZWRcbiAqIHByb21pc2UuXG4gKi9cblEuaXNGdWxmaWxsZWQgPSBpc0Z1bGZpbGxlZDtcbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKG9iamVjdCkge1xuICAgIHJldHVybiAhaXNQcm9taXNlKG9iamVjdCkgfHwgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSByZWplY3RlZCBwcm9taXNlLlxuICovXG5RLmlzUmVqZWN0ZWQgPSBpc1JlamVjdGVkO1xuZnVuY3Rpb24gaXNSZWplY3RlZChvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufTtcblxuLy8vLyBCRUdJTiBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8vIFRoaXMgcHJvbWlzZSBsaWJyYXJ5IGNvbnN1bWVzIGV4Y2VwdGlvbnMgdGhyb3duIGluIGhhbmRsZXJzIHNvIHRoZXkgY2FuIGJlXG4vLyBoYW5kbGVkIGJ5IGEgc3Vic2VxdWVudCBwcm9taXNlLiAgVGhlIGV4Y2VwdGlvbnMgZ2V0IGFkZGVkIHRvIHRoaXMgYXJyYXkgd2hlblxuLy8gdGhleSBhcmUgY3JlYXRlZCwgYW5kIHJlbW92ZWQgd2hlbiB0aGV5IGFyZSBoYW5kbGVkLiAgTm90ZSB0aGF0IGluIEVTNiBvclxuLy8gc2hpbW1lZCBlbnZpcm9ubWVudHMsIHRoaXMgd291bGQgbmF0dXJhbGx5IGJlIGEgYFNldGAuXG52YXIgdW5oYW5kbGVkUmVhc29ucyA9IFtdO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbnMgPSBbXTtcbnZhciByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMgPSBbXTtcbnZhciB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuXG5mdW5jdGlvbiByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKSB7XG4gICAgdW5oYW5kbGVkUmVhc29ucy5sZW5ndGggPSAwO1xuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMubGVuZ3RoID0gMDtcblxuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFja1JlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgUS5uZXh0VGljay5ydW5BZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwgcmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgIGlmIChyZWFzb24gJiYgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnB1c2gocmVhc29uLnN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnB1c2goXCIobm8gc3RhY2spIFwiICsgcmVhc29uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVudHJhY2tSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXQgPSBhcnJheV9pbmRleE9mKHVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpO1xuICAgIGlmIChhdCAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgUS5uZXh0VGljay5ydW5BZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0UmVwb3J0ID0gYXJyYXlfaW5kZXhPZihyZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIGlmIChhdFJlcG9ydCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwicmVqZWN0aW9uSGFuZGxlZFwiLCB1bmhhbmRsZWRSZWFzb25zW2F0XSwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoYXRSZXBvcnQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5zcGxpY2UoYXQsIDEpO1xuICAgIH1cbn1cblxuUS5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMgPSByZXNldFVuaGFuZGxlZFJlamVjdGlvbnM7XG5cblEuZ2V0VW5oYW5kbGVkUmVhc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyB0aGF0IGNvbnN1bWVycyBjYW4ndCBpbnRlcmZlcmUgd2l0aCBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gICAgcmV0dXJuIHVuaGFuZGxlZFJlYXNvbnMuc2xpY2UoKTtcbn07XG5cblEuc3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZhbHNlO1xufTtcblxucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG5cbi8vLy8gRU5EIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqIEBwYXJhbSByZWFzb24gdmFsdWUgZGVzY3JpYmluZyB0aGUgZmFpbHVyZVxuICovXG5RLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICB2YXIgcmVqZWN0aW9uID0gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGUgZXJyb3IgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdW50cmFja1JlamVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkKHJlYXNvbikgOiB0aGlzO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIHJlYXNvbiBoYXMgbm90IGJlZW4gaGFuZGxlZC5cbiAgICB0cmFja1JlamVjdGlvbihyZWplY3Rpb24sIHJlYXNvbik7XG5cbiAgICByZXR1cm4gcmVqZWN0aW9uO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBmdWxmaWxsZWQgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlXG4gKi9cblEuZnVsZmlsbCA9IGZ1bGZpbGw7XG5mdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBcImdldFwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInNldFwiOiBmdW5jdGlvbiAobmFtZSwgcmhzKSB7XG4gICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHJocztcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3N0XCI6IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAvLyBNYXJrIE1pbGxlciBwcm9wb3NlcyB0aGF0IHBvc3Qgd2l0aCBubyBuYW1lIHNob3VsZCBhcHBseSBhXG4gICAgICAgICAgICAvLyBwcm9taXNlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBudWxsIHx8IG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV0uYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImFwcGx5XCI6IGZ1bmN0aW9uICh0aGlzcCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXNwLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJrZXlzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGVuYWJsZXMgdG8gUSBwcm9taXNlcy5cbiAqIEBwYXJhbSBwcm9taXNlIHRoZW5hYmxlIHByb21pc2VcbiAqIEByZXR1cm5zIGEgUSBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShwcm9taXNlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBBbm5vdGF0ZXMgYW4gb2JqZWN0IHN1Y2ggdGhhdCBpdCB3aWxsIG5ldmVyIGJlXG4gKiB0cmFuc2ZlcnJlZCBhd2F5IGZyb20gdGhpcyBwcm9jZXNzIG92ZXIgYW55IHByb21pc2VcbiAqIGNvbW11bmljYXRpb24gY2hhbm5lbC5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIHByb21pc2UgYSB3cmFwcGluZyBvZiB0aGF0IG9iamVjdCB0aGF0XG4gKiBhZGRpdGlvbmFsbHkgcmVzcG9uZHMgdG8gdGhlIFwiaXNEZWZcIiBtZXNzYWdlXG4gKiB3aXRob3V0IGEgcmVqZWN0aW9uLlxuICovXG5RLm1hc3RlciA9IG1hc3RlcjtcbmZ1bmN0aW9uIG1hc3RlcihvYmplY3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwiaXNEZWZcIjogZnVuY3Rpb24gKCkge31cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjayhvcCwgYXJncykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncyk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUShvYmplY3QpLmluc3BlY3QoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTcHJlYWRzIHRoZSB2YWx1ZXMgb2YgYSBwcm9taXNlZCBhcnJheSBvZiBhcmd1bWVudHMgaW50byB0aGVcbiAqIGZ1bGZpbGxtZW50IGNhbGxiYWNrLlxuICogQHBhcmFtIGZ1bGZpbGxlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHZhcmlhZGljIGFyZ3VtZW50cyBmcm9tIHRoZVxuICogcHJvbWlzZWQgYXJyYXlcbiAqIEBwYXJhbSByZWplY3RlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBleGNlcHRpb24gaWYgdGhlIHByb21pc2VcbiAqIGlzIHJlamVjdGVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9yIHRocm93biBleGNlcHRpb24gb2ZcbiAqIGVpdGhlciBjYWxsYmFjay5cbiAqL1xuUS5zcHJlYWQgPSBzcHJlYWQ7XG5mdW5jdGlvbiBzcHJlYWQodmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkuc3ByZWFkKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFsbCgpLnRoZW4oZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWQuYXBwbHkodm9pZCAwLCBhcnJheSk7XG4gICAgfSwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBUaGUgYXN5bmMgZnVuY3Rpb24gaXMgYSBkZWNvcmF0b3IgZm9yIGdlbmVyYXRvciBmdW5jdGlvbnMsIHR1cm5pbmdcbiAqIHRoZW0gaW50byBhc3luY2hyb25vdXMgZ2VuZXJhdG9ycy4gIEFsdGhvdWdoIGdlbmVyYXRvcnMgYXJlIG9ubHkgcGFydFxuICogb2YgdGhlIG5ld2VzdCBFQ01BU2NyaXB0IDYgZHJhZnRzLCB0aGlzIGNvZGUgZG9lcyBub3QgY2F1c2Ugc3ludGF4XG4gKiBlcnJvcnMgaW4gb2xkZXIgZW5naW5lcy4gIFRoaXMgY29kZSBzaG91bGQgY29udGludWUgdG8gd29yayBhbmQgd2lsbFxuICogaW4gZmFjdCBpbXByb3ZlIG92ZXIgdGltZSBhcyB0aGUgbGFuZ3VhZ2UgaW1wcm92ZXMuXG4gKlxuICogRVM2IGdlbmVyYXRvcnMgYXJlIGN1cnJlbnRseSBwYXJ0IG9mIFY4IHZlcnNpb24gMy4xOSB3aXRoIHRoZVxuICogLS1oYXJtb255LWdlbmVyYXRvcnMgcnVudGltZSBmbGFnIGVuYWJsZWQuICBTcGlkZXJNb25rZXkgaGFzIGhhZCB0aGVtXG4gKiBmb3IgbG9uZ2VyLCBidXQgdW5kZXIgYW4gb2xkZXIgUHl0aG9uLWluc3BpcmVkIGZvcm0uICBUaGlzIGZ1bmN0aW9uXG4gKiB3b3JrcyBvbiBib3RoIGtpbmRzIG9mIGdlbmVyYXRvcnMuXG4gKlxuICogRGVjb3JhdGVzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHN1Y2ggdGhhdDpcbiAqICAtIGl0IG1heSB5aWVsZCBwcm9taXNlc1xuICogIC0gZXhlY3V0aW9uIHdpbGwgY29udGludWUgd2hlbiB0aGF0IHByb21pc2UgaXMgZnVsZmlsbGVkXG4gKiAgLSB0aGUgdmFsdWUgb2YgdGhlIHlpZWxkIGV4cHJlc3Npb24gd2lsbCBiZSB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiAgLSBpdCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSAod2hlbiB0aGUgZ2VuZXJhdG9yXG4gKiAgICBzdG9wcyBpdGVyYXRpbmcpXG4gKiAgLSB0aGUgZGVjb3JhdGVkIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKiAgICBvZiB0aGUgZ2VuZXJhdG9yIG9yIHRoZSBmaXJzdCByZWplY3RlZCBwcm9taXNlIGFtb25nIHRob3NlXG4gKiAgICB5aWVsZGVkLlxuICogIC0gaWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBnZW5lcmF0b3IsIGl0IHByb3BhZ2F0ZXMgdGhyb3VnaFxuICogICAgZXZlcnkgZm9sbG93aW5nIHlpZWxkIHVudGlsIGl0IGlzIGNhdWdodCwgb3IgdW50aWwgaXQgZXNjYXBlc1xuICogICAgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBhbHRvZ2V0aGVyLCBhbmQgaXMgdHJhbnNsYXRlZCBpbnRvIGFcbiAqICAgIHJlamVjdGlvbiBmb3IgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGRlY29yYXRlZCBnZW5lcmF0b3IuXG4gKi9cblEuYXN5bmMgPSBhc3luYztcbmZ1bmN0aW9uIGFzeW5jKG1ha2VHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJzZW5kXCIsIGFyZyBpcyBhIHZhbHVlXG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInRocm93XCIsIGFyZyBpcyBhbiBleGNlcHRpb25cbiAgICAgICAgZnVuY3Rpb24gY29udGludWVyKHZlcmIsIGFyZykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgLy8gVW50aWwgVjggMy4xOSAvIENocm9taXVtIDI5IGlzIHJlbGVhc2VkLCBTcGlkZXJNb25rZXkgaXMgdGhlIG9ubHlcbiAgICAgICAgICAgIC8vIGVuZ2luZSB0aGF0IGhhcyBhIGRlcGxveWVkIGJhc2Ugb2YgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBTTSdzIGdlbmVyYXRvcnMgdXNlIHRoZSBQeXRob24taW5zcGlyZWQgc2VtYW50aWNzIG9mXG4gICAgICAgICAgICAvLyBvdXRkYXRlZCBFUzYgZHJhZnRzLiAgV2Ugd291bGQgbGlrZSB0byBzdXBwb3J0IEVTNiwgYnV0IHdlJ2QgYWxzb1xuICAgICAgICAgICAgLy8gbGlrZSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSBnZW5lcmF0b3JzIGluIGRlcGxveWVkIGJyb3dzZXJzLCBzb1xuICAgICAgICAgICAgLy8gd2UgYWxzbyBzdXBwb3J0IFB5dGhvbi1zdHlsZSBnZW5lcmF0b3JzLiAgQXQgc29tZSBwb2ludCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgICAgICAvLyB0aGlzIGJsb2NrLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIFN0b3BJdGVyYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFUzYgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdC52YWx1ZSwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3BpZGVyTW9ua2V5IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogUmVtb3ZlIHRoaXMgY2FzZSB3aGVuIFNNIGRvZXMgRVM2IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEoZXhjZXB0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gbWFrZUdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwibmV4dFwiKTtcbiAgICAgICAgdmFyIGVycmJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwidGhyb3dcIik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIHNwYXduIGZ1bmN0aW9uIGlzIGEgc21hbGwgd3JhcHBlciBhcm91bmQgYXN5bmMgdGhhdCBpbW1lZGlhdGVseVxuICogY2FsbHMgdGhlIGdlbmVyYXRvciBhbmQgYWxzbyBlbmRzIHRoZSBwcm9taXNlIGNoYWluLCBzbyB0aGF0IGFueVxuICogdW5oYW5kbGVkIGVycm9ycyBhcmUgdGhyb3duIGluc3RlYWQgb2YgZm9yd2FyZGVkIHRvIHRoZSBlcnJvclxuICogaGFuZGxlci4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpdCdzIGV4dHJlbWVseSBjb21tb24gdG8gcnVuXG4gKiBnZW5lcmF0b3JzIGF0IHRoZSB0b3AtbGV2ZWwgdG8gd29yayB3aXRoIGxpYnJhcmllcy5cbiAqL1xuUS5zcGF3biA9IHNwYXduO1xuZnVuY3Rpb24gc3Bhd24obWFrZUdlbmVyYXRvcikge1xuICAgIFEuZG9uZShRLmFzeW5jKG1ha2VHZW5lcmF0b3IpKCkpO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaW50ZXJmYWNlIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbi8qKlxuICogVGhyb3dzIGEgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHRvIHN0b3AgYW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvci5cbiAqXG4gKiBUaGlzIGludGVyZmFjZSBpcyBhIHN0b3AtZ2FwIG1lYXN1cmUgdG8gc3VwcG9ydCBnZW5lcmF0b3IgcmV0dXJuXG4gKiB2YWx1ZXMgaW4gb2xkZXIgRmlyZWZveC9TcGlkZXJNb25rZXkuICBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgRVM2XG4gKiBnZW5lcmF0b3JzIGxpa2UgQ2hyb21pdW0gMjksIGp1c3QgdXNlIFwicmV0dXJuXCIgaW4geW91ciBnZW5lcmF0b3JcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJldHVybiB2YWx1ZSBmb3IgdGhlIHN1cnJvdW5kaW5nIGdlbmVyYXRvclxuICogQHRocm93cyBSZXR1cm5WYWx1ZSBleGNlcHRpb24gd2l0aCB0aGUgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uKiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIHJldHVybiBmb28gKyBiYXI7XG4gKiB9KVxuICogLy8gT2xkZXIgU3BpZGVyTW9ua2V5IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgUS5yZXR1cm4oZm9vICsgYmFyKTtcbiAqIH0pXG4gKi9cblFbXCJyZXR1cm5cIl0gPSBfcmV0dXJuO1xuZnVuY3Rpb24gX3JldHVybih2YWx1ZSkge1xuICAgIHRocm93IG5ldyBRUmV0dXJuVmFsdWUodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBwcm9taXNlZCBmdW5jdGlvbiBkZWNvcmF0b3IgZW5zdXJlcyB0aGF0IGFueSBwcm9taXNlIGFyZ3VtZW50c1xuICogYXJlIHNldHRsZWQgYW5kIHBhc3NlZCBhcyB2YWx1ZXMgKGB0aGlzYCBpcyBhbHNvIHNldHRsZWQgYW5kIHBhc3NlZFxuICogYXMgYSB2YWx1ZSkuICBJdCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdCBvZiBhIGZ1bmN0aW9uIGlzXG4gKiBhbHdheXMgYSBwcm9taXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgYWRkID0gUS5wcm9taXNlZChmdW5jdGlvbiAoYSwgYikge1xuICogICAgIHJldHVybiBhICsgYjtcbiAqIH0pO1xuICogYWRkKFEoYSksIFEoQikpO1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBkZWNvcmF0ZVxuICogQHJldHVybnMge2Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW4gZGVjb3JhdGVkLlxuICovXG5RLnByb21pc2VkID0gcHJvbWlzZWQ7XG5mdW5jdGlvbiBwcm9taXNlZChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzcHJlYWQoW3RoaXMsIGFsbChhcmd1bWVudHMpXSwgZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBzZW5kcyBhIG1lc3NhZ2UgdG8gYSB2YWx1ZSBpbiBhIGZ1dHVyZSB0dXJuXG4gKiBAcGFyYW0gb2JqZWN0KiB0aGUgcmVjaXBpZW50XG4gKiBAcGFyYW0gb3AgdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugb3BlcmF0aW9uLCBlLmcuLCBcIndoZW5cIixcbiAqIEBwYXJhbSBhcmdzIGZ1cnRoZXIgYXJndW1lbnRzIHRvIGJlIGZvcndhcmRlZCB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyByZXN1bHQge1Byb21pc2V9IGEgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKi9cblEuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbmZ1bmN0aW9uIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKG9wLCBhcmdzKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAob3AsIGFyZ3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZGVmZXJyZWQucmVzb2x2ZSwgb3AsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGdldFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcHJvcGVydHkgdmFsdWVcbiAqL1xuUS5nZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciBvYmplY3Qgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0gdmFsdWUgICAgIG5ldyB2YWx1ZSBvZiBwcm9wZXJ0eVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGRlbGV0ZVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSB2YWx1ZSAgICAgYSB2YWx1ZSB0byBwb3N0LCB0eXBpY2FsbHkgYW4gYXJyYXkgb2ZcbiAqICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBhcmd1bWVudHMgZm9yIHByb21pc2VzIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgYXJlIHVsdGltYXRlbHkgYmFja2VkIHdpdGggYHJlc29sdmVgIHZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgYXMgb3Bwb3NlZCB0byB0aG9zZSBiYWNrZWQgd2l0aCBVUkxzXG4gKiAgICAgICAgICAgICAgICAgIHdoZXJlaW4gdGhlIHBvc3RlZCB2YWx1ZSBjYW4gYmUgYW55XG4gKiAgICAgICAgICAgICAgICAgIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG4vLyBib3VuZCBsb2NhbGx5IGJlY2F1c2UgaXQgaXMgdXNlZCBieSBvdGhlciBtZXRob2RzXG5RLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGludm9jYXRpb24gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblEubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMildKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUHJvbWlzZS5wcm90b3R5cGUubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSBhcmdzICAgICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmFwcGx5ID0gZnVuY3Rpb24gKG9iamVjdCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblFbXCJ0cnlcIl0gPVxuUS5mY2FsbCA9IGZ1bmN0aW9uIChvYmplY3QgLyogLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMpXSk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiwgdHJhbnNmb3JtaW5nIHJldHVybiB2YWx1ZXMgaW50byBhIGZ1bGZpbGxlZFxuICogcHJvbWlzZSBhbmQgdGhyb3duIGVycm9ycyBpbnRvIGEgcmVqZWN0ZWQgb25lLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYmluZCA9IGZ1bmN0aW9uIChvYmplY3QgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IFEob2JqZWN0KTtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5mYmluZCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIG5hbWVzIG9mIHRoZSBvd25lZCBwcm9wZXJ0aWVzIG9mIGEgcHJvbWlzZWRcbiAqIG9iamVjdCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIGtleXMgb2YgdGhlIGV2ZW50dWFsbHkgc2V0dGxlZCBvYmplY3RcbiAqL1xuUS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5LiAgSWYgYW55IG9mXG4gKiB0aGUgcHJvbWlzZXMgZ2V0cyByZWplY3RlZCwgdGhlIHdob2xlIGFycmF5IGlzIHJlamVjdGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzXG4gKi9cbi8vIEJ5IE1hcmsgTWlsbGVyXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpjb25jdXJyZW5jeSZyZXY9MTMwODc3NjUyMSNhbGxmdWxmaWxsZWRcblEuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9taXNlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzUHJvbWlzZShwcm9taXNlKSAmJlxuICAgICAgICAgICAgICAgIChzbmFwc2hvdCA9IHByb21pc2UuaW5zcGVjdCgpKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gc25hcHNob3QudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsrcGVuZGluZ0NvdW50O1xuICAgICAgICAgICAgICAgIHdoZW4oXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1wZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7IGluZGV4OiBpbmRleCwgdmFsdWU6IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgaWYgKHBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCByZXNvbHZlZCBwcm9taXNlIG9mIGFuIGFycmF5LiBQcmlvciByZWplY3RlZCBwcm9taXNlcyBhcmVcbiAqIGlnbm9yZWQuICBSZWplY3RzIG9ubHkgaWYgYWxsIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSBjb250YWluaW5nIHZhbHVlcyBvciBwcm9taXNlcyBmb3IgdmFsdWVzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCByZXNvbHZlZCBwcm9taXNlLFxuICogb3IgYSByZWplY3RlZCBwcm9taXNlIGlmIGFsbCBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKi9cblEuYW55ID0gYW55O1xuXG5mdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBRLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBRLmRlZmVyKCk7XG4gICAgdmFyIHBlbmRpbmdDb3VudCA9IDA7XG4gICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAocHJldiwgY3VycmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBwcm9taXNlc1tpbmRleF07XG5cbiAgICAgICAgcGVuZGluZ0NvdW50Kys7XG5cbiAgICAgICAgd2hlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyk7XG4gICAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbGVkKHJlc3VsdCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgICAgICBwZW5kaW5nQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IChcIlEgY2FuJ3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIGZyb20gYW55IHByb21pc2UsIGFsbCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicHJvbWlzZXMgd2VyZSByZWplY3RlZC4gTGFzdCBlcnJvciBtZXNzYWdlOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvZ3Jlc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgdW5kZWZpbmVkKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyB0byBiZSBzZXR0bGVkLCBlaXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gIFRoaXMgaXMgZGlzdGluY3QgZnJvbSBgYWxsYCBzaW5jZSB0aGF0IHdvdWxkIHN0b3BcbiAqIHdhaXRpbmcgYXQgdGhlIGZpcnN0IHJlamVjdGlvbi4gIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gKiBgYWxsUmVzb2x2ZWRgIHdpbGwgbmV2ZXIgYmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0gcHJvbWlzZXMgYSBwcm9taXNlIGZvciBhbiBhcnJheSAob3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG4gKiAob3IgdmFsdWVzKVxuICogQHJldHVybiBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHByb21pc2VzXG4gKi9cblEuYWxsUmVzb2x2ZWQgPSBkZXByZWNhdGUoYWxsUmVzb2x2ZWQsIFwiYWxsUmVzb2x2ZWRcIiwgXCJhbGxTZXR0bGVkXCIpO1xuZnVuY3Rpb24gYWxsUmVzb2x2ZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHByb21pc2VzID0gYXJyYXlfbWFwKHByb21pc2VzLCBRKTtcbiAgICAgICAgcmV0dXJuIHdoZW4oYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGVuKHByb21pc2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbFJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXNvbHZlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQHNlZSBQcm9taXNlI2FsbFNldHRsZWRcbiAqL1xuUS5hbGxTZXR0bGVkID0gYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIGFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUShwcm9taXNlcykuYWxsU2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGVpciBzdGF0ZXMgKGFzXG4gKiByZXR1cm5lZCBieSBgaW5zcGVjdGApIHdoZW4gdGhleSBoYXZlIGFsbCBzZXR0bGVkLlxuICogQHBhcmFtIHtBcnJheVtBbnkqXX0gdmFsdWVzIGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIHtBcnJheVtTdGF0ZV19IGFuIGFycmF5IG9mIHN0YXRlcyBmb3IgdGhlIHJlc3BlY3RpdmUgdmFsdWVzLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxTZXR0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGZhaWx1cmUgb2YgYSBwcm9taXNlLCBnaXZpbmcgYW4gb3BvcnR1bml0eSB0byByZWNvdmVyXG4gKiB3aXRoIGEgY2FsbGJhY2suICBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICogcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpZiB0aGVcbiAqIGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuUS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9iamVjdCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdGhhdCBjYW4gcmVzcG9uZCB0byBwcm9ncmVzcyBub3RpZmljYXRpb25zIGZyb20gYVxuICogcHJvbWlzZSdzIG9yaWdpbmF0aW5nIGRlZmVycmVkLiBUaGlzIGxpc3RlbmVyIHJlY2VpdmVzIHRoZSBleGFjdCBhcmd1bWVudHNcbiAqIHBhc3NlZCB0byBgYGRlZmVycmVkLm5vdGlmeWBgLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIHJlY2VpdmUgYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBnaXZlbiBwcm9taXNlLCB1bmNoYW5nZWRcbiAqL1xuUS5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZnVuY3Rpb24gcHJvZ3Jlc3Mob2JqZWN0LCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBvYnNlcnZlIHRoZSBzZXR0bGluZyBvZiBhIHByb21pc2UsXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIG9yIHJlamVjdGVkLiAgRm9yd2FyZHNcbiAqIHRoZSByZXNvbHV0aW9uIHRvIHRoZSByZXR1cm5lZCBwcm9taXNlIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGRvbmUuXG4gKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIHByb21pc2UgdG8gZGVmZXIgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gb2JzZXJ2ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW5cbiAqIHByb21pc2UsIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2Ugd2hlblxuICogYGBmaW5gYCBpcyBkb25lLlxuICovXG5RLmZpbiA9IC8vIFhYWCBsZWdhY3lcblFbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpW1wiZmluYWxseVwiXShjYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maW4gPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjay5hcHBseSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3QgYXBwbHkgZmluYWxseSBjYWxsYmFja1wiKTtcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUT0RPIGF0dGVtcHQgdG8gcmVjeWNsZSB0aGUgcmVqZWN0aW9uIHdpdGggXCJ0aGlzXCIuXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLCBmb3JjaW5nIHJlamVjdGlvbnMgdG8gYmVcbiAqIHRocm93biBhcyBleGNlcHRpb25zLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGF0IHRoZSBlbmQgb2YgYSBjaGFpbiBvZiBwcm9taXNlc1xuICogQHJldHVybnMgbm90aGluZ1xuICovXG5RLmRvbmUgPSBmdW5jdGlvbiAob2JqZWN0LCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZG9uZShmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgdmFyIG9uVW5oYW5kbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gZm9yd2FyZCB0byBhIGZ1dHVyZSB0dXJuIHNvIHRoYXQgYGB3aGVuYGBcbiAgICAgICAgLy8gZG9lcyBub3QgY2F0Y2ggaXQgYW5kIHR1cm4gaXQgaW50byBhIHJlamVjdGlvbi5cbiAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgYG5leHRUaWNrYGluZyB2aWEgYW4gdW5uZWNlc3NhcnkgYHdoZW5gLlxuICAgIHZhciBwcm9taXNlID0gZnVsZmlsbGVkIHx8IHJlamVjdGVkIHx8IHByb2dyZXNzID9cbiAgICAgICAgdGhpcy50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSA6XG4gICAgICAgIHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgICBvblVuaGFuZGxlZEVycm9yID0gcHJvY2Vzcy5kb21haW4uYmluZChvblVuaGFuZGxlZEVycm9yKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4odm9pZCAwLCBvblVuaGFuZGxlZEVycm9yKTtcbn07XG5cbi8qKlxuICogQ2F1c2VzIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCBpZiBpdCBkb2VzIG5vdCBnZXQgZnVsZmlsbGVkIGJlZm9yZVxuICogc29tZSBtaWxsaXNlY29uZHMgdGltZSBvdXQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHMgdGltZW91dFxuICogQHBhcmFtIHtBbnkqfSBjdXN0b20gZXJyb3IgbWVzc2FnZSBvciBFcnJvciBvYmplY3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpZiBpdCBpc1xuICogZnVsZmlsbGVkIGJlZm9yZSB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICovXG5RLnRpbWVvdXQgPSBmdW5jdGlvbiAob2JqZWN0LCBtcywgZXJyb3IpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRpbWVvdXQobXMsIGVycm9yKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIGVycm9yKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZXJyb3IgfHwgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvciB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIik7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgIH0sIGRlZmVycmVkLm5vdGlmeSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5RLmRlbGF5ID0gZnVuY3Rpb24gKG9iamVjdCwgdGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUShvYmplY3QpLmRlbGF5KHRpbWVvdXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgYXMgYW4gYXJyYXksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiAgICAgIFEubmZhcHBseShGUy5yZWFkRmlsZSwgW19fZmlsZW5hbWVdKVxuICogICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogICAgICB9KVxuICpcbiAqL1xuUS5uZmFwcGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBpbmRpdmlkdWFsbHksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mY2FsbChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSlcbiAqIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiB9KVxuICpcbiAqL1xuUS5uZmNhbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIGEgTm9kZUpTIGNvbnRpbnVhdGlvbiBwYXNzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnRcbiAqIHZlcnNpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mYmluZChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSkoXCJ1dGYtOFwiKVxuICogLnRoZW4oY29uc29sZS5sb2cpXG4gKiAuZG9uZSgpXG4gKi9cblEubmZiaW5kID1cblEuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCB3cmFwIGFuIHVuZGVmaW5lZCBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgUShjYWxsYmFjaykuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmJpbmQgPVxuUHJvbWlzZS5wcm90b3R5cGUuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5kZW5vZGVpZnkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cblEubmJpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc3AsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUShib3VuZCkuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uYmluZCA9IGZ1bmN0aW9uICgvKnRoaXNwLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMCk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLm5iaW5kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2sgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEubnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ucG9zdChuYW1lLCBhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUubnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MgfHwgW10pO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjaywgZm9yd2FyZGluZyB0aGUgZ2l2ZW4gdmFyaWFkaWMgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGFyZ3VtZW50LlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIC4uLmFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrIHdpbGxcbiAqIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5RLm5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblByb21pc2UucHJvdG90eXBlLm5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBJZiBhIGZ1bmN0aW9uIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBib3RoIE5vZGUgY29udGludWF0aW9uLXBhc3Npbmctc3R5bGUgYW5kXG4gKiBwcm9taXNlLXJldHVybmluZy1zdHlsZSwgaXQgY2FuIGVuZCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBjaGFpbiB3aXRoXG4gKiBgbm9kZWlmeShub2RlYmFjaylgLCBmb3J3YXJkaW5nIHRoZSBvcHRpb25hbCBub2RlYmFjayBhcmd1bWVudC4gIElmIHRoZSB1c2VyXG4gKiBlbGVjdHMgdG8gdXNlIGEgbm9kZWJhY2ssIHRoZSByZXN1bHQgd2lsbCBiZSBzZW50IHRoZXJlLiAgSWYgdGhleSBkbyBub3RcbiAqIHBhc3MgYSBub2RlYmFjaywgdGhleSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBwcm9taXNlLlxuICogQHBhcmFtIG9iamVjdCBhIHJlc3VsdCAob3IgYSBwcm9taXNlIGZvciBhIHJlc3VsdClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5vZGViYWNrIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFja1xuICogQHJldHVybnMgZWl0aGVyIHRoZSBwcm9taXNlIG9yIG5vdGhpbmdcbiAqL1xuUS5ub2RlaWZ5ID0gbm9kZWlmeTtcbmZ1bmN0aW9uIG5vZGVpZnkob2JqZWN0LCBub2RlYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdCkubm9kZWlmeShub2RlYmFjayk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2spIHtcbiAgICBpZiAobm9kZWJhY2spIHtcbiAgICAgICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblEubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlEubm9Db25mbGljdCBvbmx5IHdvcmtzIHdoZW4gUSBpcyB1c2VkIGFzIGEgZ2xvYmFsXCIpO1xufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcS9xLmpzIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJpbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBRIGZyb20gJ3EnO1xuaW1wb3J0IEFsZ29saWEgZnJvbSAnYWxnb2xpYXNlYXJjaCc7XG5cbmxvZy5zZXRMZXZlbCgnZGVidWcnKVxuXG5jb25zdCBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgXCJcXFxcJCZcIik7XG59XG5cbmNvbnN0IFNlYXJjaCA9IHtcbiAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICBsb2cudHJhY2Uob3B0aW9ucyk7XG4gICAgY29uc3QgQWxnb2xpYUNsaWVudCA9IEFsZ29saWEob3B0aW9ucy5hcHBJRCwgb3B0aW9ucy5hcGlLZXksIHtcbiAgICAgIHByb3RvY29sOiAnaHR0cHM6J1xuICAgIH0pXG4gICAgY29uc3QgQWxnb2xpYUluZGV4ID0gQWxnb2xpYUNsaWVudC5pbml0SW5kZXgob3B0aW9ucy5pbmRleCk7XG5cbiAgICBjb25zdCBhZHZhbmNlZFNlYXJjaCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgQWxnb2xpYUluZGV4LmNsZWFyQ2FjaGUoKVxuICAgICAgQWxnb2xpYUluZGV4LnNlYXJjaChwYXJhbXMsIGZ1bmN0aW9uKGUsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBsb2cudHJhY2UoZSk7XG4gICAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaExpc3RJdGVtQ2FyZHMoY29udGVudC5oaXRzKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29udGVudC5oaXRzLmZvckVhY2goZnVuY3Rpb24oaGl0KSB7XG4gICAgICAgICAgICAgIGlmICghaGl0LmRlc2NyaXB0aW9uKSBoaXQuZGVzY3JpcHRpb24gPSBoaXQuc2VudGVuY2UgfHwgaGl0LnRleHRcbiAgICAgICAgICAgICAgZGVsZXRlIGhpdC5zZW50ZW5jZVxuICAgICAgICAgICAgICBkZWxldGUgaGl0LnRleHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBkLnJlc29sdmUoY29udGVudC5oaXRzKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IHNlYXJjaENhcmRzID0gZnVuY3Rpb24odXNlcklELCBzZWFyY2hUZXh0LCBoaXRzUGVyUGFnZSkge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBxdWVyeTogc2VhcmNoVGV4dCxcbiAgICAgICAgZmlsdGVyczogdXNlcklELmxlbmd0aCA/ICd1c2VySUQ6ICcgKyB1c2VySUQgOiAnJyxcbiAgICAgICAgaGl0c1BlclBhZ2U6IGhpdHNQZXJQYWdlIHx8IG51bGxcbiAgICAgIH07XG4gICAgICBsb2cudHJhY2UocGFyYW1zKTtcbiAgICAgIGFkdmFuY2VkU2VhcmNoKHBhcmFtcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGhpdHMpIHtcbiAgICAgICAgbG9nLnRyYWNlKGhpdHMpO1xuICAgICAgICBkLnJlc29sdmUoaGl0cylcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSk7XG4gICAgICB9KVxuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGZldGNoTGlzdEl0ZW1DYXJkcyA9IGZ1bmN0aW9uKGNhcmRzKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAgICAgY2FyZHMuZm9yRWFjaChmdW5jdGlvbihjYXJkKSB7XG4gICAgICAgIGNhcmQubGlzdENhcmRzID0gW11cbiAgICAgICAgaWYgKGNhcmQubGlzdEl0ZW1zKSB7XG4gICAgICAgICAgY2FyZC5saXN0SXRlbXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICAgICAgICBjb25zdCBwID0gUS5kZWZlcigpXG4gICAgICAgICAgICBnZXRDYXJkKGtleSkgLy8gRG8gd2UgbmVlZCB0byBub3RpZnkgdGhlIGNhcmQgb3IgcHJvdmlkZSBjYWxsYmFja3MgZXRjIGhlcmU/XG4gICAgICAgICAgICAvLyBwcm9taXNlcy5wdXNoKHAucHJvbWlzZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgbG9nLnRyYWNlKHByb21pc2VzKTtcbiAgICAgIFEuYWxsU2V0dGxlZChwcm9taXNlcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGNhcmRzKTtcbiAgICAgICAgZC5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBsb2cudHJhY2UoZSk7XG4gICAgICAgIGQucmVqZWN0KGUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGdldENhcmQgPSBmdW5jdGlvbihvYmplY3RJRCkge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgQWxnb2xpYUluZGV4LmdldE9iamVjdChvYmplY3RJRCwgZnVuY3Rpb24oZSwgY29udGVudCkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGxvZy50cmFjZShlKTtcbiAgICAgICAgICBkLnJlamVjdChlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGQucmVzb2x2ZShjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBkLnByb21pc2VcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb3VuZFNlYXJjaCA9IGZ1bmN0aW9uKHVzZXJJRCwgc2VhcmNoVGV4dCkge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgY29uc3QgbWF4TGVuZ3RoID0gNDAwO1xuICAgICAgY29uc3Qgc2VhcmNoVGV4dEFycmF5ID0gW107XG4gICAgICBjb25zdCBoaXRzUGVyUGFnZSA9IE1hdGgubWluKE1hdGgubWF4KE1hdGguY2VpbCgxMCAvIChzZWFyY2hUZXh0Lmxlbmd0aCAvIG1heExlbmd0aCkpLCAzKSwgMTIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWFyY2hUZXh0Lmxlbmd0aDsgaSArPSBtYXhMZW5ndGgpIHtcbiAgICAgICAgc2VhcmNoVGV4dEFycmF5LnB1c2goc2VhcmNoVGV4dC5zdWJzdHJpbmcoaSwgaSttYXhMZW5ndGgpKVxuICAgICAgfVxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBzZWFyY2hUZXh0QXJyYXkubWFwKGZ1bmN0aW9uKHQsIGopIHtcbiAgICAgICAgcmV0dXJuIHNlYXJjaENhcmRzKHVzZXJJRCwgdCwgaGl0c1BlclBhZ2UpO1xuICAgICAgfSk7XG4gICAgICBRLmFsbFNldHRsZWQocHJvbWlzZXMpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW10uY29uY2F0LmFwcGx5KFtdLCByZXN1bHRzLm1hcChmdW5jdGlvbihyKSB7cmV0dXJuIHIudmFsdWV9KSk7XG4gICAgICAgIHJlc3VsdHMgPSByZW1vdmVEdXBsaWNhdGVzKHJlc3VsdHMsICdvYmplY3RJRCcpXG4gICAgICAgIGxvZy50cmFjZShyZXN1bHRzKTtcbiAgICAgICAgZC5yZXNvbHZlKHJlc3VsdHMpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbG9nLnRyYWNlKGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgcmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uKG9yaWdpbmFsQXJyYXksIG9iaktleSkge1xuICAgICAgdmFyIHRyaW1tZWRBcnJheSA9IFtdLCB2YWx1ZXMgPSBbXSwgdmFsdWU7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3JpZ2luYWxBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9yaWdpbmFsQXJyYXlbaV1bb2JqS2V5XTtcbiAgICAgICAgaWYodmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgIHRyaW1tZWRBcnJheS5wdXNoKG9yaWdpbmFsQXJyYXlbaV0pO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyaW1tZWRBcnJheTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGVja1BhZ2VIaXQgPSBmdW5jdGlvbihwYWdlRGF0YSwgcmVzdWx0cykge1xuICAgICAgLy9Ob3QgeWV0IGFjY291bnRpbmcgZm9yIGNhcGl0YWxzXG4gICAgICBjb25zdCBib3JpbmdXb3JkcyA9IFtcbiAgICAgICAgJ2Zhdm91cml0ZScsXG4gICAgICAgICd3b3JsZCcsXG4gICAgICAgICduYW1lJyxcbiAgICAgICAgJ3RoaXMnLFxuICAgICAgICAncGxhbicsXG4gICAgICAgICduZWVkJyxcbiAgICAgICAgJ2Jlc3QnLFxuICAgICAgICAnbGlrZScsXG4gICAgICAgICd0aGUnLFxuICAgICAgICAnYXJlJyxcbiAgICAgICAgJ2lzJyxcbiAgICAgICAgJ215JyxcbiAgICAgICAgJ215JyxcbiAgICAgIF1cbiAgICAgIGNvbnN0IGhpdHMgPSBbXTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbihyZXN1bHQsIGkpIHtcbiAgICAgICAgbG9nLnRyYWNlKCctLS0nKTtcbiAgICAgICAgbG9nLnRyYWNlKGkpO1xuICAgICAgICB2YXIgY291bnQgPSBbXTtcbiAgICAgICAgcmVzdWx0LmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgaWYgKHBhZ2VEYXRhLnBhZ2VUZXh0LmluZGV4T2YoYy52YWx1ZSkgPiAtMVxuICAgICAgICAgICYmIGhpdHMuaW5kZXhPZihyZXN1bHQub2JqZWN0SUQpID09IC0xXG4gICAgICAgICAgJiYgYy52YWx1ZSAmJiBjLnZhbHVlLmxlbmd0aCA+IDNcbiAgICAgICAgICAmJiBib3JpbmdXb3Jkcy5pbmRleE9mKGMudmFsdWUpID09IC0xXG4gICAgICAgICAgJiYgY291bnQuaW5kZXhPZihjLnZhbHVlKSA9PSAtMSkge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGMudmFsdWUpO1xuICAgICAgICAgICAgY291bnQucHVzaChjLnZhbHVlKTtcbiAgICAgICAgICAgIChjLnZhbHVlLm1hdGNoKC8gL2cpIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjb3VudC5wdXNoKGMudmFsdWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGlmIChjb3VudC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgbG9nLnRyYWNlKHJlc3VsdC5zZW50ZW5jZSk7XG4gICAgICAgICAgaGl0cy5wdXNoKHJlc3VsdClcbiAgICAgICAgfVxuICAgICAgICBsb2cudHJhY2UoJy0tLScpO1xuICAgICAgfSlcblxuICAgICAgLy8gcmV0dXJuIGhpdHM7XG4gICAgICAvL0ZvcmNlIG5vIGhpdHNcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGVja1BhZ2VSZW1pbmRlciA9IGZ1bmN0aW9uKHVzZXJJRCwgcGFnZURhdGEpIHtcbiAgICAgIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgICAgIGxvZy50cmFjZShwYWdlRGF0YSk7XG4gICAgICBjb25zdCB1cmxSb290ID0gcGFnZURhdGEuYmFzZVVybC5yZXBsYWNlKCcuY29tJywnJykucmVwbGFjZSgnLmNvLnVrJywnJykucmVwbGFjZSgnLm9yZycsJycpXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIHF1ZXJ5OiAnJyxcbiAgICAgICAgZmlsdGVyczogJ3VzZXJJRDogJyArIHVzZXJJRCArICcgQU5EICh0cmlnZ2VyVXJsOiAnICsgdXJsUm9vdCArICcgT1IgdHJpZ2dlclVybDogJyArIHVybFJvb3QgKyAnLmNvbSBPUiB0cmlnZ2VyVXJsOiAnICsgdXJsUm9vdCArICcuY28udWsgT1IgdHJpZ2dlclVybDogJyArIHVybFJvb3QgKyAnLm9yZyBPUiB0cmlnZ2VyVVJMOiAnICsgdXJsUm9vdCArICcgT1IgdHJpZ2dlclVSTDogJyArIHVybFJvb3QgKyAnLmNvbSBPUiB0cmlnZ2VyVVJMOiAnICsgdXJsUm9vdCArICcuY28udWsgT1IgdHJpZ2dlclVSTDogJyArIHVybFJvb3QgKyAnLm9yZyknXG4gICAgICB9O1xuICAgICAgbG9nLnRyYWNlKCdwYXJhbXMnKTtcbiAgICAgIGxvZy50cmFjZShwYXJhbXMpO1xuICAgICAgYWR2YW5jZWRTZWFyY2gocGFyYW1zKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVtaW5kZXJzKSB7XG4gICAgICAgIGxvZy50cmFjZSgncmVtaW5kZXJzJyk7XG4gICAgICAgIGxvZy50cmFjZShyZW1pbmRlcnMpO1xuICAgICAgICBkLnJlc29sdmUocmVtaW5kZXJzKVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBkLnJlamVjdChlKVxuICAgICAgfSlcbiAgICAgIHJldHVybiBkLnByb21pc2VcbiAgICB9XG5cbiAgICBjb25zdCBnZXRQYWdlUmVzdWx0cyA9IGZ1bmN0aW9uKHVzZXJJRCwgcGFnZURhdGEsIGFsbFVzZXJDYXJkcykge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgLy8gR2V0cyBhbGwgcmVzdWx0c1xuICAgICAgY29uc3QgcGFnZVJlc3VsdHMgPSB7XG4gICAgICAgIGhpdHM6IFtdLFxuICAgICAgICByZW1pbmRlcnM6IFtdLFxuICAgICAgICBwaW5nczogW10sXG4gICAgICAgIG1lbW9yaWVzOiBbXSxcbiAgICAgIH07XG4gICAgICBsb2cudHJhY2UodXNlcklELCBwYWdlRGF0YSk7XG4gICAgICBjb25zdCBnbWFpbEJvcmluZ1BocmFzZXMgPSBbXG4gICAgICAgICdTa2lwIHRvIGNvbnRlbnQnLFxuICAgICAgICAnVXNpbmcnLFxuICAgICAgICAnd2l0aCBzY3JlZW4gcmVhZGVycycsXG4gICAgICAgICdTZWFyY2gnLFxuICAgICAgICAnTWFpbCcsXG4gICAgICAgICdDT01QT1NFJyxcbiAgICAgICAgJ0xhYmVscycsXG4gICAgICAgICdJbmJveCcsXG4gICAgICAgICdTdGFycmVkJyxcbiAgICAgICAgJ1NlbnQgTWFpbCcsXG4gICAgICAgICdEcmFmdHMnLFxuICAgICAgICAnTW9yZScsXG4gICAgICAgICctLS0tLS0tLS0tIEZvcndhcmRlZCBtZXNzYWdlIC0tLS0tLS0tLS0nLFxuICAgICAgICAnRnJvbTogJyxcbiAgICAgICAgJ0RhdGU6ICcsXG4gICAgICAgICdTdWJqZWN0OiAnLFxuICAgICAgICAnVG86ICcsXG4gICAgICAgICdDbGljayBoZXJlIHRvIFJlcGx5IG9yIEZvcndhcmQnLFxuICAgICAgICAnR0InLFxuICAgICAgICAnR0IgdXNlZCcsXG4gICAgICAgICdNYW5hZ2UnLFxuICAgICAgICAnUHJvZ3JhbSBQb2xpY2llcycsXG4gICAgICAgICdQb3dlcmVkIGJ5IEdvb2dsZScsXG4gICAgICAgICdMYXN0IGFjY291bnQgYWN0aXZpdHk6JyxcbiAgICAgICAgJ2hvdXIgYWdvJyxcbiAgICAgICAgJ2hvdXJzIGFnbycsXG4gICAgICAgICdEZXRhaWxzJyxcbiAgICAgIF1cbiAgICAgIGdtYWlsQm9yaW5nUGhyYXNlcy5mb3JFYWNoKGZ1bmN0aW9uKHBocmFzZSkge1xuICAgICAgICBwYWdlRGF0YS5wYWdlVGV4dCA9IHBhZ2VEYXRhLnBhZ2VUZXh0LnJlcGxhY2UocGhyYXNlLCAnJylcbiAgICAgIH0pXG4gICAgICBjb25zdCBib3JpbmdXb3JkcyA9IFtcbiAgICAgICAgXCJpXCIsXG4gICAgICAgIFwiYVwiLFxuICAgICAgICBcIm9mXCIsXG4gICAgICAgIFwibWVcIixcbiAgICAgICAgXCJteVwiLFxuICAgICAgICBcImlzXCIsXG4gICAgICAgIFwiaW1cIixcbiAgICAgICAgXCJzb1wiLFxuICAgICAgICBcImFsbFwiLFxuICAgICAgICBcImdldFwiLFxuICAgICAgICBcImhvd1wiLFxuICAgICAgICBcIm5ld1wiLFxuICAgICAgICBcIm91dFwiLFxuICAgICAgICBcInRoZVwiLFxuICAgICAgICBcInVzZVwiLFxuICAgICAgICBcImJlc3RcIixcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIFwibmV4dFwiLFxuICAgICAgICBcInRha2VcIixcbiAgICAgICAgXCJ3aGF0XCIsXG4gICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAgXCJzb21ldGhpbmdcIixcbiAgICAgIF1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWxsV29yZHMgPSBbXVxuICAgICAgICBhbGxVc2VyQ2FyZHMuZm9yRWFjaChmdW5jdGlvbihjYXJkKSB7XG4gICAgICAgICAgdmFyIHNjb3JlID0gMFxuICAgICAgICAgIGNhcmQuY29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uKGVudGl0eSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gU3RyaW5nKGVudGl0eS52YWx1ZSlcbiAgICAgICAgICAgIGlmIChib3JpbmdXb3Jkcy5pbmRleE9mKHZhbC50b0xvd2VyQ2FzZSgpKSA9PSAtMSAmJiB2YWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh2YWwpLCBcImdpXCIpO1xuICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSAocGFnZURhdGEucGFnZVRleHQubWF0Y2gocmVnKSB8fCBbXSkubGVuZ3RoICogdmFsLmxlbmd0aFxuICAgICAgICAgICAgICBzY29yZSArPSBwb2ludHNcbiAgICAgICAgICAgICAgaWYgKHBvaW50cykge1xuICAgICAgICAgICAgICAgIGlmIChhbGxXb3Jkcy5pbmRleE9mKHZhbCkgPT0gLTEpIGFsbFdvcmRzLnB1c2godmFsKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAoc2NvcmUgPiAxMDApIHtcbiAgICAgICAgICAgIHBhZ2VSZXN1bHRzLmhpdHMucHVzaChjYXJkKVxuICAgICAgICAgIH0gZWxzZSBpZiAoc2NvcmUgPiAwKSB7XG4gICAgICAgICAgICBwYWdlUmVzdWx0cy5tZW1vcmllcy5wdXNoKGNhcmQpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBsb2cuZGVidWcoYWxsV29yZHMpXG5cbiAgICAgICAgcGFnZVJlc3VsdHMucmVtaW5kZXJzID0gYWxsVXNlckNhcmRzLmZpbHRlcihmdW5jdGlvbihjYXJkKSB7XG4gICAgICAgICAgY29uc3QgdXJsUm9vdCA9IHBhZ2VEYXRhLmJhc2VVcmwucmVwbGFjZSgnLmNvbScsJycpLnJlcGxhY2UoJy5jby51aycsJycpLnJlcGxhY2UoJy5vcmcnLCcnKVxuICAgICAgICAgIGxvZy5pbmZvKGNhcmQudHJpZ2dlclVSTClcbiAgICAgICAgICByZXR1cm4gY2FyZC50cmlnZ2VyVVJMICYmIChjYXJkLnRyaWdnZXJVUkwuaW5kZXhPZih1cmxSb290KSA+IC0xIHx8IGNhcmQudHJpZ2dlclVSTC5pbmRleE9mKHVybFJvb3QpID4gLTEpXG4gICAgICAgIH0pXG4gICAgICAgIHBhZ2VSZXN1bHRzLnBpbmdzID0gcGFnZVJlc3VsdHMucmVtaW5kZXJzIC8vLmNvbmNhdChwYWdlUmVzdWx0cy5oaXRzKVxuICAgICAgICBwYWdlUmVzdWx0cy5waW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHBpbmcpIHsgcGluZy5oaWdobGlnaHQgPSB0cnVlIH0pXG4gICAgICAgIC8vIHBhZ2VSZXN1bHRzLm1lbW9yaWVzID0gcGFnZVJlc3VsdHMucGluZ3MuY29uY2F0KHBhZ2VSZXN1bHRzLm1lbW9yaWVzKVxuICAgICAgICBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHJlbW92ZUR1cGxpY2F0ZXMocGFnZVJlc3VsdHMubWVtb3JpZXMsICdvYmplY3RJRCcpXG4gICAgICAgIGxvZy5kZWJ1ZyhwYWdlUmVzdWx0cyk7XG4gICAgICAgIGQucmVzb2x2ZShwYWdlUmVzdWx0cylcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsb2cuZXJyb3IoZSlcbiAgICAgIH1cblxuICAgICAgLy8gY29tcG91bmRTZWFyY2godXNlcklELCBwYWdlRGF0YS5wYWdlVGV4dClcbiAgICAgIC8vIC50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIC8vICAgbG9nLnRyYWNlKDEpO1xuICAgICAgLy8gICBsb2cudHJhY2UocmVzdWx0cyk7XG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLm1lbW9yaWVzID0gcmVzdWx0cztcbiAgICAgIC8vICAgLy8gQ2hlY2tzIHdoZXRoZXIgYSBwaW5nIGlzIHJlcXVpcmVkXG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLmhpdHMgPSBjaGVja1BhZ2VIaXQocGFnZURhdGEsIHJlc3VsdHMpO1xuICAgICAgLy8gICBsb2cudHJhY2UoMik7XG4gICAgICAvLyAgIGxvZy50cmFjZShwYWdlUmVzdWx0cy5oaXRzKTtcbiAgICAgIC8vICAgcmV0dXJuIGNoZWNrUGFnZVJlbWluZGVyKHVzZXJJRCwgcGFnZURhdGEpXG4gICAgICAvLyB9KS50aGVuKGZ1bmN0aW9uKHJlbWluZGVycykge1xuICAgICAgLy8gICBwYWdlUmVzdWx0cy5yZW1pbmRlcnMgPSByZW1pbmRlcnM7XG4gICAgICAvLyAgIGxvZy50cmFjZSgzKTtcbiAgICAgIC8vICAgbG9nLnRyYWNlKHBhZ2VSZXN1bHRzLnJlbWluZGVycyk7XG4gICAgICAvLyAgIC8vIFJldHVybnMgcmVzdWx0cyBwbHVzIHBpbmdcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMucGluZ3MgPSBwYWdlUmVzdWx0cy5yZW1pbmRlcnMuY29uY2F0KHBhZ2VSZXN1bHRzLmhpdHMpXG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLnBpbmdzLmZvckVhY2goZnVuY3Rpb24ocGluZykge1xuICAgICAgLy8gICAgIGxvZy50cmFjZShwaW5nLm9iamVjdElEKTtcbiAgICAgIC8vICAgICBwaW5nLmhpZ2hsaWdodCA9IHRydWU7XG4gICAgICAvLyAgIH0pXG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLm1lbW9yaWVzID0gcGFnZVJlc3VsdHMucGluZ3MuY29uY2F0KHBhZ2VSZXN1bHRzLm1lbW9yaWVzKVxuICAgICAgLy8gICBwYWdlUmVzdWx0cy5tZW1vcmllcyA9IHJlbW92ZUR1cGxpY2F0ZXMocGFnZVJlc3VsdHMubWVtb3JpZXMsICdvYmplY3RJRCcpXG4gICAgICAvLyAgIGxvZy50cmFjZShwYWdlUmVzdWx0cyk7XG4gICAgICAvLyAgIGQucmVzb2x2ZShwYWdlUmVzdWx0cylcbiAgICAgIC8vIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vICAgbG9nLnRyYWNlKGUpO1xuICAgICAgLy8gICBkLnJlamVjdChlKVxuICAgICAgLy8gfSlcbiAgICAgIHJldHVybiBkLnByb21pc2VcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VkU2VhcmNoID0gYWR2YW5jZWRTZWFyY2g7XG4gICAgdGhpcy5zZWFyY2hDYXJkcyA9IHNlYXJjaENhcmRzO1xuICAgIHRoaXMuY29tcG91bmRTZWFyY2ggPSBjb21wb3VuZFNlYXJjaDtcbiAgICB0aGlzLmdldFBhZ2VSZXN1bHRzID0gZ2V0UGFnZVJlc3VsdHM7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWFyY2g7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvcGx1Z2lucy9leHBsYWFpbi1zZWFyY2guanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBBbGdvbGlhU2VhcmNoID0gcmVxdWlyZSgnLi4vLi4vQWxnb2xpYVNlYXJjaC5qcycpO1xudmFyIGNyZWF0ZUFsZ29saWFzZWFyY2ggPSByZXF1aXJlKCcuLi9jcmVhdGVBbGdvbGlhc2VhcmNoLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQWxnb2xpYXNlYXJjaChBbGdvbGlhU2VhcmNoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9idWlsZHMvYWxnb2xpYXNlYXJjaC5qcyIsIm1vZHVsZS5leHBvcnRzID0gQWxnb2xpYVNlYXJjaDtcblxudmFyIEluZGV4ID0gcmVxdWlyZSgnLi9JbmRleC5qcycpO1xudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlLmpzJyk7XG52YXIgZGVwcmVjYXRlZE1lc3NhZ2UgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWRNZXNzYWdlLmpzJyk7XG52YXIgQWxnb2xpYVNlYXJjaENvcmUgPSByZXF1aXJlKCcuL0FsZ29saWFTZWFyY2hDb3JlLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbmZ1bmN0aW9uIEFsZ29saWFTZWFyY2goKSB7XG4gIEFsZ29saWFTZWFyY2hDb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXRzKEFsZ29saWFTZWFyY2gsIEFsZ29saWFTZWFyY2hDb3JlKTtcblxuLypcbiAqIERlbGV0ZSBhbiBpbmRleFxuICpcbiAqIEBwYXJhbSBpbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXggdG8gZGVsZXRlXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZGVsZXRlSW5kZXggPSBmdW5jdGlvbihpbmRleE5hbWUsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhOYW1lKSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIE1vdmUgYW4gZXhpc3RpbmcgaW5kZXguXG4gKiBAcGFyYW0gc3JjSW5kZXhOYW1lIHRoZSBuYW1lIG9mIGluZGV4IHRvIGNvcHkuXG4gKiBAcGFyYW0gZHN0SW5kZXhOYW1lIHRoZSBuZXcgaW5kZXggbmFtZSB0aGF0IHdpbGwgY29udGFpbnMgYSBjb3B5IG9mXG4gKiBzcmNJbmRleE5hbWUgKGRlc3RpbmF0aW9uIHdpbGwgYmUgb3ZlcnJpdGVuIGlmIGl0IGFscmVhZHkgZXhpc3QpLlxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSB0YXNrIElEXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLm1vdmVJbmRleCA9IGZ1bmN0aW9uKHNyY0luZGV4TmFtZSwgZHN0SW5kZXhOYW1lLCBjYWxsYmFjaykge1xuICB2YXIgcG9zdE9iaiA9IHtcbiAgICBvcGVyYXRpb246ICdtb3ZlJywgZGVzdGluYXRpb246IGRzdEluZGV4TmFtZVxuICB9O1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChzcmNJbmRleE5hbWUpICsgJy9vcGVyYXRpb24nLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb3B5IGFuIGV4aXN0aW5nIGluZGV4LlxuICogQHBhcmFtIHNyY0luZGV4TmFtZSB0aGUgbmFtZSBvZiBpbmRleCB0byBjb3B5LlxuICogQHBhcmFtIGRzdEluZGV4TmFtZSB0aGUgbmV3IGluZGV4IG5hbWUgdGhhdCB3aWxsIGNvbnRhaW5zIGEgY29weVxuICogb2Ygc3JjSW5kZXhOYW1lIChkZXN0aW5hdGlvbiB3aWxsIGJlIG92ZXJyaXRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0KS5cbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgdGFzayBJRFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5jb3B5SW5kZXggPSBmdW5jdGlvbihzcmNJbmRleE5hbWUsIGRzdEluZGV4TmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgb3BlcmF0aW9uOiAnY29weScsIGRlc3RpbmF0aW9uOiBkc3RJbmRleE5hbWVcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjSW5kZXhOYW1lKSArICcvb3BlcmF0aW9uJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGxhc3QgbG9nIGVudHJpZXMuXG4gKiBAcGFyYW0gb2Zmc2V0IFNwZWNpZnkgdGhlIGZpcnN0IGVudHJ5IHRvIHJldHJpZXZlICgwLWJhc2VkLCAwIGlzIHRoZSBtb3N0IHJlY2VudCBsb2cgZW50cnkpLlxuICogQHBhcmFtIGxlbmd0aCBTcGVjaWZ5IHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIHJldHJpZXZlIHN0YXJ0aW5nXG4gKiBhdCBvZmZzZXQuIE1heGltdW0gYWxsb3dlZCB2YWx1ZTogMTAwMC5cbiAqIEBwYXJhbSB0eXBlIFNwZWNpZnkgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gcmV0cmlldmUgc3RhcnRpbmdcbiAqIGF0IG9mZnNldC4gTWF4aW11bSBhbGxvd2VkIHZhbHVlOiAxMDAwLlxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSB0YXNrIElEXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmdldExvZ3MgPSBmdW5jdGlvbihvZmZzZXQsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgdmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpO1xuICB2YXIgcGFyYW1zID0ge307XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnb2JqZWN0Jykge1xuICAgIC8vIGdldExvZ3MocGFyYW1zKVxuICAgIHBhcmFtcyA9IGNsb25lKG9mZnNldCk7XG4gICAgY2FsbGJhY2sgPSBsZW5ndGg7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZ2V0TG9ncyhbY2JdKVxuICAgIGNhbGxiYWNrID0gb2Zmc2V0O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGdldExvZ3MoMSwgW2NiKV1cbiAgICBjYWxsYmFjayA9IGxlbmd0aDtcbiAgICBwYXJhbXMub2Zmc2V0ID0gb2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIGdldExvZ3MoMSwgMiwgW2NiXSlcbiAgICBwYXJhbXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHBhcmFtcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICBpZiAocGFyYW1zLm9mZnNldCA9PT0gdW5kZWZpbmVkKSBwYXJhbXMub2Zmc2V0ID0gMDtcbiAgaWYgKHBhcmFtcy5sZW5ndGggPT09IHVuZGVmaW5lZCkgcGFyYW1zLmxlbmd0aCA9IDEwO1xuXG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9sb2dzPycgKyB0aGlzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLCAnJyksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuICogTGlzdCBhbGwgZXhpc3RpbmcgaW5kZXhlcyAocGFnaW5hdGVkKVxuICpcbiAqIEBwYXJhbSBwYWdlIFRoZSBwYWdlIHRvIHJldHJpZXZlLCBzdGFydGluZyBhdCAwLlxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIGluZGV4IGxpc3RcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUubGlzdEluZGV4ZXMgPSBmdW5jdGlvbihwYWdlLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gJyc7XG5cbiAgaWYgKHBhZ2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgcGFnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFnZTtcbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMgPSAnP3BhZ2U9JyArIHBhZ2U7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcycgKyBwYXJhbXMsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuICogR2V0IHRoZSBpbmRleCBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqXG4gKiBAcGFyYW0gaW5kZXhOYW1lIHRoZSBuYW1lIG9mIGluZGV4XG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayB3aXRoIG9uZSBhcmd1bWVudCAodGhlIEluZGV4IGluc3RhbmNlKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5pbml0SW5kZXggPSBmdW5jdGlvbihpbmRleE5hbWUpIHtcbiAgcmV0dXJuIG5ldyBJbmRleCh0aGlzLCBpbmRleE5hbWUpO1xufTtcblxuLypcbiAqIEBkZXByZWNhdGVkIHVzZSBjbGllbnQubGlzdEFwaUtleXNcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUubGlzdFVzZXJLZXlzID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmxpc3RBcGlLZXlzKGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQubGlzdFVzZXJLZXlzKCknLCAnY2xpZW50Lmxpc3RBcGlLZXlzKCknKSk7XG5cbi8qXG4gKiBMaXN0IGFsbCBleGlzdGluZyBhcGkga2V5cyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgQUNMc1xuICpcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCBhcGkga2V5cyBsaXN0XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmxpc3RBcGlLZXlzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2tleXMnLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiAqIEBkZXByZWNhdGVkIHNlZSBjbGllbnQuZ2V0QXBpS2V5XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmdldFVzZXJLZXlBQ0wgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5nZXRBcGlLZXkoa2V5LCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmdldFVzZXJLZXlBQ0woKScsICdjbGllbnQuZ2V0QXBpS2V5KCknKSk7XG5cbi8qXG4gKiBHZXQgYW4gQVBJIGtleVxuICpcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgcmlnaHQgQVBJIGtleVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5nZXRBcGlLZXkgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9rZXlzLycgKyBrZXksXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuICogQGRlcHJlY2F0ZWQgc2VlIGNsaWVudC5kZWxldGVBcGlLZXlcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZGVsZXRlVXNlcktleSA9IGRlcHJlY2F0ZShmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmRlbGV0ZUFwaUtleShrZXksIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuZGVsZXRlVXNlcktleSgpJywgJ2NsaWVudC5kZWxldGVBcGlLZXkoKScpKTtcblxuLypcbiAqIERlbGV0ZSBhbiBleGlzdGluZyBBUEkga2V5XG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGRhdGUgb2YgZGVsZXRpb25cbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZGVsZXRlQXBpS2V5ID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEva2V5cy8nICsga2V5LFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gQGRlcHJlY2F0ZWQgc2VlIGNsaWVudC5hZGRBcGlLZXlcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuYWRkVXNlcktleSA9IGRlcHJlY2F0ZShmdW5jdGlvbihhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFkZEFwaUtleShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuYWRkVXNlcktleSgpJywgJ2NsaWVudC5hZGRBcGlLZXkoKScpKTtcblxuLypcbiAqIEFkZCBhIG5ldyBnbG9iYWwgQVBJIGtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjbHMgLSBUaGUgbGlzdCBvZiBBQ0wgZm9yIHRoaXMga2V5LiBEZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdFxuICogICBjYW4gY29udGFpbnMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKiAgICAgLSBzZWFyY2g6IGFsbG93IHRvIHNlYXJjaCAoaHR0cHMgYW5kIGh0dHApXG4gKiAgICAgLSBhZGRPYmplY3Q6IGFsbG93cyB0byBhZGQvdXBkYXRlIGFuIG9iamVjdCBpbiB0aGUgaW5kZXggKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBkZWxldGVPYmplY3QgOiBhbGxvd3MgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIG9iamVjdCAoaHR0cHMgb25seSlcbiAqICAgICAtIGRlbGV0ZUluZGV4IDogYWxsb3dzIHRvIGRlbGV0ZSBpbmRleCBjb250ZW50IChodHRwcyBvbmx5KVxuICogICAgIC0gc2V0dGluZ3MgOiBhbGxvd3MgdG8gZ2V0IGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICogICAgIC0gZWRpdFNldHRpbmdzIDogYWxsb3dzIHRvIGNoYW5nZSBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbm5hbCBwYXJhbWV0ZXJzIHRvIHNldCBmb3IgdGhlIGtleVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWxpZGl0eSAtIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBrZXkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgKDAgbWVhbnMgbm8gdGltZSBsaW1pdCBmb3IgdGhpcyBrZXkpXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5pbmRleGVzIC0gQWxsb3dlZCB0YXJnZXRlZCBpbmRleGVzIGZvciB0aGlzIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucmVmZXJlcnMgLSBBIGxpc3Qgb2YgYXV0aG9yaXplZCByZWZlcmVyc1xuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGFkZGVkIEFQSSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICogQGV4YW1wbGVcbiAqIGNsaWVudC5hZGRVc2VyS2V5KFsnc2VhcmNoJ10sIHtcbiAqICAgdmFsaWRpdHk6IDMwMCxcbiAqICAgbWF4UXVlcmllc1BlcklQUGVySG91cjogMjAwMCxcbiAqICAgbWF4SGl0c1BlclF1ZXJ5OiAzLFxuICogICBpbmRleGVzOiBbJ2ZydWl0cyddLFxuICogICBkZXNjcmlwdGlvbjogJ0VhdCB0aHJlZSBmcnVpdHMnLFxuICogICByZWZlcmVyczogWycqLmFsZ29saWEuY29tJ10sXG4gKiAgIHF1ZXJ5UGFyYW1ldGVyczoge1xuICogICAgIHRhZ0ZpbHRlcnM6IFsncHVibGljJ10sXG4gKiAgIH1cbiAqIH0pXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQWRkS2V5fEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuYWRkQXBpS2V5ID0gZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBjbGllbnQuYWRkQXBpS2V5KGFycmF5T2ZBY2xzWywgcGFyYW1zLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkoYWNscykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IG51bGw7XG4gIH1cblxuICB2YXIgcG9zdE9iaiA9IHtcbiAgICBhY2w6IGFjbHNcbiAgfTtcblxuICBpZiAocGFyYW1zKSB7XG4gICAgcG9zdE9iai52YWxpZGl0eSA9IHBhcmFtcy52YWxpZGl0eTtcbiAgICBwb3N0T2JqLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgPSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91cjtcbiAgICBwb3N0T2JqLm1heEhpdHNQZXJRdWVyeSA9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnk7XG4gICAgcG9zdE9iai5pbmRleGVzID0gcGFyYW1zLmluZGV4ZXM7XG4gICAgcG9zdE9iai5kZXNjcmlwdGlvbiA9IHBhcmFtcy5kZXNjcmlwdGlvbjtcblxuICAgIGlmIChwYXJhbXMucXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICBwb3N0T2JqLnF1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuX2dldFNlYXJjaFBhcmFtcyhwYXJhbXMucXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG4gICAgfVxuXG4gICAgcG9zdE9iai5yZWZlcmVycyA9IHBhcmFtcy5yZWZlcmVycztcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEva2V5cycsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgY2xpZW50LmFkZEFwaUtleSgpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmFkZFVzZXJLZXlXaXRoVmFsaWRpdHkgPSBkZXByZWNhdGUoZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hZGRBcGlLZXkoYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmFkZFVzZXJLZXlXaXRoVmFsaWRpdHkoKScsICdjbGllbnQuYWRkQXBpS2V5KCknKSk7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBjbGllbnQudXBkYXRlQXBpS2V5KClcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUudXBkYXRlVXNlcktleSA9IGRlcHJlY2F0ZShmdW5jdGlvbihrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMudXBkYXRlQXBpS2V5KGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LnVwZGF0ZVVzZXJLZXkoKScsICdjbGllbnQudXBkYXRlQXBpS2V5KCknKSk7XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIEFQSSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gYWNscyAtIFRoZSBsaXN0IG9mIEFDTCBmb3IgdGhpcyBrZXkuIERlZmluZWQgYnkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0XG4gKiAgIGNhbiBjb250YWlucyB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqICAgICAtIHNlYXJjaDogYWxsb3cgdG8gc2VhcmNoIChodHRwcyBhbmQgaHR0cClcbiAqICAgICAtIGFkZE9iamVjdDogYWxsb3dzIHRvIGFkZC91cGRhdGUgYW4gb2JqZWN0IGluIHRoZSBpbmRleCAoaHR0cHMgb25seSlcbiAqICAgICAtIGRlbGV0ZU9iamVjdCA6IGFsbG93cyB0byBkZWxldGUgYW4gZXhpc3Rpbmcgb2JqZWN0IChodHRwcyBvbmx5KVxuICogICAgIC0gZGVsZXRlSW5kZXggOiBhbGxvd3MgdG8gZGVsZXRlIGluZGV4IGNvbnRlbnQgKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBzZXR0aW5ncyA6IGFsbG93cyB0byBnZXQgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBlZGl0U2V0dGluZ3MgOiBhbGxvd3MgdG8gY2hhbmdlIGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9ubmFsIHBhcmFtZXRlcnMgdG8gc2V0IGZvciB0aGUga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbGlkaXR5IC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGtleSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCAoMCBtZWFucyBubyB0aW1lIGxpbWl0IGZvciB0aGlzIGtleSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91ciAtIE51bWJlciBvZiBBUEkgY2FsbHMgYWxsb3dlZCBmcm9tIGFuIElQIGFkZHJlc3MgcGVyIGhvdXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5IC0gTnVtYmVyIG9mIGhpdHMgdGhpcyBBUEkga2V5IGNhbiByZXRyaWV2ZSBpbiBvbmUgY2FsbFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmluZGV4ZXMgLSBBbGxvd2VkIHRhcmdldGVkIGluZGV4ZXMgZm9yIHRoaXMga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBmb3IgeW91ciBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5yZWZlcmVycyAtIEEgbGlzdCBvZiBhdXRob3JpemVkIHJlZmVyZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnF1ZXJ5UGFyYW1ldGVycyAtIEZvcmNlIHRoZSBrZXkgdG8gdXNlIHNwZWNpZmljIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgbW9kaWZpZWQgQVBJIGtleVxuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gKiBAZXhhbXBsZVxuICogY2xpZW50LnVwZGF0ZUFwaUtleSgnQVBJS0VZJywgWydzZWFyY2gnXSwge1xuICogICB2YWxpZGl0eTogMzAwLFxuICogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuICogICBtYXhIaXRzUGVyUXVlcnk6IDMsXG4gKiAgIGluZGV4ZXM6IFsnZnJ1aXRzJ10sXG4gKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4gKiAgIHJlZmVyZXJzOiBbJyouYWxnb2xpYS5jb20nXSxcbiAqICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4gKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiAqICAgfVxuICogfSlcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNVcGRhdGVJbmRleEtleXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLnVwZGF0ZUFwaUtleSA9IGZ1bmN0aW9uKGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBjbGllbnQudXBkYXRlQXBpS2V5KGtleSwgYXJyYXlPZkFjbHNbLCBwYXJhbXMsIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShhY2xzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwdXRPYmogPSB7XG4gICAgYWNsOiBhY2xzXG4gIH07XG5cbiAgaWYgKHBhcmFtcykge1xuICAgIHB1dE9iai52YWxpZGl0eSA9IHBhcmFtcy52YWxpZGl0eTtcbiAgICBwdXRPYmoubWF4UXVlcmllc1BlcklQUGVySG91ciA9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyO1xuICAgIHB1dE9iai5tYXhIaXRzUGVyUXVlcnkgPSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5O1xuICAgIHB1dE9iai5pbmRleGVzID0gcGFyYW1zLmluZGV4ZXM7XG4gICAgcHV0T2JqLmRlc2NyaXB0aW9uID0gcGFyYW1zLmRlc2NyaXB0aW9uO1xuXG4gICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIHB1dE9iai5xdWVyeVBhcmFtZXRlcnMgPSB0aGlzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycywgJycpO1xuICAgIH1cblxuICAgIHB1dE9iai5yZWZlcmVycyA9IHBhcmFtcy5yZWZlcmVycztcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9rZXlzLycgKyBrZXksXG4gICAgYm9keTogcHV0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBiYXRjaCBvZiBzZWFyY2ggcXVlcmllc1xuICogQGRlcHJlY2F0ZWQgdXNlIGNsaWVudC5zZWFyY2goKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5zdGFydFF1ZXJpZXNCYXRjaCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBzdGFydFF1ZXJpZXNCYXRjaERlcHJlY2F0ZWQoKSB7XG4gIHRoaXMuX2JhdGNoID0gW107XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LnN0YXJ0UXVlcmllc0JhdGNoKCknLCAnY2xpZW50LnNlYXJjaCgpJykpO1xuXG4vKipcbiAqIEFkZCBhIHNlYXJjaCBxdWVyeSBpbiB0aGUgYmF0Y2hcbiAqIEBkZXByZWNhdGVkIHVzZSBjbGllbnQuc2VhcmNoKClcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuYWRkUXVlcnlJbkJhdGNoID0gZGVwcmVjYXRlKGZ1bmN0aW9uIGFkZFF1ZXJ5SW5CYXRjaERlcHJlY2F0ZWQoaW5kZXhOYW1lLCBxdWVyeSwgYXJncykge1xuICB0aGlzLl9iYXRjaC5wdXNoKHtcbiAgICBpbmRleE5hbWU6IGluZGV4TmFtZSxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgcGFyYW1zOiBhcmdzXG4gIH0pO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5hZGRRdWVyeUluQmF0Y2goKScsICdjbGllbnQuc2VhcmNoKCknKSk7XG5cbi8qKlxuICogTGF1bmNoIHRoZSBiYXRjaCBvZiBxdWVyaWVzIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LlxuICogQGRlcHJlY2F0ZWQgdXNlIGNsaWVudC5zZWFyY2goKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5zZW5kUXVlcmllc0JhdGNoID0gZGVwcmVjYXRlKGZ1bmN0aW9uIHNlbmRRdWVyaWVzQmF0Y2hEZXByZWNhdGVkKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnNlYXJjaCh0aGlzLl9iYXRjaCwgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5zZW5kUXVlcmllc0JhdGNoKCknLCAnY2xpZW50LnNlYXJjaCgpJykpO1xuXG4vKipcbiAqIFBlcmZvcm0gd3JpdGUgb3BlcmF0aW9ucyBhY2Nyb3NzIG11bHRpcGxlIGluZGV4ZXMuXG4gKlxuICogVG8gcmVkdWNlIHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCBvbiBuZXR3b3JrIHJvdW5kIHRyaXBzLFxuICogeW91IGNhbiBjcmVhdGUsIHVwZGF0ZSwgb3IgZGVsZXRlIHNldmVyYWwgb2JqZWN0cyBpbiBvbmUgY2FsbCxcbiAqIHVzaW5nIHRoZSBiYXRjaCBlbmRwb2ludCAoYWxsIG9wZXJhdGlvbnMgYXJlIGRvbmUgaW4gdGhlIGdpdmVuIG9yZGVyKS5cbiAqXG4gKiBBdmFpbGFibGUgYWN0aW9uczpcbiAqICAgLSBhZGRPYmplY3RcbiAqICAgLSB1cGRhdGVPYmplY3RcbiAqICAgLSBwYXJ0aWFsVXBkYXRlT2JqZWN0XG4gKiAgIC0gcGFydGlhbFVwZGF0ZU9iamVjdE5vQ3JlYXRlXG4gKiAgIC0gZGVsZXRlT2JqZWN0XG4gKlxuICogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0luZGV4ZXNcbiAqIEBwYXJhbSAge09iamVjdFtdfSBvcGVyYXRpb25zIEFuIGFycmF5IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybVxuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gKiBAZXhhbXBsZVxuICogY2xpZW50LmJhdGNoKFt7XG4gKiAgIGFjdGlvbjogJ2FkZE9iamVjdCcsXG4gKiAgIGluZGV4TmFtZTogJ2NsaWVudHMnLFxuICogICBib2R5OiB7XG4gKiAgICAgbmFtZTogJ0JpbGwnXG4gKiAgIH1cbiAqIH0sIHtcbiAqICAgYWN0aW9uOiAndWRwYXRlT2JqZWN0JyxcbiAqICAgaW5kZXhOYW1lOiAnZnJ1aXRzJyxcbiAqICAgYm9keToge1xuICogICAgIG9iamVjdElEOiAnMjkxMzgnLFxuICogICAgIG5hbWU6ICdiYW5hbmEnXG4gKiAgIH1cbiAqIH1dLCBjYilcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuYmF0Y2ggPSBmdW5jdGlvbihvcGVyYXRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBjbGllbnQuYmF0Y2gob3BlcmF0aW9uc1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvcGVyYXRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvKi9iYXRjaCcsXG4gICAgYm9keToge1xuICAgICAgcmVxdWVzdHM6IG9wZXJhdGlvbnNcbiAgICB9LFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8vIGVudmlyb25tZW50IHNwZWNpZmljIG1ldGhvZHNcbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRlc3Ryb3kgPSBub3RJbXBsZW1lbnRlZDtcbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmVuYWJsZVJhdGVMaW1pdEZvcndhcmQgPSBub3RJbXBsZW1lbnRlZDtcbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRpc2FibGVSYXRlTGltaXRGb3J3YXJkID0gbm90SW1wbGVtZW50ZWQ7XG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS51c2VTZWN1cmVkQVBJS2V5ID0gbm90SW1wbGVtZW50ZWQ7XG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kaXNhYmxlU2VjdXJlZEFQSUtleSA9IG5vdEltcGxlbWVudGVkO1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZ2VuZXJhdGVTZWN1cmVkQXBpS2V5ID0gbm90SW1wbGVtZW50ZWQ7XG5cbmZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKCkge1xuICB2YXIgbWVzc2FnZSA9ICdOb3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5cXG4nICtcbiAgICAnSWYgeW91IGZlZWwgdGhpcyBpcyBhIG1pc3Rha2UsIHdyaXRlIHRvIHN1cHBvcnRAYWxnb2xpYS5jb20nO1xuXG4gIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKG1lc3NhZ2UpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9BbGdvbGlhU2VhcmNoLmpzIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBJbmRleENvcmUgPSByZXF1aXJlKCcuL0luZGV4Q29yZS5qcycpO1xudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlLmpzJyk7XG52YXIgZGVwcmVjYXRlZE1lc3NhZ2UgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWRNZXNzYWdlLmpzJyk7XG52YXIgZXhpdFByb21pc2UgPSByZXF1aXJlKCcuL2V4aXRQcm9taXNlLmpzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxudmFyIGRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcyA9IGRlcHJlY2F0ZShcbiAgZnVuY3Rpb24oKSB7fSxcbiAgZGVwcmVjYXRlZE1lc3NhZ2UoJ2ZvcndhcmRUb1NsYXZlcycsICdmb3J3YXJkVG9SZXBsaWNhcycpXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4O1xuXG5mdW5jdGlvbiBJbmRleCgpIHtcbiAgSW5kZXhDb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXRzKEluZGV4LCBJbmRleENvcmUpO1xuXG4vKlxuKiBBZGQgYW4gb2JqZWN0IGluIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGNvbnRlbnQgY29udGFpbnMgdGhlIGphdmFzY3JpcHQgb2JqZWN0IHRvIGFkZCBpbnNpZGUgdGhlIGluZGV4XG4qIEBwYXJhbSBvYmplY3RJRCAob3B0aW9uYWwpIGFuIG9iamVjdElEIHlvdSB3YW50IHRvIGF0dHJpYnV0ZSB0byB0aGlzIG9iamVjdFxuKiAoaWYgdGhlIGF0dHJpYnV0ZSBhbHJlYWR5IGV4aXN0IHRoZSBvbGQgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXRlKVxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIDMgZWxlbWVudHM6IGNyZWF0ZUF0LCB0YXNrSWQgYW5kIG9iamVjdElEXG4qL1xuSW5kZXgucHJvdG90eXBlLmFkZE9iamVjdCA9IGZ1bmN0aW9uKGNvbnRlbnQsIG9iamVjdElELCBjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBvYmplY3RJRCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb2JqZWN0SUQ7XG4gICAgb2JqZWN0SUQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogb2JqZWN0SUQgIT09IHVuZGVmaW5lZCA/XG4gICAgJ1BVVCcgOiAvLyB1cGRhdGUgb3IgY3JlYXRlXG4gICAgJ1BPU1QnLCAvLyBjcmVhdGUgKEFQSSBnZW5lcmF0ZXMgYW4gb2JqZWN0SUQpXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAvLyBjcmVhdGVcbiAgICAob2JqZWN0SUQgIT09IHVuZGVmaW5lZCA/ICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCkgOiAnJyksIC8vIHVwZGF0ZSBvciBjcmVhdGVcbiAgICBib2R5OiBjb250ZW50LFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIEFkZCBzZXZlcmFsIG9iamVjdHNcbipcbiogQHBhcmFtIG9iamVjdHMgY29udGFpbnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBhZGRcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4qL1xuSW5kZXgucHJvdG90eXBlLmFkZE9iamVjdHMgPSBmdW5jdGlvbihvYmplY3RzLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5hZGRPYmplY3RzKGFycmF5T2ZPYmplY3RzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9iamVjdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciBwb3N0T2JqID0ge1xuICAgIHJlcXVlc3RzOiBbXVxuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgIGFjdGlvbjogJ2FkZE9iamVjdCcsXG4gICAgICBib2R5OiBvYmplY3RzW2ldXG4gICAgfTtcbiAgICBwb3N0T2JqLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvYmF0Y2gnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogVXBkYXRlIHBhcnRpYWxseSBhbiBvYmplY3QgKG9ubHkgdXBkYXRlIGF0dHJpYnV0ZXMgcGFzc2VkIGluIGFyZ3VtZW50KVxuKlxuKiBAcGFyYW0gcGFydGlhbE9iamVjdCBjb250YWlucyB0aGUgamF2YXNjcmlwdCBhdHRyaWJ1dGVzIHRvIG92ZXJyaWRlLCB0aGVcbiogIG9iamVjdCBtdXN0IGNvbnRhaW5zIGFuIG9iamVjdElEIGF0dHJpYnV0ZVxuKiBAcGFyYW0gY3JlYXRlSWZOb3RFeGlzdHMgKG9wdGlvbmFsKSBpZiBmYWxzZSwgYXZvaWQgYW4gYXV0b21hdGljIGNyZWF0aW9uIG9mIHRoZSBvYmplY3RcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyAzIGVsZW1lbnRzOiBjcmVhdGVBdCwgdGFza0lkIGFuZCBvYmplY3RJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5wYXJ0aWFsVXBkYXRlT2JqZWN0ID0gZnVuY3Rpb24ocGFydGlhbE9iamVjdCwgY3JlYXRlSWZOb3RFeGlzdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBjcmVhdGVJZk5vdEV4aXN0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gY3JlYXRlSWZOb3RFeGlzdHM7XG4gICAgY3JlYXRlSWZOb3RFeGlzdHMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgdXJsID0gJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcnRpYWxPYmplY3Qub2JqZWN0SUQpICsgJy9wYXJ0aWFsJztcbiAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzID09PSBmYWxzZSkge1xuICAgIHVybCArPSAnP2NyZWF0ZUlmTm90RXhpc3RzPWZhbHNlJztcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiB1cmwsXG4gICAgYm9keTogcGFydGlhbE9iamVjdCxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBQYXJ0aWFsbHkgT3ZlcnJpZGUgdGhlIGNvbnRlbnQgb2Ygc2V2ZXJhbCBvYmplY3RzXG4qXG4qIEBwYXJhbSBvYmplY3RzIGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdHMgdG8gdXBkYXRlIChlYWNoIG9iamVjdCBtdXN0IGNvbnRhaW5zIGEgb2JqZWN0SUQgYXR0cmlidXRlKVxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IHVwZGF0ZUF0IGFuZCB0YXNrSURcbiovXG5JbmRleC5wcm90b3R5cGUucGFydGlhbFVwZGF0ZU9iamVjdHMgPSBmdW5jdGlvbihvYmplY3RzLCBjcmVhdGVJZk5vdEV4aXN0cywgY2FsbGJhY2spIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGNyZWF0ZUlmTm90RXhpc3RzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVJZk5vdEV4aXN0cztcbiAgICBjcmVhdGVJZk5vdEV4aXN0cyA9IHRydWU7XG4gIH1cblxuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5wYXJ0aWFsVXBkYXRlT2JqZWN0cyhhcnJheU9mT2JqZWN0c1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvYmplY3RzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgcG9zdE9iaiA9IHtcbiAgICByZXF1ZXN0czogW11cbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICBhY3Rpb246IGNyZWF0ZUlmTm90RXhpc3RzID09PSB0cnVlID8gJ3BhcnRpYWxVcGRhdGVPYmplY3QnIDogJ3BhcnRpYWxVcGRhdGVPYmplY3ROb0NyZWF0ZScsXG4gICAgICBvYmplY3RJRDogb2JqZWN0c1tpXS5vYmplY3RJRCxcbiAgICAgIGJvZHk6IG9iamVjdHNbaV1cbiAgICB9O1xuICAgIHBvc3RPYmoucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgfVxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9iYXRjaCcsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBPdmVycmlkZSB0aGUgY29udGVudCBvZiBvYmplY3RcbipcbiogQHBhcmFtIG9iamVjdCBjb250YWlucyB0aGUgamF2YXNjcmlwdCBvYmplY3QgdG8gc2F2ZSwgdGhlIG9iamVjdCBtdXN0IGNvbnRhaW5zIGFuIG9iamVjdElEIGF0dHJpYnV0ZVxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IHVwZGF0ZUF0IGFuZCB0YXNrSURcbiovXG5JbmRleC5wcm90b3R5cGUuc2F2ZU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdC5vYmplY3RJRCksXG4gICAgYm9keTogb2JqZWN0LFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn1cblxuLypcbiogT3ZlcnJpZGUgdGhlIGNvbnRlbnQgb2Ygc2V2ZXJhbCBvYmplY3RzXG4qXG4qIEBwYXJhbSBvYmplY3RzIGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdHMgdG8gdXBkYXRlIChlYWNoIG9iamVjdCBtdXN0IGNvbnRhaW5zIGEgb2JqZWN0SUQgYXR0cmlidXRlKVxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IHVwZGF0ZUF0IGFuZCB0YXNrSURcbiovXG5JbmRleC5wcm90b3R5cGUuc2F2ZU9iamVjdHMgPSBmdW5jdGlvbihvYmplY3RzLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5zYXZlT2JqZWN0cyhhcnJheU9mT2JqZWN0c1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvYmplY3RzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgcG9zdE9iaiA9IHtcbiAgICByZXF1ZXN0czogW11cbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICBhY3Rpb246ICd1cGRhdGVPYmplY3QnLFxuICAgICAgb2JqZWN0SUQ6IG9iamVjdHNbaV0ub2JqZWN0SUQsXG4gICAgICBib2R5OiBvYmplY3RzW2ldXG4gICAgfTtcbiAgICBwb3N0T2JqLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvYmF0Y2gnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogRGVsZXRlIGFuIG9iamVjdCBmcm9tIHRoZSBpbmRleFxuKlxuKiBAcGFyYW0gb2JqZWN0SUQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIG9iamVjdCB0byBkZWxldGVcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyAzIGVsZW1lbnRzOiBjcmVhdGVBdCwgdGFza0lkIGFuZCBvYmplY3RJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5kZWxldGVPYmplY3QgPSBmdW5jdGlvbihvYmplY3RJRCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvYmplY3RJRCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqZWN0SUQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBvYmplY3RJRCAhPT0gJ251bWJlcicpIHtcbiAgICB2YXIgZXJyID0gbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ0Nhbm5vdCBkZWxldGUgYW4gb2JqZWN0IHdpdGhvdXQgYW4gb2JqZWN0SUQnKTtcbiAgICBjYWxsYmFjayA9IG9iamVjdElEO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFzLl9wcm9taXNlLnJlamVjdChlcnIpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBEZWxldGUgc2V2ZXJhbCBvYmplY3RzIGZyb20gYW4gaW5kZXhcbipcbiogQHBhcmFtIG9iamVjdElEcyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RJRCB0byBkZWxldGVcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyAzIGVsZW1lbnRzOiBjcmVhdGVBdCwgdGFza0lkIGFuZCBvYmplY3RJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5kZWxldGVPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0SURzLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwLmpzJyk7XG5cbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5kZWxldGVPYmplY3RzKGFycmF5T2ZPYmplY3RJRHNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob2JqZWN0SURzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgcG9zdE9iaiA9IHtcbiAgICByZXF1ZXN0czogbWFwKG9iamVjdElEcywgZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3Qob2JqZWN0SUQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGlvbjogJ2RlbGV0ZU9iamVjdCcsXG4gICAgICAgIG9iamVjdElEOiBvYmplY3RJRCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIG9iamVjdElEOiBvYmplY3RJRFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pXG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvYmF0Y2gnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogRGVsZXRlIGFsbCBvYmplY3RzIG1hdGNoaW5nIGEgcXVlcnlcbipcbiogQHBhcmFtIHF1ZXJ5IHRoZSBxdWVyeSBzdHJpbmdcbiogQHBhcmFtIHBhcmFtcyB0aGUgb3B0aW9uYWwgcXVlcnkgcGFyYW1ldGVyc1xuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudFxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKi9cbkluZGV4LnByb3RvdHlwZS5kZWxldGVCeVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnksIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgY2xpZW50ID0gaW5kZXhPYmouYXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHBhcmFtcyA9IGNsb25lKHBhcmFtcyk7XG4gIH1cblxuICBwYXJhbXMuYXR0cmlidXRlc1RvUmV0cmlldmUgPSAnb2JqZWN0SUQnO1xuICBwYXJhbXMuaGl0c1BlclBhZ2UgPSAxMDAwO1xuICBwYXJhbXMuZGlzdGluY3QgPSBmYWxzZTtcblxuICAvLyB3aGVuIGRlbGV0aW5nLCB3ZSBzaG91bGQgbmV2ZXIgdXNlIGNhY2hlIHRvIGdldCB0aGVcbiAgLy8gc2VhcmNoIHJlc3VsdHNcbiAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgLy8gdGhlcmUncyBhIHByb2JsZW0gaW4gaG93IHdlIHVzZSB0aGUgcHJvbWlzZSBjaGFpbixcbiAgLy8gc2VlIGhvdyB3YWl0VGFzayBpcyBkb25lXG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAuc2VhcmNoKHF1ZXJ5LCBwYXJhbXMpXG4gIC50aGVuKHN0b3BPckRlbGV0ZSk7XG5cbiAgZnVuY3Rpb24gc3RvcE9yRGVsZXRlKHNlYXJjaENvbnRlbnQpIHtcbiAgICAvLyBzdG9wIGhlcmVcbiAgICBpZiAoc2VhcmNoQ29udGVudC5uYkhpdHMgPT09IDApIHtcbiAgICAgIC8vIHJldHVybiBpbmRleE9iai5hcy5fcmVxdWVzdC5yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gc2VhcmNoQ29udGVudDtcbiAgICB9XG5cbiAgICAvLyBjb250aW51ZSBhbmQgZG8gYSByZWN1cnNpdmUgY2FsbFxuICAgIHZhciBvYmplY3RJRHMgPSBtYXAoc2VhcmNoQ29udGVudC5oaXRzLCBmdW5jdGlvbiBnZXRPYmplY3RJRChvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3Qub2JqZWN0SUQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5kZXhPYmpcbiAgICAuZGVsZXRlT2JqZWN0cyhvYmplY3RJRHMpXG4gICAgLnRoZW4od2FpdFRhc2spXG4gICAgLnRoZW4oZG9EZWxldGVCeVF1ZXJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRUYXNrKGRlbGV0ZU9iamVjdHNDb250ZW50KSB7XG4gICAgcmV0dXJuIGluZGV4T2JqLndhaXRUYXNrKGRlbGV0ZU9iamVjdHNDb250ZW50LnRhc2tJRCk7XG4gIH1cblxuICBmdW5jdGlvbiBkb0RlbGV0ZUJ5UXVlcnkoKSB7XG4gICAgcmV0dXJuIGluZGV4T2JqLmRlbGV0ZUJ5UXVlcnkocXVlcnksIHBhcmFtcyk7XG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcm9taXNlLnRoZW4oc3VjY2VzcywgZmFpbHVyZSk7XG5cbiAgZnVuY3Rpb24gc3VjY2VzcygpIHtcbiAgICBleGl0UHJvbWlzZShmdW5jdGlvbiBleGl0KCkge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfSwgY2xpZW50Ll9zZXRUaW1lb3V0IHx8IHNldFRpbWVvdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmFpbHVyZShlcnIpIHtcbiAgICBleGl0UHJvbWlzZShmdW5jdGlvbiBleGl0KCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gIH1cbn07XG5cbi8qXG4qIEJyb3dzZSBhbGwgY29udGVudCBmcm9tIGFuIGluZGV4IHVzaW5nIGV2ZW50cy4gQmFzaWNhbGx5IHRoaXMgd2lsbCBkb1xuKiAuYnJvd3NlKCkgLT4gLmJyb3dzZUZyb20gLT4gLmJyb3dzZUZyb20gLT4gLi4gdW50aWwgYWxsIHRoZSByZXN1bHRzIGFyZSByZXR1cm5lZFxuKlxuKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgZnVsbCB0ZXh0IHF1ZXJ5XG4qIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbWV0ZXJzXSAtIEFueSBzZWFyY2ggcXVlcnkgcGFyYW1ldGVyXG4qIEByZXR1cm4ge0V2ZW50RW1pdHRlcn1cbiogQGV4YW1wbGVcbiogdmFyIGJyb3dzZXIgPSBpbmRleC5icm93c2VBbGwoJ2Nvb2wgc29uZ3MnLCB7XG4qICAgdGFnRmlsdGVyczogJ3B1YmxpYyxjb21tZW50cycsXG4qICAgaGl0c1BlclBhZ2U6IDUwMFxuKiB9KTtcbipcbiogYnJvd3Nlci5vbigncmVzdWx0JywgZnVuY3Rpb24gcmVzdWx0Q2FsbGJhY2soY29udGVudCkge1xuKiAgIGNvbnNvbGUubG9nKGNvbnRlbnQuaGl0cyk7XG4qIH0pO1xuKlxuKiAvLyBpZiBhbnkgZXJyb3Igb2NjdXJzLCB5b3UgZ2V0IGl0XG4qIGJyb3dzZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4qICAgdGhyb3cgZXJyO1xuKiB9KTtcbipcbiogLy8gd2hlbiB5b3UgaGF2ZSBicm93c2VkIHRoZSB3aG9sZSBpbmRleCwgeW91IGdldCB0aGlzIGV2ZW50XG4qIGJyb3dzZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuKiAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCcpO1xuKiB9KTtcbipcbiogLy8gYXQgYW55IHBvaW50IGlmIHlvdSB3YW50IHRvIHN0b3AgdGhlIGJyb3dzaW5nIHByb2Nlc3MsIHlvdSBjYW4gc3RvcCBpdCBtYW51YWxseVxuKiAvLyBvdGhlcndpc2UgaXQgd2lsbCBnbyBvbiBhbmQgb25cbiogYnJvd3Nlci5zdG9wKCk7XG4qXG4qIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNCcm93c2V8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuKi9cbkluZGV4LnByb3RvdHlwZS5icm93c2VBbGwgPSBmdW5jdGlvbihxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzKSB7XG4gIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgcXVlcnlQYXJhbWV0ZXJzID0gcXVlcnk7XG4gICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlLmpzJyk7XG5cbiAgdmFyIEluZGV4QnJvd3NlciA9IHJlcXVpcmUoJy4vSW5kZXhCcm93c2VyJyk7XG5cbiAgdmFyIGJyb3dzZXIgPSBuZXcgSW5kZXhCcm93c2VyKCk7XG4gIHZhciBjbGllbnQgPSB0aGlzLmFzO1xuICB2YXIgaW5kZXggPSB0aGlzO1xuICB2YXIgcGFyYW1zID0gY2xpZW50Ll9nZXRTZWFyY2hQYXJhbXMoXG4gICAgbWVyZ2Uoe30sIHF1ZXJ5UGFyYW1ldGVycyB8fCB7fSwge1xuICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgfSksICcnXG4gICk7XG5cbiAgLy8gc3RhcnQgYnJvd3NpbmdcbiAgYnJvd3NlTG9vcCgpO1xuXG4gIGZ1bmN0aW9uIGJyb3dzZUxvb3AoY3Vyc29yKSB7XG4gICAgaWYgKGJyb3dzZXIuX3N0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9keTtcblxuICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9keSA9IHtcbiAgICAgICAgY3Vyc29yOiBjdXJzb3JcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSB7XG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNsaWVudC5fanNvblJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXguaW5kZXhOYW1lKSArICcvYnJvd3NlJyxcbiAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAgY2FsbGJhY2s6IGJyb3dzZUNhbGxiYWNrXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBicm93c2VDYWxsYmFjayhlcnIsIGNvbnRlbnQpIHtcbiAgICBpZiAoYnJvd3Nlci5fc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGJyb3dzZXIuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJvd3Nlci5fcmVzdWx0KGNvbnRlbnQpO1xuXG4gICAgLy8gbm8gY3Vyc29yIG1lYW5zIHdlIGFyZSBmaW5pc2hlZCBicm93c2luZ1xuICAgIGlmIChjb250ZW50LmN1cnNvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBicm93c2VyLl9lbmQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicm93c2VMb29wKGNvbnRlbnQuY3Vyc29yKTtcbiAgfVxuXG4gIHJldHVybiBicm93c2VyO1xufTtcblxuLypcbiogR2V0IGEgVHlwZWFoZWFkLmpzIGFkYXB0ZXJcbiogQHBhcmFtIHNlYXJjaFBhcmFtcyBjb250YWlucyBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzIChzZWUgc2VhcmNoIGZvciBkZXRhaWxzKVxuKi9cbkluZGV4LnByb3RvdHlwZS50dEFkYXB0ZXIgPSBkZXByZWNhdGUoZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uIHR0QWRhcHRlcihxdWVyeSwgc3luY0NiLCBhc3luY0NiKSB7XG4gICAgdmFyIGNiO1xuXG4gICAgaWYgKHR5cGVvZiBhc3luY0NiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyB0eXBlYWhlYWQgMC4xMVxuICAgICAgY2IgPSBhc3luY0NiO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcmUgdHlwZWFoZWFkIDAuMTFcbiAgICAgIGNiID0gc3luY0NiO1xuICAgIH1cblxuICAgIHNlbGYuc2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIGZ1bmN0aW9uIHNlYXJjaERvbmUoZXJyLCBjb250ZW50KSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2IoY29udGVudC5oaXRzKTtcbiAgICB9KTtcbiAgfTtcbn0sXG4ndHRBZGFwdGVyIGlzIG5vdCBuZWNlc3NhcnkgYW55bW9yZSBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24sXFxuJyArXG4naGF2ZSBhIGxvb2sgYXQgYXV0b2NvbXBsZXRlLmpzIChodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9hdXRvY29tcGxldGUuanMpJyk7XG5cbi8qXG4qIFdhaXQgdGhlIHB1YmxpY2F0aW9uIG9mIGEgdGFzayBvbiB0aGUgc2VydmVyLlxuKiBBbGwgc2VydmVyIHRhc2sgYXJlIGFzeW5jaHJvbm91cyBhbmQgeW91IGNhbiBjaGVjayB3aXRoIHRoaXMgbWV0aG9kIHRoYXQgdGhlIHRhc2sgaXMgcHVibGlzaGVkLlxuKlxuKiBAcGFyYW0gdGFza0lEIHRoZSBpZCBvZiB0aGUgdGFzayByZXR1cm5lZCBieSBzZXJ2ZXJcbiogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgd2l0aCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIHJlc3VsdHNcbiovXG5JbmRleC5wcm90b3R5cGUud2FpdFRhc2sgPSBmdW5jdGlvbih0YXNrSUQsIGNhbGxiYWNrKSB7XG4gIC8vIHdhaXQgbWluaW11bSAxMDBtcyBiZWZvcmUgcmV0cnlpbmdcbiAgdmFyIGJhc2VEZWxheSA9IDEwMDtcbiAgLy8gd2FpdCBtYXhpbXVtIDVzIGJlZm9yZSByZXRyeWluZ1xuICB2YXIgbWF4RGVsYXkgPSA1MDAwO1xuICB2YXIgbG9vcCA9IDA7XG5cbiAgLy8gd2FpdFRhc2soKSBtdXN0IGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZnJvbSBvdGhlciBtZXRob2RzLFxuICAvLyBpdCdzIGEgcmVjdXJzaXZlIG1ldGhvZCB1c2luZyBhIHRpbWVvdXRcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIGNsaWVudCA9IGluZGV4T2JqLmFzO1xuXG4gIHZhciBwcm9taXNlID0gcmV0cnlMb29wKCk7XG5cbiAgZnVuY3Rpb24gcmV0cnlMb29wKCkge1xuICAgIHJldHVybiBjbGllbnQuX2pzb25SZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL3Rhc2svJyArIHRhc2tJRFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gc3VjY2Vzcyhjb250ZW50KSB7XG4gICAgICBsb29wKys7XG4gICAgICB2YXIgZGVsYXkgPSBiYXNlRGVsYXkgKiBsb29wICogbG9vcDtcbiAgICAgIGlmIChkZWxheSA+IG1heERlbGF5KSB7XG4gICAgICAgIGRlbGF5ID0gbWF4RGVsYXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZW50LnN0YXR1cyAhPT0gJ3B1Ymxpc2hlZCcpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5kZWxheShkZWxheSkudGhlbihyZXRyeUxvb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHByb21pc2UudGhlbihzdWNjZXNzQ2IsIGZhaWx1cmVDYik7XG5cbiAgZnVuY3Rpb24gc3VjY2Vzc0NiKGNvbnRlbnQpIHtcbiAgICBleGl0UHJvbWlzZShmdW5jdGlvbiBleGl0KCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgY29udGVudCk7XG4gICAgfSwgY2xpZW50Ll9zZXRUaW1lb3V0IHx8IHNldFRpbWVvdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmFpbHVyZUNiKGVycikge1xuICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uIGV4aXQoKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgfVxufTtcblxuLypcbiogVGhpcyBmdW5jdGlvbiBkZWxldGVzIHRoZSBpbmRleCBjb250ZW50LiBTZXR0aW5ncyBhbmQgaW5kZXggc3BlY2lmaWMgQVBJIGtleXMgYXJlIGtlcHQgdW50b3VjaGVkLlxuKlxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXR0aW5ncyBvYmplY3Qgb3IgdGhlIGVycm9yIG1lc3NhZ2UgaWYgYSBmYWlsdXJlIG9jY3VyZWRcbiovXG5JbmRleC5wcm90b3R5cGUuY2xlYXJJbmRleCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2NsZWFyJyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBHZXQgc2V0dGluZ3Mgb2YgdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXR0aW5ncyBvYmplY3Qgb3IgdGhlIGVycm9yIG1lc3NhZ2UgaWYgYSBmYWlsdXJlIG9jY3VyZWRcbiovXG5JbmRleC5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL3NldHRpbmdzP2dldFZlcnNpb249MicsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuc2VhcmNoU3lub255bXMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0ge307XG4gIH0gZWxzZSBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvc2VhcmNoJyxcbiAgICBib2R5OiBwYXJhbXMsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuc2F2ZVN5bm9ueW0gPSBmdW5jdGlvbihzeW5vbnltLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcndhcmRUb1NsYXZlcyAhPT0gdW5kZWZpbmVkKSBkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMoKTtcbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gKG9wdHMuZm9yd2FyZFRvU2xhdmVzIHx8IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMpID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChzeW5vbnltLm9iamVjdElEKSArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBib2R5OiBzeW5vbnltLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5nZXRTeW5vbnltID0gZnVuY3Rpb24ob2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9zeW5vbnltcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5kZWxldGVTeW5vbnltID0gZnVuY3Rpb24ob2JqZWN0SUQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdHMuZm9yd2FyZFRvU2xhdmVzICE9PSB1bmRlZmluZWQpIGRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcygpO1xuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgfHwgb3B0cy5mb3J3YXJkVG9SZXBsaWNhcykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9zeW5vbnltcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuY2xlYXJTeW5vbnltcyA9IGZ1bmN0aW9uKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdHMuZm9yd2FyZFRvU2xhdmVzICE9PSB1bmRlZmluZWQpIGRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcygpO1xuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgfHwgb3B0cy5mb3J3YXJkVG9SZXBsaWNhcykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvY2xlYXInICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5iYXRjaFN5bm9ueW1zID0gZnVuY3Rpb24oc3lub255bXMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdHMuZm9yd2FyZFRvU2xhdmVzICE9PSB1bmRlZmluZWQpIGRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcygpO1xuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgfHwgb3B0cy5mb3J3YXJkVG9SZXBsaWNhcykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvc3lub255bXMvYmF0Y2gnICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzICtcbiAgICAgICcmcmVwbGFjZUV4aXN0aW5nU3lub255bXM9JyArIChvcHRzLnJlcGxhY2VFeGlzdGluZ1N5bm9ueW1zID8gJ3RydWUnIDogJ2ZhbHNlJyksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgYm9keTogc3lub255bXMsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLnNlYXJjaFJ1bGVzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IHt9O1xuICB9IGVsc2UgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzL3NlYXJjaCcsXG4gICAgYm9keTogcGFyYW1zLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLnNhdmVSdWxlID0gZnVuY3Rpb24ocnVsZSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSBvcHRzLmZvcndhcmRUb1JlcGxpY2FzID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcnVsZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChydWxlLm9iamVjdElEKSArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBib2R5OiBydWxlLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5nZXRSdWxlID0gZnVuY3Rpb24ob2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5kZWxldGVSdWxlID0gZnVuY3Rpb24ob2JqZWN0SUQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gb3B0cy5mb3J3YXJkVG9SZXBsaWNhcyA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5jbGVhclJ1bGVzID0gZnVuY3Rpb24ob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSBvcHRzLmZvcndhcmRUb1JlcGxpY2FzID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzL2NsZWFyJyArXG4gICAgICAnP2ZvcndhcmRUb1JlcGxpY2FzPScgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuYmF0Y2hSdWxlcyA9IGZ1bmN0aW9uKHJ1bGVzLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcnVsZXMvYmF0Y2gnICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzICtcbiAgICAgICcmY2xlYXJFeGlzdGluZ1J1bGVzPScgKyAob3B0cy5jbGVhckV4aXN0aW5nUnVsZXMgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnKSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBib2R5OiBydWxlcyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBTZXQgc2V0dGluZ3MgZm9yIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIHNldHRpZ25zIHRoZSBzZXR0aW5ncyBvYmplY3QgdGhhdCBjYW4gY29udGFpbnMgOlxuKiAtIG1pbldvcmRTaXplZm9yMVR5cG86IChpbnRlZ2VyKSB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBhY2NlcHQgb25lIHR5cG8gKGRlZmF1bHQgPSAzKS5cbiogLSBtaW5Xb3JkU2l6ZWZvcjJUeXBvczogKGludGVnZXIpIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFjY2VwdCB0d28gdHlwb3MgKGRlZmF1bHQgPSA3KS5cbiogLSBoaXRzUGVyUGFnZTogKGludGVnZXIpIHRoZSBudW1iZXIgb2YgaGl0cyBwZXIgcGFnZSAoZGVmYXVsdCA9IDEwKS5cbiogLSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZTogKGFycmF5IG9mIHN0cmluZ3MpIGRlZmF1bHQgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIHJldHJpZXZlIGluIG9iamVjdHMuXG4qICAgSWYgc2V0IHRvIG51bGwsIGFsbCBhdHRyaWJ1dGVzIGFyZSByZXRyaWV2ZWQuXG4qIC0gYXR0cmlidXRlc1RvSGlnaGxpZ2h0OiAoYXJyYXkgb2Ygc3RyaW5ncykgZGVmYXVsdCBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gaGlnaGxpZ2h0LlxuKiAgIElmIHNldCB0byBudWxsLCBhbGwgaW5kZXhlZCBhdHRyaWJ1dGVzIGFyZSBoaWdobGlnaHRlZC5cbiogLSBhdHRyaWJ1dGVzVG9TbmlwcGV0Kio6IChhcnJheSBvZiBzdHJpbmdzKSBkZWZhdWx0IGxpc3Qgb2YgYXR0cmlidXRlcyB0byBzbmlwcGV0IGFsb25nc2lkZSB0aGUgbnVtYmVyXG4qIG9mIHdvcmRzIHRvIHJldHVybiAoc3ludGF4IGlzIGF0dHJpYnV0ZU5hbWU6bmJXb3JkcykuXG4qICAgQnkgZGVmYXVsdCBubyBzbmlwcGV0IGlzIGNvbXB1dGVkLiBJZiBzZXQgdG8gbnVsbCwgbm8gc25pcHBldCBpcyBjb21wdXRlZC5cbiogLSBhdHRyaWJ1dGVzVG9JbmRleDogKGFycmF5IG9mIHN0cmluZ3MpIHRoZSBsaXN0IG9mIGZpZWxkcyB5b3Ugd2FudCB0byBpbmRleC5cbiogICBJZiBzZXQgdG8gbnVsbCwgYWxsIHRleHR1YWwgYW5kIG51bWVyaWNhbCBhdHRyaWJ1dGVzIG9mIHlvdXIgb2JqZWN0cyBhcmUgaW5kZXhlZCxcbiogICBidXQgeW91IHNob3VsZCB1cGRhdGUgaXQgdG8gZ2V0IG9wdGltYWwgcmVzdWx0cy5cbiogICBUaGlzIHBhcmFtZXRlciBoYXMgdHdvIGltcG9ydGFudCB1c2VzOlxuKiAgICAgLSBMaW1pdCB0aGUgYXR0cmlidXRlcyB0byBpbmRleDogRm9yIGV4YW1wbGUgaWYgeW91IHN0b3JlIGEgYmluYXJ5IGltYWdlIGluIGJhc2U2NCxcbiogICAgIHlvdSB3YW50IHRvIHN0b3JlIGl0IGFuZCBiZSBhYmxlIHRvXG4qICAgICAgIHJldHJpZXZlIGl0IGJ1dCB5b3UgZG9uJ3Qgd2FudCB0byBzZWFyY2ggaW4gdGhlIGJhc2U2NCBzdHJpbmcuXG4qICAgICAtIENvbnRyb2wgcGFydCBvZiB0aGUgcmFua2luZyo6IChzZWUgdGhlIHJhbmtpbmcgcGFyYW1ldGVyIGZvciBmdWxsIGV4cGxhbmF0aW9uKVxuKiAgICAgTWF0Y2hlcyBpbiBhdHRyaWJ1dGVzIGF0IHRoZSBiZWdpbm5pbmcgb2ZcbiogICAgICAgdGhlIGxpc3Qgd2lsbCBiZSBjb25zaWRlcmVkIG1vcmUgaW1wb3J0YW50IHRoYW4gbWF0Y2hlcyBpbiBhdHRyaWJ1dGVzIGZ1cnRoZXIgZG93biB0aGUgbGlzdC5cbiogICAgICAgSW4gb25lIGF0dHJpYnV0ZSwgbWF0Y2hpbmcgdGV4dCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZVxuKiAgICAgICBjb25zaWRlcmVkIG1vcmUgaW1wb3J0YW50IHRoYW4gdGV4dCBhZnRlciwgeW91IGNhbiBkaXNhYmxlXG4qICAgICAgIHRoaXMgYmVoYXZpb3IgaWYgeW91IGFkZCB5b3VyIGF0dHJpYnV0ZSBpbnNpZGUgYHVub3JkZXJlZChBdHRyaWJ1dGVOYW1lKWAsXG4qICAgICAgIGZvciBleGFtcGxlIGF0dHJpYnV0ZXNUb0luZGV4OiBbXCJ0aXRsZVwiLCBcInVub3JkZXJlZCh0ZXh0KVwiXS5cbiogLSBhdHRyaWJ1dGVzRm9yRmFjZXRpbmc6IChhcnJheSBvZiBzdHJpbmdzKSBUaGUgbGlzdCBvZiBmaWVsZHMgeW91IHdhbnQgdG8gdXNlIGZvciBmYWNldGluZy5cbiogICBBbGwgc3RyaW5ncyBpbiB0aGUgYXR0cmlidXRlIHNlbGVjdGVkIGZvciBmYWNldGluZyBhcmUgZXh0cmFjdGVkIGFuZCBhZGRlZCBhcyBhIGZhY2V0LlxuKiAgIElmIHNldCB0byBudWxsLCBubyBhdHRyaWJ1dGUgaXMgdXNlZCBmb3IgZmFjZXRpbmcuXG4qIC0gYXR0cmlidXRlRm9yRGlzdGluY3Q6IChzdHJpbmcpIFRoZSBhdHRyaWJ1dGUgbmFtZSB1c2VkIGZvciB0aGUgRGlzdGluY3QgZmVhdHVyZS5cbiogVGhpcyBmZWF0dXJlIGlzIHNpbWlsYXIgdG8gdGhlIFNRTCBcImRpc3RpbmN0XCIga2V5d29yZDogd2hlbiBlbmFibGVkXG4qICAgaW4gcXVlcnkgd2l0aCB0aGUgZGlzdGluY3Q9MSBwYXJhbWV0ZXIsIGFsbCBoaXRzIGNvbnRhaW5pbmcgYSBkdXBsaWNhdGVcbiogICB2YWx1ZSBmb3IgdGhpcyBhdHRyaWJ1dGUgYXJlIHJlbW92ZWQgZnJvbSByZXN1bHRzLlxuKiAgIEZvciBleGFtcGxlLCBpZiB0aGUgY2hvc2VuIGF0dHJpYnV0ZSBpcyBzaG93X25hbWUgYW5kIHNldmVyYWwgaGl0cyBoYXZlXG4qICAgdGhlIHNhbWUgdmFsdWUgZm9yIHNob3dfbmFtZSwgdGhlbiBvbmx5IHRoZSBiZXN0IG9uZSBpcyBrZXB0IGFuZCBvdGhlcnMgYXJlIHJlbW92ZWQuXG4qIC0gcmFua2luZzogKGFycmF5IG9mIHN0cmluZ3MpIGNvbnRyb2xzIHRoZSB3YXkgcmVzdWx0cyBhcmUgc29ydGVkLlxuKiAgIFdlIGhhdmUgc2l4IGF2YWlsYWJsZSBjcml0ZXJpYTpcbiogICAgLSB0eXBvOiBzb3J0IGFjY29yZGluZyB0byBudW1iZXIgb2YgdHlwb3MsXG4qICAgIC0gZ2VvOiBzb3J0IGFjY29yZGluZyB0byBkZWNyZWFzc2luZyBkaXN0YW5jZSB3aGVuIHBlcmZvcm1pbmcgYSBnZW8tbG9jYXRpb24gYmFzZWQgc2VhcmNoLFxuKiAgICAtIHByb3hpbWl0eTogc29ydCBhY2NvcmRpbmcgdG8gdGhlIHByb3hpbWl0eSBvZiBxdWVyeSB3b3JkcyBpbiBoaXRzLFxuKiAgICAtIGF0dHJpYnV0ZTogc29ydCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIG9mIGF0dHJpYnV0ZXMgZGVmaW5lZCBieSBhdHRyaWJ1dGVzVG9JbmRleCxcbiogICAgLSBleGFjdDpcbiogICAgICAgIC0gaWYgdGhlIHVzZXIgcXVlcnkgY29udGFpbnMgb25lIHdvcmQ6IHNvcnQgb2JqZWN0cyBoYXZpbmcgYW4gYXR0cmlidXRlXG4qICAgICAgICB0aGF0IGlzIGV4YWN0bHkgdGhlIHF1ZXJ5IHdvcmQgYmVmb3JlIG90aGVycy5cbiogICAgICAgICAgRm9yIGV4YW1wbGUgaWYgeW91IHNlYXJjaCBmb3IgdGhlIFwiVlwiIFRWIHNob3csIHlvdSB3YW50IHRvIGZpbmQgaXRcbiogICAgICAgICAgd2l0aCB0aGUgXCJWXCIgcXVlcnkgYW5kIGF2b2lkIHRvIGhhdmUgYWxsIHBvcHVsYXIgVFZcbiogICAgICAgICAgc2hvdyBzdGFydGluZyBieSB0aGUgdiBsZXR0ZXIgYmVmb3JlIGl0LlxuKiAgICAgICAgLSBpZiB0aGUgdXNlciBxdWVyeSBjb250YWlucyBtdWx0aXBsZSB3b3Jkczogc29ydCBhY2NvcmRpbmcgdG8gdGhlXG4qICAgICAgICBudW1iZXIgb2Ygd29yZHMgdGhhdCBtYXRjaGVkIGV4YWN0bHkgKGFuZCBub3QgYXMgYSBwcmVmaXgpLlxuKiAgICAtIGN1c3RvbTogc29ydCBhY2NvcmRpbmcgdG8gYSB1c2VyIGRlZmluZWQgZm9ybXVsYSBzZXQgaW4gKipjdXN0b21SYW5raW5nKiogYXR0cmlidXRlLlxuKiAgIFRoZSBzdGFuZGFyZCBvcmRlciBpcyBbXCJ0eXBvXCIsIFwiZ2VvXCIsIFwicHJveGltaXR5XCIsIFwiYXR0cmlidXRlXCIsIFwiZXhhY3RcIiwgXCJjdXN0b21cIl1cbiogLSBjdXN0b21SYW5raW5nOiAoYXJyYXkgb2Ygc3RyaW5ncykgbGV0cyB5b3Ugc3BlY2lmeSBwYXJ0IG9mIHRoZSByYW5raW5nLlxuKiAgIFRoZSBzeW50YXggb2YgdGhpcyBjb25kaXRpb24gaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIGF0dHJpYnV0ZXNcbiogICBwcmVmaXhlZCBieSBhc2MgKGFzY2VuZGluZyBvcmRlcikgb3IgZGVzYyAoZGVzY2VuZGluZyBvcmRlcikgb3BlcmF0b3IuXG4qICAgRm9yIGV4YW1wbGUgYFwiY3VzdG9tUmFua2luZ1wiID0+IFtcImRlc2MocG9wdWxhdGlvbilcIiwgXCJhc2MobmFtZSlcIl1gXG4qIC0gcXVlcnlUeXBlOiBTZWxlY3QgaG93IHRoZSBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQsIGl0IGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZTpcbiogICAtIHByZWZpeEFsbDogYWxsIHF1ZXJ5IHdvcmRzIGFyZSBpbnRlcnByZXRlZCBhcyBwcmVmaXhlcyxcbiogICAtIHByZWZpeExhc3Q6IG9ubHkgdGhlIGxhc3Qgd29yZCBpcyBpbnRlcnByZXRlZCBhcyBhIHByZWZpeCAoZGVmYXVsdCBiZWhhdmlvciksXG4qICAgLSBwcmVmaXhOb25lOiBubyBxdWVyeSB3b3JkIGlzIGludGVycHJldGVkIGFzIGEgcHJlZml4LiBUaGlzIG9wdGlvbiBpcyBub3QgcmVjb21tZW5kZWQuXG4qIC0gaGlnaGxpZ2h0UHJlVGFnOiAoc3RyaW5nKSBTcGVjaWZ5IHRoZSBzdHJpbmcgdGhhdCBpcyBpbnNlcnRlZCBiZWZvcmVcbiogdGhlIGhpZ2hsaWdodGVkIHBhcnRzIGluIHRoZSBxdWVyeSByZXN1bHQgKGRlZmF1bHQgdG8gXCI8ZW0+XCIpLlxuKiAtIGhpZ2hsaWdodFBvc3RUYWc6IChzdHJpbmcpIFNwZWNpZnkgdGhlIHN0cmluZyB0aGF0IGlzIGluc2VydGVkIGFmdGVyXG4qIHRoZSBoaWdobGlnaHRlZCBwYXJ0cyBpbiB0aGUgcXVlcnkgcmVzdWx0IChkZWZhdWx0IHRvIFwiPC9lbT5cIikuXG4qIC0gb3B0aW9uYWxXb3JkczogKGFycmF5IG9mIHN0cmluZ3MpIFNwZWNpZnkgYSBsaXN0IG9mIHdvcmRzIHRoYXQgc2hvdWxkXG4qIGJlIGNvbnNpZGVyZWQgYXMgb3B0aW9uYWwgd2hlbiBmb3VuZCBpbiB0aGUgcXVlcnkuXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgb3IgdGhlIGVycm9yIG1lc3NhZ2UgaWYgYSBmYWlsdXJlIG9jY3VyZWRcbiovXG5JbmRleC5wcm90b3R5cGUuc2V0U2V0dGluZ3MgPSBmdW5jdGlvbihzZXR0aW5ncywgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdHMuZm9yd2FyZFRvU2xhdmVzICE9PSB1bmRlZmluZWQpIGRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcygpO1xuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgfHwgb3B0cy5mb3J3YXJkVG9SZXBsaWNhcykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvc2V0dGluZ3M/Zm9yd2FyZFRvUmVwbGljYXM9J1xuICAgICAgKyBmb3J3YXJkVG9SZXBsaWNhcyxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBib2R5OiBzZXR0aW5ncyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBpbmRleC5saXN0QXBpS2V5c1xuICovXG5JbmRleC5wcm90b3R5cGUubGlzdFVzZXJLZXlzID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmxpc3RBcGlLZXlzKGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC5saXN0VXNlcktleXMoKScsICdpbmRleC5saXN0QXBpS2V5cygpJykpO1xuXG4vKlxuKiBMaXN0IGFsbCBleGlzdGluZyBBUEkga2V5cyB0byB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggQVBJIGtleXMgYmVsb25naW5nIHRvIHRoZSBpbmRleFxuKi9cbkluZGV4LnByb3RvdHlwZS5saXN0QXBpS2V5cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcva2V5cycsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBpbmRleC5nZXRBcGlLZXlcbiAqL1xuSW5kZXgucHJvdG90eXBlLmdldFVzZXJLZXlBQ0wgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5nZXRBcGlLZXkoa2V5LCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXguZ2V0VXNlcktleUFDTCgpJywgJ2luZGV4LmdldEFwaUtleSgpJykpO1xuXG5cbi8qXG4qIEdldCBhbiBBUEkga2V5IGZyb20gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0ga2V5XG4qIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIHJpZ2h0IEFQSSBrZXlcbiovXG5JbmRleC5wcm90b3R5cGUuZ2V0QXBpS2V5ID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2tleXMvJyArIGtleSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gQGRlcHJlY2F0ZWQgc2VlIGluZGV4LmRlbGV0ZUFwaUtleVxuICovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlVXNlcktleSA9IGRlcHJlY2F0ZShmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmRlbGV0ZUFwaUtleShrZXksIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC5kZWxldGVVc2VyS2V5KCknLCAnaW5kZXguZGVsZXRlQXBpS2V5KCknKSk7XG5cbi8qXG4qIERlbGV0ZSBhbiBleGlzdGluZyBBUEkga2V5IGFzc29jaWF0ZWQgdG8gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0ga2V5XG4qIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGRlbGV0aW9uIGRhdGVcbiovXG5JbmRleC5wcm90b3R5cGUuZGVsZXRlQXBpS2V5ID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2tleXMvJyArIGtleSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBpbmRleC5hZGRBcGlLZXlcbiAqL1xuSW5kZXgucHJvdG90eXBlLmFkZFVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hZGRBcGlLZXkoYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXguYWRkVXNlcktleSgpJywgJ2luZGV4LmFkZEFwaUtleSgpJykpO1xuXG4vKlxuKiBBZGQgYSBuZXcgQVBJIGtleSB0byB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSB7c3RyaW5nW119IGFjbHMgLSBUaGUgbGlzdCBvZiBBQ0wgZm9yIHRoaXMga2V5LiBEZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdFxuKiAgIGNhbiBjb250YWlucyB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiogICAgIC0gc2VhcmNoOiBhbGxvdyB0byBzZWFyY2ggKGh0dHBzIGFuZCBodHRwKVxuKiAgICAgLSBhZGRPYmplY3Q6IGFsbG93cyB0byBhZGQvdXBkYXRlIGFuIG9iamVjdCBpbiB0aGUgaW5kZXggKGh0dHBzIG9ubHkpXG4qICAgICAtIGRlbGV0ZU9iamVjdCA6IGFsbG93cyB0byBkZWxldGUgYW4gZXhpc3Rpbmcgb2JqZWN0IChodHRwcyBvbmx5KVxuKiAgICAgLSBkZWxldGVJbmRleCA6IGFsbG93cyB0byBkZWxldGUgaW5kZXggY29udGVudCAoaHR0cHMgb25seSlcbiogICAgIC0gc2V0dGluZ3MgOiBhbGxvd3MgdG8gZ2V0IGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuKiAgICAgLSBlZGl0U2V0dGluZ3MgOiBhbGxvd3MgdG8gY2hhbmdlIGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25uYWwgcGFyYW1ldGVycyB0byBzZXQgZm9yIHRoZSBrZXlcbiogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWxpZGl0eSAtIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBrZXkgd2lsbFxuKiBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgKDAgbWVhbnMgbm8gdGltZSBsaW1pdCBmb3IgdGhpcyBrZXkpXG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91ciAtIE51bWJlciBvZiBBUEkgY2FsbHMgYWxsb3dlZCBmcm9tIGFuIElQIGFkZHJlc3MgcGVyIGhvdXJcbiogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnkgLSBOdW1iZXIgb2YgaGl0cyB0aGlzIEFQSSBrZXkgY2FuIHJldHJpZXZlIGluIG9uZSBjYWxsXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIGZvciB5b3VyIGtleVxuKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucmVmZXJlcnMgLSBBIGxpc3Qgb2YgYXV0aG9yaXplZCByZWZlcmVyc1xuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnF1ZXJ5UGFyYW1ldGVycyAtIEZvcmNlIHRoZSBrZXkgdG8gdXNlIHNwZWNpZmljIHF1ZXJ5IHBhcmFtZXRlcnNcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgYWRkZWQgQVBJIGtleVxuKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiogQGV4YW1wbGVcbiogaW5kZXguYWRkVXNlcktleShbJ3NlYXJjaCddLCB7XG4qICAgdmFsaWRpdHk6IDMwMCxcbiogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuKiAgIG1heEhpdHNQZXJRdWVyeTogMyxcbiogICBkZXNjcmlwdGlvbjogJ0VhdCB0aHJlZSBmcnVpdHMnLFxuKiAgIHJlZmVyZXJzOiBbJyouYWxnb2xpYS5jb20nXSxcbiogICBxdWVyeVBhcmFtZXRlcnM6IHtcbiogICAgIHRhZ0ZpbHRlcnM6IFsncHVibGljJ10sXG4qICAgfVxuKiB9KVxuKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQWRkSW5kZXhLZXl8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuKi9cbkluZGV4LnByb3RvdHlwZS5hZGRBcGlLZXkgPSBmdW5jdGlvbihhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LmFkZEFwaUtleShhcnJheU9mQWNsc1ssIHBhcmFtcywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KGFjbHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgYWNsOiBhY2xzXG4gIH07XG5cbiAgaWYgKHBhcmFtcykge1xuICAgIHBvc3RPYmoudmFsaWRpdHkgPSBwYXJhbXMudmFsaWRpdHk7XG4gICAgcG9zdE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgcG9zdE9iai5tYXhIaXRzUGVyUXVlcnkgPSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5O1xuICAgIHBvc3RPYmouZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb247XG5cbiAgICBpZiAocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgcG9zdE9iai5xdWVyeVBhcmFtZXRlcnMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycywgJycpO1xuICAgIH1cblxuICAgIHBvc3RPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL2tleXMnLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4qIEBkZXByZWNhdGVkIHVzZSBpbmRleC5hZGRBcGlLZXkoKVxuKi9cbkluZGV4LnByb3RvdHlwZS5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uIGRlcHJlY2F0ZWRBZGRVc2VyS2V5V2l0aFZhbGlkaXR5KGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYWRkQXBpS2V5KGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4LmFkZFVzZXJLZXlXaXRoVmFsaWRpdHkoKScsICdpbmRleC5hZGRBcGlLZXkoKScpKTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXgudXBkYXRlQXBpS2V5XG4gKi9cbkluZGV4LnByb3RvdHlwZS51cGRhdGVVc2VyS2V5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy51cGRhdGVBcGlLZXkoa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC51cGRhdGVVc2VyS2V5KCknLCAnaW5kZXgudXBkYXRlQXBpS2V5KCknKSk7XG5cbi8qKlxuKiBVcGRhdGUgYW4gZXhpc3RpbmcgQVBJIGtleSBvZiB0aGlzIGluZGV4XG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHVwZGF0ZVxuKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2xzIC0gVGhlIGxpc3Qgb2YgQUNMIGZvciB0aGlzIGtleS4gRGVmaW5lZCBieSBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXRcbiogICBjYW4gY29udGFpbnMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4qICAgICAtIHNlYXJjaDogYWxsb3cgdG8gc2VhcmNoIChodHRwcyBhbmQgaHR0cClcbiogICAgIC0gYWRkT2JqZWN0OiBhbGxvd3MgdG8gYWRkL3VwZGF0ZSBhbiBvYmplY3QgaW4gdGhlIGluZGV4IChodHRwcyBvbmx5KVxuKiAgICAgLSBkZWxldGVPYmplY3QgOiBhbGxvd3MgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIG9iamVjdCAoaHR0cHMgb25seSlcbiogICAgIC0gZGVsZXRlSW5kZXggOiBhbGxvd3MgdG8gZGVsZXRlIGluZGV4IGNvbnRlbnQgKGh0dHBzIG9ubHkpXG4qICAgICAtIHNldHRpbmdzIDogYWxsb3dzIHRvIGdldCBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiogICAgIC0gZWRpdFNldHRpbmdzIDogYWxsb3dzIHRvIGNoYW5nZSBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9ubmFsIHBhcmFtZXRlcnMgdG8gc2V0IGZvciB0aGUga2V5XG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsaWRpdHkgLSBOdW1iZXIgb2Ygc2Vjb25kcyBhZnRlciB3aGljaCB0aGUga2V5IHdpbGxcbiogYmUgYXV0b21hdGljYWxseSByZW1vdmVkICgwIG1lYW5zIG5vIHRpbWUgbGltaXQgZm9yIHRoaXMga2V5KVxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5IC0gTnVtYmVyIG9mIGhpdHMgdGhpcyBBUEkga2V5IGNhbiByZXRyaWV2ZSBpbiBvbmUgY2FsbFxuKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBmb3IgeW91ciBrZXlcbiogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJlZmVyZXJzIC0gQSBsaXN0IG9mIGF1dGhvcml6ZWQgcmVmZXJlcnNcbiogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdXNlciBrZXlzIGxpc3RcbiogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4qIEBleGFtcGxlXG4qIGluZGV4LnVwZGF0ZUFwaUtleSgnQVBJS0VZJywgWydzZWFyY2gnXSwge1xuKiAgIHZhbGlkaXR5OiAzMDAsXG4qICAgbWF4UXVlcmllc1BlcklQUGVySG91cjogMjAwMCxcbiogICBtYXhIaXRzUGVyUXVlcnk6IDMsXG4qICAgZGVzY3JpcHRpb246ICdFYXQgdGhyZWUgZnJ1aXRzJyxcbiogICByZWZlcmVyczogWycqLmFsZ29saWEuY29tJ10sXG4qICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4qICAgICB0YWdGaWx0ZXJzOiBbJ3B1YmxpYyddLFxuKiAgIH1cbiogfSlcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI1VwZGF0ZUluZGV4S2V5fEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleC5wcm90b3R5cGUudXBkYXRlQXBpS2V5ID0gZnVuY3Rpb24oa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LnVwZGF0ZUFwaUtleShrZXksIGFycmF5T2ZBY2xzWywgcGFyYW1zLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkoYWNscykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IG51bGw7XG4gIH1cblxuICB2YXIgcHV0T2JqID0ge1xuICAgIGFjbDogYWNsc1xuICB9O1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBwdXRPYmoudmFsaWRpdHkgPSBwYXJhbXMudmFsaWRpdHk7XG4gICAgcHV0T2JqLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgPSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91cjtcbiAgICBwdXRPYmoubWF4SGl0c1BlclF1ZXJ5ID0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeTtcbiAgICBwdXRPYmouZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb247XG5cbiAgICBpZiAocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgcHV0T2JqLnF1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhwYXJhbXMucXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG4gICAgfVxuXG4gICAgcHV0T2JqLnJlZmVyZXJzID0gcGFyYW1zLnJlZmVyZXJzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL2tleXMvJyArIGtleSxcbiAgICBib2R5OiBwdXRPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXguanMiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsInZhciBidWlsZFNlYXJjaE1ldGhvZCA9IHJlcXVpcmUoJy4vYnVpbGRTZWFyY2hNZXRob2QuanMnKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZS5qcycpO1xudmFyIGRlcHJlY2F0ZWRNZXNzYWdlID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkTWVzc2FnZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4Q29yZTtcblxuLypcbiogSW5kZXggY2xhc3MgY29uc3RydWN0b3IuXG4qIFlvdSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseSBidXQgdXNlIGluaXRJbmRleCgpIGZ1bmN0aW9uXG4qL1xuZnVuY3Rpb24gSW5kZXhDb3JlKGFsZ29saWFzZWFyY2gsIGluZGV4TmFtZSkge1xuICB0aGlzLmluZGV4TmFtZSA9IGluZGV4TmFtZTtcbiAgdGhpcy5hcyA9IGFsZ29saWFzZWFyY2g7XG4gIHRoaXMudHlwZUFoZWFkQXJncyA9IG51bGw7XG4gIHRoaXMudHlwZUFoZWFkVmFsdWVPcHRpb24gPSBudWxsO1xuXG4gIC8vIG1ha2Ugc3VyZSBldmVyeSBpbmRleCBpbnN0YW5jZSBoYXMgaXQncyBvd24gY2FjaGVcbiAgdGhpcy5jYWNoZSA9IHt9O1xufVxuXG4vKlxuKiBDbGVhciBhbGwgcXVlcmllcyBpbiBjYWNoZVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNhY2hlID0ge307XG59O1xuXG4vKlxuKiBTZWFyY2ggaW5zaWRlIHRoZSBpbmRleCB1c2luZyBYTUxIdHRwUmVxdWVzdCByZXF1ZXN0IChVc2luZyBhIFBPU1QgcXVlcnkgdG9cbiogbWluaW1pemUgbnVtYmVyIG9mIE9QVElPTlMgcXVlcmllczogQ3Jvc3MtT3JpZ2luIFJlc291cmNlIFNoYXJpbmcpLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5XSB0aGUgZnVsbCB0ZXh0IHF1ZXJ5XG4qIEBwYXJhbSB7b2JqZWN0fSBbYXJnc10gKG9wdGlvbmFsKSBpZiBzZXQsIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnM6XG4qIC0gcGFnZTogKGludGVnZXIpIFBhZ2luYXRpb24gcGFyYW1ldGVyIHVzZWQgdG8gc2VsZWN0IHRoZSBwYWdlIHRvIHJldHJpZXZlLlxuKiAgICAgICAgICAgICAgICAgICBQYWdlIGlzIHplcm8tYmFzZWQgYW5kIGRlZmF1bHRzIHRvIDAuIFRodXMsXG4qICAgICAgICAgICAgICAgICAgIHRvIHJldHJpZXZlIHRoZSAxMHRoIHBhZ2UgeW91IG5lZWQgdG8gc2V0IHBhZ2U9OVxuKiAtIGhpdHNQZXJQYWdlOiAoaW50ZWdlcikgUGFnaW5hdGlvbiBwYXJhbWV0ZXIgdXNlZCB0byBzZWxlY3QgdGhlIG51bWJlciBvZiBoaXRzIHBlciBwYWdlLiBEZWZhdWx0cyB0byAyMC5cbiogLSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZTogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBvYmplY3QgYXR0cmlidXRlc1xuKiB5b3Ugd2FudCB0byByZXRyaWV2ZSAobGV0IHlvdSBtaW5pbWl6ZSB0aGUgYW5zd2VyIHNpemUpLlxuKiAgIEF0dHJpYnV0ZXMgYXJlIHNlcGFyYXRlZCB3aXRoIGEgY29tbWEgKGZvciBleGFtcGxlIFwibmFtZSxhZGRyZXNzXCIpLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKGZvciBleGFtcGxlIFtcIm5hbWVcIixcImFkZHJlc3NcIl0pLlxuKiAgIEJ5IGRlZmF1bHQsIGFsbCBhdHRyaWJ1dGVzIGFyZSByZXRyaWV2ZWQuIFlvdSBjYW4gYWxzbyB1c2UgJyonIHRvIHJldHJpZXZlIGFsbFxuKiAgIHZhbHVlcyB3aGVuIGFuIGF0dHJpYnV0ZXNUb1JldHJpZXZlIHNldHRpbmcgaXMgc3BlY2lmaWVkIGZvciB5b3VyIGluZGV4LlxuKiAtIGF0dHJpYnV0ZXNUb0hpZ2hsaWdodDogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBhdHRyaWJ1dGVzIHlvdVxuKiAgIHdhbnQgdG8gaGlnaGxpZ2h0IGFjY29yZGluZyB0byB0aGUgcXVlcnkuXG4qICAgQXR0cmlidXRlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEuIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKGZvciBleGFtcGxlIFtcIm5hbWVcIixcImFkZHJlc3NcIl0pLlxuKiAgIElmIGFuIGF0dHJpYnV0ZSBoYXMgbm8gbWF0Y2ggZm9yIHRoZSBxdWVyeSwgdGhlIHJhdyB2YWx1ZSBpcyByZXR1cm5lZC5cbiogICBCeSBkZWZhdWx0IGFsbCBpbmRleGVkIHRleHQgYXR0cmlidXRlcyBhcmUgaGlnaGxpZ2h0ZWQuXG4qICAgWW91IGNhbiB1c2UgYCpgIGlmIHlvdSB3YW50IHRvIGhpZ2hsaWdodCBhbGwgdGV4dHVhbCBhdHRyaWJ1dGVzLlxuKiAgIE51bWVyaWNhbCBhdHRyaWJ1dGVzIGFyZSBub3QgaGlnaGxpZ2h0ZWQuXG4qICAgQSBtYXRjaExldmVsIGlzIHJldHVybmVkIGZvciBlYWNoIGhpZ2hsaWdodGVkIGF0dHJpYnV0ZSBhbmQgY2FuIGNvbnRhaW46XG4qICAgICAgLSBmdWxsOiBpZiBhbGwgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQgaW4gdGhlIGF0dHJpYnV0ZSxcbiogICAgICAtIHBhcnRpYWw6IGlmIG9ubHkgc29tZSBvZiB0aGUgcXVlcnkgdGVybXMgd2VyZSBmb3VuZCxcbiogICAgICAtIG5vbmU6IGlmIG5vbmUgb2YgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQuXG4qIC0gYXR0cmlidXRlc1RvU25pcHBldDogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIHNuaXBwZXQgYWxvbmdzaWRlXG4qIHRoZSBudW1iZXIgb2Ygd29yZHMgdG8gcmV0dXJuIChzeW50YXggaXMgYGF0dHJpYnV0ZU5hbWU6bmJXb3Jkc2ApLlxuKiAgICBBdHRyaWJ1dGVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBjb21tYSAoRXhhbXBsZTogYXR0cmlidXRlc1RvU25pcHBldD1uYW1lOjEwLGNvbnRlbnQ6MTApLlxuKiAgICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChFeGFtcGxlOiBhdHRyaWJ1dGVzVG9TbmlwcGV0OiBbJ25hbWU6MTAnLCdjb250ZW50OjEwJ10pLlxuKiAgICBCeSBkZWZhdWx0IG5vIHNuaXBwZXQgaXMgY29tcHV0ZWQuXG4qIC0gbWluV29yZFNpemVmb3IxVHlwbzogdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gYSBxdWVyeSB3b3JkIHRvIGFjY2VwdCBvbmUgdHlwbyBpbiB0aGlzIHdvcmQuXG4qIERlZmF1bHRzIHRvIDMuXG4qIC0gbWluV29yZFNpemVmb3IyVHlwb3M6IHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIGEgcXVlcnkgd29yZFxuKiB0byBhY2NlcHQgdHdvIHR5cG9zIGluIHRoaXMgd29yZC4gRGVmYXVsdHMgdG8gNy5cbiogLSBnZXRSYW5raW5nSW5mbzogaWYgc2V0IHRvIDEsIHRoZSByZXN1bHQgaGl0cyB3aWxsIGNvbnRhaW4gcmFua2luZ1xuKiBpbmZvcm1hdGlvbiBpbiBfcmFua2luZ0luZm8gYXR0cmlidXRlLlxuKiAtIGFyb3VuZExhdExuZzogc2VhcmNoIGZvciBlbnRyaWVzIGFyb3VuZCBhIGdpdmVuXG4qIGxhdGl0dWRlL2xvbmdpdHVkZSAoc3BlY2lmaWVkIGFzIHR3byBmbG9hdHMgc2VwYXJhdGVkIGJ5IGEgY29tbWEpLlxuKiAgIEZvciBleGFtcGxlIGFyb3VuZExhdExuZz00Ny4zMTY2NjksNS4wMTY2NzApLlxuKiAgIFlvdSBjYW4gc3BlY2lmeSB0aGUgbWF4aW11bSBkaXN0YW5jZSBpbiBtZXRlcnMgd2l0aCB0aGUgYXJvdW5kUmFkaXVzIHBhcmFtZXRlciAoaW4gbWV0ZXJzKVxuKiAgIGFuZCB0aGUgcHJlY2lzaW9uIGZvciByYW5raW5nIHdpdGggYXJvdW5kUHJlY2lzaW9uXG4qICAgKGZvciBleGFtcGxlIGlmIHlvdSBzZXQgYXJvdW5kUHJlY2lzaW9uPTEwMCwgdHdvIG9iamVjdHMgdGhhdCBhcmUgZGlzdGFudCBvZlxuKiAgIGxlc3MgdGhhbiAxMDBtIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBpZGVudGljYWwgZm9yIFwiZ2VvXCIgcmFua2luZyBwYXJhbWV0ZXIpLlxuKiAgIEF0IGluZGV4aW5nLCB5b3Ugc2hvdWxkIHNwZWNpZnkgZ2VvbG9jIG9mIGFuIG9iamVjdCB3aXRoIHRoZSBfZ2VvbG9jIGF0dHJpYnV0ZVxuKiAgIChpbiB0aGUgZm9ybSB7XCJfZ2VvbG9jXCI6e1wibGF0XCI6NDguODUzNDA5LCBcImxuZ1wiOjIuMzQ4ODAwfX0pXG4qIC0gaW5zaWRlQm91bmRpbmdCb3g6IHNlYXJjaCBlbnRyaWVzIGluc2lkZSBhIGdpdmVuIGFyZWEgZGVmaW5lZCBieSB0aGUgdHdvIGV4dHJlbWUgcG9pbnRzXG4qIG9mIGEgcmVjdGFuZ2xlIChkZWZpbmVkIGJ5IDQgZmxvYXRzOiBwMUxhdCxwMUxuZyxwMkxhdCxwMkxuZykuXG4qICAgRm9yIGV4YW1wbGUgaW5zaWRlQm91bmRpbmdCb3g9NDcuMzE2NSw0Ljk2NjUsNDcuMzQyNCw1LjAyMDEpLlxuKiAgIEF0IGluZGV4aW5nLCB5b3Ugc2hvdWxkIHNwZWNpZnkgZ2VvbG9jIG9mIGFuIG9iamVjdCB3aXRoIHRoZSBfZ2VvbG9jIGF0dHJpYnV0ZVxuKiAgIChpbiB0aGUgZm9ybSB7XCJfZ2VvbG9jXCI6e1wibGF0XCI6NDguODUzNDA5LCBcImxuZ1wiOjIuMzQ4ODAwfX0pXG4qIC0gbnVtZXJpY0ZpbHRlcnM6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgbnVtZXJpYyBmaWx0ZXJzIHlvdSB3YW50IHRvXG4qIGFwcGx5IHNlcGFyYXRlZCBieSBhIGNvbW1hLlxuKiAgIFRoZSBzeW50YXggb2Ygb25lIGZpbHRlciBpcyBgYXR0cmlidXRlTmFtZWAgZm9sbG93ZWQgYnkgYG9wZXJhbmRgIGZvbGxvd2VkIGJ5IGB2YWx1ZWAuXG4qICAgU3VwcG9ydGVkIG9wZXJhbmRzIGFyZSBgPGAsIGA8PWAsIGA9YCwgYD5gIGFuZCBgPj1gLlxuKiAgIFlvdSBjYW4gaGF2ZSBtdWx0aXBsZSBjb25kaXRpb25zIG9uIG9uZSBhdHRyaWJ1dGUgbGlrZSBmb3IgZXhhbXBsZSBudW1lcmljRmlsdGVycz1wcmljZT4xMDAscHJpY2U8MTAwMC5cbiogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBudW1lcmljRmlsdGVyczogW1wicHJpY2U+MTAwXCIsXCJwcmljZTwxMDAwXCJdKS5cbiogLSB0YWdGaWx0ZXJzOiBmaWx0ZXIgdGhlIHF1ZXJ5IGJ5IGEgc2V0IG9mIHRhZ3MuIFlvdSBjYW4gQU5EIHRhZ3MgYnkgc2VwYXJhdGluZyB0aGVtIGJ5IGNvbW1hcy5cbiogICBUbyBPUiB0YWdzLCB5b3UgbXVzdCBhZGQgcGFyZW50aGVzZXMuIEZvciBleGFtcGxlLCB0YWdzPXRhZzEsKHRhZzIsdGFnMykgbWVhbnMgdGFnMSBBTkQgKHRhZzIgT1IgdGFnMykuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSwgZm9yIGV4YW1wbGUgdGFnRmlsdGVyczogW1widGFnMVwiLFtcInRhZzJcIixcInRhZzNcIl1dXG4qICAgbWVhbnMgdGFnMSBBTkQgKHRhZzIgT1IgdGFnMykuXG4qICAgQXQgaW5kZXhpbmcsIHRhZ3Mgc2hvdWxkIGJlIGFkZGVkIGluIHRoZSBfdGFncyoqIGF0dHJpYnV0ZVxuKiAgIG9mIG9iamVjdHMgKGZvciBleGFtcGxlIHtcIl90YWdzXCI6W1widGFnMVwiLFwidGFnMlwiXX0pLlxuKiAtIGZhY2V0RmlsdGVyczogZmlsdGVyIHRoZSBxdWVyeSBieSBhIGxpc3Qgb2YgZmFjZXRzLlxuKiAgIEZhY2V0cyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcyBhbmQgZWFjaCBmYWNldCBpcyBlbmNvZGVkIGFzIGBhdHRyaWJ1dGVOYW1lOnZhbHVlYC5cbiogICBGb3IgZXhhbXBsZTogYGZhY2V0RmlsdGVycz1jYXRlZ29yeTpCb29rLGF1dGhvcjpKb2huJTIwRG9lYC5cbiogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBgW1wiY2F0ZWdvcnk6Qm9va1wiLFwiYXV0aG9yOkpvaG4lMjBEb2VcIl1gKS5cbiogLSBmYWNldHM6IExpc3Qgb2Ygb2JqZWN0IGF0dHJpYnV0ZXMgdGhhdCB5b3Ugd2FudCB0byB1c2UgZm9yIGZhY2V0aW5nLlxuKiAgIENvbW1hIHNlcGFyYXRlZCBsaXN0OiBgXCJjYXRlZ29yeSxhdXRob3JcImAgb3IgYXJyYXkgYFsnY2F0ZWdvcnknLCdhdXRob3InXWBcbiogICBPbmx5IGF0dHJpYnV0ZXMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgaW4gKiphdHRyaWJ1dGVzRm9yRmFjZXRpbmcqKiBpbmRleCBzZXR0aW5nXG4qICAgY2FuIGJlIHVzZWQgaW4gdGhpcyBwYXJhbWV0ZXIuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBgKmAgdG8gcGVyZm9ybSBmYWNldGluZyBvbiBhbGwgYXR0cmlidXRlcyBzcGVjaWZpZWQgaW4gKiphdHRyaWJ1dGVzRm9yRmFjZXRpbmcqKi5cbiogLSBxdWVyeVR5cGU6IHNlbGVjdCBob3cgdGhlIHF1ZXJ5IHdvcmRzIGFyZSBpbnRlcnByZXRlZCwgaXQgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlOlxuKiAgICAtIHByZWZpeEFsbDogYWxsIHF1ZXJ5IHdvcmRzIGFyZSBpbnRlcnByZXRlZCBhcyBwcmVmaXhlcyxcbiogICAgLSBwcmVmaXhMYXN0OiBvbmx5IHRoZSBsYXN0IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXggKGRlZmF1bHQgYmVoYXZpb3IpLFxuKiAgICAtIHByZWZpeE5vbmU6IG5vIHF1ZXJ5IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXguIFRoaXMgb3B0aW9uIGlzIG5vdCByZWNvbW1lbmRlZC5cbiogLSBvcHRpb25hbFdvcmRzOiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIHdvcmRzIHRoYXQgc2hvdWxkXG4qIGJlIGNvbnNpZGVyZWQgYXMgb3B0aW9uYWwgd2hlbiBmb3VuZCBpbiB0aGUgcXVlcnkuXG4qICAgQ29tbWEgc2VwYXJhdGVkIGFuZCBhcnJheSBhcmUgYWNjZXB0ZWQuXG4qIC0gZGlzdGluY3Q6IElmIHNldCB0byAxLCBlbmFibGUgdGhlIGRpc3RpbmN0IGZlYXR1cmUgKGRpc2FibGVkIGJ5IGRlZmF1bHQpXG4qIGlmIHRoZSBhdHRyaWJ1dGVGb3JEaXN0aW5jdCBpbmRleCBzZXR0aW5nIGlzIHNldC5cbiogICBUaGlzIGZlYXR1cmUgaXMgc2ltaWxhciB0byB0aGUgU1FMIFwiZGlzdGluY3RcIiBrZXl3b3JkOiB3aGVuIGVuYWJsZWRcbiogICBpbiBhIHF1ZXJ5IHdpdGggdGhlIGRpc3RpbmN0PTEgcGFyYW1ldGVyLFxuKiAgIGFsbCBoaXRzIGNvbnRhaW5pbmcgYSBkdXBsaWNhdGUgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGVGb3JEaXN0aW5jdCBhdHRyaWJ1dGUgYXJlIHJlbW92ZWQgZnJvbSByZXN1bHRzLlxuKiAgIEZvciBleGFtcGxlLCBpZiB0aGUgY2hvc2VuIGF0dHJpYnV0ZSBpcyBzaG93X25hbWUgYW5kIHNldmVyYWwgaGl0cyBoYXZlXG4qICAgdGhlIHNhbWUgdmFsdWUgZm9yIHNob3dfbmFtZSwgdGhlbiBvbmx5IHRoZSBiZXN0XG4qICAgb25lIGlzIGtlcHQgYW5kIG90aGVycyBhcmUgcmVtb3ZlZC5cbiogLSByZXN0cmljdFNlYXJjaGFibGVBdHRyaWJ1dGVzOiBMaXN0IG9mIGF0dHJpYnV0ZXMgeW91IHdhbnQgdG8gdXNlIGZvclxuKiB0ZXh0dWFsIHNlYXJjaCAobXVzdCBiZSBhIHN1YnNldCBvZiB0aGUgYXR0cmlidXRlc1RvSW5kZXggaW5kZXggc2V0dGluZylcbiogZWl0aGVyIGNvbW1hIHNlcGFyYXRlZCBvciBhcyBhbiBhcnJheVxuKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJykuIElmIGZhbHNlLCB0aGUgY29udGVudCBjb250YWlucyB0aGUgZXJyb3IuXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIHJlc3VsdHMuXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5zZWFyY2ggPSBidWlsZFNlYXJjaE1ldGhvZCgncXVlcnknKTtcblxuLypcbiogLS0gQkVUQSAtLVxuKiBTZWFyY2ggYSByZWNvcmQgc2ltaWxhciB0byB0aGUgcXVlcnkgaW5zaWRlIHRoZSBpbmRleCB1c2luZyBYTUxIdHRwUmVxdWVzdCByZXF1ZXN0IChVc2luZyBhIFBPU1QgcXVlcnkgdG9cbiogbWluaW1pemUgbnVtYmVyIG9mIE9QVElPTlMgcXVlcmllczogQ3Jvc3MtT3JpZ2luIFJlc291cmNlIFNoYXJpbmcpLlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5XSB0aGUgc2ltaWxhciBxdWVyeVxuKiBAcGFyYW0ge29iamVjdH0gW2FyZ3NdIChvcHRpb25hbCkgaWYgc2V0LCBjb250YWlucyBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLlxuKiAgIEFsbCBzZWFyY2ggcGFyYW1ldGVycyBhcmUgc3VwcG9ydGVkIChzZWUgc2VhcmNoIGZ1bmN0aW9uKSwgcmVzdHJpY3RTZWFyY2hhYmxlQXR0cmlidXRlcyBhbmQgZmFjZXRGaWx0ZXJzXG4qICAgYXJlIHRoZSB0d28gbW9zdCB1c2VmdWwgdG8gcmVzdHJpY3QgdGhlIHNpbWlsYXIgcmVzdWx0cyBhbmQgZ2V0IG1vcmUgcmVsZXZhbnQgY29udGVudFxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuc2ltaWxhclNlYXJjaCA9IGJ1aWxkU2VhcmNoTWV0aG9kKCdzaW1pbGFyUXVlcnknKTtcblxuLypcbiogQnJvd3NlIGluZGV4IGNvbnRlbnQuIFRoZSByZXNwb25zZSBjb250ZW50IHdpbGwgaGF2ZSBhIGBjdXJzb3JgIHByb3BlcnR5IHRoYXQgeW91IGNhbiB1c2VcbiogdG8gYnJvd3NlIHN1YnNlcXVlbnQgcGFnZXMgZm9yIHRoaXMgcXVlcnkuIFVzZSBgaW5kZXguYnJvd3NlRnJvbShjdXJzb3IpYCB3aGVuIHlvdSB3YW50LlxuKlxuKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgZnVsbCB0ZXh0IHF1ZXJ5XG4qIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbWV0ZXJzXSAtIEFueSBzZWFyY2ggcXVlcnkgcGFyYW1ldGVyXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgYnJvd3NlIHJlc3VsdFxuKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiogQGV4YW1wbGVcbiogaW5kZXguYnJvd3NlKCdjb29sIHNvbmdzJywge1xuKiAgIHRhZ0ZpbHRlcnM6ICdwdWJsaWMsY29tbWVudHMnLFxuKiAgIGhpdHNQZXJQYWdlOiA1MDBcbiogfSwgY2FsbGJhY2spO1xuKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleENvcmUucHJvdG90eXBlLmJyb3dzZSA9IGZ1bmN0aW9uKHF1ZXJ5LCBxdWVyeVBhcmFtZXRlcnMsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXJnZSA9IHJlcXVpcmUoJy4vbWVyZ2UuanMnKTtcblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuXG4gIHZhciBwYWdlO1xuICB2YXIgaGl0c1BlclBhZ2U7XG5cbiAgLy8gd2UgY2hlY2sgdmFyaWFkaWMgY2FsbHMgdGhhdCBhcmUgbm90IHRoZSBvbmUgZGVmaW5lZFxuICAvLyAuYnJvd3NlKCkvLmJyb3dzZShmbilcbiAgLy8gPT4gcGFnZSA9IDBcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGFnZSA9IDA7XG4gICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyAuYnJvd3NlKDIpLy5icm93c2UoMiwgMTApLy5icm93c2UoMiwgZm4pLy5icm93c2UoMiwgMTAsIGZuKVxuICAgIHBhZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICBoaXRzUGVyUGFnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgICAgaGl0c1BlclBhZ2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgIC8vIC5icm93c2UocXVlcnlQYXJhbWV0ZXJzKS8uYnJvd3NlKHF1ZXJ5UGFyYW1ldGVycywgY2IpXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICBxdWVyeVBhcmFtZXRlcnMgPSBhcmd1bWVudHNbMF07XG4gICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC5icm93c2UocXVlcnksIGNiKVxuICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSBpdCdzIGEgLmJyb3dzZShxdWVyeSkvLmJyb3dzZShxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzKS8uYnJvd3NlKHF1ZXJ5LCBxdWVyeVBhcmFtZXRlcnMsIGNiKVxuXG4gIC8vIGdldCBzZWFyY2ggcXVlcnkgcGFyYW1ldGVycyBjb21iaW5pbmcgdmFyaW91cyBwb3NzaWJsZSBjYWxsc1xuICAvLyB0byAuYnJvd3NlKCk7XG4gIHF1ZXJ5UGFyYW1ldGVycyA9IG1lcmdlKHt9LCBxdWVyeVBhcmFtZXRlcnMgfHwge30sIHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIGhpdHNQZXJQYWdlOiBoaXRzUGVyUGFnZSxcbiAgICBxdWVyeTogcXVlcnlcbiAgfSk7XG5cbiAgdmFyIHBhcmFtcyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhxdWVyeVBhcmFtZXRlcnMsICcnKTtcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9icm93c2UnLFxuICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc30sXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBDb250aW51ZSBicm93c2luZyBmcm9tIGEgcHJldmlvdXMgcG9zaXRpb24gKGN1cnNvciksIG9idGFpbmVkIHZpYSBhIGNhbGwgdG8gYC5icm93c2UoKWAuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBmdWxsIHRleHQgcXVlcnlcbiogQHBhcmFtIHtPYmplY3R9IFtxdWVyeVBhcmFtZXRlcnNdIC0gQW55IHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBicm93c2UgcmVzdWx0XG4qIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuKiBAZXhhbXBsZVxuKiBpbmRleC5icm93c2VGcm9tKCcxNGxrZnNha2wzMicsIGNhbGxiYWNrKTtcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0Jyb3dzZXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5icm93c2VGcm9tID0gZnVuY3Rpb24oY3Vyc29yLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL2Jyb3dzZScsXG4gICAgYm9keToge2N1cnNvcjogY3Vyc29yfSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIFNlYXJjaCBmb3IgZmFjZXQgdmFsdWVzXG4qIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0LWFwaS9zZWFyY2gjc2VhcmNoLWZvci1mYWNldC12YWx1ZXNcbipcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWNldE5hbWUgRmFjZXQgbmFtZSwgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNlYXJjaCBmb3IgdmFsdWVzIGluLlxuKiBNdXN0IGJlIGRlY2xhcmVkIGFzIGEgZmFjZXRcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWNldFF1ZXJ5IFF1ZXJ5IGZvciB0aGUgZmFjZXQgc2VhcmNoXG4qIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLipdIEFueSBzZWFyY2ggcGFyYW1ldGVyIG9mIEFsZ29saWEsXG4qIHNlZSBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvYXBpLWNsaWVudC9qYXZhc2NyaXB0L3NlYXJjaCNzZWFyY2gtcGFyYW1ldGVyc1xuKiBQYWdpbmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuIFRoZSBwYWdlIGFuZCBoaXRzUGVyUGFnZSBwYXJhbWV0ZXJzIHdpbGwgYmUgaWdub3JlZC5cbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbClcbiovXG5JbmRleENvcmUucHJvdG90eXBlLnNlYXJjaEZvckZhY2V0VmFsdWVzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG4gIHZhciBvbWl0ID0gcmVxdWlyZSgnLi9vbWl0LmpzJyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguc2VhcmNoRm9yRmFjZXRWYWx1ZXMoe2ZhY2V0TmFtZSwgZmFjZXRRdWVyeSwgLi4ucGFyYW1zfVssIGNhbGxiYWNrXSknO1xuXG4gIGlmIChwYXJhbXMuZmFjZXROYW1lID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmZhY2V0UXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgZmFjZXROYW1lID0gcGFyYW1zLmZhY2V0TmFtZTtcbiAgdmFyIGZpbHRlcmVkUGFyYW1zID0gb21pdChjbG9uZShwYXJhbXMpLCBmdW5jdGlvbihrZXlOYW1lKSB7XG4gICAgcmV0dXJuIGtleU5hbWUgPT09ICdmYWNldE5hbWUnO1xuICB9KTtcbiAgdmFyIHNlYXJjaFBhcmFtZXRlcnMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMoZmlsdGVyZWRQYXJhbXMsICcnKTtcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArXG4gICAgICBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9mYWNldHMvJyArIGVuY29kZVVSSUNvbXBvbmVudChmYWNldE5hbWUpICsgJy9xdWVyeScsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBib2R5OiB7cGFyYW1zOiBzZWFyY2hQYXJhbWV0ZXJzfSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleENvcmUucHJvdG90eXBlLnNlYXJjaEZhY2V0ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuc2VhcmNoRm9yRmFjZXRWYWx1ZXMocGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZShcbiAgJ2luZGV4LnNlYXJjaEZhY2V0KHBhcmFtc1ssIGNhbGxiYWNrXSknLFxuICAnaW5kZXguc2VhcmNoRm9yRmFjZXRWYWx1ZXMocGFyYW1zWywgY2FsbGJhY2tdKSdcbikpO1xuXG5JbmRleENvcmUucHJvdG90eXBlLl9zZWFyY2ggPSBmdW5jdGlvbihwYXJhbXMsIHVybCwgY2FsbGJhY2ssIGFkZGl0aW9uYWxVQSkge1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdXJsIHx8ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9xdWVyeScsXG4gICAgYm9keToge3BhcmFtczogcGFyYW1zfSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGZhbGxiYWNrOiB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSxcbiAgICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc31cbiAgICB9LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBhZGRpdGlvbmFsVUE6IGFkZGl0aW9uYWxVQVxuICB9KTtcbn07XG5cbi8qXG4qIEdldCBhbiBvYmplY3QgZnJvbSB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBvYmplY3RJRCB0aGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIG9iamVjdCB0byByZXRyaWV2ZVxuKiBAcGFyYW0gYXR0cnMgKG9wdGlvbmFsKSBpZiBzZXQsIGNvbnRhaW5zIHRoZSBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gcmV0cmlldmVcbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgb2JqZWN0IHRvIHJldHJpZXZlIG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5nZXRPYmplY3QgPSBmdW5jdGlvbihvYmplY3RJRCwgYXR0cnMsIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGF0dHJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBhdHRycztcbiAgICBhdHRycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBwYXJhbXMgPSAnJztcbiAgaWYgKGF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMgPSAnP2F0dHJpYnV0ZXM9JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBwYXJhbXMgKz0gJywnO1xuICAgICAgfVxuICAgICAgcGFyYW1zICs9IGF0dHJzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCkgKyBwYXJhbXMsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBHZXQgc2V2ZXJhbCBvYmplY3RzIGZyb20gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gb2JqZWN0SURzIHRoZSBhcnJheSBvZiB1bmlxdWUgaWRlbnRpZmllciBvZiBvYmplY3RzIHRvIHJldHJpZXZlXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5nZXRPYmplY3RzID0gZnVuY3Rpb24ob2JqZWN0SURzLCBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguZ2V0T2JqZWN0cyhhcnJheU9mT2JqZWN0SURzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9iamVjdElEcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgYXR0cmlidXRlc1RvUmV0cmlldmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGF0dHJpYnV0ZXNUb1JldHJpZXZlO1xuICAgIGF0dHJpYnV0ZXNUb1JldHJpZXZlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGJvZHkgPSB7XG4gICAgcmVxdWVzdHM6IG1hcChvYmplY3RJRHMsIGZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KG9iamVjdElEKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgaW5kZXhOYW1lOiBpbmRleE9iai5pbmRleE5hbWUsXG4gICAgICAgIG9iamVjdElEOiBvYmplY3RJRFxuICAgICAgfTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZXNUb1JldHJpZXZlKSB7XG4gICAgICAgIHJlcXVlc3QuYXR0cmlidXRlc1RvUmV0cmlldmUgPSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZS5qb2luKCcsJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0pXG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLyovb2JqZWN0cycsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBib2R5OiBib2R5LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4Q29yZS5wcm90b3R5cGUuYXMgPSBudWxsO1xuSW5kZXhDb3JlLnByb3RvdHlwZS5pbmRleE5hbWUgPSBudWxsO1xuSW5kZXhDb3JlLnByb3RvdHlwZS50eXBlQWhlYWRBcmdzID0gbnVsbDtcbkluZGV4Q29yZS5wcm90b3R5cGUudHlwZUFoZWFkVmFsdWVPcHRpb24gPSBudWxsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleENvcmUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGJ1aWxkU2VhcmNoTWV0aG9kO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMuanMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VhcmNoIG1ldGhvZCB0byBiZSB1c2VkIGluIGNsaWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVBhcmFtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdXNlZCBmb3IgdGhlIHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHRoZSB1cmxcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSB0aGUgc2VhcmNoIG1ldGhvZFxuICovXG5mdW5jdGlvbiBidWlsZFNlYXJjaE1ldGhvZChxdWVyeVBhcmFtLCB1cmwpIHtcbiAgLyoqXG4gICAqIFRoZSBzZWFyY2ggbWV0aG9kLiBQcmVwYXJlcyB0aGUgZGF0YSBhbmQgc2VuZCB0aGUgcXVlcnkgdG8gQWxnb2xpYS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBzdHJpbmcgdXNlZCBmb3IgcXVlcnkgc2VhcmNoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBzZW5kIHdpdGggdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCB0aGUgY2xpZW50IGdldHMgdGhlIGFuc3dlclxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR8UHJvbWlzZX0gSWYgdGhlIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZCB0aGVuIHRoaXMgbWV0aG9kcyByZXR1cm5zIGEgUHJvbWlzZVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYXJjaChxdWVyeSwgYXJncywgY2FsbGJhY2spIHtcbiAgICAvLyB3YXJuIFYyIHVzZXJzIG9uIGhvdyB0byBzZWFyY2hcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmdzID09PSAnb2JqZWN0JyB8fFxuICAgICAgdHlwZW9mIGNhbGxiYWNrID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gLnNlYXJjaChxdWVyeSwgcGFyYW1zLCBjYilcbiAgICAgIC8vIC5zZWFyY2goY2IsIHBhcmFtcylcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdpbmRleC5zZWFyY2ggdXNhZ2UgaXMgaW5kZXguc2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIGNiKScpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6aW5nIHRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgcXVlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFVzYWdlIDogLnNlYXJjaCgpLCAuc2VhcmNoKGNiKVxuICAgICAgY2FsbGJhY2sgPSBxdWVyeTtcbiAgICAgIHF1ZXJ5ID0gJyc7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBhcmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2FnZSA6IC5zZWFyY2gocXVlcnkvYXJncyksIC5zZWFyY2gocXVlcnksIGNiKVxuICAgICAgY2FsbGJhY2sgPSBhcmdzO1xuICAgICAgYXJncyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIDMgYXJndW1lbnRzIHdpdGggdmFsdWVzXG5cbiAgICAvLyBVc2FnZSA6IC5zZWFyY2goYXJncykgLy8gY2FyZWZ1bDogdHlwZW9mIG51bGwgPT09ICdvYmplY3QnXG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgcXVlcnkgIT09IG51bGwpIHtcbiAgICAgIGFyZ3MgPSBxdWVyeTtcbiAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocXVlcnkgPT09IHVuZGVmaW5lZCB8fCBxdWVyeSA9PT0gbnVsbCkgeyAvLyAuc2VhcmNoKHVuZGVmaW5lZC9udWxsKVxuICAgICAgcXVlcnkgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gJyc7XG5cbiAgICBpZiAocXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW1zICs9IHF1ZXJ5UGFyYW0gKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocXVlcnkpO1xuICAgIH1cblxuICAgIHZhciBhZGRpdGlvbmFsVUE7XG4gICAgaWYgKGFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGFyZ3MuYWRkaXRpb25hbFVBKSB7XG4gICAgICAgIGFkZGl0aW9uYWxVQSA9IGFyZ3MuYWRkaXRpb25hbFVBO1xuICAgICAgICBkZWxldGUgYXJncy5hZGRpdGlvbmFsVUE7XG4gICAgICB9XG4gICAgICAvLyBgX2dldFNlYXJjaFBhcmFtc2Agd2lsbCBhdWdtZW50IHBhcmFtcywgZG8gbm90IGJlIGZvb2xlZCBieSB0aGUgPSB2ZXJzdXMgKz0gZnJvbSBwcmV2aW91cyBpZlxuICAgICAgcGFyYW1zID0gdGhpcy5hcy5fZ2V0U2VhcmNoUGFyYW1zKGFyZ3MsIHBhcmFtcyk7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoKHBhcmFtcywgdXJsLCBjYWxsYmFjaywgYWRkaXRpb25hbFVBKTtcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvYnVpbGRTZWFyY2hNZXRob2QuanMiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBob3N0cyBvdXIgZXJyb3IgZGVmaW5pdGlvbnNcbi8vIFdlIHVzZSBjdXN0b20gZXJyb3IgXCJ0eXBlc1wiIHNvIHRoYXQgd2UgY2FuIGFjdCBvbiB0aGVtIHdoZW4gd2UgbmVlZCBpdFxuLy8gZS5nLjogaWYgZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuVW5wYXJzYWJsZUpTT04gdGhlbi4uXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmZ1bmN0aW9uIEFsZ29saWFTZWFyY2hFcnJvcihtZXNzYWdlLCBleHRyYVByb3BlcnRpZXMpIHtcbiAgdmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbiAgdmFyIGVycm9yID0gdGhpcztcblxuICAvLyB0cnkgdG8gZ2V0IGEgc3RhY2t0cmFjZVxuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3Iuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICdDYW5ub3QgZ2V0IGEgc3RhY2t0cmFjZSwgYnJvd3NlciBpcyB0b28gb2xkJztcbiAgfVxuXG4gIHRoaXMubmFtZSA9ICdBbGdvbGlhU2VhcmNoRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJztcblxuICBpZiAoZXh0cmFQcm9wZXJ0aWVzKSB7XG4gICAgZm9yRWFjaChleHRyYVByb3BlcnRpZXMsIGZ1bmN0aW9uIGFkZFRvRXJyb3JPYmplY3QodmFsdWUsIGtleSkge1xuICAgICAgZXJyb3Jba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG59XG5cbmluaGVyaXRzKEFsZ29saWFTZWFyY2hFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXN0b21FcnJvcihuYW1lLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIEFsZ29saWFTZWFyY2hDdXN0b21FcnJvcigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAvLyBjdXN0b20gbWVzc2FnZSBub3Qgc2V0LCB1c2UgZGVmYXVsdFxuICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGFyZ3MudW5zaGlmdChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBBbGdvbGlhU2VhcmNoRXJyb3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdGhpcy5uYW1lID0gJ0FsZ29saWFTZWFyY2gnICsgbmFtZSArICdFcnJvcic7XG4gIH1cblxuICBpbmhlcml0cyhBbGdvbGlhU2VhcmNoQ3VzdG9tRXJyb3IsIEFsZ29saWFTZWFyY2hFcnJvcik7XG5cbiAgcmV0dXJuIEFsZ29saWFTZWFyY2hDdXN0b21FcnJvcjtcbn1cblxuLy8gbGF0ZSBleHBvcnRzIHRvIGxldCB2YXJpb3VzIGZuIGRlZnMgYW5kIGluaGVyaXRzIHRha2UgcGxhY2Vcbm1vZHVsZS5leHBvcnRzID0ge1xuICBBbGdvbGlhU2VhcmNoRXJyb3I6IEFsZ29saWFTZWFyY2hFcnJvcixcbiAgVW5wYXJzYWJsZUpTT046IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdVbnBhcnNhYmxlSlNPTicsXG4gICAgJ0NvdWxkIG5vdCBwYXJzZSB0aGUgaW5jb21pbmcgcmVzcG9uc2UgYXMgSlNPTiwgc2VlIGVyci5tb3JlIGZvciBkZXRhaWxzJ1xuICApLFxuICBSZXF1ZXN0VGltZW91dDogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ1JlcXVlc3RUaW1lb3V0JyxcbiAgICAnUmVxdWVzdCB0aW1lZG91dCBiZWZvcmUgZ2V0dGluZyBhIHJlc3BvbnNlJ1xuICApLFxuICBOZXR3b3JrOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnTmV0d29yaycsXG4gICAgJ05ldHdvcmsgaXNzdWUsIHNlZSBlcnIubW9yZSBmb3IgZGV0YWlscydcbiAgKSxcbiAgSlNPTlBTY3JpcHRGYWlsOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnSlNPTlBTY3JpcHRGYWlsJyxcbiAgICAnPHNjcmlwdD4gd2FzIGxvYWRlZCBidXQgZGlkIG5vdCBjYWxsIG91ciBwcm92aWRlZCBjYWxsYmFjaydcbiAgKSxcbiAgSlNPTlBTY3JpcHRFcnJvcjogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ0pTT05QU2NyaXB0RXJyb3InLFxuICAgICc8c2NyaXB0PiB1bmFibGUgdG8gbG9hZCBkdWUgdG8gYW4gYGVycm9yYCBldmVudCBvbiBpdCdcbiAgKSxcbiAgVW5rbm93bjogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ1Vua25vd24nLFxuICAgICdVbmtub3duIGVycm9yIG9jY3VyZWQnXG4gIClcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Vycm9ycy5qcyIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZvcmVhY2gvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbWVzc2FnZSkge1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgLyogZXNsaW50IG5vLWNvbnNvbGU6MCAqL1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZXByZWNhdGVkTWVzc2FnZShwcmV2aW91c1VzYWdlLCBuZXdVc2FnZSkge1xuICB2YXIgZ2l0aHViQW5jaG9yTGluayA9IHByZXZpb3VzVXNhZ2UudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC9bXFwuXFwoXFwpXS9nLCAnJyk7XG5cbiAgcmV0dXJuICdhbGdvbGlhc2VhcmNoOiBgJyArIHByZXZpb3VzVXNhZ2UgKyAnYCB3YXMgcmVwbGFjZWQgYnkgYCcgKyBuZXdVc2FnZSArXG4gICAgJ2AuIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYWxnb2xpYXNlYXJjaC1jbGllbnQtamF2YXNjcmlwdC93aWtpL0RlcHJlY2F0ZWQjJyArIGdpdGh1YkFuY2hvckxpbms7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9kZXByZWNhdGVkTWVzc2FnZS5qcyIsInZhciBmb3JlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlKGRlc3RpbmF0aW9uLyogLCBzb3VyY2VzICovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmb3JlYWNoKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIGZvciAodmFyIGtleU5hbWUgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleU5hbWUpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25ba2V5TmFtZV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBzb3VyY2Vba2V5TmFtZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25ba2V5TmFtZV0gPSBtZXJnZSh7fSwgZGVzdGluYXRpb25ba2V5TmFtZV0sIHNvdXJjZVtrZXlOYW1lXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlW2tleU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltrZXlOYW1lXSA9IHNvdXJjZVtrZXlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvbWVyZ2UuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Nsb25lLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvbWl0KG9iaiwgdGVzdCkge1xuICB2YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG4gIHZhciBmb3JlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG4gIHZhciBmaWx0ZXJlZCA9IHt9O1xuXG4gIGZvcmVhY2goa2V5cyhvYmopLCBmdW5jdGlvbiBkb0ZpbHRlcihrZXlOYW1lKSB7XG4gICAgaWYgKHRlc3Qoa2V5TmFtZSkgIT09IHRydWUpIHtcbiAgICAgIGZpbHRlcmVkW2tleU5hbWVdID0gb2JqW2tleU5hbWVdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvb21pdC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG52YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xudmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG52YXIgZG9udEVudW1zID0gW1xuXHQndG9TdHJpbmcnLFxuXHQndG9Mb2NhbGVTdHJpbmcnLFxuXHQndmFsdWVPZicsXG5cdCdoYXNPd25Qcm9wZXJ0eScsXG5cdCdpc1Byb3RvdHlwZU9mJyxcblx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0J2NvbnN0cnVjdG9yJ1xuXTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG59O1xudmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0JGNvbnNvbGU6IHRydWUsXG5cdCRleHRlcm5hbDogdHJ1ZSxcblx0JGZyYW1lOiB0cnVlLFxuXHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHQkZnJhbWVzOiB0cnVlLFxuXHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdCRpbm5lcldpZHRoOiB0cnVlLFxuXHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdCRvdXRlcldpZHRoOiB0cnVlLFxuXHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0JHBhcmVudDogdHJ1ZSxcblx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdCRzY3JvbGxUb3A6IHRydWUsXG5cdCRzY3JvbGxYOiB0cnVlLFxuXHQkc2Nyb2xsWTogdHJ1ZSxcblx0JHNlbGY6IHRydWUsXG5cdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0JHdpbmRvdzogdHJ1ZVxufTtcbnZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufSgpKTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIga2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0fVxuXG5cdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhlS2V5cztcbn07XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHJldHVybiAoT2JqZWN0LmtleXMoYXJndW1lbnRzKSB8fCAnJykubGVuZ3RoID09PSAyO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0dmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL34vb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9+L2lzYXJyYXkvaW5kZXguanMiLCJ2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICB2YXIgbmV3QXJyID0gW107XG4gIGZvcmVhY2goYXJyLCBmdW5jdGlvbihpdGVtLCBpdGVtSW5kZXgpIHtcbiAgICBuZXdBcnIucHVzaChmbihpdGVtLCBpdGVtSW5kZXgsIGFycikpO1xuICB9KTtcbiAgcmV0dXJuIG5ld0Fycjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL21hcC5qcyIsIi8vIFBhcnNlIGNsb3VkIGRvZXMgbm90IHN1cHBvcnRzIHNldFRpbWVvdXRcbi8vIFdlIGRvIG5vdCBzdG9yZSBhIHNldFRpbWVvdXQgcmVmZXJlbmNlIGluIHRoZSBjbGllbnQgZXZlcnl0aW1lXG4vLyBXZSBvbmx5IGZhbGxiYWNrIHRvIGEgZmFrZSBzZXRUaW1lb3V0IHdoZW4gbm90IGF2YWlsYWJsZVxuLy8gc2V0VGltZW91dCBjYW5ub3QgYmUgb3ZlcnJpZGUgZ2xvYmFsbHkgc2FkbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhpdFByb21pc2UoZm4sIF9zZXRUaW1lb3V0KSB7XG4gIF9zZXRUaW1lb3V0KGZuLCAwKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2V4aXRQcm9taXNlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGlzIHRoZSBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIGBpbmRleC5icm93c2VBbGwoKWAgbWV0aG9kXG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhCcm93c2VyO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gSW5kZXhCcm93c2VyKCkge1xufVxuXG5pbmhlcml0cyhJbmRleEJyb3dzZXIsIEV2ZW50RW1pdHRlcik7XG5cbkluZGV4QnJvd3Nlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgdGhpcy5fY2xlYW4oKTtcbn07XG5cbkluZGV4QnJvd3Nlci5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2VuZCcpO1xuICB0aGlzLl9jbGVhbigpO1xufTtcblxuSW5kZXhCcm93c2VyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuX2NsZWFuKCk7XG59O1xuXG5JbmRleEJyb3dzZXIucHJvdG90eXBlLl9yZXN1bHQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHRoaXMuZW1pdCgncmVzdWx0JywgY29udGVudCk7XG59O1xuXG5JbmRleEJyb3dzZXIucHJvdG90eXBlLl9jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnc3RvcCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVzdWx0Jyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleEJyb3dzZXIuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2V2ZW50cy9ldmVudHMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IEFsZ29saWFTZWFyY2hDb3JlO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciBleGl0UHJvbWlzZSA9IHJlcXVpcmUoJy4vZXhpdFByb21pc2UuanMnKTtcbnZhciBJbmRleENvcmUgPSByZXF1aXJlKCcuL0luZGV4Q29yZS5qcycpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZS5qcycpO1xuXG4vLyBXZSB3aWxsIGFsd2F5cyBwdXQgdGhlIEFQSSBLRVkgaW4gdGhlIEpTT04gYm9keSBpbiBjYXNlIG9mIHRvbyBsb25nIEFQSSBLRVksXG4vLyB0byBhdm9pZCBxdWVyeSBzdHJpbmcgYmVpbmcgdG9vIGxvbmcgYW5kIGZhaWxpbmcgaW4gdmFyaW91cyBjb25kaXRpb25zIChvdXIgc2VydmVyIGxpbWl0LCBicm93c2VyIGxpbWl0LFxuLy8gcHJveGllcyBsaW1pdClcbnZhciBNQVhfQVBJX0tFWV9MRU5HVEggPSA1MDA7XG52YXIgUkVTRVRfQVBQX0RBVEFfVElNRVIgPVxuICBwcm9jZXNzLmVudi5SRVNFVF9BUFBfREFUQV9USU1FUiAmJiBwYXJzZUludChwcm9jZXNzLmVudi5SRVNFVF9BUFBfREFUQV9USU1FUiwgMTApIHx8XG4gIDYwICogMiAqIDEwMDA7IC8vIGFmdGVyIDIgbWludXRlcyByZXNldCB0byBmaXJzdCBob3N0XG5cbi8qXG4gKiBBbGdvbGlhIFNlYXJjaCBsaWJyYXJ5IGluaXRpYWxpemF0aW9uXG4gKiBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwbGljYXRpb25JRCAtIFlvdXIgYXBwbGljYXRpb25JRCwgZm91bmQgaW4geW91ciBkYXNoYm9hcmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXkgLSBZb3VyIEFQSSBrZXksIGZvdW5kIGluIHlvdXIgZGFzaGJvYXJkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0yMDAwXSAtIFRoZSByZXF1ZXN0IHRpbWVvdXQgc2V0IGluIG1pbGxpc2Vjb25kcyxcbiAqIGFub3RoZXIgcmVxdWVzdCB3aWxsIGJlIGlzc3VlZCBhZnRlciB0aGlzIHRpbWVvdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wcm90b2NvbD0naHR0cDonXSAtIFRoZSBwcm90b2NvbCB1c2VkIHRvIHF1ZXJ5IEFsZ29saWEgU2VhcmNoIEFQSS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCB0byAnaHR0cHM6JyB0byBmb3JjZSB1c2luZyBodHRwcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdG8gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgaW4gYnJvd3NlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBbb3B0cy5ob3N0cz17XG4gKiAgICAgICAgICAgcmVhZDogW3RoaXMuYXBwbGljYXRpb25JRCArICctZHNuLmFsZ29saWEubmV0J10uY29uY2F0KFtcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMS5hbGdvbGlhbmV0LmNvbScsXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTIuYWxnb2xpYW5ldC5jb20nLFxuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0zLmFsZ29saWFuZXQuY29tJ11cbiAqICAgICAgICAgICBdKSxcbiAqICAgICAgICAgICB3cml0ZTogW3RoaXMuYXBwbGljYXRpb25JRCArICcuYWxnb2xpYS5uZXQnXS5jb25jYXQoW1xuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0xLmFsZ29saWFuZXQuY29tJyxcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMi5hbGdvbGlhbmV0LmNvbScsXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTMuYWxnb2xpYW5ldC5jb20nXVxuICogICAgICAgICAgIF0pIC0gVGhlIGhvc3RzIHRvIHVzZSBmb3IgQWxnb2xpYSBTZWFyY2ggQVBJLlxuICogICAgICAgICAgIElmIHlvdSBwcm92aWRlIHRoZW0sIHlvdSB3aWxsIGxlc3MgYmVuZWZpdCBmcm9tIG91ciBIQSBpbXBsZW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiBBbGdvbGlhU2VhcmNoQ29yZShhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpIHtcbiAgdmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxnb2xpYXNlYXJjaCcpO1xuXG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKTtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciB1c2FnZSA9ICdVc2FnZTogYWxnb2xpYXNlYXJjaChhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpJztcblxuICBpZiAob3B0cy5fYWxsb3dFbXB0eUNyZWRlbnRpYWxzICE9PSB0cnVlICYmICFhcHBsaWNhdGlvbklEKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGFuIGFwcGxpY2F0aW9uIElELiAnICsgdXNhZ2UpO1xuICB9XG5cbiAgaWYgKG9wdHMuX2FsbG93RW1wdHlDcmVkZW50aWFscyAhPT0gdHJ1ZSAmJiAhYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGFuIEFQSSBrZXkuICcgKyB1c2FnZSk7XG4gIH1cblxuICB0aGlzLmFwcGxpY2F0aW9uSUQgPSBhcHBsaWNhdGlvbklEO1xuICB0aGlzLmFwaUtleSA9IGFwaUtleTtcblxuICB0aGlzLmhvc3RzID0ge1xuICAgIHJlYWQ6IFtdLFxuICAgIHdyaXRlOiBbXVxuICB9O1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgfHwgJ2h0dHBzOic7XG4gIHRoaXMuX3RpbWVvdXRzID0gb3B0cy50aW1lb3V0cyB8fCB7XG4gICAgY29ubmVjdDogMSAqIDEwMDAsIC8vIDUwMG1zIGNvbm5lY3QgaXMgR1BSUyBsYXRlbmN5XG4gICAgcmVhZDogMiAqIDEwMDAsXG4gICAgd3JpdGU6IDMwICogMTAwMFxuICB9O1xuXG4gIC8vIGJhY2t3YXJkIGNvbXBhdCwgaWYgb3B0cy50aW1lb3V0IGlzIHBhc3NlZCwgd2UgdXNlIGl0IHRvIGNvbmZpZ3VyZSBhbGwgdGltZW91dHMgbGlrZSBiZWZvcmVcbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHRoaXMuX3RpbWVvdXRzLmNvbm5lY3QgPSB0aGlzLl90aW1lb3V0cy5yZWFkID0gdGhpcy5fdGltZW91dHMud3JpdGUgPSBvcHRzLnRpbWVvdXQ7XG4gIH1cblxuICAvLyB3aGlsZSB3ZSBhZHZvY2F0ZSBmb3IgY29sb24tYXQtdGhlLWVuZCB2YWx1ZXM6ICdodHRwOicgZm9yIGBvcHRzLnByb3RvY29sYFxuICAvLyB3ZSBhbHNvIGFjY2VwdCBgaHR0cGAgYW5kIGBodHRwc2AuIEl0J3MgYSBjb21tb24gZXJyb3IuXG4gIGlmICghLzokLy50ZXN0KHByb3RvY29sKSkge1xuICAgIHByb3RvY29sID0gcHJvdG9jb2wgKyAnOic7XG4gIH1cblxuICBpZiAob3B0cy5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBvcHRzLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdwcm90b2NvbCBtdXN0IGJlIGBodHRwOmAgb3IgYGh0dHBzOmAgKHdhcyBgJyArIG9wdHMucHJvdG9jb2wgKyAnYCknKTtcbiAgfVxuXG4gIHRoaXMuX2NoZWNrQXBwSWREYXRhKCk7XG5cbiAgaWYgKCFvcHRzLmhvc3RzKSB7XG4gICAgdmFyIGRlZmF1bHRIb3N0cyA9IG1hcCh0aGlzLl9zaHVmZmxlUmVzdWx0LCBmdW5jdGlvbihob3N0TnVtYmVyKSB7XG4gICAgICByZXR1cm4gYXBwbGljYXRpb25JRCArICctJyArIGhvc3ROdW1iZXIgKyAnLmFsZ29saWFuZXQuY29tJztcbiAgICB9KTtcblxuICAgIC8vIG5vIGhvc3RzIGdpdmVuLCBjb21wdXRlIGRlZmF1bHRzXG4gICAgdGhpcy5ob3N0cy5yZWFkID0gW3RoaXMuYXBwbGljYXRpb25JRCArICctZHNuLmFsZ29saWEubmV0J10uY29uY2F0KGRlZmF1bHRIb3N0cyk7XG4gICAgdGhpcy5ob3N0cy53cml0ZSA9IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLmFsZ29saWEubmV0J10uY29uY2F0KGRlZmF1bHRIb3N0cyk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShvcHRzLmhvc3RzKSkge1xuICAgIC8vIHdoZW4gcGFzc2luZyBjdXN0b20gaG9zdHMsIHdlIG5lZWQgdG8gaGF2ZSBhIGRpZmZlcmVudCBob3N0IGluZGV4IGlmIHRoZSBudW1iZXJcbiAgICAvLyBvZiB3cml0ZS9yZWFkIGhvc3RzIGFyZSBkaWZmZXJlbnQuXG4gICAgdGhpcy5ob3N0cy5yZWFkID0gY2xvbmUob3B0cy5ob3N0cyk7XG4gICAgdGhpcy5ob3N0cy53cml0ZSA9IGNsb25lKG9wdHMuaG9zdHMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaG9zdHMucmVhZCA9IGNsb25lKG9wdHMuaG9zdHMucmVhZCk7XG4gICAgdGhpcy5ob3N0cy53cml0ZSA9IGNsb25lKG9wdHMuaG9zdHMud3JpdGUpO1xuICB9XG5cbiAgLy8gYWRkIHByb3RvY29sIGFuZCBsb3dlcmNhc2UgaG9zdHNcbiAgdGhpcy5ob3N0cy5yZWFkID0gbWFwKHRoaXMuaG9zdHMucmVhZCwgcHJlcGFyZUhvc3QocHJvdG9jb2wpKTtcbiAgdGhpcy5ob3N0cy53cml0ZSA9IG1hcCh0aGlzLmhvc3RzLndyaXRlLCBwcmVwYXJlSG9zdChwcm90b2NvbCkpO1xuXG4gIHRoaXMuZXh0cmFIZWFkZXJzID0ge307XG5cbiAgLy8gSW4gc29tZSBzaXR1YXRpb25zIHlvdSBtaWdodCB3YW50IHRvIHdhcm0gdGhlIGNhY2hlXG4gIHRoaXMuY2FjaGUgPSBvcHRzLl9jYWNoZSB8fCB7fTtcblxuICB0aGlzLl91YSA9IG9wdHMuX3VhO1xuICB0aGlzLl91c2VDYWNoZSA9IG9wdHMuX3VzZUNhY2hlID09PSB1bmRlZmluZWQgfHwgb3B0cy5fY2FjaGUgPyB0cnVlIDogb3B0cy5fdXNlQ2FjaGU7XG4gIHRoaXMuX3VzZUZhbGxiYWNrID0gb3B0cy51c2VGYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMudXNlRmFsbGJhY2s7XG5cbiAgdGhpcy5fc2V0VGltZW91dCA9IG9wdHMuX3NldFRpbWVvdXQ7XG5cbiAgZGVidWcoJ2luaXQgZG9uZSwgJWonLCB0aGlzKTtcbn1cblxuLypcbiAqIEdldCB0aGUgaW5kZXggb2JqZWN0IGluaXRpYWxpemVkXG4gKlxuICogQHBhcmFtIGluZGV4TmFtZSB0aGUgbmFtZSBvZiBpbmRleFxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgd2l0aCBvbmUgYXJndW1lbnQgKHRoZSBJbmRleCBpbnN0YW5jZSlcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLmluaXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4TmFtZSkge1xuICByZXR1cm4gbmV3IEluZGV4Q29yZSh0aGlzLCBpbmRleE5hbWUpO1xufTtcblxuLyoqXG4qIEFkZCBhbiBleHRyYSBmaWVsZCB0byB0aGUgSFRUUCByZXF1ZXN0XG4qXG4qIEBwYXJhbSBuYW1lIHRoZSBoZWFkZXIgZmllbGQgbmFtZVxuKiBAcGFyYW0gdmFsdWUgdGhlIGhlYWRlciBmaWVsZCB2YWx1ZVxuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRFeHRyYUhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuZXh0cmFIZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuKiBHZXQgdGhlIHZhbHVlIG9mIGFuIGV4dHJhIEhUVFAgaGVhZGVyXG4qXG4qIEBwYXJhbSBuYW1lIHRoZSBoZWFkZXIgZmllbGQgbmFtZVxuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5nZXRFeHRyYUhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZXh0cmFIZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiogUmVtb3ZlIGFuIGV4dHJhIGZpZWxkIGZyb20gdGhlIEhUVFAgcmVxdWVzdFxuKlxuKiBAcGFyYW0gbmFtZSB0aGUgaGVhZGVyIGZpZWxkIG5hbWVcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUudW5zZXRFeHRyYUhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMuZXh0cmFIZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiogQXVnbWVudCBzZW50IHgtYWxnb2xpYS1hZ2VudCB3aXRoIG1vcmUgZGF0YSwgZWFjaCBhZ2VudCBwYXJ0XG4qIGlzIGF1dG9tYXRpY2FsbHkgc2VwYXJhdGVkIGZyb20gdGhlIG90aGVycyBieSBhIHNlbWljb2xvbjtcbipcbiogQHBhcmFtIGFsZ29saWFBZ2VudCB0aGUgYWdlbnQgdG8gYWRkXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLmFkZEFsZ29saWFBZ2VudCA9IGZ1bmN0aW9uKGFsZ29saWFBZ2VudCkge1xuICBpZiAodGhpcy5fdWEuaW5kZXhPZignOycgKyBhbGdvbGlhQWdlbnQpID09PSAtMSkge1xuICAgIHRoaXMuX3VhICs9ICc7JyArIGFsZ29saWFBZ2VudDtcbiAgfVxufTtcblxuLypcbiAqIFdyYXBwZXIgdGhhdCB0cnkgYWxsIGhvc3RzIHRvIG1heGltaXplIHRoZSBxdWFsaXR5IG9mIHNlcnZpY2VcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9qc29uUmVxdWVzdCA9IGZ1bmN0aW9uKGluaXRpYWxPcHRzKSB7XG4gIHRoaXMuX2NoZWNrQXBwSWREYXRhKCk7XG5cbiAgdmFyIHJlcXVlc3REZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2FsZ29saWFzZWFyY2g6JyArIGluaXRpYWxPcHRzLnVybCk7XG5cbiAgdmFyIGJvZHk7XG4gIHZhciBhZGRpdGlvbmFsVUEgPSBpbml0aWFsT3B0cy5hZGRpdGlvbmFsVUEgfHwgJyc7XG4gIHZhciBjYWNoZSA9IGluaXRpYWxPcHRzLmNhY2hlO1xuICB2YXIgY2xpZW50ID0gdGhpcztcbiAgdmFyIHRyaWVzID0gMDtcbiAgdmFyIHVzaW5nRmFsbGJhY2sgPSBmYWxzZTtcbiAgdmFyIGhhc0ZhbGxiYWNrID0gY2xpZW50Ll91c2VGYWxsYmFjayAmJiBjbGllbnQuX3JlcXVlc3QuZmFsbGJhY2sgJiYgaW5pdGlhbE9wdHMuZmFsbGJhY2s7XG4gIHZhciBoZWFkZXJzO1xuXG4gIGlmIChcbiAgICB0aGlzLmFwaUtleS5sZW5ndGggPiBNQVhfQVBJX0tFWV9MRU5HVEggJiZcbiAgICBpbml0aWFsT3B0cy5ib2R5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAoaW5pdGlhbE9wdHMuYm9keS5wYXJhbXMgIT09IHVuZGVmaW5lZCB8fCAvLyBpbmRleC5zZWFyY2goKVxuICAgIGluaXRpYWxPcHRzLmJvZHkucmVxdWVzdHMgIT09IHVuZGVmaW5lZCkgLy8gY2xpZW50LnNlYXJjaCgpXG4gICkge1xuICAgIGluaXRpYWxPcHRzLmJvZHkuYXBpS2V5ID0gdGhpcy5hcGlLZXk7XG4gICAgaGVhZGVycyA9IHRoaXMuX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyhhZGRpdGlvbmFsVUEsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJzID0gdGhpcy5fY29tcHV0ZVJlcXVlc3RIZWFkZXJzKGFkZGl0aW9uYWxVQSk7XG4gIH1cblxuICBpZiAoaW5pdGlhbE9wdHMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYm9keSA9IHNhZmVKU09OU3RyaW5naWZ5KGluaXRpYWxPcHRzLmJvZHkpO1xuICB9XG5cbiAgcmVxdWVzdERlYnVnKCdyZXF1ZXN0IHN0YXJ0Jyk7XG4gIHZhciBkZWJ1Z0RhdGEgPSBbXTtcblxuICBmdW5jdGlvbiBkb1JlcXVlc3QocmVxdWVzdGVyLCByZXFPcHRzKSB7XG4gICAgY2xpZW50Ll9jaGVja0FwcElkRGF0YSgpO1xuXG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgdmFyIGNhY2hlSUQ7XG5cbiAgICBpZiAoY2xpZW50Ll91c2VDYWNoZSkge1xuICAgICAgY2FjaGVJRCA9IGluaXRpYWxPcHRzLnVybDtcbiAgICB9XG5cbiAgICAvLyBhcyB3ZSBzb21ldGltZSB1c2UgUE9TVCByZXF1ZXN0cyB0byBwYXNzIHBhcmFtZXRlcnMgKGxpa2UgcXVlcnk9J2FhJyksXG4gICAgLy8gdGhlIGNhY2hlSUQgbXVzdCBhbHNvIGluY2x1ZGUgdGhlIGJvZHkgdG8gYmUgZGlmZmVyZW50IGJldHdlZW4gY2FsbHNcbiAgICBpZiAoY2xpZW50Ll91c2VDYWNoZSAmJiBib2R5KSB7XG4gICAgICBjYWNoZUlEICs9ICdfYm9keV8nICsgcmVxT3B0cy5ib2R5O1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBjYWNoZSBleGlzdGVuY2VcbiAgICBpZiAoY2xpZW50Ll91c2VDYWNoZSAmJiBjYWNoZSAmJiBjYWNoZVtjYWNoZUlEXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGVidWcoJ3NlcnZpbmcgcmVzcG9uc2UgZnJvbSBjYWNoZScpO1xuICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UoY2FjaGVbY2FjaGVJRF0pKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSByZWFjaGVkIG1heCB0cmllc1xuICAgIGlmICh0cmllcyA+PSBjbGllbnQuaG9zdHNbaW5pdGlhbE9wdHMuaG9zdFR5cGVdLmxlbmd0aCkge1xuICAgICAgaWYgKCFoYXNGYWxsYmFjayB8fCB1c2luZ0ZhbGxiYWNrKSB7XG4gICAgICAgIHJlcXVlc3REZWJ1ZygnY291bGQgbm90IGdldCBhbnkgcmVzcG9uc2UnKTtcbiAgICAgICAgLy8gdGhlbiBzdG9wXG4gICAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UucmVqZWN0KG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29ubmVjdCB0byB0aGUgQWxnb2xpYVNlYXJjaCBBUEkuJyArXG4gICAgICAgICAgJyBTZW5kIGFuIGVtYWlsIHRvIHN1cHBvcnRAYWxnb2xpYS5jb20gdG8gcmVwb3J0IGFuZCByZXNvbHZlIHRoZSBpc3N1ZS4nICtcbiAgICAgICAgICAnIEFwcGxpY2F0aW9uIGlkIHdhczogJyArIGNsaWVudC5hcHBsaWNhdGlvbklELCB7ZGVidWdEYXRhOiBkZWJ1Z0RhdGF9XG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0RGVidWcoJ3N3aXRjaGluZyB0byBmYWxsYmFjaycpO1xuXG4gICAgICAvLyBsZXQncyB0cnkgdGhlIGZhbGxiYWNrIHN0YXJ0aW5nIGZyb20gaGVyZVxuICAgICAgdHJpZXMgPSAwO1xuXG4gICAgICAvLyBtZXRob2QsIHVybCBhbmQgYm9keSBhcmUgZmFsbGJhY2sgZGVwZW5kZW50XG4gICAgICByZXFPcHRzLm1ldGhvZCA9IGluaXRpYWxPcHRzLmZhbGxiYWNrLm1ldGhvZDtcbiAgICAgIHJlcU9wdHMudXJsID0gaW5pdGlhbE9wdHMuZmFsbGJhY2sudXJsO1xuICAgICAgcmVxT3B0cy5qc29uQm9keSA9IGluaXRpYWxPcHRzLmZhbGxiYWNrLmJvZHk7XG4gICAgICBpZiAocmVxT3B0cy5qc29uQm9keSkge1xuICAgICAgICByZXFPcHRzLmJvZHkgPSBzYWZlSlNPTlN0cmluZ2lmeShyZXFPcHRzLmpzb25Cb2R5KTtcbiAgICAgIH1cbiAgICAgIC8vIHJlLWNvbXB1dGUgaGVhZGVycywgdGhleSBjb3VsZCBiZSBvbWl0dGluZyB0aGUgQVBJIEtFWVxuICAgICAgaGVhZGVycyA9IGNsaWVudC5fY29tcHV0ZVJlcXVlc3RIZWFkZXJzKGFkZGl0aW9uYWxVQSk7XG5cbiAgICAgIHJlcU9wdHMudGltZW91dHMgPSBjbGllbnQuX2dldFRpbWVvdXRzRm9yUmVxdWVzdChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICBjbGllbnQuX3NldEhvc3RJbmRleEJ5VHlwZSgwLCBpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICB1c2luZ0ZhbGxiYWNrID0gdHJ1ZTsgLy8gdGhlIGN1cnJlbnQgcmVxdWVzdCBpcyBub3cgdXNpbmcgZmFsbGJhY2tcbiAgICAgIHJldHVybiBkb1JlcXVlc3QoY2xpZW50Ll9yZXF1ZXN0LmZhbGxiYWNrLCByZXFPcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEhvc3QgPSBjbGllbnQuX2dldEhvc3RCeVR5cGUoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuXG4gICAgdmFyIHVybCA9IGN1cnJlbnRIb3N0ICsgcmVxT3B0cy51cmw7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBib2R5OiByZXFPcHRzLmJvZHksXG4gICAgICBqc29uQm9keTogcmVxT3B0cy5qc29uQm9keSxcbiAgICAgIG1ldGhvZDogcmVxT3B0cy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgdGltZW91dHM6IHJlcU9wdHMudGltZW91dHMsXG4gICAgICBkZWJ1ZzogcmVxdWVzdERlYnVnXG4gICAgfTtcblxuICAgIHJlcXVlc3REZWJ1ZygnbWV0aG9kOiAlcywgdXJsOiAlcywgaGVhZGVyczogJWosIHRpbWVvdXRzOiAlZCcsXG4gICAgICBvcHRpb25zLm1ldGhvZCwgdXJsLCBvcHRpb25zLmhlYWRlcnMsIG9wdGlvbnMudGltZW91dHMpO1xuXG4gICAgaWYgKHJlcXVlc3RlciA9PT0gY2xpZW50Ll9yZXF1ZXN0LmZhbGxiYWNrKSB7XG4gICAgICByZXF1ZXN0RGVidWcoJ3VzaW5nIGZhbGxiYWNrJyk7XG4gICAgfVxuXG4gICAgLy8gYHJlcXVlc3RlcmAgaXMgYW55IG9mIHRoaXMuX3JlcXVlc3Qgb3IgdGhpcy5fcmVxdWVzdC5mYWxsYmFja1xuICAgIC8vIHRodXMgaXQgbmVlZHMgdG8gYmUgY2FsbGVkIHVzaW5nIHRoZSBjbGllbnQgYXMgY29udGV4dFxuICAgIHJldHVybiByZXF1ZXN0ZXIuY2FsbChjbGllbnQsIHVybCwgb3B0aW9ucykudGhlbihzdWNjZXNzLCB0cnlGYWxsYmFjayk7XG5cbiAgICBmdW5jdGlvbiBzdWNjZXNzKGh0dHBSZXNwb25zZSkge1xuICAgICAgLy8gY29tcHV0ZSB0aGUgc3RhdHVzIG9mIHRoZSByZXNwb25zZSxcbiAgICAgIC8vXG4gICAgICAvLyBXaGVuIGluIGJyb3dzZXIgbW9kZSwgdXNpbmcgWERSIG9yIEpTT05QLCB3ZSBoYXZlIG5vIHN0YXR1c0NvZGUgYXZhaWxhYmxlXG4gICAgICAvLyBTbyB3ZSByZWx5IG9uIG91ciBBUEkgcmVzcG9uc2UgYHN0YXR1c2AgcHJvcGVydHkuXG4gICAgICAvLyBCdXQgYHdhaXRUYXNrYCBjYW4gc2V0IGEgYHN0YXR1c2AgcHJvcGVydHkgd2hpY2ggaXMgbm90IHRoZSBzdGF0dXNDb2RlIChpdCdzIHRoZSB0YXNrIHN0YXR1cylcbiAgICAgIC8vIFNvIHdlIGNoZWNrIGlmIHRoZXJlJ3MgYSBgbWVzc2FnZWAgYWxvbmcgYHN0YXR1c2AgYW5kIGl0IG1lYW5zIGl0J3MgYW4gZXJyb3JcbiAgICAgIC8vXG4gICAgICAvLyBUaGF0J3MgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgcmVzcG9uc2Uuc3RhdHVzIHRoYXQncyBub3QgdGhlIGh0dHAgc3RhdHVzQ29kZVxuICAgICAgdmFyIHN0YXR1cyA9IGh0dHBSZXNwb25zZSAmJiBodHRwUmVzcG9uc2UuYm9keSAmJiBodHRwUmVzcG9uc2UuYm9keS5tZXNzYWdlICYmIGh0dHBSZXNwb25zZS5ib2R5LnN0YXR1cyB8fFxuXG4gICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IHRvIGNoZWNrIHRoZSByZXF1ZXN0IHN0YXR1c0NvZGUgQUZURVIgdGhlIGJvZHkgZXZlbnR1YWxcbiAgICAgICAgLy8gc3RhdHVzQ29kZSBiZWNhdXNlIHNvbWUgaW1wbGVtZW50YXRpb25zIChqUXVlcnkgWERvbWFpblJlcXVlc3QgdHJhbnNwb3J0KSBtYXlcbiAgICAgICAgLy8gc2VuZCBzdGF0dXNDb2RlIDIwMCB3aGlsZSB3ZSBoYWQgYW4gZXJyb3JcbiAgICAgICAgaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgfHxcblxuICAgICAgICAvLyBXaGVuIGluIGJyb3dzZXIgbW9kZSwgdXNpbmcgWERSIG9yIEpTT05QXG4gICAgICAgIC8vIHdlIGRlZmF1bHQgdG8gc3VjY2VzcyB3aGVuIG5vIGVycm9yIChubyByZXNwb25zZS5zdGF0dXMgJiYgcmVzcG9uc2UubWVzc2FnZSlcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgSlNPTi5wYXJzZSgpIGVycm9yIHRoZW4gYm9keSBpcyBudWxsIGFuZCBpdCBmYWlsc1xuICAgICAgICBodHRwUmVzcG9uc2UgJiYgaHR0cFJlc3BvbnNlLmJvZHkgJiYgMjAwO1xuXG4gICAgICByZXF1ZXN0RGVidWcoJ3JlY2VpdmVkIHJlc3BvbnNlOiBzdGF0dXNDb2RlOiAlcywgY29tcHV0ZWQgc3RhdHVzQ29kZTogJWQsIGhlYWRlcnM6ICVqJyxcbiAgICAgICAgaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsIHN0YXR1cywgaHR0cFJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgICB2YXIgaHR0cFJlc3BvbnNlT2sgPSBNYXRoLmZsb29yKHN0YXR1cyAvIDEwMCkgPT09IDI7XG5cbiAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGRlYnVnRGF0YS5wdXNoKHtcbiAgICAgICAgY3VycmVudEhvc3Q6IGN1cnJlbnRIb3N0LFxuICAgICAgICBoZWFkZXJzOiByZW1vdmVDcmVkZW50aWFscyhoZWFkZXJzKSxcbiAgICAgICAgY29udGVudDogYm9keSB8fCBudWxsLFxuICAgICAgICBjb250ZW50TGVuZ3RoOiBib2R5ICE9PSB1bmRlZmluZWQgPyBib2R5Lmxlbmd0aCA6IG51bGwsXG4gICAgICAgIG1ldGhvZDogcmVxT3B0cy5tZXRob2QsXG4gICAgICAgIHRpbWVvdXRzOiByZXFPcHRzLnRpbWVvdXRzLFxuICAgICAgICB1cmw6IHJlcU9wdHMudXJsLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogZW5kVGltZSxcbiAgICAgICAgZHVyYXRpb246IGVuZFRpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChodHRwUmVzcG9uc2VPaykge1xuICAgICAgICBpZiAoY2xpZW50Ll91c2VDYWNoZSAmJiBjYWNoZSkge1xuICAgICAgICAgIGNhY2hlW2NhY2hlSURdID0gaHR0cFJlc3BvbnNlLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuYm9keTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZFJldHJ5ID0gTWF0aC5mbG9vcihzdGF0dXMgLyAxMDApICE9PSA0O1xuXG4gICAgICBpZiAoc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgdHJpZXMgKz0gMTtcbiAgICAgICAgcmV0dXJuIHJldHJ5UmVxdWVzdCgpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0RGVidWcoJ3VucmVjb3ZlcmFibGUgZXJyb3InKTtcblxuICAgICAgLy8gbm8gc3VjY2VzcyBhbmQgbm8gcmV0cnkgPT4gZmFpbFxuICAgICAgdmFyIHVucmVjb3ZlcmFibGVFcnJvciA9IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKFxuICAgICAgICBodHRwUmVzcG9uc2UuYm9keSAmJiBodHRwUmVzcG9uc2UuYm9keS5tZXNzYWdlLCB7ZGVidWdEYXRhOiBkZWJ1Z0RhdGEsIHN0YXR1c0NvZGU6IHN0YXR1c31cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UucmVqZWN0KHVucmVjb3ZlcmFibGVFcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJ5RmFsbGJhY2soZXJyKSB7XG4gICAgICAvLyBlcnJvciBjYXNlczpcbiAgICAgIC8vICBXaGlsZSBub3QgaW4gZmFsbGJhY2sgbW9kZTpcbiAgICAgIC8vICAgIC0gQ09SUyBub3Qgc3VwcG9ydGVkXG4gICAgICAvLyAgICAtIG5ldHdvcmsgZXJyb3JcbiAgICAgIC8vICBXaGlsZSBpbiBmYWxsYmFjayBtb2RlOlxuICAgICAgLy8gICAgLSB0aW1lb3V0XG4gICAgICAvLyAgICAtIG5ldHdvcmsgZXJyb3JcbiAgICAgIC8vICAgIC0gYmFkbHkgZm9ybWF0dGVkIEpTT05QIChzY3JpcHQgbG9hZGVkLCBkaWQgbm90IGNhbGwgb3VyIGNhbGxiYWNrKVxuICAgICAgLy8gIEluIGJvdGggY2FzZXM6XG4gICAgICAvLyAgICAtIHVuY2F1Z2h0IGV4Y2VwdGlvbiBvY2N1cnMgKFR5cGVFcnJvcilcbiAgICAgIHJlcXVlc3REZWJ1ZygnZXJyb3I6ICVzLCBzdGFjazogJXMnLCBlcnIubWVzc2FnZSwgZXJyLnN0YWNrKTtcblxuICAgICAgdmFyIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgZGVidWdEYXRhLnB1c2goe1xuICAgICAgICBjdXJyZW50SG9zdDogY3VycmVudEhvc3QsXG4gICAgICAgIGhlYWRlcnM6IHJlbW92ZUNyZWRlbnRpYWxzKGhlYWRlcnMpLFxuICAgICAgICBjb250ZW50OiBib2R5IHx8IG51bGwsXG4gICAgICAgIGNvbnRlbnRMZW5ndGg6IGJvZHkgIT09IHVuZGVmaW5lZCA/IGJvZHkubGVuZ3RoIDogbnVsbCxcbiAgICAgICAgbWV0aG9kOiByZXFPcHRzLm1ldGhvZCxcbiAgICAgICAgdGltZW91dHM6IHJlcU9wdHMudGltZW91dHMsXG4gICAgICAgIHVybDogcmVxT3B0cy51cmwsXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgICBlbmRUaW1lOiBlbmRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IpKSB7XG4gICAgICAgIGVyciA9IG5ldyBlcnJvcnMuVW5rbm93bihlcnIgJiYgZXJyLm1lc3NhZ2UsIGVycik7XG4gICAgICB9XG5cbiAgICAgIHRyaWVzICs9IDE7XG5cbiAgICAgIC8vIHN0b3AgdGhlIHJlcXVlc3QgaW1wbGVtZW50YXRpb24gd2hlbjpcbiAgICAgIGlmIChcbiAgICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSB0aGlzIGVycm9yLFxuICAgICAgICAvLyBpdCBjb21lcyBmcm9tIGEgdGhyb3cgaW4gc29tZSBvdGhlciBwaWVjZSBvZiBjb2RlXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIGVycm9ycy5Vbmtub3duIHx8XG5cbiAgICAgICAgLy8gc2VydmVyIHNlbnQgdW5wYXJzYWJsZSBKU09OXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIGVycm9ycy5VbnBhcnNhYmxlSlNPTiB8fFxuXG4gICAgICAgIC8vIG1heCB0cmllcyBhbmQgYWxyZWFkeSB1c2luZyBmYWxsYmFjayBvciBubyBmYWxsYmFja1xuICAgICAgICB0cmllcyA+PSBjbGllbnQuaG9zdHNbaW5pdGlhbE9wdHMuaG9zdFR5cGVdLmxlbmd0aCAmJlxuICAgICAgICAodXNpbmdGYWxsYmFjayB8fCAhaGFzRmFsbGJhY2spKSB7XG4gICAgICAgIC8vIHN0b3AgcmVxdWVzdCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBjb21tYW5kXG4gICAgICAgIGVyci5kZWJ1Z0RhdGEgPSBkZWJ1Z0RhdGE7XG4gICAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gYSB0aW1lb3V0IG9jY3VyZWQsIHJldHJ5IGJ5IHJhaXNpbmcgdGltZW91dFxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGVycm9ycy5SZXF1ZXN0VGltZW91dCkge1xuICAgICAgICByZXR1cm4gcmV0cnlSZXF1ZXN0V2l0aEhpZ2hlclRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHJ5UmVxdWVzdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldHJ5UmVxdWVzdCgpIHtcbiAgICAgIHJlcXVlc3REZWJ1ZygncmV0cnlpbmcgcmVxdWVzdCcpO1xuICAgICAgY2xpZW50Ll9pbmNyZW1lbnRIb3N0SW5kZXgoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgcmV0dXJuIGRvUmVxdWVzdChyZXF1ZXN0ZXIsIHJlcU9wdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldHJ5UmVxdWVzdFdpdGhIaWdoZXJUaW1lb3V0KCkge1xuICAgICAgcmVxdWVzdERlYnVnKCdyZXRyeWluZyByZXF1ZXN0IHdpdGggaGlnaGVyIHRpbWVvdXQnKTtcbiAgICAgIGNsaWVudC5faW5jcmVtZW50SG9zdEluZGV4KGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcbiAgICAgIGNsaWVudC5faW5jcmVtZW50VGltZW91dE11bHRpcGxlcigpO1xuICAgICAgcmVxT3B0cy50aW1lb3V0cyA9IGNsaWVudC5fZ2V0VGltZW91dHNGb3JSZXF1ZXN0KGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcbiAgICAgIHJldHVybiBkb1JlcXVlc3QocmVxdWVzdGVyLCByZXFPcHRzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IGRvUmVxdWVzdChcbiAgICBjbGllbnQuX3JlcXVlc3QsIHtcbiAgICAgIHVybDogaW5pdGlhbE9wdHMudXJsLFxuICAgICAgbWV0aG9kOiBpbml0aWFsT3B0cy5tZXRob2QsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAganNvbkJvZHk6IGluaXRpYWxPcHRzLmJvZHksXG4gICAgICB0aW1lb3V0czogY2xpZW50Ll9nZXRUaW1lb3V0c0ZvclJlcXVlc3QoaW5pdGlhbE9wdHMuaG9zdFR5cGUpXG4gICAgfVxuICApO1xuXG4gIC8vIGVpdGhlciB3ZSBoYXZlIGEgY2FsbGJhY2tcbiAgLy8gZWl0aGVyIHdlIGFyZSB1c2luZyBwcm9taXNlc1xuICBpZiAodHlwZW9mIGluaXRpYWxPcHRzLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9rQ2IoY29udGVudCkge1xuICAgICAgZXhpdFByb21pc2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIGluaXRpYWxPcHRzLmNhbGxiYWNrKG51bGwsIGNvbnRlbnQpO1xuICAgICAgfSwgY2xpZW50Ll9zZXRUaW1lb3V0IHx8IHNldFRpbWVvdXQpO1xuICAgIH0sIGZ1bmN0aW9uIG5vb2tDYihlcnIpIHtcbiAgICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBpbml0aWFsT3B0cy5jYWxsYmFjayhlcnIpO1xuICAgICAgfSwgY2xpZW50Ll9zZXRUaW1lb3V0IHx8IHNldFRpbWVvdXQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59O1xuXG4vKlxuKiBUcmFuc2Zvcm0gc2VhcmNoIHBhcmFtIG9iamVjdCBpbiBxdWVyeSBzdHJpbmdcbiogQHBhcmFtIHtvYmplY3R9IGFyZ3MgYXJndW1lbnRzIHRvIGFkZCB0byB0aGUgY3VycmVudCBxdWVyeSBzdHJpbmdcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcyBjdXJyZW50IHF1ZXJ5IHN0cmluZ1xuKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBmaW5hbCBxdWVyeSBzdHJpbmdcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uKGFyZ3MsIHBhcmFtcykge1xuICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBhcmdzKSB7XG4gICAgaWYgKGtleSAhPT0gbnVsbCAmJiBhcmdzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBhcmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHBhcmFtcyArPSBwYXJhbXMgPT09ICcnID8gJycgOiAnJic7XG4gICAgICBwYXJhbXMgKz0ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmdzW2tleV0pID09PSAnW29iamVjdCBBcnJheV0nID8gc2FmZUpTT05TdHJpbmdpZnkoYXJnc1trZXldKSA6IGFyZ3Nba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyA9IGZ1bmN0aW9uKGFkZGl0aW9uYWxVQSwgd2l0aEFQSUtleSkge1xuICB2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxuICB2YXIgdWEgPSBhZGRpdGlvbmFsVUEgP1xuICAgIHRoaXMuX3VhICsgJzsnICsgYWRkaXRpb25hbFVBIDpcbiAgICB0aGlzLl91YTtcblxuICB2YXIgcmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgJ3gtYWxnb2xpYS1hZ2VudCc6IHVhLFxuICAgICd4LWFsZ29saWEtYXBwbGljYXRpb24taWQnOiB0aGlzLmFwcGxpY2F0aW9uSURcbiAgfTtcblxuICAvLyBicm93c2VyIHdpbGwgaW5saW5lIGhlYWRlcnMgaW4gdGhlIHVybCwgbm9kZS5qcyB3aWxsIHVzZSBodHRwIGhlYWRlcnNcbiAgLy8gYnV0IGluIHNvbWUgc2l0dWF0aW9ucywgdGhlIEFQSSBLRVkgd2lsbCBiZSB0b28gbG9uZyAoYmlnIHNlY3VyZWQgQVBJIGtleXMpXG4gIC8vIHNvIGlmIHRoZSByZXF1ZXN0IGlzIGEgUE9TVCBhbmQgdGhlIEtFWSBpcyB2ZXJ5IGxvbmcsIHdlIHdpbGwgYmUgYXNrZWQgdG8gbm90IHB1dFxuICAvLyBpdCBpbnRvIGhlYWRlcnMgYnV0IGluIHRoZSBKU09OIGJvZHlcbiAgaWYgKHdpdGhBUElLZXkgIT09IGZhbHNlKSB7XG4gICAgcmVxdWVzdEhlYWRlcnNbJ3gtYWxnb2xpYS1hcGkta2V5J10gPSB0aGlzLmFwaUtleTtcbiAgfVxuXG4gIGlmICh0aGlzLnVzZXJUb2tlbikge1xuICAgIHJlcXVlc3RIZWFkZXJzWyd4LWFsZ29saWEtdXNlcnRva2VuJ10gPSB0aGlzLnVzZXJUb2tlbjtcbiAgfVxuXG4gIGlmICh0aGlzLnNlY3VyaXR5VGFncykge1xuICAgIHJlcXVlc3RIZWFkZXJzWyd4LWFsZ29saWEtdGFnZmlsdGVycyddID0gdGhpcy5zZWN1cml0eVRhZ3M7XG4gIH1cblxuICBmb3JFYWNoKHRoaXMuZXh0cmFIZWFkZXJzLCBmdW5jdGlvbiBhZGRUb1JlcXVlc3RIZWFkZXJzKHZhbHVlLCBrZXkpIHtcbiAgICByZXF1ZXN0SGVhZGVyc1trZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiByZXF1ZXN0SGVhZGVycztcbn07XG5cbi8qKlxuICogU2VhcmNoIHRocm91Z2ggbXVsdGlwbGUgaW5kaWNlcyBhdCB0aGUgc2FtZSB0aW1lXG4gKiBAcGFyYW0gIHtPYmplY3RbXX0gICBxdWVyaWVzICBBbiBhcnJheSBvZiBxdWVyaWVzIHlvdSB3YW50IHRvIHJ1bi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyaWVzW10uaW5kZXhOYW1lIFRoZSBpbmRleCBuYW1lIHlvdSB3YW50IHRvIHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyaWVzW10ucXVlcnldIFRoZSBxdWVyeSB0byBpc3N1ZSBvbiB0aGlzIGluZGV4LiBDYW4gYWxzbyBiZSBwYXNzZWQgaW50byBgcGFyYW1zYFxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJpZXNbXS5wYXJhbXMgQW55IHNlYXJjaCBwYXJhbSBsaWtlIGhpdHNQZXJQYWdlLCAuLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZFxuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihxdWVyaWVzLCBvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwLmpzJyk7XG5cbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBjbGllbnQuc2VhcmNoKGFycmF5T2ZRdWVyaWVzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KHF1ZXJpZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGNsaWVudCA9IHRoaXM7XG5cbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IG1hcChxdWVyaWVzLCBmdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChxdWVyeSkge1xuICAgICAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gICAgICAvLyBhbGxvdyBxdWVyeS5xdWVyeVxuICAgICAgLy8gc28gd2UgYXJlIG1pbWljaW5nIHRoZSBpbmRleC5zZWFyY2gocXVlcnksIHBhcmFtcykgbWV0aG9kXG4gICAgICAvLyB7aW5kZXhOYW1lOiwgcXVlcnk6LCBwYXJhbXM6fVxuICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zICs9ICdxdWVyeT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5LnF1ZXJ5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXhOYW1lOiBxdWVyeS5pbmRleE5hbWUsXG4gICAgICAgIHBhcmFtczogY2xpZW50Ll9nZXRTZWFyY2hQYXJhbXMocXVlcnkucGFyYW1zLCBwYXJhbXMpXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG5cbiAgdmFyIEpTT05QUGFyYW1zID0gbWFwKHBvc3RPYmoucmVxdWVzdHMsIGZ1bmN0aW9uIHByZXBhcmVKU09OUFBhcmFtcyhyZXF1ZXN0LCByZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gcmVxdWVzdElkICsgJz0nICtcbiAgICAgIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0LmluZGV4TmFtZSkgKyAnPycgK1xuICAgICAgICByZXF1ZXN0LnBhcmFtc1xuICAgICAgKTtcbiAgfSkuam9pbignJicpO1xuXG4gIHZhciB1cmwgPSAnLzEvaW5kZXhlcy8qL3F1ZXJpZXMnO1xuXG4gIGlmIChvcHRzLnN0cmF0ZWd5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwgKz0gJz9zdHJhdGVneT0nICsgb3B0cy5zdHJhdGVneTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgY2FjaGU6IHRoaXMuY2FjaGUsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiB1cmwsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGZhbGxiYWNrOiB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiAnLzEvaW5kZXhlcy8qJyxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgcGFyYW1zOiBKU09OUFBhcmFtc1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGV4dHJhIHNlY3VyaXR5IHRhZ0ZpbHRlcnMgaGVhZGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdGFncyBUaGUgbGlzdCBvZiB0YWdzIGRlZmluaW5nIHRoZSBjdXJyZW50IHNlY3VyaXR5IGZpbHRlcnNcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldFNlY3VyaXR5VGFncyA9IGZ1bmN0aW9uKHRhZ3MpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YWdzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHZhciBzdHJUYWdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhZ3NbaV0pID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHZhciBvcmVkVGFncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRhZ3NbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBvcmVkVGFncy5wdXNoKHRhZ3NbaV1bal0pO1xuICAgICAgICB9XG4gICAgICAgIHN0clRhZ3MucHVzaCgnKCcgKyBvcmVkVGFncy5qb2luKCcsJykgKyAnKScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyVGFncy5wdXNoKHRhZ3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0YWdzID0gc3RyVGFncy5qb2luKCcsJyk7XG4gIH1cblxuICB0aGlzLnNlY3VyaXR5VGFncyA9IHRhZ3M7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZXh0cmEgdXNlciB0b2tlbiBoZWFkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyVG9rZW4gVGhlIHRva2VuIGlkZW50aWZ5aW5nIGEgdW5pcSB1c2VyICh1c2VkIHRvIGFwcGx5IHJhdGUgbGltaXRzKVxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0VXNlclRva2VuID0gZnVuY3Rpb24odXNlclRva2VuKSB7XG4gIHRoaXMudXNlclRva2VuID0gdXNlclRva2VuO1xufTtcblxuLyoqXG4gKiBDbGVhciBhbGwgcXVlcmllcyBpbiBjbGllbnQncyBjYWNoZVxuICogQHJldHVybiB1bmRlZmluZWRcbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYWNoZSA9IHt9O1xufTtcblxuLyoqXG4qIFNldCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhIHJlcXVlc3QgY2FuIHRha2UgYmVmb3JlIGF1dG9tYXRpY2FsbHkgYmVpbmcgdGVybWluYXRlZC5cbiogQGRlcHJlY2F0ZWRcbiogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRSZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uKG1pbGxpc2Vjb25kcykge1xuICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgdGhpcy5fdGltZW91dHMuY29ubmVjdCA9IHRoaXMuX3RpbWVvdXRzLnJlYWQgPSB0aGlzLl90aW1lb3V0cy53cml0ZSA9IG1pbGxpc2Vjb25kcztcbiAgfVxufTtcblxuLyoqXG4qIFNldCB0aGUgdGhyZWUgZGlmZmVyZW50IChjb25uZWN0LCByZWFkLCB3cml0ZSkgdGltZW91dHMgdG8gYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmdcbiogQHBhcmFtIHtPYmplY3R9IHRpbWVvdXRzXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldFRpbWVvdXRzID0gZnVuY3Rpb24odGltZW91dHMpIHtcbiAgdGhpcy5fdGltZW91dHMgPSB0aW1lb3V0cztcbn07XG5cbi8qKlxuKiBHZXQgdGhlIHRocmVlIGRpZmZlcmVudCAoY29ubmVjdCwgcmVhZCwgd3JpdGUpIHRpbWVvdXRzIHRvIGJlIHVzZWQgd2hlbiByZXF1ZXN0aW5nXG4qIEBwYXJhbSB7T2JqZWN0fSB0aW1lb3V0c1xuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5nZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGltZW91dHM7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldEFwcElkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IHN0b3JlLmdldCh0aGlzLmFwcGxpY2F0aW9uSUQpO1xuICBpZiAoZGF0YSAhPT0gbnVsbCkgdGhpcy5fY2FjaGVBcHBJZERhdGEoZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9zZXRBcHBJZERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRhdGEubGFzdENoYW5nZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHRoaXMuX2NhY2hlQXBwSWREYXRhKGRhdGEpO1xuICByZXR1cm4gc3RvcmUuc2V0KHRoaXMuYXBwbGljYXRpb25JRCwgZGF0YSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2NoZWNrQXBwSWREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZ2V0QXBwSWREYXRhKCk7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBub3cgLSBkYXRhLmxhc3RDaGFuZ2UgPiBSRVNFVF9BUFBfREFUQV9USU1FUikge1xuICAgIHJldHVybiB0aGlzLl9yZXNldEluaXRpYWxBcHBJZERhdGEoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fcmVzZXRJbml0aWFsQXBwSWREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbmV3RGF0YSA9IGRhdGEgfHwge307XG4gIG5ld0RhdGEuaG9zdEluZGV4ZXMgPSB7cmVhZDogMCwgd3JpdGU6IDB9O1xuICBuZXdEYXRhLnRpbWVvdXRNdWx0aXBsaWVyID0gMTtcbiAgbmV3RGF0YS5zaHVmZmxlUmVzdWx0ID0gbmV3RGF0YS5zaHVmZmxlUmVzdWx0IHx8IHNodWZmbGUoWzEsIDIsIDNdKTtcbiAgcmV0dXJuIHRoaXMuX3NldEFwcElkRGF0YShuZXdEYXRhKTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fY2FjaGVBcHBJZERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX2hvc3RJbmRleGVzID0gZGF0YS5ob3N0SW5kZXhlcztcbiAgdGhpcy5fdGltZW91dE11bHRpcGxpZXIgPSBkYXRhLnRpbWVvdXRNdWx0aXBsaWVyO1xuICB0aGlzLl9zaHVmZmxlUmVzdWx0ID0gZGF0YS5zaHVmZmxlUmVzdWx0O1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlID0gZnVuY3Rpb24obmV3RGF0YSkge1xuICB2YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbiAgdmFyIGN1cnJlbnREYXRhID0gdGhpcy5fZ2V0QXBwSWREYXRhKCk7XG4gIGZvcmVhY2gobmV3RGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGN1cnJlbnREYXRhW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMuX3NldEFwcElkRGF0YShjdXJyZW50RGF0YSk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldEhvc3RCeVR5cGUgPSBmdW5jdGlvbihob3N0VHlwZSkge1xuICByZXR1cm4gdGhpcy5ob3N0c1tob3N0VHlwZV1bdGhpcy5fZ2V0SG9zdEluZGV4QnlUeXBlKGhvc3RUeXBlKV07XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2dldFRpbWVvdXRNdWx0aXBsaWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aW1lb3V0TXVsdGlwbGllcjtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0SG9zdEluZGV4QnlUeXBlID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuX2hvc3RJbmRleGVzW2hvc3RUeXBlXTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fc2V0SG9zdEluZGV4QnlUeXBlID0gZnVuY3Rpb24oaG9zdEluZGV4LCBob3N0VHlwZSkge1xuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJyk7XG4gIHZhciBuZXdIb3N0SW5kZXhlcyA9IGNsb25lKHRoaXMuX2hvc3RJbmRleGVzKTtcbiAgbmV3SG9zdEluZGV4ZXNbaG9zdFR5cGVdID0gaG9zdEluZGV4O1xuICB0aGlzLl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlKHtob3N0SW5kZXhlczogbmV3SG9zdEluZGV4ZXN9KTtcbiAgcmV0dXJuIGhvc3RJbmRleDtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5faW5jcmVtZW50SG9zdEluZGV4ID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuX3NldEhvc3RJbmRleEJ5VHlwZShcbiAgICAodGhpcy5fZ2V0SG9zdEluZGV4QnlUeXBlKGhvc3RUeXBlKSArIDEpICUgdGhpcy5ob3N0c1tob3N0VHlwZV0ubGVuZ3RoLCBob3N0VHlwZVxuICApO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9pbmNyZW1lbnRUaW1lb3V0TXVsdGlwbGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aW1lb3V0TXVsdGlwbGllciA9IE1hdGgubWF4KHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyICsgMSwgNCk7XG4gIHJldHVybiB0aGlzLl9wYXJ0aWFsQXBwSWREYXRhVXBkYXRlKHt0aW1lb3V0TXVsdGlwbGllcjogdGltZW91dE11bHRpcGxpZXJ9KTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0VGltZW91dHNGb3JSZXF1ZXN0ID0gZnVuY3Rpb24oaG9zdFR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0OiB0aGlzLl90aW1lb3V0cy5jb25uZWN0ICogdGhpcy5fdGltZW91dE11bHRpcGxpZXIsXG4gICAgY29tcGxldGU6IHRoaXMuX3RpbWVvdXRzW2hvc3RUeXBlXSAqIHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyXG4gIH07XG59O1xuXG5mdW5jdGlvbiBwcmVwYXJlSG9zdChwcm90b2NvbCkge1xuICByZXR1cm4gZnVuY3Rpb24gcHJlcGFyZShob3N0KSB7XG4gICAgcmV0dXJuIHByb3RvY29sICsgJy8vJyArIGhvc3QudG9Mb3dlckNhc2UoKTtcbiAgfTtcbn1cblxuLy8gUHJvdG90eXBlLmpzIDwgMS43LCBhIHdpZGVseSB1c2VkIGxpYnJhcnksIGRlZmluZXMgYSB3ZWlyZFxuLy8gQXJyYXkucHJvdG90eXBlLnRvSlNPTiBmdW5jdGlvbiB0aGF0IHdpbGwgZmFpbCB0byBzdHJpbmdpZnkgb3VyIGNvbnRlbnRcbi8vIGFwcHJvcHJpYXRlbHlcbi8vIHJlZnM6XG4vLyAgIC0gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIXRvcGljL3Byb3RvdHlwZS1jb3JlL0UtU0FWdlZfVjlRXG4vLyAgIC0gaHR0cHM6Ly9naXRodWIuY29tL3NzdGVwaGVuc29uL3Byb3RvdHlwZS9jb21taXQvMDM4YTI5ODVhNzA1OTNjMWE4NmMyMzBmYWRiZGZlMmU0ODk4YTQ4Y1xuLy8gICAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDg0NDEvMTQ3MDc5XG5mdW5jdGlvbiBzYWZlSlNPTlN0cmluZ2lmeShvYmopIHtcbiAgLyogZXNsaW50IG5vLWV4dGVuZC1uYXRpdmU6MCAqL1xuXG4gIGlmIChBcnJheS5wcm90b3R5cGUudG9KU09OID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgfVxuXG4gIHZhciB0b0pTT04gPSBBcnJheS5wcm90b3R5cGUudG9KU09OO1xuICBkZWxldGUgQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbiAgdmFyIG91dCA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIEFycmF5LnByb3RvdHlwZS50b0pTT04gPSB0b0pTT047XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICB2YXIgY3VycmVudEluZGV4ID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgdGVtcG9yYXJ5VmFsdWU7XG4gIHZhciByYW5kb21JbmRleDtcblxuICAvLyBXaGlsZSB0aGVyZSByZW1haW4gZWxlbWVudHMgdG8gc2h1ZmZsZS4uLlxuICB3aGlsZSAoY3VycmVudEluZGV4ICE9PSAwKSB7XG4gICAgLy8gUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li4uXG4gICAgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xuICAgIGN1cnJlbnRJbmRleCAtPSAxO1xuXG4gICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgIHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcbiAgICBhcnJheVtjdXJyZW50SW5kZXhdID0gYXJyYXlbcmFuZG9tSW5kZXhdO1xuICAgIGFycmF5W3JhbmRvbUluZGV4XSA9IHRlbXBvcmFyeVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDcmVkZW50aWFscyhoZWFkZXJzKSB7XG4gIHZhciBuZXdIZWFkZXJzID0ge307XG5cbiAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCBoZWFkZXJOYW1lKSkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZiAoaGVhZGVyTmFtZSA9PT0gJ3gtYWxnb2xpYS1hcGkta2V5JyB8fCBoZWFkZXJOYW1lID09PSAneC1hbGdvbGlhLWFwcGxpY2F0aW9uLWlkJykge1xuICAgICAgICB2YWx1ZSA9ICcqKmhpZGRlbiBmb3Igc2VjdXJpdHkgcHVycG9zZXMqKic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICB9XG5cbiAgICAgIG5ld0hlYWRlcnNbaGVhZGVyTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3SGVhZGVycztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaENvcmUuanMiLCJ2YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdhbGdvbGlhc2VhcmNoOnNyYy9ob3N0SW5kZXhTdGF0ZS5qcycpO1xudmFyIGxvY2FsU3RvcmFnZU5hbWVzcGFjZSA9ICdhbGdvbGlhc2VhcmNoLWNsaWVudC1qcyc7XG5cbnZhciBzdG9yZTtcbnZhciBtb2R1bGVTdG9yZSA9IHtcbiAgc3RhdGU6IHt9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgZGF0YSkge1xuICAgIHRoaXMuc3RhdGVba2V5XSA9IGRhdGE7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVba2V5XTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVtrZXldIHx8IG51bGw7XG4gIH1cbn07XG5cbnZhciBsb2NhbFN0b3JhZ2VTdG9yZSA9IHtcbiAgc2V0OiBmdW5jdGlvbihrZXksIGRhdGEpIHtcbiAgICBtb2R1bGVTdG9yZS5zZXQoa2V5LCBkYXRhKTsgLy8gYWx3YXlzIHJlcGxpY2F0ZSBsb2NhbFN0b3JhZ2VTdG9yZSB0byBtb2R1bGVTdG9yZSBpbiBjYXNlIG9mIGZhaWx1cmVcblxuICAgIHRyeSB7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gSlNPTi5wYXJzZShnbG9iYWwubG9jYWxTdG9yYWdlW2xvY2FsU3RvcmFnZU5hbWVzcGFjZV0pO1xuICAgICAgbmFtZXNwYWNlW2tleV0gPSBkYXRhO1xuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdID0gSlNPTi5zdHJpbmdpZnkobmFtZXNwYWNlKTtcbiAgICAgIHJldHVybiBuYW1lc3BhY2Vba2V5XTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlRmFpbHVyZShrZXksIGUpO1xuICAgIH1cbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZ2xvYmFsLmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VOYW1lc3BhY2VdKVtrZXldIHx8IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZUZhaWx1cmUoa2V5LCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxvY2FsU3RvcmFnZUZhaWx1cmUoa2V5LCBlKSB7XG4gIGRlYnVnKCdsb2NhbFN0b3JhZ2UgZmFpbGVkIHdpdGgnLCBlKTtcbiAgY2xlYW51cCgpO1xuICBzdG9yZSA9IG1vZHVsZVN0b3JlO1xuICByZXR1cm4gc3RvcmUuZ2V0KGtleSk7XG59XG5cbnN0b3JlID0gc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSA/IGxvY2FsU3RvcmFnZVN0b3JlIDogbW9kdWxlU3RvcmU7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXQ6IGdldE9yU2V0LFxuICBzZXQ6IGdldE9yU2V0LFxuICBzdXBwb3J0c0xvY2FsU3RvcmFnZTogc3VwcG9ydHNMb2NhbFN0b3JhZ2Vcbn07XG5cbmZ1bmN0aW9uIGdldE9yU2V0KGtleSwgZGF0YSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzdG9yZS5nZXQoa2V5KTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZS5zZXQoa2V5LCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgaWYgKCdsb2NhbFN0b3JhZ2UnIGluIGdsb2JhbCAmJlxuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlW2xvY2FsU3RvcmFnZU5hbWVzcGFjZV0pIHtcbiAgICAgICAgLy8gYWN0dWFsIGNyZWF0aW9uIG9mIHRoZSBuYW1lc3BhY2VcbiAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZU5hbWVzcGFjZSwgSlNPTi5zdHJpbmdpZnkoe30pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBJbiBjYXNlIG9mIGFueSBlcnJvciBvbiBsb2NhbFN0b3JhZ2UsIHdlIGNsZWFuIG91ciBvd24gbmFtZXNwYWNlLCB0aGlzIHNob3VsZCBoYW5kbGVcbi8vIHF1b3RhIGVycm9ycyB3aGVuIGEgbG90IG9mIGtleXMgKyBkYXRhIGFyZSB1c2VkXG5mdW5jdGlvbiBjbGVhbnVwKCkge1xuICB0cnkge1xuICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShsb2NhbFN0b3JhZ2VOYW1lc3BhY2UpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gbm90aGluZyB0byBkb1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL3N0b3JlLmpzIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbXMvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCdnbG9iYWwnKTtcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2UgfHwgcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuXG4vLyBUaGlzIGlzIHRoZSBzdGFuZGFsb25lIGJyb3dzZXIgYnVpbGQgZW50cnkgcG9pbnRcbi8vIEJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFsZ29saWEgU2VhcmNoIEphdmFTY3JpcHQgY2xpZW50LFxuLy8gdXNpbmcgWE1MSHR0cFJlcXVlc3QsIFhEb21haW5SZXF1ZXN0IGFuZCBKU09OUCBhcyBmYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVBbGdvbGlhc2VhcmNoKEFsZ29saWFTZWFyY2gsIHVhU3VmZml4KSB7XG4gIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4gIHZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbiAgdmFyIGlubGluZUhlYWRlcnMgPSByZXF1aXJlKCcuL2lubGluZS1oZWFkZXJzJyk7XG4gIHZhciBqc29ucFJlcXVlc3QgPSByZXF1aXJlKCcuL2pzb25wLXJlcXVlc3QnKTtcbiAgdmFyIHBsYWNlcyA9IHJlcXVpcmUoJy4uL3BsYWNlcy5qcycpO1xuICB1YVN1ZmZpeCA9IHVhU3VmZml4IHx8ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RlYnVnJykge1xuICAgIHJlcXVpcmUoJ2RlYnVnJykuZW5hYmxlKCdhbGdvbGlhc2VhcmNoKicpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxnb2xpYXNlYXJjaChhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpIHtcbiAgICB2YXIgY2xvbmVEZWVwID0gcmVxdWlyZSgnLi4vY2xvbmUuanMnKTtcblxuICAgIHZhciBnZXREb2N1bWVudFByb3RvY29sID0gcmVxdWlyZSgnLi9nZXQtZG9jdW1lbnQtcHJvdG9jb2wnKTtcblxuICAgIG9wdHMgPSBjbG9uZURlZXAob3B0cyB8fCB7fSk7XG5cbiAgICBpZiAob3B0cy5wcm90b2NvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRzLnByb3RvY29sID0gZ2V0RG9jdW1lbnRQcm90b2NvbCgpO1xuICAgIH1cblxuICAgIG9wdHMuX3VhID0gb3B0cy5fdWEgfHwgYWxnb2xpYXNlYXJjaC51YTtcblxuICAgIHJldHVybiBuZXcgQWxnb2xpYVNlYXJjaEJyb3dzZXIoYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKTtcbiAgfVxuXG4gIGFsZ29saWFzZWFyY2gudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24uanMnKTtcbiAgYWxnb2xpYXNlYXJjaC51YSA9ICdBbGdvbGlhIGZvciB2YW5pbGxhIEphdmFTY3JpcHQgJyArIHVhU3VmZml4ICsgYWxnb2xpYXNlYXJjaC52ZXJzaW9uO1xuICBhbGdvbGlhc2VhcmNoLmluaXRQbGFjZXMgPSBwbGFjZXMoYWxnb2xpYXNlYXJjaCk7XG5cbiAgLy8gd2UgZXhwb3NlIGludG8gd2luZG93IG5vIG1hdHRlciBob3cgd2UgYXJlIHVzZWQsIHRoaXMgd2lsbCBhbGxvd1xuICAvLyB1cyB0byBlYXNpbHkgZGVidWcgYW55IHdlYnNpdGUgcnVubmluZyBhbGdvbGlhXG4gIGdsb2JhbC5fX2FsZ29saWEgPSB7XG4gICAgZGVidWc6IHJlcXVpcmUoJ2RlYnVnJyksXG4gICAgYWxnb2xpYXNlYXJjaDogYWxnb2xpYXNlYXJjaFxuICB9O1xuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIGhhc1hNTEh0dHBSZXF1ZXN0OiAnWE1MSHR0cFJlcXVlc3QnIGluIGdsb2JhbCxcbiAgICBoYXNYRG9tYWluUmVxdWVzdDogJ1hEb21haW5SZXF1ZXN0JyBpbiBnbG9iYWxcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5oYXNYTUxIdHRwUmVxdWVzdCkge1xuICAgIHN1cHBvcnQuY29ycyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gQWxnb2xpYVNlYXJjaEJyb3dzZXIoKSB7XG4gICAgLy8gY2FsbCBBbGdvbGlhU2VhcmNoIGNvbnN0cnVjdG9yXG4gICAgQWxnb2xpYVNlYXJjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdHMoQWxnb2xpYVNlYXJjaEJyb3dzZXIsIEFsZ29saWFTZWFyY2gpO1xuXG4gIEFsZ29saWFTZWFyY2hCcm93c2VyLnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIHdyYXBSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gbm8gY29ycyBvciBYRG9tYWluUmVxdWVzdCwgbm8gcmVxdWVzdFxuICAgICAgaWYgKCFzdXBwb3J0LmNvcnMgJiYgIXN1cHBvcnQuaGFzWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgLy8gdmVyeSBvbGQgYnJvd3Nlciwgbm90IHN1cHBvcnRlZFxuICAgICAgICByZWplY3QobmV3IGVycm9ycy5OZXR3b3JrKCdDT1JTIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXJsID0gaW5saW5lSGVhZGVycyh1cmwsIG9wdHMuaGVhZGVycyk7XG5cbiAgICAgIHZhciBib2R5ID0gb3B0cy5ib2R5O1xuICAgICAgdmFyIHJlcSA9IHN1cHBvcnQuY29ycyA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICB2YXIgcmVxVGltZW91dDtcbiAgICAgIHZhciB0aW1lZE91dDtcbiAgICAgIHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgcmVxVGltZW91dCA9IHNldFRpbWVvdXQob25UaW1lb3V0LCBvcHRzLnRpbWVvdXRzLmNvbm5lY3QpO1xuICAgICAgLy8gd2Ugc2V0IGFuIGVtcHR5IG9ucHJvZ3Jlc3MgbGlzdGVuZXJcbiAgICAgIC8vIHNvIHRoYXQgWERvbWFpblJlcXVlc3Qgb24gSUU5IGlzIG5vdCBhYm9ydGVkXG4gICAgICAvLyByZWZzOlxuICAgICAgLy8gIC0gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYWxnb2xpYXNlYXJjaC1jbGllbnQtanMvaXNzdWVzLzc2XG4gICAgICAvLyAgLSBodHRwczovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2llL2VuLVVTLzMwZWYzYWRkLTc2N2MtNDQzNi1iOGE5LWYxY2ExOWI0ODEyZS9pZTktcnRtLXhkb21haW5yZXF1ZXN0LWlzc3VlZC1yZXF1ZXN0cy1tYXktYWJvcnQtaWYtYWxsLWV2ZW50LWhhbmRsZXJzLW5vdC1zcGVjaWZpZWQ/Zm9ydW09aWV3ZWJkZXZlbG9wbWVudFxuICAgICAgcmVxLm9ucHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuICAgICAgaWYgKCdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIHJlcSkgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG9uUmVhZHlTdGF0ZUNoYW5nZTtcbiAgICAgIHJlcS5vbmxvYWQgPSBvbkxvYWQ7XG4gICAgICByZXEub25lcnJvciA9IG9uRXJyb3I7XG5cbiAgICAgIC8vIGRvIG5vdCByZWx5IG9uIGRlZmF1bHQgWEhSIGFzeW5jIGZsYWcsIGFzIHNvbWUgYW5hbHl0aWNzIGNvZGUgbGlrZSBob3RqYXJcbiAgICAgIC8vIGJyZWFrcyBpdCBhbmQgc2V0IGl0IHRvIGZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgIGlmIChyZXEgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXEub3BlbihvcHRzLm1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcS5vcGVuKG9wdHMubWV0aG9kLCB1cmwpO1xuICAgICAgfVxuXG4gICAgICAvLyBoZWFkZXJzIGFyZSBtZWFudCB0byBiZSBzZW50IGFmdGVyIG9wZW5cbiAgICAgIGlmIChzdXBwb3J0LmNvcnMpIHtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICBpZiAob3B0cy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9BY2Nlc3NfY29udHJvbF9DT1JTI1NpbXBsZV9yZXF1ZXN0c1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgfVxuXG4gICAgICByZXEuc2VuZChib2R5KTtcblxuICAgICAgLy8gZXZlbnQgb2JqZWN0IG5vdCByZWNlaXZlZCBpbiBJRTgsIGF0IGxlYXN0XG4gICAgICAvLyBidXQgd2UgZG8gbm90IHVzZSBpdCwgc3RpbGwgaW1wb3J0YW50IHRvIG5vdGVcbiAgICAgIGZ1bmN0aW9uIG9uTG9hZCgvKiBldmVudCAqLykge1xuICAgICAgICAvLyBXaGVuIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydHMgcmVxLnRpbWVvdXQsIHdlIGNhblxuICAgICAgICAvLyBoYXZlIGJvdGggYSBsb2FkIGFuZCB0aW1lb3V0IGV2ZW50LCBzaW5jZSBoYW5kbGVkIGJ5IGEgZHVtYiBzZXRUaW1lb3V0XG4gICAgICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcblxuICAgICAgICB2YXIgb3V0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ID0ge1xuICAgICAgICAgICAgYm9keTogSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KSxcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogcmVxLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlcS5zdGF0dXMsXG4gICAgICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBkb2VzIG5vdCBoYXZlIGFueSByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICBoZWFkZXJzOiByZXEuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzICYmIHJlcS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCB7fVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBvdXQgPSBuZXcgZXJyb3JzLlVucGFyc2FibGVKU09OKHtcbiAgICAgICAgICAgIG1vcmU6IHJlcS5yZXNwb25zZVRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXQgaW5zdGFuY2VvZiBlcnJvcnMuVW5wYXJzYWJsZUpTT04pIHtcbiAgICAgICAgICByZWplY3Qob3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cbiAgICAgICAgLy8gZXJyb3IgZXZlbnQgaXMgdHJpZ2VycmVkIGJvdGggd2l0aCBYRFIvWEhSIG9uOlxuICAgICAgICAvLyAgIC0gRE5TIGVycm9yXG4gICAgICAgIC8vICAgLSB1bmFsbG93ZWQgY3Jvc3MgZG9tYWluIHJlcXVlc3RcbiAgICAgICAgcmVqZWN0KFxuICAgICAgICAgIG5ldyBlcnJvcnMuTmV0d29yayh7XG4gICAgICAgICAgICBtb3JlOiBldmVudFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgICByZWplY3QobmV3IGVycm9ycy5SZXF1ZXN0VGltZW91dCgpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Db25uZWN0KCkge1xuICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG4gICAgICAgIHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgb3B0cy50aW1lb3V0cy5jb21wbGV0ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmICghY29ubmVjdGVkKSBvbkNvbm5lY3QoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWFkeVN0YXRlQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWNvbm5lY3RlZCAmJiByZXEucmVhZHlTdGF0ZSA+IDEpIG9uQ29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIEFsZ29saWFTZWFyY2hCcm93c2VyLnByb3RvdHlwZS5fcmVxdWVzdC5mYWxsYmFjayA9IGZ1bmN0aW9uIHJlcXVlc3RGYWxsYmFjayh1cmwsIG9wdHMpIHtcbiAgICB1cmwgPSBpbmxpbmVIZWFkZXJzKHVybCwgb3B0cy5oZWFkZXJzKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiB3cmFwSnNvbnBSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgICAganNvbnBSZXF1ZXN0KHVybCwgb3B0cywgZnVuY3Rpb24ganNvbnBSZXF1ZXN0RG9uZShlcnIsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoY29udGVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3Byb21pc2UgPSB7XG4gICAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3RQcm9taXNlKHZhbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbCk7XG4gICAgfSxcbiAgICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsKTtcbiAgICB9LFxuICAgIGRlbGF5OiBmdW5jdGlvbiBkZWxheVByb21pc2UobXMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiByZXNvbHZlT25UaW1lb3V0KHJlc29sdmUvKiAsIHJlamVjdCovKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBhbGdvbGlhc2VhcmNoO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9jcmVhdGVBbGdvbGlhc2VhcmNoLmpzIiwidmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICB3aW4gPSBzZWxmO1xufSBlbHNlIHtcbiAgICB3aW4gPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2dsb2JhbC93aW5kb3cuanMiLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDQuMS4xXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB4O1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBfaXNBcnJheSA9IHVuZGVmaW5lZDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB1bmRlZmluZWQ7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHt9KS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciByID0gcmVxdWlyZTtcbiAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB1bmRlZmluZWQ7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBfYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbnZhciBHRVRfVEhFTl9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIEdFVF9USEVOX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSBHRVRfVEhFTl9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgZ2V0VGhlbih2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdW5kZWZpbmVkLFxuICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBFcnJvck9iamVjdCgpIHtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG59XG5cbnZhciBUUllfQ0FUQ0hfRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yID0gdW5kZWZpbmVkLFxuICAgICAgc3VjY2VlZGVkID0gdW5kZWZpbmVkLFxuICAgICAgZmFpbGVkID0gdW5kZWZpbmVkO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IkMShDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMikge1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgIH0pLCBpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJDEoZW50cnkpLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gKHN0YXRlLCBpLCB2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBpKSB7XG4gIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgfSk7XG59O1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwkMShlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvciQxKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlJDEoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdCQxKHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UkMihyZXNvbHZlcikge1xuICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UkMiA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gIH1cbn1cblxuUHJvbWlzZSQyLmFsbCA9IGFsbCQxO1xuUHJvbWlzZSQyLnJhY2UgPSByYWNlJDE7XG5Qcm9taXNlJDIucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMi5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMi5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQyLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMi5fYXNhcCA9IGFzYXA7XG5cblByb21pc2UkMi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQcm9taXNlJDIsXG5cbiAgLyoqXG4gICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQ2hhaW5pbmdcbiAgICAtLS0tLS0tLVxuICBcbiAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICB9KTtcbiAgXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgfSk7XG4gICAgYGBgXG4gICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFzc2ltaWxhdGlvblxuICAgIC0tLS0tLS0tLS0tLVxuICBcbiAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBTaW1wbGUgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCByZXN1bHQ7XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCBhdXRob3IsIGJvb2tzO1xuICBcbiAgICB0cnkge1xuICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gIFxuICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgXG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICBcbiAgICB9XG4gIFxuICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZEF1dGhvcigpLlxuICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIHRoZW46IHRoZW4sXG5cbiAgLyoqXG4gICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgfVxuICBcbiAgICAvLyBzeW5jaHJvbm91c1xuICAgIHRyeSB7XG4gICAgICBmaW5kQXV0aG9yKCk7XG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfVxuICBcbiAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgJ2NhdGNoJzogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH1cbn07XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwkMSgpIHtcbiAgICB2YXIgbG9jYWwgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBnbG9iYWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICBpZiAoUCkge1xuICAgICAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQyO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDIucG9seWZpbGwgPSBwb2x5ZmlsbCQxO1xuUHJvbWlzZSQyLlByb21pc2UgPSBQcm9taXNlJDI7XG5cbnJldHVybiBQcm9taXNlJDI7XG5cbn0pKSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL34vZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHZlcnR4IChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAzIDQgNSA2IDciLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5saW5lSGVhZGVycztcblxudmFyIGVuY29kZSA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUnKTtcblxuZnVuY3Rpb24gaW5saW5lSGVhZGVycyh1cmwsIGhlYWRlcnMpIHtcbiAgaWYgKC9cXD8vLnRlc3QodXJsKSkge1xuICAgIHVybCArPSAnJic7XG4gIH0gZWxzZSB7XG4gICAgdXJsICs9ICc/JztcbiAgfVxuXG4gIHJldHVybiB1cmwgKyBlbmNvZGUoaGVhZGVycyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvaW5saW5lLWhlYWRlcnMuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBqc29ucFJlcXVlc3Q7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxudmFyIEpTT05QQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGpzb25wUmVxdWVzdCh1cmwsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICBjYihuZXcgRXJyb3IoJ01ldGhvZCAnICsgb3B0cy5tZXRob2QgKyAnICcgKyB1cmwgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSlNPTlAuJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdHMuZGVidWcoJ0pTT05QOiBzdGFydCcpO1xuXG4gIHZhciBjYkNhbGxlZCA9IGZhbHNlO1xuICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcblxuICBKU09OUENvdW50ZXIgKz0gMTtcbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBjYk5hbWUgPSAnYWxnb2xpYUpTT05QXycgKyBKU09OUENvdW50ZXI7XG4gIHZhciBkb25lID0gZmFsc2U7XG5cbiAgd2luZG93W2NiTmFtZV0gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmVtb3ZlR2xvYmFscygpO1xuXG4gICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICBvcHRzLmRlYnVnKCdKU09OUDogTGF0ZSBhbnN3ZXIsIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2JDYWxsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW4oKTtcblxuICAgIGNiKG51bGwsIHtcbiAgICAgIGJvZHk6IGRhdGEvKiAsXG4gICAgICAvLyBXZSBkbyBub3Qgc2VuZCB0aGUgc3RhdHVzQ29kZSwgdGhlcmUncyBubyBzdGF0dXNDb2RlIGluIEpTT05QLCBpdCB3aWxsIGJlXG4gICAgICAvLyBjb21wdXRlZCB1c2luZyBkYXRhLnN0YXR1cyAmJiBkYXRhLm1lc3NhZ2UgbGlrZSB3aXRoIFhEUlxuICAgICAgc3RhdHVzQ29kZSovXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYWRkIGNhbGxiYWNrIGJ5IGhhbmRcbiAgdXJsICs9ICcmY2FsbGJhY2s9JyArIGNiTmFtZTtcblxuICAvLyBhZGQgYm9keSBwYXJhbXMgbWFudWFsbHlcbiAgaWYgKG9wdHMuanNvbkJvZHkgJiYgb3B0cy5qc29uQm9keS5wYXJhbXMpIHtcbiAgICB1cmwgKz0gJyYnICsgb3B0cy5qc29uQm9keS5wYXJhbXM7XG4gIH1cblxuICB2YXIgb250aW1lb3V0ID0gc2V0VGltZW91dCh0aW1lb3V0LCBvcHRzLnRpbWVvdXRzLmNvbXBsZXRlKTtcblxuICAvLyBzY3JpcHQgb25yZWFkeXN0YXRlY2hhbmdlIG5lZWRlZCBvbmx5IGZvclxuICAvLyA8PSBJRThcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvNDUyM1xuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZTtcbiAgc2NyaXB0Lm9ubG9hZCA9IHN1Y2Nlc3M7XG4gIHNjcmlwdC5vbmVycm9yID0gZXJyb3I7XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgb3B0cy5kZWJ1ZygnSlNPTlA6IHN1Y2Nlc3MnKTtcblxuICAgIGlmIChkb25lIHx8IHRpbWVkT3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9uZSA9IHRydWU7XG5cbiAgICAvLyBzY3JpcHQgbG9hZGVkIGJ1dCBkaWQgbm90IGNhbGwgdGhlIGZuID0+IHNjcmlwdCBsb2FkaW5nIGVycm9yXG4gICAgaWYgKCFjYkNhbGxlZCkge1xuICAgICAgb3B0cy5kZWJ1ZygnSlNPTlA6IEZhaWwuIFNjcmlwdCBsb2FkZWQgYnV0IGRpZCBub3QgY2FsbCB0aGUgY2FsbGJhY2snKTtcbiAgICAgIGNsZWFuKCk7XG4gICAgICBjYihuZXcgZXJyb3JzLkpTT05QU2NyaXB0RmFpbCgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgc3VjY2VzcygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgIGNsZWFyVGltZW91dChvbnRpbWVvdXQpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVHbG9iYWxzKCkge1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgd2luZG93W2NiTmFtZV07XG4gICAgICBkZWxldGUgd2luZG93W2NiTmFtZSArICdfbG9hZGVkJ107XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2luZG93W2NiTmFtZV0gPSB3aW5kb3dbY2JOYW1lICsgJ19sb2FkZWQnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lb3V0KCkge1xuICAgIG9wdHMuZGVidWcoJ0pTT05QOiBTY3JpcHQgdGltZW91dCcpO1xuICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICBjbGVhbigpO1xuICAgIGNiKG5ldyBlcnJvcnMuUmVxdWVzdFRpbWVvdXQoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICBvcHRzLmRlYnVnKCdKU09OUDogU2NyaXB0IGVycm9yJyk7XG5cbiAgICBpZiAoZG9uZSB8fCB0aW1lZE91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFuKCk7XG4gICAgY2IobmV3IGVycm9ycy5KU09OUFNjcmlwdEVycm9yKCkpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvanNvbnAtcmVxdWVzdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUGxhY2VzQ2xpZW50O1xuXG52YXIgYnVpbGRTZWFyY2hNZXRob2QgPSByZXF1aXJlKCcuL2J1aWxkU2VhcmNoTWV0aG9kLmpzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYWNlc0NsaWVudChhbGdvbGlhc2VhcmNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwbGFjZXMoYXBwSUQsIGFwaUtleSwgb3B0cykge1xuICAgIHZhciBjbG9uZURlZXAgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG5cbiAgICBvcHRzID0gb3B0cyAmJiBjbG9uZURlZXAob3B0cykgfHwge307XG4gICAgb3B0cy5ob3N0cyA9IG9wdHMuaG9zdHMgfHwgW1xuICAgICAgJ3BsYWNlcy1kc24uYWxnb2xpYS5uZXQnLFxuICAgICAgJ3BsYWNlcy0xLmFsZ29saWFuZXQuY29tJyxcbiAgICAgICdwbGFjZXMtMi5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAncGxhY2VzLTMuYWxnb2xpYW5ldC5jb20nXG4gICAgXTtcblxuICAgIC8vIGFsbG93IGluaXRQbGFjZXMoKSBubyBhcmd1bWVudHMgPT4gY29tbXVuaXR5IHJhdGUgbGltaXRlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBhcHBJRCA9PT0gJ29iamVjdCcgfHwgYXBwSUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXBwSUQgPSAnJztcbiAgICAgIGFwaUtleSA9ICcnO1xuICAgICAgb3B0cy5fYWxsb3dFbXB0eUNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2xpZW50ID0gYWxnb2xpYXNlYXJjaChhcHBJRCwgYXBpS2V5LCBvcHRzKTtcbiAgICB2YXIgaW5kZXggPSBjbGllbnQuaW5pdEluZGV4KCdwbGFjZXMnKTtcbiAgICBpbmRleC5zZWFyY2ggPSBidWlsZFNlYXJjaE1ldGhvZCgncXVlcnknLCAnLzEvcGxhY2VzL3F1ZXJ5Jyk7XG4gICAgaW5kZXguZ2V0T2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6ICcvMS9wbGFjZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL3BsYWNlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZXREb2N1bWVudFByb3RvY29sO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudFByb3RvY29sKCkge1xuICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cuZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2w7XG5cbiAgLy8gd2hlbiBpbiBgZmlsZTpgIG1vZGUgKGxvY2FsIGh0bWwgZmlsZSksIGRlZmF1bHQgdG8gYGh0dHA6YFxuICBpZiAocHJvdG9jb2wgIT09ICdodHRwOicgJiYgcHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgcHJvdG9jb2wgPSAnaHR0cDonO1xuICB9XG5cbiAgcmV0dXJuIHByb3RvY29sO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2dldC1kb2N1bWVudC1wcm90b2NvbC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMy4yNC4zJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvdmVyc2lvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=