/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5);


/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*
	* loglevel - https://github.com/pimterry/loglevel
	*
	* Copyright (c) 2013 Tim Perry
	* Licensed under the MIT license.
	*/
	(function (root, definition) {
	    "use strict";
	
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
	        module.exports = definition();
	    } else {
	        root.log = definition();
	    }
	})(undefined, function () {
	    "use strict";
	
	    // Slightly dubious tricks to cut down minimized file size
	
	    var noop = function noop() {};
	    var undefinedType = "undefined";
	
	    var logMethods = ["trace", "debug", "info", "warn", "error"];
	
	    // Cross-browser bind equivalent that works at least back to IE6
	    function bindMethod(obj, methodName) {
	        var method = obj[methodName];
	        if (typeof method.bind === 'function') {
	            return method.bind(obj);
	        } else {
	            try {
	                return Function.prototype.bind.call(method, obj);
	            } catch (e) {
	                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
	                return function () {
	                    return Function.prototype.apply.apply(method, [obj, arguments]);
	                };
	            }
	        }
	    }
	
	    // Build the best logging method possible for this env
	    // Wherever possible we want to bind, not wrap, to preserve stack traces
	    function realMethod(methodName) {
	        if (methodName === 'debug') {
	            methodName = 'log';
	        }
	
	        if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType) {
	            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
	        } else if (console[methodName] !== undefined) {
	            return bindMethod(console, methodName);
	        } else if (console.log !== undefined) {
	            return bindMethod(console, 'log');
	        } else {
	            return noop;
	        }
	    }
	
	    // These private functions always need `this` to be set properly
	
	    function replaceLoggingMethods(level, loggerName) {
	        /*jshint validthis:true */
	        for (var i = 0; i < logMethods.length; i++) {
	            var methodName = logMethods[i];
	            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
	        }
	
	        // Define log.log as an alias for log.debug
	        this.log = this.debug;
	    }
	
	    // In old IE versions, the console isn't present until you first open it.
	    // We build realMethod() replacements here that regenerate logging methods
	    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
	        return function () {
	            if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== undefinedType) {
	                replaceLoggingMethods.call(this, level, loggerName);
	                this[methodName].apply(this, arguments);
	            }
	        };
	    }
	
	    // By default, we use closely bound real methods wherever possible, and
	    // otherwise we wait for a console to appear, and then try again.
	    function defaultMethodFactory(methodName, level, loggerName) {
	        /*jshint validthis:true */
	        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
	    }
	
	    function Logger(name, defaultLevel, factory) {
	        var self = this;
	        var currentLevel;
	        var storageKey = "loglevel";
	        if (name) {
	            storageKey += ":" + name;
	        }
	
	        function persistLevelIfPossible(levelNum) {
	            var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            // Use localStorage if available
	            try {
	                window.localStorage[storageKey] = levelName;
	                return;
	            } catch (ignore) {}
	
	            // Use session cookie as fallback
	            try {
	                window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
	            } catch (ignore) {}
	        }
	
	        function getPersistedLevel() {
	            var storedLevel;
	
	            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;
	
	            try {
	                storedLevel = window.localStorage[storageKey];
	            } catch (ignore) {}
	
	            // Fallback to cookies if local storage gives us nothing
	            if ((typeof storedLevel === 'undefined' ? 'undefined' : _typeof(storedLevel)) === undefinedType) {
	                try {
	                    var cookie = window.document.cookie;
	                    var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
	                    if (location) {
	                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
	                    }
	                } catch (ignore) {}
	            }
	
	            // If the stored level is not valid, treat it as if nothing was stored.
	            if (self.levels[storedLevel] === undefined) {
	                storedLevel = undefined;
	            }
	
	            return storedLevel;
	        }
	
	        /*
	         *
	         * Public logger API - see https://github.com/pimterry/loglevel for details
	         *
	         */
	
	        self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
	            "ERROR": 4, "SILENT": 5 };
	
	        self.methodFactory = factory || defaultMethodFactory;
	
	        self.getLevel = function () {
	            return currentLevel;
	        };
	
	        self.setLevel = function (level, persist) {
	            if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
	                level = self.levels[level.toUpperCase()];
	            }
	            if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
	                currentLevel = level;
	                if (persist !== false) {
	                    // defaults to true
	                    persistLevelIfPossible(level);
	                }
	                replaceLoggingMethods.call(self, level, name);
	                if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType && level < self.levels.SILENT) {
	                    return "No console available for logging";
	                }
	            } else {
	                throw "log.setLevel() called with invalid level: " + level;
	            }
	        };
	
	        self.setDefaultLevel = function (level) {
	            if (!getPersistedLevel()) {
	                self.setLevel(level, false);
	            }
	        };
	
	        self.enableAll = function (persist) {
	            self.setLevel(self.levels.TRACE, persist);
	        };
	
	        self.disableAll = function (persist) {
	            self.setLevel(self.levels.SILENT, persist);
	        };
	
	        // Initialize with the right level
	        var initialLevel = getPersistedLevel();
	        if (initialLevel == null) {
	            initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
	        }
	        self.setLevel(initialLevel, false);
	    }
	
	    /*
	     *
	     * Top-level API
	     *
	     */
	
	    var defaultLogger = new Logger();
	
	    var _loggersByName = {};
	    defaultLogger.getLogger = function getLogger(name) {
	        if (typeof name !== "string" || name === "") {
	            throw new TypeError("You must supply a name when creating a logger.");
	        }
	
	        var logger = _loggersByName[name];
	        if (!logger) {
	            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
	        }
	        return logger;
	    };
	
	    // Grab the current global log variable in case of overwrite
	    var _log = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType ? window.log : undefined;
	    defaultLogger.noConflict = function () {
	        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType && window.log === defaultLogger) {
	            window.log = _log;
	        }
	
	        return defaultLogger;
	    };
	
	    return defaultLogger;
	});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(6);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _explaainSearch = __webpack_require__(12);
	
	var _explaainSearch2 = _interopRequireDefault(_explaainSearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var UserIDs = {
	  live: {
	    Jeremy: '1627888800569309',
	    Matt: '1455707247850069',
	    Carol: '1459068990878077',
	    Harriet: '1478776232161468',
	    Jonny: '1513554438729753'
	  },
	  staging: {
	    Jeremy: '1366746370089527',
	    Matt: '1528134990563202'
	  },
	  local: {
	    Jeremy: '1300120880110773',
	    Matt: '1428419100528438'
	  },
	  drive: {
	    Jeremy: '104380110279658920175',
	    ACME: '101118387301286232222'
	  }
	};
	
	var UserID = UserIDs.drive.ACME;
	var PageResults = {};
	var UserCards = [];
	var LastRefresh = 0;
	
	var algoliaParams = { // Need to send these to app.vue to avoid duplication!
	  appID: 'I2VKMNNAXI',
	  apiKey: '2b8406f84cd4cc507da173032c46ee7b',
	  index: 'ForgetMeNot_Context_Test'
	};
	_vue2.default.use(_explaainSearch2.default, algoliaParams);
	
	chrome.browserAction.onClicked.addListener(function (tab) {
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    chrome.tabs.sendMessage(tabs[0].id, { action: 'toggleDrawer' }, function (res) {
	      _loglevel2.default.info(res);
	    });
	  });
	});
	
	chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
	  try {
	    _loglevel2.default.debug(sender.tab ? "From a content script: " + sender.tab.url : "From the extension", request);
	
	    if (request.action == "getPageResults") {
	      getCurrentPageResults(request.data).then(function (res) {
	        _loglevel2.default.debug(res);
	        sendResponse(res);
	      });
	      return true;
	    }
	    if (request.action == "checkPage") {
	      _loglevel2.default.trace(request.data);
	      checkRefresh().then(function () {
	        return _explaainSearch2.default.getPageResults(UserID, request.data, UserCards);
	      }).then(function (res) {
	        addToPageResults(sender.tab.id, res);
	        PageResults = res;
	        sendResponse(res);
	      }).catch(function (e) {
	        _loglevel2.default.error(e);
	      });
	      return true;
	    }
	    if (request.action == "getUser") {
	      sendResponse(UserID);
	      return true;
	    }
	    if (request.action == "refreshCards") {
	      getAllUserCards();
	      return true;
	    }
	    if (request.event == "popupOpened") {
	      chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	        chrome.tabs.sendMessage(tabs[0].id, { event: 'popupOpened' }, function (response) {});
	      });
	      return true;
	    }
	  } catch (e) {
	    _loglevel2.default.error(e);
	  }
	});
	
	var getCurrentPageResults = function getCurrentPageResults(data) {
	  var d = _q2.default.defer();
	  var tabID;
	  _loglevel2.default.debug(1);
	  checkRefresh().then(getCurrentTab).then(function (tab) {
	    _loglevel2.default.debug(tab.id);
	    tabID = tab.id;
	    _loglevel2.default.debug(PageResults);
	    if (PageResults[tabID]) {
	      d.resolve(PageResults[tabID]);
	    } else {
	      if (!data) data = { tabID: tabID };
	      _loglevel2.default.debug(data);
	      getPageData(data).then(function (res) {
	        _loglevel2.default.debug(res);
	        return _explaainSearch2.default.getPageResults(UserID, res, UserCards);
	      }).then(function (res) {
	        _loglevel2.default.debug(res);
	        addToPageResults(tabID, res);
	        d.resolve(res);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	    }
	  }).catch(function (e) {
	    d.reject(e);
	  });
	  return d.promise;
	};
	
	var getCurrentTab = function getCurrentTab() {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    d.resolve(tabs[0]);
	  });
	  return d.promise;
	};
	
	var getPageData = function getPageData(data) {
	  var d = _q2.default.defer();
	  if (data.pageData) {
	    d.resolve(data.pageData);
	  } else if (data.tabID) {
	    sendMessageToTab(tabID, { action: 'getPageData' }).then(function (res) {
	      d.resolve(res);
	    });
	  } else {
	    d.reject();
	  }
	  return d.promise;
	};
	
	var sendMessageToTab = function sendMessageToTab(tabID, data) {
	  // Need error catching here
	  var d = _q2.default.defer();
	  chrome.tabs.sendMessage(tabID, data, function (res) {
	    _loglevel2.default.debug(res);
	    d.resolve(res);
	  });
	  return d.promise;
	};
	
	var addToPageResults = function addToPageResults(tabID, data) {
	  PageResults[tabID] = data;
	  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
	    Object.keys(PageResults).forEach(function (pageTabID) {
	      if (tabs.filter(function (tab) {
	        return tab.id == pageTabID;
	      }).length == 0) delete PageResults[pageTabID];
	    });
	    _loglevel2.default.debug(PageResults);
	  });
	};
	
	var checkRefresh = function checkRefresh() {
	  var d = _q2.default.defer();
	  var now = new Date();
	  if (now - LastRefresh > 300000) {
	    getAllUserCards().then(function () {
	      d.resolve();
	    }).catch(function (e) {
	      _loglevel2.default.error(e);
	      d.reject(e);
	    });
	  } else {
	    d.resolve();
	  }
	  return d.promise;
	};
	
	var getAllUserCards = function getAllUserCards() {
	  var d = _q2.default.defer();
	  LastRefresh = new Date();
	  _explaainSearch2.default.searchCards(UserID, '', 1000).then(function (results) {
	    UserCards = results;
	    _loglevel2.default.debug(UserCards);
	    d.resolve();
	  }).catch(function (e) {
	    _loglevel2.default.error(e);
	    d.reject(e);
	  });
	  return d.promise;
	};
	getAllUserCards();

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * Vue.js v2.4.2
	 * (c) 2014-2017 Evan You
	 * Released under the MIT License.
	 */
	/*  */
	
	// these helpers produces better vm code in JS engines due to their
	// explicitness and function inlining
	function isUndef(v) {
	  return v === undefined || v === null;
	}
	
	function isDef(v) {
	  return v !== undefined && v !== null;
	}
	
	function isTrue(v) {
	  return v === true;
	}
	
	function isFalse(v) {
	  return v === false;
	}
	
	/**
	 * Check if value is primitive
	 */
	function isPrimitive(value) {
	  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	}
	
	var _toString = Object.prototype.toString;
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	function isPlainObject(obj) {
	  return _toString.call(obj) === '[object Object]';
	}
	
	function isRegExp(v) {
	  return _toString.call(v) === '[object RegExp]';
	}
	
	/**
	 * Check if val is a valid array index.
	 */
	function isValidArrayIndex(val) {
	  var n = parseFloat(val);
	  return n >= 0 && Math.floor(n) === n && isFinite(val);
	}
	
	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function toString(val) {
	  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
	}
	
	/**
	 * Convert a input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber(val) {
	  var n = parseFloat(val);
	  return isNaN(n) ? val : n;
	}
	
	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap(str, expectsLowerCase) {
	  var map = Object.create(null);
	  var list = str.split(',');
	  for (var i = 0; i < list.length; i++) {
	    map[list[i]] = true;
	  }
	  return expectsLowerCase ? function (val) {
	    return map[val.toLowerCase()];
	  } : function (val) {
	    return map[val];
	  };
	}
	
	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);
	
	/**
	 * Check if a attribute is a reserved attribute.
	 */
	var isReservedAttribute = makeMap('key,ref,slot,is');
	
	/**
	 * Remove an item from an array
	 */
	function remove(arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1);
	    }
	  }
	}
	
	/**
	 * Check whether the object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Create a cached version of a pure function.
	 */
	function cached(fn) {
	  var cache = Object.create(null);
	  return function cachedFn(str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str));
	  };
	}
	
	/**
	 * Camelize a hyphen-delimited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	  return str.replace(camelizeRE, function (_, c) {
	    return c ? c.toUpperCase() : '';
	  });
	});
	
	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1);
	});
	
	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /([^-])([A-Z])/g;
	var hyphenate = cached(function (str) {
	  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
	});
	
	/**
	 * Simple bind, faster than native
	 */
	function bind(fn, ctx) {
	  function boundFn(a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  }
	  // record original fn length
	  boundFn._length = fn.length;
	  return boundFn;
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 */
	function extend(to, _from) {
	  for (var key in _from) {
	    to[key] = _from[key];
	  }
	  return to;
	}
	
	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject(arr) {
	  var res = {};
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i]) {
	      extend(res, arr[i]);
	    }
	  }
	  return res;
	}
	
	/**
	 * Perform no operation.
	 * Stubbing args to make Flow happy without leaving useless transpiled code
	 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
	 */
	function noop(a, b, c) {}
	
	/**
	 * Always return false.
	 */
	var no = function no(a, b, c) {
	  return false;
	};
	
	/**
	 * Return same value
	 */
	var identity = function identity(_) {
	  return _;
	};
	
	/**
	 * Generate a static keys string from compiler modules.
	 */
	function genStaticKeys(modules) {
	  return modules.reduce(function (keys, m) {
	    return keys.concat(m.staticKeys || []);
	  }, []).join(',');
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual(a, b) {
	  if (a === b) {
	    return true;
	  }
	  var isObjectA = isObject(a);
	  var isObjectB = isObject(b);
	  if (isObjectA && isObjectB) {
	    try {
	      var isArrayA = Array.isArray(a);
	      var isArrayB = Array.isArray(b);
	      if (isArrayA && isArrayB) {
	        return a.length === b.length && a.every(function (e, i) {
	          return looseEqual(e, b[i]);
	        });
	      } else if (!isArrayA && !isArrayB) {
	        var keysA = Object.keys(a);
	        var keysB = Object.keys(b);
	        return keysA.length === keysB.length && keysA.every(function (key) {
	          return looseEqual(a[key], b[key]);
	        });
	      } else {
	        /* istanbul ignore next */
	        return false;
	      }
	    } catch (e) {
	      /* istanbul ignore next */
	      return false;
	    }
	  } else if (!isObjectA && !isObjectB) {
	    return String(a) === String(b);
	  } else {
	    return false;
	  }
	}
	
	function looseIndexOf(arr, val) {
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	/**
	 * Ensure a function is called only once.
	 */
	function once(fn) {
	  var called = false;
	  return function () {
	    if (!called) {
	      called = true;
	      fn.apply(this, arguments);
	    }
	  };
	}
	
	var SSR_ATTR = 'data-server-rendered';
	
	var ASSET_TYPES = ['component', 'directive', 'filter'];
	
	var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];
	
	/*  */
	
	var config = {
	  /**
	   * Option merge strategies (used in core/util/options)
	   */
	  optionMergeStrategies: Object.create(null),
	
	  /**
	   * Whether to suppress warnings.
	   */
	  silent: false,
	
	  /**
	   * Show production mode tip message on boot?
	   */
	  productionTip: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to enable devtools
	   */
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to record perf
	   */
	  performance: false,
	
	  /**
	   * Error handler for watcher errors
	   */
	  errorHandler: null,
	
	  /**
	   * Warn handler for watcher warns
	   */
	  warnHandler: null,
	
	  /**
	   * Ignore certain custom elements
	   */
	  ignoredElements: [],
	
	  /**
	   * Custom user key aliases for v-on
	   */
	  keyCodes: Object.create(null),
	
	  /**
	   * Check if a tag is reserved so that it cannot be registered as a
	   * component. This is platform-dependent and may be overwritten.
	   */
	  isReservedTag: no,
	
	  /**
	   * Check if an attribute is reserved so that it cannot be used as a component
	   * prop. This is platform-dependent and may be overwritten.
	   */
	  isReservedAttr: no,
	
	  /**
	   * Check if a tag is an unknown element.
	   * Platform-dependent.
	   */
	  isUnknownElement: no,
	
	  /**
	   * Get the namespace of an element
	   */
	  getTagNamespace: noop,
	
	  /**
	   * Parse the real tag name for the specific platform.
	   */
	  parsePlatformTagName: identity,
	
	  /**
	   * Check if an attribute must be bound using property, e.g. value
	   * Platform-dependent.
	   */
	  mustUseProp: no,
	
	  /**
	   * Exposed for legacy reasons
	   */
	  _lifecycleHooks: LIFECYCLE_HOOKS
	};
	
	/*  */
	
	var emptyObject = Object.freeze({});
	
	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Define a property.
	 */
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Parse simple path.
	 */
	var bailRE = /[^\w.$]/;
	function parsePath(path) {
	  if (bailRE.test(path)) {
	    return;
	  }
	  var segments = path.split('.');
	  return function (obj) {
	    for (var i = 0; i < segments.length; i++) {
	      if (!obj) {
	        return;
	      }
	      obj = obj[segments[i]];
	    }
	    return obj;
	  };
	}
	
	/*  */
	
	var warn = noop;
	var tip = noop;
	var formatComponentName = null; // work around flow check
	
	if (process.env.NODE_ENV !== 'production') {
	  var hasConsole = typeof console !== 'undefined';
	  var classifyRE = /(?:^|[-_])(\w)/g;
	  var classify = function classify(str) {
	    return str.replace(classifyRE, function (c) {
	      return c.toUpperCase();
	    }).replace(/[-_]/g, '');
	  };
	
	  warn = function warn(msg, vm) {
	    var trace = vm ? generateComponentTrace(vm) : '';
	
	    if (config.warnHandler) {
	      config.warnHandler.call(null, msg, vm, trace);
	    } else if (hasConsole && !config.silent) {
	      console.error("[Vue warn]: " + msg + trace);
	    }
	  };
	
	  tip = function tip(msg, vm) {
	    if (hasConsole && !config.silent) {
	      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
	    }
	  };
	
	  formatComponentName = function formatComponentName(vm, includeFile) {
	    if (vm.$root === vm) {
	      return '<Root>';
	    }
	    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;
	
	    var file = vm._isVue && vm.$options.__file;
	    if (!name && file) {
	      var match = file.match(/([^/\\]+)\.vue$/);
	      name = match && match[1];
	    }
	
	    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
	  };
	
	  var repeat = function repeat(str, n) {
	    var res = '';
	    while (n) {
	      if (n % 2 === 1) {
	        res += str;
	      }
	      if (n > 1) {
	        str += str;
	      }
	      n >>= 1;
	    }
	    return res;
	  };
	
	  var generateComponentTrace = function generateComponentTrace(vm) {
	    if (vm._isVue && vm.$parent) {
	      var tree = [];
	      var currentRecursiveSequence = 0;
	      while (vm) {
	        if (tree.length > 0) {
	          var last = tree[tree.length - 1];
	          if (last.constructor === vm.constructor) {
	            currentRecursiveSequence++;
	            vm = vm.$parent;
	            continue;
	          } else if (currentRecursiveSequence > 0) {
	            tree[tree.length - 1] = [last, currentRecursiveSequence];
	            currentRecursiveSequence = 0;
	          }
	        }
	        tree.push(vm);
	        vm = vm.$parent;
	      }
	      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
	        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
	      }).join('\n');
	    } else {
	      return "\n\n(found in " + formatComponentName(vm) + ")";
	    }
	  };
	}
	
	/*  */
	
	function handleError(err, vm, info) {
	  if (config.errorHandler) {
	    config.errorHandler.call(null, err, vm, info);
	  } else {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
	    }
	    /* istanbul ignore else */
	    if (inBrowser && typeof console !== 'undefined') {
	      console.error(err);
	    } else {
	      throw err;
	    }
	  }
	}
	
	/*  */
	/* globals MutationObserver */
	
	// can we use __proto__?
	var hasProto = '__proto__' in {};
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
	var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
	
	// Firefix has a "watch" function on Object.prototype...
	var nativeWatch = {}.watch;
	
	var supportsPassive = false;
	if (inBrowser) {
	  try {
	    var opts = {};
	    Object.defineProperty(opts, 'passive', {
	      get: function get() {
	        /* istanbul ignore next */
	        supportsPassive = true;
	      }
	    }); // https://github.com/facebook/flow/issues/285
	    window.addEventListener('test-passive', null, opts);
	  } catch (e) {}
	}
	
	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function isServerRendering() {
	  if (_isServer === undefined) {
	    /* istanbul ignore if */
	    if (!inBrowser && typeof global !== 'undefined') {
	      // detect presence of vue-server-renderer and avoid
	      // Webpack shimming the process
	      _isServer = global['process'].env.VUE_ENV === 'server';
	    } else {
	      _isServer = false;
	    }
	  }
	  return _isServer;
	};
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	/* istanbul ignore next */
	function isNative(Ctor) {
	  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
	}
	
	var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
	
	/**
	 * Defer a task to execute it asynchronously.
	 */
	var nextTick = function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  // the nextTick behavior leverages the microtask queue, which can be accessed
	  // via either native Promise.then or MutationObserver.
	  // MutationObserver has wider support, however it is seriously bugged in
	  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	  // completely stops working after triggering a few times... so, if native
	  // Promise is available, we will use it:
	  /* istanbul ignore if */
	  if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p = Promise.resolve();
	    var logError = function logError(err) {
	      console.error(err);
	    };
	    timerFunc = function timerFunc() {
	      p.then(nextTickHandler).catch(logError);
	      // in problematic UIWebViews, Promise.then doesn't completely break, but
	      // it can get stuck in a weird state where callbacks are pushed into the
	      // microtask queue but the queue isn't being flushed, until the browser
	      // needs to do some other work, e.g. handle a timer. Therefore we can
	      // "force" the microtask queue to be flushed by adding an empty timer.
	      if (isIOS) {
	        setTimeout(noop);
	      }
	    };
	  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
	  // PhantomJS and iOS 7.x
	  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
	    // use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS IE11, iOS7, Android 4.4
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(String(counter));
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function timerFunc() {
	      counter = (counter + 1) % 2;
	      textNode.data = String(counter);
	    };
	  } else {
	    // fallback to setTimeout
	    /* istanbul ignore next */
	    timerFunc = function timerFunc() {
	      setTimeout(nextTickHandler, 0);
	    };
	  }
	
	  return function queueNextTick(cb, ctx) {
	    var _resolve;
	    callbacks.push(function () {
	      if (cb) {
	        try {
	          cb.call(ctx);
	        } catch (e) {
	          handleError(e, ctx, 'nextTick');
	        }
	      } else if (_resolve) {
	        _resolve(ctx);
	      }
	    });
	    if (!pending) {
	      pending = true;
	      timerFunc();
	    }
	    if (!cb && typeof Promise !== 'undefined') {
	      return new Promise(function (resolve, reject) {
	        _resolve = resolve;
	      });
	    }
	  };
	}();
	
	var _Set;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && isNative(Set)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    function Set() {
	      this.set = Object.create(null);
	    }
	    Set.prototype.has = function has(key) {
	      return this.set[key] === true;
	    };
	    Set.prototype.add = function add(key) {
	      this.set[key] = true;
	    };
	    Set.prototype.clear = function clear() {
	      this.set = Object.create(null);
	    };
	
	    return Set;
	  }();
	}
	
	/*  */
	
	var uid = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 */
	var Dep = function Dep() {
	  this.id = uid++;
	  this.subs = [];
	};
	
	Dep.prototype.addSub = function addSub(sub) {
	  this.subs.push(sub);
	};
	
	Dep.prototype.removeSub = function removeSub(sub) {
	  remove(this.subs, sub);
	};
	
	Dep.prototype.depend = function depend() {
	  if (Dep.target) {
	    Dep.target.addDep(this);
	  }
	};
	
	Dep.prototype.notify = function notify() {
	  // stabilize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	var targetStack = [];
	
	function pushTarget(_target) {
	  if (Dep.target) {
	    targetStack.push(Dep.target);
	  }
	  Dep.target = _target;
	}
	
	function popTarget() {
	  Dep.target = targetStack.pop();
	}
	
	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    var args = [],
	        len = arguments.length;
	    while (len--) {
	      args[len] = arguments[len];
	    }var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) {
	      ob.observeArray(inserted);
	    }
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/*  */
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However when passing down props,
	 * we don't want to force conversion because the value may be a nested value
	 * under a frozen data structure. Converting it would defeat the optimization.
	 */
	var observerState = {
	  shouldConvert: true
	};
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 */
	var Observer = function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  this.vmCount = 0;
	  def(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	};
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 */
	Observer.prototype.walk = function walk(obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0; i < keys.length; i++) {
	    defineReactive$$1(obj, keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 */
	Observer.prototype.observeArray = function observeArray(items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 */
	function protoAugment(target, src, keys) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 */
	/* istanbul ignore next */
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe(value, asRootData) {
	  if (!isObject(value)) {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (asRootData && ob) {
	    ob.vmCount++;
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive$$1(obj, key, val, customSetter, shallow) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = !shallow && observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          dependArray(value);
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      /* eslint-disable no-self-compare */
	      if (newVal === value || newVal !== newVal && value !== value) {
	        return;
	      }
	      /* eslint-enable no-self-compare */
	      if (process.env.NODE_ENV !== 'production' && customSetter) {
	        customSetter();
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = !shallow && observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 */
	function set(target, key, val) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.length = Math.max(target.length, key);
	    target.splice(key, 1, val);
	    return val;
	  }
	  if (hasOwn(target, key)) {
	    target[key] = val;
	    return val;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
	    return val;
	  }
	  if (!ob) {
	    target[key] = val;
	    return val;
	  }
	  defineReactive$$1(ob.value, key, val);
	  ob.dep.notify();
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 */
	function del(target, key) {
	  if (Array.isArray(target) && isValidArrayIndex(key)) {
	    target.splice(key, 1);
	    return;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
	    return;
	  }
	  if (!hasOwn(target, key)) {
	    return;
	  }
	  delete target[key];
	  if (!ob) {
	    return;
	  }
	  ob.dep.notify();
	}
	
	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray(value) {
	  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
	    e = value[i];
	    e && e.__ob__ && e.__ob__.dep.depend();
	    if (Array.isArray(e)) {
	      dependArray(e);
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;
	
	/**
	 * Options with restrictions
	 */
	if (process.env.NODE_ENV !== 'production') {
	  strats.el = strats.propsData = function (parent, child, vm, key) {
	    if (!vm) {
	      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
	    }
	    return defaultStrat(parent, child);
	  };
	}
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData(to, from) {
	  if (!from) {
	    return to;
	  }
	  var key, toVal, fromVal;
	  var keys = Object.keys(from);
	  for (var i = 0; i < keys.length; i++) {
	    key = keys[i];
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	function mergeDataOrFn(parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	}
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    if (childVal && typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	
	      return parentVal;
	    }
	    return mergeDataOrFn.call(this, parentVal, childVal);
	  }
	
	  return mergeDataOrFn(parentVal, childVal, vm);
	};
	
	/**
	 * Hooks and props are merged as arrays.
	 */
	function mergeHook(parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
	}
	
	LIFECYCLE_HOOKS.forEach(function (hook) {
	  strats[hook] = mergeHook;
	});
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, childVal) : res;
	}
	
	ASSET_TYPES.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal) {
	  // work around Firefox's Object.prototype.watch...
	  if (parentVal === nativeWatch) {
	    parentVal = undefined;
	  }
	  if (childVal === nativeWatch) {
	    childVal = undefined;
	  }
	  /* istanbul ignore if */
	  if (!childVal) {
	    return Object.create(parentVal || null);
	  }
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !Array.isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  if (childVal) {
	    extend(ret, childVal);
	  }
	  return ret;
	};
	strats.provide = mergeDataOrFn;
	
	/**
	 * Default strategy.
	 */
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Validate component names
	 */
	function checkComponents(options) {
	  for (var key in options.components) {
	    var lower = key.toLowerCase();
	    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
	      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps(options) {
	  var props = options.props;
	  if (!props) {
	    return;
	  }
	  var res = {};
	  var i, val, name;
	  if (Array.isArray(props)) {
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        name = camelize(val);
	        res[name] = { type: null };
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('props must be strings when using array syntax.');
	      }
	    }
	  } else if (isPlainObject(props)) {
	    for (var key in props) {
	      val = props[key];
	      name = camelize(key);
	      res[name] = isPlainObject(val) ? val : { type: val };
	    }
	  }
	  options.props = res;
	}
	
	/**
	 * Normalize all injections into Object-based format
	 */
	function normalizeInject(options) {
	  var inject = options.inject;
	  if (Array.isArray(inject)) {
	    var normalized = options.inject = {};
	    for (var i = 0; i < inject.length; i++) {
	      normalized[inject[i]] = inject[i];
	    }
	  }
	}
	
	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives(options) {
	  var dirs = options.directives;
	  if (dirs) {
	    for (var key in dirs) {
	      var def = dirs[key];
	      if (typeof def === 'function') {
	        dirs[key] = { bind: def, update: def };
	      }
	    }
	  }
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions(parent, child, vm) {
	  if (process.env.NODE_ENV !== 'production') {
	    checkComponents(child);
	  }
	
	  if (typeof child === 'function') {
	    child = child.options;
	  }
	
	  normalizeProps(child);
	  normalizeInject(child);
	  normalizeDirectives(child);
	  var extendsFrom = child.extends;
	  if (extendsFrom) {
	    parent = mergeOptions(parent, extendsFrom, vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  var options = {};
	  var key;
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  // check local registration variations first
	  if (hasOwn(assets, id)) {
	    return assets[id];
	  }
	  var camelizedId = camelize(id);
	  if (hasOwn(assets, camelizedId)) {
	    return assets[camelizedId];
	  }
	  var PascalCaseId = capitalize(camelizedId);
	  if (hasOwn(assets, PascalCaseId)) {
	    return assets[PascalCaseId];
	  }
	  // fallback to prototype chain
	  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	/*  */
	
	function validateProp(key, propOptions, propsData, vm) {
	  var prop = propOptions[key];
	  var absent = !hasOwn(propsData, key);
	  var value = propsData[key];
	  // handle boolean props
	  if (isType(Boolean, prop.type)) {
	    if (absent && !hasOwn(prop, 'default')) {
	      value = false;
	    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
	      value = true;
	    }
	  }
	  // check default value
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop, key);
	    // since the default value is a fresh copy,
	    // make sure to observe it.
	    var prevShouldConvert = observerState.shouldConvert;
	    observerState.shouldConvert = true;
	    observe(value);
	    observerState.shouldConvert = prevShouldConvert;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    assertProp(prop, key, value, vm, absent);
	  }
	  return value;
	}
	
	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue(vm, prop, key) {
	  // no default, return undefined
	  if (!hasOwn(prop, 'default')) {
	    return undefined;
	  }
	  var def = prop.default;
	  // warn against non-factory defaults for Object & Array
	  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
	    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // the raw prop value was also undefined from previous render,
	  // return previous default value to avoid unnecessary watcher trigger
	  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
	    return vm._props[key];
	  }
	  // call factory function for non-Function types
	  // a value is Function if its prototype is function even across different execution context
	  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp(prop, name, value, vm, absent) {
	  if (prop.required && absent) {
	    warn('Missing required prop: "' + name + '"', vm);
	    return;
	  }
	  if (value == null && !prop.required) {
	    return;
	  }
	  var type = prop.type;
	  var valid = !type || type === true;
	  var expectedTypes = [];
	  if (type) {
	    if (!Array.isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType || '');
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
	    return;
	  }
	  var validator = prop.validator;
	  if (validator) {
	    if (!validator(value)) {
	      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
	    }
	  }
	}
	
	var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
	
	function assertType(value, type) {
	  var valid;
	  var expectedType = getType(type);
	  if (simpleCheckRE.test(expectedType)) {
	    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();
	  } else if (expectedType === 'Object') {
	    valid = isPlainObject(value);
	  } else if (expectedType === 'Array') {
	    valid = Array.isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType(fn) {
	  var match = fn && fn.toString().match(/^\s*function (\w+)/);
	  return match ? match[1] : '';
	}
	
	function isType(type, fn) {
	  if (!Array.isArray(fn)) {
	    return getType(fn) === getType(type);
	  }
	  for (var i = 0, len = fn.length; i < len; i++) {
	    if (getType(fn[i]) === getType(type)) {
	      return true;
	    }
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	/*  */
	
	var mark;
	var measure;
	
	if (process.env.NODE_ENV !== 'production') {
	  var perf = inBrowser && window.performance;
	  /* istanbul ignore if */
	  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
	    mark = function mark(tag) {
	      return perf.mark(tag);
	    };
	    measure = function measure(name, startTag, endTag) {
	      perf.measure(name, startTag, endTag);
	      perf.clearMarks(startTag);
	      perf.clearMarks(endTag);
	      perf.clearMeasures(name);
	    };
	  }
	}
	
	/* not type checking this file because flow doesn't play well with Proxy */
	
	var initProxy;
	
	if (process.env.NODE_ENV !== 'production') {
	  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
	  );
	
	  var warnNonPresent = function warnNonPresent(target, key) {
	    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
	  };
	
	  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);
	
	  if (hasProxy) {
	    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
	    config.keyCodes = new Proxy(config.keyCodes, {
	      set: function set(target, key, value) {
	        if (isBuiltInModifier(key)) {
	          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
	          return false;
	        } else {
	          target[key] = value;
	          return true;
	        }
	      }
	    });
	  }
	
	  var hasHandler = {
	    has: function has(target, key) {
	      var has = key in target;
	      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
	      if (!has && !isAllowed) {
	        warnNonPresent(target, key);
	      }
	      return has || !isAllowed;
	    }
	  };
	
	  var getHandler = {
	    get: function get(target, key) {
	      if (typeof key === 'string' && !(key in target)) {
	        warnNonPresent(target, key);
	      }
	      return target[key];
	    }
	  };
	
	  initProxy = function initProxy(vm) {
	    if (hasProxy) {
	      // determine which proxy handler to use
	      var options = vm.$options;
	      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
	      vm._renderProxy = new Proxy(vm, handlers);
	    } else {
	      vm._renderProxy = vm;
	    }
	  };
	}
	
	/*  */
	
	var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
	  this.tag = tag;
	  this.data = data;
	  this.children = children;
	  this.text = text;
	  this.elm = elm;
	  this.ns = undefined;
	  this.context = context;
	  this.functionalContext = undefined;
	  this.key = data && data.key;
	  this.componentOptions = componentOptions;
	  this.componentInstance = undefined;
	  this.parent = undefined;
	  this.raw = false;
	  this.isStatic = false;
	  this.isRootInsert = true;
	  this.isComment = false;
	  this.isCloned = false;
	  this.isOnce = false;
	  this.asyncFactory = asyncFactory;
	  this.asyncMeta = undefined;
	  this.isAsyncPlaceholder = false;
	};
	
	var prototypeAccessors = { child: {} };
	
	// DEPRECATED: alias for componentInstance for backwards compat.
	/* istanbul ignore next */
	prototypeAccessors.child.get = function () {
	  return this.componentInstance;
	};
	
	Object.defineProperties(VNode.prototype, prototypeAccessors);
	
	var createEmptyVNode = function createEmptyVNode(text) {
	  if (text === void 0) text = '';
	
	  var node = new VNode();
	  node.text = text;
	  node.isComment = true;
	  return node;
	};
	
	function createTextVNode(val) {
	  return new VNode(undefined, undefined, undefined, String(val));
	}
	
	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode(vnode) {
	  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
	  cloned.ns = vnode.ns;
	  cloned.isStatic = vnode.isStatic;
	  cloned.key = vnode.key;
	  cloned.isComment = vnode.isComment;
	  cloned.isCloned = true;
	  return cloned;
	}
	
	function cloneVNodes(vnodes) {
	  var len = vnodes.length;
	  var res = new Array(len);
	  for (var i = 0; i < len; i++) {
	    res[i] = cloneVNode(vnodes[i]);
	  }
	  return res;
	}
	
	/*  */
	
	var normalizeEvent = cached(function (name) {
	  var passive = name.charAt(0) === '&';
	  name = passive ? name.slice(1) : name;
	  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
	  name = once$$1 ? name.slice(1) : name;
	  var capture = name.charAt(0) === '!';
	  name = capture ? name.slice(1) : name;
	  return {
	    name: name,
	    once: once$$1,
	    capture: capture,
	    passive: passive
	  };
	});
	
	function createFnInvoker(fns) {
	  function invoker() {
	    var arguments$1 = arguments;
	
	    var fns = invoker.fns;
	    if (Array.isArray(fns)) {
	      var cloned = fns.slice();
	      for (var i = 0; i < cloned.length; i++) {
	        cloned[i].apply(null, arguments$1);
	      }
	    } else {
	      // return handler return value for single handlers
	      return fns.apply(null, arguments);
	    }
	  }
	  invoker.fns = fns;
	  return invoker;
	}
	
	function updateListeners(on, oldOn, add, remove$$1, vm) {
	  var name, cur, old, event;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    event = normalizeEvent(name);
	    if (isUndef(cur)) {
	      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
	    } else if (isUndef(old)) {
	      if (isUndef(cur.fns)) {
	        cur = on[name] = createFnInvoker(cur);
	      }
	      add(event.name, cur, event.once, event.capture, event.passive);
	    } else if (cur !== old) {
	      old.fns = cur;
	      on[name] = old;
	    }
	  }
	  for (name in oldOn) {
	    if (isUndef(on[name])) {
	      event = normalizeEvent(name);
	      remove$$1(event.name, oldOn[name], event.capture);
	    }
	  }
	}
	
	/*  */
	
	function mergeVNodeHook(def, hookKey, hook) {
	  var invoker;
	  var oldHook = def[hookKey];
	
	  function wrappedHook() {
	    hook.apply(this, arguments);
	    // important: remove merged hook to ensure it's called only once
	    // and prevent memory leak
	    remove(invoker.fns, wrappedHook);
	  }
	
	  if (isUndef(oldHook)) {
	    // no existing hook
	    invoker = createFnInvoker([wrappedHook]);
	  } else {
	    /* istanbul ignore if */
	    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
	      // already a merged invoker
	      invoker = oldHook;
	      invoker.fns.push(wrappedHook);
	    } else {
	      // existing plain hook
	      invoker = createFnInvoker([oldHook, wrappedHook]);
	    }
	  }
	
	  invoker.merged = true;
	  def[hookKey] = invoker;
	}
	
	/*  */
	
	function extractPropsFromVNodeData(data, Ctor, tag) {
	  // we are only extracting raw values here.
	  // validation and default values are handled in the child
	  // component itself.
	  var propOptions = Ctor.options.props;
	  if (isUndef(propOptions)) {
	    return;
	  }
	  var res = {};
	  var attrs = data.attrs;
	  var props = data.props;
	  if (isDef(attrs) || isDef(props)) {
	    for (var key in propOptions) {
	      var altKey = hyphenate(key);
	      if (process.env.NODE_ENV !== 'production') {
	        var keyInLowerCase = key.toLowerCase();
	        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
	          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
	        }
	      }
	      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
	    }
	  }
	  return res;
	}
	
	function checkProp(res, hash, key, altKey, preserve) {
	  if (isDef(hash)) {
	    if (hasOwn(hash, key)) {
	      res[key] = hash[key];
	      if (!preserve) {
	        delete hash[key];
	      }
	      return true;
	    } else if (hasOwn(hash, altKey)) {
	      res[key] = hash[altKey];
	      if (!preserve) {
	        delete hash[altKey];
	      }
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	// The template compiler attempts to minimize the need for normalization by
	// statically analyzing the template at compile time.
	//
	// For plain HTML markup, normalization can be completely skipped because the
	// generated render function is guaranteed to return Array<VNode>. There are
	// two cases where extra normalization is needed:
	
	// 1. When the children contains components - because a functional component
	// may return an Array instead of a single root. In this case, just a simple
	// normalization is needed - if any child is an Array, we flatten the whole
	// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
	// because functional components already normalize their own children.
	function simpleNormalizeChildren(children) {
	  for (var i = 0; i < children.length; i++) {
	    if (Array.isArray(children[i])) {
	      return Array.prototype.concat.apply([], children);
	    }
	  }
	  return children;
	}
	
	// 2. When the children contains constructs that always generated nested Arrays,
	// e.g. <template>, <slot>, v-for, or when the children is provided by user
	// with hand-written render functions / JSX. In such cases a full normalization
	// is needed to cater to all possible types of children values.
	function normalizeChildren(children) {
	  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
	}
	
	function isTextNode(node) {
	  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
	}
	
	function normalizeArrayChildren(children, nestedIndex) {
	  var res = [];
	  var i, c, last;
	  for (i = 0; i < children.length; i++) {
	    c = children[i];
	    if (isUndef(c) || typeof c === 'boolean') {
	      continue;
	    }
	    last = res[res.length - 1];
	    //  nested
	    if (Array.isArray(c)) {
	      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
	    } else if (isPrimitive(c)) {
	      if (isTextNode(last)) {
	        // merge adjacent text nodes
	        // this is necessary for SSR hydration because text nodes are
	        // essentially merged when rendered to HTML strings
	        last.text += String(c);
	      } else if (c !== '') {
	        // convert primitive to vnode
	        res.push(createTextVNode(c));
	      }
	    } else {
	      if (isTextNode(c) && isTextNode(last)) {
	        // merge adjacent text nodes
	        res[res.length - 1] = createTextVNode(last.text + c.text);
	      } else {
	        // default key for nested array children (likely generated by v-for)
	        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
	          c.key = "__vlist" + nestedIndex + "_" + i + "__";
	        }
	        res.push(c);
	      }
	    }
	  }
	  return res;
	}
	
	/*  */
	
	function ensureCtor(comp, base) {
	  if (comp.__esModule && comp.default) {
	    comp = comp.default;
	  }
	  return isObject(comp) ? base.extend(comp) : comp;
	}
	
	function createAsyncPlaceholder(factory, data, context, children, tag) {
	  var node = createEmptyVNode();
	  node.asyncFactory = factory;
	  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
	  return node;
	}
	
	function resolveAsyncComponent(factory, baseCtor, context) {
	  if (isTrue(factory.error) && isDef(factory.errorComp)) {
	    return factory.errorComp;
	  }
	
	  if (isDef(factory.resolved)) {
	    return factory.resolved;
	  }
	
	  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
	    return factory.loadingComp;
	  }
	
	  if (isDef(factory.contexts)) {
	    // already pending
	    factory.contexts.push(context);
	  } else {
	    var contexts = factory.contexts = [context];
	    var sync = true;
	
	    var forceRender = function forceRender() {
	      for (var i = 0, l = contexts.length; i < l; i++) {
	        contexts[i].$forceUpdate();
	      }
	    };
	
	    var resolve = once(function (res) {
	      // cache resolved
	      factory.resolved = ensureCtor(res, baseCtor);
	      // invoke callbacks only if this is not a synchronous resolve
	      // (async resolves are shimmed as synchronous during SSR)
	      if (!sync) {
	        forceRender();
	      }
	    });
	
	    var reject = once(function (reason) {
	      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
	      if (isDef(factory.errorComp)) {
	        factory.error = true;
	        forceRender();
	      }
	    });
	
	    var res = factory(resolve, reject);
	
	    if (isObject(res)) {
	      if (typeof res.then === 'function') {
	        // () => Promise
	        if (isUndef(factory.resolved)) {
	          res.then(resolve, reject);
	        }
	      } else if (isDef(res.component) && typeof res.component.then === 'function') {
	        res.component.then(resolve, reject);
	
	        if (isDef(res.error)) {
	          factory.errorComp = ensureCtor(res.error, baseCtor);
	        }
	
	        if (isDef(res.loading)) {
	          factory.loadingComp = ensureCtor(res.loading, baseCtor);
	          if (res.delay === 0) {
	            factory.loading = true;
	          } else {
	            setTimeout(function () {
	              if (isUndef(factory.resolved) && isUndef(factory.error)) {
	                factory.loading = true;
	                forceRender();
	              }
	            }, res.delay || 200);
	          }
	        }
	
	        if (isDef(res.timeout)) {
	          setTimeout(function () {
	            if (isUndef(factory.resolved)) {
	              reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
	            }
	          }, res.timeout);
	        }
	      }
	    }
	
	    sync = false;
	    // return in case resolved synchronously
	    return factory.loading ? factory.loadingComp : factory.resolved;
	  }
	}
	
	/*  */
	
	function getFirstComponentChild(children) {
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      var c = children[i];
	      if (isDef(c) && isDef(c.componentOptions)) {
	        return c;
	      }
	    }
	  }
	}
	
	/*  */
	
	/*  */
	
	function initEvents(vm) {
	  vm._events = Object.create(null);
	  vm._hasHookEvent = false;
	  // init parent attached events
	  var listeners = vm.$options._parentListeners;
	  if (listeners) {
	    updateComponentListeners(vm, listeners);
	  }
	}
	
	var target;
	
	function add(event, fn, once$$1) {
	  if (once$$1) {
	    target.$once(event, fn);
	  } else {
	    target.$on(event, fn);
	  }
	}
	
	function remove$1(event, fn) {
	  target.$off(event, fn);
	}
	
	function updateComponentListeners(vm, listeners, oldListeners) {
	  target = vm;
	  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
	}
	
	function eventsMixin(Vue) {
	  var hookRE = /^hook:/;
	  Vue.prototype.$on = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    if (Array.isArray(event)) {
	      for (var i = 0, l = event.length; i < l; i++) {
	        this$1.$on(event[i], fn);
	      }
	    } else {
	      (vm._events[event] || (vm._events[event] = [])).push(fn);
	      // optimize hook:event cost by using a boolean flag marked at registration
	      // instead of a hash lookup
	      if (hookRE.test(event)) {
	        vm._hasHookEvent = true;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$once = function (event, fn) {
	    var vm = this;
	    function on() {
	      vm.$off(event, on);
	      fn.apply(vm, arguments);
	    }
	    on.fn = fn;
	    vm.$on(event, on);
	    return vm;
	  };
	
	  Vue.prototype.$off = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    // all
	    if (!arguments.length) {
	      vm._events = Object.create(null);
	      return vm;
	    }
	    // array of events
	    if (Array.isArray(event)) {
	      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
	        this$1.$off(event[i$1], fn);
	      }
	      return vm;
	    }
	    // specific event
	    var cbs = vm._events[event];
	    if (!cbs) {
	      return vm;
	    }
	    if (arguments.length === 1) {
	      vm._events[event] = null;
	      return vm;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$emit = function (event) {
	    var vm = this;
	    if (process.env.NODE_ENV !== 'production') {
	      var lowerCaseEvent = event.toLowerCase();
	      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
	        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
	      }
	    }
	    var cbs = vm._events[event];
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        try {
	          cbs[i].apply(vm, args);
	        } catch (e) {
	          handleError(e, vm, "event handler for \"" + event + "\"");
	        }
	      }
	    }
	    return vm;
	  };
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving raw children VNodes into a slot object.
	 */
	function resolveSlots(children, context) {
	  var slots = {};
	  if (!children) {
	    return slots;
	  }
	  var defaultSlot = [];
	  for (var i = 0, l = children.length; i < l; i++) {
	    var child = children[i];
	    // named slots should only be respected if the vnode was rendered in the
	    // same context.
	    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {
	      var name = child.data.slot;
	      var slot = slots[name] || (slots[name] = []);
	      if (child.tag === 'template') {
	        slot.push.apply(slot, child.children);
	      } else {
	        slot.push(child);
	      }
	    } else {
	      defaultSlot.push(child);
	    }
	  }
	  // ignore whitespace
	  if (!defaultSlot.every(isWhitespace)) {
	    slots.default = defaultSlot;
	  }
	  return slots;
	}
	
	function isWhitespace(node) {
	  return node.isComment || node.text === ' ';
	}
	
	function resolveScopedSlots(fns, // see flow/vnode
	res) {
	  res = res || {};
	  for (var i = 0; i < fns.length; i++) {
	    if (Array.isArray(fns[i])) {
	      resolveScopedSlots(fns[i], res);
	    } else {
	      res[fns[i].key] = fns[i].fn;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var activeInstance = null;
	var isUpdatingChildComponent = false;
	
	function initLifecycle(vm) {
	  var options = vm.$options;
	
	  // locate first non-abstract parent
	  var parent = options.parent;
	  if (parent && !options.abstract) {
	    while (parent.$options.abstract && parent.$parent) {
	      parent = parent.$parent;
	    }
	    parent.$children.push(vm);
	  }
	
	  vm.$parent = parent;
	  vm.$root = parent ? parent.$root : vm;
	
	  vm.$children = [];
	  vm.$refs = {};
	
	  vm._watcher = null;
	  vm._inactive = null;
	  vm._directInactive = false;
	  vm._isMounted = false;
	  vm._isDestroyed = false;
	  vm._isBeingDestroyed = false;
	}
	
	function lifecycleMixin(Vue) {
	  Vue.prototype._update = function (vnode, hydrating) {
	    var vm = this;
	    if (vm._isMounted) {
	      callHook(vm, 'beforeUpdate');
	    }
	    var prevEl = vm.$el;
	    var prevVnode = vm._vnode;
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    vm._vnode = vnode;
	    // Vue.prototype.__patch__ is injected in entry points
	    // based on the rendering backend used.
	    if (!prevVnode) {
	      // initial render
	      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
	      , vm.$options._parentElm, vm.$options._refElm);
	      // no need for the ref nodes after initial patch
	      // this prevents keeping a detached DOM tree in memory (#5851)
	      vm.$options._parentElm = vm.$options._refElm = null;
	    } else {
	      // updates
	      vm.$el = vm.__patch__(prevVnode, vnode);
	    }
	    activeInstance = prevActiveInstance;
	    // update __vue__ reference
	    if (prevEl) {
	      prevEl.__vue__ = null;
	    }
	    if (vm.$el) {
	      vm.$el.__vue__ = vm;
	    }
	    // if parent is an HOC, update its $el as well
	    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	      vm.$parent.$el = vm.$el;
	    }
	    // updated hook is called by the scheduler to ensure that children are
	    // updated in a parent's updated hook.
	  };
	
	  Vue.prototype.$forceUpdate = function () {
	    var vm = this;
	    if (vm._watcher) {
	      vm._watcher.update();
	    }
	  };
	
	  Vue.prototype.$destroy = function () {
	    var vm = this;
	    if (vm._isBeingDestroyed) {
	      return;
	    }
	    callHook(vm, 'beforeDestroy');
	    vm._isBeingDestroyed = true;
	    // remove self from parent
	    var parent = vm.$parent;
	    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	      remove(parent.$children, vm);
	    }
	    // teardown watchers
	    if (vm._watcher) {
	      vm._watcher.teardown();
	    }
	    var i = vm._watchers.length;
	    while (i--) {
	      vm._watchers[i].teardown();
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (vm._data.__ob__) {
	      vm._data.__ob__.vmCount--;
	    }
	    // call the last hook...
	    vm._isDestroyed = true;
	    // invoke destroy hooks on current rendered tree
	    vm.__patch__(vm._vnode, null);
	    // fire destroyed hook
	    callHook(vm, 'destroyed');
	    // turn off all instance listeners.
	    vm.$off();
	    // remove __vue__ reference
	    if (vm.$el) {
	      vm.$el.__vue__ = null;
	    }
	  };
	}
	
	function mountComponent(vm, el, hydrating) {
	  vm.$el = el;
	  if (!vm.$options.render) {
	    vm.$options.render = createEmptyVNode;
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
	        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
	      } else {
	        warn('Failed to mount component: template or render function not defined.', vm);
	      }
	    }
	  }
	  callHook(vm, 'beforeMount');
	
	  var updateComponent;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	    updateComponent = function updateComponent() {
	      var name = vm._name;
	      var id = vm._uid;
	      var startTag = "vue-perf-start:" + id;
	      var endTag = "vue-perf-end:" + id;
	
	      mark(startTag);
	      var vnode = vm._render();
	      mark(endTag);
	      measure(name + " render", startTag, endTag);
	
	      mark(startTag);
	      vm._update(vnode, hydrating);
	      mark(endTag);
	      measure(name + " patch", startTag, endTag);
	    };
	  } else {
	    updateComponent = function updateComponent() {
	      vm._update(vm._render(), hydrating);
	    };
	  }
	
	  vm._watcher = new Watcher(vm, updateComponent, noop);
	  hydrating = false;
	
	  // manually mounted instance, call mounted on self
	  // mounted is called for render-created child components in its inserted hook
	  if (vm.$vnode == null) {
	    vm._isMounted = true;
	    callHook(vm, 'mounted');
	  }
	  return vm;
	}
	
	function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = true;
	  }
	
	  // determine whether component has slot children
	  // we need to do this before overwriting $options._renderChildren
	  var hasChildren = !!(renderChildren || // has new static slots
	  vm.$options._renderChildren || // has old static slots
	  parentVnode.data.scopedSlots || // has new scoped slots
	  vm.$scopedSlots !== emptyObject // has old scoped slots
	  );
	
	  vm.$options._parentVnode = parentVnode;
	  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
	
	  if (vm._vnode) {
	    // update child tree's parent
	    vm._vnode.parent = parentVnode;
	  }
	  vm.$options._renderChildren = renderChildren;
	
	  // update $attrs and $listensers hash
	  // these are also reactive so they may trigger child update if the child
	  // used them during render
	  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
	  vm.$listeners = listeners;
	
	  // update props
	  if (propsData && vm.$options.props) {
	    observerState.shouldConvert = false;
	    var props = vm._props;
	    var propKeys = vm.$options._propKeys || [];
	    for (var i = 0; i < propKeys.length; i++) {
	      var key = propKeys[i];
	      props[key] = validateProp(key, vm.$options.props, propsData, vm);
	    }
	    observerState.shouldConvert = true;
	    // keep a copy of raw propsData
	    vm.$options.propsData = propsData;
	  }
	
	  // update listeners
	  if (listeners) {
	    var oldListeners = vm.$options._parentListeners;
	    vm.$options._parentListeners = listeners;
	    updateComponentListeners(vm, listeners, oldListeners);
	  }
	  // resolve slots + force update if has children
	  if (hasChildren) {
	    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
	    vm.$forceUpdate();
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    isUpdatingChildComponent = false;
	  }
	}
	
	function isInInactiveTree(vm) {
	  while (vm && (vm = vm.$parent)) {
	    if (vm._inactive) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function activateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = false;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  } else if (vm._directInactive) {
	    return;
	  }
	  if (vm._inactive || vm._inactive === null) {
	    vm._inactive = false;
	    for (var i = 0; i < vm.$children.length; i++) {
	      activateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'activated');
	  }
	}
	
	function deactivateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = true;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  }
	  if (!vm._inactive) {
	    vm._inactive = true;
	    for (var i = 0; i < vm.$children.length; i++) {
	      deactivateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'deactivated');
	  }
	}
	
	function callHook(vm, hook) {
	  var handlers = vm.$options[hook];
	  if (handlers) {
	    for (var i = 0, j = handlers.length; i < j; i++) {
	      try {
	        handlers[i].call(vm);
	      } catch (e) {
	        handleError(e, vm, hook + " hook");
	      }
	    }
	  }
	  if (vm._hasHookEvent) {
	    vm.$emit('hook:' + hook);
	  }
	}
	
	/*  */
	
	var MAX_UPDATE_COUNT = 100;
	
	var queue = [];
	var activatedChildren = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;
	
	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState() {
	  index = queue.length = activatedChildren.length = 0;
	  has = {};
	  if (process.env.NODE_ENV !== 'production') {
	    circular = {};
	  }
	  waiting = flushing = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue() {
	  flushing = true;
	  var watcher, id;
	
	  // Sort queue before flush.
	  // This ensures that:
	  // 1. Components are updated from parent to child. (because parent is always
	  //    created before the child)
	  // 2. A component's user watchers are run before its render watcher (because
	  //    user watchers are created before the render watcher)
	  // 3. If a component is destroyed during a parent component's watcher run,
	  //    its watchers can be skipped.
	  queue.sort(function (a, b) {
	    return a.id - b.id;
	  });
	
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (index = 0; index < queue.length; index++) {
	    watcher = queue[index];
	    id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > MAX_UPDATE_COUNT) {
	        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
	        break;
	      }
	    }
	  }
	
	  // keep copies of post queues before resetting state
	  var activatedQueue = activatedChildren.slice();
	  var updatedQueue = queue.slice();
	
	  resetSchedulerState();
	
	  // call component updated and activated hooks
	  callActivatedHooks(activatedQueue);
	  callUpdatedHooks(updatedQueue);
	
	  // devtool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }
	}
	
	function callUpdatedHooks(queue) {
	  var i = queue.length;
	  while (i--) {
	    var watcher = queue[i];
	    var vm = watcher.vm;
	    if (vm._watcher === watcher && vm._isMounted) {
	      callHook(vm, 'updated');
	    }
	  }
	}
	
	/**
	 * Queue a kept-alive component that was activated during patch.
	 * The queue will be processed after the entire tree has been patched.
	 */
	function queueActivatedComponent(vm) {
	  // setting _inactive to false here so that a render function can
	  // rely on checking whether it's in an inactive tree (e.g. router-view)
	  vm._inactive = false;
	  activatedChildren.push(vm);
	}
	
	function callActivatedHooks(queue) {
	  for (var i = 0; i < queue.length; i++) {
	    queue[i]._inactive = true;
	    activateChildComponent(queue[i], true /* true */);
	  }
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    has[id] = true;
	    if (!flushing) {
	      queue.push(watcher);
	    } else {
	      // if already flushing, splice the watcher based on its id
	      // if already past its id, it will be run next immediately.
	      var i = queue.length - 1;
	      while (i > index && queue[i].id > watcher.id) {
	        i--;
	      }
	      queue.splice(i + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushSchedulerQueue);
	    }
	  }
	}
	
	/*  */
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 */
	var Watcher = function Watcher(vm, expOrFn, cb, options) {
	  this.vm = vm;
	  vm._watchers.push(this);
	  // options
	  if (options) {
	    this.deep = !!options.deep;
	    this.user = !!options.user;
	    this.lazy = !!options.lazy;
	    this.sync = !!options.sync;
	  } else {
	    this.deep = this.user = this.lazy = this.sync = false;
	  }
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
	  // parse expression for getter
	  if (typeof expOrFn === 'function') {
	    this.getter = expOrFn;
	  } else {
	    this.getter = parsePath(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
	    }
	  }
	  this.value = this.lazy ? undefined : this.get();
	};
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	Watcher.prototype.get = function get() {
	  pushTarget(this);
	  var value;
	  var vm = this.vm;
	  try {
	    value = this.getter.call(vm, vm);
	  } catch (e) {
	    if (this.user) {
	      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
	    } else {
	      throw e;
	    }
	  } finally {
	    // "touch" every property so they are all tracked as
	    // dependencies for deep watching
	    if (this.deep) {
	      traverse(value);
	    }
	    popTarget();
	    this.cleanupDeps();
	  }
	  return value;
	};
	
	/**
	 * Add a dependency to this directive.
	 */
	Watcher.prototype.addDep = function addDep(dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	Watcher.prototype.cleanupDeps = function cleanupDeps() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this$1.deps[i];
	    if (!this$1.newDepIds.has(dep.id)) {
	      dep.removeSub(this$1);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 */
	Watcher.prototype.update = function update() {
	  /* istanbul ignore else */
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync) {
	    this.run();
	  } else {
	    queueWatcher(this);
	  }
	};
	
	/**
	 * Scheduler job interface.
	 * Will be called by the scheduler.
	 */
	Watcher.prototype.run = function run() {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated.
	    isObject(value) || this.deep) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      if (this.user) {
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	Watcher.prototype.evaluate = function evaluate() {
	  this.value = this.get();
	  this.dirty = false;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	Watcher.prototype.depend = function depend() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    this$1.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subscriber list.
	 */
	Watcher.prototype.teardown = function teardown() {
	  var this$1 = this;
	
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed.
	    if (!this.vm._isBeingDestroyed) {
	      remove(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this$1.deps[i].removeSub(this$1);
	    }
	    this.active = false;
	  }
	};
	
	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	var seenObjects = new _Set();
	function traverse(val) {
	  seenObjects.clear();
	  _traverse(val, seenObjects);
	}
	
	function _traverse(val, seen) {
	  var i, keys;
	  var isA = Array.isArray(val);
	  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
	    return;
	  }
	  if (val.__ob__) {
	    var depId = val.__ob__.dep.id;
	    if (seen.has(depId)) {
	      return;
	    }
	    seen.add(depId);
	  }
	  if (isA) {
	    i = val.length;
	    while (i--) {
	      _traverse(val[i], seen);
	    }
	  } else {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      _traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	/*  */
	
	var sharedPropertyDefinition = {
	  enumerable: true,
	  configurable: true,
	  get: noop,
	  set: noop
	};
	
	function proxy(target, sourceKey, key) {
	  sharedPropertyDefinition.get = function proxyGetter() {
	    return this[sourceKey][key];
	  };
	  sharedPropertyDefinition.set = function proxySetter(val) {
	    this[sourceKey][key] = val;
	  };
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function initState(vm) {
	  vm._watchers = [];
	  var opts = vm.$options;
	  if (opts.props) {
	    initProps(vm, opts.props);
	  }
	  if (opts.methods) {
	    initMethods(vm, opts.methods);
	  }
	  if (opts.data) {
	    initData(vm);
	  } else {
	    observe(vm._data = {}, true /* asRootData */);
	  }
	  if (opts.computed) {
	    initComputed(vm, opts.computed);
	  }
	  if (opts.watch && opts.watch !== nativeWatch) {
	    initWatch(vm, opts.watch);
	  }
	}
	
	function checkOptionType(vm, name) {
	  var option = vm.$options[name];
	  if (!isPlainObject(option)) {
	    warn("component option \"" + name + "\" should be an object.", vm);
	  }
	}
	
	function initProps(vm, propsOptions) {
	  var propsData = vm.$options.propsData || {};
	  var props = vm._props = {};
	  // cache prop keys so that future props updates can iterate using Array
	  // instead of dynamic object key enumeration.
	  var keys = vm.$options._propKeys = [];
	  var isRoot = !vm.$parent;
	  // root instance props should be converted
	  observerState.shouldConvert = isRoot;
	  var loop = function loop(key) {
	    keys.push(key);
	    var value = validateProp(key, propsOptions, propsData, vm);
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
	        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
	      }
	      defineReactive$$1(props, key, value, function () {
	        if (vm.$parent && !isUpdatingChildComponent) {
	          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
	        }
	      });
	    } else {
	      defineReactive$$1(props, key, value);
	    }
	    // static props are already proxied on the component's prototype
	    // during Vue.extend(). We only need to proxy props defined at
	    // instantiation here.
	    if (!(key in vm)) {
	      proxy(vm, "_props", key);
	    }
	  };
	
	  for (var key in propsOptions) {
	    loop(key);
	  }observerState.shouldConvert = true;
	}
	
	function initData(vm) {
	  var data = vm.$options.data;
	  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
	  if (!isPlainObject(data)) {
	    data = {};
	    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var props = vm.$options.props;
	  var methods = vm.$options.methods;
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods && hasOwn(methods, key)) {
	        warn("method \"" + key + "\" has already been defined as a data property.", vm);
	      }
	    }
	    if (props && hasOwn(props, key)) {
	      process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
	    } else if (!isReserved(key)) {
	      proxy(vm, "_data", key);
	    }
	  }
	  // observe data
	  observe(data, true /* asRootData */);
	}
	
	function getData(data, vm) {
	  try {
	    return data.call(vm);
	  } catch (e) {
	    handleError(e, vm, "data()");
	    return {};
	  }
	}
	
	var computedWatcherOptions = { lazy: true };
	
	function initComputed(vm, computed) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');
	  var watchers = vm._computedWatchers = Object.create(null);
	
	  for (var key in computed) {
	    var userDef = computed[key];
	    var getter = typeof userDef === 'function' ? userDef : userDef.get;
	    if (process.env.NODE_ENV !== 'production' && getter == null) {
	      warn("Getter is missing for computed property \"" + key + "\".", vm);
	    }
	    // create internal watcher for the computed property.
	    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
	
	    // component-defined computed properties are already defined on the
	    // component prototype. We only need to define computed properties defined
	    // at instantiation here.
	    if (!(key in vm)) {
	      defineComputed(vm, key, userDef);
	    } else if (process.env.NODE_ENV !== 'production') {
	      if (key in vm.$data) {
	        warn("The computed property \"" + key + "\" is already defined in data.", vm);
	      } else if (vm.$options.props && key in vm.$options.props) {
	        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function defineComputed(target, key, userDef) {
	  if (typeof userDef === 'function') {
	    sharedPropertyDefinition.get = createComputedGetter(key);
	    sharedPropertyDefinition.set = noop;
	  } else {
	    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
	    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
	  }
	  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
	    sharedPropertyDefinition.set = function () {
	      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
	    };
	  }
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function createComputedGetter(key) {
	  return function computedGetter() {
	    var watcher = this._computedWatchers && this._computedWatchers[key];
	    if (watcher) {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    }
	  };
	}
	
	function initMethods(vm, methods) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');
	  var props = vm.$options.props;
	  for (var key in methods) {
	    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods[key] == null) {
	        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
	      }
	      if (props && hasOwn(props, key)) {
	        warn("method \"" + key + "\" has already been defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function initWatch(vm, watch) {
	  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');
	  for (var key in watch) {
	    var handler = watch[key];
	    if (Array.isArray(handler)) {
	      for (var i = 0; i < handler.length; i++) {
	        createWatcher(vm, key, handler[i]);
	      }
	    } else {
	      createWatcher(vm, key, handler);
	    }
	  }
	}
	
	function createWatcher(vm, keyOrFn, handler, options) {
	  if (isPlainObject(handler)) {
	    options = handler;
	    handler = handler.handler;
	  }
	  if (typeof handler === 'string') {
	    handler = vm[handler];
	  }
	  return vm.$watch(keyOrFn, handler, options);
	}
	
	function stateMixin(Vue) {
	  // flow somehow has problems with directly declared definition object
	  // when using Object.defineProperty, so we have to procedurally build up
	  // the object here.
	  var dataDef = {};
	  dataDef.get = function () {
	    return this._data;
	  };
	  var propsDef = {};
	  propsDef.get = function () {
	    return this._props;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    dataDef.set = function (newData) {
	      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
	    };
	    propsDef.set = function () {
	      warn("$props is readonly.", this);
	    };
	  }
	  Object.defineProperty(Vue.prototype, '$data', dataDef);
	  Object.defineProperty(Vue.prototype, '$props', propsDef);
	
	  Vue.prototype.$set = set;
	  Vue.prototype.$delete = del;
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    if (isPlainObject(cb)) {
	      return createWatcher(vm, expOrFn, cb, options);
	    }
	    options = options || {};
	    options.user = true;
	    var watcher = new Watcher(vm, expOrFn, cb, options);
	    if (options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	}
	
	/*  */
	
	function initProvide(vm) {
	  var provide = vm.$options.provide;
	  if (provide) {
	    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
	  }
	}
	
	function initInjections(vm) {
	  var result = resolveInject(vm.$options.inject, vm);
	  if (result) {
	    observerState.shouldConvert = false;
	    Object.keys(result).forEach(function (key) {
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        defineReactive$$1(vm, key, result[key], function () {
	          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
	        });
	      } else {
	        defineReactive$$1(vm, key, result[key]);
	      }
	    });
	    observerState.shouldConvert = true;
	  }
	}
	
	function resolveInject(inject, vm) {
	  if (inject) {
	    // inject is :any because flow is not smart enough to figure out cached
	    var result = Object.create(null);
	    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
	
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var provideKey = inject[key];
	      var source = vm;
	      while (source) {
	        if (source._provided && provideKey in source._provided) {
	          result[key] = source._provided[provideKey];
	          break;
	        }
	        source = source.$parent;
	      }
	      if (process.env.NODE_ENV !== 'production' && !source) {
	        warn("Injection \"" + key + "\" not found", vm);
	      }
	    }
	    return result;
	  }
	}
	
	/*  */
	
	function createFunctionalComponent(Ctor, propsData, data, context, children) {
	  var props = {};
	  var propOptions = Ctor.options.props;
	  if (isDef(propOptions)) {
	    for (var key in propOptions) {
	      props[key] = validateProp(key, propOptions, propsData || {});
	    }
	  } else {
	    if (isDef(data.attrs)) {
	      mergeProps(props, data.attrs);
	    }
	    if (isDef(data.props)) {
	      mergeProps(props, data.props);
	    }
	  }
	  // ensure the createElement function in functional components
	  // gets a unique context - this is necessary for correct named slot check
	  var _context = Object.create(context);
	  var h = function h(a, b, c, d) {
	    return createElement(_context, a, b, c, d, true);
	  };
	  var vnode = Ctor.options.render.call(null, h, {
	    data: data,
	    props: props,
	    children: children,
	    parent: context,
	    listeners: data.on || {},
	    injections: resolveInject(Ctor.options.inject, context),
	    slots: function slots() {
	      return resolveSlots(children, context);
	    }
	  });
	  if (vnode instanceof VNode) {
	    vnode.functionalContext = context;
	    vnode.functionalOptions = Ctor.options;
	    if (data.slot) {
	      (vnode.data || (vnode.data = {})).slot = data.slot;
	    }
	  }
	  return vnode;
	}
	
	function mergeProps(to, from) {
	  for (var key in from) {
	    to[camelize(key)] = from[key];
	  }
	}
	
	/*  */
	
	// hooks to be invoked on component VNodes during patch
	var componentVNodeHooks = {
	  init: function init(vnode, hydrating, parentElm, refElm) {
	    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
	      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
	      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	    } else if (vnode.data.keepAlive) {
	      // kept-alive components, treat as a patch
	      var mountedNode = vnode; // work around flow
	      componentVNodeHooks.prepatch(mountedNode, mountedNode);
	    }
	  },
	
	  prepatch: function prepatch(oldVnode, vnode) {
	    var options = vnode.componentOptions;
	    var child = vnode.componentInstance = oldVnode.componentInstance;
	    updateChildComponent(child, options.propsData, // updated props
	    options.listeners, // updated listeners
	    vnode, // new parent vnode
	    options.children // new children
	    );
	  },
	
	  insert: function insert(vnode) {
	    var context = vnode.context;
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isMounted) {
	      componentInstance._isMounted = true;
	      callHook(componentInstance, 'mounted');
	    }
	    if (vnode.data.keepAlive) {
	      if (context._isMounted) {
	        // vue-router#1212
	        // During updates, a kept-alive component's child components may
	        // change, so directly walking the tree here may call activated hooks
	        // on incorrect children. Instead we push them into a queue which will
	        // be processed after the whole patch process ended.
	        queueActivatedComponent(componentInstance);
	      } else {
	        activateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  },
	
	  destroy: function destroy(vnode) {
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isDestroyed) {
	      if (!vnode.data.keepAlive) {
	        componentInstance.$destroy();
	      } else {
	        deactivateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  }
	};
	
	var hooksToMerge = Object.keys(componentVNodeHooks);
	
	function createComponent(Ctor, data, context, children, tag) {
	  if (isUndef(Ctor)) {
	    return;
	  }
	
	  var baseCtor = context.$options._base;
	
	  // plain options object: turn it into a constructor
	  if (isObject(Ctor)) {
	    Ctor = baseCtor.extend(Ctor);
	  }
	
	  // if at this stage it's not a constructor or an async component factory,
	  // reject.
	  if (typeof Ctor !== 'function') {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Invalid Component definition: " + String(Ctor), context);
	    }
	    return;
	  }
	
	  // async component
	  var asyncFactory;
	  if (isUndef(Ctor.cid)) {
	    asyncFactory = Ctor;
	    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
	    if (Ctor === undefined) {
	      // return a placeholder node for async component, which is rendered
	      // as a comment node but preserves all the raw information for the node.
	      // the information will be used for async server-rendering and hydration.
	      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
	    }
	  }
	
	  data = data || {};
	
	  // resolve constructor options in case global mixins are applied after
	  // component constructor creation
	  resolveConstructorOptions(Ctor);
	
	  // transform component v-model data into props & events
	  if (isDef(data.model)) {
	    transformModel(Ctor.options, data);
	  }
	
	  // extract props
	  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
	
	  // functional component
	  if (isTrue(Ctor.options.functional)) {
	    return createFunctionalComponent(Ctor, propsData, data, context, children);
	  }
	
	  // extract listeners, since these needs to be treated as
	  // child component listeners instead of DOM listeners
	  var listeners = data.on;
	  // replace with listeners with .native modifier
	  // so it gets processed during parent component patch.
	  data.on = data.nativeOn;
	
	  if (isTrue(Ctor.options.abstract)) {
	    // abstract components do not keep anything
	    // other than props & listeners & slot
	
	    // work around flow
	    var slot = data.slot;
	    data = {};
	    if (slot) {
	      data.slot = slot;
	    }
	  }
	
	  // merge component management hooks onto the placeholder node
	  mergeHooks(data);
	
	  // return a placeholder vnode
	  var name = Ctor.options.name || tag;
	  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
	  return vnode;
	}
	
	function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
	parent, // activeInstance in lifecycle state
	parentElm, refElm) {
	  var vnodeComponentOptions = vnode.componentOptions;
	  var options = {
	    _isComponent: true,
	    parent: parent,
	    propsData: vnodeComponentOptions.propsData,
	    _componentTag: vnodeComponentOptions.tag,
	    _parentVnode: vnode,
	    _parentListeners: vnodeComponentOptions.listeners,
	    _renderChildren: vnodeComponentOptions.children,
	    _parentElm: parentElm || null,
	    _refElm: refElm || null
	  };
	  // check inline-template render functions
	  var inlineTemplate = vnode.data.inlineTemplate;
	  if (isDef(inlineTemplate)) {
	    options.render = inlineTemplate.render;
	    options.staticRenderFns = inlineTemplate.staticRenderFns;
	  }
	  return new vnodeComponentOptions.Ctor(options);
	}
	
	function mergeHooks(data) {
	  if (!data.hook) {
	    data.hook = {};
	  }
	  for (var i = 0; i < hooksToMerge.length; i++) {
	    var key = hooksToMerge[i];
	    var fromParent = data.hook[key];
	    var ours = componentVNodeHooks[key];
	    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
	  }
	}
	
	function mergeHook$1(one, two) {
	  return function (a, b, c, d) {
	    one(a, b, c, d);
	    two(a, b, c, d);
	  };
	}
	
	// transform component v-model info (value and callback) into
	// prop and event handler respectively.
	function transformModel(options, data) {
	  var prop = options.model && options.model.prop || 'value';
	  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
	  var on = data.on || (data.on = {});
	  if (isDef(on[event])) {
	    on[event] = [data.model.callback].concat(on[event]);
	  } else {
	    on[event] = data.model.callback;
	  }
	}
	
	/*  */
	
	var SIMPLE_NORMALIZE = 1;
	var ALWAYS_NORMALIZE = 2;
	
	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
	  if (Array.isArray(data) || isPrimitive(data)) {
	    normalizationType = children;
	    children = data;
	    data = undefined;
	  }
	  if (isTrue(alwaysNormalize)) {
	    normalizationType = ALWAYS_NORMALIZE;
	  }
	  return _createElement(context, tag, data, children, normalizationType);
	}
	
	function _createElement(context, tag, data, children, normalizationType) {
	  if (isDef(data) && isDef(data.__ob__)) {
	    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
	    return createEmptyVNode();
	  }
	  // object syntax in v-bind
	  if (isDef(data) && isDef(data.is)) {
	    tag = data.is;
	  }
	  if (!tag) {
	    // in case of component :is set to falsy value
	    return createEmptyVNode();
	  }
	  // warn against non-primitive key
	  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
	    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
	  }
	  // support single function children as default scoped slot
	  if (Array.isArray(children) && typeof children[0] === 'function') {
	    data = data || {};
	    data.scopedSlots = { default: children[0] };
	    children.length = 0;
	  }
	  if (normalizationType === ALWAYS_NORMALIZE) {
	    children = normalizeChildren(children);
	  } else if (normalizationType === SIMPLE_NORMALIZE) {
	    children = simpleNormalizeChildren(children);
	  }
	  var vnode, ns;
	  if (typeof tag === 'string') {
	    var Ctor;
	    ns = config.getTagNamespace(tag);
	    if (config.isReservedTag(tag)) {
	      // platform built-in elements
	      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
	    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
	      // component
	      vnode = createComponent(Ctor, data, context, children, tag);
	    } else {
	      // unknown or unlisted namespaced elements
	      // check at runtime because it may get assigned a namespace when its
	      // parent normalizes children
	      vnode = new VNode(tag, data, children, undefined, undefined, context);
	    }
	  } else {
	    // direct component options / constructor
	    vnode = createComponent(tag, data, context, children);
	  }
	  if (isDef(vnode)) {
	    if (ns) {
	      applyNS(vnode, ns);
	    }
	    return vnode;
	  } else {
	    return createEmptyVNode();
	  }
	}
	
	function applyNS(vnode, ns) {
	  vnode.ns = ns;
	  if (vnode.tag === 'foreignObject') {
	    // use default namespace inside foreignObject
	    return;
	  }
	  if (isDef(vnode.children)) {
	    for (var i = 0, l = vnode.children.length; i < l; i++) {
	      var child = vnode.children[i];
	      if (isDef(child.tag) && isUndef(child.ns)) {
	        applyNS(child, ns);
	      }
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering v-for lists.
	 */
	function renderList(val, render) {
	  var ret, i, l, keys, key;
	  if (Array.isArray(val) || typeof val === 'string') {
	    ret = new Array(val.length);
	    for (i = 0, l = val.length; i < l; i++) {
	      ret[i] = render(val[i], i);
	    }
	  } else if (typeof val === 'number') {
	    ret = new Array(val);
	    for (i = 0; i < val; i++) {
	      ret[i] = render(i + 1, i);
	    }
	  } else if (isObject(val)) {
	    keys = Object.keys(val);
	    ret = new Array(keys.length);
	    for (i = 0, l = keys.length; i < l; i++) {
	      key = keys[i];
	      ret[i] = render(val[key], key, i);
	    }
	  }
	  if (isDef(ret)) {
	    ret._isVList = true;
	  }
	  return ret;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering <slot>
	 */
	function renderSlot(name, fallback, props, bindObject) {
	  var scopedSlotFn = this.$scopedSlots[name];
	  if (scopedSlotFn) {
	    // scoped slot
	    props = props || {};
	    if (bindObject) {
	      props = extend(extend({}, bindObject), props);
	    }
	    return scopedSlotFn(props) || fallback;
	  } else {
	    var slotNodes = this.$slots[name];
	    // warn duplicate slot usage
	    if (slotNodes && process.env.NODE_ENV !== 'production') {
	      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
	      slotNodes._rendered = true;
	    }
	    return slotNodes || fallback;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving filters
	 */
	function resolveFilter(id) {
	  return resolveAsset(this.$options, 'filters', id, true) || identity;
	}
	
	/*  */
	
	/**
	 * Runtime helper for checking keyCodes from config.
	 */
	function checkKeyCodes(eventKeyCode, key, builtInAlias) {
	  var keyCodes = config.keyCodes[key] || builtInAlias;
	  if (Array.isArray(keyCodes)) {
	    return keyCodes.indexOf(eventKeyCode) === -1;
	  } else {
	    return keyCodes !== eventKeyCode;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for merging v-bind="object" into a VNode's data.
	 */
	function bindObjectProps(data, tag, value, asProp, isSync) {
	  if (value) {
	    if (!isObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
	    } else {
	      if (Array.isArray(value)) {
	        value = toObject(value);
	      }
	      var hash;
	      var loop = function loop(key) {
	        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
	          hash = data;
	        } else {
	          var type = data.attrs && data.attrs.type;
	          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
	        }
	        if (!(key in hash)) {
	          hash[key] = value[key];
	
	          if (isSync) {
	            var on = data.on || (data.on = {});
	            on["update:" + key] = function ($event) {
	              value[key] = $event;
	            };
	          }
	        }
	      };
	
	      for (var key in value) {
	        loop(key);
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering static trees.
	 */
	function renderStatic(index, isInFor) {
	  var tree = this._staticTrees[index];
	  // if has already-rendered static tree and not inside v-for,
	  // we can reuse the same tree by doing a shallow clone.
	  if (tree && !isInFor) {
	    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
	  }
	  // otherwise, render a fresh tree.
	  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
	  markStatic(tree, "__static__" + index, false);
	  return tree;
	}
	
	/**
	 * Runtime helper for v-once.
	 * Effectively it means marking the node as static with a unique key.
	 */
	function markOnce(tree, index, key) {
	  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
	  return tree;
	}
	
	function markStatic(tree, key, isOnce) {
	  if (Array.isArray(tree)) {
	    for (var i = 0; i < tree.length; i++) {
	      if (tree[i] && typeof tree[i] !== 'string') {
	        markStaticNode(tree[i], key + "_" + i, isOnce);
	      }
	    }
	  } else {
	    markStaticNode(tree, key, isOnce);
	  }
	}
	
	function markStaticNode(node, key, isOnce) {
	  node.isStatic = true;
	  node.key = key;
	  node.isOnce = isOnce;
	}
	
	/*  */
	
	function bindObjectListeners(data, value) {
	  if (value) {
	    if (!isPlainObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
	    } else {
	      var on = data.on = data.on ? extend({}, data.on) : {};
	      for (var key in value) {
	        var existing = on[key];
	        var ours = value[key];
	        on[key] = existing ? [].concat(ours, existing) : ours;
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	function initRender(vm) {
	  vm._vnode = null; // the root of the child tree
	  vm._staticTrees = null;
	  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
	  var renderContext = parentVnode && parentVnode.context;
	  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
	  vm.$scopedSlots = emptyObject;
	  // bind the createElement fn to this instance
	  // so that we get proper render context inside it.
	  // args order: tag, data, children, normalizationType, alwaysNormalize
	  // internal version is used by render functions compiled from templates
	  vm._c = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, false);
	  };
	  // normalization is always applied for the public version, used in
	  // user-written render functions.
	  vm.$createElement = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, true);
	  };
	
	  // $attrs & $listeners are exposed for easier HOC creation.
	  // they need to be reactive so that HOCs using them are always updated
	  var parentData = parentVnode && parentVnode.data;
	  /* istanbul ignore else */
	  if (process.env.NODE_ENV !== 'production') {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
	      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
	    }, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
	      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
	    }, true);
	  } else {
	    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
	    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);
	  }
	}
	
	function renderMixin(Vue) {
	  Vue.prototype.$nextTick = function (fn) {
	    return nextTick(fn, this);
	  };
	
	  Vue.prototype._render = function () {
	    var vm = this;
	    var ref = vm.$options;
	    var render = ref.render;
	    var staticRenderFns = ref.staticRenderFns;
	    var _parentVnode = ref._parentVnode;
	
	    if (vm._isMounted) {
	      // clone slot nodes on re-renders
	      for (var key in vm.$slots) {
	        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
	      }
	    }
	
	    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;
	
	    if (staticRenderFns && !vm._staticTrees) {
	      vm._staticTrees = [];
	    }
	    // set parent vnode. this allows render functions to have access
	    // to the data on the placeholder node.
	    vm.$vnode = _parentVnode;
	    // render self
	    var vnode;
	    try {
	      vnode = render.call(vm._renderProxy, vm.$createElement);
	    } catch (e) {
	      handleError(e, vm, "render function");
	      // return error render result,
	      // or previous vnode to prevent render error causing blank component
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
	      } else {
	        vnode = vm._vnode;
	      }
	    }
	    // return empty vnode in case the render function errored out
	    if (!(vnode instanceof VNode)) {
	      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
	        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
	      }
	      vnode = createEmptyVNode();
	    }
	    // set parent
	    vnode.parent = _parentVnode;
	    return vnode;
	  };
	
	  // internal render helpers.
	  // these are exposed on the instance prototype to reduce generated render
	  // code size.
	  Vue.prototype._o = markOnce;
	  Vue.prototype._n = toNumber;
	  Vue.prototype._s = toString;
	  Vue.prototype._l = renderList;
	  Vue.prototype._t = renderSlot;
	  Vue.prototype._q = looseEqual;
	  Vue.prototype._i = looseIndexOf;
	  Vue.prototype._m = renderStatic;
	  Vue.prototype._f = resolveFilter;
	  Vue.prototype._k = checkKeyCodes;
	  Vue.prototype._b = bindObjectProps;
	  Vue.prototype._v = createTextVNode;
	  Vue.prototype._e = createEmptyVNode;
	  Vue.prototype._u = resolveScopedSlots;
	  Vue.prototype._g = bindObjectListeners;
	}
	
	/*  */
	
	var uid$1 = 0;
	
	function initMixin(Vue) {
	  Vue.prototype._init = function (options) {
	    var vm = this;
	    // a uid
	    vm._uid = uid$1++;
	
	    var startTag, endTag;
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      startTag = "vue-perf-init:" + vm._uid;
	      endTag = "vue-perf-end:" + vm._uid;
	      mark(startTag);
	    }
	
	    // a flag to avoid this being observed
	    vm._isVue = true;
	    // merge options
	    if (options && options._isComponent) {
	      // optimize internal component instantiation
	      // since dynamic options merging is pretty slow, and none of the
	      // internal component options needs special treatment.
	      initInternalComponent(vm, options);
	    } else {
	      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
	    }
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      initProxy(vm);
	    } else {
	      vm._renderProxy = vm;
	    }
	    // expose real self
	    vm._self = vm;
	    initLifecycle(vm);
	    initEvents(vm);
	    initRender(vm);
	    callHook(vm, 'beforeCreate');
	    initInjections(vm); // resolve injections before data/props
	    initState(vm);
	    initProvide(vm); // resolve provide after data/props
	    callHook(vm, 'created');
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      vm._name = formatComponentName(vm, false);
	      mark(endTag);
	      measure(vm._name + " init", startTag, endTag);
	    }
	
	    if (vm.$options.el) {
	      vm.$mount(vm.$options.el);
	    }
	  };
	}
	
	function initInternalComponent(vm, options) {
	  var opts = vm.$options = Object.create(vm.constructor.options);
	  // doing this because it's faster than dynamic enumeration.
	  opts.parent = options.parent;
	  opts.propsData = options.propsData;
	  opts._parentVnode = options._parentVnode;
	  opts._parentListeners = options._parentListeners;
	  opts._renderChildren = options._renderChildren;
	  opts._componentTag = options._componentTag;
	  opts._parentElm = options._parentElm;
	  opts._refElm = options._refElm;
	  if (options.render) {
	    opts.render = options.render;
	    opts.staticRenderFns = options.staticRenderFns;
	  }
	}
	
	function resolveConstructorOptions(Ctor) {
	  var options = Ctor.options;
	  if (Ctor.super) {
	    var superOptions = resolveConstructorOptions(Ctor.super);
	    var cachedSuperOptions = Ctor.superOptions;
	    if (superOptions !== cachedSuperOptions) {
	      // super option changed,
	      // need to resolve new options.
	      Ctor.superOptions = superOptions;
	      // check if there are any late-modified/attached options (#4976)
	      var modifiedOptions = resolveModifiedOptions(Ctor);
	      // update base extend options
	      if (modifiedOptions) {
	        extend(Ctor.extendOptions, modifiedOptions);
	      }
	      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
	      if (options.name) {
	        options.components[options.name] = Ctor;
	      }
	    }
	  }
	  return options;
	}
	
	function resolveModifiedOptions(Ctor) {
	  var modified;
	  var latest = Ctor.options;
	  var extended = Ctor.extendOptions;
	  var sealed = Ctor.sealedOptions;
	  for (var key in latest) {
	    if (latest[key] !== sealed[key]) {
	      if (!modified) {
	        modified = {};
	      }
	      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
	    }
	  }
	  return modified;
	}
	
	function dedupe(latest, extended, sealed) {
	  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
	  // between merges
	  if (Array.isArray(latest)) {
	    var res = [];
	    sealed = Array.isArray(sealed) ? sealed : [sealed];
	    extended = Array.isArray(extended) ? extended : [extended];
	    for (var i = 0; i < latest.length; i++) {
	      // push original options and not sealed options to exclude duplicated options
	      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
	        res.push(latest[i]);
	      }
	    }
	    return res;
	  } else {
	    return latest;
	  }
	}
	
	function Vue$3(options) {
	  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
	    warn('Vue is a constructor and should be called with the `new` keyword');
	  }
	  this._init(options);
	}
	
	initMixin(Vue$3);
	stateMixin(Vue$3);
	eventsMixin(Vue$3);
	lifecycleMixin(Vue$3);
	renderMixin(Vue$3);
	
	/*  */
	
	function initUse(Vue) {
	  Vue.use = function (plugin) {
	    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
	    if (installedPlugins.indexOf(plugin) > -1) {
	      return this;
	    }
	
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else if (typeof plugin === 'function') {
	      plugin.apply(null, args);
	    }
	    installedPlugins.push(plugin);
	    return this;
	  };
	}
	
	/*  */
	
	function initMixin$1(Vue) {
	  Vue.mixin = function (mixin) {
	    this.options = mergeOptions(this.options, mixin);
	    return this;
	  };
	}
	
	/*  */
	
	function initExtend(Vue) {
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   */
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var SuperId = Super.cid;
	    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
	    if (cachedCtors[SuperId]) {
	      return cachedCtors[SuperId];
	    }
	
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
	      }
	    }
	
	    var Sub = function VueComponent(options) {
	      this._init(options);
	    };
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	
	    // For props and computed properties, we define the proxy getters on
	    // the Vue instances at extension time, on the extended prototype. This
	    // avoids Object.defineProperty calls for each instance created.
	    if (Sub.options.props) {
	      initProps$1(Sub);
	    }
	    if (Sub.options.computed) {
	      initComputed$1(Sub);
	    }
	
	    // allow further extension/mixin/plugin usage
	    Sub.extend = Super.extend;
	    Sub.mixin = Super.mixin;
	    Sub.use = Super.use;
	
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    ASSET_TYPES.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	
	    // keep a reference to the super options at extension time.
	    // later at instantiation we can check if Super's options have
	    // been updated.
	    Sub.superOptions = Super.options;
	    Sub.extendOptions = extendOptions;
	    Sub.sealedOptions = extend({}, Sub.options);
	
	    // cache constructor
	    cachedCtors[SuperId] = Sub;
	    return Sub;
	  };
	}
	
	function initProps$1(Comp) {
	  var props = Comp.options.props;
	  for (var key in props) {
	    proxy(Comp.prototype, "_props", key);
	  }
	}
	
	function initComputed$1(Comp) {
	  var computed = Comp.options.computed;
	  for (var key in computed) {
	    defineComputed(Comp.prototype, key, computed[key]);
	  }
	}
	
	/*  */
	
	function initAssetRegisters(Vue) {
	  /**
	   * Create asset registration methods.
	   */
	  ASSET_TYPES.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && config.isReservedTag(id)) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = definition.name || id;
	          definition = this.options._base.extend(definition);
	        }
	        if (type === 'directive' && typeof definition === 'function') {
	          definition = { bind: definition, update: definition };
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	}
	
	/*  */
	
	var patternTypes = [String, RegExp, Array];
	
	function getComponentName(opts) {
	  return opts && (opts.Ctor.options.name || opts.tag);
	}
	
	function matches(pattern, name) {
	  if (Array.isArray(pattern)) {
	    return pattern.indexOf(name) > -1;
	  } else if (typeof pattern === 'string') {
	    return pattern.split(',').indexOf(name) > -1;
	  } else if (isRegExp(pattern)) {
	    return pattern.test(name);
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	function pruneCache(cache, current, filter) {
	  for (var key in cache) {
	    var cachedNode = cache[key];
	    if (cachedNode) {
	      var name = getComponentName(cachedNode.componentOptions);
	      if (name && !filter(name)) {
	        if (cachedNode !== current) {
	          pruneCacheEntry(cachedNode);
	        }
	        cache[key] = null;
	      }
	    }
	  }
	}
	
	function pruneCacheEntry(vnode) {
	  if (vnode) {
	    vnode.componentInstance.$destroy();
	  }
	}
	
	var KeepAlive = {
	  name: 'keep-alive',
	  abstract: true,
	
	  props: {
	    include: patternTypes,
	    exclude: patternTypes
	  },
	
	  created: function created() {
	    this.cache = Object.create(null);
	  },
	
	  destroyed: function destroyed() {
	    var this$1 = this;
	
	    for (var key in this$1.cache) {
	      pruneCacheEntry(this$1.cache[key]);
	    }
	  },
	
	  watch: {
	    include: function include(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return matches(val, name);
	      });
	    },
	    exclude: function exclude(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return !matches(val, name);
	      });
	    }
	  },
	
	  render: function render() {
	    var vnode = getFirstComponentChild(this.$slots.default);
	    var componentOptions = vnode && vnode.componentOptions;
	    if (componentOptions) {
	      // check pattern
	      var name = getComponentName(componentOptions);
	      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
	        return vnode;
	      }
	      var key = vnode.key == null
	      // same constructor may get registered as different local components
	      // so cid alone is not enough (#3269)
	      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
	      if (this.cache[key]) {
	        vnode.componentInstance = this.cache[key].componentInstance;
	      } else {
	        this.cache[key] = vnode;
	      }
	      vnode.data.keepAlive = true;
	    }
	    return vnode;
	  }
	};
	
	var builtInComponents = {
	  KeepAlive: KeepAlive
	};
	
	/*  */
	
	function initGlobalAPI(Vue) {
	  // config
	  var configDef = {};
	  configDef.get = function () {
	    return config;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    configDef.set = function () {
	      warn('Do not replace the Vue.config object, set individual fields instead.');
	    };
	  }
	  Object.defineProperty(Vue, 'config', configDef);
	
	  // exposed util methods.
	  // NOTE: these are not considered part of the public API - avoid relying on
	  // them unless you are aware of the risk.
	  Vue.util = {
	    warn: warn,
	    extend: extend,
	    mergeOptions: mergeOptions,
	    defineReactive: defineReactive$$1
	  };
	
	  Vue.set = set;
	  Vue.delete = del;
	  Vue.nextTick = nextTick;
	
	  Vue.options = Object.create(null);
	  ASSET_TYPES.forEach(function (type) {
	    Vue.options[type + 's'] = Object.create(null);
	  });
	
	  // this is used to identify the "base" constructor to extend all plain-object
	  // components with in Weex's multi-instance scenarios.
	  Vue.options._base = Vue;
	
	  extend(Vue.options.components, builtInComponents);
	
	  initUse(Vue);
	  initMixin$1(Vue);
	  initExtend(Vue);
	  initAssetRegisters(Vue);
	}
	
	initGlobalAPI(Vue$3);
	
	Object.defineProperty(Vue$3.prototype, '$isServer', {
	  get: isServerRendering
	});
	
	Object.defineProperty(Vue$3.prototype, '$ssrContext', {
	  get: function get() {
	    /* istanbul ignore next */
	    return this.$vnode && this.$vnode.ssrContext;
	  }
	});
	
	Vue$3.version = '2.4.2';
	
	/*  */
	
	// these are reserved for web because they are directly compiled away
	// during template compilation
	var isReservedAttr = makeMap('style,class');
	
	// attributes that should be using props for binding
	var acceptValue = makeMap('input,textarea,option,select');
	var mustUseProp = function mustUseProp(tag, type, attr) {
	  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
	};
	
	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
	
	var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
	
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	
	var isXlink = function isXlink(name) {
	  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
	};
	
	var getXlinkProp = function getXlinkProp(name) {
	  return isXlink(name) ? name.slice(6, name.length) : '';
	};
	
	var isFalsyAttrValue = function isFalsyAttrValue(val) {
	  return val == null || val === false;
	};
	
	/*  */
	
	function genClassForVnode(vnode) {
	  var data = vnode.data;
	  var parentNode = vnode;
	  var childNode = vnode;
	  while (isDef(childNode.componentInstance)) {
	    childNode = childNode.componentInstance._vnode;
	    if (childNode.data) {
	      data = mergeClassData(childNode.data, data);
	    }
	  }
	  while (isDef(parentNode = parentNode.parent)) {
	    if (parentNode.data) {
	      data = mergeClassData(data, parentNode.data);
	    }
	  }
	  return renderClass(data.staticClass, data.class);
	}
	
	function mergeClassData(child, parent) {
	  return {
	    staticClass: concat(child.staticClass, parent.staticClass),
	    class: isDef(child.class) ? [child.class, parent.class] : parent.class
	  };
	}
	
	function renderClass(staticClass, dynamicClass) {
	  if (isDef(staticClass) || isDef(dynamicClass)) {
	    return concat(staticClass, stringifyClass(dynamicClass));
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function concat(a, b) {
	  return a ? b ? a + ' ' + b : a : b || '';
	}
	
	function stringifyClass(value) {
	  if (Array.isArray(value)) {
	    return stringifyArray(value);
	  }
	  if (isObject(value)) {
	    return stringifyObject(value);
	  }
	  if (typeof value === 'string') {
	    return value;
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function stringifyArray(value) {
	  var res = '';
	  var stringified;
	  for (var i = 0, l = value.length; i < l; i++) {
	    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
	      if (res) {
	        res += ' ';
	      }
	      res += stringified;
	    }
	  }
	  return res;
	}
	
	function stringifyObject(value) {
	  var res = '';
	  for (var key in value) {
	    if (value[key]) {
	      if (res) {
	        res += ' ';
	      }
	      res += key;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var namespaceMap = {
	  svg: 'http://www.w3.org/2000/svg',
	  math: 'http://www.w3.org/1998/Math/MathML'
	};
	
	var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');
	
	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
	
	var isPreTag = function isPreTag(tag) {
	  return tag === 'pre';
	};
	
	var isReservedTag = function isReservedTag(tag) {
	  return isHTMLTag(tag) || isSVG(tag);
	};
	
	function getTagNamespace(tag) {
	  if (isSVG(tag)) {
	    return 'svg';
	  }
	  // basic support for MathML
	  // note it doesn't support other MathML elements being component roots
	  if (tag === 'math') {
	    return 'math';
	  }
	}
	
	var unknownElementCache = Object.create(null);
	function isUnknownElement(tag) {
	  /* istanbul ignore if */
	  if (!inBrowser) {
	    return true;
	  }
	  if (isReservedTag(tag)) {
	    return false;
	  }
	  tag = tag.toLowerCase();
	  /* istanbul ignore if */
	  if (unknownElementCache[tag] != null) {
	    return unknownElementCache[tag];
	  }
	  var el = document.createElement(tag);
	  if (tag.indexOf('-') > -1) {
	    // http://stackoverflow.com/a/28210364/1070244
	    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	  } else {
	    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
	  }
	}
	
	/*  */
	
	/**
	 * Query an element selector if it's not an element already.
	 */
	function query(el) {
	  if (typeof el === 'string') {
	    var selected = document.querySelector(el);
	    if (!selected) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
	      return document.createElement('div');
	    }
	    return selected;
	  } else {
	    return el;
	  }
	}
	
	/*  */
	
	function createElement$1(tagName, vnode) {
	  var elm = document.createElement(tagName);
	  if (tagName !== 'select') {
	    return elm;
	  }
	  // false or null will remove the attribute but undefined will not
	  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
	    elm.setAttribute('multiple', 'multiple');
	  }
	  return elm;
	}
	
	function createElementNS(namespace, tagName) {
	  return document.createElementNS(namespaceMap[namespace], tagName);
	}
	
	function createTextNode(text) {
	  return document.createTextNode(text);
	}
	
	function createComment(text) {
	  return document.createComment(text);
	}
	
	function insertBefore(parentNode, newNode, referenceNode) {
	  parentNode.insertBefore(newNode, referenceNode);
	}
	
	function removeChild(node, child) {
	  node.removeChild(child);
	}
	
	function appendChild(node, child) {
	  node.appendChild(child);
	}
	
	function parentNode(node) {
	  return node.parentNode;
	}
	
	function nextSibling(node) {
	  return node.nextSibling;
	}
	
	function tagName(node) {
	  return node.tagName;
	}
	
	function setTextContent(node, text) {
	  node.textContent = text;
	}
	
	function setAttribute(node, key, val) {
	  node.setAttribute(key, val);
	}
	
	var nodeOps = Object.freeze({
	  createElement: createElement$1,
	  createElementNS: createElementNS,
	  createTextNode: createTextNode,
	  createComment: createComment,
	  insertBefore: insertBefore,
	  removeChild: removeChild,
	  appendChild: appendChild,
	  parentNode: parentNode,
	  nextSibling: nextSibling,
	  tagName: tagName,
	  setTextContent: setTextContent,
	  setAttribute: setAttribute
	});
	
	/*  */
	
	var ref = {
	  create: function create(_, vnode) {
	    registerRef(vnode);
	  },
	  update: function update(oldVnode, vnode) {
	    if (oldVnode.data.ref !== vnode.data.ref) {
	      registerRef(oldVnode, true);
	      registerRef(vnode);
	    }
	  },
	  destroy: function destroy(vnode) {
	    registerRef(vnode, true);
	  }
	};
	
	function registerRef(vnode, isRemoval) {
	  var key = vnode.data.ref;
	  if (!key) {
	    return;
	  }
	
	  var vm = vnode.context;
	  var ref = vnode.componentInstance || vnode.elm;
	  var refs = vm.$refs;
	  if (isRemoval) {
	    if (Array.isArray(refs[key])) {
	      remove(refs[key], ref);
	    } else if (refs[key] === ref) {
	      refs[key] = undefined;
	    }
	  } else {
	    if (vnode.data.refInFor) {
	      if (!Array.isArray(refs[key])) {
	        refs[key] = [ref];
	      } else if (refs[key].indexOf(ref) < 0) {
	        // $flow-disable-line
	        refs[key].push(ref);
	      }
	    } else {
	      refs[key] = ref;
	    }
	  }
	}
	
	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *
	
	/*
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */
	
	var emptyNode = new VNode('', {}, []);
	
	var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
	
	function sameVnode(a, b) {
	  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
	}
	
	// Some browsers do not support dynamically changing type for <input>
	// so they need to be treated as different nodes
	function sameInputType(a, b) {
	  if (a.tag !== 'input') {
	    return true;
	  }
	  var i;
	  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
	  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
	  return typeA === typeB;
	}
	
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, key;
	  var map = {};
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) {
	      map[key] = i;
	    }
	  }
	  return map;
	}
	
	function createPatchFunction(backend) {
	  var i, j;
	  var cbs = {};
	
	  var modules = backend.modules;
	  var nodeOps = backend.nodeOps;
	
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (isDef(modules[j][hooks[i]])) {
	        cbs[hooks[i]].push(modules[j][hooks[i]]);
	      }
	    }
	  }
	
	  function emptyNodeAt(elm) {
	    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
	  }
	
	  function createRmCb(childElm, listeners) {
	    function remove$$1() {
	      if (--remove$$1.listeners === 0) {
	        removeNode(childElm);
	      }
	    }
	    remove$$1.listeners = listeners;
	    return remove$$1;
	  }
	
	  function removeNode(el) {
	    var parent = nodeOps.parentNode(el);
	    // element may have already been removed due to v-html / v-text
	    if (isDef(parent)) {
	      nodeOps.removeChild(parent, el);
	    }
	  }
	
	  var inPre = 0;
	  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
	    vnode.isRootInsert = !nested; // for transition enter check
	    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	      return;
	    }
	
	    var data = vnode.data;
	    var children = vnode.children;
	    var tag = vnode.tag;
	    if (isDef(tag)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (data && data.pre) {
	          inPre++;
	        }
	        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
	        }
	      }
	      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
	      setScope(vnode);
	
	      /* istanbul ignore if */
	      {
	        createChildren(vnode, children, insertedVnodeQueue);
	        if (isDef(data)) {
	          invokeCreateHooks(vnode, insertedVnodeQueue);
	        }
	        insert(parentElm, vnode.elm, refElm);
	      }
	
	      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
	        inPre--;
	      }
	    } else if (isTrue(vnode.isComment)) {
	      vnode.elm = nodeOps.createComment(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    } else {
	      vnode.elm = nodeOps.createTextNode(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    }
	  }
	
	  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i = vnode.data;
	    if (isDef(i)) {
	      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
	      if (isDef(i = i.hook) && isDef(i = i.init)) {
	        i(vnode, false /* hydrating */, parentElm, refElm);
	      }
	      // after calling the init hook, if the vnode is a child component
	      // it should've created a child instance and mounted it. the child
	      // component also has set the placeholder vnode's elm.
	      // in that case we can just return the element and be done.
	      if (isDef(vnode.componentInstance)) {
	        initComponent(vnode, insertedVnodeQueue);
	        if (isTrue(isReactivated)) {
	          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
	        }
	        return true;
	      }
	    }
	  }
	
	  function initComponent(vnode, insertedVnodeQueue) {
	    if (isDef(vnode.data.pendingInsert)) {
	      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	      vnode.data.pendingInsert = null;
	    }
	    vnode.elm = vnode.componentInstance.$el;
	    if (isPatchable(vnode)) {
	      invokeCreateHooks(vnode, insertedVnodeQueue);
	      setScope(vnode);
	    } else {
	      // empty component root.
	      // skip all element-related modules except for ref (#3455)
	      registerRef(vnode);
	      // make sure to invoke the insert hook
	      insertedVnodeQueue.push(vnode);
	    }
	  }
	
	  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i;
	    // hack for #4339: a reactivated component with inner transition
	    // does not trigger because the inner node's created hooks are not called
	    // again. It's not ideal to involve module-specific logic in here but
	    // there doesn't seem to be a better way to do it.
	    var innerNode = vnode;
	    while (innerNode.componentInstance) {
	      innerNode = innerNode.componentInstance._vnode;
	      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
	        for (i = 0; i < cbs.activate.length; ++i) {
	          cbs.activate[i](emptyNode, innerNode);
	        }
	        insertedVnodeQueue.push(innerNode);
	        break;
	      }
	    }
	    // unlike a newly created component,
	    // a reactivated keep-alive component doesn't insert itself
	    insert(parentElm, vnode.elm, refElm);
	  }
	
	  function insert(parent, elm, ref$$1) {
	    if (isDef(parent)) {
	      if (isDef(ref$$1)) {
	        if (ref$$1.parentNode === parent) {
	          nodeOps.insertBefore(parent, elm, ref$$1);
	        }
	      } else {
	        nodeOps.appendChild(parent, elm);
	      }
	    }
	  }
	
	  function createChildren(vnode, children, insertedVnodeQueue) {
	    if (Array.isArray(children)) {
	      for (var i = 0; i < children.length; ++i) {
	        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
	      }
	    } else if (isPrimitive(vnode.text)) {
	      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
	    }
	  }
	
	  function isPatchable(vnode) {
	    while (vnode.componentInstance) {
	      vnode = vnode.componentInstance._vnode;
	    }
	    return isDef(vnode.tag);
	  }
	
	  function invokeCreateHooks(vnode, insertedVnodeQueue) {
	    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
	      cbs.create[i$1](emptyNode, vnode);
	    }
	    i = vnode.data.hook; // Reuse variable
	    if (isDef(i)) {
	      if (isDef(i.create)) {
	        i.create(emptyNode, vnode);
	      }
	      if (isDef(i.insert)) {
	        insertedVnodeQueue.push(vnode);
	      }
	    }
	  }
	
	  // set scope id attribute for scoped CSS.
	  // this is implemented as a special case to avoid the overhead
	  // of going through the normal attribute patching process.
	  function setScope(vnode) {
	    var i;
	    var ancestor = vnode;
	    while (ancestor) {
	      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
	        nodeOps.setAttribute(vnode.elm, i, '');
	      }
	      ancestor = ancestor.parent;
	    }
	    // for slot content they should also get the scopeId from the host instance.
	    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	  }
	
	  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
	    }
	  }
	
	  function invokeDestroyHook(vnode) {
	    var i, j;
	    var data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
	        i(vnode);
	      }
	      for (i = 0; i < cbs.destroy.length; ++i) {
	        cbs.destroy[i](vnode);
	      }
	    }
	    if (isDef(i = vnode.children)) {
	      for (j = 0; j < vnode.children.length; ++j) {
	        invokeDestroyHook(vnode.children[j]);
	      }
	    }
	  }
	
	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.tag)) {
	          removeAndInvokeRemoveHook(ch);
	          invokeDestroyHook(ch);
	        } else {
	          // Text node
	          removeNode(ch.elm);
	        }
	      }
	    }
	  }
	
	  function removeAndInvokeRemoveHook(vnode, rm) {
	    if (isDef(rm) || isDef(vnode.data)) {
	      var i;
	      var listeners = cbs.remove.length + 1;
	      if (isDef(rm)) {
	        // we have a recursively passed down rm callback
	        // increase the listeners count
	        rm.listeners += listeners;
	      } else {
	        // directly removing
	        rm = createRmCb(vnode.elm, listeners);
	      }
	      // recursively invoke hooks on child component root node
	      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
	        removeAndInvokeRemoveHook(i, rm);
	      }
	      for (i = 0; i < cbs.remove.length; ++i) {
	        cbs.remove[i](vnode, rm);
	      }
	      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
	        i(vnode, rm);
	      } else {
	        rm();
	      }
	    } else {
	      removeNode(vnode.elm);
	    }
	  }
	
	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	    var oldStartIdx = 0;
	    var newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, refElm;
	
	    // removeOnly is a special flag used only by <transition-group>
	    // to ensure removed elements stay in correct relative positions
	    // during leaving transitions
	    var canMove = !removeOnly;
	
	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) {
	        // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) {
	        // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) {
	          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        }
	        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
	        if (isUndef(idxInOld)) {
	          // New element
	          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
	            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
	          }
	          if (sameVnode(elmToMove, newStartVnode)) {
	            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	            oldCh[idxInOld] = undefined;
	            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          } else {
	            // same key but different element. treat as new element
	            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          }
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }
	
	  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
	    if (oldVnode === vnode) {
	      return;
	    }
	
	    var elm = vnode.elm = oldVnode.elm;
	
	    if (isTrue(oldVnode.isAsyncPlaceholder)) {
	      if (isDef(vnode.asyncFactory.resolved)) {
	        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
	      } else {
	        vnode.isAsyncPlaceholder = true;
	      }
	      return;
	    }
	
	    // reuse element for static trees.
	    // note we only do this if the vnode is cloned -
	    // if the new node is not cloned it means the render functions have been
	    // reset by the hot-reload-api and we need to do a proper re-render.
	    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
	      vnode.componentInstance = oldVnode.componentInstance;
	      return;
	    }
	
	    var i;
	    var data = vnode.data;
	    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
	      i(oldVnode, vnode);
	    }
	
	    var oldCh = oldVnode.children;
	    var ch = vnode.children;
	    if (isDef(data) && isPatchable(vnode)) {
	      for (i = 0; i < cbs.update.length; ++i) {
	        cbs.update[i](oldVnode, vnode);
	      }
	      if (isDef(i = data.hook) && isDef(i = i.update)) {
	        i(oldVnode, vnode);
	      }
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) {
	          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
	        }
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) {
	          nodeOps.setTextContent(elm, '');
	        }
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        nodeOps.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      nodeOps.setTextContent(elm, vnode.text);
	    }
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
	        i(oldVnode, vnode);
	      }
	    }
	  }
	
	  function invokeInsertHook(vnode, queue, initial) {
	    // delay insert hooks for component root nodes, invoke them after the
	    // element is really inserted
	    if (isTrue(initial) && isDef(vnode.parent)) {
	      vnode.parent.data.pendingInsert = queue;
	    } else {
	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].data.hook.insert(queue[i]);
	      }
	    }
	  }
	
	  var bailed = false;
	  // list of modules that can skip create hook during hydration because they
	  // are already rendered on the client or has no need for initialization
	  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
	
	  // Note: this is a browser-only function so we can assume elms are DOM nodes.
	  function hydrate(elm, vnode, insertedVnodeQueue) {
	    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
	      vnode.elm = elm;
	      vnode.isAsyncPlaceholder = true;
	      return true;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (!assertNodeMatch(elm, vnode)) {
	        return false;
	      }
	    }
	    vnode.elm = elm;
	    var tag = vnode.tag;
	    var data = vnode.data;
	    var children = vnode.children;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) {
	        i(vnode, true /* hydrating */);
	      }
	      if (isDef(i = vnode.componentInstance)) {
	        // child component. it should have hydrated its own tree.
	        initComponent(vnode, insertedVnodeQueue);
	        return true;
	      }
	    }
	    if (isDef(tag)) {
	      if (isDef(children)) {
	        // empty element, allow client to pick up and populate children
	        if (!elm.hasChildNodes()) {
	          createChildren(vnode, children, insertedVnodeQueue);
	        } else {
	          var childrenMatch = true;
	          var childNode = elm.firstChild;
	          for (var i$1 = 0; i$1 < children.length; i$1++) {
	            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
	              childrenMatch = false;
	              break;
	            }
	            childNode = childNode.nextSibling;
	          }
	          // if childNode is not null, it means the actual childNodes list is
	          // longer than the virtual children list.
	          if (!childrenMatch || childNode) {
	            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
	              bailed = true;
	              console.warn('Parent: ', elm);
	              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
	            }
	            return false;
	          }
	        }
	      }
	      if (isDef(data)) {
	        for (var key in data) {
	          if (!isRenderedModule(key)) {
	            invokeCreateHooks(vnode, insertedVnodeQueue);
	            break;
	          }
	        }
	      }
	    } else if (elm.data !== vnode.text) {
	      elm.data = vnode.text;
	    }
	    return true;
	  }
	
	  function assertNodeMatch(node, vnode) {
	    if (isDef(vnode.tag)) {
	      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
	    } else {
	      return node.nodeType === (vnode.isComment ? 8 : 3);
	    }
	  }
	
	  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
	    if (isUndef(vnode)) {
	      if (isDef(oldVnode)) {
	        invokeDestroyHook(oldVnode);
	      }
	      return;
	    }
	
	    var isInitialPatch = false;
	    var insertedVnodeQueue = [];
	
	    if (isUndef(oldVnode)) {
	      // empty mount (likely as component), create new root element
	      isInitialPatch = true;
	      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
	    } else {
	      var isRealElement = isDef(oldVnode.nodeType);
	      if (!isRealElement && sameVnode(oldVnode, vnode)) {
	        // patch existing root node
	        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
	      } else {
	        if (isRealElement) {
	          // mounting to a real element
	          // check if this is server-rendered content and if we can perform
	          // a successful hydration.
	          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
	            oldVnode.removeAttribute(SSR_ATTR);
	            hydrating = true;
	          }
	          if (isTrue(hydrating)) {
	            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	              invokeInsertHook(vnode, insertedVnodeQueue, true);
	              return oldVnode;
	            } else if (process.env.NODE_ENV !== 'production') {
	              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
	            }
	          }
	          // either not server-rendered, or hydration failed.
	          // create an empty node and replace it
	          oldVnode = emptyNodeAt(oldVnode);
	        }
	        // replacing existing element
	        var oldElm = oldVnode.elm;
	        var parentElm$1 = nodeOps.parentNode(oldElm);
	        createElm(vnode, insertedVnodeQueue,
	        // extremely rare edge case: do not insert if old element is in a
	        // leaving transition. Only happens when combining transition +
	        // keep-alive + HOCs. (#4590)
	        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));
	
	        if (isDef(vnode.parent)) {
	          // component root element replaced.
	          // update parent placeholder node element, recursively
	          var ancestor = vnode.parent;
	          while (ancestor) {
	            ancestor.elm = vnode.elm;
	            ancestor = ancestor.parent;
	          }
	          if (isPatchable(vnode)) {
	            for (var i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode.parent);
	            }
	          }
	        }
	
	        if (isDef(parentElm$1)) {
	          removeVnodes(parentElm$1, [oldVnode], 0, 0);
	        } else if (isDef(oldVnode.tag)) {
	          invokeDestroyHook(oldVnode);
	        }
	      }
	    }
	
	    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	    return vnode.elm;
	  };
	}
	
	/*  */
	
	var directives = {
	  create: updateDirectives,
	  update: updateDirectives,
	  destroy: function unbindDirectives(vnode) {
	    updateDirectives(vnode, emptyNode);
	  }
	};
	
	function updateDirectives(oldVnode, vnode) {
	  if (oldVnode.data.directives || vnode.data.directives) {
	    _update(oldVnode, vnode);
	  }
	}
	
	function _update(oldVnode, vnode) {
	  var isCreate = oldVnode === emptyNode;
	  var isDestroy = vnode === emptyNode;
	  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
	  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
	
	  var dirsWithInsert = [];
	  var dirsWithPostpatch = [];
	
	  var key, oldDir, dir;
	  for (key in newDirs) {
	    oldDir = oldDirs[key];
	    dir = newDirs[key];
	    if (!oldDir) {
	      // new directive, bind
	      callHook$1(dir, 'bind', vnode, oldVnode);
	      if (dir.def && dir.def.inserted) {
	        dirsWithInsert.push(dir);
	      }
	    } else {
	      // existing directive, update
	      dir.oldValue = oldDir.value;
	      callHook$1(dir, 'update', vnode, oldVnode);
	      if (dir.def && dir.def.componentUpdated) {
	        dirsWithPostpatch.push(dir);
	      }
	    }
	  }
	
	  if (dirsWithInsert.length) {
	    var callInsert = function callInsert() {
	      for (var i = 0; i < dirsWithInsert.length; i++) {
	        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
	      }
	    };
	    if (isCreate) {
	      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
	    } else {
	      callInsert();
	    }
	  }
	
	  if (dirsWithPostpatch.length) {
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
	      for (var i = 0; i < dirsWithPostpatch.length; i++) {
	        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
	      }
	    });
	  }
	
	  if (!isCreate) {
	    for (key in oldDirs) {
	      if (!newDirs[key]) {
	        // no longer present, unbind
	        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
	      }
	    }
	  }
	}
	
	var emptyModifiers = Object.create(null);
	
	function normalizeDirectives$1(dirs, vm) {
	  var res = Object.create(null);
	  if (!dirs) {
	    return res;
	  }
	  var i, dir;
	  for (i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (!dir.modifiers) {
	      dir.modifiers = emptyModifiers;
	    }
	    res[getRawDirName(dir)] = dir;
	    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
	  }
	  return res;
	}
	
	function getRawDirName(dir) {
	  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
	}
	
	function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
	  var fn = dir.def && dir.def[hook];
	  if (fn) {
	    try {
	      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
	    } catch (e) {
	      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
	    }
	  }
	}
	
	var baseModules = [ref, directives];
	
	/*  */
	
	function updateAttrs(oldVnode, vnode) {
	  var opts = vnode.componentOptions;
	  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
	    return;
	  }
	  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
	    return;
	  }
	  var key, cur, old;
	  var elm = vnode.elm;
	  var oldAttrs = oldVnode.data.attrs || {};
	  var attrs = vnode.data.attrs || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(attrs.__ob__)) {
	    attrs = vnode.data.attrs = extend({}, attrs);
	  }
	
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      setAttr(elm, key, cur);
	    }
	  }
	  // #4391: in IE9, setting type can reset value for input[type=radio]
	  /* istanbul ignore if */
	  if (isIE9 && attrs.value !== oldAttrs.value) {
	    setAttr(elm, 'value', attrs.value);
	  }
	  for (key in oldAttrs) {
	    if (isUndef(attrs[key])) {
	      if (isXlink(key)) {
	        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	      } else if (!isEnumeratedAttr(key)) {
	        elm.removeAttribute(key);
	      }
	    }
	  }
	}
	
	function setAttr(el, key, value) {
	  if (isBooleanAttr(key)) {
	    // set attribute for blank value
	    // e.g. <option disabled>Select one</option>
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, key);
	    }
	  } else if (isEnumeratedAttr(key)) {
	    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
	  } else if (isXlink(key)) {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, value);
	    }
	  }
	}
	
	var attrs = {
	  create: updateAttrs,
	  update: updateAttrs
	};
	
	/*  */
	
	function updateClass(oldVnode, vnode) {
	  var el = vnode.elm;
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
	    return;
	  }
	
	  var cls = genClassForVnode(vnode);
	
	  // handle transition classes
	  var transitionClass = el._transitionClasses;
	  if (isDef(transitionClass)) {
	    cls = concat(cls, stringifyClass(transitionClass));
	  }
	
	  // set the class
	  if (cls !== el._prevClass) {
	    el.setAttribute('class', cls);
	    el._prevClass = cls;
	  }
	}
	
	var klass = {
	  create: updateClass,
	  update: updateClass
	};
	
	/*  */
	
	var validDivisionCharRE = /[\w).+\-_$\]]/;
	
	function parseFilters(exp) {
	  var inSingle = false;
	  var inDouble = false;
	  var inTemplateString = false;
	  var inRegex = false;
	  var curly = 0;
	  var square = 0;
	  var paren = 0;
	  var lastFilterIndex = 0;
	  var c, prev, i, expression, filters;
	
	  for (i = 0; i < exp.length; i++) {
	    prev = c;
	    c = exp.charCodeAt(i);
	    if (inSingle) {
	      if (c === 0x27 && prev !== 0x5C) {
	        inSingle = false;
	      }
	    } else if (inDouble) {
	      if (c === 0x22 && prev !== 0x5C) {
	        inDouble = false;
	      }
	    } else if (inTemplateString) {
	      if (c === 0x60 && prev !== 0x5C) {
	        inTemplateString = false;
	      }
	    } else if (inRegex) {
	      if (c === 0x2f && prev !== 0x5C) {
	        inRegex = false;
	      }
	    } else if (c === 0x7C && // pipe
	    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
	      if (expression === undefined) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        expression = exp.slice(0, i).trim();
	      } else {
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x60:
	          inTemplateString = true;break; // `
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	      if (c === 0x2f) {
	        // /
	        var j = i - 1;
	        var p = void 0;
	        // find first non-whitespace prev char
	        for (; j >= 0; j--) {
	          p = exp.charAt(j);
	          if (p !== ' ') {
	            break;
	          }
	        }
	        if (!p || !validDivisionCharRE.test(p)) {
	          inRegex = true;
	        }
	      }
	    }
	  }
	
	  if (expression === undefined) {
	    expression = exp.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  function pushFilter() {
	    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
	    lastFilterIndex = i + 1;
	  }
	
	  if (filters) {
	    for (i = 0; i < filters.length; i++) {
	      expression = wrapFilter(expression, filters[i]);
	    }
	  }
	
	  return expression;
	}
	
	function wrapFilter(exp, filter) {
	  var i = filter.indexOf('(');
	  if (i < 0) {
	    // _f: resolveFilter
	    return "_f(\"" + filter + "\")(" + exp + ")";
	  } else {
	    var name = filter.slice(0, i);
	    var args = filter.slice(i + 1);
	    return "_f(\"" + name + "\")(" + exp + "," + args;
	  }
	}
	
	/*  */
	
	function baseWarn(msg) {
	  console.error("[Vue compiler]: " + msg);
	}
	
	function pluckModuleFunction(modules, key) {
	  return modules ? modules.map(function (m) {
	    return m[key];
	  }).filter(function (_) {
	    return _;
	  }) : [];
	}
	
	function addProp(el, name, value) {
	  (el.props || (el.props = [])).push({ name: name, value: value });
	}
	
	function addAttr(el, name, value) {
	  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
	}
	
	function addDirective(el, name, rawName, value, arg, modifiers) {
	  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
	}
	
	function addHandler(el, name, value, modifiers, important, warn) {
	  // warn prevent and passive modifier
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {
	    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
	  }
	  // check capture modifier
	  if (modifiers && modifiers.capture) {
	    delete modifiers.capture;
	    name = '!' + name; // mark the event as captured
	  }
	  if (modifiers && modifiers.once) {
	    delete modifiers.once;
	    name = '~' + name; // mark the event as once
	  }
	  /* istanbul ignore if */
	  if (modifiers && modifiers.passive) {
	    delete modifiers.passive;
	    name = '&' + name; // mark the event as passive
	  }
	  var events;
	  if (modifiers && modifiers.native) {
	    delete modifiers.native;
	    events = el.nativeEvents || (el.nativeEvents = {});
	  } else {
	    events = el.events || (el.events = {});
	  }
	  var newHandler = { value: value, modifiers: modifiers };
	  var handlers = events[name];
	  /* istanbul ignore if */
	  if (Array.isArray(handlers)) {
	    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
	  } else if (handlers) {
	    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
	  } else {
	    events[name] = newHandler;
	  }
	}
	
	function getBindingAttr(el, name, getStatic) {
	  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
	  if (dynamicValue != null) {
	    return parseFilters(dynamicValue);
	  } else if (getStatic !== false) {
	    var staticValue = getAndRemoveAttr(el, name);
	    if (staticValue != null) {
	      return JSON.stringify(staticValue);
	    }
	  }
	}
	
	function getAndRemoveAttr(el, name) {
	  var val;
	  if ((val = el.attrsMap[name]) != null) {
	    var list = el.attrsList;
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (list[i].name === name) {
	        list.splice(i, 1);
	        break;
	      }
	    }
	  }
	  return val;
	}
	
	/*  */
	
	/**
	 * Cross-platform code generation for component v-model
	 */
	function genComponentModel(el, value, modifiers) {
	  var ref = modifiers || {};
	  var number = ref.number;
	  var trim = ref.trim;
	
	  var baseValueExpression = '$$v';
	  var valueExpression = baseValueExpression;
	  if (trim) {
	    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	  var assignment = genAssignmentCode(value, valueExpression);
	
	  el.model = {
	    value: "(" + value + ")",
	    expression: "\"" + value + "\"",
	    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
	  };
	}
	
	/**
	 * Cross-platform codegen helper for generating v-model value assignment code.
	 */
	function genAssignmentCode(value, assignment) {
	  var modelRs = parseModel(value);
	  if (modelRs.idx === null) {
	    return value + "=" + assignment;
	  } else {
	    return "$set(" + modelRs.exp + ", " + modelRs.idx + ", " + assignment + ")";
	  }
	}
	
	/**
	 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
	 *
	 * for loop possible cases:
	 *
	 * - test
	 * - test[idx]
	 * - test[test1[idx]]
	 * - test["a"][idx]
	 * - xxx.test[a[a].test1[idx]]
	 * - test.xxx.a["asa"][test1[idx]]
	 *
	 */
	
	var len;
	var str;
	var chr;
	var index$1;
	var expressionPos;
	var expressionEndPos;
	
	function parseModel(val) {
	  str = val;
	  len = str.length;
	  index$1 = expressionPos = expressionEndPos = 0;
	
	  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
	    return {
	      exp: val,
	      idx: null
	    };
	  }
	
	  while (!eof()) {
	    chr = next();
	    /* istanbul ignore if */
	    if (isStringStart(chr)) {
	      parseString(chr);
	    } else if (chr === 0x5B) {
	      parseBracket(chr);
	    }
	  }
	
	  return {
	    exp: val.substring(0, expressionPos),
	    idx: val.substring(expressionPos + 1, expressionEndPos)
	  };
	}
	
	function next() {
	  return str.charCodeAt(++index$1);
	}
	
	function eof() {
	  return index$1 >= len;
	}
	
	function isStringStart(chr) {
	  return chr === 0x22 || chr === 0x27;
	}
	
	function parseBracket(chr) {
	  var inBracket = 1;
	  expressionPos = index$1;
	  while (!eof()) {
	    chr = next();
	    if (isStringStart(chr)) {
	      parseString(chr);
	      continue;
	    }
	    if (chr === 0x5B) {
	      inBracket++;
	    }
	    if (chr === 0x5D) {
	      inBracket--;
	    }
	    if (inBracket === 0) {
	      expressionEndPos = index$1;
	      break;
	    }
	  }
	}
	
	function parseString(chr) {
	  var stringQuote = chr;
	  while (!eof()) {
	    chr = next();
	    if (chr === stringQuote) {
	      break;
	    }
	  }
	}
	
	/*  */
	
	var warn$1;
	
	// in some cases, the event used has to be determined at runtime
	// so we used some reserved tokens during compile.
	var RANGE_TOKEN = '__r';
	var CHECKBOX_RADIO_TOKEN = '__c';
	
	function model(el, dir, _warn) {
	  warn$1 = _warn;
	  var value = dir.value;
	  var modifiers = dir.modifiers;
	  var tag = el.tag;
	  var type = el.attrsMap.type;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
	    if (tag === 'input' && dynamicType) {
	      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
	    }
	    // inputs with type="file" are read only and setting the input's
	    // value will throw an error.
	    if (tag === 'input' && type === 'file') {
	      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
	    }
	  }
	
	  if (el.component) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (tag === 'select') {
	    genSelect(el, value, modifiers);
	  } else if (tag === 'input' && type === 'checkbox') {
	    genCheckboxModel(el, value, modifiers);
	  } else if (tag === 'input' && type === 'radio') {
	    genRadioModel(el, value, modifiers);
	  } else if (tag === 'input' || tag === 'textarea') {
	    genDefaultModel(el, value, modifiers);
	  } else if (!config.isReservedTag(tag)) {
	    genComponentModel(el, value, modifiers);
	    // component v-model doesn't need extra runtime
	    return false;
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
	  }
	
	  // ensure runtime directive metadata
	  return true;
	}
	
	function genCheckboxModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
	  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
	  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
	  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
	}
	
	function genRadioModel(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
	  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
	  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
	}
	
	function genSelect(el, value, modifiers) {
	  var number = modifiers && modifiers.number;
	  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
	
	  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
	  var code = "var $$selectedVal = " + selectedVal + ";";
	  code = code + " " + genAssignmentCode(value, assignment);
	  addHandler(el, 'change', code, null, true);
	}
	
	function genDefaultModel(el, value, modifiers) {
	  var type = el.attrsMap.type;
	  var ref = modifiers || {};
	  var lazy = ref.lazy;
	  var number = ref.number;
	  var trim = ref.trim;
	  var needCompositionGuard = !lazy && type !== 'range';
	  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
	
	  var valueExpression = '$event.target.value';
	  if (trim) {
	    valueExpression = "$event.target.value.trim()";
	  }
	  if (number) {
	    valueExpression = "_n(" + valueExpression + ")";
	  }
	
	  var code = genAssignmentCode(value, valueExpression);
	  if (needCompositionGuard) {
	    code = "if($event.target.composing)return;" + code;
	  }
	
	  addProp(el, 'value', "(" + value + ")");
	  addHandler(el, event, code, null, true);
	  if (trim || number) {
	    addHandler(el, 'blur', '$forceUpdate()');
	  }
	}
	
	/*  */
	
	// normalize v-model event tokens that can only be determined at runtime.
	// it's important to place the event as the first in the array because
	// the whole point is ensuring the v-model callback gets called before
	// user-attached handlers.
	function normalizeEvents(on) {
	  var event;
	  /* istanbul ignore if */
	  if (isDef(on[RANGE_TOKEN])) {
	    // IE input[type=range] only supports `change` event
	    event = isIE ? 'change' : 'input';
	    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
	    delete on[RANGE_TOKEN];
	  }
	  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
	    // Chrome fires microtasks in between click/change, leads to #4521
	    event = isChrome ? 'click' : 'change';
	    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
	    delete on[CHECKBOX_RADIO_TOKEN];
	  }
	}
	
	var target$1;
	
	function add$1(event, _handler, once$$1, capture, passive) {
	  if (once$$1) {
	    var oldHandler = _handler;
	    var _target = target$1; // save current target element in closure
	    _handler = function handler(ev) {
	      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
	      if (res !== null) {
	        remove$2(event, _handler, capture, _target);
	      }
	    };
	  }
	  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);
	}
	
	function remove$2(event, handler, capture, _target) {
	  (_target || target$1).removeEventListener(event, handler, capture);
	}
	
	function updateDOMListeners(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
	    return;
	  }
	  var on = vnode.data.on || {};
	  var oldOn = oldVnode.data.on || {};
	  target$1 = vnode.elm;
	  normalizeEvents(on);
	  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
	}
	
	var events = {
	  create: updateDOMListeners,
	  update: updateDOMListeners
	};
	
	/*  */
	
	function updateDOMProps(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
	    return;
	  }
	  var key, cur;
	  var elm = vnode.elm;
	  var oldProps = oldVnode.data.domProps || {};
	  var props = vnode.data.domProps || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(props.__ob__)) {
	    props = vnode.data.domProps = extend({}, props);
	  }
	
	  for (key in oldProps) {
	    if (isUndef(props[key])) {
	      elm[key] = '';
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    // ignore children if the node has textContent or innerHTML,
	    // as these will throw away existing DOM nodes and cause removal errors
	    // on subsequent patches (#3360)
	    if (key === 'textContent' || key === 'innerHTML') {
	      if (vnode.children) {
	        vnode.children.length = 0;
	      }
	      if (cur === oldProps[key]) {
	        continue;
	      }
	    }
	
	    if (key === 'value') {
	      // store value as _value as well since
	      // non-string values will be stringified
	      elm._value = cur;
	      // avoid resetting cursor position when value is the same
	      var strCur = isUndef(cur) ? '' : String(cur);
	      if (shouldUpdateValue(elm, vnode, strCur)) {
	        elm.value = strCur;
	      }
	    } else {
	      elm[key] = cur;
	    }
	  }
	}
	
	// check platforms/web/util/attrs.js acceptValue
	
	
	function shouldUpdateValue(elm, vnode, checkVal) {
	  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
	}
	
	function isDirty(elm, checkVal) {
	  // return true when textbox (.number and .trim) loses focus and its value is
	  // not equal to the updated value
	  var notInFocus = true;
	  // #6157
	  // work around IE bug when accessing document.activeElement in an iframe
	  try {
	    notInFocus = document.activeElement !== elm;
	  } catch (e) {}
	  return notInFocus && elm.value !== checkVal;
	}
	
	function isInputChanged(elm, newVal) {
	  var value = elm.value;
	  var modifiers = elm._vModifiers; // injected by v-model runtime
	  if (isDef(modifiers) && modifiers.number) {
	    return toNumber(value) !== toNumber(newVal);
	  }
	  if (isDef(modifiers) && modifiers.trim) {
	    return value.trim() !== newVal.trim();
	  }
	  return value !== newVal;
	}
	
	var domProps = {
	  create: updateDOMProps,
	  update: updateDOMProps
	};
	
	/*  */
	
	var parseStyleText = cached(function (cssText) {
	  var res = {};
	  var listDelimiter = /;(?![^(]*\))/g;
	  var propertyDelimiter = /:(.+)/;
	  cssText.split(listDelimiter).forEach(function (item) {
	    if (item) {
	      var tmp = item.split(propertyDelimiter);
	      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
	    }
	  });
	  return res;
	});
	
	// merge static and dynamic style data on the same vnode
	function normalizeStyleData(data) {
	  var style = normalizeStyleBinding(data.style);
	  // static style is pre-processed into an object during compilation
	  // and is always a fresh object, so it's safe to merge into it
	  return data.staticStyle ? extend(data.staticStyle, style) : style;
	}
	
	// normalize possible array / string values into Object
	function normalizeStyleBinding(bindingStyle) {
	  if (Array.isArray(bindingStyle)) {
	    return toObject(bindingStyle);
	  }
	  if (typeof bindingStyle === 'string') {
	    return parseStyleText(bindingStyle);
	  }
	  return bindingStyle;
	}
	
	/**
	 * parent component style should be after child's
	 * so that parent component's style could override it
	 */
	function getStyle(vnode, checkChild) {
	  var res = {};
	  var styleData;
	
	  if (checkChild) {
	    var childNode = vnode;
	    while (childNode.componentInstance) {
	      childNode = childNode.componentInstance._vnode;
	      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
	        extend(res, styleData);
	      }
	    }
	  }
	
	  if (styleData = normalizeStyleData(vnode.data)) {
	    extend(res, styleData);
	  }
	
	  var parentNode = vnode;
	  while (parentNode = parentNode.parent) {
	    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
	      extend(res, styleData);
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var cssVarRE = /^--/;
	var importantRE = /\s*!important$/;
	var setProp = function setProp(el, name, val) {
	  /* istanbul ignore if */
	  if (cssVarRE.test(name)) {
	    el.style.setProperty(name, val);
	  } else if (importantRE.test(val)) {
	    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
	  } else {
	    var normalizedName = normalize(name);
	    if (Array.isArray(val)) {
	      // Support values array created by autoprefixer, e.g.
	      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
	      // Set them one by one, and the browser will only set those it can recognize
	      for (var i = 0, len = val.length; i < len; i++) {
	        el.style[normalizedName] = val[i];
	      }
	    } else {
	      el.style[normalizedName] = val;
	    }
	  }
	};
	
	var vendorNames = ['Webkit', 'Moz', 'ms'];
	
	var emptyStyle;
	var normalize = cached(function (prop) {
	  emptyStyle = emptyStyle || document.createElement('div').style;
	  prop = camelize(prop);
	  if (prop !== 'filter' && prop in emptyStyle) {
	    return prop;
	  }
	  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
	  for (var i = 0; i < vendorNames.length; i++) {
	    var name = vendorNames[i] + capName;
	    if (name in emptyStyle) {
	      return name;
	    }
	  }
	});
	
	function updateStyle(oldVnode, vnode) {
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	
	  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
	    return;
	  }
	
	  var cur, name;
	  var el = vnode.elm;
	  var oldStaticStyle = oldData.staticStyle;
	  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
	
	  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
	  var oldStyle = oldStaticStyle || oldStyleBinding;
	
	  var style = normalizeStyleBinding(vnode.data.style) || {};
	
	  // store normalized style under a different key for next diff
	  // make sure to clone it if it's reactive, since the user likley wants
	  // to mutate it.
	  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
	
	  var newStyle = getStyle(vnode, true);
	
	  for (name in oldStyle) {
	    if (isUndef(newStyle[name])) {
	      setProp(el, name, '');
	    }
	  }
	  for (name in newStyle) {
	    cur = newStyle[name];
	    if (cur !== oldStyle[name]) {
	      // ie9 setting to null has no effect, must use empty string
	      setProp(el, name, cur == null ? '' : cur);
	    }
	  }
	}
	
	var style = {
	  create: updateStyle,
	  update: updateStyle
	};
	
	/*  */
	
	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.add(c);
	      });
	    } else {
	      el.classList.add(cls);
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.remove(c);
	      });
	    } else {
	      el.classList.remove(cls);
	    }
	    if (!el.classList.length) {
	      el.removeAttribute('class');
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    cur = cur.trim();
	    if (cur) {
	      el.setAttribute('class', cur);
	    } else {
	      el.removeAttribute('class');
	    }
	  }
	}
	
	/*  */
	
	function resolveTransition(def$$1) {
	  if (!def$$1) {
	    return;
	  }
	  /* istanbul ignore else */
	  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
	    var res = {};
	    if (def$$1.css !== false) {
	      extend(res, autoCssTransition(def$$1.name || 'v'));
	    }
	    extend(res, def$$1);
	    return res;
	  } else if (typeof def$$1 === 'string') {
	    return autoCssTransition(def$$1);
	  }
	}
	
	var autoCssTransition = cached(function (name) {
	  return {
	    enterClass: name + "-enter",
	    enterToClass: name + "-enter-to",
	    enterActiveClass: name + "-enter-active",
	    leaveClass: name + "-leave",
	    leaveToClass: name + "-leave-to",
	    leaveActiveClass: name + "-leave-active"
	  };
	});
	
	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';
	
	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	  /* istanbul ignore if */
	  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
	    transitionProp = 'WebkitTransition';
	    transitionEndEvent = 'webkitTransitionEnd';
	  }
	  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
	    animationProp = 'WebkitAnimation';
	    animationEndEvent = 'webkitAnimationEnd';
	  }
	}
	
	// binding to window is necessary to make hot reload work in IE in strict mode
	var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;
	
	function nextFrame(fn) {
	  raf(function () {
	    raf(fn);
	  });
	}
	
	function addTransitionClass(el, cls) {
	  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
	  if (transitionClasses.indexOf(cls) < 0) {
	    transitionClasses.push(cls);
	    addClass(el, cls);
	  }
	}
	
	function removeTransitionClass(el, cls) {
	  if (el._transitionClasses) {
	    remove(el._transitionClasses, cls);
	  }
	  removeClass(el, cls);
	}
	
	function whenTransitionEnds(el, expectedType, cb) {
	  var ref = getTransitionInfo(el, expectedType);
	  var type = ref.type;
	  var timeout = ref.timeout;
	  var propCount = ref.propCount;
	  if (!type) {
	    return cb();
	  }
	  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	  var ended = 0;
	  var end = function end() {
	    el.removeEventListener(event, onEnd);
	    cb();
	  };
	  var onEnd = function onEnd(e) {
	    if (e.target === el) {
	      if (++ended >= propCount) {
	        end();
	      }
	    }
	  };
	  setTimeout(function () {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(event, onEnd);
	}
	
	var transformRE = /\b(transform|all)(,|$)/;
	
	function getTransitionInfo(el, expectedType) {
	  var styles = window.getComputedStyle(el);
	  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
	  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
	  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	  var animationDelays = styles[animationProp + 'Delay'].split(', ');
	  var animationDurations = styles[animationProp + 'Duration'].split(', ');
	  var animationTimeout = getTimeout(animationDelays, animationDurations);
	
	  var type;
	  var timeout = 0;
	  var propCount = 0;
	  /* istanbul ignore if */
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
	    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
	  }
	  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
	  return {
	    type: type,
	    timeout: timeout,
	    propCount: propCount,
	    hasTransform: hasTransform
	  };
	}
	
	function getTimeout(delays, durations) {
	  /* istanbul ignore next */
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }
	
	  return Math.max.apply(null, durations.map(function (d, i) {
	    return toMs(d) + toMs(delays[i]);
	  }));
	}
	
	function toMs(s) {
	  return Number(s.slice(0, -1)) * 1000;
	}
	
	/*  */
	
	function enter(vnode, toggleDisplay) {
	  var el = vnode.elm;
	
	  // call leave callback now
	  if (isDef(el._leaveCb)) {
	    el._leaveCb.cancelled = true;
	    el._leaveCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return;
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._enterCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var enterClass = data.enterClass;
	  var enterToClass = data.enterToClass;
	  var enterActiveClass = data.enterActiveClass;
	  var appearClass = data.appearClass;
	  var appearToClass = data.appearToClass;
	  var appearActiveClass = data.appearActiveClass;
	  var beforeEnter = data.beforeEnter;
	  var enter = data.enter;
	  var afterEnter = data.afterEnter;
	  var enterCancelled = data.enterCancelled;
	  var beforeAppear = data.beforeAppear;
	  var appear = data.appear;
	  var afterAppear = data.afterAppear;
	  var appearCancelled = data.appearCancelled;
	  var duration = data.duration;
	
	  // activeInstance will always be the <transition> component managing this
	  // transition. One edge case to check is when the <transition> is placed
	  // as the root node of a child component. In that case we need to check
	  // <transition>'s parent for appear check.
	  var context = activeInstance;
	  var transitionNode = activeInstance.$vnode;
	  while (transitionNode && transitionNode.parent) {
	    transitionNode = transitionNode.parent;
	    context = transitionNode.context;
	  }
	
	  var isAppear = !context._isMounted || !vnode.isRootInsert;
	
	  if (isAppear && !appear && appear !== '') {
	    return;
	  }
	
	  var startClass = isAppear && appearClass ? appearClass : enterClass;
	  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
	  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
	
	  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
	  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
	  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
	  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
	
	  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
	
	  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
	    checkDuration(explicitEnterDuration, 'enter', vnode);
	  }
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(enterHook);
	
	  var cb = el._enterCb = once(function () {
	    if (expectsCSS) {
	      removeTransitionClass(el, toClass);
	      removeTransitionClass(el, activeClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, startClass);
	      }
	      enterCancelledHook && enterCancelledHook(el);
	    } else {
	      afterEnterHook && afterEnterHook(el);
	    }
	    el._enterCb = null;
	  });
	
	  if (!vnode.data.show) {
	    // remove pending leave element on enter by injecting an insert hook
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
	      var parent = el.parentNode;
	      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
	        pendingNode.elm._leaveCb();
	      }
	      enterHook && enterHook(el, cb);
	    });
	  }
	
	  // start enter transition
	  beforeEnterHook && beforeEnterHook(el);
	  if (expectsCSS) {
	    addTransitionClass(el, startClass);
	    addTransitionClass(el, activeClass);
	    nextFrame(function () {
	      addTransitionClass(el, toClass);
	      removeTransitionClass(el, startClass);
	      if (!cb.cancelled && !userWantsControl) {
	        if (isValidDuration(explicitEnterDuration)) {
	          setTimeout(cb, explicitEnterDuration);
	        } else {
	          whenTransitionEnds(el, type, cb);
	        }
	      }
	    });
	  }
	
	  if (vnode.data.show) {
	    toggleDisplay && toggleDisplay();
	    enterHook && enterHook(el, cb);
	  }
	
	  if (!expectsCSS && !userWantsControl) {
	    cb();
	  }
	}
	
	function leave(vnode, rm) {
	  var el = vnode.elm;
	
	  // call enter callback now
	  if (isDef(el._enterCb)) {
	    el._enterCb.cancelled = true;
	    el._enterCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return rm();
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._leaveCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var leaveClass = data.leaveClass;
	  var leaveToClass = data.leaveToClass;
	  var leaveActiveClass = data.leaveActiveClass;
	  var beforeLeave = data.beforeLeave;
	  var leave = data.leave;
	  var afterLeave = data.afterLeave;
	  var leaveCancelled = data.leaveCancelled;
	  var delayLeave = data.delayLeave;
	  var duration = data.duration;
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(leave);
	
	  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
	
	  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
	    checkDuration(explicitLeaveDuration, 'leave', vnode);
	  }
	
	  var cb = el._leaveCb = once(function () {
	    if (el.parentNode && el.parentNode._pending) {
	      el.parentNode._pending[vnode.key] = null;
	    }
	    if (expectsCSS) {
	      removeTransitionClass(el, leaveToClass);
	      removeTransitionClass(el, leaveActiveClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, leaveClass);
	      }
	      leaveCancelled && leaveCancelled(el);
	    } else {
	      rm();
	      afterLeave && afterLeave(el);
	    }
	    el._leaveCb = null;
	  });
	
	  if (delayLeave) {
	    delayLeave(performLeave);
	  } else {
	    performLeave();
	  }
	
	  function performLeave() {
	    // the delayed leave may have already been cancelled
	    if (cb.cancelled) {
	      return;
	    }
	    // record leaving element
	    if (!vnode.data.show) {
	      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
	    }
	    beforeLeave && beforeLeave(el);
	    if (expectsCSS) {
	      addTransitionClass(el, leaveClass);
	      addTransitionClass(el, leaveActiveClass);
	      nextFrame(function () {
	        addTransitionClass(el, leaveToClass);
	        removeTransitionClass(el, leaveClass);
	        if (!cb.cancelled && !userWantsControl) {
	          if (isValidDuration(explicitLeaveDuration)) {
	            setTimeout(cb, explicitLeaveDuration);
	          } else {
	            whenTransitionEnds(el, type, cb);
	          }
	        }
	      });
	    }
	    leave && leave(el, cb);
	    if (!expectsCSS && !userWantsControl) {
	      cb();
	    }
	  }
	}
	
	// only used in dev mode
	function checkDuration(val, name, vnode) {
	  if (typeof val !== 'number') {
	    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
	  } else if (isNaN(val)) {
	    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
	  }
	}
	
	function isValidDuration(val) {
	  return typeof val === 'number' && !isNaN(val);
	}
	
	/**
	 * Normalize a transition hook's argument length. The hook may be:
	 * - a merged hook (invoker) with the original in .fns
	 * - a wrapped component method (check ._length)
	 * - a plain function (.length)
	 */
	function getHookArgumentsLength(fn) {
	  if (isUndef(fn)) {
	    return false;
	  }
	  var invokerFns = fn.fns;
	  if (isDef(invokerFns)) {
	    // invoker
	    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
	  } else {
	    return (fn._length || fn.length) > 1;
	  }
	}
	
	function _enter(_, vnode) {
	  if (vnode.data.show !== true) {
	    enter(vnode);
	  }
	}
	
	var transition = inBrowser ? {
	  create: _enter,
	  activate: _enter,
	  remove: function remove$$1(vnode, rm) {
	    /* istanbul ignore else */
	    if (vnode.data.show !== true) {
	      leave(vnode, rm);
	    } else {
	      rm();
	    }
	  }
	} : {};
	
	var platformModules = [attrs, klass, events, domProps, style, transition];
	
	/*  */
	
	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);
	
	var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
	
	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */
	
	var isTextInputType = makeMap('text,number,password,search,email,tel,url');
	
	/* istanbul ignore if */
	if (isIE9) {
	  // http://www.matts411.com/post/internet-explorer-9-oninput/
	  document.addEventListener('selectionchange', function () {
	    var el = document.activeElement;
	    if (el && el.vmodel) {
	      trigger(el, 'input');
	    }
	  });
	}
	
	var model$1 = {
	  inserted: function inserted(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      var cb = function cb() {
	        setSelected(el, binding, vnode.context);
	      };
	      cb();
	      /* istanbul ignore if */
	      if (isIE || isEdge) {
	        setTimeout(cb, 0);
	      }
	      el._vOptions = [].map.call(el.options, getValue);
	    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
	      el._vModifiers = binding.modifiers;
	      if (!binding.modifiers.lazy) {
	        // Safari < 10.2 & UIWebView doesn't fire compositionend when
	        // switching focus before confirming composition choice
	        // this also fixes the issue where some browsers e.g. iOS Chrome
	        // fires "change" instead of "input" on autocomplete.
	        el.addEventListener('change', onCompositionEnd);
	        if (!isAndroid) {
	          el.addEventListener('compositionstart', onCompositionStart);
	          el.addEventListener('compositionend', onCompositionEnd);
	        }
	        /* istanbul ignore if */
	        if (isIE9) {
	          el.vmodel = true;
	        }
	      }
	    }
	  },
	  componentUpdated: function componentUpdated(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      setSelected(el, binding, vnode.context);
	      // in case the options rendered by v-for have changed,
	      // it's possible that the value is out-of-sync with the rendered options.
	      // detect such cases and filter out values that no longer has a matching
	      // option in the DOM.
	      var prevOptions = el._vOptions;
	      var curOptions = el._vOptions = [].map.call(el.options, getValue);
	      if (curOptions.some(function (o, i) {
	        return !looseEqual(o, prevOptions[i]);
	      })) {
	        trigger(el, 'change');
	      }
	    }
	  }
	};
	
	function setSelected(el, binding, vm) {
	  var value = binding.value;
	  var isMultiple = el.multiple;
	  if (isMultiple && !Array.isArray(value)) {
	    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
	    return;
	  }
	  var selected, option;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    option = el.options[i];
	    if (isMultiple) {
	      selected = looseIndexOf(value, getValue(option)) > -1;
	      if (option.selected !== selected) {
	        option.selected = selected;
	      }
	    } else {
	      if (looseEqual(getValue(option), value)) {
	        if (el.selectedIndex !== i) {
	          el.selectedIndex = i;
	        }
	        return;
	      }
	    }
	  }
	  if (!isMultiple) {
	    el.selectedIndex = -1;
	  }
	}
	
	function getValue(option) {
	  return '_value' in option ? option._value : option.value;
	}
	
	function onCompositionStart(e) {
	  e.target.composing = true;
	}
	
	function onCompositionEnd(e) {
	  // prevent triggering an input event for no reason
	  if (!e.target.composing) {
	    return;
	  }
	  e.target.composing = false;
	  trigger(e.target, 'input');
	}
	
	function trigger(el, type) {
	  var e = document.createEvent('HTMLEvents');
	  e.initEvent(type, true, true);
	  el.dispatchEvent(e);
	}
	
	/*  */
	
	// recursively search for possible transition defined inside the component root
	function locateNode(vnode) {
	  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
	}
	
	var show = {
	  bind: function bind(el, ref, vnode) {
	    var value = ref.value;
	
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
	    if (value && transition$$1) {
	      vnode.data.show = true;
	      enter(vnode, function () {
	        el.style.display = originalDisplay;
	      });
	    } else {
	      el.style.display = value ? originalDisplay : 'none';
	    }
	  },
	
	  update: function update(el, ref, vnode) {
	    var value = ref.value;
	    var oldValue = ref.oldValue;
	
	    /* istanbul ignore if */
	    if (value === oldValue) {
	      return;
	    }
	    vnode = locateNode(vnode);
	    var transition$$1 = vnode.data && vnode.data.transition;
	    if (transition$$1) {
	      vnode.data.show = true;
	      if (value) {
	        enter(vnode, function () {
	          el.style.display = el.__vOriginalDisplay;
	        });
	      } else {
	        leave(vnode, function () {
	          el.style.display = 'none';
	        });
	      }
	    } else {
	      el.style.display = value ? el.__vOriginalDisplay : 'none';
	    }
	  },
	
	  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
	    if (!isDestroy) {
	      el.style.display = el.__vOriginalDisplay;
	    }
	  }
	};
	
	var platformDirectives = {
	  model: model$1,
	  show: show
	};
	
	/*  */
	
	// Provides transition support for a single element/component.
	// supports transition mode (out-in / in-out)
	
	var transitionProps = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  duration: [Number, String, Object]
	};
	
	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild(vnode) {
	  var compOptions = vnode && vnode.componentOptions;
	  if (compOptions && compOptions.Ctor.options.abstract) {
	    return getRealChild(getFirstComponentChild(compOptions.children));
	  } else {
	    return vnode;
	  }
	}
	
	function extractTransitionData(comp) {
	  var data = {};
	  var options = comp.$options;
	  // props
	  for (var key in options.propsData) {
	    data[key] = comp[key];
	  }
	  // events.
	  // extract listeners and pass them directly to the transition methods
	  var listeners = options._parentListeners;
	  for (var key$1 in listeners) {
	    data[camelize(key$1)] = listeners[key$1];
	  }
	  return data;
	}
	
	function placeholder(h, rawChild) {
	  if (/\d-keep-alive$/.test(rawChild.tag)) {
	    return h('keep-alive', {
	      props: rawChild.componentOptions.propsData
	    });
	  }
	}
	
	function hasParentTransition(vnode) {
	  while (vnode = vnode.parent) {
	    if (vnode.data.transition) {
	      return true;
	    }
	  }
	}
	
	function isSameChild(child, oldChild) {
	  return oldChild.key === child.key && oldChild.tag === child.tag;
	}
	
	function isAsyncPlaceholder(node) {
	  return node.isComment && node.asyncFactory;
	}
	
	var Transition = {
	  name: 'transition',
	  props: transitionProps,
	  abstract: true,
	
	  render: function render(h) {
	    var this$1 = this;
	
	    var children = this.$options._renderChildren;
	    if (!children) {
	      return;
	    }
	
	    // filter out text nodes (possible whitespaces)
	    children = children.filter(function (c) {
	      return c.tag || isAsyncPlaceholder(c);
	    });
	    /* istanbul ignore if */
	    if (!children.length) {
	      return;
	    }
	
	    // warn multiple elements
	    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
	      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
	    }
	
	    var mode = this.mode;
	
	    // warn invalid mode
	    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
	      warn('invalid <transition> mode: ' + mode, this.$parent);
	    }
	
	    var rawChild = children[0];
	
	    // if this is a component root node and the component's
	    // parent container node also has transition, skip.
	    if (hasParentTransition(this.$vnode)) {
	      return rawChild;
	    }
	
	    // apply transition data to child
	    // use getRealChild() to ignore abstract components e.g. keep-alive
	    var child = getRealChild(rawChild);
	    /* istanbul ignore if */
	    if (!child) {
	      return rawChild;
	    }
	
	    if (this._leaving) {
	      return placeholder(h, rawChild);
	    }
	
	    // ensure a key that is unique to the vnode type and to this transition
	    // component instance. This key will be used to remove pending leaving nodes
	    // during entering.
	    var id = "__transition-" + this._uid + "-";
	    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
	
	    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
	    var oldRawChild = this._vnode;
	    var oldChild = getRealChild(oldRawChild);
	
	    // mark v-show
	    // so that the transition module can hand over the control to the directive
	    if (child.data.directives && child.data.directives.some(function (d) {
	      return d.name === 'show';
	    })) {
	      child.data.show = true;
	    }
	
	    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
	      // replace old child transition data with fresh one
	      // important for dynamic transitions!
	      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
	      // handle transition mode
	      if (mode === 'out-in') {
	        // return placeholder node and queue update when leave finishes
	        this._leaving = true;
	        mergeVNodeHook(oldData, 'afterLeave', function () {
	          this$1._leaving = false;
	          this$1.$forceUpdate();
	        });
	        return placeholder(h, rawChild);
	      } else if (mode === 'in-out') {
	        if (isAsyncPlaceholder(child)) {
	          return oldRawChild;
	        }
	        var delayedLeave;
	        var performLeave = function performLeave() {
	          delayedLeave();
	        };
	        mergeVNodeHook(data, 'afterEnter', performLeave);
	        mergeVNodeHook(data, 'enterCancelled', performLeave);
	        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	          delayedLeave = leave;
	        });
	      }
	    }
	
	    return rawChild;
	  }
	};
	
	/*  */
	
	// Provides transition support for list items.
	// supports move transitions using the FLIP technique.
	
	// Because the vdom's children update algorithm is "unstable" - i.e.
	// it doesn't guarantee the relative positioning of removed elements,
	// we force transition-group to update its children into two passes:
	// in the first pass, we remove all nodes that need to be removed,
	// triggering their leaving transition; in the second pass, we insert/move
	// into the final desired state. This way in the second pass removed
	// nodes will remain where they should be.
	
	var props = extend({
	  tag: String,
	  moveClass: String
	}, transitionProps);
	
	delete props.mode;
	
	var TransitionGroup = {
	  props: props,
	
	  render: function render(h) {
	    var tag = this.tag || this.$vnode.data.tag || 'span';
	    var map = Object.create(null);
	    var prevChildren = this.prevChildren = this.children;
	    var rawChildren = this.$slots.default || [];
	    var children = this.children = [];
	    var transitionData = extractTransitionData(this);
	
	    for (var i = 0; i < rawChildren.length; i++) {
	      var c = rawChildren[i];
	      if (c.tag) {
	        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	          children.push(c);
	          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
	        } else if (process.env.NODE_ENV !== 'production') {
	          var opts = c.componentOptions;
	          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
	          warn("<transition-group> children must be keyed: <" + name + ">");
	        }
	      }
	    }
	
	    if (prevChildren) {
	      var kept = [];
	      var removed = [];
	      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
	        var c$1 = prevChildren[i$1];
	        c$1.data.transition = transitionData;
	        c$1.data.pos = c$1.elm.getBoundingClientRect();
	        if (map[c$1.key]) {
	          kept.push(c$1);
	        } else {
	          removed.push(c$1);
	        }
	      }
	      this.kept = h(tag, null, kept);
	      this.removed = removed;
	    }
	
	    return h(tag, null, children);
	  },
	
	  beforeUpdate: function beforeUpdate() {
	    // force removing pass
	    this.__patch__(this._vnode, this.kept, false, // hydrating
	    true // removeOnly (!important, avoids unnecessary moves)
	    );
	    this._vnode = this.kept;
	  },
	
	  updated: function updated() {
	    var children = this.prevChildren;
	    var moveClass = this.moveClass || (this.name || 'v') + '-move';
	    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	      return;
	    }
	
	    // we divide the work into three loops to avoid mixing DOM reads and writes
	    // in each iteration - which helps prevent layout thrashing.
	    children.forEach(callPendingCbs);
	    children.forEach(recordPosition);
	    children.forEach(applyTranslation);
	
	    // force reflow to put everything in position
	    var body = document.body;
	    var f = body.offsetHeight; // eslint-disable-line
	
	    children.forEach(function (c) {
	      if (c.data.moved) {
	        var el = c.elm;
	        var s = el.style;
	        addTransitionClass(el, moveClass);
	        s.transform = s.WebkitTransform = s.transitionDuration = '';
	        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
	          if (!e || /transform$/.test(e.propertyName)) {
	            el.removeEventListener(transitionEndEvent, cb);
	            el._moveCb = null;
	            removeTransitionClass(el, moveClass);
	          }
	        });
	      }
	    });
	  },
	
	  methods: {
	    hasMove: function hasMove(el, moveClass) {
	      /* istanbul ignore if */
	      if (!hasTransition) {
	        return false;
	      }
	      /* istanbul ignore if */
	      if (this._hasMove) {
	        return this._hasMove;
	      }
	      // Detect whether an element with the move class applied has
	      // CSS transitions. Since the element may be inside an entering
	      // transition at this very moment, we make a clone of it and remove
	      // all other transition classes applied to ensure only the move class
	      // is applied.
	      var clone = el.cloneNode();
	      if (el._transitionClasses) {
	        el._transitionClasses.forEach(function (cls) {
	          removeClass(clone, cls);
	        });
	      }
	      addClass(clone, moveClass);
	      clone.style.display = 'none';
	      this.$el.appendChild(clone);
	      var info = getTransitionInfo(clone);
	      this.$el.removeChild(clone);
	      return this._hasMove = info.hasTransform;
	    }
	  }
	};
	
	function callPendingCbs(c) {
	  /* istanbul ignore if */
	  if (c.elm._moveCb) {
	    c.elm._moveCb();
	  }
	  /* istanbul ignore if */
	  if (c.elm._enterCb) {
	    c.elm._enterCb();
	  }
	}
	
	function recordPosition(c) {
	  c.data.newPos = c.elm.getBoundingClientRect();
	}
	
	function applyTranslation(c) {
	  var oldPos = c.data.pos;
	  var newPos = c.data.newPos;
	  var dx = oldPos.left - newPos.left;
	  var dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    c.data.moved = true;
	    var s = c.elm.style;
	    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
	    s.transitionDuration = '0s';
	  }
	}
	
	var platformComponents = {
	  Transition: Transition,
	  TransitionGroup: TransitionGroup
	};
	
	/*  */
	
	// install platform specific utils
	Vue$3.config.mustUseProp = mustUseProp;
	Vue$3.config.isReservedTag = isReservedTag;
	Vue$3.config.isReservedAttr = isReservedAttr;
	Vue$3.config.getTagNamespace = getTagNamespace;
	Vue$3.config.isUnknownElement = isUnknownElement;
	
	// install platform runtime directives & components
	extend(Vue$3.options.directives, platformDirectives);
	extend(Vue$3.options.components, platformComponents);
	
	// install platform patch function
	Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
	
	// public mount method
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && inBrowser ? query(el) : undefined;
	  return mountComponent(this, el, hydrating);
	};
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue$3);
	    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
	      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
	    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
	  }
	}, 0);
	
	/*  */
	
	// check whether current browser encodes a char inside attribute values
	function shouldDecode(content, encoded) {
	  var div = document.createElement('div');
	  div.innerHTML = "<div a=\"" + content + "\"/>";
	  return div.innerHTML.indexOf(encoded) > 0;
	}
	
	// #3663
	// IE encodes newlines inside attribute values while other browsers don't
	var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;
	
	/*  */
	
	var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	
	var buildRegex = cached(function (delimiters) {
	  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
	  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
	  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
	});
	
	function parseText(text, delimiters) {
	  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
	  if (!tagRE.test(text)) {
	    return;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index;
	  while (match = tagRE.exec(text)) {
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
	    }
	    // tag token
	    var exp = parseFilters(match[1].trim());
	    tokens.push("_s(" + exp + ")");
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push(JSON.stringify(text.slice(lastIndex)));
	  }
	  return tokens.join('+');
	}
	
	/*  */
	
	function transformNode(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticClass = getAndRemoveAttr(el, 'class');
	  if (process.env.NODE_ENV !== 'production' && staticClass) {
	    var expression = parseText(staticClass, options.delimiters);
	    if (expression) {
	      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
	    }
	  }
	  if (staticClass) {
	    el.staticClass = JSON.stringify(staticClass);
	  }
	  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
	  if (classBinding) {
	    el.classBinding = classBinding;
	  }
	}
	
	function genData(el) {
	  var data = '';
	  if (el.staticClass) {
	    data += "staticClass:" + el.staticClass + ",";
	  }
	  if (el.classBinding) {
	    data += "class:" + el.classBinding + ",";
	  }
	  return data;
	}
	
	var klass$1 = {
	  staticKeys: ['staticClass'],
	  transformNode: transformNode,
	  genData: genData
	};
	
	/*  */
	
	function transformNode$1(el, options) {
	  var warn = options.warn || baseWarn;
	  var staticStyle = getAndRemoveAttr(el, 'style');
	  if (staticStyle) {
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      var expression = parseText(staticStyle, options.delimiters);
	      if (expression) {
	        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
	      }
	    }
	    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
	  }
	
	  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
	  if (styleBinding) {
	    el.styleBinding = styleBinding;
	  }
	}
	
	function genData$1(el) {
	  var data = '';
	  if (el.staticStyle) {
	    data += "staticStyle:" + el.staticStyle + ",";
	  }
	  if (el.styleBinding) {
	    data += "style:(" + el.styleBinding + "),";
	  }
	  return data;
	}
	
	var style$1 = {
	  staticKeys: ['staticStyle'],
	  transformNode: transformNode$1,
	  genData: genData$1
	};
	
	var modules$1 = [klass$1, style$1];
	
	/*  */
	
	function text(el, dir) {
	  if (dir.value) {
	    addProp(el, 'textContent', "_s(" + dir.value + ")");
	  }
	}
	
	/*  */
	
	function html(el, dir) {
	  if (dir.value) {
	    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
	  }
	}
	
	var directives$1 = {
	  model: model,
	  text: text,
	  html: html
	};
	
	/*  */
	
	var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');
	
	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
	
	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
	
	/*  */
	
	var baseOptions = {
	  expectHTML: true,
	  modules: modules$1,
	  directives: directives$1,
	  isPreTag: isPreTag,
	  isUnaryTag: isUnaryTag,
	  mustUseProp: mustUseProp,
	  canBeLeftOpenTag: canBeLeftOpenTag,
	  isReservedTag: isReservedTag,
	  getTagNamespace: getTagNamespace,
	  staticKeys: genStaticKeys(modules$1)
	};
	
	/*  */
	
	var decoder;
	
	var he = {
	  decode: function decode(html) {
	    decoder = decoder || document.createElement('div');
	    decoder.innerHTML = html;
	    return decoder.textContent;
	  }
	};
	
	/**
	 * Not type-checking this file because it's mostly vendor code.
	 */
	
	/*!
	 * HTML Parser By John Resig (ejohn.org)
	 * Modified by Juriy "kangax" Zaytsev
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 */
	
	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/;
	var singleAttrAssign = /(?:=)/;
	var singleAttrValues = [
	// attr value double quotes
	/"([^"]*)"+/.source,
	// attr value, single quotes
	/'([^']*)'+/.source,
	// attr value, no quotes
	/([^\s"'=<>`]+)/.source];
	var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');
	
	// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	// but for Vue templates we can enforce a simple charset
	var ncname = '[a-zA-Z_][\\w\\-\\.]*';
	var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
	var startTagOpen = new RegExp('^<' + qnameCapture);
	var startTagClose = /^\s*(\/?)>/;
	var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
	var doctype = /^<!DOCTYPE [^>]+>/i;
	var comment = /^<!--/;
	var conditionalComment = /^<!\[/;
	
	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function (m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});
	
	// Special Elements (can contain anything)
	var isPlainTextElement = makeMap('script,style,textarea', true);
	var reCache = {};
	
	var decodingMap = {
	  '&lt;': '<',
	  '&gt;': '>',
	  '&quot;': '"',
	  '&amp;': '&',
	  '&#10;': '\n'
	};
	var encodedAttr = /&(?:lt|gt|quot|amp);/g;
	var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;
	
	// #5992
	var isIgnoreNewlineTag = makeMap('pre,textarea', true);
	var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
	  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
	};
	
	function decodeAttr(value, shouldDecodeNewlines) {
	  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
	  return value.replace(re, function (match) {
	    return decodingMap[match];
	  });
	}
	
	function parseHTML(html, options) {
	  var stack = [];
	  var expectHTML = options.expectHTML;
	  var isUnaryTag$$1 = options.isUnaryTag || no;
	  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
	  var index = 0;
	  var last, lastTag;
	  while (html) {
	    last = html;
	    // Make sure we're not in a plaintext content element like script/style
	    if (!lastTag || !isPlainTextElement(lastTag)) {
	      var textEnd = html.indexOf('<');
	      if (textEnd === 0) {
	        // Comment:
	        if (comment.test(html)) {
	          var commentEnd = html.indexOf('-->');
	
	          if (commentEnd >= 0) {
	            if (options.shouldKeepComment) {
	              options.comment(html.substring(4, commentEnd));
	            }
	            advance(commentEnd + 3);
	            continue;
	          }
	        }
	
	        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	        if (conditionalComment.test(html)) {
	          var conditionalEnd = html.indexOf(']>');
	
	          if (conditionalEnd >= 0) {
	            advance(conditionalEnd + 2);
	            continue;
	          }
	        }
	
	        // Doctype:
	        var doctypeMatch = html.match(doctype);
	        if (doctypeMatch) {
	          advance(doctypeMatch[0].length);
	          continue;
	        }
	
	        // End tag:
	        var endTagMatch = html.match(endTag);
	        if (endTagMatch) {
	          var curIndex = index;
	          advance(endTagMatch[0].length);
	          parseEndTag(endTagMatch[1], curIndex, index);
	          continue;
	        }
	
	        // Start tag:
	        var startTagMatch = parseStartTag();
	        if (startTagMatch) {
	          handleStartTag(startTagMatch);
	          if (shouldIgnoreFirstNewline(lastTag, html)) {
	            advance(1);
	          }
	          continue;
	        }
	      }
	
	      var text = void 0,
	          rest = void 0,
	          next = void 0;
	      if (textEnd >= 0) {
	        rest = html.slice(textEnd);
	        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
	          // < in plain text, be forgiving and treat it as text
	          next = rest.indexOf('<', 1);
	          if (next < 0) {
	            break;
	          }
	          textEnd += next;
	          rest = html.slice(textEnd);
	        }
	        text = html.substring(0, textEnd);
	        advance(textEnd);
	      }
	
	      if (textEnd < 0) {
	        text = html;
	        html = '';
	      }
	
	      if (options.chars && text) {
	        options.chars(text);
	      }
	    } else {
	      var endTagLength = 0;
	      var stackedTag = lastTag.toLowerCase();
	      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
	      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
	        endTagLength = endTag.length;
	        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
	          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	        }
	        if (shouldIgnoreFirstNewline(stackedTag, text)) {
	          text = text.slice(1);
	        }
	        if (options.chars) {
	          options.chars(text);
	        }
	        return '';
	      });
	      index += html.length - rest$1.length;
	      html = rest$1;
	      parseEndTag(stackedTag, index - endTagLength, index);
	    }
	
	    if (html === last) {
	      options.chars && options.chars(html);
	      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
	        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
	      }
	      break;
	    }
	  }
	
	  // Clean up any remaining tags
	  parseEndTag();
	
	  function advance(n) {
	    index += n;
	    html = html.substring(n);
	  }
	
	  function parseStartTag() {
	    var start = html.match(startTagOpen);
	    if (start) {
	      var match = {
	        tagName: start[1],
	        attrs: [],
	        start: index
	      };
	      advance(start[0].length);
	      var end, attr;
	      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
	        advance(attr[0].length);
	        match.attrs.push(attr);
	      }
	      if (end) {
	        match.unarySlash = end[1];
	        advance(end[0].length);
	        match.end = index;
	        return match;
	      }
	    }
	  }
	
	  function handleStartTag(match) {
	    var tagName = match.tagName;
	    var unarySlash = match.unarySlash;
	
	    if (expectHTML) {
	      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
	        parseEndTag(lastTag);
	      }
	      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
	        parseEndTag(tagName);
	      }
	    }
	
	    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
	
	    var l = match.attrs.length;
	    var attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      var args = match.attrs[i];
	      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	        if (args[3] === '') {
	          delete args[3];
	        }
	        if (args[4] === '') {
	          delete args[4];
	        }
	        if (args[5] === '') {
	          delete args[5];
	        }
	      }
	      var value = args[3] || args[4] || args[5] || '';
	      attrs[i] = {
	        name: args[1],
	        value: decodeAttr(value, options.shouldDecodeNewlines)
	      };
	    }
	
	    if (!unary) {
	      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
	      lastTag = tagName;
	    }
	
	    if (options.start) {
	      options.start(tagName, attrs, unary, match.start, match.end);
	    }
	  }
	
	  function parseEndTag(tagName, start, end) {
	    var pos, lowerCasedTagName;
	    if (start == null) {
	      start = index;
	    }
	    if (end == null) {
	      end = index;
	    }
	
	    if (tagName) {
	      lowerCasedTagName = tagName.toLowerCase();
	    }
	
	    // Find the closest opened tag of the same type
	    if (tagName) {
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
	          break;
	        }
	      }
	    } else {
	      // If no tag name is provided, clean shop
	      pos = 0;
	    }
	
	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (var i = stack.length - 1; i >= pos; i--) {
	        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
	          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
	        }
	        if (options.end) {
	          options.end(stack[i].tag, start, end);
	        }
	      }
	
	      // Remove the open elements from the stack
	      stack.length = pos;
	      lastTag = pos && stack[pos - 1].tag;
	    } else if (lowerCasedTagName === 'br') {
	      if (options.start) {
	        options.start(tagName, [], true, start, end);
	      }
	    } else if (lowerCasedTagName === 'p') {
	      if (options.start) {
	        options.start(tagName, [], false, start, end);
	      }
	      if (options.end) {
	        options.end(tagName, start, end);
	      }
	    }
	  }
	}
	
	/*  */
	
	var onRE = /^@|^v-on:/;
	var dirRE = /^v-|^@|^:/;
	var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
	var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
	
	var argRE = /:(.*)$/;
	var bindRE = /^:|^v-bind:/;
	var modifierRE = /\.[^.]+/g;
	
	var decodeHTMLCached = cached(he.decode);
	
	// configurable state
	var warn$2;
	var delimiters;
	var transforms;
	var preTransforms;
	var postTransforms;
	var platformIsPreTag;
	var platformMustUseProp;
	var platformGetTagNamespace;
	
	/**
	 * Convert HTML string to AST.
	 */
	function parse(template, options) {
	  warn$2 = options.warn || baseWarn;
	
	  platformIsPreTag = options.isPreTag || no;
	  platformMustUseProp = options.mustUseProp || no;
	  platformGetTagNamespace = options.getTagNamespace || no;
	
	  transforms = pluckModuleFunction(options.modules, 'transformNode');
	  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
	  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
	
	  delimiters = options.delimiters;
	
	  var stack = [];
	  var preserveWhitespace = options.preserveWhitespace !== false;
	  var root;
	  var currentParent;
	  var inVPre = false;
	  var inPre = false;
	  var warned = false;
	
	  function warnOnce(msg) {
	    if (!warned) {
	      warned = true;
	      warn$2(msg);
	    }
	  }
	
	  function endPre(element) {
	    // check pre state
	    if (element.pre) {
	      inVPre = false;
	    }
	    if (platformIsPreTag(element.tag)) {
	      inPre = false;
	    }
	  }
	
	  parseHTML(template, {
	    warn: warn$2,
	    expectHTML: options.expectHTML,
	    isUnaryTag: options.isUnaryTag,
	    canBeLeftOpenTag: options.canBeLeftOpenTag,
	    shouldDecodeNewlines: options.shouldDecodeNewlines,
	    shouldKeepComment: options.comments,
	    start: function start(tag, attrs, unary) {
	      // check namespace.
	      // inherit parent ns if there is one
	      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);
	
	      // handle IE svg bug
	      /* istanbul ignore if */
	      if (isIE && ns === 'svg') {
	        attrs = guardIESVGBug(attrs);
	      }
	
	      var element = {
	        type: 1,
	        tag: tag,
	        attrsList: attrs,
	        attrsMap: makeAttrsMap(attrs),
	        parent: currentParent,
	        children: []
	      };
	      if (ns) {
	        element.ns = ns;
	      }
	
	      if (isForbiddenTag(element) && !isServerRendering()) {
	        element.forbidden = true;
	        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
	      }
	
	      // apply pre-transforms
	      for (var i = 0; i < preTransforms.length; i++) {
	        preTransforms[i](element, options);
	      }
	
	      if (!inVPre) {
	        processPre(element);
	        if (element.pre) {
	          inVPre = true;
	        }
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = true;
	      }
	      if (inVPre) {
	        processRawAttrs(element);
	      } else {
	        processFor(element);
	        processIf(element);
	        processOnce(element);
	        processKey(element);
	
	        // determine whether this is a plain element after
	        // removing structural attributes
	        element.plain = !element.key && !attrs.length;
	
	        processRef(element);
	        processSlot(element);
	        processComponent(element);
	        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
	          transforms[i$1](element, options);
	        }
	        processAttrs(element);
	      }
	
	      function checkRootConstraints(el) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (el.tag === 'slot' || el.tag === 'template') {
	            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
	          }
	          if (el.attrsMap.hasOwnProperty('v-for')) {
	            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
	          }
	        }
	      }
	
	      // tree management
	      if (!root) {
	        root = element;
	        checkRootConstraints(root);
	      } else if (!stack.length) {
	        // allow root elements with v-if, v-else-if and v-else
	        if (root.if && (element.elseif || element.else)) {
	          checkRootConstraints(element);
	          addIfCondition(root, {
	            exp: element.elseif,
	            block: element
	          });
	        } else if (process.env.NODE_ENV !== 'production') {
	          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
	        }
	      }
	      if (currentParent && !element.forbidden) {
	        if (element.elseif || element.else) {
	          processIfConditions(element, currentParent);
	        } else if (element.slotScope) {
	          // scoped slot
	          currentParent.plain = false;
	          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	        } else {
	          currentParent.children.push(element);
	          element.parent = currentParent;
	        }
	      }
	      if (!unary) {
	        currentParent = element;
	        stack.push(element);
	      } else {
	        endPre(element);
	      }
	      // apply post-transforms
	      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
	        postTransforms[i$2](element, options);
	      }
	    },
	
	    end: function end() {
	      // remove trailing whitespace
	      var element = stack[stack.length - 1];
	      var lastNode = element.children[element.children.length - 1];
	      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
	        element.children.pop();
	      }
	      // pop stack
	      stack.length -= 1;
	      currentParent = stack[stack.length - 1];
	      endPre(element);
	    },
	
	    chars: function chars(text) {
	      if (!currentParent) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (text === template) {
	            warnOnce('Component template requires a root element, rather than just text.');
	          } else if (text = text.trim()) {
	            warnOnce("text \"" + text + "\" outside root element will be ignored.");
	          }
	        }
	        return;
	      }
	      // IE textarea placeholder bug
	      /* istanbul ignore if */
	      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
	        return;
	      }
	      var children = currentParent.children;
	      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
	      // only preserve whitespace if its not right after a starting tag
	      : preserveWhitespace && children.length ? ' ' : '';
	      if (text) {
	        var expression;
	        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
	          children.push({
	            type: 2,
	            expression: expression,
	            text: text
	          });
	        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
	          children.push({
	            type: 3,
	            text: text
	          });
	        }
	      }
	    },
	    comment: function comment(text) {
	      currentParent.children.push({
	        type: 3,
	        text: text,
	        isComment: true
	      });
	    }
	  });
	  return root;
	}
	
	function processPre(el) {
	  if (getAndRemoveAttr(el, 'v-pre') != null) {
	    el.pre = true;
	  }
	}
	
	function processRawAttrs(el) {
	  var l = el.attrsList.length;
	  if (l) {
	    var attrs = el.attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      attrs[i] = {
	        name: el.attrsList[i].name,
	        value: JSON.stringify(el.attrsList[i].value)
	      };
	    }
	  } else if (!el.pre) {
	    // non root node in pre blocks with no attributes
	    el.plain = true;
	  }
	}
	
	function processKey(el) {
	  var exp = getBindingAttr(el, 'key');
	  if (exp) {
	    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
	      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
	    }
	    el.key = exp;
	  }
	}
	
	function processRef(el) {
	  var ref = getBindingAttr(el, 'ref');
	  if (ref) {
	    el.ref = ref;
	    el.refInFor = checkInFor(el);
	  }
	}
	
	function processFor(el) {
	  var exp;
	  if (exp = getAndRemoveAttr(el, 'v-for')) {
	    var inMatch = exp.match(forAliasRE);
	    if (!inMatch) {
	      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
	      return;
	    }
	    el.for = inMatch[2].trim();
	    var alias = inMatch[1].trim();
	    var iteratorMatch = alias.match(forIteratorRE);
	    if (iteratorMatch) {
	      el.alias = iteratorMatch[1].trim();
	      el.iterator1 = iteratorMatch[2].trim();
	      if (iteratorMatch[3]) {
	        el.iterator2 = iteratorMatch[3].trim();
	      }
	    } else {
	      el.alias = alias;
	    }
	  }
	}
	
	function processIf(el) {
	  var exp = getAndRemoveAttr(el, 'v-if');
	  if (exp) {
	    el.if = exp;
	    addIfCondition(el, {
	      exp: exp,
	      block: el
	    });
	  } else {
	    if (getAndRemoveAttr(el, 'v-else') != null) {
	      el.else = true;
	    }
	    var elseif = getAndRemoveAttr(el, 'v-else-if');
	    if (elseif) {
	      el.elseif = elseif;
	    }
	  }
	}
	
	function processIfConditions(el, parent) {
	  var prev = findPrevElement(parent.children);
	  if (prev && prev.if) {
	    addIfCondition(prev, {
	      exp: el.elseif,
	      block: el
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
	  }
	}
	
	function findPrevElement(children) {
	  var i = children.length;
	  while (i--) {
	    if (children[i].type === 1) {
	      return children[i];
	    } else {
	      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
	        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
	      }
	      children.pop();
	    }
	  }
	}
	
	function addIfCondition(el, condition) {
	  if (!el.ifConditions) {
	    el.ifConditions = [];
	  }
	  el.ifConditions.push(condition);
	}
	
	function processOnce(el) {
	  var once$$1 = getAndRemoveAttr(el, 'v-once');
	  if (once$$1 != null) {
	    el.once = true;
	  }
	}
	
	function processSlot(el) {
	  if (el.tag === 'slot') {
	    el.slotName = getBindingAttr(el, 'name');
	    if (process.env.NODE_ENV !== 'production' && el.key) {
	      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
	    }
	  } else {
	    var slotTarget = getBindingAttr(el, 'slot');
	    if (slotTarget) {
	      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
	    }
	    if (el.tag === 'template') {
	      el.slotScope = getAndRemoveAttr(el, 'scope');
	    }
	  }
	}
	
	function processComponent(el) {
	  var binding;
	  if (binding = getBindingAttr(el, 'is')) {
	    el.component = binding;
	  }
	  if (getAndRemoveAttr(el, 'inline-template') != null) {
	    el.inlineTemplate = true;
	  }
	}
	
	function processAttrs(el) {
	  var list = el.attrsList;
	  var i, l, name, rawName, value, modifiers, isProp;
	  for (i = 0, l = list.length; i < l; i++) {
	    name = rawName = list[i].name;
	    value = list[i].value;
	    if (dirRE.test(name)) {
	      // mark element as dynamic
	      el.hasBindings = true;
	      // modifiers
	      modifiers = parseModifiers(name);
	      if (modifiers) {
	        name = name.replace(modifierRE, '');
	      }
	      if (bindRE.test(name)) {
	        // v-bind
	        name = name.replace(bindRE, '');
	        value = parseFilters(value);
	        isProp = false;
	        if (modifiers) {
	          if (modifiers.prop) {
	            isProp = true;
	            name = camelize(name);
	            if (name === 'innerHtml') {
	              name = 'innerHTML';
	            }
	          }
	          if (modifiers.camel) {
	            name = camelize(name);
	          }
	          if (modifiers.sync) {
	            addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
	          }
	        }
	        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
	          addProp(el, name, value);
	        } else {
	          addAttr(el, name, value);
	        }
	      } else if (onRE.test(name)) {
	        // v-on
	        name = name.replace(onRE, '');
	        addHandler(el, name, value, modifiers, false, warn$2);
	      } else {
	        // normal directives
	        name = name.replace(dirRE, '');
	        // parse arg
	        var argMatch = name.match(argRE);
	        var arg = argMatch && argMatch[1];
	        if (arg) {
	          name = name.slice(0, -(arg.length + 1));
	        }
	        addDirective(el, name, rawName, value, arg, modifiers);
	        if (process.env.NODE_ENV !== 'production' && name === 'model') {
	          checkForAliasModel(el, value);
	        }
	      }
	    } else {
	      // literal attribute
	      if (process.env.NODE_ENV !== 'production') {
	        var expression = parseText(value, delimiters);
	        if (expression) {
	          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
	        }
	      }
	      addAttr(el, name, JSON.stringify(value));
	    }
	  }
	}
	
	function checkInFor(el) {
	  var parent = el;
	  while (parent) {
	    if (parent.for !== undefined) {
	      return true;
	    }
	    parent = parent.parent;
	  }
	  return false;
	}
	
	function parseModifiers(name) {
	  var match = name.match(modifierRE);
	  if (match) {
	    var ret = {};
	    match.forEach(function (m) {
	      ret[m.slice(1)] = true;
	    });
	    return ret;
	  }
	}
	
	function makeAttrsMap(attrs) {
	  var map = {};
	  for (var i = 0, l = attrs.length; i < l; i++) {
	    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
	      warn$2('duplicate attribute: ' + attrs[i].name);
	    }
	    map[attrs[i].name] = attrs[i].value;
	  }
	  return map;
	}
	
	// for script (e.g. type="x/template") or style, do not decode content
	function isTextTag(el) {
	  return el.tag === 'script' || el.tag === 'style';
	}
	
	function isForbiddenTag(el) {
	  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
	}
	
	var ieNSBug = /^xmlns:NS\d+/;
	var ieNSPrefix = /^NS\d+:/;
	
	/* istanbul ignore next */
	function guardIESVGBug(attrs) {
	  var res = [];
	  for (var i = 0; i < attrs.length; i++) {
	    var attr = attrs[i];
	    if (!ieNSBug.test(attr.name)) {
	      attr.name = attr.name.replace(ieNSPrefix, '');
	      res.push(attr);
	    }
	  }
	  return res;
	}
	
	function checkForAliasModel(el, value) {
	  var _el = el;
	  while (_el) {
	    if (_el.for && _el.alias === value) {
	      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
	    }
	    _el = _el.parent;
	  }
	}
	
	/*  */
	
	var isStaticKey;
	var isPlatformReservedTag;
	
	var genStaticKeysCached = cached(genStaticKeys$1);
	
	/**
	 * Goal of the optimizer: walk the generated template AST tree
	 * and detect sub-trees that are purely static, i.e. parts of
	 * the DOM that never needs to change.
	 *
	 * Once we detect these sub-trees, we can:
	 *
	 * 1. Hoist them into constants, so that we no longer need to
	 *    create fresh nodes for them on each re-render;
	 * 2. Completely skip them in the patching process.
	 */
	function optimize(root, options) {
	  if (!root) {
	    return;
	  }
	  isStaticKey = genStaticKeysCached(options.staticKeys || '');
	  isPlatformReservedTag = options.isReservedTag || no;
	  // first pass: mark all non-static nodes.
	  markStatic$1(root);
	  // second pass: mark static roots.
	  markStaticRoots(root, false);
	}
	
	function genStaticKeys$1(keys) {
	  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
	}
	
	function markStatic$1(node) {
	  node.static = isStatic(node);
	  if (node.type === 1) {
	    // do not make component slot content static. this avoids
	    // 1. components not able to mutate slot nodes
	    // 2. static slot content fails for hot-reloading
	    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
	      return;
	    }
	    for (var i = 0, l = node.children.length; i < l; i++) {
	      var child = node.children[i];
	      markStatic$1(child);
	      if (!child.static) {
	        node.static = false;
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        var block = node.ifConditions[i$1].block;
	        markStatic$1(block);
	        if (!block.static) {
	          node.static = false;
	        }
	      }
	    }
	  }
	}
	
	function markStaticRoots(node, isInFor) {
	  if (node.type === 1) {
	    if (node.static || node.once) {
	      node.staticInFor = isInFor;
	    }
	    // For a node to qualify as a static root, it should have children that
	    // are not just static text. Otherwise the cost of hoisting out will
	    // outweigh the benefits and it's better off to just always render it fresh.
	    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
	      node.staticRoot = true;
	      return;
	    } else {
	      node.staticRoot = false;
	    }
	    if (node.children) {
	      for (var i = 0, l = node.children.length; i < l; i++) {
	        markStaticRoots(node.children[i], isInFor || !!node.for);
	      }
	    }
	    if (node.ifConditions) {
	      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
	        markStaticRoots(node.ifConditions[i$1].block, isInFor);
	      }
	    }
	  }
	}
	
	function isStatic(node) {
	  if (node.type === 2) {
	    // expression
	    return false;
	  }
	  if (node.type === 3) {
	    // text
	    return true;
	  }
	  return !!(node.pre || !node.hasBindings && // no dynamic bindings
	  !node.if && !node.for && // not v-if or v-for or v-else
	  !isBuiltInTag(node.tag) && // not a built-in
	  isPlatformReservedTag(node.tag) && // not a component
	  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
	}
	
	function isDirectChildOfTemplateFor(node) {
	  while (node.parent) {
	    node = node.parent;
	    if (node.tag !== 'template') {
	      return false;
	    }
	    if (node.for) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
	var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  'delete': [8, 46]
	};
	
	// #4868: modifiers that prevent the execution of the listener
	// need to explicitly return null so that we can determine whether to remove
	// the listener for .once
	var genGuard = function genGuard(condition) {
	  return "if(" + condition + ")return null;";
	};
	
	var modifierCode = {
	  stop: '$event.stopPropagation();',
	  prevent: '$event.preventDefault();',
	  self: genGuard("$event.target !== $event.currentTarget"),
	  ctrl: genGuard("!$event.ctrlKey"),
	  shift: genGuard("!$event.shiftKey"),
	  alt: genGuard("!$event.altKey"),
	  meta: genGuard("!$event.metaKey"),
	  left: genGuard("'button' in $event && $event.button !== 0"),
	  middle: genGuard("'button' in $event && $event.button !== 1"),
	  right: genGuard("'button' in $event && $event.button !== 2")
	};
	
	function genHandlers(events, isNative, warn) {
	  var res = isNative ? 'nativeOn:{' : 'on:{';
	  for (var name in events) {
	    var handler = events[name];
	    // #5330: warn click.right, since right clicks do not actually fire click events.
	    if (process.env.NODE_ENV !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {
	      warn("Use \"contextmenu\" instead of \"click.right\" since right clicks " + "do not actually fire \"click\" events.");
	    }
	    res += "\"" + name + "\":" + genHandler(name, handler) + ",";
	  }
	  return res.slice(0, -1) + '}';
	}
	
	function genHandler(name, handler) {
	  if (!handler) {
	    return 'function(){}';
	  }
	
	  if (Array.isArray(handler)) {
	    return "[" + handler.map(function (handler) {
	      return genHandler(name, handler);
	    }).join(',') + "]";
	  }
	
	  var isMethodPath = simplePathRE.test(handler.value);
	  var isFunctionExpression = fnExpRE.test(handler.value);
	
	  if (!handler.modifiers) {
	    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
	  } else {
	    var code = '';
	    var genModifierCode = '';
	    var keys = [];
	    for (var key in handler.modifiers) {
	      if (modifierCode[key]) {
	        genModifierCode += modifierCode[key];
	        // left/right
	        if (keyCodes[key]) {
	          keys.push(key);
	        }
	      } else {
	        keys.push(key);
	      }
	    }
	    if (keys.length) {
	      code += genKeyFilter(keys);
	    }
	    // Make sure modifiers like prevent and stop get executed after key filtering
	    if (genModifierCode) {
	      code += genModifierCode;
	    }
	    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
	    return "function($event){" + code + handlerCode + "}";
	  }
	}
	
	function genKeyFilter(keys) {
	  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
	}
	
	function genFilterCode(key) {
	  var keyVal = parseInt(key, 10);
	  if (keyVal) {
	    return "$event.keyCode!==" + keyVal;
	  }
	  var alias = keyCodes[key];
	  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
	}
	
	/*  */
	
	function on(el, dir) {
	  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {
	    warn("v-on without argument does not support modifiers.");
	  }
	  el.wrapListeners = function (code) {
	    return "_g(" + code + "," + dir.value + ")";
	  };
	}
	
	/*  */
	
	function bind$1(el, dir) {
	  el.wrapData = function (code) {
	    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
	  };
	}
	
	/*  */
	
	var baseDirectives = {
	  on: on,
	  bind: bind$1,
	  cloak: noop
	};
	
	/*  */
	
	var CodegenState = function CodegenState(options) {
	  this.options = options;
	  this.warn = options.warn || baseWarn;
	  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
	  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
	  this.directives = extend(extend({}, baseDirectives), options.directives);
	  var isReservedTag = options.isReservedTag || no;
	  this.maybeComponent = function (el) {
	    return !isReservedTag(el.tag);
	  };
	  this.onceId = 0;
	  this.staticRenderFns = [];
	};
	
	function generate(ast, options) {
	  var state = new CodegenState(options);
	  var code = ast ? genElement(ast, state) : '_c("div")';
	  return {
	    render: "with(this){return " + code + "}",
	    staticRenderFns: state.staticRenderFns
	  };
	}
	
	function genElement(el, state) {
	  if (el.staticRoot && !el.staticProcessed) {
	    return genStatic(el, state);
	  } else if (el.once && !el.onceProcessed) {
	    return genOnce(el, state);
	  } else if (el.for && !el.forProcessed) {
	    return genFor(el, state);
	  } else if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.tag === 'template' && !el.slotTarget) {
	    return genChildren(el, state) || 'void 0';
	  } else if (el.tag === 'slot') {
	    return genSlot(el, state);
	  } else {
	    // component or element
	    var code;
	    if (el.component) {
	      code = genComponent(el.component, el, state);
	    } else {
	      var data = el.plain ? undefined : genData$2(el, state);
	
	      var children = el.inlineTemplate ? null : genChildren(el, state, true);
	      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
	    }
	    // module transforms
	    for (var i = 0; i < state.transforms.length; i++) {
	      code = state.transforms[i](el, code);
	    }
	    return code;
	  }
	}
	
	// hoist static sub-trees out
	function genStatic(el, state) {
	  el.staticProcessed = true;
	  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
	  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
	}
	
	// v-once
	function genOnce(el, state) {
	  el.onceProcessed = true;
	  if (el.if && !el.ifProcessed) {
	    return genIf(el, state);
	  } else if (el.staticInFor) {
	    var key = '';
	    var parent = el.parent;
	    while (parent) {
	      if (parent.for) {
	        key = parent.key;
	        break;
	      }
	      parent = parent.parent;
	    }
	    if (!key) {
	      process.env.NODE_ENV !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
	      return genElement(el, state);
	    }
	    return "_o(" + genElement(el, state) + "," + state.onceId++ + (key ? "," + key : "") + ")";
	  } else {
	    return genStatic(el, state);
	  }
	}
	
	function genIf(el, state, altGen, altEmpty) {
	  el.ifProcessed = true; // avoid recursion
	  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
	}
	
	function genIfConditions(conditions, state, altGen, altEmpty) {
	  if (!conditions.length) {
	    return altEmpty || '_e()';
	  }
	
	  var condition = conditions.shift();
	  if (condition.exp) {
	    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
	  } else {
	    return "" + genTernaryExp(condition.block);
	  }
	
	  // v-if with v-once should generate code like (a)?_m(0):_m(1)
	  function genTernaryExp(el) {
	    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
	  }
	}
	
	function genFor(el, state, altGen, altHelper) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	
	  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
	    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
	    );
	  }
	
	  el.forProcessed = true; // avoid recursion
	  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
	}
	
	function genData$2(el, state) {
	  var data = '{';
	
	  // directives first.
	  // directives may mutate the el's other properties before they are generated.
	  var dirs = genDirectives(el, state);
	  if (dirs) {
	    data += dirs + ',';
	  }
	
	  // key
	  if (el.key) {
	    data += "key:" + el.key + ",";
	  }
	  // ref
	  if (el.ref) {
	    data += "ref:" + el.ref + ",";
	  }
	  if (el.refInFor) {
	    data += "refInFor:true,";
	  }
	  // pre
	  if (el.pre) {
	    data += "pre:true,";
	  }
	  // record original tag name for components using "is" attribute
	  if (el.component) {
	    data += "tag:\"" + el.tag + "\",";
	  }
	  // module data generation functions
	  for (var i = 0; i < state.dataGenFns.length; i++) {
	    data += state.dataGenFns[i](el);
	  }
	  // attributes
	  if (el.attrs) {
	    data += "attrs:{" + genProps(el.attrs) + "},";
	  }
	  // DOM props
	  if (el.props) {
	    data += "domProps:{" + genProps(el.props) + "},";
	  }
	  // event handlers
	  if (el.events) {
	    data += genHandlers(el.events, false, state.warn) + ",";
	  }
	  if (el.nativeEvents) {
	    data += genHandlers(el.nativeEvents, true, state.warn) + ",";
	  }
	  // slot target
	  if (el.slotTarget) {
	    data += "slot:" + el.slotTarget + ",";
	  }
	  // scoped slots
	  if (el.scopedSlots) {
	    data += genScopedSlots(el.scopedSlots, state) + ",";
	  }
	  // component v-model
	  if (el.model) {
	    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
	  }
	  // inline-template
	  if (el.inlineTemplate) {
	    var inlineTemplate = genInlineTemplate(el, state);
	    if (inlineTemplate) {
	      data += inlineTemplate + ",";
	    }
	  }
	  data = data.replace(/,$/, '') + '}';
	  // v-bind data wrap
	  if (el.wrapData) {
	    data = el.wrapData(data);
	  }
	  // v-on data wrap
	  if (el.wrapListeners) {
	    data = el.wrapListeners(data);
	  }
	  return data;
	}
	
	function genDirectives(el, state) {
	  var dirs = el.directives;
	  if (!dirs) {
	    return;
	  }
	  var res = 'directives:[';
	  var hasRuntime = false;
	  var i, l, dir, needRuntime;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    dir = dirs[i];
	    needRuntime = true;
	    var gen = state.directives[dir.name];
	    if (gen) {
	      // compile-time directive that manipulates AST.
	      // returns true if it also needs a runtime counterpart.
	      needRuntime = !!gen(el, dir, state.warn);
	    }
	    if (needRuntime) {
	      hasRuntime = true;
	      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
	    }
	  }
	  if (hasRuntime) {
	    return res.slice(0, -1) + ']';
	  }
	}
	
	function genInlineTemplate(el, state) {
	  var ast = el.children[0];
	  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
	    state.warn('Inline-template components must have exactly one child element.');
	  }
	  if (ast.type === 1) {
	    var inlineRenderFns = generate(ast, state.options);
	    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
	      return "function(){" + code + "}";
	    }).join(',') + "]}";
	  }
	}
	
	function genScopedSlots(slots, state) {
	  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
	    return genScopedSlot(key, slots[key], state);
	  }).join(',') + "])";
	}
	
	function genScopedSlot(key, el, state) {
	  if (el.for && !el.forProcessed) {
	    return genForScopedSlot(key, el, state);
	  }
	  return "{key:" + key + ",fn:function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + "}}";
	}
	
	function genForScopedSlot(key, el, state) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
	  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
	  el.forProcessed = true; // avoid recursion
	  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
	}
	
	function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
	  var children = el.children;
	  if (children.length) {
	    var el$1 = children[0];
	    // optimize single v-for
	    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
	      return (altGenElement || genElement)(el$1, state);
	    }
	    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
	    var gen = altGenNode || genNode;
	    return "[" + children.map(function (c) {
	      return gen(c, state);
	    }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
	  }
	}
	
	// determine the normalization needed for the children array.
	// 0: no normalization needed
	// 1: simple normalization needed (possible 1-level deep nested array)
	// 2: full normalization needed
	function getNormalizationType(children, maybeComponent) {
	  var res = 0;
	  for (var i = 0; i < children.length; i++) {
	    var el = children[i];
	    if (el.type !== 1) {
	      continue;
	    }
	    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return needsNormalization(c.block);
	    })) {
	      res = 2;
	      break;
	    }
	    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
	      return maybeComponent(c.block);
	    })) {
	      res = 1;
	    }
	  }
	  return res;
	}
	
	function needsNormalization(el) {
	  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
	}
	
	function genNode(node, state) {
	  if (node.type === 1) {
	    return genElement(node, state);
	  }if (node.type === 3 && node.isComment) {
	    return genComment(node);
	  } else {
	    return genText(node);
	  }
	}
	
	function genText(text) {
	  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
	  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
	}
	
	function genComment(comment) {
	  return "_e(" + JSON.stringify(comment.text) + ")";
	}
	
	function genSlot(el, state) {
	  var slotName = el.slotName || '"default"';
	  var children = genChildren(el, state);
	  var res = "_t(" + slotName + (children ? "," + children : '');
	  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
	    return camelize(a.name) + ":" + a.value;
	  }).join(',') + "}";
	  var bind$$1 = el.attrsMap['v-bind'];
	  if ((attrs || bind$$1) && !children) {
	    res += ",null";
	  }
	  if (attrs) {
	    res += "," + attrs;
	  }
	  if (bind$$1) {
	    res += (attrs ? '' : ',null') + "," + bind$$1;
	  }
	  return res + ')';
	}
	
	// componentName is el.component, take it as argument to shun flow's pessimistic refinement
	function genComponent(componentName, el, state) {
	  var children = el.inlineTemplate ? null : genChildren(el, state, true);
	  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
	}
	
	function genProps(props) {
	  var res = '';
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
	  }
	  return res.slice(0, -1);
	}
	
	// #3895, #4268
	function transformSpecialNewlines(text) {
	  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
	}
	
	/*  */
	
	// these keywords should not appear inside expressions, but operators like
	// typeof, instanceof and in are allowed
	var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');
	
	// these unary operators should not be used as property/method names
	var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');
	
	// check valid identifier for v-for
	var identRE = /[A-Za-z_$][\w$]*/;
	
	// strip strings in expressions
	var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
	
	// detect problematic expressions in a template
	function detectErrors(ast) {
	  var errors = [];
	  if (ast) {
	    checkNode(ast, errors);
	  }
	  return errors;
	}
	
	function checkNode(node, errors) {
	  if (node.type === 1) {
	    for (var name in node.attrsMap) {
	      if (dirRE.test(name)) {
	        var value = node.attrsMap[name];
	        if (value) {
	          if (name === 'v-for') {
	            checkFor(node, "v-for=\"" + value + "\"", errors);
	          } else if (onRE.test(name)) {
	            checkEvent(value, name + "=\"" + value + "\"", errors);
	          } else {
	            checkExpression(value, name + "=\"" + value + "\"", errors);
	          }
	        }
	      }
	    }
	    if (node.children) {
	      for (var i = 0; i < node.children.length; i++) {
	        checkNode(node.children[i], errors);
	      }
	    }
	  } else if (node.type === 2) {
	    checkExpression(node.expression, node.text, errors);
	  }
	}
	
	function checkEvent(exp, text, errors) {
	  var stipped = exp.replace(stripStringRE, '');
	  var keywordMatch = stipped.match(unaryOperatorsRE);
	  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
	    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	  }
	  checkExpression(exp, text, errors);
	}
	
	function checkFor(node, text, errors) {
	  checkExpression(node.for || '', text, errors);
	  checkIdentifier(node.alias, 'v-for alias', text, errors);
	  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
	  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
	}
	
	function checkIdentifier(ident, type, text, errors) {
	  if (typeof ident === 'string' && !identRE.test(ident)) {
	    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
	  }
	}
	
	function checkExpression(exp, text, errors) {
	  try {
	    new Function("return " + exp);
	  } catch (e) {
	    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
	    if (keywordMatch) {
	      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
	    } else {
	      errors.push("invalid expression: " + text.trim());
	    }
	  }
	}
	
	/*  */
	
	function createFunction(code, errors) {
	  try {
	    return new Function(code);
	  } catch (err) {
	    errors.push({ err: err, code: code });
	    return noop;
	  }
	}
	
	function createCompileToFunctionFn(compile) {
	  var cache = Object.create(null);
	
	  return function compileToFunctions(template, options, vm) {
	    options = options || {};
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      // detect possible CSP restriction
	      try {
	        new Function('return 1');
	      } catch (e) {
	        if (e.toString().match(/unsafe-eval|CSP/)) {
	          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
	        }
	      }
	    }
	
	    // check cache
	    var key = options.delimiters ? String(options.delimiters) + template : template;
	    if (cache[key]) {
	      return cache[key];
	    }
	
	    // compile
	    var compiled = compile(template, options);
	
	    // check compilation errors/tips
	    if (process.env.NODE_ENV !== 'production') {
	      if (compiled.errors && compiled.errors.length) {
	        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
	          return "- " + e;
	        }).join('\n') + '\n', vm);
	      }
	      if (compiled.tips && compiled.tips.length) {
	        compiled.tips.forEach(function (msg) {
	          return tip(msg, vm);
	        });
	      }
	    }
	
	    // turn code into functions
	    var res = {};
	    var fnGenErrors = [];
	    res.render = createFunction(compiled.render, fnGenErrors);
	    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
	      return createFunction(code, fnGenErrors);
	    });
	
	    // check function generation errors.
	    // this should only happen if there is a bug in the compiler itself.
	    // mostly for codegen development use
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production') {
	      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
	        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
	          var err = ref.err;
	          var code = ref.code;
	
	          return err.toString() + " in\n\n" + code + "\n";
	        }).join('\n'), vm);
	      }
	    }
	
	    return cache[key] = res;
	  };
	}
	
	/*  */
	
	function createCompilerCreator(baseCompile) {
	  return function createCompiler(baseOptions) {
	    function compile(template, options) {
	      var finalOptions = Object.create(baseOptions);
	      var errors = [];
	      var tips = [];
	      finalOptions.warn = function (msg, tip) {
	        (tip ? tips : errors).push(msg);
	      };
	
	      if (options) {
	        // merge custom modules
	        if (options.modules) {
	          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
	        }
	        // merge custom directives
	        if (options.directives) {
	          finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
	        }
	        // copy other options
	        for (var key in options) {
	          if (key !== 'modules' && key !== 'directives') {
	            finalOptions[key] = options[key];
	          }
	        }
	      }
	
	      var compiled = baseCompile(template, finalOptions);
	      if (process.env.NODE_ENV !== 'production') {
	        errors.push.apply(errors, detectErrors(compiled.ast));
	      }
	      compiled.errors = errors;
	      compiled.tips = tips;
	      return compiled;
	    }
	
	    return {
	      compile: compile,
	      compileToFunctions: createCompileToFunctionFn(compile)
	    };
	  };
	}
	
	/*  */
	
	// `createCompilerCreator` allows creating compilers that use alternative
	// parser/optimizer/codegen, e.g the SSR optimizing compiler.
	// Here we just export a default compiler using the default parts.
	var createCompiler = createCompilerCreator(function baseCompile(template, options) {
	  var ast = parse(template.trim(), options);
	  optimize(ast, options);
	  var code = generate(ast, options);
	  return {
	    ast: ast,
	    render: code.render,
	    staticRenderFns: code.staticRenderFns
	  };
	});
	
	/*  */
	
	var ref$1 = createCompiler(baseOptions);
	var compileToFunctions = ref$1.compileToFunctions;
	
	/*  */
	
	var idToTemplate = cached(function (id) {
	  var el = query(id);
	  return el && el.innerHTML;
	});
	
	var mount = Vue$3.prototype.$mount;
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && query(el);
	
	  /* istanbul ignore if */
	  if (el === document.body || el === document.documentElement) {
	    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
	    return this;
	  }
	
	  var options = this.$options;
	  // resolve template/el and convert to render function
	  if (!options.render) {
	    var template = options.template;
	    if (template) {
	      if (typeof template === 'string') {
	        if (template.charAt(0) === '#') {
	          template = idToTemplate(template);
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !template) {
	            warn("Template element not found or is empty: " + options.template, this);
	          }
	        }
	      } else if (template.nodeType) {
	        template = template.innerHTML;
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          warn('invalid template option:' + template, this);
	        }
	        return this;
	      }
	    } else if (el) {
	      template = getOuterHTML(el);
	    }
	    if (template) {
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile');
	      }
	
	      var ref = compileToFunctions(template, {
	        shouldDecodeNewlines: shouldDecodeNewlines,
	        delimiters: options.delimiters,
	        comments: options.comments
	      }, this);
	      var render = ref.render;
	      var staticRenderFns = ref.staticRenderFns;
	      options.render = render;
	      options.staticRenderFns = staticRenderFns;
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        mark('compile end');
	        measure(this._name + " compile", 'compile', 'compile end');
	      }
	    }
	  }
	  return mount.call(this, el, hydrating);
	};
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 */
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	Vue$3.compile = compileToFunctions;
	
	exports.default = Vue$3;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) {
	    return [];
	};
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, module) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
	 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	
	(function (definition) {
	    "use strict";
	
	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.
	
	    // Montage Require
	
	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);
	
	        // CommonJS
	    } else if (( false ? "undefined" : _typeof(exports)) === "object" && ( false ? "undefined" : _typeof(module)) === "object") {
	        module.exports = definition();
	
	        // RequireJS
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	        // SES (Secure EcmaScript)
	    } else if (typeof ses !== "undefined") {
	        if (!ses.ok()) {
	            return;
	        } else {
	            ses.makeQ = definition;
	        }
	
	        // <script>
	    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
	        // Prefer window over self for add-on scripts. Use self for
	        // non-windowed contexts.
	        var global = typeof window !== "undefined" ? window : self;
	
	        // Get the `window` object, save the previous Q global
	        // and initialize Q as a global.
	        var previousQ = global.Q;
	        global.Q = definition();
	
	        // Add a noConflict function so Q can be removed from the
	        // global namespace.
	        global.Q.noConflict = function () {
	            global.Q = previousQ;
	            return this;
	        };
	    } else {
	        throw new Error("This environment was not anticipated by Q. Please file a bug.");
	    }
	})(function () {
	    "use strict";
	
	    var hasStacks = false;
	    try {
	        throw new Error();
	    } catch (e) {
	        hasStacks = !!e.stack;
	    }
	
	    // All code after this point will be filtered from stack traces reported
	    // by Q.
	    var qStartingLine = captureLine();
	    var qFileName;
	
	    // shims
	
	    // used for fallback in "allResolved"
	    var noop = function noop() {};
	
	    // Use the fastest possible means to execute a task in a future turn
	    // of the event loop.
	    var nextTick = function () {
	        // linked list of tasks (single, with head node)
	        var head = { task: void 0, next: null };
	        var tail = head;
	        var flushing = false;
	        var requestTick = void 0;
	        var isNodeJS = false;
	        // queue for late tasks, used by unhandled rejection tracking
	        var laterQueue = [];
	
	        function flush() {
	            /* jshint loopfunc: true */
	            var task, domain;
	
	            while (head.next) {
	                head = head.next;
	                task = head.task;
	                head.task = void 0;
	                domain = head.domain;
	
	                if (domain) {
	                    head.domain = void 0;
	                    domain.enter();
	                }
	                runSingle(task, domain);
	            }
	            while (laterQueue.length) {
	                task = laterQueue.pop();
	                runSingle(task);
	            }
	            flushing = false;
	        }
	        // runs a single function in the async queue
	        function runSingle(task, domain) {
	            try {
	                task();
	            } catch (e) {
	                if (isNodeJS) {
	                    // In node, uncaught exceptions are considered fatal errors.
	                    // Re-throw them synchronously to interrupt flushing!
	
	                    // Ensure continuation if the uncaught exception is suppressed
	                    // listening "uncaughtException" events (as domains does).
	                    // Continue in next event to avoid tick recursion.
	                    if (domain) {
	                        domain.exit();
	                    }
	                    setTimeout(flush, 0);
	                    if (domain) {
	                        domain.enter();
	                    }
	
	                    throw e;
	                } else {
	                    // In browsers, uncaught exceptions are not fatal.
	                    // Re-throw them asynchronously to avoid slow-downs.
	                    setTimeout(function () {
	                        throw e;
	                    }, 0);
	                }
	            }
	
	            if (domain) {
	                domain.exit();
	            }
	        }
	
	        nextTick = function nextTick(task) {
	            tail = tail.next = {
	                task: task,
	                domain: isNodeJS && process.domain,
	                next: null
	            };
	
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.toString() === "[object process]" && process.nextTick) {
	            // Ensure Q is in a real Node environment, with a `process.nextTick`.
	            // To see through fake Node environments:
	            // * Mocha test runner - exposes a `process` global without a `nextTick`
	            // * Browserify - exposes a `process.nexTick` function that uses
	            //   `setTimeout`. In this case `setImmediate` is preferred because
	            //    it is faster. Browserify's `process.toString()` yields
	            //   "[object Object]", while in a real Node environment
	            //   `process.toString()` yields "[object process]".
	            isNodeJS = true;
	
	            requestTick = function requestTick() {
	                process.nextTick(flush);
	            };
	        } else if (typeof setImmediate === "function") {
	            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	            if (typeof window !== "undefined") {
	                requestTick = setImmediate.bind(window, flush);
	            } else {
	                requestTick = function requestTick() {
	                    setImmediate(flush);
	                };
	            }
	        } else if (typeof MessageChannel !== "undefined") {
	            // modern browsers
	            // http://www.nonblocking.io/2011/06/windownexttick.html
	            var channel = new MessageChannel();
	            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	            // working message ports the first time a page loads.
	            channel.port1.onmessage = function () {
	                requestTick = requestPortTick;
	                channel.port1.onmessage = flush;
	                flush();
	            };
	            var requestPortTick = function requestPortTick() {
	                // Opera requires us to provide a message payload, regardless of
	                // whether we use it.
	                channel.port2.postMessage(0);
	            };
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	                requestPortTick();
	            };
	        } else {
	            // old browsers
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	            };
	        }
	        // runs a task after all other tasks have been run
	        // this is useful for unhandled rejection tracking that needs to happen
	        // after all `then`d tasks have been run.
	        nextTick.runAfter = function (task) {
	            laterQueue.push(task);
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	        return nextTick;
	    }();
	
	    // Attempt to make generics safe in the face of downstream
	    // modifications.
	    // There is no situation where this is necessary.
	    // If you need a security guarantee, these primordials need to be
	    // deeply frozen anyway, and if you dont need a security guarantee,
	    // this is just plain paranoid.
	    // However, this **might** have the nice side-effect of reducing the size of
	    // the minified code by reducing x.call() to merely x()
	    // See Mark Millers explanation of what this does.
	    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	    var call = Function.call;
	    function uncurryThis(f) {
	        return function () {
	            return call.apply(f, arguments);
	        };
	    }
	    // This is equivalent, but slower:
	    // uncurryThis = Function_bind.bind(Function_bind.call);
	    // http://jsperf.com/uncurrythis
	
	    var array_slice = uncurryThis(Array.prototype.slice);
	
	    var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    });
	
	    var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    });
	
	    var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    });
	
	    var object_create = Object.create || function (prototype) {
	        function Type() {}
	        Type.prototype = prototype;
	        return new Type();
	    };
	
	    var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
	        obj[prop] = descriptor.value;
	        return obj;
	    };
	
	    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
	
	    var object_keys = Object.keys || function (object) {
	        var keys = [];
	        for (var key in object) {
	            if (object_hasOwnProperty(object, key)) {
	                keys.push(key);
	            }
	        }
	        return keys;
	    };
	
	    var object_toString = uncurryThis(Object.prototype.toString);
	
	    function isObject(value) {
	        return value === Object(value);
	    }
	
	    // generator related shims
	
	    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	    function isStopIteration(exception) {
	        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
	    }
	
	    // FIXME: Remove this helper and Q.return once ES6 generators are in
	    // SpiderMonkey.
	    var QReturnValue;
	    if (typeof ReturnValue !== "undefined") {
	        QReturnValue = ReturnValue;
	    } else {
	        QReturnValue = function QReturnValue(value) {
	            this.value = value;
	        };
	    }
	
	    // long stack traces
	
	    var STACK_JUMP_SEPARATOR = "From previous event:";
	
	    function makeStackTraceLong(error, promise) {
	        // If possible, transform the error stack trace by removing Node and Q
	        // cruft, then concatenating with the stack trace of `promise`. See #57.
	        if (hasStacks && promise.stack && (typeof error === "undefined" ? "undefined" : _typeof(error)) === "object" && error !== null && error.stack) {
	            var stacks = [];
	            for (var p = promise; !!p; p = p.source) {
	                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
	                    object_defineProperty(error, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
	                    stacks.unshift(p.stack);
	                }
	            }
	            stacks.unshift(error.stack);
	
	            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	            var stack = filterStackString(concatedStacks);
	            object_defineProperty(error, "stack", { value: stack, configurable: true });
	        }
	    }
	
	    function filterStackString(stackString) {
	        var lines = stackString.split("\n");
	        var desiredLines = [];
	        for (var i = 0; i < lines.length; ++i) {
	            var line = lines[i];
	
	            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	                desiredLines.push(line);
	            }
	        }
	        return desiredLines.join("\n");
	    }
	
	    function isNodeFrame(stackLine) {
	        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
	    }
	
	    function getFileNameAndLineNumber(stackLine) {
	        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	        // In IE10 function name can have spaces ("Anonymous function") O_o
	        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	        if (attempt1) {
	            return [attempt1[1], Number(attempt1[2])];
	        }
	
	        // Anonymous functions: "at filename:lineNumber:columnNumber"
	        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	        if (attempt2) {
	            return [attempt2[1], Number(attempt2[2])];
	        }
	
	        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	        if (attempt3) {
	            return [attempt3[1], Number(attempt3[2])];
	        }
	    }
	
	    function isInternalFrame(stackLine) {
	        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
	
	        if (!fileNameAndLineNumber) {
	            return false;
	        }
	
	        var fileName = fileNameAndLineNumber[0];
	        var lineNumber = fileNameAndLineNumber[1];
	
	        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
	    }
	
	    // discover own file name and line number range for filtering stack
	    // traces
	    function captureLine() {
	        if (!hasStacks) {
	            return;
	        }
	
	        try {
	            throw new Error();
	        } catch (e) {
	            var lines = e.stack.split("\n");
	            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	            if (!fileNameAndLineNumber) {
	                return;
	            }
	
	            qFileName = fileNameAndLineNumber[0];
	            return fileNameAndLineNumber[1];
	        }
	    }
	
	    function deprecate(callback, name, alternative) {
	        return function () {
	            if (typeof console !== "undefined" && typeof console.warn === "function") {
	                console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
	            }
	            return callback.apply(callback, arguments);
	        };
	    }
	
	    // end of shims
	    // beginning of real work
	
	    /**
	     * Constructs a promise for an immediate reference, passes promises through, or
	     * coerces promises from different systems.
	     * @param value immediate reference or promise
	     */
	    function Q(value) {
	        // If the object is already a Promise, return it directly.  This enables
	        // the resolve function to both be used to created references from objects,
	        // but to tolerably coerce non-promises to promises.
	        if (value instanceof Promise) {
	            return value;
	        }
	
	        // assimilate thenables
	        if (isPromiseAlike(value)) {
	            return coerce(value);
	        } else {
	            return fulfill(value);
	        }
	    }
	    Q.resolve = Q;
	
	    /**
	     * Performs a task in a future turn of the event loop.
	     * @param {Function} task
	     */
	    Q.nextTick = nextTick;
	
	    /**
	     * Controls whether or not long stack traces will be on
	     */
	    Q.longStackSupport = false;
	
	    /**
	     * The counter is used to determine the stopping point for building
	     * long stack traces. In makeStackTraceLong we walk backwards through
	     * the linked list of promises, only stacks which were created before
	     * the rejection are concatenated.
	     */
	    var longStackCounter = 1;
	
	    // enable long stacks if Q_DEBUG is set
	    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.env && process.env.Q_DEBUG) {
	        Q.longStackSupport = true;
	    }
	
	    /**
	     * Constructs a {promise, resolve, reject} object.
	     *
	     * `resolve` is a callback to invoke with a more resolved value for the
	     * promise. To fulfill the promise, invoke `resolve` with any value that is
	     * not a thenable. To reject the promise, invoke `resolve` with a rejected
	     * thenable, or invoke `reject` with the reason directly. To resolve the
	     * promise to another thenable, thus putting it in the same state, invoke
	     * `resolve` with that other thenable.
	     */
	    Q.defer = defer;
	    function defer() {
	        // if "messages" is an "Array", that indicates that the promise has not yet
	        // been resolved.  If it is "undefined", it has been resolved.  Each
	        // element of the messages array is itself an array of complete arguments to
	        // forward to the resolved promise.  We coerce the resolution value to a
	        // promise using the `resolve` function because it handles both fully
	        // non-thenable values and other thenables gracefully.
	        var messages = [],
	            progressListeners = [],
	            resolvedPromise;
	
	        var deferred = object_create(defer.prototype);
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, operands) {
	            var args = array_slice(arguments);
	            if (messages) {
	                messages.push(args);
	                if (op === "when" && operands[1]) {
	                    // progress operand
	                    progressListeners.push(operands[1]);
	                }
	            } else {
	                Q.nextTick(function () {
	                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	                });
	            }
	        };
	
	        // XXX deprecated
	        promise.valueOf = function () {
	            if (messages) {
	                return promise;
	            }
	            var nearerValue = nearer(resolvedPromise);
	            if (isPromise(nearerValue)) {
	                resolvedPromise = nearerValue; // shorten chain
	            }
	            return nearerValue;
	        };
	
	        promise.inspect = function () {
	            if (!resolvedPromise) {
	                return { state: "pending" };
	            }
	            return resolvedPromise.inspect();
	        };
	
	        if (Q.longStackSupport && hasStacks) {
	            try {
	                throw new Error();
	            } catch (e) {
	                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	                // accessor around; that causes memory leaks as per GH-111. Just
	                // reify the stack trace as a string ASAP.
	                //
	                // At the same time, cut off the first line; it's always just
	                // "[object Promise]\n", as per the `toString`.
	                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	                promise.stackCounter = longStackCounter++;
	            }
	        }
	
	        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	        // consolidating them into `become`, since otherwise we'd create new
	        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
	
	        function become(newPromise) {
	            resolvedPromise = newPromise;
	
	            if (Q.longStackSupport && hasStacks) {
	                // Only hold a reference to the new promise if long stacks
	                // are enabled to reduce memory usage
	                promise.source = newPromise;
	            }
	
	            array_reduce(messages, function (undefined, message) {
	                Q.nextTick(function () {
	                    newPromise.promiseDispatch.apply(newPromise, message);
	                });
	            }, void 0);
	
	            messages = void 0;
	            progressListeners = void 0;
	        }
	
	        deferred.promise = promise;
	        deferred.resolve = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(Q(value));
	        };
	
	        deferred.fulfill = function (value) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(fulfill(value));
	        };
	        deferred.reject = function (reason) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            become(reject(reason));
	        };
	        deferred.notify = function (progress) {
	            if (resolvedPromise) {
	                return;
	            }
	
	            array_reduce(progressListeners, function (undefined, progressListener) {
	                Q.nextTick(function () {
	                    progressListener(progress);
	                });
	            }, void 0);
	        };
	
	        return deferred;
	    }
	
	    /**
	     * Creates a Node-style callback that will resolve or reject the deferred
	     * promise.
	     * @returns a nodeback
	     */
	    defer.prototype.makeNodeResolver = function () {
	        var self = this;
	        return function (error, value) {
	            if (error) {
	                self.reject(error);
	            } else if (arguments.length > 2) {
	                self.resolve(array_slice(arguments, 1));
	            } else {
	                self.resolve(value);
	            }
	        };
	    };
	
	    /**
	     * @param resolver {Function} a function that returns nothing and accepts
	     * the resolve, reject, and notify functions for a deferred.
	     * @returns a promise that may be resolved with the given resolve and reject
	     * functions, or rejected by a thrown exception in resolver
	     */
	    Q.Promise = promise; // ES6
	    Q.promise = promise;
	    function promise(resolver) {
	        if (typeof resolver !== "function") {
	            throw new TypeError("resolver must be a function.");
	        }
	        var deferred = defer();
	        try {
	            resolver(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (reason) {
	            deferred.reject(reason);
	        }
	        return deferred.promise;
	    }
	
	    promise.race = race; // ES6
	    promise.all = all; // ES6
	    promise.reject = reject; // ES6
	    promise.resolve = Q; // ES6
	
	    // XXX experimental.  This method is a way to denote that a local value is
	    // serializable and should be immediately dispatched to a remote upon request,
	    // instead of passing a reference.
	    Q.passByCopy = function (object) {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return object;
	    };
	
	    Promise.prototype.passByCopy = function () {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return this;
	    };
	
	    /**
	     * If two promises eventually fulfill to the same value, promises that value,
	     * but otherwise rejects.
	     * @param x {Any*}
	     * @param y {Any*}
	     * @returns {Any*} a promise for x and y if they are the same, but a rejection
	     * otherwise.
	     *
	     */
	    Q.join = function (x, y) {
	        return Q(x).join(y);
	    };
	
	    Promise.prototype.join = function (that) {
	        return Q([this, that]).spread(function (x, y) {
	            if (x === y) {
	                // TODO: "===" should be Object.is or equiv
	                return x;
	            } else {
	                throw new Error("Q can't join: not the same: " + x + " " + y);
	            }
	        });
	    };
	
	    /**
	     * Returns a promise for the first of an array of promises to become settled.
	     * @param answers {Array[Any*]} promises to race
	     * @returns {Any*} the first promise to be settled
	     */
	    Q.race = race;
	    function race(answerPs) {
	        return promise(function (resolve, reject) {
	            // Switch to this once we can assume at least ES5
	            // answerPs.forEach(function (answerP) {
	            //     Q(answerP).then(resolve, reject);
	            // });
	            // Use this in the meantime
	            for (var i = 0, len = answerPs.length; i < len; i++) {
	                Q(answerPs[i]).then(resolve, reject);
	            }
	        });
	    }
	
	    Promise.prototype.race = function () {
	        return this.then(Q.race);
	    };
	
	    /**
	     * Constructs a Promise with a promise descriptor object and optional fallback
	     * function.  The descriptor contains methods like when(rejected), get(name),
	     * set(name, value), post(name, args), and delete(name), which all
	     * return either a value, a promise for a value, or a rejection.  The fallback
	     * accepts the operation name, a resolver, and any further arguments that would
	     * have been forwarded to the appropriate method above had a method been
	     * provided with the proper name.  The API makes no guarantees about the nature
	     * of the returned object, apart from that it is usable whereever promises are
	     * bought and sold.
	     */
	    Q.makePromise = Promise;
	    function Promise(descriptor, fallback, inspect) {
	        if (fallback === void 0) {
	            fallback = function fallback(op) {
	                return reject(new Error("Promise does not support operation: " + op));
	            };
	        }
	        if (inspect === void 0) {
	            inspect = function inspect() {
	                return { state: "unknown" };
	            };
	        }
	
	        var promise = object_create(Promise.prototype);
	
	        promise.promiseDispatch = function (resolve, op, args) {
	            var result;
	            try {
	                if (descriptor[op]) {
	                    result = descriptor[op].apply(promise, args);
	                } else {
	                    result = fallback.call(promise, op, args);
	                }
	            } catch (exception) {
	                result = reject(exception);
	            }
	            if (resolve) {
	                resolve(result);
	            }
	        };
	
	        promise.inspect = inspect;
	
	        // XXX deprecated `valueOf` and `exception` support
	        if (inspect) {
	            var inspected = inspect();
	            if (inspected.state === "rejected") {
	                promise.exception = inspected.reason;
	            }
	
	            promise.valueOf = function () {
	                var inspected = inspect();
	                if (inspected.state === "pending" || inspected.state === "rejected") {
	                    return promise;
	                }
	                return inspected.value;
	            };
	        }
	
	        return promise;
	    }
	
	    Promise.prototype.toString = function () {
	        return "[object Promise]";
	    };
	
	    Promise.prototype.then = function (fulfilled, rejected, progressed) {
	        var self = this;
	        var deferred = defer();
	        var done = false; // ensure the untrusted promise makes at most a
	        // single call to one of the callbacks
	
	        function _fulfilled(value) {
	            try {
	                return typeof fulfilled === "function" ? fulfilled(value) : value;
	            } catch (exception) {
	                return reject(exception);
	            }
	        }
	
	        function _rejected(exception) {
	            if (typeof rejected === "function") {
	                makeStackTraceLong(exception, self);
	                try {
	                    return rejected(exception);
	                } catch (newException) {
	                    return reject(newException);
	                }
	            }
	            return reject(exception);
	        }
	
	        function _progressed(value) {
	            return typeof progressed === "function" ? progressed(value) : value;
	        }
	
	        Q.nextTick(function () {
	            self.promiseDispatch(function (value) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_fulfilled(value));
	            }, "when", [function (exception) {
	                if (done) {
	                    return;
	                }
	                done = true;
	
	                deferred.resolve(_rejected(exception));
	            }]);
	        });
	
	        // Progress propagator need to be attached in the current tick.
	        self.promiseDispatch(void 0, "when", [void 0, function (value) {
	            var newValue;
	            var threw = false;
	            try {
	                newValue = _progressed(value);
	            } catch (e) {
	                threw = true;
	                if (Q.onerror) {
	                    Q.onerror(e);
	                } else {
	                    throw e;
	                }
	            }
	
	            if (!threw) {
	                deferred.notify(newValue);
	            }
	        }]);
	
	        return deferred.promise;
	    };
	
	    Q.tap = function (promise, callback) {
	        return Q(promise).tap(callback);
	    };
	
	    /**
	     * Works almost like "finally", but not called for rejections.
	     * Original resolution value is passed through callback unaffected.
	     * Callback may return a promise that will be awaited for.
	     * @param {Function} callback
	     * @returns {Q.Promise}
	     * @example
	     * doSomething()
	     *   .then(...)
	     *   .tap(console.log)
	     *   .then(...);
	     */
	    Promise.prototype.tap = function (callback) {
	        callback = Q(callback);
	
	        return this.then(function (value) {
	            return callback.fcall(value).thenResolve(value);
	        });
	    };
	
	    /**
	     * Registers an observer on a promise.
	     *
	     * Guarantees:
	     *
	     * 1. that fulfilled and rejected will be called only once.
	     * 2. that either the fulfilled callback or the rejected callback will be
	     *    called, but not both.
	     * 3. that fulfilled and rejected will not be called in this turn.
	     *
	     * @param value      promise or immediate reference to observe
	     * @param fulfilled  function to be called with the fulfilled value
	     * @param rejected   function to be called with the rejection exception
	     * @param progressed function to be called on any progress notifications
	     * @return promise for the return value from the invoked callback
	     */
	    Q.when = when;
	    function when(value, fulfilled, rejected, progressed) {
	        return Q(value).then(fulfilled, rejected, progressed);
	    }
	
	    Promise.prototype.thenResolve = function (value) {
	        return this.then(function () {
	            return value;
	        });
	    };
	
	    Q.thenResolve = function (promise, value) {
	        return Q(promise).thenResolve(value);
	    };
	
	    Promise.prototype.thenReject = function (reason) {
	        return this.then(function () {
	            throw reason;
	        });
	    };
	
	    Q.thenReject = function (promise, reason) {
	        return Q(promise).thenReject(reason);
	    };
	
	    /**
	     * If an object is not a promise, it is as "near" as possible.
	     * If a promise is rejected, it is as "near" as possible too.
	     * If its a fulfilled promise, the fulfillment value is nearer.
	     * If its a deferred promise and the deferred has been resolved, the
	     * resolution is "nearer".
	     * @param object
	     * @returns most resolved (nearest) form of the object
	     */
	
	    // XXX should we re-do this?
	    Q.nearer = nearer;
	    function nearer(value) {
	        if (isPromise(value)) {
	            var inspected = value.inspect();
	            if (inspected.state === "fulfilled") {
	                return inspected.value;
	            }
	        }
	        return value;
	    }
	
	    /**
	     * @returns whether the given object is a promise.
	     * Otherwise it is a fulfilled value.
	     */
	    Q.isPromise = isPromise;
	    function isPromise(object) {
	        return object instanceof Promise;
	    }
	
	    Q.isPromiseAlike = isPromiseAlike;
	    function isPromiseAlike(object) {
	        return isObject(object) && typeof object.then === "function";
	    }
	
	    /**
	     * @returns whether the given object is a pending promise, meaning not
	     * fulfilled or rejected.
	     */
	    Q.isPending = isPending;
	    function isPending(object) {
	        return isPromise(object) && object.inspect().state === "pending";
	    }
	
	    Promise.prototype.isPending = function () {
	        return this.inspect().state === "pending";
	    };
	
	    /**
	     * @returns whether the given object is a value or fulfilled
	     * promise.
	     */
	    Q.isFulfilled = isFulfilled;
	    function isFulfilled(object) {
	        return !isPromise(object) || object.inspect().state === "fulfilled";
	    }
	
	    Promise.prototype.isFulfilled = function () {
	        return this.inspect().state === "fulfilled";
	    };
	
	    /**
	     * @returns whether the given object is a rejected promise.
	     */
	    Q.isRejected = isRejected;
	    function isRejected(object) {
	        return isPromise(object) && object.inspect().state === "rejected";
	    }
	
	    Promise.prototype.isRejected = function () {
	        return this.inspect().state === "rejected";
	    };
	
	    //// BEGIN UNHANDLED REJECTION TRACKING
	
	    // This promise library consumes exceptions thrown in handlers so they can be
	    // handled by a subsequent promise.  The exceptions get added to this array when
	    // they are created, and removed when they are handled.  Note that in ES6 or
	    // shimmed environments, this would naturally be a `Set`.
	    var unhandledReasons = [];
	    var unhandledRejections = [];
	    var reportedUnhandledRejections = [];
	    var trackUnhandledRejections = true;
	
	    function resetUnhandledRejections() {
	        unhandledReasons.length = 0;
	        unhandledRejections.length = 0;
	
	        if (!trackUnhandledRejections) {
	            trackUnhandledRejections = true;
	        }
	    }
	
	    function trackRejection(promise, reason) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	            Q.nextTick.runAfter(function () {
	                if (array_indexOf(unhandledRejections, promise) !== -1) {
	                    process.emit("unhandledRejection", reason, promise);
	                    reportedUnhandledRejections.push(promise);
	                }
	            });
	        }
	
	        unhandledRejections.push(promise);
	        if (reason && typeof reason.stack !== "undefined") {
	            unhandledReasons.push(reason.stack);
	        } else {
	            unhandledReasons.push("(no stack) " + reason);
	        }
	    }
	
	    function untrackRejection(promise) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	
	        var at = array_indexOf(unhandledRejections, promise);
	        if (at !== -1) {
	            if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	                Q.nextTick.runAfter(function () {
	                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
	                    if (atReport !== -1) {
	                        process.emit("rejectionHandled", unhandledReasons[at], promise);
	                        reportedUnhandledRejections.splice(atReport, 1);
	                    }
	                });
	            }
	            unhandledRejections.splice(at, 1);
	            unhandledReasons.splice(at, 1);
	        }
	    }
	
	    Q.resetUnhandledRejections = resetUnhandledRejections;
	
	    Q.getUnhandledReasons = function () {
	        // Make a copy so that consumers can't interfere with our internal state.
	        return unhandledReasons.slice();
	    };
	
	    Q.stopUnhandledRejectionTracking = function () {
	        resetUnhandledRejections();
	        trackUnhandledRejections = false;
	    };
	
	    resetUnhandledRejections();
	
	    //// END UNHANDLED REJECTION TRACKING
	
	    /**
	     * Constructs a rejected promise.
	     * @param reason value describing the failure
	     */
	    Q.reject = reject;
	    function reject(reason) {
	        var rejection = Promise({
	            "when": function when(rejected) {
	                // note that the error has been handled
	                if (rejected) {
	                    untrackRejection(this);
	                }
	                return rejected ? rejected(reason) : this;
	            }
	        }, function fallback() {
	            return this;
	        }, function inspect() {
	            return { state: "rejected", reason: reason };
	        });
	
	        // Note that the reason has not been handled.
	        trackRejection(rejection, reason);
	
	        return rejection;
	    }
	
	    /**
	     * Constructs a fulfilled promise for an immediate reference.
	     * @param value immediate reference
	     */
	    Q.fulfill = fulfill;
	    function fulfill(value) {
	        return Promise({
	            "when": function when() {
	                return value;
	            },
	            "get": function get(name) {
	                return value[name];
	            },
	            "set": function set(name, rhs) {
	                value[name] = rhs;
	            },
	            "delete": function _delete(name) {
	                delete value[name];
	            },
	            "post": function post(name, args) {
	                // Mark Miller proposes that post with no name should apply a
	                // promised function.
	                if (name === null || name === void 0) {
	                    return value.apply(void 0, args);
	                } else {
	                    return value[name].apply(value, args);
	                }
	            },
	            "apply": function apply(thisp, args) {
	                return value.apply(thisp, args);
	            },
	            "keys": function keys() {
	                return object_keys(value);
	            }
	        }, void 0, function inspect() {
	            return { state: "fulfilled", value: value };
	        });
	    }
	
	    /**
	     * Converts thenables to Q promises.
	     * @param promise thenable promise
	     * @returns a Q promise
	     */
	    function coerce(promise) {
	        var deferred = defer();
	        Q.nextTick(function () {
	            try {
	                promise.then(deferred.resolve, deferred.reject, deferred.notify);
	            } catch (exception) {
	                deferred.reject(exception);
	            }
	        });
	        return deferred.promise;
	    }
	
	    /**
	     * Annotates an object such that it will never be
	     * transferred away from this process over any promise
	     * communication channel.
	     * @param object
	     * @returns promise a wrapping of that object that
	     * additionally responds to the "isDef" message
	     * without a rejection.
	     */
	    Q.master = master;
	    function master(object) {
	        return Promise({
	            "isDef": function isDef() {}
	        }, function fallback(op, args) {
	            return dispatch(object, op, args);
	        }, function () {
	            return Q(object).inspect();
	        });
	    }
	
	    /**
	     * Spreads the values of a promised array of arguments into the
	     * fulfillment callback.
	     * @param fulfilled callback that receives variadic arguments from the
	     * promised array
	     * @param rejected callback that receives the exception if the promise
	     * is rejected.
	     * @returns a promise for the return value or thrown exception of
	     * either callback.
	     */
	    Q.spread = spread;
	    function spread(value, fulfilled, rejected) {
	        return Q(value).spread(fulfilled, rejected);
	    }
	
	    Promise.prototype.spread = function (fulfilled, rejected) {
	        return this.all().then(function (array) {
	            return fulfilled.apply(void 0, array);
	        }, rejected);
	    };
	
	    /**
	     * The async function is a decorator for generator functions, turning
	     * them into asynchronous generators.  Although generators are only part
	     * of the newest ECMAScript 6 drafts, this code does not cause syntax
	     * errors in older engines.  This code should continue to work and will
	     * in fact improve over time as the language improves.
	     *
	     * ES6 generators are currently part of V8 version 3.19 with the
	     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	     * for longer, but under an older Python-inspired form.  This function
	     * works on both kinds of generators.
	     *
	     * Decorates a generator function such that:
	     *  - it may yield promises
	     *  - execution will continue when that promise is fulfilled
	     *  - the value of the yield expression will be the fulfilled value
	     *  - it returns a promise for the return value (when the generator
	     *    stops iterating)
	     *  - the decorated function returns a promise for the return value
	     *    of the generator or the first rejected promise among those
	     *    yielded.
	     *  - if an error is thrown in the generator, it propagates through
	     *    every following yield until it is caught, or until it escapes
	     *    the generator function altogether, and is translated into a
	     *    rejection for the promise returned by the decorated generator.
	     */
	    Q.async = async;
	    function async(makeGenerator) {
	        return function () {
	            // when verb is "send", arg is a value
	            // when verb is "throw", arg is an exception
	            function continuer(verb, arg) {
	                var result;
	
	                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	                // engine that has a deployed base of browsers that support generators.
	                // However, SM's generators use the Python-inspired semantics of
	                // outdated ES6 drafts.  We would like to support ES6, but we'd also
	                // like to make it possible to use generators in deployed browsers, so
	                // we also support Python-style generators.  At some point we can remove
	                // this block.
	
	                if (typeof StopIteration === "undefined") {
	                    // ES6 Generators
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        return reject(exception);
	                    }
	                    if (result.done) {
	                        return Q(result.value);
	                    } else {
	                        return when(result.value, callback, errback);
	                    }
	                } else {
	                    // SpiderMonkey Generators
	                    // FIXME: Remove this case when SM does ES6 generators.
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        if (isStopIteration(exception)) {
	                            return Q(exception.value);
	                        } else {
	                            return reject(exception);
	                        }
	                    }
	                    return when(result, callback, errback);
	                }
	            }
	            var generator = makeGenerator.apply(this, arguments);
	            var callback = continuer.bind(continuer, "next");
	            var errback = continuer.bind(continuer, "throw");
	            return callback();
	        };
	    }
	
	    /**
	     * The spawn function is a small wrapper around async that immediately
	     * calls the generator and also ends the promise chain, so that any
	     * unhandled errors are thrown instead of forwarded to the error
	     * handler. This is useful because it's extremely common to run
	     * generators at the top-level to work with libraries.
	     */
	    Q.spawn = spawn;
	    function spawn(makeGenerator) {
	        Q.done(Q.async(makeGenerator)());
	    }
	
	    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	    /**
	     * Throws a ReturnValue exception to stop an asynchronous generator.
	     *
	     * This interface is a stop-gap measure to support generator return
	     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	     * generators like Chromium 29, just use "return" in your generator
	     * functions.
	     *
	     * @param value the return value for the surrounding generator
	     * @throws ReturnValue exception with the value.
	     * @example
	     * // ES6 style
	     * Q.async(function* () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      return foo + bar;
	     * })
	     * // Older SpiderMonkey style
	     * Q.async(function () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      Q.return(foo + bar);
	     * })
	     */
	    Q["return"] = _return;
	    function _return(value) {
	        throw new QReturnValue(value);
	    }
	
	    /**
	     * The promised function decorator ensures that any promise arguments
	     * are settled and passed as values (`this` is also settled and passed
	     * as a value).  It will also ensure that the result of a function is
	     * always a promise.
	     *
	     * @example
	     * var add = Q.promised(function (a, b) {
	     *     return a + b;
	     * });
	     * add(Q(a), Q(B));
	     *
	     * @param {function} callback The function to decorate
	     * @returns {function} a function that has been decorated.
	     */
	    Q.promised = promised;
	    function promised(callback) {
	        return function () {
	            return spread([this, all(arguments)], function (self, args) {
	                return callback.apply(self, args);
	            });
	        };
	    }
	
	    /**
	     * sends a message to a value in a future turn
	     * @param object* the recipient
	     * @param op the name of the message operation, e.g., "when",
	     * @param args further arguments to be forwarded to the operation
	     * @returns result {Promise} a promise for the result of the operation
	     */
	    Q.dispatch = dispatch;
	    function dispatch(object, op, args) {
	        return Q(object).dispatch(op, args);
	    }
	
	    Promise.prototype.dispatch = function (op, args) {
	        var self = this;
	        var deferred = defer();
	        Q.nextTick(function () {
	            self.promiseDispatch(deferred.resolve, op, args);
	        });
	        return deferred.promise;
	    };
	
	    /**
	     * Gets the value of a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to get
	     * @return promise for the property value
	     */
	    Q.get = function (object, key) {
	        return Q(object).dispatch("get", [key]);
	    };
	
	    Promise.prototype.get = function (key) {
	        return this.dispatch("get", [key]);
	    };
	
	    /**
	     * Sets the value of a property in a future turn.
	     * @param object    promise or immediate reference for object object
	     * @param name      name of property to set
	     * @param value     new value of property
	     * @return promise for the return value
	     */
	    Q.set = function (object, key, value) {
	        return Q(object).dispatch("set", [key, value]);
	    };
	
	    Promise.prototype.set = function (key, value) {
	        return this.dispatch("set", [key, value]);
	    };
	
	    /**
	     * Deletes a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to delete
	     * @return promise for the return value
	     */
	    Q.del = // XXX legacy
	    Q["delete"] = function (object, key) {
	        return Q(object).dispatch("delete", [key]);
	    };
	
	    Promise.prototype.del = // XXX legacy
	    Promise.prototype["delete"] = function (key) {
	        return this.dispatch("delete", [key]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param value     a value to post, typically an array of
	     *                  invocation arguments for promises that
	     *                  are ultimately backed with `resolve` values,
	     *                  as opposed to those backed with URLs
	     *                  wherein the posted value can be any
	     *                  JSON serializable object.
	     * @return promise for the return value
	     */
	    // bound locally because it is used by other methods
	    Q.mapply = // XXX As proposed by "Redsandro"
	    Q.post = function (object, name, args) {
	        return Q(object).dispatch("post", [name, args]);
	    };
	
	    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.post = function (name, args) {
	        return this.dispatch("post", [name, args]);
	    };
	
	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param ...args   array of invocation arguments
	     * @return promise for the return value
	     */
	    Q.send = // XXX Mark Miller's proposed parlance
	    Q.mcall = // XXX As proposed by "Redsandro"
	    Q.invoke = function (object, name /*...args*/) {
	        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	    };
	
	    Promise.prototype.send = // XXX Mark Miller's proposed parlance
	    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	    Promise.prototype.invoke = function (name /*...args*/) {
	        return this.dispatch("post", [name, array_slice(arguments, 1)]);
	    };
	
	    /**
	     * Applies the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param args      array of application arguments
	     */
	    Q.fapply = function (object, args) {
	        return Q(object).dispatch("apply", [void 0, args]);
	    };
	
	    Promise.prototype.fapply = function (args) {
	        return this.dispatch("apply", [void 0, args]);
	    };
	
	    /**
	     * Calls the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q["try"] = Q.fcall = function (object /* ...args*/) {
	        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	    };
	
	    Promise.prototype.fcall = function () /*...args*/{
	        return this.dispatch("apply", [void 0, array_slice(arguments)]);
	    };
	
	    /**
	     * Binds the promised function, transforming return values into a fulfilled
	     * promise and thrown errors into a rejected one.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q.fbind = function (object /*...args*/) {
	        var promise = Q(object);
	        var args = array_slice(arguments, 1);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	    Promise.prototype.fbind = function () /*...args*/{
	        var promise = this;
	        var args = array_slice(arguments);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	
	    /**
	     * Requests the names of the owned properties of a promised
	     * object in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @return promise for the keys of the eventually settled object
	     */
	    Q.keys = function (object) {
	        return Q(object).dispatch("keys", []);
	    };
	
	    Promise.prototype.keys = function () {
	        return this.dispatch("keys", []);
	    };
	
	    /**
	     * Turns an array of promises into a promise for an array.  If any of
	     * the promises gets rejected, the whole array is rejected immediately.
	     * @param {Array*} an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns a promise for an array of the corresponding values
	     */
	    // By Mark Miller
	    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	    Q.all = all;
	    function all(promises) {
	        return when(promises, function (promises) {
	            var pendingCount = 0;
	            var deferred = defer();
	            array_reduce(promises, function (undefined, promise, index) {
	                var snapshot;
	                if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
	                    promises[index] = snapshot.value;
	                } else {
	                    ++pendingCount;
	                    when(promise, function (value) {
	                        promises[index] = value;
	                        if (--pendingCount === 0) {
	                            deferred.resolve(promises);
	                        }
	                    }, deferred.reject, function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    });
	                }
	            }, void 0);
	            if (pendingCount === 0) {
	                deferred.resolve(promises);
	            }
	            return deferred.promise;
	        });
	    }
	
	    Promise.prototype.all = function () {
	        return all(this);
	    };
	
	    /**
	     * Returns the first resolved promise of an array. Prior rejected promises are
	     * ignored.  Rejects only if all promises are rejected.
	     * @param {Array*} an array containing values or promises for values
	     * @returns a promise fulfilled with the value of the first resolved promise,
	     * or a rejected promise if all promises are rejected.
	     */
	    Q.any = any;
	
	    function any(promises) {
	        if (promises.length === 0) {
	            return Q.resolve();
	        }
	
	        var deferred = Q.defer();
	        var pendingCount = 0;
	        array_reduce(promises, function (prev, current, index) {
	            var promise = promises[index];
	
	            pendingCount++;
	
	            when(promise, onFulfilled, onRejected, onProgress);
	            function onFulfilled(result) {
	                deferred.resolve(result);
	            }
	            function onRejected(err) {
	                pendingCount--;
	                if (pendingCount === 0) {
	                    err.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + err.message;
	                    deferred.reject(err);
	                }
	            }
	            function onProgress(progress) {
	                deferred.notify({
	                    index: index,
	                    value: progress
	                });
	            }
	        }, undefined);
	
	        return deferred.promise;
	    }
	
	    Promise.prototype.any = function () {
	        return any(this);
	    };
	
	    /**
	     * Waits for all promises to be settled, either fulfilled or
	     * rejected.  This is distinct from `all` since that would stop
	     * waiting at the first rejection.  The promise returned by
	     * `allResolved` will never be rejected.
	     * @param promises a promise for an array (or an array) of promises
	     * (or values)
	     * @return a promise for an array of promises
	     */
	    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	    function allResolved(promises) {
	        return when(promises, function (promises) {
	            promises = array_map(promises, Q);
	            return when(all(array_map(promises, function (promise) {
	                return when(promise, noop, noop);
	            })), function () {
	                return promises;
	            });
	        });
	    }
	
	    Promise.prototype.allResolved = function () {
	        return allResolved(this);
	    };
	
	    /**
	     * @see Promise#allSettled
	     */
	    Q.allSettled = allSettled;
	    function allSettled(promises) {
	        return Q(promises).allSettled();
	    }
	
	    /**
	     * Turns an array of promises into a promise for an array of their states (as
	     * returned by `inspect`) when they have all settled.
	     * @param {Array[Any*]} values an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns {Array[State]} an array of states for the respective values.
	     */
	    Promise.prototype.allSettled = function () {
	        return this.then(function (promises) {
	            return all(array_map(promises, function (promise) {
	                promise = Q(promise);
	                function regardless() {
	                    return promise.inspect();
	                }
	                return promise.then(regardless, regardless);
	            }));
	        });
	    };
	
	    /**
	     * Captures the failure of a promise, giving an oportunity to recover
	     * with a callback.  If the given promise is fulfilled, the returned
	     * promise is fulfilled.
	     * @param {Any*} promise for something
	     * @param {Function} callback to fulfill the returned promise if the
	     * given promise is rejected
	     * @returns a promise for the return value of the callback
	     */
	    Q.fail = // XXX legacy
	    Q["catch"] = function (object, rejected) {
	        return Q(object).then(void 0, rejected);
	    };
	
	    Promise.prototype.fail = // XXX legacy
	    Promise.prototype["catch"] = function (rejected) {
	        return this.then(void 0, rejected);
	    };
	
	    /**
	     * Attaches a listener that can respond to progress notifications from a
	     * promise's originating deferred. This listener receives the exact arguments
	     * passed to ``deferred.notify``.
	     * @param {Any*} promise for something
	     * @param {Function} callback to receive any progress notifications
	     * @returns the given promise, unchanged
	     */
	    Q.progress = progress;
	    function progress(object, progressed) {
	        return Q(object).then(void 0, void 0, progressed);
	    }
	
	    Promise.prototype.progress = function (progressed) {
	        return this.then(void 0, void 0, progressed);
	    };
	
	    /**
	     * Provides an opportunity to observe the settling of a promise,
	     * regardless of whether the promise is fulfilled or rejected.  Forwards
	     * the resolution to the returned promise when the callback is done.
	     * The callback can return a promise to defer completion.
	     * @param {Any*} promise
	     * @param {Function} callback to observe the resolution of the given
	     * promise, takes no arguments.
	     * @returns a promise for the resolution of the given promise when
	     * ``fin`` is done.
	     */
	    Q.fin = // XXX legacy
	    Q["finally"] = function (object, callback) {
	        return Q(object)["finally"](callback);
	    };
	
	    Promise.prototype.fin = // XXX legacy
	    Promise.prototype["finally"] = function (callback) {
	        if (!callback || typeof callback.apply !== "function") {
	            throw new Error("Q can't apply finally callback");
	        }
	        callback = Q(callback);
	        return this.then(function (value) {
	            return callback.fcall().then(function () {
	                return value;
	            });
	        }, function (reason) {
	            // TODO attempt to recycle the rejection with "this".
	            return callback.fcall().then(function () {
	                throw reason;
	            });
	        });
	    };
	
	    /**
	     * Terminates a chain of promises, forcing rejections to be
	     * thrown as exceptions.
	     * @param {Any*} promise at the end of a chain of promises
	     * @returns nothing
	     */
	    Q.done = function (object, fulfilled, rejected, progress) {
	        return Q(object).done(fulfilled, rejected, progress);
	    };
	
	    Promise.prototype.done = function (fulfilled, rejected, progress) {
	        var onUnhandledError = function onUnhandledError(error) {
	            // forward to a future turn so that ``when``
	            // does not catch it and turn it into a rejection.
	            Q.nextTick(function () {
	                makeStackTraceLong(error, promise);
	                if (Q.onerror) {
	                    Q.onerror(error);
	                } else {
	                    throw error;
	                }
	            });
	        };
	
	        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
	
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.domain) {
	            onUnhandledError = process.domain.bind(onUnhandledError);
	        }
	
	        promise.then(void 0, onUnhandledError);
	    };
	
	    /**
	     * Causes a promise to be rejected if it does not get fulfilled before
	     * some milliseconds time out.
	     * @param {Any*} promise
	     * @param {Number} milliseconds timeout
	     * @param {Any*} custom error message or Error object (optional)
	     * @returns a promise for the resolution of the given promise if it is
	     * fulfilled before the timeout, otherwise rejected.
	     */
	    Q.timeout = function (object, ms, error) {
	        return Q(object).timeout(ms, error);
	    };
	
	    Promise.prototype.timeout = function (ms, error) {
	        var deferred = defer();
	        var timeoutId = setTimeout(function () {
	            if (!error || "string" === typeof error) {
	                error = new Error(error || "Timed out after " + ms + " ms");
	                error.code = "ETIMEDOUT";
	            }
	            deferred.reject(error);
	        }, ms);
	
	        this.then(function (value) {
	            clearTimeout(timeoutId);
	            deferred.resolve(value);
	        }, function (exception) {
	            clearTimeout(timeoutId);
	            deferred.reject(exception);
	        }, deferred.notify);
	
	        return deferred.promise;
	    };
	
	    /**
	     * Returns a promise for the given value (or promised value), some
	     * milliseconds after it resolved. Passes rejections immediately.
	     * @param {Any*} promise
	     * @param {Number} milliseconds
	     * @returns a promise for the resolution of the given promise after milliseconds
	     * time has elapsed since the resolution of the given promise.
	     * If the given promise rejects, that is passed immediately.
	     */
	    Q.delay = function (object, timeout) {
	        if (timeout === void 0) {
	            timeout = object;
	            object = void 0;
	        }
	        return Q(object).delay(timeout);
	    };
	
	    Promise.prototype.delay = function (timeout) {
	        return this.then(function (value) {
	            var deferred = defer();
	            setTimeout(function () {
	                deferred.resolve(value);
	            }, timeout);
	            return deferred.promise;
	        });
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided as an array, and returns a promise.
	     *
	     *      Q.nfapply(FS.readFile, [__filename])
	     *      .then(function (content) {
	     *      })
	     *
	     */
	    Q.nfapply = function (callback, args) {
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfapply = function (args) {
	        var deferred = defer();
	        var nodeArgs = array_slice(args);
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided individually, and returns a promise.
	     * @example
	     * Q.nfcall(FS.readFile, __filename)
	     * .then(function (content) {
	     * })
	     *
	     */
	    Q.nfcall = function (callback /*...args*/) {
	        var args = array_slice(arguments, 1);
	        return Q(callback).nfapply(args);
	    };
	
	    Promise.prototype.nfcall = function () /*...args*/{
	        var nodeArgs = array_slice(arguments);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Wraps a NodeJS continuation passing function and returns an equivalent
	     * version that returns a promise.
	     * @example
	     * Q.nfbind(FS.readFile, __filename)("utf-8")
	     * .then(console.log)
	     * .done()
	     */
	    Q.nfbind = Q.denodeify = function (callback /*...args*/) {
	        if (callback === undefined) {
	            throw new Error("Q can't wrap an undefined function");
	        }
	        var baseArgs = array_slice(arguments, 1);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            Q(callback).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nfbind = Promise.prototype.denodeify = function () /*...args*/{
	        var args = array_slice(arguments);
	        args.unshift(this);
	        return Q.denodeify.apply(void 0, args);
	    };
	
	    Q.nbind = function (callback, thisp /*...args*/) {
	        var baseArgs = array_slice(arguments, 2);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            function bound() {
	                return callback.apply(thisp, arguments);
	            }
	            Q(bound).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };
	
	    Promise.prototype.nbind = function () /*thisp, ...args*/{
	        var args = array_slice(arguments, 0);
	        args.unshift(this);
	        return Q.nbind.apply(void 0, args);
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback with a given array of arguments, plus a provided callback.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param {Array} args arguments to pass to the method; the callback
	     * will be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nmapply = // XXX As proposed by "Redsandro"
	    Q.npost = function (object, name, args) {
	        return Q(object).npost(name, args);
	    };
	
	    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.npost = function (name, args) {
	        var nodeArgs = array_slice(args || []);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback, forwarding the given variadic arguments, plus a provided
	     * callback argument.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param ...args arguments to pass to the method; the callback will
	     * be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nsend = // XXX Based on Mark Miller's proposed "send"
	    Q.nmcall = // XXX Based on "Redsandro's" proposal
	    Q.ninvoke = function (object, name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 2);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	    Promise.prototype.ninvoke = function (name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 1);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };
	
	    /**
	     * If a function would like to support both Node continuation-passing-style and
	     * promise-returning-style, it can end its internal promise chain with
	     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	     * elects to use a nodeback, the result will be sent there.  If they do not
	     * pass a nodeback, they will receive the result promise.
	     * @param object a result (or a promise for a result)
	     * @param {Function} nodeback a Node.js-style callback
	     * @returns either the promise or nothing
	     */
	    Q.nodeify = nodeify;
	    function nodeify(object, nodeback) {
	        return Q(object).nodeify(nodeback);
	    }
	
	    Promise.prototype.nodeify = function (nodeback) {
	        if (nodeback) {
	            this.then(function (value) {
	                Q.nextTick(function () {
	                    nodeback(null, value);
	                });
	            }, function (error) {
	                Q.nextTick(function () {
	                    nodeback(error);
	                });
	            });
	        } else {
	            return this;
	        }
	    };
	
	    Q.noConflict = function () {
	        throw new Error("Q.noConflict only works when Q is used as a global");
	    };
	
	    // All code before this point will be filtered from stack traces.
	    var qEndingLine = captureLine();
	
	    return Q;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(9).setImmediate, __webpack_require__(11)(module)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function () {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function () {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout = exports.clearInterval = function (timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function () {};
	Timeout.prototype.close = function () {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function (item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function (item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function (item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout) item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(10);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	
	(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	        // Callback can either be a function or a string
	        if (typeof callback !== "function") {
	            callback = new Function("" + callback);
	        }
	        // Copy function arguments
	        var args = new Array(arguments.length - 1);
	        for (var i = 0; i < args.length; i++) {
	            args[i] = arguments[i + 1];
	        }
	        // Store and register the task
	        var task = { callback: callback, args: args };
	        tasksByHandle[nextHandle] = task;
	        registerImmediate(nextHandle);
	        return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	            case 0:
	                callback();
	                break;
	            case 1:
	                callback(args[0]);
	                break;
	            case 2:
	                callback(args[0], args[1]);
	                break;
	            case 3:
	                callback(args[0], args[1], args[2]);
	                break;
	            default:
	                callback.apply(undefined, args);
	                break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            process.nextTick(function () {
	                runIfPresent(handle);
	            });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function () {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function onGlobalMessage(event) {
	            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function registerImmediate(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function registerImmediate(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function registerImmediate(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function registerImmediate(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 68
	        installReadyStateChangeImplementation();
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _loglevel = __webpack_require__(4);
	
	var _loglevel2 = _interopRequireDefault(_loglevel);
	
	var _q = __webpack_require__(8);
	
	var _q2 = _interopRequireDefault(_q);
	
	var _algoliasearch = __webpack_require__(13);
	
	var _algoliasearch2 = _interopRequireDefault(_algoliasearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_loglevel2.default.setLevel('debug');
	
	var escapeRegExp = function escapeRegExp(str) {
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	};
	
	var Search = {
	  install: function install(Vue, options) {
	    _loglevel2.default.trace(options);
	    var AlgoliaClient = (0, _algoliasearch2.default)(options.appID, options.apiKey, {
	      protocol: 'https:'
	    });
	    var AlgoliaIndex = AlgoliaClient.initIndex(options.index);
	
	    var advancedSearch = function advancedSearch(params) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.clearCache();
	      AlgoliaIndex.search(params, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          fetchListItemCards(content.hits).then(function () {
	            d.resolve(content.hits);
	          });
	        }
	      });
	      return d.promise;
	    };
	
	    var searchCards = function searchCards(userID, searchText, hitsPerPage) {
	      var d = _q2.default.defer();
	      var params = {
	        query: searchText,
	        filters: userID.length ? 'userID: ' + userID : '',
	        hitsPerPage: hitsPerPage || null
	      };
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (hits) {
	        _loglevel2.default.trace(hits);
	        d.resolve(hits);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var fetchListItemCards = function fetchListItemCards(cards) {
	      var d = _q2.default.defer();
	      var self = this;
	      var promises = [];
	      cards.forEach(function (card) {
	        card.listCards = {};
	        if (card.listItems) {
	          card.listItems.forEach(function (key) {
	            var p = _q2.default.defer();
	            getCard(key).then(function (content) {
	              card.listCards[key] = content;
	              p.resolve(content);
	            });
	            promises.push(p.promise);
	          });
	        }
	      });
	      _loglevel2.default.trace(promises);
	      _q2.default.allSettled(promises).then(function (results) {
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getCard = function getCard(objectID) {
	      var d = _q2.default.defer();
	      AlgoliaIndex.getObject(objectID, function (e, content) {
	        if (e) {
	          _loglevel2.default.trace(e);
	          d.reject(e);
	        } else {
	          d.resolve(content);
	        }
	      });
	      return d.promise;
	    };
	
	    var compoundSearch = function compoundSearch(userID, searchText) {
	      var d = _q2.default.defer();
	      var maxLength = 400;
	      var searchTextArray = [];
	      var hitsPerPage = Math.min(Math.max(Math.ceil(10 / (searchText.length / maxLength)), 3), 12);
	      for (var i = 0; i < searchText.length; i += maxLength) {
	        searchTextArray.push(searchText.substring(i, i + maxLength));
	      }
	      var promises = searchTextArray.map(function (t, j) {
	        return searchCards(userID, t, hitsPerPage);
	      });
	      _q2.default.allSettled(promises).then(function (results) {
	        var results = [].concat.apply([], results.map(function (r) {
	          return r.value;
	        }));
	        results = removeDuplicates(results, 'objectID');
	        _loglevel2.default.trace(results);
	        d.resolve(results);
	      }).catch(function (e) {
	        _loglevel2.default.trace(e);
	      });
	      return d.promise;
	    };
	
	    var removeDuplicates = function removeDuplicates(originalArray, objKey) {
	      var trimmedArray = [],
	          values = [],
	          value;
	      for (var i = 0; i < originalArray.length; i++) {
	        value = originalArray[i][objKey];
	        if (values.indexOf(value) === -1) {
	          trimmedArray.push(originalArray[i]);
	          values.push(value);
	        }
	      }
	      return trimmedArray;
	    };
	
	    var checkPageHit = function checkPageHit(pageData, results) {
	      //Not yet accounting for capitals
	      var boringWords = ['favourite', 'world', 'name', 'this', 'plan', 'need', 'best', 'like', 'the', 'are', 'is', 'my', 'my'];
	      var hits = [];
	      results.forEach(function (result, i) {
	        _loglevel2.default.trace('---');
	        _loglevel2.default.trace(i);
	        var count = [];
	        result.context.forEach(function (c) {
	          if (pageData.pageText.indexOf(c.value) > -1 && hits.indexOf(result.objectID) == -1 && c.value && c.value.length > 3 && boringWords.indexOf(c.value) == -1 && count.indexOf(c.value) == -1) {
	            _loglevel2.default.trace(c.value);
	            count.push(c.value);
	            (c.value.match(/ /g) || []).forEach(function () {
	              count.push(c.value);
	            });
	          }
	        });
	        if (count.length > 2) {
	          _loglevel2.default.trace(result.sentence);
	          hits.push(result);
	        }
	        _loglevel2.default.trace('---');
	      });
	
	      // return hits;
	      //Force no hits
	      return [];
	    };
	
	    var checkPageReminder = function checkPageReminder(userID, pageData) {
	      var d = _q2.default.defer();
	      _loglevel2.default.trace(pageData);
	      var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	      var params = {
	        query: '',
	        filters: 'userID: ' + userID + ' AND (triggerUrl: ' + urlRoot + ' OR triggerUrl: ' + urlRoot + '.com OR triggerUrl: ' + urlRoot + '.co.uk OR triggerUrl: ' + urlRoot + '.org OR triggerURL: ' + urlRoot + ' OR triggerURL: ' + urlRoot + '.com OR triggerURL: ' + urlRoot + '.co.uk OR triggerURL: ' + urlRoot + '.org)'
	      };
	      _loglevel2.default.trace('params');
	      _loglevel2.default.trace(params);
	      advancedSearch(params).then(function (reminders) {
	        _loglevel2.default.trace('reminders');
	        _loglevel2.default.trace(reminders);
	        d.resolve(reminders);
	      }).catch(function (e) {
	        d.reject(e);
	      });
	      return d.promise;
	    };
	
	    var getPageResults = function getPageResults(userID, pageData, allUserCards) {
	      var d = _q2.default.defer();
	      // Gets all results
	      var pageResults = {
	        hits: [],
	        reminders: [],
	        pings: [],
	        memories: []
	      };
	      _loglevel2.default.trace(userID, pageData);
	      var gmailBoringPhrases = ['Skip to content', 'Using', 'with screen readers', 'Search', 'Mail', 'COMPOSE', 'Labels', 'Inbox', 'Starred', 'Sent Mail', 'Drafts', 'More', '---------- Forwarded message ----------', 'From: ', 'Date: ', 'Subject: ', 'To: ', 'Click here to Reply or Forward', 'GB', 'GB used', 'Manage', 'Program Policies', 'Powered by Google', 'Last account activity:', 'hour ago', 'hours ago', 'Details'];
	      gmailBoringPhrases.forEach(function (phrase) {
	        pageData.pageText = pageData.pageText.replace(phrase, '');
	      });
	      var boringWords = ["i", "a", "of", "me", "my", "is", "im", "so", "all", "get", "how", "new", "out", "the", "use", "best", "name", "next", "take", "what", "image", "something"];
	
	      try {
	        var allWords = [];
	        allUserCards.forEach(function (card) {
	          var score = 0;
	          card.context.forEach(function (entity) {
	            var val = String(entity.value);
	            if (boringWords.indexOf(val.toLowerCase()) == -1 && val.length > 1) {
	              var reg = new RegExp(escapeRegExp(val), "gi");
	              var points = (pageData.pageText.match(reg) || []).length * val.length;
	              score += points;
	              if (points) {
	                if (allWords.indexOf(val) == -1) allWords.push(val);
	              }
	            }
	          });
	          if (score > 100) {
	            pageResults.hits.push(card);
	          } else if (score > 0) {
	            pageResults.memories.push(card);
	          }
	        });
	        _loglevel2.default.debug(allWords);
	
	        pageResults.reminders = allUserCards.filter(function (card) {
	          var urlRoot = pageData.baseUrl.replace('.com', '').replace('.co.uk', '').replace('.org', '');
	          _loglevel2.default.info(card.triggerURL);
	          return card.triggerURL && (card.triggerURL.indexOf(urlRoot) > -1 || card.triggerURL.indexOf(urlRoot) > -1);
	        });
	        pageResults.pings = pageResults.reminders; //.concat(pageResults.hits)
	        pageResults.pings.forEach(function (ping) {
	          ping.highlight = true;
	        });
	        // pageResults.memories = pageResults.pings.concat(pageResults.memories)
	        pageResults.memories = removeDuplicates(pageResults.memories, 'objectID');
	        _loglevel2.default.debug(pageResults);
	        d.resolve(pageResults);
	      } catch (e) {
	        _loglevel2.default.error(e);
	      }
	
	      // compoundSearch(userID, pageData.pageText)
	      // .then(function(results) {
	      //   log.trace(1);
	      //   log.trace(results);
	      //   pageResults.memories = results;
	      //   // Checks whether a ping is required
	      //   pageResults.hits = checkPageHit(pageData, results);
	      //   log.trace(2);
	      //   log.trace(pageResults.hits);
	      //   return checkPageReminder(userID, pageData)
	      // }).then(function(reminders) {
	      //   pageResults.reminders = reminders;
	      //   log.trace(3);
	      //   log.trace(pageResults.reminders);
	      //   // Returns results plus ping
	      //   pageResults.pings = pageResults.reminders.concat(pageResults.hits)
	      //   pageResults.pings.forEach(function(ping) {
	      //     log.trace(ping.objectID);
	      //     ping.highlight = true;
	      //   })
	      //   pageResults.memories = pageResults.pings.concat(pageResults.memories)
	      //   pageResults.memories = removeDuplicates(pageResults.memories, 'objectID')
	      //   log.trace(pageResults);
	      //   d.resolve(pageResults)
	      // }).catch(function(e) {
	      //   log.trace(e);
	      //   d.reject(e)
	      // })
	      return d.promise;
	    };
	
	    this.advancedSearch = advancedSearch;
	    this.searchCards = searchCards;
	    this.compoundSearch = compoundSearch;
	    this.getPageResults = getPageResults;
	  }
	};
	
	exports.default = Search;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var AlgoliaSearch = __webpack_require__(14);
	var createAlgoliasearch = __webpack_require__(38);
	
	module.exports = createAlgoliasearch(AlgoliaSearch);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = AlgoliaSearch;
	
	var Index = __webpack_require__(15);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var AlgoliaSearchCore = __webpack_require__(33);
	var inherits = __webpack_require__(16);
	var errors = __webpack_require__(19);
	
	function AlgoliaSearch() {
	  AlgoliaSearchCore.apply(this, arguments);
	}
	
	inherits(AlgoliaSearch, AlgoliaSearchCore);
	
	/*
	 * Delete an index
	 *
	 * @param indexName the name of index to delete
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.deleteIndex = function (indexName, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexName),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Move an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy of
	 * srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.moveIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'move', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Copy an existing index.
	 * @param srcIndexName the name of index to copy.
	 * @param dstIndexName the new index name that will contains a copy
	 * of srcIndexName (destination will be overriten if it already exist).
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.copyIndex = function (srcIndexName, dstIndexName, callback) {
	  var postObj = {
	    operation: 'copy', destination: dstIndexName
	  };
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Return last log entries.
	 * @param offset Specify the first entry to retrieve (0-based, 0 is the most recent log entry).
	 * @param length Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param type Specify the maximum number of entries to retrieve starting
	 * at offset. Maximum allowed value: 1000.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer that contains the task ID
	 */
	AlgoliaSearch.prototype.getLogs = function (offset, length, callback) {
	  var clone = __webpack_require__(24);
	  var params = {};
	  if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) === 'object') {
	    // getLogs(params)
	    params = clone(offset);
	    callback = length;
	  } else if (arguments.length === 0 || typeof offset === 'function') {
	    // getLogs([cb])
	    callback = offset;
	  } else if (arguments.length === 1 || typeof length === 'function') {
	    // getLogs(1, [cb)]
	    callback = length;
	    params.offset = offset;
	  } else {
	    // getLogs(1, 2, [cb])
	    params.offset = offset;
	    params.length = length;
	  }
	
	  if (params.offset === undefined) params.offset = 0;
	  if (params.length === undefined) params.length = 10;
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/logs?' + this._getSearchParams(params, ''),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * List all existing indexes (paginated)
	 *
	 * @param page The page to retrieve, starting at 0.
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with index list
	 */
	AlgoliaSearch.prototype.listIndexes = function (page, callback) {
	  var params = '';
	
	  if (page === undefined || typeof page === 'function') {
	    callback = page;
	  } else {
	    params = '?page=' + page;
	  }
	
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes' + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearch.prototype.initIndex = function (indexName) {
	  return new Index(this, indexName);
	};
	
	/*
	 * @deprecated use client.listApiKeys
	 */
	AlgoliaSearch.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('client.listUserKeys()', 'client.listApiKeys()'));
	
	/*
	 * List all existing api keys with their associated ACLs
	 *
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with api keys list
	 */
	AlgoliaSearch.prototype.listApiKeys = function (callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.getApiKey
	 */
	AlgoliaSearch.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('client.getUserKeyACL()', 'client.getApiKey()'));
	
	/*
	 * Get an API key
	 *
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the right API key
	 */
	AlgoliaSearch.prototype.getApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'GET',
	    url: '/1/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 * @deprecated see client.deleteApiKey
	 */
	AlgoliaSearch.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('client.deleteUserKey()', 'client.deleteApiKey()'));
	
	/*
	 * Delete an existing API key
	 * @param key
	 * @param callback the result callback called with two arguments
	 *  error: null or Error('message')
	 *  content: the server answer with the date of deletion
	 */
	AlgoliaSearch.prototype.deleteApiKey = function (key, callback) {
	  return this._jsonRequest({
	    method: 'DELETE',
	    url: '/1/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see client.addApiKey
	 */
	AlgoliaSearch.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKey()', 'client.addApiKey()'));
	
	/*
	 * Add a new global API key
	 *
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the added API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.addUserKey(['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#AddKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.indexes = params.indexes;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * @deprecated Please use client.addApiKey()
	 */
	AlgoliaSearch.prototype.addUserKeyWithValidity = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('client.addUserKeyWithValidity()', 'client.addApiKey()'));
	
	/**
	 * @deprecated Please use client.updateApiKey()
	 */
	AlgoliaSearch.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('client.updateUserKey()', 'client.updateApiKey()'));
	
	/**
	 * Update an existing API key
	 * @param {string} key - The key to update
	 * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	 *   can contains the following values:
	 *     - search: allow to search (https and http)
	 *     - addObject: allows to add/update an object in the index (https only)
	 *     - deleteObject : allows to delete an existing object (https only)
	 *     - deleteIndex : allows to delete index content (https only)
	 *     - settings : allows to get index settings (https only)
	 *     - editSettings : allows to change index settings (https only)
	 * @param {Object} [params] - Optionnal parameters to set for the key
	 * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
	 * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	 * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	 * @param {string[]} params.indexes - Allowed targeted indexes for this key
	 * @param {string} params.description - A description for your key
	 * @param {string[]} params.referers - A list of authorized referers
	 * @param {Object} params.queryParameters - Force the key to use specific query parameters
	 * @param {Function} callback - The result callback called with two arguments
	 *   error: null or Error('message')
	 *   content: the server answer with the modified API key
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.updateApiKey('APIKEY', ['search'], {
	 *   validity: 300,
	 *   maxQueriesPerIPPerHour: 2000,
	 *   maxHitsPerQuery: 3,
	 *   indexes: ['fruits'],
	 *   description: 'Eat three fruits',
	 *   referers: ['*.algolia.com'],
	 *   queryParameters: {
	 *     tagFilters: ['public'],
	 *   }
	 * })
	 * @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	 */
	AlgoliaSearch.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.indexes = params.indexes;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this._jsonRequest({
	    method: 'PUT',
	    url: '/1/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	 * Initialize a new batch of search queries
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.startQueriesBatch = deprecate(function startQueriesBatchDeprecated() {
	  this._batch = [];
	}, deprecatedMessage('client.startQueriesBatch()', 'client.search()'));
	
	/**
	 * Add a search query in the batch
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.addQueryInBatch = deprecate(function addQueryInBatchDeprecated(indexName, query, args) {
	  this._batch.push({
	    indexName: indexName,
	    query: query,
	    params: args
	  });
	}, deprecatedMessage('client.addQueryInBatch()', 'client.search()'));
	
	/**
	 * Launch the batch of queries using XMLHttpRequest.
	 * @deprecated use client.search()
	 */
	AlgoliaSearch.prototype.sendQueriesBatch = deprecate(function sendQueriesBatchDeprecated(callback) {
	  return this.search(this._batch, callback);
	}, deprecatedMessage('client.sendQueriesBatch()', 'client.search()'));
	
	/**
	 * Perform write operations accross multiple indexes.
	 *
	 * To reduce the amount of time spent on network round trips,
	 * you can create, update, or delete several objects in one call,
	 * using the batch endpoint (all operations are done in the given order).
	 *
	 * Available actions:
	 *   - addObject
	 *   - updateObject
	 *   - partialUpdateObject
	 *   - partialUpdateObjectNoCreate
	 *   - deleteObject
	 *
	 * https://www.algolia.com/doc/rest_api#Indexes
	 * @param  {Object[]} operations An array of operations to perform
	 * @return {Promise|undefined} Returns a promise if no callback given
	 * @example
	 * client.batch([{
	 *   action: 'addObject',
	 *   indexName: 'clients',
	 *   body: {
	 *     name: 'Bill'
	 *   }
	 * }, {
	 *   action: 'udpateObject',
	 *   indexName: 'fruits',
	 *   body: {
	 *     objectID: '29138',
	 *     name: 'banana'
	 *   }
	 * }], cb)
	 */
	AlgoliaSearch.prototype.batch = function (operations, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: client.batch(operations[, callback])';
	
	  if (!isArray(operations)) {
	    throw new Error(usage);
	  }
	
	  return this._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/batch',
	    body: {
	      requests: operations
	    },
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	// environment specific methods
	AlgoliaSearch.prototype.destroy = notImplemented;
	AlgoliaSearch.prototype.enableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.disableRateLimitForward = notImplemented;
	AlgoliaSearch.prototype.useSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.disableSecuredAPIKey = notImplemented;
	AlgoliaSearch.prototype.generateSecuredApiKey = notImplemented;
	
	function notImplemented() {
	  var message = 'Not implemented in this environment.\n' + 'If you feel this is a mistake, write to support@algolia.com';
	
	  throw new errors.AlgoliaSearchError(message);
	}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var inherits = __webpack_require__(16);
	var IndexCore = __webpack_require__(17);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	var exitPromise = __webpack_require__(30);
	var errors = __webpack_require__(19);
	
	var deprecateForwardToSlaves = deprecate(function () {}, deprecatedMessage('forwardToSlaves', 'forwardToReplicas'));
	
	module.exports = Index;
	
	function Index() {
	  IndexCore.apply(this, arguments);
	}
	
	inherits(Index, IndexCore);
	
	/*
	* Add an object in this index
	*
	* @param content contains the javascript object to add inside the index
	* @param objectID (optional) an objectID you want to attribute to this object
	* (if the attribute already exist the old object will be overwrite)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.addObject = function (content, objectID, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof objectID === 'function') {
	    callback = objectID;
	    objectID = undefined;
	  }
	
	  return this.as._jsonRequest({
	    method: objectID !== undefined ? 'PUT' : // update or create
	    'POST', // create (API generates an objectID)
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + ( // create
	    objectID !== undefined ? '/' + encodeURIComponent(objectID) : ''), // update or create
	    body: content,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Add several objects
	*
	* @param objects contains an array of objects to add
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.addObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'addObject',
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Update partially an object (only update attributes passed in argument)
	*
	* @param partialObject contains the javascript attributes to override, the
	*  object must contains an objectID attribute
	* @param createIfNotExists (optional) if false, avoid an automatic creation of the object
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.partialUpdateObject = function (partialObject, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = undefined;
	  }
	
	  var indexObj = this;
	  var url = '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(partialObject.objectID) + '/partial';
	  if (createIfNotExists === false) {
	    url += '?createIfNotExists=false';
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: url,
	    body: partialObject,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Partially Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.partialUpdateObjects = function (objects, createIfNotExists, callback) {
	  if (arguments.length === 1 || typeof createIfNotExists === 'function') {
	    callback = createIfNotExists;
	    createIfNotExists = true;
	  }
	
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.partialUpdateObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: createIfNotExists === true ? 'partialUpdateObject' : 'partialUpdateObjectNoCreate',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of object
	*
	* @param object contains the javascript object to save, the object must contains an objectID attribute
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObject = function (object, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(object.objectID),
	    body: object,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Override the content of several objects
	*
	* @param objects contains an array of objects to update (each object must contains a objectID attribute)
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that updateAt and taskID
	*/
	Index.prototype.saveObjects = function (objects, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.saveObjects(arrayOfObjects[, callback])';
	
	  if (!isArray(objects)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: []
	  };
	  for (var i = 0; i < objects.length; ++i) {
	    var request = {
	      action: 'updateObject',
	      objectID: objects[i].objectID,
	      body: objects[i]
	    };
	    postObj.requests.push(request);
	  }
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete an object from the index
	*
	* @param objectID the unique identifier of object to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObject = function (objectID, callback) {
	  if (typeof objectID === 'function' || typeof objectID !== 'string' && typeof objectID !== 'number') {
	    var err = new errors.AlgoliaSearchError('Cannot delete an object without an objectID');
	    callback = objectID;
	    if (typeof callback === 'function') {
	      return callback(err);
	    }
	
	    return this.as._promise.reject(err);
	  }
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID),
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete several objects from an index
	*
	* @param objectIDs contains an array of objectID to delete
	* @param callback (optional) the result callback called with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains 3 elements: createAt, taskId and objectID
	*/
	Index.prototype.deleteObjects = function (objectIDs, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.deleteObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	  var postObj = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      return {
	        action: 'deleteObject',
	        objectID: objectID,
	        body: {
	          objectID: objectID
	        }
	      };
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Delete all objects matching a query
	*
	* @param query the query string
	* @param params the optional query parameters
	* @param callback (optional) the result callback called with one argument
	*  error: null or Error('message')
	*/
	Index.prototype.deleteByQuery = function (query, params, callback) {
	  var clone = __webpack_require__(24);
	  var map = __webpack_require__(29);
	
	  var indexObj = this;
	  var client = indexObj.as;
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else {
	    params = clone(params);
	  }
	
	  params.attributesToRetrieve = 'objectID';
	  params.hitsPerPage = 1000;
	  params.distinct = false;
	
	  // when deleting, we should never use cache to get the
	  // search results
	  this.clearCache();
	
	  // there's a problem in how we use the promise chain,
	  // see how waitTask is done
	  var promise = this.search(query, params).then(stopOrDelete);
	
	  function stopOrDelete(searchContent) {
	    // stop here
	    if (searchContent.nbHits === 0) {
	      // return indexObj.as._request.resolve();
	      return searchContent;
	    }
	
	    // continue and do a recursive call
	    var objectIDs = map(searchContent.hits, function getObjectID(object) {
	      return object.objectID;
	    });
	
	    return indexObj.deleteObjects(objectIDs).then(waitTask).then(doDeleteByQuery);
	  }
	
	  function waitTask(deleteObjectsContent) {
	    return indexObj.waitTask(deleteObjectsContent.taskID);
	  }
	
	  function doDeleteByQuery() {
	    return indexObj.deleteByQuery(query, params);
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(success, failure);
	
	  function success() {
	    exitPromise(function exit() {
	      callback(null);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failure(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* Browse all content from an index using events. Basically this will do
	* .browse() -> .browseFrom -> .browseFrom -> .. until all the results are returned
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @return {EventEmitter}
	* @example
	* var browser = index.browseAll('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* });
	*
	* browser.on('result', function resultCallback(content) {
	*   console.log(content.hits);
	* });
	*
	* // if any error occurs, you get it
	* browser.on('error', function(err) {
	*   throw err;
	* });
	*
	* // when you have browsed the whole index, you get this event
	* browser.on('end', function() {
	*   console.log('finished');
	* });
	*
	* // at any point if you want to stop the browsing process, you can stop it manually
	* // otherwise it will go on and on
	* browser.stop();
	*
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	Index.prototype.browseAll = function (query, queryParameters) {
	  if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
	    queryParameters = query;
	    query = undefined;
	  }
	
	  var merge = __webpack_require__(23);
	
	  var IndexBrowser = __webpack_require__(31);
	
	  var browser = new IndexBrowser();
	  var client = this.as;
	  var index = this;
	  var params = client._getSearchParams(merge({}, queryParameters || {}, {
	    query: query
	  }), '');
	
	  // start browsing
	  browseLoop();
	
	  function browseLoop(cursor) {
	    if (browser._stopped) {
	      return;
	    }
	
	    var body;
	
	    if (cursor !== undefined) {
	      body = {
	        cursor: cursor
	      };
	    } else {
	      body = {
	        params: params
	      };
	    }
	
	    client._jsonRequest({
	      method: 'POST',
	      url: '/1/indexes/' + encodeURIComponent(index.indexName) + '/browse',
	      hostType: 'read',
	      body: body,
	      callback: browseCallback
	    });
	  }
	
	  function browseCallback(err, content) {
	    if (browser._stopped) {
	      return;
	    }
	
	    if (err) {
	      browser._error(err);
	      return;
	    }
	
	    browser._result(content);
	
	    // no cursor means we are finished browsing
	    if (content.cursor === undefined) {
	      browser._end();
	      return;
	    }
	
	    browseLoop(content.cursor);
	  }
	
	  return browser;
	};
	
	/*
	* Get a Typeahead.js adapter
	* @param searchParams contains an object with query parameters (see search for details)
	*/
	Index.prototype.ttAdapter = deprecate(function (params) {
	  var self = this;
	  return function ttAdapter(query, syncCb, asyncCb) {
	    var cb;
	
	    if (typeof asyncCb === 'function') {
	      // typeahead 0.11
	      cb = asyncCb;
	    } else {
	      // pre typeahead 0.11
	      cb = syncCb;
	    }
	
	    self.search(query, params, function searchDone(err, content) {
	      if (err) {
	        cb(err);
	        return;
	      }
	
	      cb(content.hits);
	    });
	  };
	}, 'ttAdapter is not necessary anymore and will be removed in the next version,\n' + 'have a look at autocomplete.js (https://github.com/algolia/autocomplete.js)');
	
	/*
	* Wait the publication of a task on the server.
	* All server task are asynchronous and you can check with this method that the task is published.
	*
	* @param taskID the id of the task returned by server
	* @param callback the result callback with with two arguments:
	*  error: null or Error('message')
	*  content: the server answer that contains the list of results
	*/
	Index.prototype.waitTask = function (taskID, callback) {
	  // wait minimum 100ms before retrying
	  var baseDelay = 100;
	  // wait maximum 5s before retrying
	  var maxDelay = 5000;
	  var loop = 0;
	
	  // waitTask() must be handled differently from other methods,
	  // it's a recursive method using a timeout
	  var indexObj = this;
	  var client = indexObj.as;
	
	  var promise = retryLoop();
	
	  function retryLoop() {
	    return client._jsonRequest({
	      method: 'GET',
	      hostType: 'read',
	      url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/task/' + taskID
	    }).then(function success(content) {
	      loop++;
	      var delay = baseDelay * loop * loop;
	      if (delay > maxDelay) {
	        delay = maxDelay;
	      }
	
	      if (content.status !== 'published') {
	        return client._promise.delay(delay).then(retryLoop);
	      }
	
	      return content;
	    });
	  }
	
	  if (!callback) {
	    return promise;
	  }
	
	  promise.then(successCb, failureCb);
	
	  function successCb(content) {
	    exitPromise(function exit() {
	      callback(null, content);
	    }, client._setTimeout || setTimeout);
	  }
	
	  function failureCb(err) {
	    exitPromise(function exit() {
	      callback(err);
	    }, client._setTimeout || setTimeout);
	  }
	};
	
	/*
	* This function deletes the index content. Settings and index specific API keys are kept untouched.
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.clearIndex = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/clear',
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	* Get settings of this index
	*
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the settings object or the error message if a failure occured
	*/
	Index.prototype.getSettings = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?getVersion=2',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.searchSynonyms = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveSynonym = function (synonym, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(synonym.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: synonym,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getSynonym = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteSynonym = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearSynonyms = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchSynonyms = function (synonyms, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/synonyms/batch' + '?forwardToReplicas=' + forwardToReplicas + '&replaceExistingSynonyms=' + (opts.replaceExistingSynonyms ? 'true' : 'false'),
	    hostType: 'write',
	    body: synonyms,
	    callback: callback
	  });
	};
	
	Index.prototype.searchRules = function (params, callback) {
	  if (typeof params === 'function') {
	    callback = params;
	    params = {};
	  } else if (params === undefined) {
	    params = {};
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/search',
	    body: params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.saveRule = function (rule, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(rule.objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    body: rule,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.getRule = function (objectID, callback) {
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID),
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	Index.prototype.deleteRule = function (objectID, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/' + encodeURIComponent(objectID) + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.clearRules = function (opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/clear' + '?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	Index.prototype.batchRules = function (rules, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var forwardToReplicas = opts.forwardToReplicas === true ? 'true' : 'false';
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/rules/batch' + '?forwardToReplicas=' + forwardToReplicas + '&clearExistingRules=' + (opts.clearExistingRules === true ? 'true' : 'false'),
	    hostType: 'write',
	    body: rules,
	    callback: callback
	  });
	};
	
	/*
	* Set settings for this index
	*
	* @param settigns the settings object that can contains :
	* - minWordSizefor1Typo: (integer) the minimum number of characters to accept one typo (default = 3).
	* - minWordSizefor2Typos: (integer) the minimum number of characters to accept two typos (default = 7).
	* - hitsPerPage: (integer) the number of hits per page (default = 10).
	* - attributesToRetrieve: (array of strings) default list of attributes to retrieve in objects.
	*   If set to null, all attributes are retrieved.
	* - attributesToHighlight: (array of strings) default list of attributes to highlight.
	*   If set to null, all indexed attributes are highlighted.
	* - attributesToSnippet**: (array of strings) default list of attributes to snippet alongside the number
	* of words to return (syntax is attributeName:nbWords).
	*   By default no snippet is computed. If set to null, no snippet is computed.
	* - attributesToIndex: (array of strings) the list of fields you want to index.
	*   If set to null, all textual and numerical attributes of your objects are indexed,
	*   but you should update it to get optimal results.
	*   This parameter has two important uses:
	*     - Limit the attributes to index: For example if you store a binary image in base64,
	*     you want to store it and be able to
	*       retrieve it but you don't want to search in the base64 string.
	*     - Control part of the ranking*: (see the ranking parameter for full explanation)
	*     Matches in attributes at the beginning of
	*       the list will be considered more important than matches in attributes further down the list.
	*       In one attribute, matching text at the beginning of the attribute will be
	*       considered more important than text after, you can disable
	*       this behavior if you add your attribute inside `unordered(AttributeName)`,
	*       for example attributesToIndex: ["title", "unordered(text)"].
	* - attributesForFaceting: (array of strings) The list of fields you want to use for faceting.
	*   All strings in the attribute selected for faceting are extracted and added as a facet.
	*   If set to null, no attribute is used for faceting.
	* - attributeForDistinct: (string) The attribute name used for the Distinct feature.
	* This feature is similar to the SQL "distinct" keyword: when enabled
	*   in query with the distinct=1 parameter, all hits containing a duplicate
	*   value for this attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best one is kept and others are removed.
	* - ranking: (array of strings) controls the way results are sorted.
	*   We have six available criteria:
	*    - typo: sort according to number of typos,
	*    - geo: sort according to decreassing distance when performing a geo-location based search,
	*    - proximity: sort according to the proximity of query words in hits,
	*    - attribute: sort according to the order of attributes defined by attributesToIndex,
	*    - exact:
	*        - if the user query contains one word: sort objects having an attribute
	*        that is exactly the query word before others.
	*          For example if you search for the "V" TV show, you want to find it
	*          with the "V" query and avoid to have all popular TV
	*          show starting by the v letter before it.
	*        - if the user query contains multiple words: sort according to the
	*        number of words that matched exactly (and not as a prefix).
	*    - custom: sort according to a user defined formula set in **customRanking** attribute.
	*   The standard order is ["typo", "geo", "proximity", "attribute", "exact", "custom"]
	* - customRanking: (array of strings) lets you specify part of the ranking.
	*   The syntax of this condition is an array of strings containing attributes
	*   prefixed by asc (ascending order) or desc (descending order) operator.
	*   For example `"customRanking" => ["desc(population)", "asc(name)"]`
	* - queryType: Select how the query words are interpreted, it can be one of the following value:
	*   - prefixAll: all query words are interpreted as prefixes,
	*   - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*   - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - highlightPreTag: (string) Specify the string that is inserted before
	* the highlighted parts in the query result (default to "<em>").
	* - highlightPostTag: (string) Specify the string that is inserted after
	* the highlighted parts in the query result (default to "</em>").
	* - optionalWords: (array of strings) Specify a list of words that should
	* be considered as optional when found in the query.
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer or the error message if a failure occured
	*/
	Index.prototype.setSettings = function (settings, opts, callback) {
	  if (arguments.length === 1 || typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	
	  if (opts.forwardToSlaves !== undefined) deprecateForwardToSlaves();
	  var forwardToReplicas = opts.forwardToSlaves || opts.forwardToReplicas ? 'true' : 'false';
	
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings?forwardToReplicas=' + forwardToReplicas,
	    hostType: 'write',
	    body: settings,
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.listApiKeys
	 */
	Index.prototype.listUserKeys = deprecate(function (callback) {
	  return this.listApiKeys(callback);
	}, deprecatedMessage('index.listUserKeys()', 'index.listApiKeys()'));
	
	/*
	* List all existing API keys to this index
	*
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with API keys belonging to the index
	*/
	Index.prototype.listApiKeys = function (callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys',
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.getApiKey
	 */
	Index.prototype.getUserKeyACL = deprecate(function (key, callback) {
	  return this.getApiKey(key, callback);
	}, deprecatedMessage('index.getUserKeyACL()', 'index.getApiKey()'));
	
	/*
	* Get an API key from this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the right API key
	*/
	Index.prototype.getApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.deleteApiKey
	 */
	Index.prototype.deleteUserKey = deprecate(function (key, callback) {
	  return this.deleteApiKey(key, callback);
	}, deprecatedMessage('index.deleteUserKey()', 'index.deleteApiKey()'));
	
	/*
	* Delete an existing API key associated to this index
	*
	* @param key
	* @param callback the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the server answer with the deletion date
	*/
	Index.prototype.deleteApiKey = function (key, callback) {
	  var indexObj = this;
	  return this.as._jsonRequest({
	    method: 'DELETE',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/*
	 @deprecated see index.addApiKey
	 */
	Index.prototype.addUserKey = deprecate(function (acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKey()', 'index.addApiKey()'));
	
	/*
	* Add a new API key to this index
	*
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the added API key
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.addUserKey(['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#AddIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.addApiKey = function (acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.addApiKey(arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 1 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var postObj = {
	    acl: acls
	  };
	
	  if (params) {
	    postObj.validity = params.validity;
	    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    postObj.description = params.description;
	
	    if (params.queryParameters) {
	      postObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    postObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys',
	    body: postObj,
	    hostType: 'write',
	    callback: callback
	  });
	};
	
	/**
	* @deprecated use index.addApiKey()
	*/
	Index.prototype.addUserKeyWithValidity = deprecate(function deprecatedAddUserKeyWithValidity(acls, params, callback) {
	  return this.addApiKey(acls, params, callback);
	}, deprecatedMessage('index.addUserKeyWithValidity()', 'index.addApiKey()'));
	
	/*
	 @deprecated see index.updateApiKey
	 */
	Index.prototype.updateUserKey = deprecate(function (key, acls, params, callback) {
	  return this.updateApiKey(key, acls, params, callback);
	}, deprecatedMessage('index.updateUserKey()', 'index.updateApiKey()'));
	
	/**
	* Update an existing API key of this index
	* @param {string} key - The key to update
	* @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
	*   can contains the following values:
	*     - search: allow to search (https and http)
	*     - addObject: allows to add/update an object in the index (https only)
	*     - deleteObject : allows to delete an existing object (https only)
	*     - deleteIndex : allows to delete index content (https only)
	*     - settings : allows to get index settings (https only)
	*     - editSettings : allows to change index settings (https only)
	* @param {Object} [params] - Optionnal parameters to set for the key
	* @param {number} params.validity - Number of seconds after which the key will
	* be automatically removed (0 means no time limit for this key)
	* @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
	* @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
	* @param {string} params.description - A description for your key
	* @param {string[]} params.referers - A list of authorized referers
	* @param {Object} params.queryParameters - Force the key to use specific query parameters
	* @param {Function} callback - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with user keys list
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.updateApiKey('APIKEY', ['search'], {
	*   validity: 300,
	*   maxQueriesPerIPPerHour: 2000,
	*   maxHitsPerQuery: 3,
	*   description: 'Eat three fruits',
	*   referers: ['*.algolia.com'],
	*   queryParameters: {
	*     tagFilters: ['public'],
	*   }
	* })
	* @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}
	*/
	Index.prototype.updateApiKey = function (key, acls, params, callback) {
	  var isArray = __webpack_require__(28);
	  var usage = 'Usage: index.updateApiKey(key, arrayOfAcls[, params, callback])';
	
	  if (!isArray(acls)) {
	    throw new Error(usage);
	  }
	
	  if (arguments.length === 2 || typeof params === 'function') {
	    callback = params;
	    params = null;
	  }
	
	  var putObj = {
	    acl: acls
	  };
	
	  if (params) {
	    putObj.validity = params.validity;
	    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
	    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
	    putObj.description = params.description;
	
	    if (params.queryParameters) {
	      putObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');
	    }
	
	    putObj.referers = params.referers;
	  }
	
	  return this.as._jsonRequest({
	    method: 'PUT',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys/' + key,
	    body: putObj,
	    hostType: 'write',
	    callback: callback
	  });
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';
	
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var buildSearchMethod = __webpack_require__(18);
	var deprecate = __webpack_require__(21);
	var deprecatedMessage = __webpack_require__(22);
	
	module.exports = IndexCore;
	
	/*
	* Index class constructor.
	* You should not use this method directly but use initIndex() function
	*/
	function IndexCore(algoliasearch, indexName) {
	  this.indexName = indexName;
	  this.as = algoliasearch;
	  this.typeAheadArgs = null;
	  this.typeAheadValueOption = null;
	
	  // make sure every index instance has it's own cache
	  this.cache = {};
	}
	
	/*
	* Clear all queries in cache
	*/
	IndexCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/*
	* Search inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the full text query
	* @param {object} [args] (optional) if set, contains an object with query parameters:
	* - page: (integer) Pagination parameter used to select the page to retrieve.
	*                   Page is zero-based and defaults to 0. Thus,
	*                   to retrieve the 10th page you need to set page=9
	* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.
	* - attributesToRetrieve: a string that contains the list of object attributes
	* you want to retrieve (let you minimize the answer size).
	*   Attributes are separated with a comma (for example "name,address").
	*   You can also use an array (for example ["name","address"]).
	*   By default, all attributes are retrieved. You can also use '*' to retrieve all
	*   values when an attributesToRetrieve setting is specified for your index.
	* - attributesToHighlight: a string that contains the list of attributes you
	*   want to highlight according to the query.
	*   Attributes are separated by a comma. You can also use an array (for example ["name","address"]).
	*   If an attribute has no match for the query, the raw value is returned.
	*   By default all indexed text attributes are highlighted.
	*   You can use `*` if you want to highlight all textual attributes.
	*   Numerical attributes are not highlighted.
	*   A matchLevel is returned for each highlighted attribute and can contain:
	*      - full: if all the query terms were found in the attribute,
	*      - partial: if only some of the query terms were found,
	*      - none: if none of the query terms were found.
	* - attributesToSnippet: a string that contains the list of attributes to snippet alongside
	* the number of words to return (syntax is `attributeName:nbWords`).
	*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).
	*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).
	*    By default no snippet is computed.
	* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.
	* Defaults to 3.
	* - minWordSizefor2Typos: the minimum number of characters in a query word
	* to accept two typos in this word. Defaults to 7.
	* - getRankingInfo: if set to 1, the result hits will contain ranking
	* information in _rankingInfo attribute.
	* - aroundLatLng: search for entries around a given
	* latitude/longitude (specified as two floats separated by a comma).
	*   For example aroundLatLng=47.316669,5.016670).
	*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)
	*   and the precision for ranking with aroundPrecision
	*   (for example if you set aroundPrecision=100, two objects that are distant of
	*   less than 100m will be considered as identical for "geo" ranking parameter).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - insideBoundingBox: search entries inside a given area defined by the two extreme points
	* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).
	*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).
	*   At indexing, you should specify geoloc of an object with the _geoloc attribute
	*   (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
	* - numericFilters: a string that contains the list of numeric filters you want to
	* apply separated by a comma.
	*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.
	*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.
	*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.
	*   You can also use an array (for example numericFilters: ["price>100","price<1000"]).
	* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.
	*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).
	*   You can also use an array, for example tagFilters: ["tag1",["tag2","tag3"]]
	*   means tag1 AND (tag2 OR tag3).
	*   At indexing, tags should be added in the _tags** attribute
	*   of objects (for example {"_tags":["tag1","tag2"]}).
	* - facetFilters: filter the query by a list of facets.
	*   Facets are separated by commas and each facet is encoded as `attributeName:value`.
	*   For example: `facetFilters=category:Book,author:John%20Doe`.
	*   You can also use an array (for example `["category:Book","author:John%20Doe"]`).
	* - facets: List of object attributes that you want to use for faceting.
	*   Comma separated list: `"category,author"` or array `['category','author']`
	*   Only attributes that have been added in **attributesForFaceting** index setting
	*   can be used in this parameter.
	*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.
	* - queryType: select how the query words are interpreted, it can be one of the following value:
	*    - prefixAll: all query words are interpreted as prefixes,
	*    - prefixLast: only the last word is interpreted as a prefix (default behavior),
	*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
	* - optionalWords: a string that contains the list of words that should
	* be considered as optional when found in the query.
	*   Comma separated and array are accepted.
	* - distinct: If set to 1, enable the distinct feature (disabled by default)
	* if the attributeForDistinct index setting is set.
	*   This feature is similar to the SQL "distinct" keyword: when enabled
	*   in a query with the distinct=1 parameter,
	*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.
	*   For example, if the chosen attribute is show_name and several hits have
	*   the same value for show_name, then only the best
	*   one is kept and others are removed.
	* - restrictSearchableAttributes: List of attributes you want to use for
	* textual search (must be a subset of the attributesToIndex index setting)
	* either comma separated or as an array
	* @param {function} [callback] the result callback called with two arguments:
	*  error: null or Error('message'). If false, the content contains the error.
	*  content: the server answer that contains the list of results.
	*/
	IndexCore.prototype.search = buildSearchMethod('query');
	
	/*
	* -- BETA --
	* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to
	* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
	*
	* @param {string} [query] the similar query
	* @param {object} [args] (optional) if set, contains an object with query parameters.
	*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters
	*   are the two most useful to restrict the similar results and get more relevant content
	*/
	IndexCore.prototype.similarSearch = buildSearchMethod('similarQuery');
	
	/*
	* Browse index content. The response content will have a `cursor` property that you can use
	* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browse('cool songs', {
	*   tagFilters: 'public,comments',
	*   hitsPerPage: 500
	* }, callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browse = function (query, queryParameters, callback) {
	  var merge = __webpack_require__(23);
	
	  var indexObj = this;
	
	  var page;
	  var hitsPerPage;
	
	  // we check variadic calls that are not the one defined
	  // .browse()/.browse(fn)
	  // => page = 0
	  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {
	    page = 0;
	    callback = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'number') {
	    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)
	    page = arguments[0];
	    if (typeof arguments[1] === 'number') {
	      hitsPerPage = arguments[1];
	    } else if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	      hitsPerPage = undefined;
	    }
	    query = undefined;
	    queryParameters = undefined;
	  } else if (_typeof(arguments[0]) === 'object') {
	    // .browse(queryParameters)/.browse(queryParameters, cb)
	    if (typeof arguments[1] === 'function') {
	      callback = arguments[1];
	    }
	    queryParameters = arguments[0];
	    query = undefined;
	  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {
	    // .browse(query, cb)
	    callback = arguments[1];
	    queryParameters = undefined;
	  }
	
	  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)
	
	  // get search query parameters combining various possible calls
	  // to .browse();
	  queryParameters = merge({}, queryParameters || {}, {
	    page: page,
	    hitsPerPage: hitsPerPage,
	    query: query
	  });
	
	  var params = this.as._getSearchParams(queryParameters, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',
	    body: { params: params },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.
	*
	* @param {string} query - The full text query
	* @param {Object} [queryParameters] - Any search query parameter
	* @param {Function} [callback] - The result callback called with two arguments
	*   error: null or Error('message')
	*   content: the server answer with the browse result
	* @return {Promise|undefined} Returns a promise if no callback given
	* @example
	* index.browseFrom('14lkfsakl32', callback);
	* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}
	*/
	IndexCore.prototype.browseFrom = function (cursor, callback) {
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',
	    body: { cursor: cursor },
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Search for facet values
	* https://www.algolia.com/doc/rest-api/search#search-for-facet-values
	*
	* @param {string} params.facetName Facet name, name of the attribute to search for values in.
	* Must be declared as a facet
	* @param {string} params.facetQuery Query for the facet search
	* @param {string} [params.*] Any search parameter of Algolia,
	* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters
	* Pagination is not supported. The page and hitsPerPage parameters will be ignored.
	* @param callback (optional)
	*/
	IndexCore.prototype.searchForFacetValues = function (params, callback) {
	  var clone = __webpack_require__(24);
	  var omit = __webpack_require__(25);
	  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';
	
	  if (params.facetName === undefined || params.facetQuery === undefined) {
	    throw new Error(usage);
	  }
	
	  var facetName = params.facetName;
	  var filteredParams = omit(clone(params), function (keyName) {
	    return keyName === 'facetName';
	  });
	  var searchParameters = this.as._getSearchParams(filteredParams, '');
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',
	    hostType: 'read',
	    body: { params: searchParameters },
	    callback: callback
	  });
	};
	
	IndexCore.prototype.searchFacet = deprecate(function (params, callback) {
	  return this.searchForFacetValues(params, callback);
	}, deprecatedMessage('index.searchFacet(params[, callback])', 'index.searchForFacetValues(params[, callback])'));
	
	IndexCore.prototype._search = function (params, url, callback, additionalUA) {
	  return this.as._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',
	    body: { params: params },
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/' + encodeURIComponent(this.indexName),
	      body: { params: params }
	    },
	    callback: callback,
	    additionalUA: additionalUA
	  });
	};
	
	/*
	* Get an object from this index
	*
	* @param objectID the unique identifier of the object to retrieve
	* @param attrs (optional) if set, contains the array of attribute names to retrieve
	* @param callback (optional) the result callback called with two arguments
	*  error: null or Error('message')
	*  content: the object to retrieve or the error message if a failure occured
	*/
	IndexCore.prototype.getObject = function (objectID, attrs, callback) {
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attrs === 'function') {
	    callback = attrs;
	    attrs = undefined;
	  }
	
	  var params = '';
	  if (attrs !== undefined) {
	    params = '?attributes=';
	    for (var i = 0; i < attrs.length; ++i) {
	      if (i !== 0) {
	        params += ',';
	      }
	      params += attrs[i];
	    }
	  }
	
	  return this.as._jsonRequest({
	    method: 'GET',
	    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,
	    hostType: 'read',
	    callback: callback
	  });
	};
	
	/*
	* Get several objects from this index
	*
	* @param objectIDs the array of unique identifier of objects to retrieve
	*/
	IndexCore.prototype.getObjects = function (objectIDs, attributesToRetrieve, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';
	
	  if (!isArray(objectIDs)) {
	    throw new Error(usage);
	  }
	
	  var indexObj = this;
	
	  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {
	    callback = attributesToRetrieve;
	    attributesToRetrieve = undefined;
	  }
	
	  var body = {
	    requests: map(objectIDs, function prepareRequest(objectID) {
	      var request = {
	        indexName: indexObj.indexName,
	        objectID: objectID
	      };
	
	      if (attributesToRetrieve) {
	        request.attributesToRetrieve = attributesToRetrieve.join(',');
	      }
	
	      return request;
	    })
	  };
	
	  return this.as._jsonRequest({
	    method: 'POST',
	    url: '/1/indexes/*/objects',
	    hostType: 'read',
	    body: body,
	    callback: callback
	  });
	};
	
	IndexCore.prototype.as = null;
	IndexCore.prototype.indexName = null;
	IndexCore.prototype.typeAheadArgs = null;
	IndexCore.prototype.typeAheadValueOption = null;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = buildSearchMethod;
	
	var errors = __webpack_require__(19);
	
	/**
	 * Creates a search method to be used in clients
	 * @param {string} queryParam the name of the attribute used for the query
	 * @param {string} url the url
	 * @return {function} the search method
	 */
	function buildSearchMethod(queryParam, url) {
	  /**
	   * The search method. Prepares the data and send the query to Algolia.
	   * @param {string} query the string used for query search
	   * @param {object} args additional parameters to send with the search
	   * @param {function} [callback] the callback to be called with the client gets the answer
	   * @return {undefined|Promise} If the callback is not provided then this methods returns a Promise
	   */
	  return function search(query, args, callback) {
	    // warn V2 users on how to search
	    if (typeof query === 'function' && (typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' || (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) === 'object') {
	      // .search(query, params, cb)
	      // .search(cb, params)
	      throw new errors.AlgoliaSearchError('index.search usage is index.search(query, params, cb)');
	    }
	
	    // Normalizing the function signature
	    if (arguments.length === 0 || typeof query === 'function') {
	      // Usage : .search(), .search(cb)
	      callback = query;
	      query = '';
	    } else if (arguments.length === 1 || typeof args === 'function') {
	      // Usage : .search(query/args), .search(query, cb)
	      callback = args;
	      args = undefined;
	    }
	    // At this point we have 3 arguments with values
	
	    // Usage : .search(args) // careful: typeof null === 'object'
	    if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object' && query !== null) {
	      args = query;
	      query = undefined;
	    } else if (query === undefined || query === null) {
	      // .search(undefined/null)
	      query = '';
	    }
	
	    var params = '';
	
	    if (query !== undefined) {
	      params += queryParam + '=' + encodeURIComponent(query);
	    }
	
	    var additionalUA;
	    if (args !== undefined) {
	      if (args.additionalUA) {
	        additionalUA = args.additionalUA;
	        delete args.additionalUA;
	      }
	      // `_getSearchParams` will augment params, do not be fooled by the = versus += from previous if
	      params = this.as._getSearchParams(args, params);
	    }
	
	    return this._search(params, url, callback, additionalUA);
	  };
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This file hosts our error definitions
	// We use custom error "types" so that we can act on them when we need it
	// e.g.: if error instanceof errors.UnparsableJSON then..
	
	var inherits = __webpack_require__(16);
	
	function AlgoliaSearchError(message, extraProperties) {
	  var forEach = __webpack_require__(20);
	
	  var error = this;
	
	  // try to get a stacktrace
	  if (typeof Error.captureStackTrace === 'function') {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    error.stack = new Error().stack || 'Cannot get a stacktrace, browser is too old';
	  }
	
	  this.name = 'AlgoliaSearchError';
	  this.message = message || 'Unknown error';
	
	  if (extraProperties) {
	    forEach(extraProperties, function addToErrorObject(value, key) {
	      error[key] = value;
	    });
	  }
	}
	
	inherits(AlgoliaSearchError, Error);
	
	function createCustomError(name, message) {
	  function AlgoliaSearchCustomError() {
	    var args = Array.prototype.slice.call(arguments, 0);
	
	    // custom message not set, use default
	    if (typeof args[0] !== 'string') {
	      args.unshift(message);
	    }
	
	    AlgoliaSearchError.apply(this, args);
	    this.name = 'AlgoliaSearch' + name + 'Error';
	  }
	
	  inherits(AlgoliaSearchCustomError, AlgoliaSearchError);
	
	  return AlgoliaSearchCustomError;
	}
	
	// late exports to let various fn defs and inherits take place
	module.exports = {
	  AlgoliaSearchError: AlgoliaSearchError,
	  UnparsableJSON: createCustomError('UnparsableJSON', 'Could not parse the incoming response as JSON, see err.more for details'),
	  RequestTimeout: createCustomError('RequestTimeout', 'Request timedout before getting a response'),
	  Network: createCustomError('Network', 'Network issue, see err.more for details'),
	  JSONPScriptFail: createCustomError('JSONPScriptFail', '<script> was loaded but did not call our provided callback'),
	  JSONPScriptError: createCustomError('JSONPScriptError', '<script> unable to load due to an `error` event on it'),
	  Unknown: createCustomError('Unknown', 'Unknown error occured')
	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = function forEach(obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function deprecate(fn, message) {
	  var warned = false;
	
	  function deprecated() {
	    if (!warned) {
	      /* eslint no-console:0 */
	      console.warn(message);
	      warned = true;
	    }
	
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function deprecatedMessage(previousUsage, newUsage) {
	  var githubAnchorLink = previousUsage.toLowerCase().replace(/[\.\(\)]/g, '');
	
	  return 'algoliasearch: `' + previousUsage + '` was replaced by `' + newUsage + '`. Please see https://github.com/algolia/algoliasearch-client-javascript/wiki/Deprecated#' + githubAnchorLink;
	};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var foreach = __webpack_require__(20);
	
	module.exports = function merge(destination /* , sources */) {
	  var sources = Array.prototype.slice.call(arguments);
	
	  foreach(sources, function (source) {
	    for (var keyName in source) {
	      if (source.hasOwnProperty(keyName)) {
	        if (_typeof(destination[keyName]) === 'object' && _typeof(source[keyName]) === 'object') {
	          destination[keyName] = merge({}, destination[keyName], source[keyName]);
	        } else if (source[keyName] !== undefined) {
	          destination[keyName] = source[keyName];
	        }
	      }
	    }
	  });
	
	  return destination;
	};

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function clone(obj) {
	  return JSON.parse(JSON.stringify(obj));
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = function omit(obj, test) {
	  var keys = __webpack_require__(26);
	  var foreach = __webpack_require__(20);
	
	  var filtered = {};
	
	  foreach(keys(obj), function doFilter(keyName) {
	    if (test(keyName) !== true) {
	      filtered[keyName] = obj[keyName];
	    }
	  });
	
	  return filtered;
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// modified from https://github.com/es-shims/es5-shim
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(27);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
	var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = function () {
		/* global window */
		if (typeof window === 'undefined') {
			return false;
		}
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}();
	var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};
	
	var keysShim = function keys(object) {
		var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];
	
		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}
	
		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}
	
		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}
	
		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	
			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
	
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2);
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};
	
	module.exports = keysShim;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toStr = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	'use strict';
	
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var foreach = __webpack_require__(20);
	
	module.exports = function map(arr, fn) {
	  var newArr = [];
	  foreach(arr, function (item, itemIndex) {
	    newArr.push(fn(item, itemIndex, arr));
	  });
	  return newArr;
	};

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	"use strict";
	
	// Parse cloud does not supports setTimeout
	// We do not store a setTimeout reference in the client everytime
	// We only fallback to a fake setTimeout when not available
	// setTimeout cannot be override globally sadly
	module.exports = function exitPromise(fn, _setTimeout) {
	  _setTimeout(fn, 0);
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// This is the object returned by the `index.browseAll()` method
	
	module.exports = IndexBrowser;
	
	var inherits = __webpack_require__(16);
	var EventEmitter = __webpack_require__(32).EventEmitter;
	
	function IndexBrowser() {}
	
	inherits(IndexBrowser, EventEmitter);
	
	IndexBrowser.prototype.stop = function () {
	  this._stopped = true;
	  this._clean();
	};
	
	IndexBrowser.prototype._end = function () {
	  this.emit('end');
	  this._clean();
	};
	
	IndexBrowser.prototype._error = function (err) {
	  this.emit('error', err);
	  this._clean();
	};
	
	IndexBrowser.prototype._result = function (content) {
	  this.emit('result', content);
	};
	
	IndexBrowser.prototype._clean = function () {
	  this.removeAllListeners('stop');
	  this.removeAllListeners('end');
	  this.removeAllListeners('error');
	  this.removeAllListeners('result');
	};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function (type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events) this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler)) return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function (type, listener) {
	  var m;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events) this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function (type, listener) {
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function (type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener)) throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type]) return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener || isFunction(list.listener) && list.listener === listener) {
	    delete this._events[type];
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0) return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function (type) {
	  var key, listeners;
	
	  if (!this._events) return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length) {
	      this.removeListener(type, listeners[listeners.length - 1]);
	    }
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function (type) {
	  var ret;
	  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function (type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function (emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = AlgoliaSearchCore;
	
	var errors = __webpack_require__(19);
	var exitPromise = __webpack_require__(30);
	var IndexCore = __webpack_require__(17);
	var store = __webpack_require__(34);
	
	// We will always put the API KEY in the JSON body in case of too long API KEY,
	// to avoid query string being too long and failing in various conditions (our server limit, browser limit,
	// proxies limit)
	var MAX_API_KEY_LENGTH = 500;
	var RESET_APP_DATA_TIMER = process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) || 60 * 2 * 1000; // after 2 minutes reset to first host
	
	/*
	 * Algolia Search library initialization
	 * https://www.algolia.com/
	 *
	 * @param {string} applicationID - Your applicationID, found in your dashboard
	 * @param {string} apiKey - Your API key, found in your dashboard
	 * @param {Object} [opts]
	 * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,
	 * another request will be issued after this timeout
	 * @param {string} [opts.protocol='http:'] - The protocol used to query Algolia Search API.
	 *                                        Set to 'https:' to force using https.
	 *                                        Default to document.location.protocol in browsers
	 * @param {Object|Array} [opts.hosts={
	 *           read: [this.applicationID + '-dsn.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]),
	 *           write: [this.applicationID + '.algolia.net'].concat([
	 *             this.applicationID + '-1.algolianet.com',
	 *             this.applicationID + '-2.algolianet.com',
	 *             this.applicationID + '-3.algolianet.com']
	 *           ]) - The hosts to use for Algolia Search API.
	 *           If you provide them, you will less benefit from our HA implementation
	 */
	function AlgoliaSearchCore(applicationID, apiKey, opts) {
	  var debug = __webpack_require__(35)('algoliasearch');
	
	  var clone = __webpack_require__(24);
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';
	
	  if (opts._allowEmptyCredentials !== true && !applicationID) {
	    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);
	  }
	
	  if (opts._allowEmptyCredentials !== true && !apiKey) {
	    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);
	  }
	
	  this.applicationID = applicationID;
	  this.apiKey = apiKey;
	
	  this.hosts = {
	    read: [],
	    write: []
	  };
	
	  opts = opts || {};
	
	  var protocol = opts.protocol || 'https:';
	  this._timeouts = opts.timeouts || {
	    connect: 1 * 1000, // 500ms connect is GPRS latency
	    read: 2 * 1000,
	    write: 30 * 1000
	  };
	
	  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before
	  if (opts.timeout) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;
	  }
	
	  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`
	  // we also accept `http` and `https`. It's a common error.
	  if (!/:$/.test(protocol)) {
	    protocol = protocol + ':';
	  }
	
	  if (opts.protocol !== 'http:' && opts.protocol !== 'https:') {
	    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');
	  }
	
	  this._checkAppIdData();
	
	  if (!opts.hosts) {
	    var defaultHosts = map(this._shuffleResult, function (hostNumber) {
	      return applicationID + '-' + hostNumber + '.algolianet.com';
	    });
	
	    // no hosts given, compute defaults
	    this.hosts.read = [this.applicationID + '-dsn.algolia.net'].concat(defaultHosts);
	    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);
	  } else if (isArray(opts.hosts)) {
	    // when passing custom hosts, we need to have a different host index if the number
	    // of write/read hosts are different.
	    this.hosts.read = clone(opts.hosts);
	    this.hosts.write = clone(opts.hosts);
	  } else {
	    this.hosts.read = clone(opts.hosts.read);
	    this.hosts.write = clone(opts.hosts.write);
	  }
	
	  // add protocol and lowercase hosts
	  this.hosts.read = map(this.hosts.read, prepareHost(protocol));
	  this.hosts.write = map(this.hosts.write, prepareHost(protocol));
	
	  this.extraHeaders = {};
	
	  // In some situations you might want to warm the cache
	  this.cache = opts._cache || {};
	
	  this._ua = opts._ua;
	  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;
	  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;
	
	  this._setTimeout = opts._setTimeout;
	
	  debug('init done, %j', this);
	}
	
	/*
	 * Get the index object initialized
	 *
	 * @param indexName the name of index
	 * @param callback the result callback with one argument (the Index instance)
	 */
	AlgoliaSearchCore.prototype.initIndex = function (indexName) {
	  return new IndexCore(this, indexName);
	};
	
	/**
	* Add an extra field to the HTTP request
	*
	* @param name the header field name
	* @param value the header field value
	*/
	AlgoliaSearchCore.prototype.setExtraHeader = function (name, value) {
	  this.extraHeaders[name.toLowerCase()] = value;
	};
	
	/**
	* Get the value of an extra HTTP header
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.getExtraHeader = function (name) {
	  return this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Remove an extra field from the HTTP request
	*
	* @param name the header field name
	*/
	AlgoliaSearchCore.prototype.unsetExtraHeader = function (name) {
	  delete this.extraHeaders[name.toLowerCase()];
	};
	
	/**
	* Augment sent x-algolia-agent with more data, each agent part
	* is automatically separated from the others by a semicolon;
	*
	* @param algoliaAgent the agent to add
	*/
	AlgoliaSearchCore.prototype.addAlgoliaAgent = function (algoliaAgent) {
	  if (this._ua.indexOf(';' + algoliaAgent) === -1) {
	    this._ua += ';' + algoliaAgent;
	  }
	};
	
	/*
	 * Wrapper that try all hosts to maximize the quality of service
	 */
	AlgoliaSearchCore.prototype._jsonRequest = function (initialOpts) {
	  this._checkAppIdData();
	
	  var requestDebug = __webpack_require__(35)('algoliasearch:' + initialOpts.url);
	
	  var body;
	  var additionalUA = initialOpts.additionalUA || '';
	  var cache = initialOpts.cache;
	  var client = this;
	  var tries = 0;
	  var usingFallback = false;
	  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;
	  var headers;
	
	  if (this.apiKey.length > MAX_API_KEY_LENGTH && initialOpts.body !== undefined && (initialOpts.body.params !== undefined || // index.search()
	  initialOpts.body.requests !== undefined) // client.search()
	  ) {
	      initialOpts.body.apiKey = this.apiKey;
	      headers = this._computeRequestHeaders(additionalUA, false);
	    } else {
	    headers = this._computeRequestHeaders(additionalUA);
	  }
	
	  if (initialOpts.body !== undefined) {
	    body = safeJSONStringify(initialOpts.body);
	  }
	
	  requestDebug('request start');
	  var debugData = [];
	
	  function doRequest(requester, reqOpts) {
	    client._checkAppIdData();
	
	    var startTime = new Date();
	    var cacheID;
	
	    if (client._useCache) {
	      cacheID = initialOpts.url;
	    }
	
	    // as we sometime use POST requests to pass parameters (like query='aa'),
	    // the cacheID must also include the body to be different between calls
	    if (client._useCache && body) {
	      cacheID += '_body_' + reqOpts.body;
	    }
	
	    // handle cache existence
	    if (client._useCache && cache && cache[cacheID] !== undefined) {
	      requestDebug('serving response from cache');
	      return client._promise.resolve(JSON.parse(cache[cacheID]));
	    }
	
	    // if we reached max tries
	    if (tries >= client.hosts[initialOpts.hostType].length) {
	      if (!hasFallback || usingFallback) {
	        requestDebug('could not get any response');
	        // then stop
	        return client._promise.reject(new errors.AlgoliaSearchError('Cannot connect to the AlgoliaSearch API.' + ' Send an email to support@algolia.com to report and resolve the issue.' + ' Application id was: ' + client.applicationID, { debugData: debugData }));
	      }
	
	      requestDebug('switching to fallback');
	
	      // let's try the fallback starting from here
	      tries = 0;
	
	      // method, url and body are fallback dependent
	      reqOpts.method = initialOpts.fallback.method;
	      reqOpts.url = initialOpts.fallback.url;
	      reqOpts.jsonBody = initialOpts.fallback.body;
	      if (reqOpts.jsonBody) {
	        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);
	      }
	      // re-compute headers, they could be omitting the API KEY
	      headers = client._computeRequestHeaders(additionalUA);
	
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      client._setHostIndexByType(0, initialOpts.hostType);
	      usingFallback = true; // the current request is now using fallback
	      return doRequest(client._request.fallback, reqOpts);
	    }
	
	    var currentHost = client._getHostByType(initialOpts.hostType);
	
	    var url = currentHost + reqOpts.url;
	    var options = {
	      body: reqOpts.body,
	      jsonBody: reqOpts.jsonBody,
	      method: reqOpts.method,
	      headers: headers,
	      timeouts: reqOpts.timeouts,
	      debug: requestDebug
	    };
	
	    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d', options.method, url, options.headers, options.timeouts);
	
	    if (requester === client._request.fallback) {
	      requestDebug('using fallback');
	    }
	
	    // `requester` is any of this._request or this._request.fallback
	    // thus it needs to be called using the client as context
	    return requester.call(client, url, options).then(success, tryFallback);
	
	    function success(httpResponse) {
	      // compute the status of the response,
	      //
	      // When in browser mode, using XDR or JSONP, we have no statusCode available
	      // So we rely on our API response `status` property.
	      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)
	      // So we check if there's a `message` along `status` and it means it's an error
	      //
	      // That's the only case where we have a response.status that's not the http statusCode
	      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||
	
	      // this is important to check the request statusCode AFTER the body eventual
	      // statusCode because some implementations (jQuery XDomainRequest transport) may
	      // send statusCode 200 while we had an error
	      httpResponse.statusCode ||
	
	      // When in browser mode, using XDR or JSONP
	      // we default to success when no error (no response.status && response.message)
	      // If there was a JSON.parse() error then body is null and it fails
	      httpResponse && httpResponse.body && 200;
	
	      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j', httpResponse.statusCode, status, httpResponse.headers);
	
	      var httpResponseOk = Math.floor(status / 100) === 2;
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime,
	        statusCode: status
	      });
	
	      if (httpResponseOk) {
	        if (client._useCache && cache) {
	          cache[cacheID] = httpResponse.responseText;
	        }
	
	        return httpResponse.body;
	      }
	
	      var shouldRetry = Math.floor(status / 100) !== 4;
	
	      if (shouldRetry) {
	        tries += 1;
	        return retryRequest();
	      }
	
	      requestDebug('unrecoverable error');
	
	      // no success and no retry => fail
	      var unrecoverableError = new errors.AlgoliaSearchError(httpResponse.body && httpResponse.body.message, { debugData: debugData, statusCode: status });
	
	      return client._promise.reject(unrecoverableError);
	    }
	
	    function tryFallback(err) {
	      // error cases:
	      //  While not in fallback mode:
	      //    - CORS not supported
	      //    - network error
	      //  While in fallback mode:
	      //    - timeout
	      //    - network error
	      //    - badly formatted JSONP (script loaded, did not call our callback)
	      //  In both cases:
	      //    - uncaught exception occurs (TypeError)
	      requestDebug('error: %s, stack: %s', err.message, err.stack);
	
	      var endTime = new Date();
	      debugData.push({
	        currentHost: currentHost,
	        headers: removeCredentials(headers),
	        content: body || null,
	        contentLength: body !== undefined ? body.length : null,
	        method: reqOpts.method,
	        timeouts: reqOpts.timeouts,
	        url: reqOpts.url,
	        startTime: startTime,
	        endTime: endTime,
	        duration: endTime - startTime
	      });
	
	      if (!(err instanceof errors.AlgoliaSearchError)) {
	        err = new errors.Unknown(err && err.message, err);
	      }
	
	      tries += 1;
	
	      // stop the request implementation when:
	      if (
	      // we did not generate this error,
	      // it comes from a throw in some other piece of code
	      err instanceof errors.Unknown ||
	
	      // server sent unparsable JSON
	      err instanceof errors.UnparsableJSON ||
	
	      // max tries and already using fallback or no fallback
	      tries >= client.hosts[initialOpts.hostType].length && (usingFallback || !hasFallback)) {
	        // stop request implementation for this command
	        err.debugData = debugData;
	        return client._promise.reject(err);
	      }
	
	      // When a timeout occured, retry by raising timeout
	      if (err instanceof errors.RequestTimeout) {
	        return retryRequestWithHigherTimeout();
	      }
	
	      return retryRequest();
	    }
	
	    function retryRequest() {
	      requestDebug('retrying request');
	      client._incrementHostIndex(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	
	    function retryRequestWithHigherTimeout() {
	      requestDebug('retrying request with higher timeout');
	      client._incrementHostIndex(initialOpts.hostType);
	      client._incrementTimeoutMultipler();
	      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);
	      return doRequest(requester, reqOpts);
	    }
	  }
	
	  var promise = doRequest(client._request, {
	    url: initialOpts.url,
	    method: initialOpts.method,
	    body: body,
	    jsonBody: initialOpts.body,
	    timeouts: client._getTimeoutsForRequest(initialOpts.hostType)
	  });
	
	  // either we have a callback
	  // either we are using promises
	  if (typeof initialOpts.callback === 'function') {
	    promise.then(function okCb(content) {
	      exitPromise(function () {
	        initialOpts.callback(null, content);
	      }, client._setTimeout || setTimeout);
	    }, function nookCb(err) {
	      exitPromise(function () {
	        initialOpts.callback(err);
	      }, client._setTimeout || setTimeout);
	    });
	  } else {
	    return promise;
	  }
	};
	
	/*
	* Transform search param object in query string
	* @param {object} args arguments to add to the current query string
	* @param {string} params current query string
	* @return {string} the final query string
	*/
	AlgoliaSearchCore.prototype._getSearchParams = function (args, params) {
	  if (args === undefined || args === null) {
	    return params;
	  }
	  for (var key in args) {
	    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {
	      params += params === '' ? '' : '&';
	      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);
	    }
	  }
	  return params;
	};
	
	AlgoliaSearchCore.prototype._computeRequestHeaders = function (additionalUA, withAPIKey) {
	  var forEach = __webpack_require__(20);
	
	  var ua = additionalUA ? this._ua + ';' + additionalUA : this._ua;
	
	  var requestHeaders = {
	    'x-algolia-agent': ua,
	    'x-algolia-application-id': this.applicationID
	  };
	
	  // browser will inline headers in the url, node.js will use http headers
	  // but in some situations, the API KEY will be too long (big secured API keys)
	  // so if the request is a POST and the KEY is very long, we will be asked to not put
	  // it into headers but in the JSON body
	  if (withAPIKey !== false) {
	    requestHeaders['x-algolia-api-key'] = this.apiKey;
	  }
	
	  if (this.userToken) {
	    requestHeaders['x-algolia-usertoken'] = this.userToken;
	  }
	
	  if (this.securityTags) {
	    requestHeaders['x-algolia-tagfilters'] = this.securityTags;
	  }
	
	  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {
	    requestHeaders[key] = value;
	  });
	
	  return requestHeaders;
	};
	
	/**
	 * Search through multiple indices at the same time
	 * @param  {Object[]}   queries  An array of queries you want to run.
	 * @param {string} queries[].indexName The index name you want to target
	 * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`
	 * @param {Object} queries[].params Any search param like hitsPerPage, ..
	 * @param  {Function} callback Callback to be called
	 * @return {Promise|undefined} Returns a promise if no callback given
	 */
	AlgoliaSearchCore.prototype.search = function (queries, opts, callback) {
	  var isArray = __webpack_require__(28);
	  var map = __webpack_require__(29);
	
	  var usage = 'Usage: client.search(arrayOfQueries[, callback])';
	
	  if (!isArray(queries)) {
	    throw new Error(usage);
	  }
	
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (opts === undefined) {
	    opts = {};
	  }
	
	  var client = this;
	
	  var postObj = {
	    requests: map(queries, function prepareRequest(query) {
	      var params = '';
	
	      // allow query.query
	      // so we are mimicing the index.search(query, params) method
	      // {indexName:, query:, params:}
	      if (query.query !== undefined) {
	        params += 'query=' + encodeURIComponent(query.query);
	      }
	
	      return {
	        indexName: query.indexName,
	        params: client._getSearchParams(query.params, params)
	      };
	    })
	  };
	
	  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {
	    return requestId + '=' + encodeURIComponent('/1/indexes/' + encodeURIComponent(request.indexName) + '?' + request.params);
	  }).join('&');
	
	  var url = '/1/indexes/*/queries';
	
	  if (opts.strategy !== undefined) {
	    url += '?strategy=' + opts.strategy;
	  }
	
	  return this._jsonRequest({
	    cache: this.cache,
	    method: 'POST',
	    url: url,
	    body: postObj,
	    hostType: 'read',
	    fallback: {
	      method: 'GET',
	      url: '/1/indexes/*',
	      body: {
	        params: JSONPParams
	      }
	    },
	    callback: callback
	  });
	};
	
	/**
	 * Set the extra security tagFilters header
	 * @param {string|array} tags The list of tags defining the current security filters
	 */
	AlgoliaSearchCore.prototype.setSecurityTags = function (tags) {
	  if (Object.prototype.toString.call(tags) === '[object Array]') {
	    var strTags = [];
	    for (var i = 0; i < tags.length; ++i) {
	      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {
	        var oredTags = [];
	        for (var j = 0; j < tags[i].length; ++j) {
	          oredTags.push(tags[i][j]);
	        }
	        strTags.push('(' + oredTags.join(',') + ')');
	      } else {
	        strTags.push(tags[i]);
	      }
	    }
	    tags = strTags.join(',');
	  }
	
	  this.securityTags = tags;
	};
	
	/**
	 * Set the extra user token header
	 * @param {string} userToken The token identifying a uniq user (used to apply rate limits)
	 */
	AlgoliaSearchCore.prototype.setUserToken = function (userToken) {
	  this.userToken = userToken;
	};
	
	/**
	 * Clear all queries in client's cache
	 * @return undefined
	 */
	AlgoliaSearchCore.prototype.clearCache = function () {
	  this.cache = {};
	};
	
	/**
	* Set the number of milliseconds a request can take before automatically being terminated.
	* @deprecated
	* @param {Number} milliseconds
	*/
	AlgoliaSearchCore.prototype.setRequestTimeout = function (milliseconds) {
	  if (milliseconds) {
	    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;
	  }
	};
	
	/**
	* Set the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.setTimeouts = function (timeouts) {
	  this._timeouts = timeouts;
	};
	
	/**
	* Get the three different (connect, read, write) timeouts to be used when requesting
	* @param {Object} timeouts
	*/
	AlgoliaSearchCore.prototype.getTimeouts = function () {
	  return this._timeouts;
	};
	
	AlgoliaSearchCore.prototype._getAppIdData = function () {
	  var data = store.get(this.applicationID);
	  if (data !== null) this._cacheAppIdData(data);
	  return data;
	};
	
	AlgoliaSearchCore.prototype._setAppIdData = function (data) {
	  data.lastChange = new Date().getTime();
	  this._cacheAppIdData(data);
	  return store.set(this.applicationID, data);
	};
	
	AlgoliaSearchCore.prototype._checkAppIdData = function () {
	  var data = this._getAppIdData();
	  var now = new Date().getTime();
	  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {
	    return this._resetInitialAppIdData(data);
	  }
	
	  return data;
	};
	
	AlgoliaSearchCore.prototype._resetInitialAppIdData = function (data) {
	  var newData = data || {};
	  newData.hostIndexes = { read: 0, write: 0 };
	  newData.timeoutMultiplier = 1;
	  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);
	  return this._setAppIdData(newData);
	};
	
	AlgoliaSearchCore.prototype._cacheAppIdData = function (data) {
	  this._hostIndexes = data.hostIndexes;
	  this._timeoutMultiplier = data.timeoutMultiplier;
	  this._shuffleResult = data.shuffleResult;
	};
	
	AlgoliaSearchCore.prototype._partialAppIdDataUpdate = function (newData) {
	  var foreach = __webpack_require__(20);
	  var currentData = this._getAppIdData();
	  foreach(newData, function (value, key) {
	    currentData[key] = value;
	  });
	
	  return this._setAppIdData(currentData);
	};
	
	AlgoliaSearchCore.prototype._getHostByType = function (hostType) {
	  return this.hosts[hostType][this._getHostIndexByType(hostType)];
	};
	
	AlgoliaSearchCore.prototype._getTimeoutMultiplier = function () {
	  return this._timeoutMultiplier;
	};
	
	AlgoliaSearchCore.prototype._getHostIndexByType = function (hostType) {
	  return this._hostIndexes[hostType];
	};
	
	AlgoliaSearchCore.prototype._setHostIndexByType = function (hostIndex, hostType) {
	  var clone = __webpack_require__(24);
	  var newHostIndexes = clone(this._hostIndexes);
	  newHostIndexes[hostType] = hostIndex;
	  this._partialAppIdDataUpdate({ hostIndexes: newHostIndexes });
	  return hostIndex;
	};
	
	AlgoliaSearchCore.prototype._incrementHostIndex = function (hostType) {
	  return this._setHostIndexByType((this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType);
	};
	
	AlgoliaSearchCore.prototype._incrementTimeoutMultipler = function () {
	  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);
	  return this._partialAppIdDataUpdate({ timeoutMultiplier: timeoutMultiplier });
	};
	
	AlgoliaSearchCore.prototype._getTimeoutsForRequest = function (hostType) {
	  return {
	    connect: this._timeouts.connect * this._timeoutMultiplier,
	    complete: this._timeouts[hostType] * this._timeoutMultiplier
	  };
	};
	
	function prepareHost(protocol) {
	  return function prepare(host) {
	    return protocol + '//' + host.toLowerCase();
	  };
	}
	
	// Prototype.js < 1.7, a widely used library, defines a weird
	// Array.prototype.toJSON function that will fail to stringify our content
	// appropriately
	// refs:
	//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q
	//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c
	//   - http://stackoverflow.com/a/3148441/147079
	function safeJSONStringify(obj) {
	  /* eslint no-extend-native:0 */
	
	  if (Array.prototype.toJSON === undefined) {
	    return JSON.stringify(obj);
	  }
	
	  var toJSON = Array.prototype.toJSON;
	  delete Array.prototype.toJSON;
	  var out = JSON.stringify(obj);
	  Array.prototype.toJSON = toJSON;
	
	  return out;
	}
	
	function shuffle(array) {
	  var currentIndex = array.length;
	  var temporaryValue;
	  var randomIndex;
	
	  // While there remain elements to shuffle...
	  while (currentIndex !== 0) {
	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex -= 1;
	
	    // And swap it with the current element.
	    temporaryValue = array[currentIndex];
	    array[currentIndex] = array[randomIndex];
	    array[randomIndex] = temporaryValue;
	  }
	
	  return array;
	}
	
	function removeCredentials(headers) {
	  var newHeaders = {};
	
	  for (var headerName in headers) {
	    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {
	      var value;
	
	      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {
	        value = '**hidden for security purposes**';
	      } else {
	        value = headers[headerName];
	      }
	
	      newHeaders[headerName] = value;
	    }
	  }
	
	  return newHeaders;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var debug = __webpack_require__(35)('algoliasearch:src/hostIndexState.js');
	var localStorageNamespace = 'algoliasearch-client-js';
	
	var store;
	var moduleStore = {
	  state: {},
	  set: function set(key, data) {
	    this.state[key] = data;
	    return this.state[key];
	  },
	  get: function get(key) {
	    return this.state[key] || null;
	  }
	};
	
	var localStorageStore = {
	  set: function set(key, data) {
	    moduleStore.set(key, data); // always replicate localStorageStore to moduleStore in case of failure
	
	    try {
	      var namespace = JSON.parse(global.localStorage[localStorageNamespace]);
	      namespace[key] = data;
	      global.localStorage[localStorageNamespace] = JSON.stringify(namespace);
	      return namespace[key];
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  },
	  get: function get(key) {
	    try {
	      return JSON.parse(global.localStorage[localStorageNamespace])[key] || null;
	    } catch (e) {
	      return localStorageFailure(key, e);
	    }
	  }
	};
	
	function localStorageFailure(key, e) {
	  debug('localStorage failed with', e);
	  cleanup();
	  store = moduleStore;
	  return store.get(key);
	}
	
	store = supportsLocalStorage() ? localStorageStore : moduleStore;
	
	module.exports = {
	  get: getOrSet,
	  set: getOrSet,
	  supportsLocalStorage: supportsLocalStorage
	};
	
	function getOrSet(key, data) {
	  if (arguments.length === 1) {
	    return store.get(key);
	  }
	
	  return store.set(key, data);
	}
	
	function supportsLocalStorage() {
	  try {
	    if ('localStorage' in global && global.localStorage !== null) {
	      if (!global.localStorage[localStorageNamespace]) {
	        // actual creation of the namespace
	        global.localStorage.setItem(localStorageNamespace, JSON.stringify({}));
	      }
	      return true;
	    }
	
	    return false;
	  } catch (_) {
	    return false;
	  }
	}
	
	// In case of any error on localStorage, we clean our own namespace, this should handle
	// quota errors when a lot of keys + data are used
	function cleanup() {
	  try {
	    global.localStorage.removeItem(localStorageNamespace);
	  } catch (_) {
	    // nothing to do
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(36);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
	  // double check webkit in userAgent just in case we are in a worker
	  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(37);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0,
	      i;
	
	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var global = __webpack_require__(39);
	var Promise = global.Promise || __webpack_require__(40).Promise;
	
	// This is the standalone browser build entry point
	// Browser implementation of the Algolia Search JavaScript client,
	// using XMLHttpRequest, XDomainRequest and JSONP as fallback
	module.exports = function createAlgoliasearch(AlgoliaSearch, uaSuffix) {
	  var inherits = __webpack_require__(16);
	  var errors = __webpack_require__(19);
	  var inlineHeaders = __webpack_require__(42);
	  var jsonpRequest = __webpack_require__(44);
	  var places = __webpack_require__(45);
	  uaSuffix = uaSuffix || '';
	
	  if (process.env.NODE_ENV === 'debug') {
	    __webpack_require__(35).enable('algoliasearch*');
	  }
	
	  function algoliasearch(applicationID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    var getDocumentProtocol = __webpack_require__(46);
	
	    opts = cloneDeep(opts || {});
	
	    if (opts.protocol === undefined) {
	      opts.protocol = getDocumentProtocol();
	    }
	
	    opts._ua = opts._ua || algoliasearch.ua;
	
	    return new AlgoliaSearchBrowser(applicationID, apiKey, opts);
	  }
	
	  algoliasearch.version = __webpack_require__(47);
	  algoliasearch.ua = 'Algolia for vanilla JavaScript ' + uaSuffix + algoliasearch.version;
	  algoliasearch.initPlaces = places(algoliasearch);
	
	  // we expose into window no matter how we are used, this will allow
	  // us to easily debug any website running algolia
	  global.__algolia = {
	    debug: __webpack_require__(35),
	    algoliasearch: algoliasearch
	  };
	
	  var support = {
	    hasXMLHttpRequest: 'XMLHttpRequest' in global,
	    hasXDomainRequest: 'XDomainRequest' in global
	  };
	
	  if (support.hasXMLHttpRequest) {
	    support.cors = 'withCredentials' in new XMLHttpRequest();
	  }
	
	  function AlgoliaSearchBrowser() {
	    // call AlgoliaSearch constructor
	    AlgoliaSearch.apply(this, arguments);
	  }
	
	  inherits(AlgoliaSearchBrowser, AlgoliaSearch);
	
	  AlgoliaSearchBrowser.prototype._request = function request(url, opts) {
	    return new Promise(function wrapRequest(resolve, reject) {
	      // no cors or XDomainRequest, no request
	      if (!support.cors && !support.hasXDomainRequest) {
	        // very old browser, not supported
	        reject(new errors.Network('CORS not supported'));
	        return;
	      }
	
	      url = inlineHeaders(url, opts.headers);
	
	      var body = opts.body;
	      var req = support.cors ? new XMLHttpRequest() : new XDomainRequest();
	      var reqTimeout;
	      var timedOut;
	      var connected = false;
	
	      reqTimeout = setTimeout(onTimeout, opts.timeouts.connect);
	      // we set an empty onprogress listener
	      // so that XDomainRequest on IE9 is not aborted
	      // refs:
	      //  - https://github.com/algolia/algoliasearch-client-js/issues/76
	      //  - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
	      req.onprogress = onProgress;
	      if ('onreadystatechange' in req) req.onreadystatechange = onReadyStateChange;
	      req.onload = onLoad;
	      req.onerror = onError;
	
	      // do not rely on default XHR async flag, as some analytics code like hotjar
	      // breaks it and set it to false by default
	      if (req instanceof XMLHttpRequest) {
	        req.open(opts.method, url, true);
	      } else {
	        req.open(opts.method, url);
	      }
	
	      // headers are meant to be sent after open
	      if (support.cors) {
	        if (body) {
	          if (opts.method === 'POST') {
	            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests
	            req.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
	          } else {
	            req.setRequestHeader('content-type', 'application/json');
	          }
	        }
	        req.setRequestHeader('accept', 'application/json');
	      }
	
	      req.send(body);
	
	      // event object not received in IE8, at least
	      // but we do not use it, still important to note
	      function onLoad() /* event */{
	        // When browser does not supports req.timeout, we can
	        // have both a load and timeout event, since handled by a dumb setTimeout
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        var out;
	
	        try {
	          out = {
	            body: JSON.parse(req.responseText),
	            responseText: req.responseText,
	            statusCode: req.status,
	            // XDomainRequest does not have any response headers
	            headers: req.getAllResponseHeaders && req.getAllResponseHeaders() || {}
	          };
	        } catch (e) {
	          out = new errors.UnparsableJSON({
	            more: req.responseText
	          });
	        }
	
	        if (out instanceof errors.UnparsableJSON) {
	          reject(out);
	        } else {
	          resolve(out);
	        }
	      }
	
	      function onError(event) {
	        if (timedOut) {
	          return;
	        }
	
	        clearTimeout(reqTimeout);
	
	        // error event is trigerred both with XDR/XHR on:
	        //   - DNS error
	        //   - unallowed cross domain request
	        reject(new errors.Network({
	          more: event
	        }));
	      }
	
	      function onTimeout() {
	        timedOut = true;
	        req.abort();
	
	        reject(new errors.RequestTimeout());
	      }
	
	      function onConnect() {
	        connected = true;
	        clearTimeout(reqTimeout);
	        reqTimeout = setTimeout(onTimeout, opts.timeouts.complete);
	      }
	
	      function onProgress() {
	        if (!connected) onConnect();
	      }
	
	      function onReadyStateChange() {
	        if (!connected && req.readyState > 1) onConnect();
	      }
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._request.fallback = function requestFallback(url, opts) {
	    url = inlineHeaders(url, opts.headers);
	
	    return new Promise(function wrapJsonpRequest(resolve, reject) {
	      jsonpRequest(url, opts, function jsonpRequestDone(err, content) {
	        if (err) {
	          reject(err);
	          return;
	        }
	
	        resolve(content);
	      });
	    });
	  };
	
	  AlgoliaSearchBrowser.prototype._promise = {
	    reject: function rejectPromise(val) {
	      return Promise.reject(val);
	    },
	    resolve: function resolvePromise(val) {
	      return Promise.resolve(val);
	    },
	    delay: function delayPromise(ms) {
	      return new Promise(function resolveOnTimeout(resolve /* , reject*/) {
	        setTimeout(resolve, ms);
	      });
	    }
	  };
	
	  return algoliasearch;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var win;
	
	if (typeof window !== "undefined") {
	    win = window;
	} else if (typeof global !== "undefined") {
	    win = global;
	} else if (typeof self !== "undefined") {
	    win = self;
	} else {
	    win = {};
	}
	
	module.exports = win;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.1.1
	 */
	
	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.ES6Promise = factory();
	})(undefined, function () {
	  'use strict';
	
	  function objectOrFunction(x) {
	    var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);
	    return x !== null && (type === 'object' || type === 'function');
	  }
	
	  function isFunction(x) {
	    return typeof x === 'function';
	  }
	
	  var _isArray = undefined;
	  if (Array.isArray) {
	    _isArray = Array.isArray;
	  } else {
	    _isArray = function _isArray(x) {
	      return Object.prototype.toString.call(x) === '[object Array]';
	    };
	  }
	
	  var isArray = _isArray;
	
	  var len = 0;
	  var vertxNext = undefined;
	  var customSchedulerFn = undefined;
	
	  var asap = function asap(callback, arg) {
	    queue[len] = callback;
	    queue[len + 1] = arg;
	    len += 2;
	    if (len === 2) {
	      // If len is 2, that means that we need to schedule an async flush.
	      // If additional callbacks are queued before the queue is flushed, they
	      // will be processed by this flush that we are scheduling.
	      if (customSchedulerFn) {
	        customSchedulerFn(flush);
	      } else {
	        scheduleFlush();
	      }
	    }
	  };
	
	  function setScheduler(scheduleFn) {
	    customSchedulerFn = scheduleFn;
	  }
	
	  function setAsap(asapFn) {
	    asap = asapFn;
	  }
	
	  var browserWindow = typeof window !== 'undefined' ? window : undefined;
	  var browserGlobal = browserWindow || {};
	  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	  // test for web worker but not in IE10
	  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	  // node
	  function useNextTick() {
	    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	    // see https://github.com/cujojs/when/issues/410 for details
	    return function () {
	      return process.nextTick(flush);
	    };
	  }
	
	  // vertx
	  function useVertxTimer() {
	    if (typeof vertxNext !== 'undefined') {
	      return function () {
	        vertxNext(flush);
	      };
	    }
	
	    return useSetTimeout();
	  }
	
	  function useMutationObserver() {
	    var iterations = 0;
	    var observer = new BrowserMutationObserver(flush);
	    var node = document.createTextNode('');
	    observer.observe(node, { characterData: true });
	
	    return function () {
	      node.data = iterations = ++iterations % 2;
	    };
	  }
	
	  // web worker
	  function useMessageChannel() {
	    var channel = new MessageChannel();
	    channel.port1.onmessage = flush;
	    return function () {
	      return channel.port2.postMessage(0);
	    };
	  }
	
	  function useSetTimeout() {
	    // Store setTimeout reference so es6-promise will be unaffected by
	    // other code modifying setTimeout (like sinon.useFakeTimers())
	    var globalSetTimeout = setTimeout;
	    return function () {
	      return globalSetTimeout(flush, 1);
	    };
	  }
	
	  var queue = new Array(1000);
	  function flush() {
	    for (var i = 0; i < len; i += 2) {
	      var callback = queue[i];
	      var arg = queue[i + 1];
	
	      callback(arg);
	
	      queue[i] = undefined;
	      queue[i + 1] = undefined;
	    }
	
	    len = 0;
	  }
	
	  function attemptVertx() {
	    try {
	      var r = require;
	      var vertx = __webpack_require__(41);
	      vertxNext = vertx.runOnLoop || vertx.runOnContext;
	      return useVertxTimer();
	    } catch (e) {
	      return useSetTimeout();
	    }
	  }
	
	  var scheduleFlush = undefined;
	  // Decide what async method to use to triggering processing of queued callbacks:
	  if (isNode) {
	    scheduleFlush = useNextTick();
	  } else if (BrowserMutationObserver) {
	    scheduleFlush = useMutationObserver();
	  } else if (isWorker) {
	    scheduleFlush = useMessageChannel();
	  } else if (browserWindow === undefined && "function" === 'function') {
	    scheduleFlush = attemptVertx();
	  } else {
	    scheduleFlush = useSetTimeout();
	  }
	
	  function then(onFulfillment, onRejection) {
	    var _arguments = arguments;
	
	    var parent = this;
	
	    var child = new this.constructor(noop);
	
	    if (child[PROMISE_ID] === undefined) {
	      makePromise(child);
	    }
	
	    var _state = parent._state;
	
	    if (_state) {
	      (function () {
	        var callback = _arguments[_state - 1];
	        asap(function () {
	          return invokeCallback(_state, child, callback, parent._result);
	        });
	      })();
	    } else {
	      subscribe(parent, child, onFulfillment, onRejection);
	    }
	
	    return child;
	  }
	
	  /**
	    `Promise.resolve` returns a promise that will become resolved with the
	    passed `value`. It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      resolve(1);
	    });
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.resolve(1);
	  
	    promise.then(function(value){
	      // value === 1
	    });
	    ```
	  
	    @method resolve
	    @static
	    @param {Any} value value that the returned promise will be resolved with
	    Useful for tooling.
	    @return {Promise} a promise that will become fulfilled with the given
	    `value`
	  */
	  function resolve$1(object) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
	      return object;
	    }
	
	    var promise = new Constructor(noop);
	    resolve(promise, object);
	    return promise;
	  }
	
	  var PROMISE_ID = Math.random().toString(36).substring(16);
	
	  function noop() {}
	
	  var PENDING = void 0;
	  var FULFILLED = 1;
	  var REJECTED = 2;
	
	  var GET_THEN_ERROR = new ErrorObject();
	
	  function selfFulfillment() {
	    return new TypeError("You cannot resolve a promise with itself");
	  }
	
	  function cannotReturnOwn() {
	    return new TypeError('A promises callback cannot return that same promise.');
	  }
	
	  function getThen(promise) {
	    try {
	      return promise.then;
	    } catch (error) {
	      GET_THEN_ERROR.error = error;
	      return GET_THEN_ERROR;
	    }
	  }
	
	  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
	    try {
	      then$$1.call(value, fulfillmentHandler, rejectionHandler);
	    } catch (e) {
	      return e;
	    }
	  }
	
	  function handleForeignThenable(promise, thenable, then$$1) {
	    asap(function (promise) {
	      var sealed = false;
	      var error = tryThen(then$$1, thenable, function (value) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	        if (thenable !== value) {
	          resolve(promise, value);
	        } else {
	          fulfill(promise, value);
	        }
	      }, function (reason) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	
	        reject(promise, reason);
	      }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	      if (!sealed && error) {
	        sealed = true;
	        reject(promise, error);
	      }
	    }, promise);
	  }
	
	  function handleOwnThenable(promise, thenable) {
	    if (thenable._state === FULFILLED) {
	      fulfill(promise, thenable._result);
	    } else if (thenable._state === REJECTED) {
	      reject(promise, thenable._result);
	    } else {
	      subscribe(thenable, undefined, function (value) {
	        return resolve(promise, value);
	      }, function (reason) {
	        return reject(promise, reason);
	      });
	    }
	  }
	
	  function handleMaybeThenable(promise, maybeThenable, then$$1) {
	    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
	      handleOwnThenable(promise, maybeThenable);
	    } else {
	      if (then$$1 === GET_THEN_ERROR) {
	        reject(promise, GET_THEN_ERROR.error);
	        GET_THEN_ERROR.error = null;
	      } else if (then$$1 === undefined) {
	        fulfill(promise, maybeThenable);
	      } else if (isFunction(then$$1)) {
	        handleForeignThenable(promise, maybeThenable, then$$1);
	      } else {
	        fulfill(promise, maybeThenable);
	      }
	    }
	  }
	
	  function resolve(promise, value) {
	    if (promise === value) {
	      reject(promise, selfFulfillment());
	    } else if (objectOrFunction(value)) {
	      handleMaybeThenable(promise, value, getThen(value));
	    } else {
	      fulfill(promise, value);
	    }
	  }
	
	  function publishRejection(promise) {
	    if (promise._onerror) {
	      promise._onerror(promise._result);
	    }
	
	    publish(promise);
	  }
	
	  function fulfill(promise, value) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	
	    promise._result = value;
	    promise._state = FULFILLED;
	
	    if (promise._subscribers.length !== 0) {
	      asap(publish, promise);
	    }
	  }
	
	  function reject(promise, reason) {
	    if (promise._state !== PENDING) {
	      return;
	    }
	    promise._state = REJECTED;
	    promise._result = reason;
	
	    asap(publishRejection, promise);
	  }
	
	  function subscribe(parent, child, onFulfillment, onRejection) {
	    var _subscribers = parent._subscribers;
	    var length = _subscribers.length;
	
	    parent._onerror = null;
	
	    _subscribers[length] = child;
	    _subscribers[length + FULFILLED] = onFulfillment;
	    _subscribers[length + REJECTED] = onRejection;
	
	    if (length === 0 && parent._state) {
	      asap(publish, parent);
	    }
	  }
	
	  function publish(promise) {
	    var subscribers = promise._subscribers;
	    var settled = promise._state;
	
	    if (subscribers.length === 0) {
	      return;
	    }
	
	    var child = undefined,
	        callback = undefined,
	        detail = promise._result;
	
	    for (var i = 0; i < subscribers.length; i += 3) {
	      child = subscribers[i];
	      callback = subscribers[i + settled];
	
	      if (child) {
	        invokeCallback(settled, child, callback, detail);
	      } else {
	        callback(detail);
	      }
	    }
	
	    promise._subscribers.length = 0;
	  }
	
	  function ErrorObject() {
	    this.error = null;
	  }
	
	  var TRY_CATCH_ERROR = new ErrorObject();
	
	  function tryCatch(callback, detail) {
	    try {
	      return callback(detail);
	    } catch (e) {
	      TRY_CATCH_ERROR.error = e;
	      return TRY_CATCH_ERROR;
	    }
	  }
	
	  function invokeCallback(settled, promise, callback, detail) {
	    var hasCallback = isFunction(callback),
	        value = undefined,
	        error = undefined,
	        succeeded = undefined,
	        failed = undefined;
	
	    if (hasCallback) {
	      value = tryCatch(callback, detail);
	
	      if (value === TRY_CATCH_ERROR) {
	        failed = true;
	        error = value.error;
	        value.error = null;
	      } else {
	        succeeded = true;
	      }
	
	      if (promise === value) {
	        reject(promise, cannotReturnOwn());
	        return;
	      }
	    } else {
	      value = detail;
	      succeeded = true;
	    }
	
	    if (promise._state !== PENDING) {
	      // noop
	    } else if (hasCallback && succeeded) {
	      resolve(promise, value);
	    } else if (failed) {
	      reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      reject(promise, value);
	    }
	  }
	
	  function initializePromise(promise, resolver) {
	    try {
	      resolver(function resolvePromise(value) {
	        resolve(promise, value);
	      }, function rejectPromise(reason) {
	        reject(promise, reason);
	      });
	    } catch (e) {
	      reject(promise, e);
	    }
	  }
	
	  var id = 0;
	  function nextId() {
	    return id++;
	  }
	
	  function makePromise(promise) {
	    promise[PROMISE_ID] = id++;
	    promise._state = undefined;
	    promise._result = undefined;
	    promise._subscribers = [];
	  }
	
	  function Enumerator$1(Constructor, input) {
	    this._instanceConstructor = Constructor;
	    this.promise = new Constructor(noop);
	
	    if (!this.promise[PROMISE_ID]) {
	      makePromise(this.promise);
	    }
	
	    if (isArray(input)) {
	      this.length = input.length;
	      this._remaining = input.length;
	
	      this._result = new Array(this.length);
	
	      if (this.length === 0) {
	        fulfill(this.promise, this._result);
	      } else {
	        this.length = this.length || 0;
	        this._enumerate(input);
	        if (this._remaining === 0) {
	          fulfill(this.promise, this._result);
	        }
	      }
	    } else {
	      reject(this.promise, validationError());
	    }
	  }
	
	  function validationError() {
	    return new Error('Array Methods must be provided an Array');
	  }
	
	  Enumerator$1.prototype._enumerate = function (input) {
	    for (var i = 0; this._state === PENDING && i < input.length; i++) {
	      this._eachEntry(input[i], i);
	    }
	  };
	
	  Enumerator$1.prototype._eachEntry = function (entry, i) {
	    var c = this._instanceConstructor;
	    var resolve$$1 = c.resolve;
	
	    if (resolve$$1 === resolve$1) {
	      var _then = getThen(entry);
	
	      if (_then === then && entry._state !== PENDING) {
	        this._settledAt(entry._state, i, entry._result);
	      } else if (typeof _then !== 'function') {
	        this._remaining--;
	        this._result[i] = entry;
	      } else if (c === Promise$2) {
	        var promise = new c(noop);
	        handleMaybeThenable(promise, entry, _then);
	        this._willSettleAt(promise, i);
	      } else {
	        this._willSettleAt(new c(function (resolve$$1) {
	          return resolve$$1(entry);
	        }), i);
	      }
	    } else {
	      this._willSettleAt(resolve$$1(entry), i);
	    }
	  };
	
	  Enumerator$1.prototype._settledAt = function (state, i, value) {
	    var promise = this.promise;
	
	    if (promise._state === PENDING) {
	      this._remaining--;
	
	      if (state === REJECTED) {
	        reject(promise, value);
	      } else {
	        this._result[i] = value;
	      }
	    }
	
	    if (this._remaining === 0) {
	      fulfill(promise, this._result);
	    }
	  };
	
	  Enumerator$1.prototype._willSettleAt = function (promise, i) {
	    var enumerator = this;
	
	    subscribe(promise, undefined, function (value) {
	      return enumerator._settledAt(FULFILLED, i, value);
	    }, function (reason) {
	      return enumerator._settledAt(REJECTED, i, reason);
	    });
	  };
	
	  /**
	    `Promise.all` accepts an array of promises, and returns a new promise which
	    is fulfilled with an array of fulfillment values for the passed promises, or
	    rejected with the reason of the first passed promise to be rejected. It casts all
	    elements of the passed iterable to promises as it runs this algorithm.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = resolve(2);
	    let promise3 = resolve(3);
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // The array here would be [ 1, 2, 3 ];
	    });
	    ```
	  
	    If any of the `promises` given to `all` are rejected, the first promise
	    that is rejected will be given as an argument to the returned promises's
	    rejection handler. For example:
	  
	    Example:
	  
	    ```javascript
	    let promise1 = resolve(1);
	    let promise2 = reject(new Error("2"));
	    let promise3 = reject(new Error("3"));
	    let promises = [ promise1, promise2, promise3 ];
	  
	    Promise.all(promises).then(function(array){
	      // Code here never runs because there are rejected promises!
	    }, function(error) {
	      // error.message === "2"
	    });
	    ```
	  
	    @method all
	    @static
	    @param {Array} entries array of promises
	    @param {String} label optional string for labeling the promise.
	    Useful for tooling.
	    @return {Promise} promise that is fulfilled when all `promises` have been
	    fulfilled, or rejected if any of them become rejected.
	    @static
	  */
	  function all$1(entries) {
	    return new Enumerator$1(this, entries).promise;
	  }
	
	  /**
	    `Promise.race` returns a new promise which is settled in the same way as the
	    first passed promise to settle.
	  
	    Example:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 2');
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // result === 'promise 2' because it was resolved before promise1
	      // was resolved.
	    });
	    ```
	  
	    `Promise.race` is deterministic in that only the state of the first
	    settled promise matters. For example, even if other promises given to the
	    `promises` array argument are resolved, but the first settled promise has
	    become rejected before the other promises became fulfilled, the returned
	    promise will become rejected:
	  
	    ```javascript
	    let promise1 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        resolve('promise 1');
	      }, 200);
	    });
	  
	    let promise2 = new Promise(function(resolve, reject){
	      setTimeout(function(){
	        reject(new Error('promise 2'));
	      }, 100);
	    });
	  
	    Promise.race([promise1, promise2]).then(function(result){
	      // Code here never runs
	    }, function(reason){
	      // reason.message === 'promise 2' because promise 2 became rejected before
	      // promise 1 became fulfilled
	    });
	    ```
	  
	    An example real-world use case is implementing timeouts:
	  
	    ```javascript
	    Promise.race([ajax('foo.json'), timeout(5000)])
	    ```
	  
	    @method race
	    @static
	    @param {Array} promises array of promises to observe
	    Useful for tooling.
	    @return {Promise} a promise which settles in the same way as the first passed
	    promise to settle.
	  */
	  function race$1(entries) {
	    /*jshint validthis:true */
	    var Constructor = this;
	
	    if (!isArray(entries)) {
	      return new Constructor(function (_, reject) {
	        return reject(new TypeError('You must pass an array to race.'));
	      });
	    } else {
	      return new Constructor(function (resolve, reject) {
	        var length = entries.length;
	        for (var i = 0; i < length; i++) {
	          Constructor.resolve(entries[i]).then(resolve, reject);
	        }
	      });
	    }
	  }
	
	  /**
	    `Promise.reject` returns a promise rejected with the passed `reason`.
	    It is shorthand for the following:
	  
	    ```javascript
	    let promise = new Promise(function(resolve, reject){
	      reject(new Error('WHOOPS'));
	    });
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    Instead of writing the above, your code now simply becomes the following:
	  
	    ```javascript
	    let promise = Promise.reject(new Error('WHOOPS'));
	  
	    promise.then(function(value){
	      // Code here doesn't run because the promise is rejected!
	    }, function(reason){
	      // reason.message === 'WHOOPS'
	    });
	    ```
	  
	    @method reject
	    @static
	    @param {Any} reason value that the returned promise will be rejected with.
	    Useful for tooling.
	    @return {Promise} a promise rejected with the given `reason`.
	  */
	  function reject$1(reason) {
	    /*jshint validthis:true */
	    var Constructor = this;
	    var promise = new Constructor(noop);
	    reject(promise, reason);
	    return promise;
	  }
	
	  function needsResolver() {
	    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	  }
	
	  function needsNew() {
	    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	  }
	
	  /**
	    Promise objects represent the eventual result of an asynchronous operation. The
	    primary way of interacting with a promise is through its `then` method, which
	    registers callbacks to receive either a promise's eventual value or the reason
	    why the promise cannot be fulfilled.
	  
	    Terminology
	    -----------
	  
	    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	    - `thenable` is an object or function that defines a `then` method.
	    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	    - `exception` is a value that is thrown using the throw statement.
	    - `reason` is a value that indicates why a promise was rejected.
	    - `settled` the final resting state of a promise, fulfilled or rejected.
	  
	    A promise can be in one of three states: pending, fulfilled, or rejected.
	  
	    Promises that are fulfilled have a fulfillment value and are in the fulfilled
	    state.  Promises that are rejected have a rejection reason and are in the
	    rejected state.  A fulfillment value is never a thenable.
	  
	    Promises can also be said to *resolve* a value.  If this value is also a
	    promise, then the original promise's settled state will match the value's
	    settled state.  So a promise that *resolves* a promise that rejects will
	    itself reject, and a promise that *resolves* a promise that fulfills will
	    itself fulfill.
	  
	  
	    Basic Usage:
	    ------------
	  
	    ```js
	    let promise = new Promise(function(resolve, reject) {
	      // on success
	      resolve(value);
	  
	      // on failure
	      reject(reason);
	    });
	  
	    promise.then(function(value) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Advanced Usage:
	    ---------------
	  
	    Promises shine when abstracting away asynchronous interactions such as
	    `XMLHttpRequest`s.
	  
	    ```js
	    function getJSON(url) {
	      return new Promise(function(resolve, reject){
	        let xhr = new XMLHttpRequest();
	  
	        xhr.open('GET', url);
	        xhr.onreadystatechange = handler;
	        xhr.responseType = 'json';
	        xhr.setRequestHeader('Accept', 'application/json');
	        xhr.send();
	  
	        function handler() {
	          if (this.readyState === this.DONE) {
	            if (this.status === 200) {
	              resolve(this.response);
	            } else {
	              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	            }
	          }
	        };
	      });
	    }
	  
	    getJSON('/posts.json').then(function(json) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	  
	    Unlike callbacks, promises are great composable primitives.
	  
	    ```js
	    Promise.all([
	      getJSON('/posts'),
	      getJSON('/comments')
	    ]).then(function(values){
	      values[0] // => postsJSON
	      values[1] // => commentsJSON
	  
	      return values;
	    });
	    ```
	  
	    @class Promise
	    @param {function} resolver
	    Useful for tooling.
	    @constructor
	  */
	  function Promise$2(resolver) {
	    this[PROMISE_ID] = nextId();
	    this._result = this._state = undefined;
	    this._subscribers = [];
	
	    if (noop !== resolver) {
	      typeof resolver !== 'function' && needsResolver();
	      this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
	    }
	  }
	
	  Promise$2.all = all$1;
	  Promise$2.race = race$1;
	  Promise$2.resolve = resolve$1;
	  Promise$2.reject = reject$1;
	  Promise$2._setScheduler = setScheduler;
	  Promise$2._setAsap = setAsap;
	  Promise$2._asap = asap;
	
	  Promise$2.prototype = {
	    constructor: Promise$2,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	    
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	    
	      Chaining
	      --------
	    
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	    
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	    
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	    
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	    
	      Assimilation
	      ------------
	    
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	    
	      If the assimliated promise rejects, then the downstream promise will also reject.
	    
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	    
	      Simple Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let result;
	    
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	    
	      Advanced Example
	      --------------
	    
	      Synchronous Example
	    
	      ```javascript
	      let author, books;
	    
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	    
	      Errback Example
	    
	      ```js
	    
	      function foundBooks(books) {
	    
	      }
	    
	      function failure(reason) {
	    
	      }
	    
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	    
	      Promise Example;
	    
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	    then: then,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	    
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	    
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	    
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	    
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	    'catch': function _catch(onRejection) {
	      return this.then(null, onRejection);
	    }
	  };
	
	  /*global self*/
	  function polyfill$1() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	      local = global;
	    } else if (typeof self !== 'undefined') {
	      local = self;
	    } else {
	      try {
	        local = Function('return this')();
	      } catch (e) {
	        throw new Error('polyfill failed because global object is unavailable in this environment');
	      }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	      var promiseToString = null;
	      try {
	        promiseToString = Object.prototype.toString.call(P.resolve());
	      } catch (e) {
	        // silently ignored
	      }
	
	      if (promiseToString === '[object Promise]' && !P.cast) {
	        return;
	      }
	    }
	
	    local.Promise = Promise$2;
	  }
	
	  // Strange compat..
	  Promise$2.polyfill = polyfill$1;
	  Promise$2.Promise = Promise$2;
	
	  return Promise$2;
	});
	
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = inlineHeaders;
	
	var encode = __webpack_require__(43);
	
	function inlineHeaders(url, headers) {
	  if (/\?/.test(url)) {
	    url += '&';
	  } else {
	    url += '?';
	  }
	
	  return url + encode(headers);
	}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return map(objectKeys(obj), function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (isArray(obj[k])) {
	        return map(obj[k], function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};
	
	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	function map(xs, f) {
	  if (xs.map) return xs.map(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    res.push(f(xs[i], i));
	  }
	  return res;
	}
	
	var objectKeys = Object.keys || function (obj) {
	  var res = [];
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
	  }
	  return res;
	};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = jsonpRequest;
	
	var errors = __webpack_require__(19);
	
	var JSONPCounter = 0;
	
	function jsonpRequest(url, opts, cb) {
	  if (opts.method !== 'GET') {
	    cb(new Error('Method ' + opts.method + ' ' + url + ' is not supported by JSONP.'));
	    return;
	  }
	
	  opts.debug('JSONP: start');
	
	  var cbCalled = false;
	  var timedOut = false;
	
	  JSONPCounter += 1;
	  var head = document.getElementsByTagName('head')[0];
	  var script = document.createElement('script');
	  var cbName = 'algoliaJSONP_' + JSONPCounter;
	  var done = false;
	
	  window[cbName] = function (data) {
	    removeGlobals();
	
	    if (timedOut) {
	      opts.debug('JSONP: Late answer, ignoring');
	      return;
	    }
	
	    cbCalled = true;
	
	    clean();
	
	    cb(null, {
	      body: data /* ,
	                 // We do not send the statusCode, there's no statusCode in JSONP, it will be
	                 // computed using data.status && data.message like with XDR
	                 statusCode*/
	    });
	  };
	
	  // add callback by hand
	  url += '&callback=' + cbName;
	
	  // add body params manually
	  if (opts.jsonBody && opts.jsonBody.params) {
	    url += '&' + opts.jsonBody.params;
	  }
	
	  var ontimeout = setTimeout(timeout, opts.timeouts.complete);
	
	  // script onreadystatechange needed only for
	  // <= IE8
	  // https://github.com/angular/angular.js/issues/4523
	  script.onreadystatechange = readystatechange;
	  script.onload = success;
	  script.onerror = error;
	
	  script.async = true;
	  script.defer = true;
	  script.src = url;
	  head.appendChild(script);
	
	  function success() {
	    opts.debug('JSONP: success');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    done = true;
	
	    // script loaded but did not call the fn => script loading error
	    if (!cbCalled) {
	      opts.debug('JSONP: Fail. Script loaded but did not call the callback');
	      clean();
	      cb(new errors.JSONPScriptFail());
	    }
	  }
	
	  function readystatechange() {
	    if (this.readyState === 'loaded' || this.readyState === 'complete') {
	      success();
	    }
	  }
	
	  function clean() {
	    clearTimeout(ontimeout);
	    script.onload = null;
	    script.onreadystatechange = null;
	    script.onerror = null;
	    head.removeChild(script);
	  }
	
	  function removeGlobals() {
	    try {
	      delete window[cbName];
	      delete window[cbName + '_loaded'];
	    } catch (e) {
	      window[cbName] = window[cbName + '_loaded'] = undefined;
	    }
	  }
	
	  function timeout() {
	    opts.debug('JSONP: Script timeout');
	    timedOut = true;
	    clean();
	    cb(new errors.RequestTimeout());
	  }
	
	  function error() {
	    opts.debug('JSONP: Script error');
	
	    if (done || timedOut) {
	      return;
	    }
	
	    clean();
	    cb(new errors.JSONPScriptError());
	  }
	}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = createPlacesClient;
	
	var buildSearchMethod = __webpack_require__(18);
	
	function createPlacesClient(algoliasearch) {
	  return function places(appID, apiKey, opts) {
	    var cloneDeep = __webpack_require__(24);
	
	    opts = opts && cloneDeep(opts) || {};
	    opts.hosts = opts.hosts || ['places-dsn.algolia.net', 'places-1.algolianet.com', 'places-2.algolianet.com', 'places-3.algolianet.com'];
	
	    // allow initPlaces() no arguments => community rate limited
	    if (arguments.length === 0 || (typeof appID === 'undefined' ? 'undefined' : _typeof(appID)) === 'object' || appID === undefined) {
	      appID = '';
	      apiKey = '';
	      opts._allowEmptyCredentials = true;
	    }
	
	    var client = algoliasearch(appID, apiKey, opts);
	    var index = client.initIndex('places');
	    index.search = buildSearchMethod('query', '/1/places/query');
	    index.getObject = function (objectID, callback) {
	      return this.as._jsonRequest({
	        method: 'GET',
	        url: '/1/places/' + encodeURIComponent(objectID),
	        hostType: 'read',
	        callback: callback
	      });
	    };
	    return index;
	  };
	}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = getDocumentProtocol;
	
	function getDocumentProtocol() {
	  var protocol = window.document.location.protocol;
	
	  // when in `file:` mode (local html file), default to `http:`
	  if (protocol !== 'http:' && protocol !== 'https:') {
	    protocol = 'http:';
	  }
	
	  return protocol;
	}

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = '3.24.3';

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNGNhYTg3ZjEyYTkzNDIzMTU4ODQ/NDQ2NCoqIiwid2VicGFjazovLy8uL34vbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzP2RjZWIiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZXZlbnQtcGFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xL3EuanMiLCJ3ZWJwYWNrOi8vLy4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL2FwcC9wbHVnaW5zL2V4cGxhYWluLXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvYnVpbGRzL2FsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9BbGdvbGlhU2VhcmNoLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvSW5kZXhDb3JlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnVpbGRTZWFyY2hNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3JlYWNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZGVwcmVjYXRlZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Nsb25lLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvb21pdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvbWFwLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvZXhpdFByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleEJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvQWxnb2xpYVNlYXJjaENvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2NyZWF0ZUFsZ29saWFzZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbG9iYWwvd2luZG93LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvaW5saW5lLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9qc29ucC1yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvcGxhY2VzLmpzIiwid2VicGFjazovLy8uL34vYWxnb2xpYXNlYXJjaC9zcmMvYnJvd3Nlci9nZXQtZG9jdW1lbnQtcHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbGdvbGlhc2VhcmNoL3NyYy92ZXJzaW9uLmpzIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwiZGVmaW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwibG9nTWV0aG9kcyIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlYWxNZXRob2QiLCJjb25zb2xlIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJsb2dnZXJOYW1lIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJkZWJ1ZyIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIkxvZ2dlciIsIm5hbWUiLCJkZWZhdWx0TGV2ZWwiLCJmYWN0b3J5Iiwic2VsZiIsImN1cnJlbnRMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJ0b1VwcGVyQ2FzZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImlnbm9yZSIsImRvY3VtZW50IiwiY29va2llIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0UGVyc2lzdGVkTGV2ZWwiLCJzdG9yZWRMZXZlbCIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImxldmVscyIsImdldExldmVsIiwic2V0TGV2ZWwiLCJwZXJzaXN0IiwiU0lMRU5UIiwic2V0RGVmYXVsdExldmVsIiwiZW5hYmxlQWxsIiwiVFJBQ0UiLCJkaXNhYmxlQWxsIiwiaW5pdGlhbExldmVsIiwiZGVmYXVsdExvZ2dlciIsIl9sb2dnZXJzQnlOYW1lIiwiZ2V0TG9nZ2VyIiwiVHlwZUVycm9yIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJVc2VySURzIiwibGl2ZSIsIkplcmVteSIsIk1hdHQiLCJDYXJvbCIsIkhhcnJpZXQiLCJKb25ueSIsInN0YWdpbmciLCJsb2NhbCIsImRyaXZlIiwiQUNNRSIsIlVzZXJJRCIsIlBhZ2VSZXN1bHRzIiwiVXNlckNhcmRzIiwiTGFzdFJlZnJlc2giLCJhbGdvbGlhUGFyYW1zIiwiYXBwSUQiLCJhcGlLZXkiLCJpbmRleCIsInVzZSIsImNocm9tZSIsImJyb3dzZXJBY3Rpb24iLCJvbkNsaWNrZWQiLCJhZGRMaXN0ZW5lciIsInRhYiIsInRhYnMiLCJxdWVyeSIsImFjdGl2ZSIsImN1cnJlbnRXaW5kb3ciLCJzZW5kTWVzc2FnZSIsImlkIiwiYWN0aW9uIiwicmVzIiwiaW5mbyIsInJ1bnRpbWUiLCJvbk1lc3NhZ2UiLCJyZXF1ZXN0Iiwic2VuZGVyIiwic2VuZFJlc3BvbnNlIiwidXJsIiwiZ2V0Q3VycmVudFBhZ2VSZXN1bHRzIiwiZGF0YSIsInRoZW4iLCJ0cmFjZSIsImNoZWNrUmVmcmVzaCIsImdldFBhZ2VSZXN1bHRzIiwiYWRkVG9QYWdlUmVzdWx0cyIsImNhdGNoIiwiZXJyb3IiLCJnZXRBbGxVc2VyQ2FyZHMiLCJldmVudCIsInJlc3BvbnNlIiwiZCIsImRlZmVyIiwidGFiSUQiLCJnZXRDdXJyZW50VGFiIiwicmVzb2x2ZSIsImdldFBhZ2VEYXRhIiwicmVqZWN0IiwicHJvbWlzZSIsInBhZ2VEYXRhIiwic2VuZE1lc3NhZ2VUb1RhYiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicGFnZVRhYklEIiwiZmlsdGVyIiwibm93IiwiRGF0ZSIsInNlYXJjaENhcmRzIiwicmVzdWx0cyIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0IiwiX3RvU3RyaW5nIiwidG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwiU3RyaW5nIiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwiYiIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXkiLCJpc0FycmF5QiIsImV2ZXJ5Iiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwid2FybiIsInRpcCIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm9wdGlvbnMiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwibWF0Y2giLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJjb25zdHJ1Y3RvciIsInB1c2giLCJoYW5kbGVFcnJvciIsImVyciIsImluQnJvd3NlciIsImhhc1Byb3RvIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwibmV4dFRpY2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwidGltZXJGdW5jIiwibmV4dFRpY2tIYW5kbGVyIiwiY29waWVzIiwiUHJvbWlzZSIsInAiLCJsb2dFcnJvciIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicXVldWVOZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ1aWQiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsInBvcCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsInBhcmVudCIsImNoaWxkIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJ0eXBlIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY2FwdHVyZSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImNoZWNrT3B0aW9uVHlwZSIsIm9wdGlvbiIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5Iiwic291cmNlIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJfY29udGV4dCIsImgiLCJjcmVhdGVFbGVtZW50IiwiaW5qZWN0aW9ucyIsImZ1bmN0aW9uYWxPcHRpb25zIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJzdGF0aWNSZW5kZXJGbnMiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwiY3VycmVudCIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImhvb2tzIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsIm1vZGVsUnMiLCJwYXJzZU1vZGVsIiwiaWR4IiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0Iiwic3Vic3RyaW5nIiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJkeW5hbWljVHlwZSIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJ0YXJnZXQkMSIsImFkZCQxIiwib2xkSGFuZGxlciIsImV2IiwicmVtb3ZlJDIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwiZW5kIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsIk51bWJlciIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwiaXNUZXh0SW5wdXRUeXBlIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJiaW5kaW5nIiwic2V0U2VsZWN0ZWQiLCJfdk9wdGlvbnMiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJzb21lIiwibyIsImlzTXVsdGlwbGUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsInNob3VsZERlY29kZSIsImNvbnRlbnQiLCJlbmNvZGVkIiwiZGl2IiwiaW5uZXJIVE1MIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsImxhc3RJbmRleCIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJtb2R1bGVzJDEiLCJodG1sIiwiZGlyZWN0aXZlcyQxIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYmFzZU9wdGlvbnMiLCJleHBlY3RIVE1MIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwic2luZ2xlQXR0cklkZW50aWZpZXIiLCJzaW5nbGVBdHRyQXNzaWduIiwic2luZ2xlQXR0clZhbHVlcyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5IiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJwYXJzZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImVsZW1lbnQiLCJjb21tZW50cyIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJzcGFjZSIsInVwIiwicmlnaHQiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsInNoaWZ0IiwiYWx0IiwibWV0YSIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJpZGVudFJFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImNyZWF0ZUZ1bmN0aW9uIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJyZWYkMSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsIkl0ZW0iLCJhcnJheSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJib290c3RyYXAiLCJzZXMiLCJvayIsIm1ha2VRIiwicHJldmlvdXNRIiwiUSIsImhhc1N0YWNrcyIsInFTdGFydGluZ0xpbmUiLCJjYXB0dXJlTGluZSIsInFGaWxlTmFtZSIsImhlYWQiLCJ0YXNrIiwidGFpbCIsInJlcXVlc3RUaWNrIiwiaXNOb2RlSlMiLCJsYXRlclF1ZXVlIiwiZmx1c2giLCJkb21haW4iLCJydW5TaW5nbGUiLCJleGl0Iiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJyZXF1ZXN0UG9ydFRpY2siLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwicnVuQWZ0ZXIiLCJ1bmN1cnJ5VGhpcyIsImFycmF5X3NsaWNlIiwiYXJyYXlfcmVkdWNlIiwiYmFzaXMiLCJhcnJheV9pbmRleE9mIiwiYXJyYXlfbWFwIiwidGhpc3AiLCJjb2xsZWN0Iiwib2JqZWN0X2NyZWF0ZSIsIlR5cGUiLCJvYmplY3RfZGVmaW5lUHJvcGVydHkiLCJkZXNjcmlwdG9yIiwib2JqZWN0X2hhc093blByb3BlcnR5Iiwib2JqZWN0X2tleXMiLCJvYmplY3QiLCJvYmplY3RfdG9TdHJpbmciLCJpc1N0b3BJdGVyYXRpb24iLCJleGNlcHRpb24iLCJRUmV0dXJuVmFsdWUiLCJSZXR1cm5WYWx1ZSIsIlNUQUNLX0pVTVBfU0VQQVJBVE9SIiwibWFrZVN0YWNrVHJhY2VMb25nIiwic3RhY2tzIiwiX19taW5pbXVtU3RhY2tDb3VudGVyX18iLCJzdGFja0NvdW50ZXIiLCJjb25jYXRlZFN0YWNrcyIsImZpbHRlclN0YWNrU3RyaW5nIiwic3RhY2tTdHJpbmciLCJsaW5lcyIsImRlc2lyZWRMaW5lcyIsImxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJpc05vZGVGcmFtZSIsInN0YWNrTGluZSIsImdldEZpbGVOYW1lQW5kTGluZU51bWJlciIsImF0dGVtcHQxIiwiYXR0ZW1wdDIiLCJhdHRlbXB0MyIsImZpbGVOYW1lQW5kTGluZU51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsInFFbmRpbmdMaW5lIiwiZmlyc3RMaW5lIiwiZGVwcmVjYXRlIiwiYWx0ZXJuYXRpdmUiLCJpc1Byb21pc2VBbGlrZSIsImNvZXJjZSIsImZ1bGZpbGwiLCJsb25nU3RhY2tTdXBwb3J0IiwibG9uZ1N0YWNrQ291bnRlciIsIlFfREVCVUciLCJtZXNzYWdlcyIsInByb2dyZXNzTGlzdGVuZXJzIiwicmVzb2x2ZWRQcm9taXNlIiwiZGVmZXJyZWQiLCJwcm9taXNlRGlzcGF0Y2giLCJvcCIsIm9wZXJhbmRzIiwidmFsdWVPZiIsIm5lYXJlclZhbHVlIiwibmVhcmVyIiwiaXNQcm9taXNlIiwiaW5zcGVjdCIsImJlY29tZSIsIm5ld1Byb21pc2UiLCJtZXNzYWdlIiwicHJvZ3Jlc3MiLCJwcm9ncmVzc0xpc3RlbmVyIiwibWFrZU5vZGVSZXNvbHZlciIsInJlc29sdmVyIiwicmFjZSIsInBhc3NCeUNvcHkiLCJ4IiwieSIsInRoYXQiLCJzcHJlYWQiLCJhbnN3ZXJQcyIsIm1ha2VQcm9taXNlIiwiaW5zcGVjdGVkIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwcm9ncmVzc2VkIiwiZG9uZSIsIl9mdWxmaWxsZWQiLCJfcmVqZWN0ZWQiLCJuZXdFeGNlcHRpb24iLCJfcHJvZ3Jlc3NlZCIsIm5ld1ZhbHVlIiwidGhyZXciLCJvbmVycm9yIiwidGFwIiwiZmNhbGwiLCJ0aGVuUmVzb2x2ZSIsIndoZW4iLCJ0aGVuUmVqZWN0IiwiaXNQZW5kaW5nIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwidW5oYW5kbGVkUmVhc29ucyIsInVuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXNldFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1JlamVjdGlvbiIsInVudHJhY2tSZWplY3Rpb24iLCJhdCIsImF0UmVwb3J0IiwiZ2V0VW5oYW5kbGVkUmVhc29ucyIsInN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyIsInJlamVjdGlvbiIsInJocyIsIm1hc3RlciIsImRpc3BhdGNoIiwiYXN5bmMiLCJtYWtlR2VuZXJhdG9yIiwiY29udGludWVyIiwidmVyYiIsIlN0b3BJdGVyYXRpb24iLCJnZW5lcmF0b3IiLCJlcnJiYWNrIiwic3Bhd24iLCJfcmV0dXJuIiwicHJvbWlzZWQiLCJtYXBwbHkiLCJwb3N0Iiwic2VuZCIsIm1jYWxsIiwiaW52b2tlIiwiZmFwcGx5IiwiZmJpbmQiLCJmYm91bmQiLCJwcm9taXNlcyIsInBlbmRpbmdDb3VudCIsInNuYXBzaG90IiwiYW55Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsImFsbFJlc29sdmVkIiwiYWxsU2V0dGxlZCIsInJlZ2FyZGxlc3MiLCJmYWlsIiwiZmluIiwib25VbmhhbmRsZWRFcnJvciIsIm1zIiwidGltZW91dElkIiwibmZhcHBseSIsIm5vZGVBcmdzIiwibmZjYWxsIiwibmZiaW5kIiwiZGVub2RlaWZ5IiwiYmFzZUFyZ3MiLCJuYmluZCIsImJvdW5kIiwibm1hcHBseSIsIm5wb3N0IiwibnNlbmQiLCJubWNhbGwiLCJuaW52b2tlIiwibm9kZWlmeSIsIm5vZGViYWNrIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJjbGVhckltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsImdldFByb3RvdHlwZU9mIiwid2VicGFja1BvbHlmaWxsIiwicGF0aHMiLCJlc2NhcGVSZWdFeHAiLCJTZWFyY2giLCJBbGdvbGlhQ2xpZW50IiwicHJvdG9jb2wiLCJBbGdvbGlhSW5kZXgiLCJpbml0SW5kZXgiLCJhZHZhbmNlZFNlYXJjaCIsInBhcmFtcyIsImNsZWFyQ2FjaGUiLCJzZWFyY2giLCJmZXRjaExpc3RJdGVtQ2FyZHMiLCJoaXRzIiwidXNlcklEIiwic2VhcmNoVGV4dCIsImhpdHNQZXJQYWdlIiwiY2FyZHMiLCJjYXJkIiwibGlzdENhcmRzIiwibGlzdEl0ZW1zIiwiZ2V0Q2FyZCIsIm9iamVjdElEIiwiZ2V0T2JqZWN0IiwiY29tcG91bmRTZWFyY2giLCJtYXhMZW5ndGgiLCJzZWFyY2hUZXh0QXJyYXkiLCJtaW4iLCJjZWlsIiwidCIsInIiLCJyZW1vdmVEdXBsaWNhdGVzIiwib3JpZ2luYWxBcnJheSIsIm9iaktleSIsInRyaW1tZWRBcnJheSIsInZhbHVlcyIsImNoZWNrUGFnZUhpdCIsImJvcmluZ1dvcmRzIiwiY291bnQiLCJwYWdlVGV4dCIsInNlbnRlbmNlIiwiY2hlY2tQYWdlUmVtaW5kZXIiLCJ1cmxSb290IiwiYmFzZVVybCIsInJlbWluZGVycyIsImFsbFVzZXJDYXJkcyIsInBhZ2VSZXN1bHRzIiwicGluZ3MiLCJtZW1vcmllcyIsImdtYWlsQm9yaW5nUGhyYXNlcyIsInBocmFzZSIsImFsbFdvcmRzIiwic2NvcmUiLCJlbnRpdHkiLCJyZWciLCJwb2ludHMiLCJ0cmlnZ2VyVVJMIiwicGluZyIsImhpZ2hsaWdodCIsIkFsZ29saWFTZWFyY2giLCJjcmVhdGVBbGdvbGlhc2VhcmNoIiwiSW5kZXgiLCJkZXByZWNhdGVkTWVzc2FnZSIsIkFsZ29saWFTZWFyY2hDb3JlIiwiaW5oZXJpdHMiLCJkZWxldGVJbmRleCIsImluZGV4TmFtZSIsIl9qc29uUmVxdWVzdCIsImhvc3RUeXBlIiwibW92ZUluZGV4Iiwic3JjSW5kZXhOYW1lIiwiZHN0SW5kZXhOYW1lIiwicG9zdE9iaiIsIm9wZXJhdGlvbiIsImRlc3RpbmF0aW9uIiwiY29weUluZGV4IiwiZ2V0TG9ncyIsIm9mZnNldCIsIl9nZXRTZWFyY2hQYXJhbXMiLCJsaXN0SW5kZXhlcyIsInBhZ2UiLCJsaXN0VXNlcktleXMiLCJsaXN0QXBpS2V5cyIsImdldFVzZXJLZXlBQ0wiLCJnZXRBcGlLZXkiLCJkZWxldGVVc2VyS2V5IiwiZGVsZXRlQXBpS2V5IiwiYWRkVXNlcktleSIsImFjbHMiLCJhZGRBcGlLZXkiLCJ1c2FnZSIsImFjbCIsInZhbGlkaXR5IiwibWF4UXVlcmllc1BlcklQUGVySG91ciIsIm1heEhpdHNQZXJRdWVyeSIsImluZGV4ZXMiLCJkZXNjcmlwdGlvbiIsInF1ZXJ5UGFyYW1ldGVycyIsInJlZmVyZXJzIiwiYWRkVXNlcktleVdpdGhWYWxpZGl0eSIsInVwZGF0ZVVzZXJLZXkiLCJ1cGRhdGVBcGlLZXkiLCJwdXRPYmoiLCJzdGFydFF1ZXJpZXNCYXRjaCIsInN0YXJ0UXVlcmllc0JhdGNoRGVwcmVjYXRlZCIsIl9iYXRjaCIsImFkZFF1ZXJ5SW5CYXRjaCIsImFkZFF1ZXJ5SW5CYXRjaERlcHJlY2F0ZWQiLCJzZW5kUXVlcmllc0JhdGNoIiwic2VuZFF1ZXJpZXNCYXRjaERlcHJlY2F0ZWQiLCJiYXRjaCIsIm9wZXJhdGlvbnMiLCJyZXF1ZXN0cyIsIm5vdEltcGxlbWVudGVkIiwiZW5hYmxlUmF0ZUxpbWl0Rm9yd2FyZCIsImRpc2FibGVSYXRlTGltaXRGb3J3YXJkIiwidXNlU2VjdXJlZEFQSUtleSIsImRpc2FibGVTZWN1cmVkQVBJS2V5IiwiZ2VuZXJhdGVTZWN1cmVkQXBpS2V5IiwiQWxnb2xpYVNlYXJjaEVycm9yIiwiSW5kZXhDb3JlIiwiZXhpdFByb21pc2UiLCJkZXByZWNhdGVGb3J3YXJkVG9TbGF2ZXMiLCJhZGRPYmplY3QiLCJpbmRleE9iaiIsImFzIiwiYWRkT2JqZWN0cyIsIm9iamVjdHMiLCJwYXJ0aWFsVXBkYXRlT2JqZWN0IiwicGFydGlhbE9iamVjdCIsImNyZWF0ZUlmTm90RXhpc3RzIiwicGFydGlhbFVwZGF0ZU9iamVjdHMiLCJzYXZlT2JqZWN0Iiwic2F2ZU9iamVjdHMiLCJkZWxldGVPYmplY3QiLCJfcHJvbWlzZSIsImRlbGV0ZU9iamVjdHMiLCJvYmplY3RJRHMiLCJwcmVwYXJlUmVxdWVzdCIsImRlbGV0ZUJ5UXVlcnkiLCJjbGllbnQiLCJhdHRyaWJ1dGVzVG9SZXRyaWV2ZSIsImRpc3RpbmN0Iiwic3RvcE9yRGVsZXRlIiwic2VhcmNoQ29udGVudCIsIm5iSGl0cyIsImdldE9iamVjdElEIiwid2FpdFRhc2siLCJkb0RlbGV0ZUJ5UXVlcnkiLCJkZWxldGVPYmplY3RzQ29udGVudCIsInRhc2tJRCIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwiX3NldFRpbWVvdXQiLCJicm93c2VBbGwiLCJtZXJnZSIsIkluZGV4QnJvd3NlciIsImJyb3dzZUxvb3AiLCJjdXJzb3IiLCJfc3RvcHBlZCIsImJyb3dzZUNhbGxiYWNrIiwiX2Vycm9yIiwiX3Jlc3VsdCIsIl9lbmQiLCJ0dEFkYXB0ZXIiLCJzeW5jQ2IiLCJhc3luY0NiIiwic2VhcmNoRG9uZSIsImJhc2VEZWxheSIsIm1heERlbGF5IiwicmV0cnlMb29wIiwic3RhdHVzIiwic3VjY2Vzc0NiIiwiZmFpbHVyZUNiIiwiY2xlYXJJbmRleCIsImdldFNldHRpbmdzIiwic2VhcmNoU3lub255bXMiLCJzYXZlU3lub255bSIsInN5bm9ueW0iLCJmb3J3YXJkVG9TbGF2ZXMiLCJmb3J3YXJkVG9SZXBsaWNhcyIsImdldFN5bm9ueW0iLCJkZWxldGVTeW5vbnltIiwiY2xlYXJTeW5vbnltcyIsImJhdGNoU3lub255bXMiLCJzeW5vbnltcyIsInJlcGxhY2VFeGlzdGluZ1N5bm9ueW1zIiwic2VhcmNoUnVsZXMiLCJzYXZlUnVsZSIsInJ1bGUiLCJnZXRSdWxlIiwiZGVsZXRlUnVsZSIsImNsZWFyUnVsZXMiLCJiYXRjaFJ1bGVzIiwicnVsZXMiLCJjbGVhckV4aXN0aW5nUnVsZXMiLCJzZXRTZXR0aW5ncyIsInNldHRpbmdzIiwiZGVwcmVjYXRlZEFkZFVzZXJLZXlXaXRoVmFsaWRpdHkiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJidWlsZFNlYXJjaE1ldGhvZCIsImFsZ29saWFzZWFyY2giLCJ0eXBlQWhlYWRBcmdzIiwidHlwZUFoZWFkVmFsdWVPcHRpb24iLCJzaW1pbGFyU2VhcmNoIiwiYnJvd3NlIiwiYnJvd3NlRnJvbSIsInNlYXJjaEZvckZhY2V0VmFsdWVzIiwib21pdCIsImZhY2V0TmFtZSIsImZhY2V0UXVlcnkiLCJmaWx0ZXJlZFBhcmFtcyIsImtleU5hbWUiLCJzZWFyY2hQYXJhbWV0ZXJzIiwic2VhcmNoRmFjZXQiLCJfc2VhcmNoIiwiYWRkaXRpb25hbFVBIiwiZ2V0T2JqZWN0cyIsInF1ZXJ5UGFyYW0iLCJleHRyYVByb3BlcnRpZXMiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImFkZFRvRXJyb3JPYmplY3QiLCJjcmVhdGVDdXN0b21FcnJvciIsIkFsZ29saWFTZWFyY2hDdXN0b21FcnJvciIsIlVucGFyc2FibGVKU09OIiwiUmVxdWVzdFRpbWVvdXQiLCJOZXR3b3JrIiwiSlNPTlBTY3JpcHRGYWlsIiwiSlNPTlBTY3JpcHRFcnJvciIsIlVua25vd24iLCJrIiwiZGVwcmVjYXRlZCIsInByZXZpb3VzVXNhZ2UiLCJuZXdVc2FnZSIsImdpdGh1YkFuY2hvckxpbmsiLCJmb3JlYWNoIiwic291cmNlcyIsImZpbHRlcmVkIiwiZG9GaWx0ZXIiLCJ0b1N0ciIsImlzQXJncyIsImlzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaGFzRG9udEVudW1CdWciLCJoYXNQcm90b0VudW1CdWciLCJkb250RW51bXMiLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSIsImV4Y2x1ZGVkS2V5cyIsIiRjb25zb2xlIiwiJGV4dGVybmFsIiwiJGZyYW1lIiwiJGZyYW1lRWxlbWVudCIsIiRmcmFtZXMiLCIkaW5uZXJIZWlnaHQiLCIkaW5uZXJXaWR0aCIsIiRvdXRlckhlaWdodCIsIiRvdXRlcldpZHRoIiwiJHBhZ2VYT2Zmc2V0IiwiJHBhZ2VZT2Zmc2V0IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJrZXlzU2hpbSIsImlzRnVuY3Rpb24iLCJpc0FyZ3VtZW50cyIsImlzU3RyaW5nIiwidGhlS2V5cyIsInNraXBQcm90byIsInNraXBDb25zdHJ1Y3RvciIsInNoaW0iLCJzaGltT2JqZWN0S2V5cyIsImtleXNXb3Jrc1dpdGhBcmd1bWVudHMiLCJvcmlnaW5hbEtleXMiLCJjYWxsZWUiLCJuZXdBcnIiLCJpdGVtSW5kZXgiLCJFdmVudEVtaXR0ZXIiLCJfY2xlYW4iLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsImlzTnVtYmVyIiwiZXIiLCJpc1VuZGVmaW5lZCIsImxpc3RlbmVyIiwibmV3TGlzdGVuZXIiLCJmaXJlZCIsInBvc2l0aW9uIiwibGlzdGVuZXJDb3VudCIsImV2bGlzdGVuZXIiLCJlbWl0dGVyIiwic3RvcmUiLCJNQVhfQVBJX0tFWV9MRU5HVEgiLCJSRVNFVF9BUFBfREFUQV9USU1FUiIsImFwcGxpY2F0aW9uSUQiLCJfYWxsb3dFbXB0eUNyZWRlbnRpYWxzIiwiaG9zdHMiLCJyZWFkIiwid3JpdGUiLCJfdGltZW91dHMiLCJ0aW1lb3V0cyIsImNvbm5lY3QiLCJfY2hlY2tBcHBJZERhdGEiLCJkZWZhdWx0SG9zdHMiLCJfc2h1ZmZsZVJlc3VsdCIsImhvc3ROdW1iZXIiLCJwcmVwYXJlSG9zdCIsImV4dHJhSGVhZGVycyIsIl9jYWNoZSIsIl91YSIsIl91c2VDYWNoZSIsIl91c2VGYWxsYmFjayIsInVzZUZhbGxiYWNrIiwic2V0RXh0cmFIZWFkZXIiLCJnZXRFeHRyYUhlYWRlciIsInVuc2V0RXh0cmFIZWFkZXIiLCJhZGRBbGdvbGlhQWdlbnQiLCJhbGdvbGlhQWdlbnQiLCJpbml0aWFsT3B0cyIsInJlcXVlc3REZWJ1ZyIsInRyaWVzIiwidXNpbmdGYWxsYmFjayIsImhhc0ZhbGxiYWNrIiwiX3JlcXVlc3QiLCJoZWFkZXJzIiwiX2NvbXB1dGVSZXF1ZXN0SGVhZGVycyIsInNhZmVKU09OU3RyaW5naWZ5IiwiZGVidWdEYXRhIiwiZG9SZXF1ZXN0IiwicmVxdWVzdGVyIiwicmVxT3B0cyIsInN0YXJ0VGltZSIsImNhY2hlSUQiLCJqc29uQm9keSIsIl9nZXRUaW1lb3V0c0ZvclJlcXVlc3QiLCJfc2V0SG9zdEluZGV4QnlUeXBlIiwiY3VycmVudEhvc3QiLCJfZ2V0SG9zdEJ5VHlwZSIsInRyeUZhbGxiYWNrIiwiaHR0cFJlc3BvbnNlIiwic3RhdHVzQ29kZSIsImh0dHBSZXNwb25zZU9rIiwiZW5kVGltZSIsInJlbW92ZUNyZWRlbnRpYWxzIiwiY29udGVudExlbmd0aCIsInJlc3BvbnNlVGV4dCIsInNob3VsZFJldHJ5IiwicmV0cnlSZXF1ZXN0IiwidW5yZWNvdmVyYWJsZUVycm9yIiwicmV0cnlSZXF1ZXN0V2l0aEhpZ2hlclRpbWVvdXQiLCJfaW5jcmVtZW50SG9zdEluZGV4IiwiX2luY3JlbWVudFRpbWVvdXRNdWx0aXBsZXIiLCJva0NiIiwibm9va0NiIiwid2l0aEFQSUtleSIsInVhIiwicmVxdWVzdEhlYWRlcnMiLCJ1c2VyVG9rZW4iLCJzZWN1cml0eVRhZ3MiLCJhZGRUb1JlcXVlc3RIZWFkZXJzIiwicXVlcmllcyIsIkpTT05QUGFyYW1zIiwicHJlcGFyZUpTT05QUGFyYW1zIiwicmVxdWVzdElkIiwic3RyYXRlZ3kiLCJzZXRTZWN1cml0eVRhZ3MiLCJ0YWdzIiwic3RyVGFncyIsIm9yZWRUYWdzIiwic2V0VXNlclRva2VuIiwic2V0UmVxdWVzdFRpbWVvdXQiLCJtaWxsaXNlY29uZHMiLCJzZXRUaW1lb3V0cyIsImdldFRpbWVvdXRzIiwiX2dldEFwcElkRGF0YSIsIl9jYWNoZUFwcElkRGF0YSIsIl9zZXRBcHBJZERhdGEiLCJsYXN0Q2hhbmdlIiwiZ2V0VGltZSIsIl9yZXNldEluaXRpYWxBcHBJZERhdGEiLCJob3N0SW5kZXhlcyIsInRpbWVvdXRNdWx0aXBsaWVyIiwic2h1ZmZsZVJlc3VsdCIsInNodWZmbGUiLCJfaG9zdEluZGV4ZXMiLCJfdGltZW91dE11bHRpcGxpZXIiLCJfcGFydGlhbEFwcElkRGF0YVVwZGF0ZSIsImN1cnJlbnREYXRhIiwiX2dldEhvc3RJbmRleEJ5VHlwZSIsIl9nZXRUaW1lb3V0TXVsdGlwbGllciIsImhvc3RJbmRleCIsIm5ld0hvc3RJbmRleGVzIiwiY29tcGxldGUiLCJwcmVwYXJlIiwiaG9zdCIsInRvSlNPTiIsIm91dCIsImN1cnJlbnRJbmRleCIsInRlbXBvcmFyeVZhbHVlIiwicmFuZG9tSW5kZXgiLCJuZXdIZWFkZXJzIiwiaGVhZGVyTmFtZSIsImxvY2FsU3RvcmFnZU5hbWVzcGFjZSIsIm1vZHVsZVN0b3JlIiwibG9jYWxTdG9yYWdlU3RvcmUiLCJsb2NhbFN0b3JhZ2VGYWlsdXJlIiwiY2xlYW51cCIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwiZ2V0T3JTZXQiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsInRhYmxlIiwiJDEiLCJmb3JtYXR0ZXJzIiwiaHVtYW5pemUiLCJkaWZmIiwiY29sb3IiLCJsYXN0QyIsIm5hbWVzcGFjZXMiLCJERUJVRyIsImVuYWJsZSIsImNyZWF0ZURlYnVnIiwiZGlzYWJsZSIsImVuYWJsZWQiLCJuYW1lcyIsInNraXBzIiwicHJldlRpbWUiLCJzZWxlY3RDb2xvciIsImFicyIsImN1cnIiLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJsb2dGbiIsInN1YnN0ciIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJyb3VuZCIsInBsdXJhbCIsInVhU3VmZml4IiwiaW5saW5lSGVhZGVycyIsImpzb25wUmVxdWVzdCIsInBsYWNlcyIsImNsb25lRGVlcCIsImdldERvY3VtZW50UHJvdG9jb2wiLCJBbGdvbGlhU2VhcmNoQnJvd3NlciIsImluaXRQbGFjZXMiLCJfX2FsZ29saWEiLCJzdXBwb3J0IiwiaGFzWE1MSHR0cFJlcXVlc3QiLCJoYXNYRG9tYWluUmVxdWVzdCIsImNvcnMiLCJYTUxIdHRwUmVxdWVzdCIsIndyYXBSZXF1ZXN0IiwicmVxIiwiWERvbWFpblJlcXVlc3QiLCJyZXFUaW1lb3V0IiwidGltZWRPdXQiLCJjb25uZWN0ZWQiLCJvbnByb2dyZXNzIiwib25SZWFkeVN0YXRlQ2hhbmdlIiwib25sb2FkIiwib25Mb2FkIiwib25FcnJvciIsInNldFJlcXVlc3RIZWFkZXIiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJtb3JlIiwiYWJvcnQiLCJvbkNvbm5lY3QiLCJyZWFkeVN0YXRlIiwicmVxdWVzdEZhbGxiYWNrIiwid3JhcEpzb25wUmVxdWVzdCIsImpzb25wUmVxdWVzdERvbmUiLCJyZWplY3RQcm9taXNlIiwicmVzb2x2ZVByb21pc2UiLCJkZWxheVByb21pc2UiLCJyZXNvbHZlT25UaW1lb3V0Iiwid2luIiwiRVM2UHJvbWlzZSIsIm9iamVjdE9yRnVuY3Rpb24iLCJfaXNBcnJheSIsInZlcnR4TmV4dCIsImN1c3RvbVNjaGVkdWxlckZuIiwiYXNhcCIsInNjaGVkdWxlRmx1c2giLCJzZXRTY2hlZHVsZXIiLCJzY2hlZHVsZUZuIiwic2V0QXNhcCIsImFzYXBGbiIsImJyb3dzZXJXaW5kb3ciLCJicm93c2VyR2xvYmFsIiwiQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiaXNOb2RlIiwiaXNXb3JrZXIiLCJVaW50OENsYW1wZWRBcnJheSIsInVzZU5leHRUaWNrIiwidXNlVmVydHhUaW1lciIsInVzZVNldFRpbWVvdXQiLCJ1c2VNdXRhdGlvbk9ic2VydmVyIiwiaXRlcmF0aW9ucyIsInVzZU1lc3NhZ2VDaGFubmVsIiwiZ2xvYmFsU2V0VGltZW91dCIsImF0dGVtcHRWZXJ0eCIsInZlcnR4IiwicnVuT25Mb29wIiwicnVuT25Db250ZXh0Iiwib25GdWxmaWxsbWVudCIsIm9uUmVqZWN0aW9uIiwiX2FyZ3VtZW50cyIsIlBST01JU0VfSUQiLCJfc3RhdGUiLCJpbnZva2VDYWxsYmFjayIsInN1YnNjcmliZSIsInJlc29sdmUkMSIsIkNvbnN0cnVjdG9yIiwiUEVORElORyIsIkZVTEZJTExFRCIsIlJFSkVDVEVEIiwiR0VUX1RIRU5fRVJST1IiLCJFcnJvck9iamVjdCIsInNlbGZGdWxmaWxsbWVudCIsImNhbm5vdFJldHVybk93biIsImdldFRoZW4iLCJ0cnlUaGVuIiwidGhlbiQkMSIsImZ1bGZpbGxtZW50SGFuZGxlciIsInJlamVjdGlvbkhhbmRsZXIiLCJoYW5kbGVGb3JlaWduVGhlbmFibGUiLCJ0aGVuYWJsZSIsIl9sYWJlbCIsImhhbmRsZU93blRoZW5hYmxlIiwiaGFuZGxlTWF5YmVUaGVuYWJsZSIsIm1heWJlVGhlbmFibGUiLCJwdWJsaXNoUmVqZWN0aW9uIiwiX29uZXJyb3IiLCJwdWJsaXNoIiwiX3N1YnNjcmliZXJzIiwic3Vic2NyaWJlcnMiLCJzZXR0bGVkIiwiZGV0YWlsIiwiVFJZX0NBVENIX0VSUk9SIiwidHJ5Q2F0Y2giLCJoYXNDYWxsYmFjayIsInN1Y2NlZWRlZCIsImZhaWxlZCIsImluaXRpYWxpemVQcm9taXNlIiwibmV4dElkIiwiRW51bWVyYXRvciQxIiwiaW5wdXQiLCJfaW5zdGFuY2VDb25zdHJ1Y3RvciIsIl9yZW1haW5pbmciLCJfZW51bWVyYXRlIiwidmFsaWRhdGlvbkVycm9yIiwiX2VhY2hFbnRyeSIsImVudHJ5IiwicmVzb2x2ZSQkMSIsIl90aGVuIiwiX3NldHRsZWRBdCIsIlByb21pc2UkMiIsIl93aWxsU2V0dGxlQXQiLCJlbnVtZXJhdG9yIiwiYWxsJDEiLCJlbnRyaWVzIiwicmFjZSQxIiwicmVqZWN0JDEiLCJuZWVkc1Jlc29sdmVyIiwibmVlZHNOZXciLCJfc2V0U2NoZWR1bGVyIiwiX3NldEFzYXAiLCJfYXNhcCIsIl9jYXRjaCIsInBvbHlmaWxsJDEiLCJQIiwicHJvbWlzZVRvU3RyaW5nIiwiY2FzdCIsInBvbHlmaWxsIiwiZW5jb2RlIiwic3RyaW5naWZ5UHJpbWl0aXZlIiwic2VwIiwiZXEiLCJvYmplY3RLZXlzIiwia3MiLCJ4cyIsIkpTT05QQ291bnRlciIsImNiQ2FsbGVkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjYk5hbWUiLCJyZW1vdmVHbG9iYWxzIiwiY2xlYW4iLCJvbnRpbWVvdXQiLCJyZWFkeXN0YXRlY2hhbmdlIiwiY3JlYXRlUGxhY2VzQ2xpZW50Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENBOzs7Ozs7QUFNQyxZQUFVQSxJQUFWLEVBQWdCQyxVQUFoQixFQUE0QjtBQUN6Qjs7QUFDQSxTQUFJLElBQUosRUFBZ0Q7QUFDNUNDLFNBQUEsb0NBQU9ELFVBQVA7QUFDSCxNQUZELE1BRU8sSUFBSSxRQUFPRSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCQSxPQUFPQyxPQUF6QyxFQUFrRDtBQUNyREQsZ0JBQU9DLE9BQVAsR0FBaUJILFlBQWpCO0FBQ0gsTUFGTSxNQUVBO0FBQ0hELGNBQUtLLEdBQUwsR0FBV0osWUFBWDtBQUNIO0FBQ0osRUFUQSxhQVNPLFlBQVk7QUFDaEI7O0FBRUE7O0FBQ0EsU0FBSUssT0FBTyxTQUFQQSxJQUFPLEdBQVcsQ0FBRSxDQUF4QjtBQUNBLFNBQUlDLGdCQUFnQixXQUFwQjs7QUFFQSxTQUFJQyxhQUFhLENBQ2IsT0FEYSxFQUViLE9BRmEsRUFHYixNQUhhLEVBSWIsTUFKYSxFQUtiLE9BTGEsQ0FBakI7O0FBUUE7QUFDQSxjQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUF5QkMsVUFBekIsRUFBcUM7QUFDakMsYUFBSUMsU0FBU0YsSUFBSUMsVUFBSixDQUFiO0FBQ0EsYUFBSSxPQUFPQyxPQUFPQyxJQUFkLEtBQXVCLFVBQTNCLEVBQXVDO0FBQ25DLG9CQUFPRCxPQUFPQyxJQUFQLENBQVlILEdBQVosQ0FBUDtBQUNILFVBRkQsTUFFTztBQUNILGlCQUFJO0FBQ0Esd0JBQU9JLFNBQVNDLFNBQVQsQ0FBbUJGLElBQW5CLENBQXdCRyxJQUF4QixDQUE2QkosTUFBN0IsRUFBcUNGLEdBQXJDLENBQVA7QUFDSCxjQUZELENBRUUsT0FBT08sQ0FBUCxFQUFVO0FBQ1I7QUFDQSx3QkFBTyxZQUFXO0FBQ2QsNEJBQU9ILFNBQVNDLFNBQVQsQ0FBbUJHLEtBQW5CLENBQXlCQSxLQUF6QixDQUErQk4sTUFBL0IsRUFBdUMsQ0FBQ0YsR0FBRCxFQUFNUyxTQUFOLENBQXZDLENBQVA7QUFDSCxrQkFGRDtBQUdIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0EsY0FBU0MsVUFBVCxDQUFvQlQsVUFBcEIsRUFBZ0M7QUFDNUIsYUFBSUEsZUFBZSxPQUFuQixFQUE0QjtBQUN4QkEsMEJBQWEsS0FBYjtBQUNIOztBQUVELGFBQUksUUFBT1UsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQmQsYUFBdkIsRUFBc0M7QUFDbEMsb0JBQU8sS0FBUCxDQURrQyxDQUNwQjtBQUNqQixVQUZELE1BRU8sSUFBSWMsUUFBUVYsVUFBUixNQUF3QlcsU0FBNUIsRUFBdUM7QUFDMUMsb0JBQU9iLFdBQVdZLE9BQVgsRUFBb0JWLFVBQXBCLENBQVA7QUFDSCxVQUZNLE1BRUEsSUFBSVUsUUFBUWhCLEdBQVIsS0FBZ0JpQixTQUFwQixFQUErQjtBQUNsQyxvQkFBT2IsV0FBV1ksT0FBWCxFQUFvQixLQUFwQixDQUFQO0FBQ0gsVUFGTSxNQUVBO0FBQ0gsb0JBQU9mLElBQVA7QUFDSDtBQUNKOztBQUVEOztBQUVBLGNBQVNpQixxQkFBVCxDQUErQkMsS0FBL0IsRUFBc0NDLFVBQXRDLEVBQWtEO0FBQzlDO0FBQ0EsY0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlsQixXQUFXbUIsTUFBL0IsRUFBdUNELEdBQXZDLEVBQTRDO0FBQ3hDLGlCQUFJZixhQUFhSCxXQUFXa0IsQ0FBWCxDQUFqQjtBQUNBLGtCQUFLZixVQUFMLElBQW9CZSxJQUFJRixLQUFMLEdBQ2ZsQixJQURlLEdBRWYsS0FBS3NCLGFBQUwsQ0FBbUJqQixVQUFuQixFQUErQmEsS0FBL0IsRUFBc0NDLFVBQXRDLENBRko7QUFHSDs7QUFFRDtBQUNBLGNBQUtwQixHQUFMLEdBQVcsS0FBS3dCLEtBQWhCO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLGNBQVNDLCtCQUFULENBQXlDbkIsVUFBekMsRUFBcURhLEtBQXJELEVBQTREQyxVQUE1RCxFQUF3RTtBQUNwRSxnQkFBTyxZQUFZO0FBQ2YsaUJBQUksUUFBT0osT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQmQsYUFBdkIsRUFBc0M7QUFDbENnQix1Q0FBc0JQLElBQXRCLENBQTJCLElBQTNCLEVBQWlDUSxLQUFqQyxFQUF3Q0MsVUFBeEM7QUFDQSxzQkFBS2QsVUFBTCxFQUFpQk8sS0FBakIsQ0FBdUIsSUFBdkIsRUFBNkJDLFNBQTdCO0FBQ0g7QUFDSixVQUxEO0FBTUg7O0FBRUQ7QUFDQTtBQUNBLGNBQVNZLG9CQUFULENBQThCcEIsVUFBOUIsRUFBMENhLEtBQTFDLEVBQWlEQyxVQUFqRCxFQUE2RDtBQUN6RDtBQUNBLGdCQUFPTCxXQUFXVCxVQUFYLEtBQ0FtQixnQ0FBZ0NaLEtBQWhDLENBQXNDLElBQXRDLEVBQTRDQyxTQUE1QyxDQURQO0FBRUg7O0FBRUQsY0FBU2EsTUFBVCxDQUFnQkMsSUFBaEIsRUFBc0JDLFlBQXRCLEVBQW9DQyxPQUFwQyxFQUE2QztBQUMzQyxhQUFJQyxPQUFPLElBQVg7QUFDQSxhQUFJQyxZQUFKO0FBQ0EsYUFBSUMsYUFBYSxVQUFqQjtBQUNBLGFBQUlMLElBQUosRUFBVTtBQUNSSywyQkFBYyxNQUFNTCxJQUFwQjtBQUNEOztBQUVELGtCQUFTTSxzQkFBVCxDQUFnQ0MsUUFBaEMsRUFBMEM7QUFDdEMsaUJBQUlDLFlBQVksQ0FBQ2pDLFdBQVdnQyxRQUFYLEtBQXdCLFFBQXpCLEVBQW1DRSxXQUFuQyxFQUFoQjs7QUFFQSxpQkFBSSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCcEMsYUFBdEIsRUFBcUM7O0FBRXJDO0FBQ0EsaUJBQUk7QUFDQW9DLHdCQUFPQyxZQUFQLENBQW9CTixVQUFwQixJQUFrQ0csU0FBbEM7QUFDQTtBQUNILGNBSEQsQ0FHRSxPQUFPSSxNQUFQLEVBQWUsQ0FBRTs7QUFFbkI7QUFDQSxpQkFBSTtBQUNBRix3QkFBT0csUUFBUCxDQUFnQkMsTUFBaEIsR0FDRUMsbUJBQW1CVixVQUFuQixJQUFpQyxHQUFqQyxHQUF1Q0csU0FBdkMsR0FBbUQsR0FEckQ7QUFFSCxjQUhELENBR0UsT0FBT0ksTUFBUCxFQUFlLENBQUU7QUFDdEI7O0FBRUQsa0JBQVNJLGlCQUFULEdBQTZCO0FBQ3pCLGlCQUFJQyxXQUFKOztBQUVBLGlCQUFJLFFBQU9QLE1BQVAseUNBQU9BLE1BQVAsT0FBa0JwQyxhQUF0QixFQUFxQzs7QUFFckMsaUJBQUk7QUFDQTJDLCtCQUFjUCxPQUFPQyxZQUFQLENBQW9CTixVQUFwQixDQUFkO0FBQ0gsY0FGRCxDQUVFLE9BQU9PLE1BQVAsRUFBZSxDQUFFOztBQUVuQjtBQUNBLGlCQUFJLFFBQU9LLFdBQVAseUNBQU9BLFdBQVAsT0FBdUIzQyxhQUEzQixFQUEwQztBQUN0QyxxQkFBSTtBQUNBLHlCQUFJd0MsU0FBU0osT0FBT0csUUFBUCxDQUFnQkMsTUFBN0I7QUFDQSx5QkFBSUksV0FBV0osT0FBT0ssT0FBUCxDQUNYSixtQkFBbUJWLFVBQW5CLElBQWlDLEdBRHRCLENBQWY7QUFFQSx5QkFBSWEsUUFBSixFQUFjO0FBQ1ZELHVDQUFjLFdBQVdHLElBQVgsQ0FBZ0JOLE9BQU9PLEtBQVAsQ0FBYUgsUUFBYixDQUFoQixFQUF3QyxDQUF4QyxDQUFkO0FBQ0g7QUFDSixrQkFQRCxDQU9FLE9BQU9OLE1BQVAsRUFBZSxDQUFFO0FBQ3RCOztBQUVEO0FBQ0EsaUJBQUlULEtBQUttQixNQUFMLENBQVlMLFdBQVosTUFBNkI1QixTQUFqQyxFQUE0QztBQUN4QzRCLCtCQUFjNUIsU0FBZDtBQUNIOztBQUVELG9CQUFPNEIsV0FBUDtBQUNIOztBQUVEOzs7Ozs7QUFNQWQsY0FBS21CLE1BQUwsR0FBYyxFQUFFLFNBQVMsQ0FBWCxFQUFjLFNBQVMsQ0FBdkIsRUFBMEIsUUFBUSxDQUFsQyxFQUFxQyxRQUFRLENBQTdDO0FBQ1Ysc0JBQVMsQ0FEQyxFQUNFLFVBQVUsQ0FEWixFQUFkOztBQUdBbkIsY0FBS1IsYUFBTCxHQUFxQk8sV0FBV0osb0JBQWhDOztBQUVBSyxjQUFLb0IsUUFBTCxHQUFnQixZQUFZO0FBQ3hCLG9CQUFPbkIsWUFBUDtBQUNILFVBRkQ7O0FBSUFELGNBQUtxQixRQUFMLEdBQWdCLFVBQVVqQyxLQUFWLEVBQWlCa0MsT0FBakIsRUFBMEI7QUFDdEMsaUJBQUksT0FBT2xDLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJZLEtBQUttQixNQUFMLENBQVkvQixNQUFNa0IsV0FBTixFQUFaLE1BQXFDcEIsU0FBdEUsRUFBaUY7QUFDN0VFLHlCQUFRWSxLQUFLbUIsTUFBTCxDQUFZL0IsTUFBTWtCLFdBQU4sRUFBWixDQUFSO0FBQ0g7QUFDRCxpQkFBSSxPQUFPbEIsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsU0FBUyxDQUF0QyxJQUEyQ0EsU0FBU1ksS0FBS21CLE1BQUwsQ0FBWUksTUFBcEUsRUFBNEU7QUFDeEV0QixnQ0FBZWIsS0FBZjtBQUNBLHFCQUFJa0MsWUFBWSxLQUFoQixFQUF1QjtBQUFHO0FBQ3RCbkIsNENBQXVCZixLQUF2QjtBQUNIO0FBQ0RELHVDQUFzQlAsSUFBdEIsQ0FBMkJvQixJQUEzQixFQUFpQ1osS0FBakMsRUFBd0NTLElBQXhDO0FBQ0EscUJBQUksUUFBT1osT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQmQsYUFBbkIsSUFBb0NpQixRQUFRWSxLQUFLbUIsTUFBTCxDQUFZSSxNQUE1RCxFQUFvRTtBQUNoRSw0QkFBTyxrQ0FBUDtBQUNIO0FBQ0osY0FURCxNQVNPO0FBQ0gsdUJBQU0sK0NBQStDbkMsS0FBckQ7QUFDSDtBQUNKLFVBaEJEOztBQWtCQVksY0FBS3dCLGVBQUwsR0FBdUIsVUFBVXBDLEtBQVYsRUFBaUI7QUFDcEMsaUJBQUksQ0FBQ3lCLG1CQUFMLEVBQTBCO0FBQ3RCYixzQkFBS3FCLFFBQUwsQ0FBY2pDLEtBQWQsRUFBcUIsS0FBckI7QUFDSDtBQUNKLFVBSkQ7O0FBTUFZLGNBQUt5QixTQUFMLEdBQWlCLFVBQVNILE9BQVQsRUFBa0I7QUFDL0J0QixrQkFBS3FCLFFBQUwsQ0FBY3JCLEtBQUttQixNQUFMLENBQVlPLEtBQTFCLEVBQWlDSixPQUFqQztBQUNILFVBRkQ7O0FBSUF0QixjQUFLMkIsVUFBTCxHQUFrQixVQUFTTCxPQUFULEVBQWtCO0FBQ2hDdEIsa0JBQUtxQixRQUFMLENBQWNyQixLQUFLbUIsTUFBTCxDQUFZSSxNQUExQixFQUFrQ0QsT0FBbEM7QUFDSCxVQUZEOztBQUlBO0FBQ0EsYUFBSU0sZUFBZWYsbUJBQW5CO0FBQ0EsYUFBSWUsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3RCQSw0QkFBZTlCLGdCQUFnQixJQUFoQixHQUF1QixNQUF2QixHQUFnQ0EsWUFBL0M7QUFDSDtBQUNERSxjQUFLcUIsUUFBTCxDQUFjTyxZQUFkLEVBQTRCLEtBQTVCO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQUlDLGdCQUFnQixJQUFJakMsTUFBSixFQUFwQjs7QUFFQSxTQUFJa0MsaUJBQWlCLEVBQXJCO0FBQ0FELG1CQUFjRSxTQUFkLEdBQTBCLFNBQVNBLFNBQVQsQ0FBbUJsQyxJQUFuQixFQUF5QjtBQUMvQyxhQUFJLE9BQU9BLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEJBLFNBQVMsRUFBekMsRUFBNkM7QUFDM0MsbUJBQU0sSUFBSW1DLFNBQUosQ0FBYyxnREFBZCxDQUFOO0FBQ0Q7O0FBRUQsYUFBSUMsU0FBU0gsZUFBZWpDLElBQWYsQ0FBYjtBQUNBLGFBQUksQ0FBQ29DLE1BQUwsRUFBYTtBQUNYQSxzQkFBU0gsZUFBZWpDLElBQWYsSUFBdUIsSUFBSUQsTUFBSixDQUM5QkMsSUFEOEIsRUFDeEJnQyxjQUFjVCxRQUFkLEVBRHdCLEVBQ0VTLGNBQWNyQyxhQURoQixDQUFoQztBQUVEO0FBQ0QsZ0JBQU95QyxNQUFQO0FBQ0gsTUFYRDs7QUFhQTtBQUNBLFNBQUlDLE9BQVEsUUFBTzNCLE1BQVAseUNBQU9BLE1BQVAsT0FBa0JwQyxhQUFuQixHQUFvQ29DLE9BQU90QyxHQUEzQyxHQUFpRGlCLFNBQTVEO0FBQ0EyQyxtQkFBY00sVUFBZCxHQUEyQixZQUFXO0FBQ2xDLGFBQUksUUFBTzVCLE1BQVAseUNBQU9BLE1BQVAsT0FBa0JwQyxhQUFsQixJQUNHb0MsT0FBT3RDLEdBQVAsS0FBZTRELGFBRHRCLEVBQ3FDO0FBQ2pDdEIsb0JBQU90QyxHQUFQLEdBQWFpRSxJQUFiO0FBQ0g7O0FBRUQsZ0JBQU9MLGFBQVA7QUFDSCxNQVBEOztBQVNBLFlBQU9BLGFBQVA7QUFDSCxFQTdPQSxDQUFELEM7Ozs7Ozs7O0FDTkE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQUVBLG9CQUFJUixRQUFKLENBQWEsT0FBYjs7QUFFQSxLQUFNZSxVQUFVO0FBQ2RDLFNBQU07QUFDSkMsYUFBUSxrQkFESjtBQUVKQyxXQUFNLGtCQUZGO0FBR0pDLFlBQU8sa0JBSEg7QUFJSkMsY0FBUyxrQkFKTDtBQUtKQyxZQUFPO0FBTEgsSUFEUTtBQVFkQyxZQUFTO0FBQ1BMLGFBQVEsa0JBREQ7QUFFUEMsV0FBTTtBQUZDLElBUks7QUFZZEssVUFBTztBQUNMTixhQUFRLGtCQURIO0FBRUxDLFdBQU07QUFGRCxJQVpPO0FBZ0JkTSxVQUFPO0FBQ0xQLGFBQVEsdUJBREg7QUFFTFEsV0FBTTtBQUZEO0FBaEJPLEVBQWhCOztBQXNCQSxLQUFNQyxTQUFTWCxRQUFRUyxLQUFSLENBQWNDLElBQTdCO0FBQ0EsS0FBSUUsY0FBYyxFQUFsQjtBQUNBLEtBQUlDLFlBQVksRUFBaEI7QUFDQSxLQUFJQyxjQUFjLENBQWxCOztBQUVBLEtBQU1DLGdCQUFnQixFQUFFO0FBQ3RCQyxVQUFPLFlBRGE7QUFFcEJDLFdBQVEsa0NBRlk7QUFHcEJDLFVBQU87QUFIYSxFQUF0QjtBQUtBLGVBQUlDLEdBQUosMkJBQXdCSixhQUF4Qjs7QUFFQUssUUFBT0MsYUFBUCxDQUFxQkMsU0FBckIsQ0FBK0JDLFdBQS9CLENBQTJDLFVBQVNDLEdBQVQsRUFBYztBQUN2REosVUFBT0ssSUFBUCxDQUFZQyxLQUFaLENBQWtCLEVBQUNDLFFBQVEsSUFBVCxFQUFlQyxlQUFlLElBQTlCLEVBQWxCLEVBQXVELFVBQVNILElBQVQsRUFBYztBQUNuRUwsWUFBT0ssSUFBUCxDQUFZSSxXQUFaLENBQXdCSixLQUFLLENBQUwsRUFBUUssRUFBaEMsRUFBb0MsRUFBQ0MsUUFBUSxjQUFULEVBQXBDLEVBQThELFVBQVNDLEdBQVQsRUFBYztBQUMxRSwwQkFBSUMsSUFBSixDQUFTRCxHQUFUO0FBQ0QsTUFGRDtBQUdELElBSkQ7QUFLRCxFQU5EOztBQVFBWixRQUFPYyxPQUFQLENBQWVDLFNBQWYsQ0FBeUJaLFdBQXpCLENBQXFDLFVBQVNhLE9BQVQsRUFBa0JDLE1BQWxCLEVBQTBCQyxZQUExQixFQUF3QztBQUMzRSxPQUFJO0FBQ0Ysd0JBQUlqRixLQUFKLENBQVdnRixPQUFPYixHQUFQLEdBQWEsNEJBQTRCYSxPQUFPYixHQUFQLENBQVdlLEdBQXBELEdBQTBELG9CQUFyRSxFQUE0RkgsT0FBNUY7O0FBRUEsU0FBR0EsUUFBUUwsTUFBUixJQUFrQixnQkFBckIsRUFBc0M7QUFDcENTLDZCQUFzQkosUUFBUUssSUFBOUIsRUFDQ0MsSUFERCxDQUNNLFVBQVNWLEdBQVQsRUFBYztBQUNsQiw0QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQU0sc0JBQWFOLEdBQWI7QUFDRCxRQUpEO0FBS0EsY0FBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFJSSxRQUFRTCxNQUFSLElBQWtCLFdBQXRCLEVBQW1DO0FBQ2pDLDBCQUFJWSxLQUFKLENBQVVQLFFBQVFLLElBQWxCO0FBQ0FHLHNCQUNDRixJQURELENBQ00sWUFBVztBQUNmLGdCQUFPLHlCQUFlRyxjQUFmLENBQThCbEMsTUFBOUIsRUFBc0N5QixRQUFRSyxJQUE5QyxFQUFvRDVCLFNBQXBELENBQVA7QUFDRCxRQUhELEVBR0c2QixJQUhILENBR1EsVUFBU1YsR0FBVCxFQUFjO0FBQ3BCYywwQkFBaUJULE9BQU9iLEdBQVAsQ0FBV00sRUFBNUIsRUFBZ0NFLEdBQWhDO0FBQ0FwQix1QkFBY29CLEdBQWQ7QUFDQU0sc0JBQWFOLEdBQWI7QUFDRCxRQVBELEVBT0dlLEtBUEgsQ0FPUyxVQUFTdEcsQ0FBVCxFQUFZO0FBQ25CLDRCQUFJdUcsS0FBSixDQUFVdkcsQ0FBVjtBQUNELFFBVEQ7QUFVQSxjQUFPLElBQVA7QUFDRDtBQUNELFNBQUcyRixRQUFRTCxNQUFSLElBQWtCLFNBQXJCLEVBQStCO0FBQzdCTyxvQkFBYTNCLE1BQWI7QUFDQSxjQUFPLElBQVA7QUFDRDtBQUNELFNBQUd5QixRQUFRTCxNQUFSLElBQWtCLGNBQXJCLEVBQW9DO0FBQ2xDa0I7QUFDQSxjQUFPLElBQVA7QUFDRDtBQUNELFNBQUdiLFFBQVFjLEtBQVIsSUFBaUIsYUFBcEIsRUFBa0M7QUFDaEM5QixjQUFPSyxJQUFQLENBQVlDLEtBQVosQ0FBa0IsRUFBQ0MsUUFBUSxJQUFULEVBQWVDLGVBQWUsSUFBOUIsRUFBbEIsRUFBdUQsVUFBU0gsSUFBVCxFQUFjO0FBQ25FTCxnQkFBT0ssSUFBUCxDQUFZSSxXQUFaLENBQXdCSixLQUFLLENBQUwsRUFBUUssRUFBaEMsRUFBb0MsRUFBQ29CLE9BQU8sYUFBUixFQUFwQyxFQUE0RCxVQUFTQyxRQUFULEVBQW1CLENBQUUsQ0FBakY7QUFDRCxRQUZEO0FBR0EsY0FBTyxJQUFQO0FBQ0Q7QUFDRixJQXZDRCxDQXVDRSxPQUFNMUcsQ0FBTixFQUFTO0FBQ1Qsd0JBQUl1RyxLQUFKLENBQVV2RyxDQUFWO0FBQ0Q7QUFDRixFQTNDRDs7QUE2Q0EsS0FBTStGLHdCQUF3QixTQUF4QkEscUJBQXdCLENBQVNDLElBQVQsRUFBZTtBQUMzQyxPQUFNVyxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBLE9BQUlDLEtBQUo7QUFDQSxzQkFBSWpHLEtBQUosQ0FBVSxDQUFWO0FBQ0F1RixrQkFDQ0YsSUFERCxDQUNNYSxhQUROLEVBRUNiLElBRkQsQ0FFTSxVQUFTbEIsR0FBVCxFQUFjO0FBQ2xCLHdCQUFJbkUsS0FBSixDQUFVbUUsSUFBSU0sRUFBZDtBQUNBd0IsYUFBUTlCLElBQUlNLEVBQVo7QUFDQSx3QkFBSXpFLEtBQUosQ0FBVXVELFdBQVY7QUFDQSxTQUFJQSxZQUFZMEMsS0FBWixDQUFKLEVBQXdCO0FBQ3RCRixTQUFFSSxPQUFGLENBQVU1QyxZQUFZMEMsS0FBWixDQUFWO0FBQ0QsTUFGRCxNQUVPO0FBQ0wsV0FBSSxDQUFDYixJQUFMLEVBQVdBLE9BQU8sRUFBQ2EsT0FBT0EsS0FBUixFQUFQO0FBQ1gsMEJBQUlqRyxLQUFKLENBQVVvRixJQUFWO0FBQ0FnQixtQkFBWWhCLElBQVosRUFDQ0MsSUFERCxDQUNNLFVBQVNWLEdBQVQsRUFBYztBQUNsQiw0QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQSxnQkFBTyx5QkFBZWEsY0FBZixDQUE4QmxDLE1BQTlCLEVBQXNDcUIsR0FBdEMsRUFBMkNuQixTQUEzQyxDQUFQO0FBQ0QsUUFKRCxFQUlHNkIsSUFKSCxDQUlRLFVBQVNWLEdBQVQsRUFBYztBQUNwQiw0QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQWMsMEJBQWlCUSxLQUFqQixFQUF3QnRCLEdBQXhCO0FBQ0FvQixXQUFFSSxPQUFGLENBQVV4QixHQUFWO0FBQ0QsUUFSRCxFQVFHZSxLQVJILENBUVMsVUFBU3RHLENBQVQsRUFBWTtBQUNuQjJHLFdBQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxRQVZEO0FBV0Q7QUFDRixJQXZCRCxFQXVCR3NHLEtBdkJILENBdUJTLFVBQVN0RyxDQUFULEVBQVk7QUFDbkIyRyxPQUFFTSxNQUFGLENBQVNqSCxDQUFUO0FBQ0QsSUF6QkQ7QUEwQkEsVUFBTzJHLEVBQUVPLE9BQVQ7QUFDRCxFQS9CRDs7QUFpQ0EsS0FBTUosZ0JBQWdCLFNBQWhCQSxhQUFnQixHQUFXO0FBQy9CO0FBQ0EsT0FBTUgsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQWpDLFVBQU9LLElBQVAsQ0FBWUMsS0FBWixDQUFrQixFQUFDQyxRQUFRLElBQVQsRUFBZUMsZUFBZSxJQUE5QixFQUFsQixFQUF1RCxVQUFTSCxJQUFULEVBQWM7QUFDbkUyQixPQUFFSSxPQUFGLENBQVUvQixLQUFLLENBQUwsQ0FBVjtBQUNELElBRkQ7QUFHQSxVQUFPMkIsRUFBRU8sT0FBVDtBQUNELEVBUEQ7O0FBU0EsS0FBTUYsY0FBYyxTQUFkQSxXQUFjLENBQVNoQixJQUFULEVBQWU7QUFDakMsT0FBTVcsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQSxPQUFJWixLQUFLbUIsUUFBVCxFQUFtQjtBQUNqQlIsT0FBRUksT0FBRixDQUFVZixLQUFLbUIsUUFBZjtBQUNELElBRkQsTUFFTyxJQUFJbkIsS0FBS2EsS0FBVCxFQUFnQjtBQUNyQk8sc0JBQWlCUCxLQUFqQixFQUF3QixFQUFDdkIsUUFBUSxhQUFULEVBQXhCLEVBQ0NXLElBREQsQ0FDTSxVQUFTVixHQUFULEVBQWM7QUFDbEJvQixTQUFFSSxPQUFGLENBQVV4QixHQUFWO0FBQ0QsTUFIRDtBQUlELElBTE0sTUFLQTtBQUNMb0IsT0FBRU0sTUFBRjtBQUNEO0FBQ0QsVUFBT04sRUFBRU8sT0FBVDtBQUNELEVBYkQ7O0FBZUEsS0FBTUUsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU1AsS0FBVCxFQUFnQmIsSUFBaEIsRUFBc0I7QUFDN0M7QUFDQSxPQUFNVyxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBakMsVUFBT0ssSUFBUCxDQUFZSSxXQUFaLENBQXdCeUIsS0FBeEIsRUFBK0JiLElBQS9CLEVBQXFDLFVBQVNULEdBQVQsRUFBYztBQUNqRCx3QkFBSTNFLEtBQUosQ0FBVTJFLEdBQVY7QUFDQW9CLE9BQUVJLE9BQUYsQ0FBVXhCLEdBQVY7QUFDRCxJQUhEO0FBSUEsVUFBT29CLEVBQUVPLE9BQVQ7QUFDRCxFQVJEOztBQVVBLEtBQU1iLG1CQUFtQixTQUFuQkEsZ0JBQW1CLENBQVNRLEtBQVQsRUFBZ0JiLElBQWhCLEVBQXNCO0FBQzdDN0IsZUFBWTBDLEtBQVosSUFBcUJiLElBQXJCO0FBQ0FyQixVQUFPSyxJQUFQLENBQVlDLEtBQVosQ0FBa0IsRUFBQ0MsUUFBUSxJQUFULEVBQWVDLGVBQWUsSUFBOUIsRUFBbEIsRUFBdUQsVUFBU0gsSUFBVCxFQUFjO0FBQ25FcUMsWUFBT0MsSUFBUCxDQUFZbkQsV0FBWixFQUF5Qm9ELE9BQXpCLENBQWlDLFVBQVNDLFNBQVQsRUFBb0I7QUFDbkQsV0FBS3hDLEtBQUt5QyxNQUFMLENBQVksVUFBUzFDLEdBQVQsRUFBYztBQUFDLGdCQUFPQSxJQUFJTSxFQUFKLElBQVVtQyxTQUFqQjtBQUEyQixRQUF0RCxFQUF3RDlHLE1BQXhELElBQWtFLENBQXZFLEVBQ0UsT0FBT3lELFlBQVlxRCxTQUFaLENBQVA7QUFDSCxNQUhEO0FBSUEsd0JBQUk1RyxLQUFKLENBQVV1RCxXQUFWO0FBQ0QsSUFORDtBQU9ELEVBVEQ7O0FBV0EsS0FBTWdDLGVBQWUsU0FBZkEsWUFBZSxHQUFXO0FBQzlCLE9BQU1RLElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0EsT0FBTWMsTUFBTSxJQUFJQyxJQUFKLEVBQVo7QUFDQSxPQUFJRCxNQUFNckQsV0FBTixHQUFvQixNQUF4QixFQUFnQztBQUM5Qm1DLHVCQUNDUCxJQURELENBQ00sWUFBVztBQUNmVSxTQUFFSSxPQUFGO0FBQ0QsTUFIRCxFQUdHVCxLQUhILENBR1MsVUFBU3RHLENBQVQsRUFBWTtBQUNuQiwwQkFBSXVHLEtBQUosQ0FBVXZHLENBQVY7QUFDQTJHLFNBQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxNQU5EO0FBT0QsSUFSRCxNQVFPO0FBQ0wyRyxPQUFFSSxPQUFGO0FBQ0Q7QUFDRCxVQUFPSixFQUFFTyxPQUFUO0FBQ0QsRUFmRDs7QUFpQkEsS0FBTVYsa0JBQWtCLFNBQWxCQSxlQUFrQixHQUFXO0FBQ2pDLE9BQU1HLElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0F2QyxpQkFBYyxJQUFJc0QsSUFBSixFQUFkO0FBQ0EsNEJBQWVDLFdBQWYsQ0FBMkIxRCxNQUEzQixFQUFtQyxFQUFuQyxFQUF1QyxJQUF2QyxFQUNDK0IsSUFERCxDQUNNLFVBQVM0QixPQUFULEVBQWtCO0FBQ3RCekQsaUJBQVl5RCxPQUFaO0FBQ0Esd0JBQUlqSCxLQUFKLENBQVV3RCxTQUFWO0FBQ0F1QyxPQUFFSSxPQUFGO0FBQ0QsSUFMRCxFQUtHVCxLQUxILENBS1MsVUFBU3RHLENBQVQsRUFBWTtBQUNuQix3QkFBSXVHLEtBQUosQ0FBVXZHLENBQVY7QUFDQTJHLE9BQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxJQVJEO0FBU0EsVUFBTzJHLEVBQUVPLE9BQVQ7QUFDRCxFQWJEO0FBY0FWLG1COzs7Ozs7Ozs7Ozs7OztBQzVNQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0EsVUFBU3NCLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFVBQU9BLE1BQU0xSCxTQUFOLElBQW1CMEgsTUFBTSxJQUFoQztBQUNEOztBQUVELFVBQVNDLEtBQVQsQ0FBZ0JELENBQWhCLEVBQW1CO0FBQ2pCLFVBQU9BLE1BQU0xSCxTQUFOLElBQW1CMEgsTUFBTSxJQUFoQztBQUNEOztBQUVELFVBQVNFLE1BQVQsQ0FBaUJGLENBQWpCLEVBQW9CO0FBQ2xCLFVBQU9BLE1BQU0sSUFBYjtBQUNEOztBQUVELFVBQVNHLE9BQVQsQ0FBa0JILENBQWxCLEVBQXFCO0FBQ25CLFVBQU9BLE1BQU0sS0FBYjtBQUNEOztBQUVEOzs7QUFHQSxVQUFTSSxXQUFULENBQXNCQyxLQUF0QixFQUE2QjtBQUMzQixVQUNFLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFDQSxPQUFPQSxLQUFQLEtBQWlCLFFBRGpCLElBRUEsT0FBT0EsS0FBUCxLQUFpQixTQUhuQjtBQUtEOztBQUVEOzs7OztBQUtBLFVBQVNDLFFBQVQsQ0FBbUI1SSxHQUFuQixFQUF3QjtBQUN0QixVQUFPQSxRQUFRLElBQVIsSUFBZ0IsUUFBT0EsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQXRDO0FBQ0Q7O0FBRUQsS0FBSTZJLFlBQVlqQixPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpDOztBQUVBOzs7O0FBSUEsVUFBU0MsYUFBVCxDQUF3Qi9JLEdBQXhCLEVBQTZCO0FBQzNCLFVBQU82SSxVQUFVdkksSUFBVixDQUFlTixHQUFmLE1BQXdCLGlCQUEvQjtBQUNEOztBQUVELFVBQVNnSixRQUFULENBQW1CVixDQUFuQixFQUFzQjtBQUNwQixVQUFPTyxVQUFVdkksSUFBVixDQUFlZ0ksQ0FBZixNQUFzQixpQkFBN0I7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU1csaUJBQVQsQ0FBNEJDLEdBQTVCLEVBQWlDO0FBQy9CLE9BQUlDLElBQUlDLFdBQVdGLEdBQVgsQ0FBUjtBQUNBLFVBQU9DLEtBQUssQ0FBTCxJQUFVRSxLQUFLQyxLQUFMLENBQVdILENBQVgsTUFBa0JBLENBQTVCLElBQWlDSSxTQUFTTCxHQUFULENBQXhDO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNKLFFBQVQsQ0FBbUJJLEdBQW5CLEVBQXdCO0FBQ3RCLFVBQU9BLE9BQU8sSUFBUCxHQUNILEVBREcsR0FFSCxRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBZixHQUNFTSxLQUFLQyxTQUFMLENBQWVQLEdBQWYsRUFBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsQ0FERixHQUVFUSxPQUFPUixHQUFQLENBSk47QUFLRDs7QUFFRDs7OztBQUlBLFVBQVNTLFFBQVQsQ0FBbUJULEdBQW5CLEVBQXdCO0FBQ3RCLE9BQUlDLElBQUlDLFdBQVdGLEdBQVgsQ0FBUjtBQUNBLFVBQU9VLE1BQU1ULENBQU4sSUFBV0QsR0FBWCxHQUFpQkMsQ0FBeEI7QUFDRDs7QUFFRDs7OztBQUlBLFVBQVNVLE9BQVQsQ0FDRUMsR0FERixFQUVFQyxnQkFGRixFQUdFO0FBQ0EsT0FBSUMsTUFBTXBDLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFWO0FBQ0EsT0FBSUMsT0FBT0osSUFBSUssS0FBSixDQUFVLEdBQVYsQ0FBWDtBQUNBLFFBQUssSUFBSW5KLElBQUksQ0FBYixFQUFnQkEsSUFBSWtKLEtBQUtqSixNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDcENnSixTQUFJRSxLQUFLbEosQ0FBTCxDQUFKLElBQWUsSUFBZjtBQUNEO0FBQ0QsVUFBTytJLG1CQUNILFVBQVViLEdBQVYsRUFBZTtBQUFFLFlBQU9jLElBQUlkLElBQUlrQixXQUFKLEVBQUosQ0FBUDtBQUFnQyxJQUQ5QyxHQUVILFVBQVVsQixHQUFWLEVBQWU7QUFBRSxZQUFPYyxJQUFJZCxHQUFKLENBQVA7QUFBa0IsSUFGdkM7QUFHRDs7QUFFRDs7O0FBR0EsS0FBSW1CLGVBQWVSLFFBQVEsZ0JBQVIsRUFBMEIsSUFBMUIsQ0FBbkI7O0FBRUE7OztBQUdBLEtBQUlTLHNCQUFzQlQsUUFBUSxpQkFBUixDQUExQjs7QUFFQTs7O0FBR0EsVUFBU1UsTUFBVCxDQUFpQkMsR0FBakIsRUFBc0JDLElBQXRCLEVBQTRCO0FBQzFCLE9BQUlELElBQUl2SixNQUFSLEVBQWdCO0FBQ2QsU0FBSStELFFBQVF3RixJQUFJOUgsT0FBSixDQUFZK0gsSUFBWixDQUFaO0FBQ0EsU0FBSXpGLFFBQVEsQ0FBQyxDQUFiLEVBQWdCO0FBQ2QsY0FBT3dGLElBQUlFLE1BQUosQ0FBVzFGLEtBQVgsRUFBa0IsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7O0FBR0EsS0FBSTJGLGlCQUFpQi9DLE9BQU92SCxTQUFQLENBQWlCc0ssY0FBdEM7QUFDQSxVQUFTQyxNQUFULENBQWlCNUssR0FBakIsRUFBc0I2SyxHQUF0QixFQUEyQjtBQUN6QixVQUFPRixlQUFlckssSUFBZixDQUFvQk4sR0FBcEIsRUFBeUI2SyxHQUF6QixDQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNDLE1BQVQsQ0FBaUJDLEVBQWpCLEVBQXFCO0FBQ25CLE9BQUlDLFFBQVFwRCxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBWjtBQUNBLFVBQVEsU0FBU2dCLFFBQVQsQ0FBbUJuQixHQUFuQixFQUF3QjtBQUM5QixTQUFJb0IsTUFBTUYsTUFBTWxCLEdBQU4sQ0FBVjtBQUNBLFlBQU9vQixRQUFRRixNQUFNbEIsR0FBTixJQUFhaUIsR0FBR2pCLEdBQUgsQ0FBckIsQ0FBUDtBQUNELElBSEQ7QUFJRDs7QUFFRDs7O0FBR0EsS0FBSXFCLGFBQWEsUUFBakI7QUFDQSxLQUFJQyxXQUFXTixPQUFPLFVBQVVoQixHQUFWLEVBQWU7QUFDbkMsVUFBT0EsSUFBSXVCLE9BQUosQ0FBWUYsVUFBWixFQUF3QixVQUFVRyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFBRSxZQUFPQSxJQUFJQSxFQUFFdkosV0FBRixFQUFKLEdBQXNCLEVBQTdCO0FBQWtDLElBQTVFLENBQVA7QUFDRCxFQUZjLENBQWY7O0FBSUE7OztBQUdBLEtBQUl3SixhQUFhVixPQUFPLFVBQVVoQixHQUFWLEVBQWU7QUFDckMsVUFBT0EsSUFBSTJCLE1BQUosQ0FBVyxDQUFYLEVBQWN6SixXQUFkLEtBQThCOEgsSUFBSWxILEtBQUosQ0FBVSxDQUFWLENBQXJDO0FBQ0QsRUFGZ0IsQ0FBakI7O0FBSUE7OztBQUdBLEtBQUk4SSxjQUFjLGdCQUFsQjtBQUNBLEtBQUlDLFlBQVliLE9BQU8sVUFBVWhCLEdBQVYsRUFBZTtBQUNwQyxVQUFPQSxJQUNKdUIsT0FESSxDQUNJSyxXQURKLEVBQ2lCLE9BRGpCLEVBRUpMLE9BRkksQ0FFSUssV0FGSixFQUVpQixPQUZqQixFQUdKdEIsV0FISSxFQUFQO0FBSUQsRUFMZSxDQUFoQjs7QUFPQTs7O0FBR0EsVUFBU2pLLElBQVQsQ0FBZTRLLEVBQWYsRUFBbUJhLEdBQW5CLEVBQXdCO0FBQ3RCLFlBQVNDLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFNBQUlDLElBQUl0TCxVQUFVUSxNQUFsQjtBQUNBLFlBQU84SyxJQUNIQSxJQUFJLENBQUosR0FDRWhCLEdBQUd2SyxLQUFILENBQVNvTCxHQUFULEVBQWNuTCxTQUFkLENBREYsR0FFRXNLLEdBQUd6SyxJQUFILENBQVFzTCxHQUFSLEVBQWFFLENBQWIsQ0FIQyxHQUlIZixHQUFHekssSUFBSCxDQUFRc0wsR0FBUixDQUpKO0FBS0Q7QUFDRDtBQUNBQyxXQUFRRyxPQUFSLEdBQWtCakIsR0FBRzlKLE1BQXJCO0FBQ0EsVUFBTzRLLE9BQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU0ksT0FBVCxDQUFrQi9CLElBQWxCLEVBQXdCZ0MsS0FBeEIsRUFBK0I7QUFDN0JBLFdBQVFBLFNBQVMsQ0FBakI7QUFDQSxPQUFJbEwsSUFBSWtKLEtBQUtqSixNQUFMLEdBQWNpTCxLQUF0QjtBQUNBLE9BQUlDLE1BQU0sSUFBSUMsS0FBSixDQUFVcEwsQ0FBVixDQUFWO0FBQ0EsVUFBT0EsR0FBUCxFQUFZO0FBQ1ZtTCxTQUFJbkwsQ0FBSixJQUFTa0osS0FBS2xKLElBQUlrTCxLQUFULENBQVQ7QUFDRDtBQUNELFVBQU9DLEdBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU0UsTUFBVCxDQUFpQkMsRUFBakIsRUFBcUJDLEtBQXJCLEVBQTRCO0FBQzFCLFFBQUssSUFBSTFCLEdBQVQsSUFBZ0IwQixLQUFoQixFQUF1QjtBQUNyQkQsUUFBR3pCLEdBQUgsSUFBVTBCLE1BQU0xQixHQUFOLENBQVY7QUFDRDtBQUNELFVBQU95QixFQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNFLFFBQVQsQ0FBbUJoQyxHQUFuQixFQUF3QjtBQUN0QixPQUFJMUUsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJOUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd0osSUFBSXZKLE1BQXhCLEVBQWdDRCxHQUFoQyxFQUFxQztBQUNuQyxTQUFJd0osSUFBSXhKLENBQUosQ0FBSixFQUFZO0FBQ1ZxTCxjQUFPdkcsR0FBUCxFQUFZMEUsSUFBSXhKLENBQUosQ0FBWjtBQUNEO0FBQ0Y7QUFDRCxVQUFPOEUsR0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFVBQVNsRyxJQUFULENBQWVrTSxDQUFmLEVBQWtCVyxDQUFsQixFQUFxQmxCLENBQXJCLEVBQXdCLENBQUU7O0FBRTFCOzs7QUFHQSxLQUFJbUIsS0FBSyxTQUFMQSxFQUFLLENBQVVaLENBQVYsRUFBYVcsQ0FBYixFQUFnQmxCLENBQWhCLEVBQW1CO0FBQUUsVUFBTyxLQUFQO0FBQWUsRUFBN0M7O0FBRUE7OztBQUdBLEtBQUlvQixXQUFXLFNBQVhBLFFBQVcsQ0FBVXJCLENBQVYsRUFBYTtBQUFFLFVBQU9BLENBQVA7QUFBVyxFQUF6Qzs7QUFFQTs7O0FBR0EsVUFBU3NCLGFBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDO0FBQy9CLFVBQU9BLFFBQVFDLE1BQVIsQ0FBZSxVQUFVakYsSUFBVixFQUFnQmtGLENBQWhCLEVBQW1CO0FBQ3ZDLFlBQU9sRixLQUFLbUYsTUFBTCxDQUFZRCxFQUFFRSxVQUFGLElBQWdCLEVBQTVCLENBQVA7QUFDRCxJQUZNLEVBRUosRUFGSSxFQUVBQyxJQUZBLENBRUssR0FGTCxDQUFQO0FBR0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTQyxVQUFULENBQXFCckIsQ0FBckIsRUFBd0JXLENBQXhCLEVBQTJCO0FBQ3pCLE9BQUlYLE1BQU1XLENBQVYsRUFBYTtBQUFFLFlBQU8sSUFBUDtBQUFhO0FBQzVCLE9BQUlXLFlBQVl4RSxTQUFTa0QsQ0FBVCxDQUFoQjtBQUNBLE9BQUl1QixZQUFZekUsU0FBUzZELENBQVQsQ0FBaEI7QUFDQSxPQUFJVyxhQUFhQyxTQUFqQixFQUE0QjtBQUMxQixTQUFJO0FBQ0YsV0FBSUMsV0FBV2xCLE1BQU1tQixPQUFOLENBQWN6QixDQUFkLENBQWY7QUFDQSxXQUFJMEIsV0FBV3BCLE1BQU1tQixPQUFOLENBQWNkLENBQWQsQ0FBZjtBQUNBLFdBQUlhLFlBQVlFLFFBQWhCLEVBQTBCO0FBQ3hCLGdCQUFPMUIsRUFBRTdLLE1BQUYsS0FBYXdMLEVBQUV4TCxNQUFmLElBQXlCNkssRUFBRTJCLEtBQUYsQ0FBUSxVQUFVbE4sQ0FBVixFQUFhUyxDQUFiLEVBQWdCO0FBQ3RELGtCQUFPbU0sV0FBVzVNLENBQVgsRUFBY2tNLEVBQUV6TCxDQUFGLENBQWQsQ0FBUDtBQUNELFVBRitCLENBQWhDO0FBR0QsUUFKRCxNQUlPLElBQUksQ0FBQ3NNLFFBQUQsSUFBYSxDQUFDRSxRQUFsQixFQUE0QjtBQUNqQyxhQUFJRSxRQUFROUYsT0FBT0MsSUFBUCxDQUFZaUUsQ0FBWixDQUFaO0FBQ0EsYUFBSTZCLFFBQVEvRixPQUFPQyxJQUFQLENBQVk0RSxDQUFaLENBQVo7QUFDQSxnQkFBT2lCLE1BQU16TSxNQUFOLEtBQWlCME0sTUFBTTFNLE1BQXZCLElBQWlDeU0sTUFBTUQsS0FBTixDQUFZLFVBQVU1QyxHQUFWLEVBQWU7QUFDakUsa0JBQU9zQyxXQUFXckIsRUFBRWpCLEdBQUYsQ0FBWCxFQUFtQjRCLEVBQUU1QixHQUFGLENBQW5CLENBQVA7QUFDRCxVQUZ1QyxDQUF4QztBQUdELFFBTk0sTUFNQTtBQUNMO0FBQ0EsZ0JBQU8sS0FBUDtBQUNEO0FBQ0YsTUFqQkQsQ0FpQkUsT0FBT3RLLENBQVAsRUFBVTtBQUNWO0FBQ0EsY0FBTyxLQUFQO0FBQ0Q7QUFDRixJQXRCRCxNQXNCTyxJQUFJLENBQUM2TSxTQUFELElBQWMsQ0FBQ0MsU0FBbkIsRUFBOEI7QUFDbkMsWUFBTzNELE9BQU9vQyxDQUFQLE1BQWNwQyxPQUFPK0MsQ0FBUCxDQUFyQjtBQUNELElBRk0sTUFFQTtBQUNMLFlBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsVUFBU21CLFlBQVQsQ0FBdUJwRCxHQUF2QixFQUE0QnRCLEdBQTVCLEVBQWlDO0FBQy9CLFFBQUssSUFBSWxJLElBQUksQ0FBYixFQUFnQkEsSUFBSXdKLElBQUl2SixNQUF4QixFQUFnQ0QsR0FBaEMsRUFBcUM7QUFDbkMsU0FBSW1NLFdBQVczQyxJQUFJeEosQ0FBSixDQUFYLEVBQW1Ca0ksR0FBbkIsQ0FBSixFQUE2QjtBQUFFLGNBQU9sSSxDQUFQO0FBQVU7QUFDMUM7QUFDRCxVQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVEOzs7QUFHQSxVQUFTNk0sSUFBVCxDQUFlOUMsRUFBZixFQUFtQjtBQUNqQixPQUFJK0MsU0FBUyxLQUFiO0FBQ0EsVUFBTyxZQUFZO0FBQ2pCLFNBQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1hBLGdCQUFTLElBQVQ7QUFDQS9DLFVBQUd2SyxLQUFILENBQVMsSUFBVCxFQUFlQyxTQUFmO0FBQ0Q7QUFDRixJQUxEO0FBTUQ7O0FBRUQsS0FBSXNOLFdBQVcsc0JBQWY7O0FBRUEsS0FBSUMsY0FBYyxDQUNoQixXQURnQixFQUVoQixXQUZnQixFQUdoQixRQUhnQixDQUFsQjs7QUFNQSxLQUFJQyxrQkFBa0IsQ0FDcEIsY0FEb0IsRUFFcEIsU0FGb0IsRUFHcEIsYUFIb0IsRUFJcEIsU0FKb0IsRUFLcEIsY0FMb0IsRUFNcEIsU0FOb0IsRUFPcEIsZUFQb0IsRUFRcEIsV0FSb0IsRUFTcEIsV0FUb0IsRUFVcEIsYUFWb0IsQ0FBdEI7O0FBYUE7O0FBRUEsS0FBSUMsU0FBVTtBQUNaOzs7QUFHQUMsMEJBQXVCdkcsT0FBT3FDLE1BQVAsQ0FBYyxJQUFkLENBSlg7O0FBTVo7OztBQUdBbUUsV0FBUSxLQVRJOztBQVdaOzs7QUFHQUMsa0JBQWVDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQWQ1Qjs7QUFnQlo7OztBQUdBQyxhQUFVSCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFuQnZCOztBQXFCWjs7O0FBR0FFLGdCQUFhLEtBeEJEOztBQTBCWjs7O0FBR0FDLGlCQUFjLElBN0JGOztBQStCWjs7O0FBR0FDLGdCQUFhLElBbENEOztBQW9DWjs7O0FBR0FDLG9CQUFpQixFQXZDTDs7QUF5Q1o7OztBQUdBQyxhQUFVbEgsT0FBT3FDLE1BQVAsQ0FBYyxJQUFkLENBNUNFOztBQThDWjs7OztBQUlBOEUsa0JBQWVyQyxFQWxESDs7QUFvRFo7Ozs7QUFJQXNDLG1CQUFnQnRDLEVBeERKOztBQTBEWjs7OztBQUlBdUMscUJBQWtCdkMsRUE5RE47O0FBZ0VaOzs7QUFHQXdDLG9CQUFpQnRQLElBbkVMOztBQXFFWjs7O0FBR0F1UCx5QkFBc0J4QyxRQXhFVjs7QUEwRVo7Ozs7QUFJQXlDLGdCQUFhMUMsRUE5RUQ7O0FBZ0ZaOzs7QUFHQTJDLG9CQUFpQnBCO0FBbkZMLEVBQWQ7O0FBc0ZBOztBQUVBLEtBQUlxQixjQUFjMUgsT0FBTzJILE1BQVAsQ0FBYyxFQUFkLENBQWxCOztBQUVBOzs7QUFHQSxVQUFTQyxVQUFULENBQXFCMUYsR0FBckIsRUFBMEI7QUFDeEIsT0FBSXlCLElBQUksQ0FBQ3pCLE1BQU0sRUFBUCxFQUFXMkYsVUFBWCxDQUFzQixDQUF0QixDQUFSO0FBQ0EsVUFBT2xFLE1BQU0sSUFBTixJQUFjQSxNQUFNLElBQTNCO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNtRSxHQUFULENBQWMxUCxHQUFkLEVBQW1CNkssR0FBbkIsRUFBd0IzQixHQUF4QixFQUE2QnlHLFVBQTdCLEVBQXlDO0FBQ3ZDL0gsVUFBT2dJLGNBQVAsQ0FBc0I1UCxHQUF0QixFQUEyQjZLLEdBQTNCLEVBQWdDO0FBQzlCbEMsWUFBT08sR0FEdUI7QUFFOUJ5RyxpQkFBWSxDQUFDLENBQUNBLFVBRmdCO0FBRzlCRSxlQUFVLElBSG9CO0FBSTlCQyxtQkFBYztBQUpnQixJQUFoQztBQU1EOztBQUVEOzs7QUFHQSxLQUFJQyxTQUFTLFNBQWI7QUFDQSxVQUFTQyxTQUFULENBQW9CQyxJQUFwQixFQUEwQjtBQUN4QixPQUFJRixPQUFPRyxJQUFQLENBQVlELElBQVosQ0FBSixFQUF1QjtBQUNyQjtBQUNEO0FBQ0QsT0FBSUUsV0FBV0YsS0FBSzlGLEtBQUwsQ0FBVyxHQUFYLENBQWY7QUFDQSxVQUFPLFVBQVVuSyxHQUFWLEVBQWU7QUFDcEIsVUFBSyxJQUFJZ0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbVAsU0FBU2xQLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4QyxXQUFJLENBQUNoQixHQUFMLEVBQVU7QUFBRTtBQUFRO0FBQ3BCQSxhQUFNQSxJQUFJbVEsU0FBU25QLENBQVQsQ0FBSixDQUFOO0FBQ0Q7QUFDRCxZQUFPaEIsR0FBUDtBQUNELElBTkQ7QUFPRDs7QUFFRDs7QUFFQSxLQUFJb1EsT0FBT3hRLElBQVg7QUFDQSxLQUFJeVEsTUFBTXpRLElBQVY7QUFDQSxLQUFJMFEsc0JBQXVCLElBQTNCLEMsQ0FBa0M7O0FBRWxDLEtBQUloQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsT0FBSStCLGFBQWEsT0FBTzVQLE9BQVAsS0FBbUIsV0FBcEM7QUFDQSxPQUFJNlAsYUFBYSxpQkFBakI7QUFDQSxPQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVTNHLEdBQVYsRUFBZTtBQUFFLFlBQU9BLElBQ3BDdUIsT0FEb0MsQ0FDNUJtRixVQUQ0QixFQUNoQixVQUFVakYsQ0FBVixFQUFhO0FBQUUsY0FBT0EsRUFBRXZKLFdBQUYsRUFBUDtBQUF5QixNQUR4QixFQUVwQ3FKLE9BRm9DLENBRTVCLE9BRjRCLEVBRW5CLEVBRm1CLENBQVA7QUFFTixJQUYxQjs7QUFJQStFLFVBQU8sY0FBVU0sR0FBVixFQUFlQyxFQUFmLEVBQW1CO0FBQ3hCLFNBQUlsSyxRQUFRa0ssS0FBS0MsdUJBQXVCRCxFQUF2QixDQUFMLEdBQWtDLEVBQTlDOztBQUVBLFNBQUl6QyxPQUFPVSxXQUFYLEVBQXdCO0FBQ3RCVixjQUFPVSxXQUFQLENBQW1CdE8sSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJvUSxHQUE5QixFQUFtQ0MsRUFBbkMsRUFBdUNsSyxLQUF2QztBQUNELE1BRkQsTUFFTyxJQUFJOEosY0FBZSxDQUFDckMsT0FBT0UsTUFBM0IsRUFBb0M7QUFDekN6TixlQUFRbUcsS0FBUixDQUFlLGlCQUFpQjRKLEdBQWpCLEdBQXVCakssS0FBdEM7QUFDRDtBQUNGLElBUkQ7O0FBVUE0SixTQUFNLGFBQVVLLEdBQVYsRUFBZUMsRUFBZixFQUFtQjtBQUN2QixTQUFJSixjQUFlLENBQUNyQyxPQUFPRSxNQUEzQixFQUFvQztBQUNsQ3pOLGVBQVF5UCxJQUFSLENBQWEsZ0JBQWdCTSxHQUFoQixJQUNYQyxLQUFLQyx1QkFBdUJELEVBQXZCLENBQUwsR0FBa0MsRUFEdkIsQ0FBYjtBQUdEO0FBQ0YsSUFORDs7QUFRQUwseUJBQXNCLDZCQUFVSyxFQUFWLEVBQWNFLFdBQWQsRUFBMkI7QUFDL0MsU0FBSUYsR0FBR0csS0FBSCxLQUFhSCxFQUFqQixFQUFxQjtBQUNuQixjQUFPLFFBQVA7QUFDRDtBQUNELFNBQUlwUCxPQUFPLE9BQU9vUCxFQUFQLEtBQWMsUUFBZCxHQUNQQSxFQURPLEdBRVAsT0FBT0EsRUFBUCxLQUFjLFVBQWQsSUFBNEJBLEdBQUdJLE9BQS9CLEdBQ0VKLEdBQUdJLE9BQUgsQ0FBV3hQLElBRGIsR0FFRW9QLEdBQUdLLE1BQUgsR0FDRUwsR0FBR00sUUFBSCxDQUFZMVAsSUFBWixJQUFvQm9QLEdBQUdNLFFBQUgsQ0FBWUMsYUFEbEMsR0FFRVAsR0FBR3BQLElBTlg7O0FBUUEsU0FBSTRQLE9BQU9SLEdBQUdLLE1BQUgsSUFBYUwsR0FBR00sUUFBSCxDQUFZRyxNQUFwQztBQUNBLFNBQUksQ0FBQzdQLElBQUQsSUFBUzRQLElBQWIsRUFBbUI7QUFDakIsV0FBSUUsUUFBUUYsS0FBS0UsS0FBTCxDQUFXLGlCQUFYLENBQVo7QUFDQTlQLGNBQU84UCxTQUFTQSxNQUFNLENBQU4sQ0FBaEI7QUFDRDs7QUFFRCxZQUNFLENBQUM5UCxPQUFRLE1BQU9rUCxTQUFTbFAsSUFBVCxDQUFQLEdBQXlCLEdBQWpDLEdBQXdDLGFBQXpDLEtBQ0M0UCxRQUFRTixnQkFBZ0IsS0FBeEIsR0FBaUMsU0FBU00sSUFBMUMsR0FBa0QsRUFEbkQsQ0FERjtBQUlELElBdEJEOztBQXdCQSxPQUFJRyxTQUFTLFNBQVRBLE1BQVMsQ0FBVXhILEdBQVYsRUFBZVgsQ0FBZixFQUFrQjtBQUM3QixTQUFJckQsTUFBTSxFQUFWO0FBQ0EsWUFBT3FELENBQVAsRUFBVTtBQUNSLFdBQUlBLElBQUksQ0FBSixLQUFVLENBQWQsRUFBaUI7QUFBRXJELGdCQUFPZ0UsR0FBUDtBQUFhO0FBQ2hDLFdBQUlYLElBQUksQ0FBUixFQUFXO0FBQUVXLGdCQUFPQSxHQUFQO0FBQWE7QUFDMUJYLGFBQU0sQ0FBTjtBQUNEO0FBQ0QsWUFBT3JELEdBQVA7QUFDRCxJQVJEOztBQVVBLE9BQUk4Syx5QkFBeUIsU0FBekJBLHNCQUF5QixDQUFVRCxFQUFWLEVBQWM7QUFDekMsU0FBSUEsR0FBR0ssTUFBSCxJQUFhTCxHQUFHWSxPQUFwQixFQUE2QjtBQUMzQixXQUFJQyxPQUFPLEVBQVg7QUFDQSxXQUFJQywyQkFBMkIsQ0FBL0I7QUFDQSxjQUFPZCxFQUFQLEVBQVc7QUFDVCxhQUFJYSxLQUFLdlEsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ25CLGVBQUl5USxPQUFPRixLQUFLQSxLQUFLdlEsTUFBTCxHQUFjLENBQW5CLENBQVg7QUFDQSxlQUFJeVEsS0FBS0MsV0FBTCxLQUFxQmhCLEdBQUdnQixXQUE1QixFQUF5QztBQUN2Q0Y7QUFDQWQsa0JBQUtBLEdBQUdZLE9BQVI7QUFDQTtBQUNELFlBSkQsTUFJTyxJQUFJRSwyQkFBMkIsQ0FBL0IsRUFBa0M7QUFDdkNELGtCQUFLQSxLQUFLdlEsTUFBTCxHQUFjLENBQW5CLElBQXdCLENBQUN5USxJQUFELEVBQU9ELHdCQUFQLENBQXhCO0FBQ0FBLHdDQUEyQixDQUEzQjtBQUNEO0FBQ0Y7QUFDREQsY0FBS0ksSUFBTCxDQUFVakIsRUFBVjtBQUNBQSxjQUFLQSxHQUFHWSxPQUFSO0FBQ0Q7QUFDRCxjQUFPLHFCQUFxQkMsS0FDekJ4SCxHQUR5QixDQUNyQixVQUFVMkcsRUFBVixFQUFjM1AsQ0FBZCxFQUFpQjtBQUFFLGdCQUFRLE1BQU1BLE1BQU0sQ0FBTixHQUFVLE9BQVYsR0FBb0JzUSxPQUFPLEdBQVAsRUFBWSxJQUFJdFEsSUFBSSxDQUFwQixDQUExQixLQUFxRG9MLE1BQU1tQixPQUFOLENBQWNvRCxFQUFkLElBQzdFTCxvQkFBb0JLLEdBQUcsQ0FBSCxDQUFwQixDQUFELEdBQStCLE9BQS9CLEdBQTBDQSxHQUFHLENBQUgsQ0FBMUMsR0FBbUQsbUJBRDJCLEdBRS9FTCxvQkFBb0JLLEVBQXBCLENBRjBCLENBQVI7QUFFVSxRQUhSLEVBSXpCekQsSUFKeUIsQ0FJcEIsSUFKb0IsQ0FBNUI7QUFLRCxNQXZCRCxNQXVCTztBQUNMLGNBQVEsbUJBQW9Cb0Qsb0JBQW9CSyxFQUFwQixDQUFwQixHQUErQyxHQUF2RDtBQUNEO0FBQ0YsSUEzQkQ7QUE0QkQ7O0FBRUQ7O0FBRUEsVUFBU2tCLFdBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCbkIsRUFBM0IsRUFBK0I1SyxJQUEvQixFQUFxQztBQUNuQyxPQUFJbUksT0FBT1MsWUFBWCxFQUF5QjtBQUN2QlQsWUFBT1MsWUFBUCxDQUFvQnJPLElBQXBCLENBQXlCLElBQXpCLEVBQStCd1IsR0FBL0IsRUFBb0NuQixFQUFwQyxFQUF3QzVLLElBQXhDO0FBQ0QsSUFGRCxNQUVPO0FBQ0wsU0FBSXVJLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzRCLFlBQU0sY0FBY3JLLElBQWQsR0FBcUIsTUFBckIsR0FBK0IrTCxJQUFJaEosUUFBSixFQUEvQixHQUFpRCxJQUF2RCxFQUE4RDZILEVBQTlEO0FBQ0Q7QUFDRDtBQUNBLFNBQUlvQixhQUFhLE9BQU9wUixPQUFQLEtBQW1CLFdBQXBDLEVBQWlEO0FBQy9DQSxlQUFRbUcsS0FBUixDQUFjZ0wsR0FBZDtBQUNELE1BRkQsTUFFTztBQUNMLGFBQU1BLEdBQU47QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLEtBQUlFLFdBQVcsZUFBZSxFQUE5Qjs7QUFFQTtBQUNBLEtBQUlELFlBQVksT0FBTzlQLE1BQVAsS0FBa0IsV0FBbEM7QUFDQSxLQUFJZ1EsS0FBS0YsYUFBYTlQLE9BQU9pUSxTQUFQLENBQWlCQyxTQUFqQixDQUEyQi9ILFdBQTNCLEVBQXRCO0FBQ0EsS0FBSWdJLE9BQU9ILE1BQU0sZUFBZS9CLElBQWYsQ0FBb0IrQixFQUFwQixDQUFqQjtBQUNBLEtBQUlJLFFBQVFKLE1BQU1BLEdBQUd2UCxPQUFILENBQVcsVUFBWCxJQUF5QixDQUEzQztBQUNBLEtBQUk0UCxTQUFTTCxNQUFNQSxHQUFHdlAsT0FBSCxDQUFXLE9BQVgsSUFBc0IsQ0FBekM7QUFDQSxLQUFJNlAsWUFBWU4sTUFBTUEsR0FBR3ZQLE9BQUgsQ0FBVyxTQUFYLElBQXdCLENBQTlDO0FBQ0EsS0FBSThQLFFBQVFQLE1BQU0sdUJBQXVCL0IsSUFBdkIsQ0FBNEIrQixFQUE1QixDQUFsQjtBQUNBLEtBQUlRLFdBQVdSLE1BQU0sY0FBYy9CLElBQWQsQ0FBbUIrQixFQUFuQixDQUFOLElBQWdDLENBQUNLLE1BQWhEOztBQUVBO0FBQ0EsS0FBSUksY0FBZSxFQUFELENBQUtDLEtBQXZCOztBQUVBLEtBQUlDLGtCQUFrQixLQUF0QjtBQUNBLEtBQUliLFNBQUosRUFBZTtBQUNiLE9BQUk7QUFDRixTQUFJYyxPQUFPLEVBQVg7QUFDQWpMLFlBQU9nSSxjQUFQLENBQXNCaUQsSUFBdEIsRUFBNEIsU0FBNUIsRUFBd0M7QUFDdENDLFlBQUssU0FBU0EsR0FBVCxHQUFnQjtBQUNuQjtBQUNBRiwyQkFBa0IsSUFBbEI7QUFDRDtBQUpxQyxNQUF4QyxFQUZFLENBT0c7QUFDTDNRLFlBQU84USxnQkFBUCxDQUF3QixjQUF4QixFQUF3QyxJQUF4QyxFQUE4Q0YsSUFBOUM7QUFDRCxJQVRELENBU0UsT0FBT3RTLENBQVAsRUFBVSxDQUFFO0FBQ2Y7O0FBRUQ7QUFDQTtBQUNBLEtBQUl5UyxTQUFKO0FBQ0EsS0FBSUMsb0JBQW9CLFNBQXBCQSxpQkFBb0IsR0FBWTtBQUNsQyxPQUFJRCxjQUFjcFMsU0FBbEIsRUFBNkI7QUFDM0I7QUFDQSxTQUFJLENBQUNtUixTQUFELElBQWMsT0FBT21CLE1BQVAsS0FBa0IsV0FBcEMsRUFBaUQ7QUFDL0M7QUFDQTtBQUNBRixtQkFBWUUsT0FBTyxTQUFQLEVBQWtCM0UsR0FBbEIsQ0FBc0I0RSxPQUF0QixLQUFrQyxRQUE5QztBQUNELE1BSkQsTUFJTztBQUNMSCxtQkFBWSxLQUFaO0FBQ0Q7QUFDRjtBQUNELFVBQU9BLFNBQVA7QUFDRCxFQVpEOztBQWNBO0FBQ0EsS0FBSXZFLFdBQVdzRCxhQUFhOVAsT0FBT21SLDRCQUFuQzs7QUFFQTtBQUNBLFVBQVNDLFFBQVQsQ0FBbUJDLElBQW5CLEVBQXlCO0FBQ3ZCLFVBQU8sT0FBT0EsSUFBUCxLQUFnQixVQUFoQixJQUE4QixjQUFjcEQsSUFBZCxDQUFtQm9ELEtBQUt4SyxRQUFMLEVBQW5CLENBQXJDO0FBQ0Q7O0FBRUQsS0FBSXlLLFlBQ0YsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0gsU0FBU0csTUFBVCxDQUFqQyxJQUNBLE9BQU9DLE9BQVAsS0FBbUIsV0FEbkIsSUFDa0NKLFNBQVNJLFFBQVFDLE9BQWpCLENBRnBDOztBQUlBOzs7QUFHQSxLQUFJQyxXQUFZLFlBQVk7QUFDMUIsT0FBSUMsWUFBWSxFQUFoQjtBQUNBLE9BQUlDLFVBQVUsS0FBZDtBQUNBLE9BQUlDLFNBQUo7O0FBRUEsWUFBU0MsZUFBVCxHQUE0QjtBQUMxQkYsZUFBVSxLQUFWO0FBQ0EsU0FBSUcsU0FBU0osVUFBVWhSLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBYjtBQUNBZ1IsZUFBVTNTLE1BQVYsR0FBbUIsQ0FBbkI7QUFDQSxVQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSWdULE9BQU8vUyxNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDdENnVCxjQUFPaFQsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFJLE9BQU9pVCxPQUFQLEtBQW1CLFdBQW5CLElBQWtDWixTQUFTWSxPQUFULENBQXRDLEVBQXlEO0FBQ3ZELFNBQUlDLElBQUlELFFBQVEzTSxPQUFSLEVBQVI7QUFDQSxTQUFJNk0sV0FBVyxTQUFYQSxRQUFXLENBQVVyQyxHQUFWLEVBQWU7QUFBRW5SLGVBQVFtRyxLQUFSLENBQWNnTCxHQUFkO0FBQXFCLE1BQXJEO0FBQ0FnQyxpQkFBWSxxQkFBWTtBQUN0QkksU0FBRTFOLElBQUYsQ0FBT3VOLGVBQVAsRUFBd0JsTixLQUF4QixDQUE4QnNOLFFBQTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUkzQixLQUFKLEVBQVc7QUFBRTRCLG9CQUFXeFUsSUFBWDtBQUFtQjtBQUNqQyxNQVJEO0FBU0QsSUFaRCxNQVlPLElBQUksT0FBT3lVLGdCQUFQLEtBQTRCLFdBQTVCLEtBQ1RoQixTQUFTZ0IsZ0JBQVQ7QUFDQTtBQUNBQSxvQkFBaUJ2TCxRQUFqQixPQUFnQyxzQ0FIdkIsQ0FBSixFQUlKO0FBQ0Q7QUFDQTtBQUNBLFNBQUl3TCxVQUFVLENBQWQ7QUFDQSxTQUFJQyxXQUFXLElBQUlGLGdCQUFKLENBQXFCTixlQUFyQixDQUFmO0FBQ0EsU0FBSVMsV0FBV3BTLFNBQVNxUyxjQUFULENBQXdCL0ssT0FBTzRLLE9BQVAsQ0FBeEIsQ0FBZjtBQUNBQyxjQUFTRyxPQUFULENBQWlCRixRQUFqQixFQUEyQjtBQUN6Qkcsc0JBQWU7QUFEVSxNQUEzQjtBQUdBYixpQkFBWSxxQkFBWTtBQUN0QlEsaUJBQVUsQ0FBQ0EsVUFBVSxDQUFYLElBQWdCLENBQTFCO0FBQ0FFLGdCQUFTak8sSUFBVCxHQUFnQm1ELE9BQU80SyxPQUFQLENBQWhCO0FBQ0QsTUFIRDtBQUlELElBakJNLE1BaUJBO0FBQ0w7QUFDQTtBQUNBUixpQkFBWSxxQkFBWTtBQUN0Qk0sa0JBQVdMLGVBQVgsRUFBNEIsQ0FBNUI7QUFDRCxNQUZEO0FBR0Q7O0FBRUQsVUFBTyxTQUFTYSxhQUFULENBQXdCQyxFQUF4QixFQUE0QmpKLEdBQTVCLEVBQWlDO0FBQ3RDLFNBQUlrSixRQUFKO0FBQ0FsQixlQUFVaEMsSUFBVixDQUFlLFlBQVk7QUFDekIsV0FBSWlELEVBQUosRUFBUTtBQUNOLGFBQUk7QUFDRkEsY0FBR3ZVLElBQUgsQ0FBUXNMLEdBQVI7QUFDRCxVQUZELENBRUUsT0FBT3JMLENBQVAsRUFBVTtBQUNWc1IsdUJBQVl0UixDQUFaLEVBQWVxTCxHQUFmLEVBQW9CLFVBQXBCO0FBQ0Q7QUFDRixRQU5ELE1BTU8sSUFBSWtKLFFBQUosRUFBYztBQUNuQkEsa0JBQVNsSixHQUFUO0FBQ0Q7QUFDRixNQVZEO0FBV0EsU0FBSSxDQUFDaUksT0FBTCxFQUFjO0FBQ1pBLGlCQUFVLElBQVY7QUFDQUM7QUFDRDtBQUNELFNBQUksQ0FBQ2UsRUFBRCxJQUFPLE9BQU9aLE9BQVAsS0FBbUIsV0FBOUIsRUFBMkM7QUFDekMsY0FBTyxJQUFJQSxPQUFKLENBQVksVUFBVTNNLE9BQVYsRUFBbUJFLE1BQW5CLEVBQTJCO0FBQzVDc04sb0JBQVd4TixPQUFYO0FBQ0QsUUFGTSxDQUFQO0FBR0Q7QUFDRixJQXRCRDtBQXVCRCxFQWpGYyxFQUFmOztBQW1GQSxLQUFJeU4sSUFBSjtBQUNBO0FBQ0EsS0FBSSxPQUFPQyxHQUFQLEtBQWUsV0FBZixJQUE4QjNCLFNBQVMyQixHQUFULENBQWxDLEVBQWlEO0FBQy9DO0FBQ0FELFVBQU9DLEdBQVA7QUFDRCxFQUhELE1BR087QUFDTDtBQUNBRCxVQUFRLFlBQVk7QUFDbEIsY0FBU0MsR0FBVCxHQUFnQjtBQUNkLFlBQUtDLEdBQUwsR0FBV3JOLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFYO0FBQ0Q7QUFDRCtLLFNBQUkzVSxTQUFKLENBQWM2VSxHQUFkLEdBQW9CLFNBQVNBLEdBQVQsQ0FBY3JLLEdBQWQsRUFBbUI7QUFDckMsY0FBTyxLQUFLb0ssR0FBTCxDQUFTcEssR0FBVCxNQUFrQixJQUF6QjtBQUNELE1BRkQ7QUFHQW1LLFNBQUkzVSxTQUFKLENBQWM4VSxHQUFkLEdBQW9CLFNBQVNBLEdBQVQsQ0FBY3RLLEdBQWQsRUFBbUI7QUFDckMsWUFBS29LLEdBQUwsQ0FBU3BLLEdBQVQsSUFBZ0IsSUFBaEI7QUFDRCxNQUZEO0FBR0FtSyxTQUFJM1UsU0FBSixDQUFjK1UsS0FBZCxHQUFzQixTQUFTQSxLQUFULEdBQWtCO0FBQ3RDLFlBQUtILEdBQUwsR0FBV3JOLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFYO0FBQ0QsTUFGRDs7QUFJQSxZQUFPK0ssR0FBUDtBQUNELElBZk8sRUFBUjtBQWdCRDs7QUFFRDs7QUFHQSxLQUFJSyxNQUFNLENBQVY7O0FBRUE7Ozs7QUFJQSxLQUFJQyxNQUFNLFNBQVNBLEdBQVQsR0FBZ0I7QUFDeEIsUUFBSzFQLEVBQUwsR0FBVXlQLEtBQVY7QUFDQSxRQUFLRSxJQUFMLEdBQVksRUFBWjtBQUNELEVBSEQ7O0FBS0FELEtBQUlqVixTQUFKLENBQWNtVixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQzNDLFFBQUtGLElBQUwsQ0FBVTNELElBQVYsQ0FBZTZELEdBQWY7QUFDRCxFQUZEOztBQUlBSCxLQUFJalYsU0FBSixDQUFjcVYsU0FBZCxHQUEwQixTQUFTQSxTQUFULENBQW9CRCxHQUFwQixFQUF5QjtBQUNqRGxMLFVBQU8sS0FBS2dMLElBQVosRUFBa0JFLEdBQWxCO0FBQ0QsRUFGRDs7QUFJQUgsS0FBSWpWLFNBQUosQ0FBY3NWLE1BQWQsR0FBdUIsU0FBU0EsTUFBVCxHQUFtQjtBQUN4QyxPQUFJTCxJQUFJTSxNQUFSLEVBQWdCO0FBQ2ROLFNBQUlNLE1BQUosQ0FBV0MsTUFBWCxDQUFrQixJQUFsQjtBQUNEO0FBQ0YsRUFKRDs7QUFNQVAsS0FBSWpWLFNBQUosQ0FBY3lWLE1BQWQsR0FBdUIsU0FBU0EsTUFBVCxHQUFtQjtBQUN4QztBQUNBLE9BQUlQLE9BQU8sS0FBS0EsSUFBTCxDQUFVM1MsS0FBVixFQUFYO0FBQ0EsUUFBSyxJQUFJNUIsSUFBSSxDQUFSLEVBQVcrSyxJQUFJd0osS0FBS3RVLE1BQXpCLEVBQWlDRCxJQUFJK0ssQ0FBckMsRUFBd0MvSyxHQUF4QyxFQUE2QztBQUMzQ3VVLFVBQUt2VSxDQUFMLEVBQVErVSxNQUFSO0FBQ0Q7QUFDRixFQU5EOztBQVFBO0FBQ0E7QUFDQTtBQUNBVCxLQUFJTSxNQUFKLEdBQWEsSUFBYjtBQUNBLEtBQUlJLGNBQWMsRUFBbEI7O0FBRUEsVUFBU0MsVUFBVCxDQUFxQkMsT0FBckIsRUFBOEI7QUFDNUIsT0FBSVosSUFBSU0sTUFBUixFQUFnQjtBQUFFSSxpQkFBWXBFLElBQVosQ0FBaUIwRCxJQUFJTSxNQUFyQjtBQUErQjtBQUNqRE4sT0FBSU0sTUFBSixHQUFhTSxPQUFiO0FBQ0Q7O0FBRUQsVUFBU0MsU0FBVCxHQUFzQjtBQUNwQmIsT0FBSU0sTUFBSixHQUFhSSxZQUFZSSxHQUFaLEVBQWI7QUFDRDs7QUFFRDs7Ozs7QUFLQSxLQUFJQyxhQUFhakssTUFBTS9MLFNBQXZCO0FBQ0EsS0FBSWlXLGVBQWUxTyxPQUFPcUMsTUFBUCxDQUFjb00sVUFBZCxDQUFuQixDQUE2QyxDQUMzQyxNQUQyQyxFQUUzQyxLQUYyQyxFQUczQyxPQUgyQyxFQUkzQyxTQUoyQyxFQUszQyxRQUwyQyxFQU0zQyxNQU4yQyxFQU8zQyxTQVAyQyxFQVM1Q3ZPLE9BVDRDLENBU3BDLFVBQVU1SCxNQUFWLEVBQWtCO0FBQ3pCO0FBQ0EsT0FBSXFXLFdBQVdGLFdBQVduVyxNQUFYLENBQWY7QUFDQXdQLE9BQUk0RyxZQUFKLEVBQWtCcFcsTUFBbEIsRUFBMEIsU0FBU3NXLE9BQVQsR0FBb0I7QUFDNUMsU0FBSUMsT0FBTyxFQUFYO0FBQUEsU0FBZUMsTUFBTWpXLFVBQVVRLE1BQS9CO0FBQ0EsWUFBUXlWLEtBQVI7QUFBZ0JELFlBQU1DLEdBQU4sSUFBY2pXLFVBQVdpVyxHQUFYLENBQWQ7QUFBaEIsTUFFQSxJQUFJQyxTQUFTSixTQUFTL1YsS0FBVCxDQUFlLElBQWYsRUFBcUJpVyxJQUFyQixDQUFiO0FBQ0EsU0FBSUcsS0FBSyxLQUFLQyxNQUFkO0FBQ0EsU0FBSUMsUUFBSjtBQUNBLGFBQVE1VyxNQUFSO0FBQ0UsWUFBSyxNQUFMO0FBQ0EsWUFBSyxTQUFMO0FBQ0U0VyxvQkFBV0wsSUFBWDtBQUNBO0FBQ0YsWUFBSyxRQUFMO0FBQ0VLLG9CQUFXTCxLQUFLN1QsS0FBTCxDQUFXLENBQVgsQ0FBWDtBQUNBO0FBUEo7QUFTQSxTQUFJa1UsUUFBSixFQUFjO0FBQUVGLFVBQUdHLFlBQUgsQ0FBZ0JELFFBQWhCO0FBQTRCO0FBQzVDO0FBQ0FGLFFBQUdJLEdBQUgsQ0FBT2xCLE1BQVA7QUFDQSxZQUFPYSxNQUFQO0FBQ0QsSUFwQkQ7QUFxQkQsRUFqQzRDOztBQW1DN0M7O0FBRUEsS0FBSU0sWUFBWXJQLE9BQU9zUCxtQkFBUCxDQUEyQlosWUFBM0IsQ0FBaEI7O0FBRUE7Ozs7OztBQU1BLEtBQUlhLGdCQUFnQjtBQUNsQkMsa0JBQWU7QUFERyxFQUFwQjs7QUFJQTs7Ozs7O0FBTUEsS0FBSUMsV0FBVyxTQUFTQSxRQUFULENBQW1CMU8sS0FBbkIsRUFBMEI7QUFDdkMsUUFBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsUUFBS3FPLEdBQUwsR0FBVyxJQUFJMUIsR0FBSixFQUFYO0FBQ0EsUUFBS2dDLE9BQUwsR0FBZSxDQUFmO0FBQ0E1SCxPQUFJL0csS0FBSixFQUFXLFFBQVgsRUFBcUIsSUFBckI7QUFDQSxPQUFJeUQsTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixTQUFJNE8sVUFBVXZGLFdBQ1Z3RixZQURVLEdBRVZDLFdBRko7QUFHQUYsYUFBUTVPLEtBQVIsRUFBZTJOLFlBQWYsRUFBNkJXLFNBQTdCO0FBQ0EsVUFBS0YsWUFBTCxDQUFrQnBPLEtBQWxCO0FBQ0QsSUFORCxNQU1PO0FBQ0wsVUFBSytPLElBQUwsQ0FBVS9PLEtBQVY7QUFDRDtBQUNGLEVBZEQ7O0FBZ0JBOzs7OztBQUtBME8sVUFBU2hYLFNBQVQsQ0FBbUJxWCxJQUFuQixHQUEwQixTQUFTQSxJQUFULENBQWUxWCxHQUFmLEVBQW9CO0FBQzVDLE9BQUk2SCxPQUFPRCxPQUFPQyxJQUFQLENBQVk3SCxHQUFaLENBQVg7QUFDQSxRQUFLLElBQUlnQixJQUFJLENBQWIsRUFBZ0JBLElBQUk2RyxLQUFLNUcsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDMlcsdUJBQWtCM1gsR0FBbEIsRUFBdUI2SCxLQUFLN0csQ0FBTCxDQUF2QixFQUFnQ2hCLElBQUk2SCxLQUFLN0csQ0FBTCxDQUFKLENBQWhDO0FBQ0Q7QUFDRixFQUxEOztBQU9BOzs7QUFHQXFXLFVBQVNoWCxTQUFULENBQW1CMFcsWUFBbkIsR0FBa0MsU0FBU0EsWUFBVCxDQUF1QmEsS0FBdkIsRUFBOEI7QUFDOUQsUUFBSyxJQUFJNVcsSUFBSSxDQUFSLEVBQVcrSyxJQUFJNkwsTUFBTTNXLE1BQTFCLEVBQWtDRCxJQUFJK0ssQ0FBdEMsRUFBeUMvSyxHQUF6QyxFQUE4QztBQUM1QzBULGFBQVFrRCxNQUFNNVcsQ0FBTixDQUFSO0FBQ0Q7QUFDRixFQUpEOztBQU1BOztBQUVBOzs7O0FBSUEsVUFBU3dXLFlBQVQsQ0FBdUI1QixNQUF2QixFQUErQmlDLEdBQS9CLEVBQW9DaFEsSUFBcEMsRUFBMEM7QUFDeEM7QUFDQStOLFVBQU9rQyxTQUFQLEdBQW1CRCxHQUFuQjtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTtBQUNBLFVBQVNKLFdBQVQsQ0FBc0I3QixNQUF0QixFQUE4QmlDLEdBQTlCLEVBQW1DaFEsSUFBbkMsRUFBeUM7QUFDdkMsUUFBSyxJQUFJN0csSUFBSSxDQUFSLEVBQVcrSyxJQUFJbEUsS0FBSzVHLE1BQXpCLEVBQWlDRCxJQUFJK0ssQ0FBckMsRUFBd0MvSyxHQUF4QyxFQUE2QztBQUMzQyxTQUFJNkosTUFBTWhELEtBQUs3RyxDQUFMLENBQVY7QUFDQTBPLFNBQUlrRyxNQUFKLEVBQVkvSyxHQUFaLEVBQWlCZ04sSUFBSWhOLEdBQUosQ0FBakI7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFVBQVM2SixPQUFULENBQWtCL0wsS0FBbEIsRUFBeUJvUCxVQUF6QixFQUFxQztBQUNuQyxPQUFJLENBQUNuUCxTQUFTRCxLQUFULENBQUwsRUFBc0I7QUFDcEI7QUFDRDtBQUNELE9BQUlpTyxFQUFKO0FBQ0EsT0FBSWhNLE9BQU9qQyxLQUFQLEVBQWMsUUFBZCxLQUEyQkEsTUFBTWtPLE1BQU4sWUFBd0JRLFFBQXZELEVBQWlFO0FBQy9EVCxVQUFLak8sTUFBTWtPLE1BQVg7QUFDRCxJQUZELE1BRU8sSUFDTE0sY0FBY0MsYUFBZCxJQUNBLENBQUNuRSxtQkFERCxLQUVDN0csTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsS0FBd0JJLGNBQWNKLEtBQWQsQ0FGekIsS0FHQWYsT0FBT29RLFlBQVAsQ0FBb0JyUCxLQUFwQixDQUhBLElBSUEsQ0FBQ0EsTUFBTXFJLE1BTEYsRUFNTDtBQUNBNEYsVUFBSyxJQUFJUyxRQUFKLENBQWExTyxLQUFiLENBQUw7QUFDRDtBQUNELE9BQUlvUCxjQUFjbkIsRUFBbEIsRUFBc0I7QUFDcEJBLFFBQUdVLE9BQUg7QUFDRDtBQUNELFVBQU9WLEVBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU2UsaUJBQVQsQ0FDRTNYLEdBREYsRUFFRTZLLEdBRkYsRUFHRTNCLEdBSEYsRUFJRStPLFlBSkYsRUFLRUMsT0FMRixFQU1FO0FBQ0EsT0FBSWxCLE1BQU0sSUFBSTFCLEdBQUosRUFBVjs7QUFFQSxPQUFJNkMsV0FBV3ZRLE9BQU93USx3QkFBUCxDQUFnQ3BZLEdBQWhDLEVBQXFDNkssR0FBckMsQ0FBZjtBQUNBLE9BQUlzTixZQUFZQSxTQUFTckksWUFBVCxLQUEwQixLQUExQyxFQUFpRDtBQUMvQztBQUNEOztBQUVEO0FBQ0EsT0FBSXVJLFNBQVNGLFlBQVlBLFNBQVNyRixHQUFsQztBQUNBLE9BQUl3RixTQUFTSCxZQUFZQSxTQUFTbEQsR0FBbEM7O0FBRUEsT0FBSXNELFVBQVUsQ0FBQ0wsT0FBRCxJQUFZeEQsUUFBUXhMLEdBQVIsQ0FBMUI7QUFDQXRCLFVBQU9nSSxjQUFQLENBQXNCNVAsR0FBdEIsRUFBMkI2SyxHQUEzQixFQUFnQztBQUM5QjhFLGlCQUFZLElBRGtCO0FBRTlCRyxtQkFBYyxJQUZnQjtBQUc5QmdELFVBQUssU0FBUzBGLGNBQVQsR0FBMkI7QUFDOUIsV0FBSTdQLFFBQVEwUCxTQUFTQSxPQUFPL1gsSUFBUCxDQUFZTixHQUFaLENBQVQsR0FBNEJrSixHQUF4QztBQUNBLFdBQUlvTSxJQUFJTSxNQUFSLEVBQWdCO0FBQ2RvQixhQUFJckIsTUFBSjtBQUNBLGFBQUk0QyxPQUFKLEVBQWE7QUFDWEEsbUJBQVF2QixHQUFSLENBQVlyQixNQUFaO0FBQ0Q7QUFDRCxhQUFJdkosTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBSixFQUEwQjtBQUN4QjhQLHVCQUFZOVAsS0FBWjtBQUNEO0FBQ0Y7QUFDRCxjQUFPQSxLQUFQO0FBQ0QsTUFmNkI7QUFnQjlCc00sVUFBSyxTQUFTeUQsY0FBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDcEMsV0FBSWhRLFFBQVEwUCxTQUFTQSxPQUFPL1gsSUFBUCxDQUFZTixHQUFaLENBQVQsR0FBNEJrSixHQUF4QztBQUNBO0FBQ0EsV0FBSXlQLFdBQVdoUSxLQUFYLElBQXFCZ1EsV0FBV0EsTUFBWCxJQUFxQmhRLFVBQVVBLEtBQXhELEVBQWdFO0FBQzlEO0FBQ0Q7QUFDRDtBQUNBLFdBQUkyRixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUN5SixZQUE3QyxFQUEyRDtBQUN6REE7QUFDRDtBQUNELFdBQUlLLE1BQUosRUFBWTtBQUNWQSxnQkFBT2hZLElBQVAsQ0FBWU4sR0FBWixFQUFpQjJZLE1BQWpCO0FBQ0QsUUFGRCxNQUVPO0FBQ0x6UCxlQUFNeVAsTUFBTjtBQUNEO0FBQ0RKLGlCQUFVLENBQUNMLE9BQUQsSUFBWXhELFFBQVFpRSxNQUFSLENBQXRCO0FBQ0EzQixXQUFJbEIsTUFBSjtBQUNEO0FBakM2QixJQUFoQztBQW1DRDs7QUFFRDs7Ozs7QUFLQSxVQUFTYixHQUFULENBQWNXLE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQjNCLEdBQTNCLEVBQWdDO0FBQzlCLE9BQUlrRCxNQUFNbUIsT0FBTixDQUFjcUksTUFBZCxLQUF5QjNNLGtCQUFrQjRCLEdBQWxCLENBQTdCLEVBQXFEO0FBQ25EK0ssWUFBTzNVLE1BQVAsR0FBZ0JvSSxLQUFLdVAsR0FBTCxDQUFTaEQsT0FBTzNVLE1BQWhCLEVBQXdCNEosR0FBeEIsQ0FBaEI7QUFDQStLLFlBQU9sTCxNQUFQLENBQWNHLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0IzQixHQUF0QjtBQUNBLFlBQU9BLEdBQVA7QUFDRDtBQUNELE9BQUkwQixPQUFPZ0wsTUFBUCxFQUFlL0ssR0FBZixDQUFKLEVBQXlCO0FBQ3ZCK0ssWUFBTy9LLEdBQVAsSUFBYzNCLEdBQWQ7QUFDQSxZQUFPQSxHQUFQO0FBQ0Q7QUFDRCxPQUFJME4sS0FBTWhCLE1BQUQsQ0FBU2lCLE1BQWxCO0FBQ0EsT0FBSWpCLE9BQU81RSxNQUFQLElBQWtCNEYsTUFBTUEsR0FBR1UsT0FBL0IsRUFBeUM7QUFDdkNoSixhQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2QywwRUFDQSxxREFGdUMsQ0FBekM7QUFJQSxZQUFPbEgsR0FBUDtBQUNEO0FBQ0QsT0FBSSxDQUFDME4sRUFBTCxFQUFTO0FBQ1BoQixZQUFPL0ssR0FBUCxJQUFjM0IsR0FBZDtBQUNBLFlBQU9BLEdBQVA7QUFDRDtBQUNEeU8scUJBQWtCZixHQUFHak8sS0FBckIsRUFBNEJrQyxHQUE1QixFQUFpQzNCLEdBQWpDO0FBQ0EwTixNQUFHSSxHQUFILENBQU9sQixNQUFQO0FBQ0EsVUFBTzVNLEdBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBUzJQLEdBQVQsQ0FBY2pELE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQjtBQUN6QixPQUFJdUIsTUFBTW1CLE9BQU4sQ0FBY3FJLE1BQWQsS0FBeUIzTSxrQkFBa0I0QixHQUFsQixDQUE3QixFQUFxRDtBQUNuRCtLLFlBQU9sTCxNQUFQLENBQWNHLEdBQWQsRUFBbUIsQ0FBbkI7QUFDQTtBQUNEO0FBQ0QsT0FBSStMLEtBQU1oQixNQUFELENBQVNpQixNQUFsQjtBQUNBLE9BQUlqQixPQUFPNUUsTUFBUCxJQUFrQjRGLE1BQU1BLEdBQUdVLE9BQS9CLEVBQXlDO0FBQ3ZDaEosYUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsbUVBQ0Esd0JBRnVDLENBQXpDO0FBSUE7QUFDRDtBQUNELE9BQUksQ0FBQ3hGLE9BQU9nTCxNQUFQLEVBQWUvSyxHQUFmLENBQUwsRUFBMEI7QUFDeEI7QUFDRDtBQUNELFVBQU8rSyxPQUFPL0ssR0FBUCxDQUFQO0FBQ0EsT0FBSSxDQUFDK0wsRUFBTCxFQUFTO0FBQ1A7QUFDRDtBQUNEQSxNQUFHSSxHQUFILENBQU9sQixNQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTMkMsV0FBVCxDQUFzQjlQLEtBQXRCLEVBQTZCO0FBQzNCLFFBQUssSUFBSXBJLElBQUssS0FBSyxDQUFkLEVBQWtCUyxJQUFJLENBQXRCLEVBQXlCK0ssSUFBSXBELE1BQU0xSCxNQUF4QyxFQUFnREQsSUFBSStLLENBQXBELEVBQXVEL0ssR0FBdkQsRUFBNEQ7QUFDMURULFNBQUlvSSxNQUFNM0gsQ0FBTixDQUFKO0FBQ0FULFVBQUtBLEVBQUVzVyxNQUFQLElBQWlCdFcsRUFBRXNXLE1BQUYsQ0FBU0csR0FBVCxDQUFhckIsTUFBYixFQUFqQjtBQUNBLFNBQUl2SixNQUFNbUIsT0FBTixDQUFjaE4sQ0FBZCxDQUFKLEVBQXNCO0FBQ3BCa1ksbUJBQVlsWSxDQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBOzs7OztBQUtBLEtBQUl1WSxTQUFTNUssT0FBT0MscUJBQXBCOztBQUVBOzs7QUFHQSxLQUFJRyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNzSyxVQUFPQyxFQUFQLEdBQVlELE9BQU9FLFNBQVAsR0FBbUIsVUFBVUMsTUFBVixFQUFrQkMsS0FBbEIsRUFBeUJ2SSxFQUF6QixFQUE2QjlGLEdBQTdCLEVBQWtDO0FBQy9ELFNBQUksQ0FBQzhGLEVBQUwsRUFBUztBQUNQUCxZQUNFLGNBQWN2RixHQUFkLEdBQW9CLHNDQUFwQixHQUNBLGtDQUZGO0FBSUQ7QUFDRCxZQUFPc08sYUFBYUYsTUFBYixFQUFxQkMsS0FBckIsQ0FBUDtBQUNELElBUkQ7QUFTRDs7QUFFRDs7O0FBR0EsVUFBU0UsU0FBVCxDQUFvQjlNLEVBQXBCLEVBQXdCK00sSUFBeEIsRUFBOEI7QUFDNUIsT0FBSSxDQUFDQSxJQUFMLEVBQVc7QUFBRSxZQUFPL00sRUFBUDtBQUFXO0FBQ3hCLE9BQUl6QixHQUFKLEVBQVN5TyxLQUFULEVBQWdCQyxPQUFoQjtBQUNBLE9BQUkxUixPQUFPRCxPQUFPQyxJQUFQLENBQVl3UixJQUFaLENBQVg7QUFDQSxRQUFLLElBQUlyWSxJQUFJLENBQWIsRUFBZ0JBLElBQUk2RyxLQUFLNUcsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDNkosV0FBTWhELEtBQUs3RyxDQUFMLENBQU47QUFDQXNZLGFBQVFoTixHQUFHekIsR0FBSCxDQUFSO0FBQ0EwTyxlQUFVRixLQUFLeE8sR0FBTCxDQUFWO0FBQ0EsU0FBSSxDQUFDRCxPQUFPMEIsRUFBUCxFQUFXekIsR0FBWCxDQUFMLEVBQXNCO0FBQ3BCb0ssV0FBSTNJLEVBQUosRUFBUXpCLEdBQVIsRUFBYTBPLE9BQWI7QUFDRCxNQUZELE1BRU8sSUFBSXhRLGNBQWN1USxLQUFkLEtBQXdCdlEsY0FBY3dRLE9BQWQsQ0FBNUIsRUFBb0Q7QUFDekRILGlCQUFVRSxLQUFWLEVBQWlCQyxPQUFqQjtBQUNEO0FBQ0Y7QUFDRCxVQUFPak4sRUFBUDtBQUNEOztBQUVEOzs7QUFHQSxVQUFTa04sYUFBVCxDQUNFQyxTQURGLEVBRUVDLFFBRkYsRUFHRS9JLEVBSEYsRUFJRTtBQUNBLE9BQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1A7QUFDQSxTQUFJLENBQUMrSSxRQUFMLEVBQWU7QUFDYixjQUFPRCxTQUFQO0FBQ0Q7QUFDRCxTQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZCxjQUFPQyxRQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBTyxTQUFTQyxZQUFULEdBQXlCO0FBQzlCLGNBQU9QLFVBQ0wsT0FBT00sUUFBUCxLQUFvQixVQUFwQixHQUFpQ0EsU0FBU3BaLElBQVQsQ0FBYyxJQUFkLENBQWpDLEdBQXVEb1osUUFEbEQsRUFFTCxPQUFPRCxTQUFQLEtBQXFCLFVBQXJCLEdBQWtDQSxVQUFVblosSUFBVixDQUFlLElBQWYsQ0FBbEMsR0FBeURtWixTQUZwRCxDQUFQO0FBSUQsTUFMRDtBQU1ELElBbkJELE1BbUJPLElBQUlBLGFBQWFDLFFBQWpCLEVBQTJCO0FBQ2hDLFlBQU8sU0FBU0Usb0JBQVQsR0FBaUM7QUFDdEM7QUFDQSxXQUFJQyxlQUFlLE9BQU9ILFFBQVAsS0FBb0IsVUFBcEIsR0FDZkEsU0FBU3BaLElBQVQsQ0FBY3FRLEVBQWQsQ0FEZSxHQUVmK0ksUUFGSjtBQUdBLFdBQUlJLGNBQWMsT0FBT0wsU0FBUCxLQUFxQixVQUFyQixHQUNkQSxVQUFVblosSUFBVixDQUFlcVEsRUFBZixDQURjLEdBRWQvUCxTQUZKO0FBR0EsV0FBSWlaLFlBQUosRUFBa0I7QUFDaEIsZ0JBQU9ULFVBQVVTLFlBQVYsRUFBd0JDLFdBQXhCLENBQVA7QUFDRCxRQUZELE1BRU87QUFDTCxnQkFBT0EsV0FBUDtBQUNEO0FBQ0YsTUFiRDtBQWNEO0FBQ0Y7O0FBRURoQixRQUFPdlMsSUFBUCxHQUFjLFVBQ1prVCxTQURZLEVBRVpDLFFBRlksRUFHWi9JLEVBSFksRUFJWjtBQUNBLE9BQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1AsU0FBSStJLFlBQVksT0FBT0EsUUFBUCxLQUFvQixVQUFwQyxFQUFnRDtBQUM5Q3BMLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLDRDQUNBLGlEQURBLEdBRUEsY0FIdUMsRUFJdkNPLEVBSnVDLENBQXpDOztBQU9BLGNBQU84SSxTQUFQO0FBQ0Q7QUFDRCxZQUFPRCxjQUFjbFosSUFBZCxDQUFtQixJQUFuQixFQUF5Qm1aLFNBQXpCLEVBQW9DQyxRQUFwQyxDQUFQO0FBQ0Q7O0FBRUQsVUFBT0YsY0FBY0MsU0FBZCxFQUF5QkMsUUFBekIsRUFBbUMvSSxFQUFuQyxDQUFQO0FBQ0QsRUFwQkQ7O0FBc0JBOzs7QUFHQSxVQUFTb0osU0FBVCxDQUNFTixTQURGLEVBRUVDLFFBRkYsRUFHRTtBQUNBLFVBQU9BLFdBQ0hELFlBQ0VBLFVBQVV6TSxNQUFWLENBQWlCME0sUUFBakIsQ0FERixHQUVFdE4sTUFBTW1CLE9BQU4sQ0FBY21NLFFBQWQsSUFDRUEsUUFERixHQUVFLENBQUNBLFFBQUQsQ0FMRCxHQU1IRCxTQU5KO0FBT0Q7O0FBRUR4TCxpQkFBZ0JuRyxPQUFoQixDQUF3QixVQUFVa1MsSUFBVixFQUFnQjtBQUN0Q2xCLFVBQU9rQixJQUFQLElBQWVELFNBQWY7QUFDRCxFQUZEOztBQUlBOzs7Ozs7O0FBT0EsVUFBU0UsV0FBVCxDQUFzQlIsU0FBdEIsRUFBaUNDLFFBQWpDLEVBQTJDO0FBQ3pDLE9BQUk1VCxNQUFNOEIsT0FBT3FDLE1BQVAsQ0FBY3dQLGFBQWEsSUFBM0IsQ0FBVjtBQUNBLFVBQU9DLFdBQ0hyTixPQUFPdkcsR0FBUCxFQUFZNFQsUUFBWixDQURHLEdBRUg1VCxHQUZKO0FBR0Q7O0FBRURrSSxhQUFZbEcsT0FBWixDQUFvQixVQUFVb1MsSUFBVixFQUFnQjtBQUNsQ3BCLFVBQU9vQixPQUFPLEdBQWQsSUFBcUJELFdBQXJCO0FBQ0QsRUFGRDs7QUFJQTs7Ozs7O0FBTUFuQixRQUFPbkcsS0FBUCxHQUFlLFVBQVU4RyxTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtBQUM1QztBQUNBLE9BQUlELGNBQWMvRyxXQUFsQixFQUErQjtBQUFFK0csaUJBQVk3WSxTQUFaO0FBQXdCO0FBQ3pELE9BQUk4WSxhQUFhaEgsV0FBakIsRUFBOEI7QUFBRWdILGdCQUFXOVksU0FBWDtBQUF1QjtBQUN2RDtBQUNBLE9BQUksQ0FBQzhZLFFBQUwsRUFBZTtBQUFFLFlBQU85UixPQUFPcUMsTUFBUCxDQUFjd1AsYUFBYSxJQUEzQixDQUFQO0FBQXlDO0FBQzFELE9BQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUFFLFlBQU9DLFFBQVA7QUFBaUI7QUFDbkMsT0FBSXZOLE1BQU0sRUFBVjtBQUNBRSxVQUFPRixHQUFQLEVBQVlzTixTQUFaO0FBQ0EsUUFBSyxJQUFJNU8sR0FBVCxJQUFnQjZPLFFBQWhCLEVBQTBCO0FBQ3hCLFNBQUlULFNBQVM5TSxJQUFJdEIsR0FBSixDQUFiO0FBQ0EsU0FBSXFPLFFBQVFRLFNBQVM3TyxHQUFULENBQVo7QUFDQSxTQUFJb08sVUFBVSxDQUFDN00sTUFBTW1CLE9BQU4sQ0FBYzBMLE1BQWQsQ0FBZixFQUFzQztBQUNwQ0EsZ0JBQVMsQ0FBQ0EsTUFBRCxDQUFUO0FBQ0Q7QUFDRDlNLFNBQUl0QixHQUFKLElBQVdvTyxTQUNQQSxPQUFPak0sTUFBUCxDQUFja00sS0FBZCxDQURPLEdBRVA5TSxNQUFNbUIsT0FBTixDQUFjMkwsS0FBZCxJQUF1QkEsS0FBdkIsR0FBK0IsQ0FBQ0EsS0FBRCxDQUZuQztBQUdEO0FBQ0QsVUFBTy9NLEdBQVA7QUFDRCxFQXBCRDs7QUFzQkE7OztBQUdBMk0sUUFBT3FCLEtBQVAsR0FDQXJCLE9BQU9zQixPQUFQLEdBQ0F0QixPQUFPdUIsTUFBUCxHQUNBdkIsT0FBT3dCLFFBQVAsR0FBa0IsVUFBVWIsU0FBVixFQUFxQkMsUUFBckIsRUFBK0I7QUFDL0MsT0FBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQUUsWUFBT0MsUUFBUDtBQUFpQjtBQUNuQyxPQUFJdk4sTUFBTXZFLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFWO0FBQ0FvQyxVQUFPRixHQUFQLEVBQVlzTixTQUFaO0FBQ0EsT0FBSUMsUUFBSixFQUFjO0FBQUVyTixZQUFPRixHQUFQLEVBQVl1TixRQUFaO0FBQXdCO0FBQ3hDLFVBQU92TixHQUFQO0FBQ0QsRUFURDtBQVVBMk0sUUFBT3lCLE9BQVAsR0FBaUJmLGFBQWpCOztBQUVBOzs7QUFHQSxLQUFJTCxlQUFlLFNBQWZBLFlBQWUsQ0FBVU0sU0FBVixFQUFxQkMsUUFBckIsRUFBK0I7QUFDaEQsVUFBT0EsYUFBYTlZLFNBQWIsR0FDSDZZLFNBREcsR0FFSEMsUUFGSjtBQUdELEVBSkQ7O0FBTUE7OztBQUdBLFVBQVNjLGVBQVQsQ0FBMEJ6SixPQUExQixFQUFtQztBQUNqQyxRQUFLLElBQUlsRyxHQUFULElBQWdCa0csUUFBUTBKLFVBQXhCLEVBQW9DO0FBQ2xDLFNBQUlDLFFBQVE3UCxJQUFJVCxXQUFKLEVBQVo7QUFDQSxTQUFJQyxhQUFhcVEsS0FBYixLQUF1QnhNLE9BQU9hLGFBQVAsQ0FBcUIyTCxLQUFyQixDQUEzQixFQUF3RDtBQUN0RHRLLFlBQ0UsZ0VBQ0EsTUFEQSxHQUNTdkYsR0FGWDtBQUlEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVM4UCxjQUFULENBQXlCNUosT0FBekIsRUFBa0M7QUFDaEMsT0FBSW9KLFFBQVFwSixRQUFRb0osS0FBcEI7QUFDQSxPQUFJLENBQUNBLEtBQUwsRUFBWTtBQUFFO0FBQVE7QUFDdEIsT0FBSXJVLE1BQU0sRUFBVjtBQUNBLE9BQUk5RSxDQUFKLEVBQU9rSSxHQUFQLEVBQVkzSCxJQUFaO0FBQ0EsT0FBSTZLLE1BQU1tQixPQUFOLENBQWM0TSxLQUFkLENBQUosRUFBMEI7QUFDeEJuWixTQUFJbVosTUFBTWxaLE1BQVY7QUFDQSxZQUFPRCxHQUFQLEVBQVk7QUFDVmtJLGFBQU1pUixNQUFNblosQ0FBTixDQUFOO0FBQ0EsV0FBSSxPQUFPa0ksR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCM0gsZ0JBQU82SixTQUFTbEMsR0FBVCxDQUFQO0FBQ0FwRCxhQUFJdkUsSUFBSixJQUFZLEVBQUUyWSxNQUFNLElBQVIsRUFBWjtBQUNELFFBSEQsTUFHTyxJQUFJNUwsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hENEIsY0FBSyxnREFBTDtBQUNEO0FBQ0Y7QUFDRixJQVhELE1BV08sSUFBSXJILGNBQWNvUixLQUFkLENBQUosRUFBMEI7QUFDL0IsVUFBSyxJQUFJdFAsR0FBVCxJQUFnQnNQLEtBQWhCLEVBQXVCO0FBQ3JCalIsYUFBTWlSLE1BQU10UCxHQUFOLENBQU47QUFDQXRKLGNBQU82SixTQUFTUCxHQUFULENBQVA7QUFDQS9FLFdBQUl2RSxJQUFKLElBQVl3SCxjQUFjRyxHQUFkLElBQ1JBLEdBRFEsR0FFUixFQUFFZ1IsTUFBTWhSLEdBQVIsRUFGSjtBQUdEO0FBQ0Y7QUFDRDZILFdBQVFvSixLQUFSLEdBQWdCclUsR0FBaEI7QUFDRDs7QUFFRDs7O0FBR0EsVUFBUzhVLGVBQVQsQ0FBMEI3SixPQUExQixFQUFtQztBQUNqQyxPQUFJc0osU0FBU3RKLFFBQVFzSixNQUFyQjtBQUNBLE9BQUlqTyxNQUFNbUIsT0FBTixDQUFjOE0sTUFBZCxDQUFKLEVBQTJCO0FBQ3pCLFNBQUlRLGFBQWE5SixRQUFRc0osTUFBUixHQUFpQixFQUFsQztBQUNBLFVBQUssSUFBSXJaLElBQUksQ0FBYixFQUFnQkEsSUFBSXFaLE9BQU9wWixNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDdEM2WixrQkFBV1IsT0FBT3JaLENBQVAsQ0FBWCxJQUF3QnFaLE9BQU9yWixDQUFQLENBQXhCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7QUFHQSxVQUFTOFosbUJBQVQsQ0FBOEIvSixPQUE5QixFQUF1QztBQUNyQyxPQUFJZ0ssT0FBT2hLLFFBQVFpSyxVQUFuQjtBQUNBLE9BQUlELElBQUosRUFBVTtBQUNSLFVBQUssSUFBSWxRLEdBQVQsSUFBZ0JrUSxJQUFoQixFQUFzQjtBQUNwQixXQUFJckwsTUFBTXFMLEtBQUtsUSxHQUFMLENBQVY7QUFDQSxXQUFJLE9BQU82RSxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0JxTCxjQUFLbFEsR0FBTCxJQUFZLEVBQUUxSyxNQUFNdVAsR0FBUixFQUFhcUcsUUFBUXJHLEdBQXJCLEVBQVo7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVN1TCxZQUFULENBQ0VoQyxNQURGLEVBRUVDLEtBRkYsRUFHRXZJLEVBSEYsRUFJRTtBQUNBLE9BQUlyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnTSxxQkFBZ0J0QixLQUFoQjtBQUNEOztBQUVELE9BQUksT0FBT0EsS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUMvQkEsYUFBUUEsTUFBTW5JLE9BQWQ7QUFDRDs7QUFFRDRKLGtCQUFlekIsS0FBZjtBQUNBMEIsbUJBQWdCMUIsS0FBaEI7QUFDQTRCLHVCQUFvQjVCLEtBQXBCO0FBQ0EsT0FBSWdDLGNBQWNoQyxNQUFNaUMsT0FBeEI7QUFDQSxPQUFJRCxXQUFKLEVBQWlCO0FBQ2ZqQyxjQUFTZ0MsYUFBYWhDLE1BQWIsRUFBcUJpQyxXQUFyQixFQUFrQ3ZLLEVBQWxDLENBQVQ7QUFDRDtBQUNELE9BQUl1SSxNQUFNa0MsTUFBVixFQUFrQjtBQUNoQixVQUFLLElBQUlwYSxJQUFJLENBQVIsRUFBVytLLElBQUltTixNQUFNa0MsTUFBTixDQUFhbmEsTUFBakMsRUFBeUNELElBQUkrSyxDQUE3QyxFQUFnRC9LLEdBQWhELEVBQXFEO0FBQ25EaVksZ0JBQVNnQyxhQUFhaEMsTUFBYixFQUFxQkMsTUFBTWtDLE1BQU4sQ0FBYXBhLENBQWIsQ0FBckIsRUFBc0MyUCxFQUF0QyxDQUFUO0FBQ0Q7QUFDRjtBQUNELE9BQUlJLFVBQVUsRUFBZDtBQUNBLE9BQUlsRyxHQUFKO0FBQ0EsUUFBS0EsR0FBTCxJQUFZb08sTUFBWixFQUFvQjtBQUNsQm9DLGdCQUFXeFEsR0FBWDtBQUNEO0FBQ0QsUUFBS0EsR0FBTCxJQUFZcU8sS0FBWixFQUFtQjtBQUNqQixTQUFJLENBQUN0TyxPQUFPcU8sTUFBUCxFQUFlcE8sR0FBZixDQUFMLEVBQTBCO0FBQ3hCd1Esa0JBQVd4USxHQUFYO0FBQ0Q7QUFDRjtBQUNELFlBQVN3USxVQUFULENBQXFCeFEsR0FBckIsRUFBMEI7QUFDeEIsU0FBSXlRLFFBQVF4QyxPQUFPak8sR0FBUCxLQUFlc08sWUFBM0I7QUFDQXBJLGFBQVFsRyxHQUFSLElBQWV5USxNQUFNckMsT0FBT3BPLEdBQVAsQ0FBTixFQUFtQnFPLE1BQU1yTyxHQUFOLENBQW5CLEVBQStCOEYsRUFBL0IsRUFBbUM5RixHQUFuQyxDQUFmO0FBQ0Q7QUFDRCxVQUFPa0csT0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFVBQVN3SyxZQUFULENBQ0V4SyxPQURGLEVBRUVtSixJQUZGLEVBR0V0VSxFQUhGLEVBSUU0VixXQUpGLEVBS0U7QUFDQTtBQUNBLE9BQUksT0FBTzVWLEVBQVAsS0FBYyxRQUFsQixFQUE0QjtBQUMxQjtBQUNEO0FBQ0QsT0FBSTZWLFNBQVMxSyxRQUFRbUosSUFBUixDQUFiO0FBQ0E7QUFDQSxPQUFJdFAsT0FBTzZRLE1BQVAsRUFBZTdWLEVBQWYsQ0FBSixFQUF3QjtBQUFFLFlBQU82VixPQUFPN1YsRUFBUCxDQUFQO0FBQW1CO0FBQzdDLE9BQUk4VixjQUFjdFEsU0FBU3hGLEVBQVQsQ0FBbEI7QUFDQSxPQUFJZ0YsT0FBTzZRLE1BQVAsRUFBZUMsV0FBZixDQUFKLEVBQWlDO0FBQUUsWUFBT0QsT0FBT0MsV0FBUCxDQUFQO0FBQTRCO0FBQy9ELE9BQUlDLGVBQWVuUSxXQUFXa1EsV0FBWCxDQUFuQjtBQUNBLE9BQUk5USxPQUFPNlEsTUFBUCxFQUFlRSxZQUFmLENBQUosRUFBa0M7QUFBRSxZQUFPRixPQUFPRSxZQUFQLENBQVA7QUFBNkI7QUFDakU7QUFDQSxPQUFJN1YsTUFBTTJWLE9BQU83VixFQUFQLEtBQWM2VixPQUFPQyxXQUFQLENBQWQsSUFBcUNELE9BQU9FLFlBQVAsQ0FBL0M7QUFDQSxPQUFJck4sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDZ04sV0FBekMsSUFBd0QsQ0FBQzFWLEdBQTdELEVBQWtFO0FBQ2hFc0ssVUFDRSx1QkFBdUI4SixLQUFLdFgsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLENBQWYsQ0FBdkIsR0FBMkMsSUFBM0MsR0FBa0RnRCxFQURwRCxFQUVFbUwsT0FGRjtBQUlEO0FBQ0QsVUFBT2pMLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxVQUFTOFYsWUFBVCxDQUNFL1EsR0FERixFQUVFZ1IsV0FGRixFQUdFN0MsU0FIRixFQUlFckksRUFKRixFQUtFO0FBQ0EsT0FBSW1MLE9BQU9ELFlBQVloUixHQUFaLENBQVg7QUFDQSxPQUFJa1IsU0FBUyxDQUFDblIsT0FBT29PLFNBQVAsRUFBa0JuTyxHQUFsQixDQUFkO0FBQ0EsT0FBSWxDLFFBQVFxUSxVQUFVbk8sR0FBVixDQUFaO0FBQ0E7QUFDQSxPQUFJbVIsT0FBT0MsT0FBUCxFQUFnQkgsS0FBSzVCLElBQXJCLENBQUosRUFBZ0M7QUFDOUIsU0FBSTZCLFVBQVUsQ0FBQ25SLE9BQU9rUixJQUFQLEVBQWEsU0FBYixDQUFmLEVBQXdDO0FBQ3RDblQsZUFBUSxLQUFSO0FBQ0QsTUFGRCxNQUVPLElBQUksQ0FBQ3FULE9BQU90UyxNQUFQLEVBQWVvUyxLQUFLNUIsSUFBcEIsQ0FBRCxLQUErQnZSLFVBQVUsRUFBVixJQUFnQkEsVUFBVWdELFVBQVVkLEdBQVYsQ0FBekQsQ0FBSixFQUE4RTtBQUNuRmxDLGVBQVEsSUFBUjtBQUNEO0FBQ0Y7QUFDRDtBQUNBLE9BQUlBLFVBQVUvSCxTQUFkLEVBQXlCO0FBQ3ZCK0gsYUFBUXVULG9CQUFvQnZMLEVBQXBCLEVBQXdCbUwsSUFBeEIsRUFBOEJqUixHQUE5QixDQUFSO0FBQ0E7QUFDQTtBQUNBLFNBQUlzUixvQkFBb0JoRixjQUFjQyxhQUF0QztBQUNBRCxtQkFBY0MsYUFBZCxHQUE4QixJQUE5QjtBQUNBMUMsYUFBUS9MLEtBQVI7QUFDQXdPLG1CQUFjQyxhQUFkLEdBQThCK0UsaUJBQTlCO0FBQ0Q7QUFDRCxPQUFJN04sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNE4sZ0JBQVdOLElBQVgsRUFBaUJqUixHQUFqQixFQUFzQmxDLEtBQXRCLEVBQTZCZ0ksRUFBN0IsRUFBaUNvTCxNQUFqQztBQUNEO0FBQ0QsVUFBT3BULEtBQVA7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU3VULG1CQUFULENBQThCdkwsRUFBOUIsRUFBa0NtTCxJQUFsQyxFQUF3Q2pSLEdBQXhDLEVBQTZDO0FBQzNDO0FBQ0EsT0FBSSxDQUFDRCxPQUFPa1IsSUFBUCxFQUFhLFNBQWIsQ0FBTCxFQUE4QjtBQUM1QixZQUFPbGIsU0FBUDtBQUNEO0FBQ0QsT0FBSThPLE1BQU1vTSxLQUFLTyxPQUFmO0FBQ0E7QUFDQSxPQUFJL04sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNUYsU0FBUzhHLEdBQVQsQ0FBN0MsRUFBNEQ7QUFDMURVLFVBQ0UscUNBQXFDdkYsR0FBckMsR0FBMkMsS0FBM0MsR0FDQSwyREFEQSxHQUVBLDhCQUhGLEVBSUU4RixFQUpGO0FBTUQ7QUFDRDtBQUNBO0FBQ0EsT0FBSUEsTUFBTUEsR0FBR00sUUFBSCxDQUFZK0gsU0FBbEIsSUFDRnJJLEdBQUdNLFFBQUgsQ0FBWStILFNBQVosQ0FBc0JuTyxHQUF0QixNQUErQmpLLFNBRDdCLElBRUYrUCxHQUFHMkwsTUFBSCxDQUFVelIsR0FBVixNQUFtQmpLLFNBRnJCLEVBR0U7QUFDQSxZQUFPK1AsR0FBRzJMLE1BQUgsQ0FBVXpSLEdBQVYsQ0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFVBQU8sT0FBTzZFLEdBQVAsS0FBZSxVQUFmLElBQTZCNk0sUUFBUVQsS0FBSzVCLElBQWIsTUFBdUIsVUFBcEQsR0FDSHhLLElBQUlwUCxJQUFKLENBQVNxUSxFQUFULENBREcsR0FFSGpCLEdBRko7QUFHRDs7QUFFRDs7O0FBR0EsVUFBUzBNLFVBQVQsQ0FDRU4sSUFERixFQUVFdmEsSUFGRixFQUdFb0gsS0FIRixFQUlFZ0ksRUFKRixFQUtFb0wsTUFMRixFQU1FO0FBQ0EsT0FBSUQsS0FBS1UsUUFBTCxJQUFpQlQsTUFBckIsRUFBNkI7QUFDM0IzTCxVQUNFLDZCQUE2QjdPLElBQTdCLEdBQW9DLEdBRHRDLEVBRUVvUCxFQUZGO0FBSUE7QUFDRDtBQUNELE9BQUloSSxTQUFTLElBQVQsSUFBaUIsQ0FBQ21ULEtBQUtVLFFBQTNCLEVBQXFDO0FBQ25DO0FBQ0Q7QUFDRCxPQUFJdEMsT0FBTzRCLEtBQUs1QixJQUFoQjtBQUNBLE9BQUl1QyxRQUFRLENBQUN2QyxJQUFELElBQVNBLFNBQVMsSUFBOUI7QUFDQSxPQUFJd0MsZ0JBQWdCLEVBQXBCO0FBQ0EsT0FBSXhDLElBQUosRUFBVTtBQUNSLFNBQUksQ0FBQzlOLE1BQU1tQixPQUFOLENBQWMyTSxJQUFkLENBQUwsRUFBMEI7QUFDeEJBLGNBQU8sQ0FBQ0EsSUFBRCxDQUFQO0FBQ0Q7QUFDRCxVQUFLLElBQUlsWixJQUFJLENBQWIsRUFBZ0JBLElBQUlrWixLQUFLalosTUFBVCxJQUFtQixDQUFDd2IsS0FBcEMsRUFBMkN6YixHQUEzQyxFQUFnRDtBQUM5QyxXQUFJMmIsZUFBZUMsV0FBV2pVLEtBQVgsRUFBa0J1UixLQUFLbFosQ0FBTCxDQUFsQixDQUFuQjtBQUNBMGIscUJBQWM5SyxJQUFkLENBQW1CK0ssYUFBYUUsWUFBYixJQUE2QixFQUFoRDtBQUNBSixlQUFRRSxhQUFhRixLQUFyQjtBQUNEO0FBQ0Y7QUFDRCxPQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNWck0sVUFDRSwrQ0FBK0M3TyxJQUEvQyxHQUFzRCxJQUF0RCxHQUNBLFlBREEsR0FDZW1iLGNBQWMxUyxHQUFkLENBQWtCd0IsVUFBbEIsRUFBOEIwQixJQUE5QixDQUFtQyxJQUFuQyxDQURmLEdBRUEsUUFGQSxHQUVXdEYsT0FBT3ZILFNBQVAsQ0FBaUJ5SSxRQUFqQixDQUEwQnhJLElBQTFCLENBQStCcUksS0FBL0IsRUFBc0MvRixLQUF0QyxDQUE0QyxDQUE1QyxFQUErQyxDQUFDLENBQWhELENBRlgsR0FFZ0UsR0FIbEUsRUFJRStOLEVBSkY7QUFNQTtBQUNEO0FBQ0QsT0FBSW1NLFlBQVloQixLQUFLZ0IsU0FBckI7QUFDQSxPQUFJQSxTQUFKLEVBQWU7QUFDYixTQUFJLENBQUNBLFVBQVVuVSxLQUFWLENBQUwsRUFBdUI7QUFDckJ5SCxZQUNFLDJEQUEyRDdPLElBQTNELEdBQWtFLElBRHBFLEVBRUVvUCxFQUZGO0FBSUQ7QUFDRjtBQUNGOztBQUVELEtBQUlvTSxnQkFBZ0IsMkNBQXBCOztBQUVBLFVBQVNILFVBQVQsQ0FBcUJqVSxLQUFyQixFQUE0QnVSLElBQTVCLEVBQWtDO0FBQ2hDLE9BQUl1QyxLQUFKO0FBQ0EsT0FBSUksZUFBZU4sUUFBUXJDLElBQVIsQ0FBbkI7QUFDQSxPQUFJNkMsY0FBYzdNLElBQWQsQ0FBbUIyTSxZQUFuQixDQUFKLEVBQXNDO0FBQ3BDSixhQUFRLFFBQU85VCxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCa1UsYUFBYXpTLFdBQWIsRUFBekI7QUFDRCxJQUZELE1BRU8sSUFBSXlTLGlCQUFpQixRQUFyQixFQUErQjtBQUNwQ0osYUFBUTFULGNBQWNKLEtBQWQsQ0FBUjtBQUNELElBRk0sTUFFQSxJQUFJa1UsaUJBQWlCLE9BQXJCLEVBQThCO0FBQ25DSixhQUFRclEsTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBUjtBQUNELElBRk0sTUFFQTtBQUNMOFQsYUFBUTlULGlCQUFpQnVSLElBQXpCO0FBQ0Q7QUFDRCxVQUFPO0FBQ0x1QyxZQUFPQSxLQURGO0FBRUxJLG1CQUFjQTtBQUZULElBQVA7QUFJRDs7QUFFRDs7Ozs7QUFLQSxVQUFTTixPQUFULENBQWtCeFIsRUFBbEIsRUFBc0I7QUFDcEIsT0FBSXNHLFFBQVF0RyxNQUFNQSxHQUFHakMsUUFBSCxHQUFjdUksS0FBZCxDQUFvQixvQkFBcEIsQ0FBbEI7QUFDQSxVQUFPQSxRQUFRQSxNQUFNLENBQU4sQ0FBUixHQUFtQixFQUExQjtBQUNEOztBQUVELFVBQVMySyxNQUFULENBQWlCOUIsSUFBakIsRUFBdUJuUCxFQUF2QixFQUEyQjtBQUN6QixPQUFJLENBQUNxQixNQUFNbUIsT0FBTixDQUFjeEMsRUFBZCxDQUFMLEVBQXdCO0FBQ3RCLFlBQU93UixRQUFReFIsRUFBUixNQUFnQndSLFFBQVFyQyxJQUFSLENBQXZCO0FBQ0Q7QUFDRCxRQUFLLElBQUlsWixJQUFJLENBQVIsRUFBVzBWLE1BQU0zTCxHQUFHOUosTUFBekIsRUFBaUNELElBQUkwVixHQUFyQyxFQUEwQzFWLEdBQTFDLEVBQStDO0FBQzdDLFNBQUl1YixRQUFReFIsR0FBRy9KLENBQUgsQ0FBUixNQUFtQnViLFFBQVFyQyxJQUFSLENBQXZCLEVBQXNDO0FBQ3BDLGNBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFVBQU8sS0FBUDtBQUNEOztBQUVEOztBQUVBLEtBQUk4QyxJQUFKO0FBQ0EsS0FBSUMsT0FBSjs7QUFFQSxLQUFJM08sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE9BQUkwTyxPQUFPbkwsYUFBYTlQLE9BQU95TSxXQUEvQjtBQUNBO0FBQ0EsT0FDRXdPLFFBQ0FBLEtBQUtGLElBREwsSUFFQUUsS0FBS0QsT0FGTCxJQUdBQyxLQUFLQyxVQUhMLElBSUFELEtBQUtFLGFBTFAsRUFNRTtBQUNBSixZQUFPLGNBQVVLLEdBQVYsRUFBZTtBQUFFLGNBQU9ILEtBQUtGLElBQUwsQ0FBVUssR0FBVixDQUFQO0FBQXdCLE1BQWhEO0FBQ0FKLGVBQVUsaUJBQVUxYixJQUFWLEVBQWdCK2IsUUFBaEIsRUFBMEJDLE1BQTFCLEVBQWtDO0FBQzFDTCxZQUFLRCxPQUFMLENBQWExYixJQUFiLEVBQW1CK2IsUUFBbkIsRUFBNkJDLE1BQTdCO0FBQ0FMLFlBQUtDLFVBQUwsQ0FBZ0JHLFFBQWhCO0FBQ0FKLFlBQUtDLFVBQUwsQ0FBZ0JJLE1BQWhCO0FBQ0FMLFlBQUtFLGFBQUwsQ0FBbUI3YixJQUFuQjtBQUNELE1BTEQ7QUFNRDtBQUNGOztBQUVEOztBQUVBLEtBQUlpYyxTQUFKOztBQUVBLEtBQUlsUCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsT0FBSWlQLGlCQUFpQjVULFFBQ25CLDJDQUNBLGdGQURBLEdBRUEsd0VBRkEsR0FHQSxTQUptQixDQUlUO0FBSlMsSUFBckI7O0FBT0EsT0FBSTZULGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBVTlILE1BQVYsRUFBa0IvSyxHQUFsQixFQUF1QjtBQUMxQ3VGLFVBQ0UsMEJBQTBCdkYsR0FBMUIsR0FBZ0Msd0NBQWhDLEdBQ0EsK0RBREEsR0FFQSxnQ0FIRixFQUlFK0ssTUFKRjtBQU1ELElBUEQ7O0FBU0EsT0FBSStILFdBQ0YsT0FBT0MsS0FBUCxLQUFpQixXQUFqQixJQUNBQSxNQUFNOVUsUUFBTixHQUFpQnVJLEtBQWpCLENBQXVCLGFBQXZCLENBRkY7O0FBSUEsT0FBSXNNLFFBQUosRUFBYztBQUNaLFNBQUlFLG9CQUFvQmhVLFFBQVEsdUNBQVIsQ0FBeEI7QUFDQXFFLFlBQU9ZLFFBQVAsR0FBa0IsSUFBSThPLEtBQUosQ0FBVTFQLE9BQU9ZLFFBQWpCLEVBQTJCO0FBQzNDbUcsWUFBSyxTQUFTQSxHQUFULENBQWNXLE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQmxDLEtBQTNCLEVBQWtDO0FBQ3JDLGFBQUlrVixrQkFBa0JoVCxHQUFsQixDQUFKLEVBQTRCO0FBQzFCdUYsZ0JBQU0sOERBQThEdkYsR0FBcEU7QUFDQSxrQkFBTyxLQUFQO0FBQ0QsVUFIRCxNQUdPO0FBQ0wrSyxrQkFBTy9LLEdBQVAsSUFBY2xDLEtBQWQ7QUFDQSxrQkFBTyxJQUFQO0FBQ0Q7QUFDRjtBQVQwQyxNQUEzQixDQUFsQjtBQVdEOztBQUVELE9BQUltVixhQUFhO0FBQ2Y1SSxVQUFLLFNBQVNBLEdBQVQsQ0FBY1UsTUFBZCxFQUFzQi9LLEdBQXRCLEVBQTJCO0FBQzlCLFdBQUlxSyxNQUFNckssT0FBTytLLE1BQWpCO0FBQ0EsV0FBSW1JLFlBQVlOLGVBQWU1UyxHQUFmLEtBQXVCQSxJQUFJWSxNQUFKLENBQVcsQ0FBWCxNQUFrQixHQUF6RDtBQUNBLFdBQUksQ0FBQ3lKLEdBQUQsSUFBUSxDQUFDNkksU0FBYixFQUF3QjtBQUN0Qkwsd0JBQWU5SCxNQUFmLEVBQXVCL0ssR0FBdkI7QUFDRDtBQUNELGNBQU9xSyxPQUFPLENBQUM2SSxTQUFmO0FBQ0Q7QUFSYyxJQUFqQjs7QUFXQSxPQUFJQyxhQUFhO0FBQ2ZsTCxVQUFLLFNBQVNBLEdBQVQsQ0FBYzhDLE1BQWQsRUFBc0IvSyxHQUF0QixFQUEyQjtBQUM5QixXQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLEVBQUVBLE9BQU8rSyxNQUFULENBQS9CLEVBQWlEO0FBQy9DOEgsd0JBQWU5SCxNQUFmLEVBQXVCL0ssR0FBdkI7QUFDRDtBQUNELGNBQU8rSyxPQUFPL0ssR0FBUCxDQUFQO0FBQ0Q7QUFOYyxJQUFqQjs7QUFTQTJTLGVBQVksU0FBU0EsU0FBVCxDQUFvQjdNLEVBQXBCLEVBQXdCO0FBQ2xDLFNBQUlnTixRQUFKLEVBQWM7QUFDWjtBQUNBLFdBQUk1TSxVQUFVSixHQUFHTSxRQUFqQjtBQUNBLFdBQUlnTixXQUFXbE4sUUFBUW1OLE1BQVIsSUFBa0JuTixRQUFRbU4sTUFBUixDQUFlQyxhQUFqQyxHQUNYSCxVQURXLEdBRVhGLFVBRko7QUFHQW5OLFVBQUd5TixZQUFILEdBQWtCLElBQUlSLEtBQUosQ0FBVWpOLEVBQVYsRUFBY3NOLFFBQWQsQ0FBbEI7QUFDRCxNQVBELE1BT087QUFDTHROLFVBQUd5TixZQUFILEdBQWtCek4sRUFBbEI7QUFDRDtBQUNGLElBWEQ7QUFZRDs7QUFFRDs7QUFFQSxLQUFJME4sUUFBUSxTQUFTQSxLQUFULENBQ1ZoQixHQURVLEVBRVY5VyxJQUZVLEVBR1YrWCxRQUhVLEVBSVZDLElBSlUsRUFLVkMsR0FMVSxFQU1WQyxPQU5VLEVBT1ZDLGdCQVBVLEVBUVZDLFlBUlUsRUFTVjtBQUNBLFFBQUt0QixHQUFMLEdBQVdBLEdBQVg7QUFDQSxRQUFLOVcsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsUUFBSytYLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsUUFBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsUUFBS0MsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsUUFBS0ksRUFBTCxHQUFVaGUsU0FBVjtBQUNBLFFBQUs2ZCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxRQUFLSSxpQkFBTCxHQUF5QmplLFNBQXpCO0FBQ0EsUUFBS2lLLEdBQUwsR0FBV3RFLFFBQVFBLEtBQUtzRSxHQUF4QjtBQUNBLFFBQUs2VCxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBQ0EsUUFBS0ksaUJBQUwsR0FBeUJsZSxTQUF6QjtBQUNBLFFBQUtxWSxNQUFMLEdBQWNyWSxTQUFkO0FBQ0EsUUFBS21lLEdBQUwsR0FBVyxLQUFYO0FBQ0EsUUFBS0MsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFFBQUtDLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxRQUFLQyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsUUFBS0MsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFFBQUtDLE1BQUwsR0FBYyxLQUFkO0FBQ0EsUUFBS1QsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxRQUFLVSxTQUFMLEdBQWlCemUsU0FBakI7QUFDQSxRQUFLMGUsa0JBQUwsR0FBMEIsS0FBMUI7QUFDRCxFQS9CRDs7QUFpQ0EsS0FBSUMscUJBQXFCLEVBQUVyRyxPQUFPLEVBQVQsRUFBekI7O0FBRUE7QUFDQTtBQUNBcUcsb0JBQW1CckcsS0FBbkIsQ0FBeUJwRyxHQUF6QixHQUErQixZQUFZO0FBQ3pDLFVBQU8sS0FBS2dNLGlCQUFaO0FBQ0QsRUFGRDs7QUFJQWxYLFFBQU80WCxnQkFBUCxDQUF5Qm5CLE1BQU1oZSxTQUEvQixFQUEwQ2tmLGtCQUExQzs7QUFFQSxLQUFJRSxtQkFBbUIsU0FBbkJBLGdCQUFtQixDQUFVbEIsSUFBVixFQUFnQjtBQUNyQyxPQUFLQSxTQUFTLEtBQUssQ0FBbkIsRUFBdUJBLE9BQU8sRUFBUDs7QUFFdkIsT0FBSW1CLE9BQU8sSUFBSXJCLEtBQUosRUFBWDtBQUNBcUIsUUFBS25CLElBQUwsR0FBWUEsSUFBWjtBQUNBbUIsUUFBS1IsU0FBTCxHQUFpQixJQUFqQjtBQUNBLFVBQU9RLElBQVA7QUFDRCxFQVBEOztBQVNBLFVBQVNDLGVBQVQsQ0FBMEJ6VyxHQUExQixFQUErQjtBQUM3QixVQUFPLElBQUltVixLQUFKLENBQVV6ZCxTQUFWLEVBQXFCQSxTQUFyQixFQUFnQ0EsU0FBaEMsRUFBMkM4SSxPQUFPUixHQUFQLENBQTNDLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMwVyxVQUFULENBQXFCQyxLQUFyQixFQUE0QjtBQUMxQixPQUFJQyxTQUFTLElBQUl6QixLQUFKLENBQ1h3QixNQUFNeEMsR0FESyxFQUVYd0MsTUFBTXRaLElBRkssRUFHWHNaLE1BQU12QixRQUhLLEVBSVh1QixNQUFNdEIsSUFKSyxFQUtYc0IsTUFBTXJCLEdBTEssRUFNWHFCLE1BQU1wQixPQU5LLEVBT1hvQixNQUFNbkIsZ0JBUEssRUFRWG1CLE1BQU1sQixZQVJLLENBQWI7QUFVQW1CLFVBQU9sQixFQUFQLEdBQVlpQixNQUFNakIsRUFBbEI7QUFDQWtCLFVBQU9kLFFBQVAsR0FBa0JhLE1BQU1iLFFBQXhCO0FBQ0FjLFVBQU9qVixHQUFQLEdBQWFnVixNQUFNaFYsR0FBbkI7QUFDQWlWLFVBQU9aLFNBQVAsR0FBbUJXLE1BQU1YLFNBQXpCO0FBQ0FZLFVBQU9YLFFBQVAsR0FBa0IsSUFBbEI7QUFDQSxVQUFPVyxNQUFQO0FBQ0Q7O0FBRUQsVUFBU0MsV0FBVCxDQUFzQkMsTUFBdEIsRUFBOEI7QUFDNUIsT0FBSXRKLE1BQU1zSixPQUFPL2UsTUFBakI7QUFDQSxPQUFJNkUsTUFBTSxJQUFJc0csS0FBSixDQUFVc0ssR0FBVixDQUFWO0FBQ0EsUUFBSyxJQUFJMVYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMFYsR0FBcEIsRUFBeUIxVixHQUF6QixFQUE4QjtBQUM1QjhFLFNBQUk5RSxDQUFKLElBQVM0ZSxXQUFXSSxPQUFPaGYsQ0FBUCxDQUFYLENBQVQ7QUFDRDtBQUNELFVBQU84RSxHQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsS0FBSW1hLGlCQUFpQm5WLE9BQU8sVUFBVXZKLElBQVYsRUFBZ0I7QUFDMUMsT0FBSTJlLFVBQVUzZSxLQUFLa0ssTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBakM7QUFDQWxLLFVBQU8yZSxVQUFVM2UsS0FBS3FCLEtBQUwsQ0FBVyxDQUFYLENBQVYsR0FBMEJyQixJQUFqQztBQUNBLE9BQUk0ZSxVQUFVNWUsS0FBS2tLLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQWpDLENBSDBDLENBR0o7QUFDdENsSyxVQUFPNGUsVUFBVTVlLEtBQUtxQixLQUFMLENBQVcsQ0FBWCxDQUFWLEdBQTBCckIsSUFBakM7QUFDQSxPQUFJNmUsVUFBVTdlLEtBQUtrSyxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFqQztBQUNBbEssVUFBTzZlLFVBQVU3ZSxLQUFLcUIsS0FBTCxDQUFXLENBQVgsQ0FBVixHQUEwQnJCLElBQWpDO0FBQ0EsVUFBTztBQUNMQSxXQUFNQSxJQUREO0FBRUxzTSxXQUFNc1MsT0FGRDtBQUdMQyxjQUFTQSxPQUhKO0FBSUxGLGNBQVNBO0FBSkosSUFBUDtBQU1ELEVBYm9CLENBQXJCOztBQWVBLFVBQVNHLGVBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQzdCLFlBQVNDLE9BQVQsR0FBb0I7QUFDbEIsU0FBSUMsY0FBYy9mLFNBQWxCOztBQUVBLFNBQUk2ZixNQUFNQyxRQUFRRCxHQUFsQjtBQUNBLFNBQUlsVSxNQUFNbUIsT0FBTixDQUFjK1MsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCLFdBQUlSLFNBQVNRLElBQUkxZCxLQUFKLEVBQWI7QUFDQSxZQUFLLElBQUk1QixJQUFJLENBQWIsRUFBZ0JBLElBQUk4ZSxPQUFPN2UsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDO0FBQ3RDOGUsZ0JBQU85ZSxDQUFQLEVBQVVSLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0JnZ0IsV0FBdEI7QUFDRDtBQUNGLE1BTEQsTUFLTztBQUNMO0FBQ0EsY0FBT0YsSUFBSTlmLEtBQUosQ0FBVSxJQUFWLEVBQWdCQyxTQUFoQixDQUFQO0FBQ0Q7QUFDRjtBQUNEOGYsV0FBUUQsR0FBUixHQUFjQSxHQUFkO0FBQ0EsVUFBT0MsT0FBUDtBQUNEOztBQUVELFVBQVNFLGVBQVQsQ0FDRUMsRUFERixFQUVFQyxLQUZGLEVBR0V4TCxHQUhGLEVBSUV5TCxTQUpGLEVBS0VqUSxFQUxGLEVBTUU7QUFDQSxPQUFJcFAsSUFBSixFQUFVc2YsR0FBVixFQUFlQyxHQUFmLEVBQW9COVosS0FBcEI7QUFDQSxRQUFLekYsSUFBTCxJQUFhbWYsRUFBYixFQUFpQjtBQUNmRyxXQUFNSCxHQUFHbmYsSUFBSCxDQUFOO0FBQ0F1ZixXQUFNSCxNQUFNcGYsSUFBTixDQUFOO0FBQ0F5RixhQUFRaVosZUFBZTFlLElBQWYsQ0FBUjtBQUNBLFNBQUk4RyxRQUFRd1ksR0FBUixDQUFKLEVBQWtCO0FBQ2hCdlMsZUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsaUNBQWtDcEosTUFBTXpGLElBQXhDLEdBQWdELFVBQWhELEdBQTZEbUksT0FBT21YLEdBQVAsQ0FEdEIsRUFFdkNsUSxFQUZ1QyxDQUF6QztBQUlELE1BTEQsTUFLTyxJQUFJdEksUUFBUXlZLEdBQVIsQ0FBSixFQUFrQjtBQUN2QixXQUFJelksUUFBUXdZLElBQUlQLEdBQVosQ0FBSixFQUFzQjtBQUNwQk8sZUFBTUgsR0FBR25mLElBQUgsSUFBVzhlLGdCQUFnQlEsR0FBaEIsQ0FBakI7QUFDRDtBQUNEMUwsV0FBSW5PLE1BQU16RixJQUFWLEVBQWdCc2YsR0FBaEIsRUFBcUI3WixNQUFNNkcsSUFBM0IsRUFBaUM3RyxNQUFNb1osT0FBdkMsRUFBZ0RwWixNQUFNa1osT0FBdEQ7QUFDRCxNQUxNLE1BS0EsSUFBSVcsUUFBUUMsR0FBWixFQUFpQjtBQUN0QkEsV0FBSVIsR0FBSixHQUFVTyxHQUFWO0FBQ0FILFVBQUduZixJQUFILElBQVd1ZixHQUFYO0FBQ0Q7QUFDRjtBQUNELFFBQUt2ZixJQUFMLElBQWFvZixLQUFiLEVBQW9CO0FBQ2xCLFNBQUl0WSxRQUFRcVksR0FBR25mLElBQUgsQ0FBUixDQUFKLEVBQXVCO0FBQ3JCeUYsZUFBUWlaLGVBQWUxZSxJQUFmLENBQVI7QUFDQXFmLGlCQUFVNVosTUFBTXpGLElBQWhCLEVBQXNCb2YsTUFBTXBmLElBQU4sQ0FBdEIsRUFBbUN5RixNQUFNb1osT0FBekM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUEsVUFBU1csY0FBVCxDQUF5QnJSLEdBQXpCLEVBQThCc1IsT0FBOUIsRUFBdUNoSCxJQUF2QyxFQUE2QztBQUMzQyxPQUFJdUcsT0FBSjtBQUNBLE9BQUlVLFVBQVV2UixJQUFJc1IsT0FBSixDQUFkOztBQUVBLFlBQVNFLFdBQVQsR0FBd0I7QUFDdEJsSCxVQUFLeFosS0FBTCxDQUFXLElBQVgsRUFBaUJDLFNBQWpCO0FBQ0E7QUFDQTtBQUNBOEosWUFBT2dXLFFBQVFELEdBQWYsRUFBb0JZLFdBQXBCO0FBQ0Q7O0FBRUQsT0FBSTdZLFFBQVE0WSxPQUFSLENBQUosRUFBc0I7QUFDcEI7QUFDQVYsZUFBVUYsZ0JBQWdCLENBQUNhLFdBQUQsQ0FBaEIsQ0FBVjtBQUNELElBSEQsTUFHTztBQUNMO0FBQ0EsU0FBSTNZLE1BQU0wWSxRQUFRWCxHQUFkLEtBQXNCOVgsT0FBT3lZLFFBQVFFLE1BQWYsQ0FBMUIsRUFBa0Q7QUFDaEQ7QUFDQVosaUJBQVVVLE9BQVY7QUFDQVYsZUFBUUQsR0FBUixDQUFZMU8sSUFBWixDQUFpQnNQLFdBQWpCO0FBQ0QsTUFKRCxNQUlPO0FBQ0w7QUFDQVgsaUJBQVVGLGdCQUFnQixDQUFDWSxPQUFELEVBQVVDLFdBQVYsQ0FBaEIsQ0FBVjtBQUNEO0FBQ0Y7O0FBRURYLFdBQVFZLE1BQVIsR0FBaUIsSUFBakI7QUFDQXpSLE9BQUlzUixPQUFKLElBQWVULE9BQWY7QUFDRDs7QUFFRDs7QUFFQSxVQUFTYSx5QkFBVCxDQUNFN2EsSUFERixFQUVFK00sSUFGRixFQUdFK0osR0FIRixFQUlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBSXhCLGNBQWN2SSxLQUFLdkMsT0FBTCxDQUFhb0osS0FBL0I7QUFDQSxPQUFJOVIsUUFBUXdULFdBQVIsQ0FBSixFQUEwQjtBQUN4QjtBQUNEO0FBQ0QsT0FBSS9WLE1BQU0sRUFBVjtBQUNBLE9BQUl1YixRQUFROWEsS0FBSzhhLEtBQWpCO0FBQ0EsT0FBSWxILFFBQVE1VCxLQUFLNFQsS0FBakI7QUFDQSxPQUFJNVIsTUFBTThZLEtBQU4sS0FBZ0I5WSxNQUFNNFIsS0FBTixDQUFwQixFQUFrQztBQUNoQyxVQUFLLElBQUl0UCxHQUFULElBQWdCZ1IsV0FBaEIsRUFBNkI7QUFDM0IsV0FBSXlGLFNBQVMzVixVQUFVZCxHQUFWLENBQWI7QUFDQSxXQUFJeUQsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGFBQUkrUyxpQkFBaUIxVyxJQUFJVCxXQUFKLEVBQXJCO0FBQ0EsYUFDRVMsUUFBUTBXLGNBQVIsSUFDQUYsS0FEQSxJQUNTelcsT0FBT3lXLEtBQVAsRUFBY0UsY0FBZCxDQUZYLEVBR0U7QUFDQWxSLGVBQ0UsWUFBWWtSLGNBQVosR0FBNkIsNEJBQTdCLEdBQ0NqUixvQkFBb0IrTSxPQUFPL0osSUFBM0IsQ0FERCxHQUNxQyxpQ0FEckMsR0FFQSxLQUZBLEdBRVF6SSxHQUZSLEdBRWMsTUFGZCxHQUdBLGdFQUhBLEdBSUEsbUVBSkEsR0FLQSx1Q0FMQSxHQUswQ3lXLE1BTDFDLEdBS21ELGtCQUxuRCxHQUt3RXpXLEdBTHhFLEdBSzhFLEtBTmhGO0FBUUQ7QUFDRjtBQUNEMlcsaUJBQVUxYixHQUFWLEVBQWVxVSxLQUFmLEVBQXNCdFAsR0FBdEIsRUFBMkJ5VyxNQUEzQixFQUFtQyxJQUFuQyxLQUNBRSxVQUFVMWIsR0FBVixFQUFldWIsS0FBZixFQUFzQnhXLEdBQXRCLEVBQTJCeVcsTUFBM0IsRUFBbUMsS0FBbkMsQ0FEQTtBQUVEO0FBQ0Y7QUFDRCxVQUFPeGIsR0FBUDtBQUNEOztBQUVELFVBQVMwYixTQUFULENBQ0UxYixHQURGLEVBRUUyYixJQUZGLEVBR0U1VyxHQUhGLEVBSUV5VyxNQUpGLEVBS0VJLFFBTEYsRUFNRTtBQUNBLE9BQUluWixNQUFNa1osSUFBTixDQUFKLEVBQWlCO0FBQ2YsU0FBSTdXLE9BQU82VyxJQUFQLEVBQWE1VyxHQUFiLENBQUosRUFBdUI7QUFDckIvRSxXQUFJK0UsR0FBSixJQUFXNFcsS0FBSzVXLEdBQUwsQ0FBWDtBQUNBLFdBQUksQ0FBQzZXLFFBQUwsRUFBZTtBQUNiLGdCQUFPRCxLQUFLNVcsR0FBTCxDQUFQO0FBQ0Q7QUFDRCxjQUFPLElBQVA7QUFDRCxNQU5ELE1BTU8sSUFBSUQsT0FBTzZXLElBQVAsRUFBYUgsTUFBYixDQUFKLEVBQTBCO0FBQy9CeGIsV0FBSStFLEdBQUosSUFBVzRXLEtBQUtILE1BQUwsQ0FBWDtBQUNBLFdBQUksQ0FBQ0ksUUFBTCxFQUFlO0FBQ2IsZ0JBQU9ELEtBQUtILE1BQUwsQ0FBUDtBQUNEO0FBQ0QsY0FBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQU8sS0FBUDtBQUNEOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBU0ssdUJBQVQsQ0FBa0NyRCxRQUFsQyxFQUE0QztBQUMxQyxRQUFLLElBQUl0ZCxJQUFJLENBQWIsRUFBZ0JBLElBQUlzZCxTQUFTcmQsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQ3hDLFNBQUlvTCxNQUFNbUIsT0FBTixDQUFjK1EsU0FBU3RkLENBQVQsQ0FBZCxDQUFKLEVBQWdDO0FBQzlCLGNBQU9vTCxNQUFNL0wsU0FBTixDQUFnQjJNLE1BQWhCLENBQXVCeE0sS0FBdkIsQ0FBNkIsRUFBN0IsRUFBaUM4ZCxRQUFqQyxDQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQU9BLFFBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVNzRCxpQkFBVCxDQUE0QnRELFFBQTVCLEVBQXNDO0FBQ3BDLFVBQU81VixZQUFZNFYsUUFBWixJQUNILENBQUNxQixnQkFBZ0JyQixRQUFoQixDQUFELENBREcsR0FFSGxTLE1BQU1tQixPQUFOLENBQWMrUSxRQUFkLElBQ0V1RCx1QkFBdUJ2RCxRQUF2QixDQURGLEdBRUUxZCxTQUpOO0FBS0Q7O0FBRUQsVUFBU2toQixVQUFULENBQXFCcEMsSUFBckIsRUFBMkI7QUFDekIsVUFBT25YLE1BQU1tWCxJQUFOLEtBQWVuWCxNQUFNbVgsS0FBS25CLElBQVgsQ0FBZixJQUFtQzlWLFFBQVFpWCxLQUFLUixTQUFiLENBQTFDO0FBQ0Q7O0FBRUQsVUFBUzJDLHNCQUFULENBQWlDdkQsUUFBakMsRUFBMkN5RCxXQUEzQyxFQUF3RDtBQUN0RCxPQUFJamMsTUFBTSxFQUFWO0FBQ0EsT0FBSTlFLENBQUosRUFBT3VLLENBQVAsRUFBVW1HLElBQVY7QUFDQSxRQUFLMVEsSUFBSSxDQUFULEVBQVlBLElBQUlzZCxTQUFTcmQsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDdUssU0FBSStTLFNBQVN0ZCxDQUFULENBQUo7QUFDQSxTQUFJcUgsUUFBUWtELENBQVIsS0FBYyxPQUFPQSxDQUFQLEtBQWEsU0FBL0IsRUFBMEM7QUFBRTtBQUFVO0FBQ3REbUcsWUFBTzVMLElBQUlBLElBQUk3RSxNQUFKLEdBQWEsQ0FBakIsQ0FBUDtBQUNBO0FBQ0EsU0FBSW1MLE1BQU1tQixPQUFOLENBQWNoQyxDQUFkLENBQUosRUFBc0I7QUFDcEJ6RixXQUFJOEwsSUFBSixDQUFTcFIsS0FBVCxDQUFlc0YsR0FBZixFQUFvQitiLHVCQUF1QnRXLENBQXZCLEVBQTJCLENBQUN3VyxlQUFlLEVBQWhCLElBQXNCLEdBQXRCLEdBQTRCL2dCLENBQXZELENBQXBCO0FBQ0QsTUFGRCxNQUVPLElBQUkwSCxZQUFZNkMsQ0FBWixDQUFKLEVBQW9CO0FBQ3pCLFdBQUl1VyxXQUFXcFEsSUFBWCxDQUFKLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNDQSxhQUFELENBQU82TSxJQUFQLElBQWU3VSxPQUFPNkIsQ0FBUCxDQUFmO0FBQ0QsUUFMRCxNQUtPLElBQUlBLE1BQU0sRUFBVixFQUFjO0FBQ25CO0FBQ0F6RixhQUFJOEwsSUFBSixDQUFTK04sZ0JBQWdCcFUsQ0FBaEIsQ0FBVDtBQUNEO0FBQ0YsTUFWTSxNQVVBO0FBQ0wsV0FBSXVXLFdBQVd2VyxDQUFYLEtBQWlCdVcsV0FBV3BRLElBQVgsQ0FBckIsRUFBdUM7QUFDckM7QUFDQTVMLGFBQUlBLElBQUk3RSxNQUFKLEdBQWEsQ0FBakIsSUFBc0IwZSxnQkFBZ0JqTyxLQUFLNk0sSUFBTCxHQUFZaFQsRUFBRWdULElBQTlCLENBQXRCO0FBQ0QsUUFIRCxNQUdPO0FBQ0w7QUFDQSxhQUFJL1YsT0FBTzhWLFNBQVMwRCxRQUFoQixLQUNGelosTUFBTWdELEVBQUU4UixHQUFSLENBREUsSUFFRmhWLFFBQVFrRCxFQUFFVixHQUFWLENBRkUsSUFHRnRDLE1BQU13WixXQUFOLENBSEYsRUFHc0I7QUFDcEJ4VyxhQUFFVixHQUFGLEdBQVEsWUFBWWtYLFdBQVosR0FBMEIsR0FBMUIsR0FBZ0MvZ0IsQ0FBaEMsR0FBb0MsSUFBNUM7QUFDRDtBQUNEOEUsYUFBSThMLElBQUosQ0FBU3JHLENBQVQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPekYsR0FBUDtBQUNEOztBQUVEOztBQUVBLFVBQVNtYyxVQUFULENBQXFCQyxJQUFyQixFQUEyQkMsSUFBM0IsRUFBaUM7QUFDL0IsT0FBSUQsS0FBS0UsVUFBTCxJQUFtQkYsS0FBSzdGLE9BQTVCLEVBQXFDO0FBQ25DNkYsWUFBT0EsS0FBSzdGLE9BQVo7QUFDRDtBQUNELFVBQU96VCxTQUFTc1osSUFBVCxJQUNIQyxLQUFLOVYsTUFBTCxDQUFZNlYsSUFBWixDQURHLEdBRUhBLElBRko7QUFHRDs7QUFFRCxVQUFTRyxzQkFBVCxDQUNFNWdCLE9BREYsRUFFRThFLElBRkYsRUFHRWtZLE9BSEYsRUFJRUgsUUFKRixFQUtFakIsR0FMRixFQU1FO0FBQ0EsT0FBSXFDLE9BQU9ELGtCQUFYO0FBQ0FDLFFBQUtmLFlBQUwsR0FBb0JsZCxPQUFwQjtBQUNBaWUsUUFBS0wsU0FBTCxHQUFpQixFQUFFOVksTUFBTUEsSUFBUixFQUFja1ksU0FBU0EsT0FBdkIsRUFBZ0NILFVBQVVBLFFBQTFDLEVBQW9EakIsS0FBS0EsR0FBekQsRUFBakI7QUFDQSxVQUFPcUMsSUFBUDtBQUNEOztBQUVELFVBQVM0QyxxQkFBVCxDQUNFN2dCLE9BREYsRUFFRThnQixRQUZGLEVBR0U5RCxPQUhGLEVBSUU7QUFDQSxPQUFJalcsT0FBTy9HLFFBQVFxRixLQUFmLEtBQXlCeUIsTUFBTTlHLFFBQVErZ0IsU0FBZCxDQUE3QixFQUF1RDtBQUNyRCxZQUFPL2dCLFFBQVErZ0IsU0FBZjtBQUNEOztBQUVELE9BQUlqYSxNQUFNOUcsUUFBUWdoQixRQUFkLENBQUosRUFBNkI7QUFDM0IsWUFBT2hoQixRQUFRZ2hCLFFBQWY7QUFDRDs7QUFFRCxPQUFJamEsT0FBTy9HLFFBQVFpaEIsT0FBZixLQUEyQm5hLE1BQU05RyxRQUFRa2hCLFdBQWQsQ0FBL0IsRUFBMkQ7QUFDekQsWUFBT2xoQixRQUFRa2hCLFdBQWY7QUFDRDs7QUFFRCxPQUFJcGEsTUFBTTlHLFFBQVFtaEIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCO0FBQ0FuaEIsYUFBUW1oQixRQUFSLENBQWlCaFIsSUFBakIsQ0FBc0I2TSxPQUF0QjtBQUNELElBSEQsTUFHTztBQUNMLFNBQUltRSxXQUFXbmhCLFFBQVFtaEIsUUFBUixHQUFtQixDQUFDbkUsT0FBRCxDQUFsQztBQUNBLFNBQUlvRSxPQUFPLElBQVg7O0FBRUEsU0FBSUMsY0FBYyxTQUFkQSxXQUFjLEdBQVk7QUFDNUIsWUFBSyxJQUFJOWhCLElBQUksQ0FBUixFQUFXK0ssSUFBSTZXLFNBQVMzaEIsTUFBN0IsRUFBcUNELElBQUkrSyxDQUF6QyxFQUE0Qy9LLEdBQTVDLEVBQWlEO0FBQy9DNGhCLGtCQUFTNWhCLENBQVQsRUFBWStoQixZQUFaO0FBQ0Q7QUFDRixNQUpEOztBQU1BLFNBQUl6YixVQUFVdUcsS0FBSyxVQUFVL0gsR0FBVixFQUFlO0FBQ2hDO0FBQ0FyRSxlQUFRZ2hCLFFBQVIsR0FBbUJSLFdBQVduYyxHQUFYLEVBQWdCeWMsUUFBaEIsQ0FBbkI7QUFDQTtBQUNBO0FBQ0EsV0FBSSxDQUFDTSxJQUFMLEVBQVc7QUFDVEM7QUFDRDtBQUNGLE1BUmEsQ0FBZDs7QUFVQSxTQUFJdGIsU0FBU3FHLEtBQUssVUFBVW1WLE1BQVYsRUFBa0I7QUFDbEMxVSxlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2Qyx3Q0FBeUMxRyxPQUFPakksT0FBUCxDQUF6QyxJQUNDdWhCLFNBQVUsZUFBZUEsTUFBekIsR0FBbUMsRUFEcEMsQ0FEdUMsQ0FBekM7QUFJQSxXQUFJemEsTUFBTTlHLFFBQVErZ0IsU0FBZCxDQUFKLEVBQThCO0FBQzVCL2dCLGlCQUFRcUYsS0FBUixHQUFnQixJQUFoQjtBQUNBZ2M7QUFDRDtBQUNGLE1BVFksQ0FBYjs7QUFXQSxTQUFJaGQsTUFBTXJFLFFBQVE2RixPQUFSLEVBQWlCRSxNQUFqQixDQUFWOztBQUVBLFNBQUlvQixTQUFTOUMsR0FBVCxDQUFKLEVBQW1CO0FBQ2pCLFdBQUksT0FBT0EsSUFBSVUsSUFBWCxLQUFvQixVQUF4QixFQUFvQztBQUNsQztBQUNBLGFBQUk2QixRQUFRNUcsUUFBUWdoQixRQUFoQixDQUFKLEVBQStCO0FBQzdCM2MsZUFBSVUsSUFBSixDQUFTYyxPQUFULEVBQWtCRSxNQUFsQjtBQUNEO0FBQ0YsUUFMRCxNQUtPLElBQUllLE1BQU16QyxJQUFJbWQsU0FBVixLQUF3QixPQUFPbmQsSUFBSW1kLFNBQUosQ0FBY3pjLElBQXJCLEtBQThCLFVBQTFELEVBQXNFO0FBQzNFVixhQUFJbWQsU0FBSixDQUFjemMsSUFBZCxDQUFtQmMsT0FBbkIsRUFBNEJFLE1BQTVCOztBQUVBLGFBQUllLE1BQU16QyxJQUFJZ0IsS0FBVixDQUFKLEVBQXNCO0FBQ3BCckYsbUJBQVErZ0IsU0FBUixHQUFvQlAsV0FBV25jLElBQUlnQixLQUFmLEVBQXNCeWIsUUFBdEIsQ0FBcEI7QUFDRDs7QUFFRCxhQUFJaGEsTUFBTXpDLElBQUk0YyxPQUFWLENBQUosRUFBd0I7QUFDdEJqaEIsbUJBQVFraEIsV0FBUixHQUFzQlYsV0FBV25jLElBQUk0YyxPQUFmLEVBQXdCSCxRQUF4QixDQUF0QjtBQUNBLGVBQUl6YyxJQUFJb2QsS0FBSixLQUFjLENBQWxCLEVBQXFCO0FBQ25CemhCLHFCQUFRaWhCLE9BQVIsR0FBa0IsSUFBbEI7QUFDRCxZQUZELE1BRU87QUFDTHRPLHdCQUFXLFlBQVk7QUFDckIsbUJBQUkvTCxRQUFRNUcsUUFBUWdoQixRQUFoQixLQUE2QnBhLFFBQVE1RyxRQUFRcUYsS0FBaEIsQ0FBakMsRUFBeUQ7QUFDdkRyRix5QkFBUWloQixPQUFSLEdBQWtCLElBQWxCO0FBQ0FJO0FBQ0Q7QUFDRixjQUxELEVBS0doZCxJQUFJb2QsS0FBSixJQUFhLEdBTGhCO0FBTUQ7QUFDRjs7QUFFRCxhQUFJM2EsTUFBTXpDLElBQUlxZCxPQUFWLENBQUosRUFBd0I7QUFDdEIvTyxzQkFBVyxZQUFZO0FBQ3JCLGlCQUFJL0wsUUFBUTVHLFFBQVFnaEIsUUFBaEIsQ0FBSixFQUErQjtBQUM3QmpiLHNCQUNFOEcsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLEdBQ0ssY0FBZTFJLElBQUlxZCxPQUFuQixHQUE4QixLQURuQyxHQUVJLElBSE47QUFLRDtBQUNGLFlBUkQsRUFRR3JkLElBQUlxZCxPQVJQO0FBU0Q7QUFDRjtBQUNGOztBQUVETixZQUFPLEtBQVA7QUFDQTtBQUNBLFlBQU9waEIsUUFBUWloQixPQUFSLEdBQ0hqaEIsUUFBUWtoQixXQURMLEdBRUhsaEIsUUFBUWdoQixRQUZaO0FBR0Q7QUFDRjs7QUFFRDs7QUFFQSxVQUFTVyxzQkFBVCxDQUFpQzlFLFFBQWpDLEVBQTJDO0FBQ3pDLE9BQUlsUyxNQUFNbUIsT0FBTixDQUFjK1EsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFVBQUssSUFBSXRkLElBQUksQ0FBYixFQUFnQkEsSUFBSXNkLFNBQVNyZCxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDeEMsV0FBSXVLLElBQUkrUyxTQUFTdGQsQ0FBVCxDQUFSO0FBQ0EsV0FBSXVILE1BQU1nRCxDQUFOLEtBQVloRCxNQUFNZ0QsRUFBRW1ULGdCQUFSLENBQWhCLEVBQTJDO0FBQ3pDLGdCQUFPblQsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEOztBQUVBOztBQUVBLFVBQVM4WCxVQUFULENBQXFCMVMsRUFBckIsRUFBeUI7QUFDdkJBLE1BQUcyUyxPQUFILEdBQWExYixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNBMEcsTUFBRzRTLGFBQUgsR0FBbUIsS0FBbkI7QUFDQTtBQUNBLE9BQUlDLFlBQVk3UyxHQUFHTSxRQUFILENBQVl3UyxnQkFBNUI7QUFDQSxPQUFJRCxTQUFKLEVBQWU7QUFDYkUsOEJBQXlCL1MsRUFBekIsRUFBNkI2UyxTQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsS0FBSTVOLE1BQUo7O0FBRUEsVUFBU1QsR0FBVCxDQUFjbk8sS0FBZCxFQUFxQitELEVBQXJCLEVBQXlCb1YsT0FBekIsRUFBa0M7QUFDaEMsT0FBSUEsT0FBSixFQUFhO0FBQ1h2SyxZQUFPK04sS0FBUCxDQUFhM2MsS0FBYixFQUFvQitELEVBQXBCO0FBQ0QsSUFGRCxNQUVPO0FBQ0w2SyxZQUFPZ08sR0FBUCxDQUFXNWMsS0FBWCxFQUFrQitELEVBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTOFksUUFBVCxDQUFtQjdjLEtBQW5CLEVBQTBCK0QsRUFBMUIsRUFBOEI7QUFDNUI2SyxVQUFPa08sSUFBUCxDQUFZOWMsS0FBWixFQUFtQitELEVBQW5CO0FBQ0Q7O0FBRUQsVUFBUzJZLHdCQUFULENBQ0UvUyxFQURGLEVBRUU2UyxTQUZGLEVBR0VPLFlBSEYsRUFJRTtBQUNBbk8sWUFBU2pGLEVBQVQ7QUFDQThQLG1CQUFnQitDLFNBQWhCLEVBQTJCTyxnQkFBZ0IsRUFBM0MsRUFBK0M1TyxHQUEvQyxFQUFvRDBPLFFBQXBELEVBQThEbFQsRUFBOUQ7QUFDRDs7QUFFRCxVQUFTcVQsV0FBVCxDQUFzQkMsR0FBdEIsRUFBMkI7QUFDekIsT0FBSUMsU0FBUyxRQUFiO0FBQ0FELE9BQUk1akIsU0FBSixDQUFjdWpCLEdBQWQsR0FBb0IsVUFBVTVjLEtBQVYsRUFBaUIrRCxFQUFqQixFQUFxQjtBQUN2QyxTQUFJb1osU0FBUyxJQUFiOztBQUVBLFNBQUl4VCxLQUFLLElBQVQ7QUFDQSxTQUFJdkUsTUFBTW1CLE9BQU4sQ0FBY3ZHLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixZQUFLLElBQUloRyxJQUFJLENBQVIsRUFBVytLLElBQUkvRSxNQUFNL0YsTUFBMUIsRUFBa0NELElBQUkrSyxDQUF0QyxFQUF5Qy9LLEdBQXpDLEVBQThDO0FBQzVDbWpCLGdCQUFPUCxHQUFQLENBQVc1YyxNQUFNaEcsQ0FBTixDQUFYLEVBQXFCK0osRUFBckI7QUFDRDtBQUNGLE1BSkQsTUFJTztBQUNMLFFBQUM0RixHQUFHMlMsT0FBSCxDQUFXdGMsS0FBWCxNQUFzQjJKLEdBQUcyUyxPQUFILENBQVd0YyxLQUFYLElBQW9CLEVBQTFDLENBQUQsRUFBZ0Q0SyxJQUFoRCxDQUFxRDdHLEVBQXJEO0FBQ0E7QUFDQTtBQUNBLFdBQUltWixPQUFPaFUsSUFBUCxDQUFZbEosS0FBWixDQUFKLEVBQXdCO0FBQ3RCMkosWUFBRzRTLGFBQUgsR0FBbUIsSUFBbkI7QUFDRDtBQUNGO0FBQ0QsWUFBTzVTLEVBQVA7QUFDRCxJQWpCRDs7QUFtQkFzVCxPQUFJNWpCLFNBQUosQ0FBY3NqQixLQUFkLEdBQXNCLFVBQVUzYyxLQUFWLEVBQWlCK0QsRUFBakIsRUFBcUI7QUFDekMsU0FBSTRGLEtBQUssSUFBVDtBQUNBLGNBQVMrUCxFQUFULEdBQWU7QUFDYi9QLFVBQUdtVCxJQUFILENBQVE5YyxLQUFSLEVBQWUwWixFQUFmO0FBQ0EzVixVQUFHdkssS0FBSCxDQUFTbVEsRUFBVCxFQUFhbFEsU0FBYjtBQUNEO0FBQ0RpZ0IsUUFBRzNWLEVBQUgsR0FBUUEsRUFBUjtBQUNBNEYsUUFBR2lULEdBQUgsQ0FBTzVjLEtBQVAsRUFBYzBaLEVBQWQ7QUFDQSxZQUFPL1AsRUFBUDtBQUNELElBVEQ7O0FBV0FzVCxPQUFJNWpCLFNBQUosQ0FBY3lqQixJQUFkLEdBQXFCLFVBQVU5YyxLQUFWLEVBQWlCK0QsRUFBakIsRUFBcUI7QUFDeEMsU0FBSW9aLFNBQVMsSUFBYjs7QUFFQSxTQUFJeFQsS0FBSyxJQUFUO0FBQ0E7QUFDQSxTQUFJLENBQUNsUSxVQUFVUSxNQUFmLEVBQXVCO0FBQ3JCMFAsVUFBRzJTLE9BQUgsR0FBYTFiLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFiO0FBQ0EsY0FBTzBHLEVBQVA7QUFDRDtBQUNEO0FBQ0EsU0FBSXZFLE1BQU1tQixPQUFOLENBQWN2RyxLQUFkLENBQUosRUFBMEI7QUFDeEIsWUFBSyxJQUFJb2QsTUFBTSxDQUFWLEVBQWFyWSxJQUFJL0UsTUFBTS9GLE1BQTVCLEVBQW9DbWpCLE1BQU1yWSxDQUExQyxFQUE2Q3FZLEtBQTdDLEVBQW9EO0FBQ2xERCxnQkFBT0wsSUFBUCxDQUFZOWMsTUFBTW9kLEdBQU4sQ0FBWixFQUF3QnJaLEVBQXhCO0FBQ0Q7QUFDRCxjQUFPNEYsRUFBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFJMFQsTUFBTTFULEdBQUcyUyxPQUFILENBQVd0YyxLQUFYLENBQVY7QUFDQSxTQUFJLENBQUNxZCxHQUFMLEVBQVU7QUFDUixjQUFPMVQsRUFBUDtBQUNEO0FBQ0QsU0FBSWxRLFVBQVVRLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIwUCxVQUFHMlMsT0FBSCxDQUFXdGMsS0FBWCxJQUFvQixJQUFwQjtBQUNBLGNBQU8ySixFQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQUlrRSxFQUFKO0FBQ0EsU0FBSTdULElBQUlxakIsSUFBSXBqQixNQUFaO0FBQ0EsWUFBT0QsR0FBUCxFQUFZO0FBQ1Y2VCxZQUFLd1AsSUFBSXJqQixDQUFKLENBQUw7QUFDQSxXQUFJNlQsT0FBTzlKLEVBQVAsSUFBYThKLEdBQUc5SixFQUFILEtBQVVBLEVBQTNCLEVBQStCO0FBQzdCc1osYUFBSTNaLE1BQUosQ0FBVzFKLENBQVgsRUFBYyxDQUFkO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsWUFBTzJQLEVBQVA7QUFDRCxJQXBDRDs7QUFzQ0FzVCxPQUFJNWpCLFNBQUosQ0FBY2lrQixLQUFkLEdBQXNCLFVBQVV0ZCxLQUFWLEVBQWlCO0FBQ3JDLFNBQUkySixLQUFLLElBQVQ7QUFDQSxTQUFJckMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFdBQUkrVixpQkFBaUJ2ZCxNQUFNb0QsV0FBTixFQUFyQjtBQUNBLFdBQUltYSxtQkFBbUJ2ZCxLQUFuQixJQUE0QjJKLEdBQUcyUyxPQUFILENBQVdpQixjQUFYLENBQWhDLEVBQTREO0FBQzFEbFUsYUFDRSxhQUFha1UsY0FBYixHQUE4Qiw2QkFBOUIsR0FDQ2pVLG9CQUFvQkssRUFBcEIsQ0FERCxHQUM0Qix1Q0FENUIsR0FDc0UzSixLQUR0RSxHQUM4RSxNQUQ5RSxHQUVBLG9FQUZBLEdBR0Esa0VBSEEsR0FJQSw0QkFKQSxHQUlnQzJFLFVBQVUzRSxLQUFWLENBSmhDLEdBSW9ELGtCQUpwRCxHQUl5RUEsS0FKekUsR0FJaUYsS0FMbkY7QUFPRDtBQUNGO0FBQ0QsU0FBSXFkLE1BQU0xVCxHQUFHMlMsT0FBSCxDQUFXdGMsS0FBWCxDQUFWO0FBQ0EsU0FBSXFkLEdBQUosRUFBUztBQUNQQSxhQUFNQSxJQUFJcGpCLE1BQUosR0FBYSxDQUFiLEdBQWlCZ0wsUUFBUW9ZLEdBQVIsQ0FBakIsR0FBZ0NBLEdBQXRDO0FBQ0EsV0FBSTVOLE9BQU94SyxRQUFReEwsU0FBUixFQUFtQixDQUFuQixDQUFYO0FBQ0EsWUFBSyxJQUFJTyxJQUFJLENBQVIsRUFBVytLLElBQUlzWSxJQUFJcGpCLE1BQXhCLEVBQWdDRCxJQUFJK0ssQ0FBcEMsRUFBdUMvSyxHQUF2QyxFQUE0QztBQUMxQyxhQUFJO0FBQ0ZxakIsZUFBSXJqQixDQUFKLEVBQU9SLEtBQVAsQ0FBYW1RLEVBQWIsRUFBaUI4RixJQUFqQjtBQUNELFVBRkQsQ0FFRSxPQUFPbFcsQ0FBUCxFQUFVO0FBQ1ZzUix1QkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBb0IseUJBQXlCM0osS0FBekIsR0FBaUMsSUFBckQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxZQUFPMkosRUFBUDtBQUNELElBM0JEO0FBNEJEOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTNlQsWUFBVCxDQUNFbEcsUUFERixFQUVFRyxPQUZGLEVBR0U7QUFDQSxPQUFJZ0csUUFBUSxFQUFaO0FBQ0EsT0FBSSxDQUFDbkcsUUFBTCxFQUFlO0FBQ2IsWUFBT21HLEtBQVA7QUFDRDtBQUNELE9BQUlDLGNBQWMsRUFBbEI7QUFDQSxRQUFLLElBQUkxakIsSUFBSSxDQUFSLEVBQVcrSyxJQUFJdVMsU0FBU3JkLE1BQTdCLEVBQXFDRCxJQUFJK0ssQ0FBekMsRUFBNEMvSyxHQUE1QyxFQUFpRDtBQUMvQyxTQUFJa1ksUUFBUW9GLFNBQVN0ZCxDQUFULENBQVo7QUFDQTtBQUNBO0FBQ0EsU0FBSSxDQUFDa1ksTUFBTXVGLE9BQU4sS0FBa0JBLE9BQWxCLElBQTZCdkYsTUFBTTJGLGlCQUFOLEtBQTRCSixPQUExRCxLQUNGdkYsTUFBTTNTLElBREosSUFDWTJTLE1BQU0zUyxJQUFOLENBQVdvZSxJQUFYLElBQW1CLElBRG5DLEVBRUU7QUFDQSxXQUFJcGpCLE9BQU8yWCxNQUFNM1MsSUFBTixDQUFXb2UsSUFBdEI7QUFDQSxXQUFJQSxPQUFRRixNQUFNbGpCLElBQU4sTUFBZ0JrakIsTUFBTWxqQixJQUFOLElBQWMsRUFBOUIsQ0FBWjtBQUNBLFdBQUkyWCxNQUFNbUUsR0FBTixLQUFjLFVBQWxCLEVBQThCO0FBQzVCc0gsY0FBSy9TLElBQUwsQ0FBVXBSLEtBQVYsQ0FBZ0Jta0IsSUFBaEIsRUFBc0J6TCxNQUFNb0YsUUFBNUI7QUFDRCxRQUZELE1BRU87QUFDTHFHLGNBQUsvUyxJQUFMLENBQVVzSCxLQUFWO0FBQ0Q7QUFDRixNQVZELE1BVU87QUFDTHdMLG1CQUFZOVMsSUFBWixDQUFpQnNILEtBQWpCO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsT0FBSSxDQUFDd0wsWUFBWWpYLEtBQVosQ0FBa0JtWCxZQUFsQixDQUFMLEVBQXNDO0FBQ3BDSCxXQUFNcEksT0FBTixHQUFnQnFJLFdBQWhCO0FBQ0Q7QUFDRCxVQUFPRCxLQUFQO0FBQ0Q7O0FBRUQsVUFBU0csWUFBVCxDQUF1QmxGLElBQXZCLEVBQTZCO0FBQzNCLFVBQU9BLEtBQUtSLFNBQUwsSUFBa0JRLEtBQUtuQixJQUFMLEtBQWMsR0FBdkM7QUFDRDs7QUFFRCxVQUFTc0csa0JBQVQsQ0FDRXZFLEdBREYsRUFDTztBQUNMeGEsSUFGRixFQUdFO0FBQ0FBLFNBQU1BLE9BQU8sRUFBYjtBQUNBLFFBQUssSUFBSTlFLElBQUksQ0FBYixFQUFnQkEsSUFBSXNmLElBQUlyZixNQUF4QixFQUFnQ0QsR0FBaEMsRUFBcUM7QUFDbkMsU0FBSW9MLE1BQU1tQixPQUFOLENBQWMrUyxJQUFJdGYsQ0FBSixDQUFkLENBQUosRUFBMkI7QUFDekI2akIsMEJBQW1CdkUsSUFBSXRmLENBQUosQ0FBbkIsRUFBMkI4RSxHQUEzQjtBQUNELE1BRkQsTUFFTztBQUNMQSxXQUFJd2EsSUFBSXRmLENBQUosRUFBTzZKLEdBQVgsSUFBa0J5VixJQUFJdGYsQ0FBSixFQUFPK0osRUFBekI7QUFDRDtBQUNGO0FBQ0QsVUFBT2pGLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxLQUFJZ2YsaUJBQWlCLElBQXJCO0FBQ0EsS0FBSUMsMkJBQTJCLEtBQS9COztBQUVBLFVBQVNDLGFBQVQsQ0FBd0JyVSxFQUF4QixFQUE0QjtBQUMxQixPQUFJSSxVQUFVSixHQUFHTSxRQUFqQjs7QUFFQTtBQUNBLE9BQUlnSSxTQUFTbEksUUFBUWtJLE1BQXJCO0FBQ0EsT0FBSUEsVUFBVSxDQUFDbEksUUFBUWtVLFFBQXZCLEVBQWlDO0FBQy9CLFlBQU9oTSxPQUFPaEksUUFBUCxDQUFnQmdVLFFBQWhCLElBQTRCaE0sT0FBTzFILE9BQTFDLEVBQW1EO0FBQ2pEMEgsZ0JBQVNBLE9BQU8xSCxPQUFoQjtBQUNEO0FBQ0QwSCxZQUFPaU0sU0FBUCxDQUFpQnRULElBQWpCLENBQXNCakIsRUFBdEI7QUFDRDs7QUFFREEsTUFBR1ksT0FBSCxHQUFhMEgsTUFBYjtBQUNBdEksTUFBR0csS0FBSCxHQUFXbUksU0FBU0EsT0FBT25JLEtBQWhCLEdBQXdCSCxFQUFuQzs7QUFFQUEsTUFBR3VVLFNBQUgsR0FBZSxFQUFmO0FBQ0F2VSxNQUFHd1UsS0FBSCxHQUFXLEVBQVg7O0FBRUF4VSxNQUFHeVUsUUFBSCxHQUFjLElBQWQ7QUFDQXpVLE1BQUcwVSxTQUFILEdBQWUsSUFBZjtBQUNBMVUsTUFBRzJVLGVBQUgsR0FBcUIsS0FBckI7QUFDQTNVLE1BQUc0VSxVQUFILEdBQWdCLEtBQWhCO0FBQ0E1VSxNQUFHNlUsWUFBSCxHQUFrQixLQUFsQjtBQUNBN1UsTUFBRzhVLGlCQUFILEdBQXVCLEtBQXZCO0FBQ0Q7O0FBRUQsVUFBU0MsY0FBVCxDQUF5QnpCLEdBQXpCLEVBQThCO0FBQzVCQSxPQUFJNWpCLFNBQUosQ0FBY3NsQixPQUFkLEdBQXdCLFVBQVU5RixLQUFWLEVBQWlCK0YsU0FBakIsRUFBNEI7QUFDbEQsU0FBSWpWLEtBQUssSUFBVDtBQUNBLFNBQUlBLEdBQUc0VSxVQUFQLEVBQW1CO0FBQ2pCTSxnQkFBU2xWLEVBQVQsRUFBYSxjQUFiO0FBQ0Q7QUFDRCxTQUFJbVYsU0FBU25WLEdBQUdvVixHQUFoQjtBQUNBLFNBQUlDLFlBQVlyVixHQUFHc1YsTUFBbkI7QUFDQSxTQUFJQyxxQkFBcUJwQixjQUF6QjtBQUNBQSxzQkFBaUJuVSxFQUFqQjtBQUNBQSxRQUFHc1YsTUFBSCxHQUFZcEcsS0FBWjtBQUNBO0FBQ0E7QUFDQSxTQUFJLENBQUNtRyxTQUFMLEVBQWdCO0FBQ2Q7QUFDQXJWLFVBQUdvVixHQUFILEdBQVNwVixHQUFHd1YsU0FBSCxDQUNQeFYsR0FBR29WLEdBREksRUFDQ2xHLEtBREQsRUFDUStGLFNBRFIsRUFDbUIsS0FEbkIsQ0FDeUI7QUFEekIsU0FFUGpWLEdBQUdNLFFBQUgsQ0FBWW1WLFVBRkwsRUFHUHpWLEdBQUdNLFFBQUgsQ0FBWW9WLE9BSEwsQ0FBVDtBQUtBO0FBQ0E7QUFDQTFWLFVBQUdNLFFBQUgsQ0FBWW1WLFVBQVosR0FBeUJ6VixHQUFHTSxRQUFILENBQVlvVixPQUFaLEdBQXNCLElBQS9DO0FBQ0QsTUFWRCxNQVVPO0FBQ0w7QUFDQTFWLFVBQUdvVixHQUFILEdBQVNwVixHQUFHd1YsU0FBSCxDQUFhSCxTQUFiLEVBQXdCbkcsS0FBeEIsQ0FBVDtBQUNEO0FBQ0RpRixzQkFBaUJvQixrQkFBakI7QUFDQTtBQUNBLFNBQUlKLE1BQUosRUFBWTtBQUNWQSxjQUFPUSxPQUFQLEdBQWlCLElBQWpCO0FBQ0Q7QUFDRCxTQUFJM1YsR0FBR29WLEdBQVAsRUFBWTtBQUNWcFYsVUFBR29WLEdBQUgsQ0FBT08sT0FBUCxHQUFpQjNWLEVBQWpCO0FBQ0Q7QUFDRDtBQUNBLFNBQUlBLEdBQUc0VixNQUFILElBQWE1VixHQUFHWSxPQUFoQixJQUEyQlosR0FBRzRWLE1BQUgsS0FBYzVWLEdBQUdZLE9BQUgsQ0FBVzBVLE1BQXhELEVBQWdFO0FBQzlEdFYsVUFBR1ksT0FBSCxDQUFXd1UsR0FBWCxHQUFpQnBWLEdBQUdvVixHQUFwQjtBQUNEO0FBQ0Q7QUFDQTtBQUNELElBeENEOztBQTBDQTlCLE9BQUk1akIsU0FBSixDQUFjMGlCLFlBQWQsR0FBNkIsWUFBWTtBQUN2QyxTQUFJcFMsS0FBSyxJQUFUO0FBQ0EsU0FBSUEsR0FBR3lVLFFBQVAsRUFBaUI7QUFDZnpVLFVBQUd5VSxRQUFILENBQVlyUCxNQUFaO0FBQ0Q7QUFDRixJQUxEOztBQU9Ba08sT0FBSTVqQixTQUFKLENBQWNtbUIsUUFBZCxHQUF5QixZQUFZO0FBQ25DLFNBQUk3VixLQUFLLElBQVQ7QUFDQSxTQUFJQSxHQUFHOFUsaUJBQVAsRUFBMEI7QUFDeEI7QUFDRDtBQUNESSxjQUFTbFYsRUFBVCxFQUFhLGVBQWI7QUFDQUEsUUFBRzhVLGlCQUFILEdBQXVCLElBQXZCO0FBQ0E7QUFDQSxTQUFJeE0sU0FBU3RJLEdBQUdZLE9BQWhCO0FBQ0EsU0FBSTBILFVBQVUsQ0FBQ0EsT0FBT3dNLGlCQUFsQixJQUF1QyxDQUFDOVUsR0FBR00sUUFBSCxDQUFZZ1UsUUFBeEQsRUFBa0U7QUFDaEUxYSxjQUFPME8sT0FBT2lNLFNBQWQsRUFBeUJ2VSxFQUF6QjtBQUNEO0FBQ0Q7QUFDQSxTQUFJQSxHQUFHeVUsUUFBUCxFQUFpQjtBQUNmelUsVUFBR3lVLFFBQUgsQ0FBWXFCLFFBQVo7QUFDRDtBQUNELFNBQUl6bEIsSUFBSTJQLEdBQUcrVixTQUFILENBQWF6bEIsTUFBckI7QUFDQSxZQUFPRCxHQUFQLEVBQVk7QUFDVjJQLFVBQUcrVixTQUFILENBQWExbEIsQ0FBYixFQUFnQnlsQixRQUFoQjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFNBQUk5VixHQUFHZ1csS0FBSCxDQUFTOVAsTUFBYixFQUFxQjtBQUNuQmxHLFVBQUdnVyxLQUFILENBQVM5UCxNQUFULENBQWdCUyxPQUFoQjtBQUNEO0FBQ0Q7QUFDQTNHLFFBQUc2VSxZQUFILEdBQWtCLElBQWxCO0FBQ0E7QUFDQTdVLFFBQUd3VixTQUFILENBQWF4VixHQUFHc1YsTUFBaEIsRUFBd0IsSUFBeEI7QUFDQTtBQUNBSixjQUFTbFYsRUFBVCxFQUFhLFdBQWI7QUFDQTtBQUNBQSxRQUFHbVQsSUFBSDtBQUNBO0FBQ0EsU0FBSW5ULEdBQUdvVixHQUFQLEVBQVk7QUFDVnBWLFVBQUdvVixHQUFILENBQU9PLE9BQVAsR0FBaUIsSUFBakI7QUFDRDtBQUNGLElBckNEO0FBc0NEOztBQUVELFVBQVNNLGNBQVQsQ0FDRWpXLEVBREYsRUFFRW9JLEVBRkYsRUFHRTZNLFNBSEYsRUFJRTtBQUNBalYsTUFBR29WLEdBQUgsR0FBU2hOLEVBQVQ7QUFDQSxPQUFJLENBQUNwSSxHQUFHTSxRQUFILENBQVlpTixNQUFqQixFQUF5QjtBQUN2QnZOLFFBQUdNLFFBQUgsQ0FBWWlOLE1BQVosR0FBcUJ1QixnQkFBckI7QUFDQSxTQUFJblIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDO0FBQ0EsV0FBS21DLEdBQUdNLFFBQUgsQ0FBWTRWLFFBQVosSUFBd0JsVyxHQUFHTSxRQUFILENBQVk0VixRQUFaLENBQXFCcGIsTUFBckIsQ0FBNEIsQ0FBNUIsTUFBbUMsR0FBNUQsSUFDRmtGLEdBQUdNLFFBQUgsQ0FBWThILEVBRFYsSUFDZ0JBLEVBRHBCLEVBQ3dCO0FBQ3RCM0ksY0FDRSxvRUFDQSxtRUFEQSxHQUVBLHVEQUhGLEVBSUVPLEVBSkY7QUFNRCxRQVJELE1BUU87QUFDTFAsY0FDRSxxRUFERixFQUVFTyxFQUZGO0FBSUQ7QUFDRjtBQUNGO0FBQ0RrVixZQUFTbFYsRUFBVCxFQUFhLGFBQWI7O0FBRUEsT0FBSW1XLGVBQUo7QUFDQTtBQUNBLE9BQUl4WSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkU4Six1QkFBa0IsMkJBQVk7QUFDNUIsV0FBSXZsQixPQUFPb1AsR0FBR29XLEtBQWQ7QUFDQSxXQUFJbmhCLEtBQUsrSyxHQUFHcVcsSUFBWjtBQUNBLFdBQUkxSixXQUFXLG9CQUFvQjFYLEVBQW5DO0FBQ0EsV0FBSTJYLFNBQVMsa0JBQWtCM1gsRUFBL0I7O0FBRUFvWCxZQUFLTSxRQUFMO0FBQ0EsV0FBSXVDLFFBQVFsUCxHQUFHc1csT0FBSCxFQUFaO0FBQ0FqSyxZQUFLTyxNQUFMO0FBQ0FOLGVBQVMxYixPQUFPLFNBQWhCLEVBQTRCK2IsUUFBNUIsRUFBc0NDLE1BQXRDOztBQUVBUCxZQUFLTSxRQUFMO0FBQ0EzTSxVQUFHZ1YsT0FBSCxDQUFXOUYsS0FBWCxFQUFrQitGLFNBQWxCO0FBQ0E1SSxZQUFLTyxNQUFMO0FBQ0FOLGVBQVMxYixPQUFPLFFBQWhCLEVBQTJCK2IsUUFBM0IsRUFBcUNDLE1BQXJDO0FBQ0QsTUFmRDtBQWdCRCxJQWpCRCxNQWlCTztBQUNMdUosdUJBQWtCLDJCQUFZO0FBQzVCblcsVUFBR2dWLE9BQUgsQ0FBV2hWLEdBQUdzVyxPQUFILEVBQVgsRUFBeUJyQixTQUF6QjtBQUNELE1BRkQ7QUFHRDs7QUFFRGpWLE1BQUd5VSxRQUFILEdBQWMsSUFBSThCLE9BQUosQ0FBWXZXLEVBQVosRUFBZ0JtVyxlQUFoQixFQUFpQ2xuQixJQUFqQyxDQUFkO0FBQ0FnbUIsZUFBWSxLQUFaOztBQUVBO0FBQ0E7QUFDQSxPQUFJalYsR0FBRzRWLE1BQUgsSUFBYSxJQUFqQixFQUF1QjtBQUNyQjVWLFFBQUc0VSxVQUFILEdBQWdCLElBQWhCO0FBQ0FNLGNBQVNsVixFQUFULEVBQWEsU0FBYjtBQUNEO0FBQ0QsVUFBT0EsRUFBUDtBQUNEOztBQUVELFVBQVN3VyxvQkFBVCxDQUNFeFcsRUFERixFQUVFcUksU0FGRixFQUdFd0ssU0FIRixFQUlFNEQsV0FKRixFQUtFQyxjQUxGLEVBTUU7QUFDQSxPQUFJL1ksUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDdVcsZ0NBQTJCLElBQTNCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQUl1QyxjQUFjLENBQUMsRUFDakJELGtCQUFnQztBQUNoQzFXLE1BQUdNLFFBQUgsQ0FBWXNXLGVBRFosSUFDZ0M7QUFDaENILGVBQVk3Z0IsSUFBWixDQUFpQmloQixXQUZqQixJQUVnQztBQUNoQzdXLE1BQUc4VyxZQUFILEtBQW9CblksV0FKSCxDQUllO0FBSmYsSUFBbkI7O0FBT0FxQixNQUFHTSxRQUFILENBQVl5VyxZQUFaLEdBQTJCTixXQUEzQjtBQUNBelcsTUFBRzRWLE1BQUgsR0FBWWEsV0FBWixDQWZBLENBZXlCOztBQUV6QixPQUFJelcsR0FBR3NWLE1BQVAsRUFBZTtBQUFFO0FBQ2Z0VixRQUFHc1YsTUFBSCxDQUFVaE4sTUFBVixHQUFtQm1PLFdBQW5CO0FBQ0Q7QUFDRHpXLE1BQUdNLFFBQUgsQ0FBWXNXLGVBQVosR0FBOEJGLGNBQTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBMVcsTUFBR2dYLE1BQUgsR0FBWVAsWUFBWTdnQixJQUFaLElBQW9CNmdCLFlBQVk3Z0IsSUFBWixDQUFpQjhhLEtBQWpEO0FBQ0ExUSxNQUFHaVgsVUFBSCxHQUFnQnBFLFNBQWhCOztBQUVBO0FBQ0EsT0FBSXhLLGFBQWFySSxHQUFHTSxRQUFILENBQVlrSixLQUE3QixFQUFvQztBQUNsQ2hELG1CQUFjQyxhQUFkLEdBQThCLEtBQTlCO0FBQ0EsU0FBSStDLFFBQVF4SixHQUFHMkwsTUFBZjtBQUNBLFNBQUl1TCxXQUFXbFgsR0FBR00sUUFBSCxDQUFZNlcsU0FBWixJQUF5QixFQUF4QztBQUNBLFVBQUssSUFBSTltQixJQUFJLENBQWIsRUFBZ0JBLElBQUk2bUIsU0FBUzVtQixNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDeEMsV0FBSTZKLE1BQU1nZCxTQUFTN21CLENBQVQsQ0FBVjtBQUNBbVosYUFBTXRQLEdBQU4sSUFBYStRLGFBQWEvUSxHQUFiLEVBQWtCOEYsR0FBR00sUUFBSCxDQUFZa0osS0FBOUIsRUFBcUNuQixTQUFyQyxFQUFnRHJJLEVBQWhELENBQWI7QUFDRDtBQUNEd0csbUJBQWNDLGFBQWQsR0FBOEIsSUFBOUI7QUFDQTtBQUNBekcsUUFBR00sUUFBSCxDQUFZK0gsU0FBWixHQUF3QkEsU0FBeEI7QUFDRDs7QUFFRDtBQUNBLE9BQUl3SyxTQUFKLEVBQWU7QUFDYixTQUFJTyxlQUFlcFQsR0FBR00sUUFBSCxDQUFZd1MsZ0JBQS9CO0FBQ0E5UyxRQUFHTSxRQUFILENBQVl3UyxnQkFBWixHQUErQkQsU0FBL0I7QUFDQUUsOEJBQXlCL1MsRUFBekIsRUFBNkI2UyxTQUE3QixFQUF3Q08sWUFBeEM7QUFDRDtBQUNEO0FBQ0EsT0FBSXVELFdBQUosRUFBaUI7QUFDZjNXLFFBQUdvWCxNQUFILEdBQVl2RCxhQUFhNkMsY0FBYixFQUE2QkQsWUFBWTNJLE9BQXpDLENBQVo7QUFDQTlOLFFBQUdvUyxZQUFIO0FBQ0Q7O0FBRUQsT0FBSXpVLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3VXLGdDQUEyQixLQUEzQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU2lELGdCQUFULENBQTJCclgsRUFBM0IsRUFBK0I7QUFDN0IsVUFBT0EsT0FBT0EsS0FBS0EsR0FBR1ksT0FBZixDQUFQLEVBQWdDO0FBQzlCLFNBQUlaLEdBQUcwVSxTQUFQLEVBQWtCO0FBQUUsY0FBTyxJQUFQO0FBQWE7QUFDbEM7QUFDRCxVQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFTNEMsc0JBQVQsQ0FBaUN0WCxFQUFqQyxFQUFxQ3VYLE1BQXJDLEVBQTZDO0FBQzNDLE9BQUlBLE1BQUosRUFBWTtBQUNWdlgsUUFBRzJVLGVBQUgsR0FBcUIsS0FBckI7QUFDQSxTQUFJMEMsaUJBQWlCclgsRUFBakIsQ0FBSixFQUEwQjtBQUN4QjtBQUNEO0FBQ0YsSUFMRCxNQUtPLElBQUlBLEdBQUcyVSxlQUFQLEVBQXdCO0FBQzdCO0FBQ0Q7QUFDRCxPQUFJM1UsR0FBRzBVLFNBQUgsSUFBZ0IxVSxHQUFHMFUsU0FBSCxLQUFpQixJQUFyQyxFQUEyQztBQUN6QzFVLFFBQUcwVSxTQUFILEdBQWUsS0FBZjtBQUNBLFVBQUssSUFBSXJrQixJQUFJLENBQWIsRUFBZ0JBLElBQUkyUCxHQUFHdVUsU0FBSCxDQUFhamtCLE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1Q2luQiw4QkFBdUJ0WCxHQUFHdVUsU0FBSCxDQUFhbGtCLENBQWIsQ0FBdkI7QUFDRDtBQUNENmtCLGNBQVNsVixFQUFULEVBQWEsV0FBYjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU3dYLHdCQUFULENBQW1DeFgsRUFBbkMsRUFBdUN1WCxNQUF2QyxFQUErQztBQUM3QyxPQUFJQSxNQUFKLEVBQVk7QUFDVnZYLFFBQUcyVSxlQUFILEdBQXFCLElBQXJCO0FBQ0EsU0FBSTBDLGlCQUFpQnJYLEVBQWpCLENBQUosRUFBMEI7QUFDeEI7QUFDRDtBQUNGO0FBQ0QsT0FBSSxDQUFDQSxHQUFHMFUsU0FBUixFQUFtQjtBQUNqQjFVLFFBQUcwVSxTQUFILEdBQWUsSUFBZjtBQUNBLFVBQUssSUFBSXJrQixJQUFJLENBQWIsRUFBZ0JBLElBQUkyUCxHQUFHdVUsU0FBSCxDQUFhamtCLE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1Q21uQixnQ0FBeUJ4WCxHQUFHdVUsU0FBSCxDQUFhbGtCLENBQWIsQ0FBekI7QUFDRDtBQUNENmtCLGNBQVNsVixFQUFULEVBQWEsYUFBYjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU2tWLFFBQVQsQ0FBbUJsVixFQUFuQixFQUF1QnFKLElBQXZCLEVBQTZCO0FBQzNCLE9BQUlpRSxXQUFXdE4sR0FBR00sUUFBSCxDQUFZK0ksSUFBWixDQUFmO0FBQ0EsT0FBSWlFLFFBQUosRUFBYztBQUNaLFVBQUssSUFBSWpkLElBQUksQ0FBUixFQUFXb25CLElBQUluSyxTQUFTaGQsTUFBN0IsRUFBcUNELElBQUlvbkIsQ0FBekMsRUFBNENwbkIsR0FBNUMsRUFBaUQ7QUFDL0MsV0FBSTtBQUNGaWQsa0JBQVNqZCxDQUFULEVBQVlWLElBQVosQ0FBaUJxUSxFQUFqQjtBQUNELFFBRkQsQ0FFRSxPQUFPcFEsQ0FBUCxFQUFVO0FBQ1ZzUixxQkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBb0JxSixPQUFPLE9BQTNCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsT0FBSXJKLEdBQUc0UyxhQUFQLEVBQXNCO0FBQ3BCNVMsUUFBRzJULEtBQUgsQ0FBUyxVQUFVdEssSUFBbkI7QUFDRDtBQUNGOztBQUVEOztBQUdBLEtBQUlxTyxtQkFBbUIsR0FBdkI7O0FBRUEsS0FBSUMsUUFBUSxFQUFaO0FBQ0EsS0FBSUMsb0JBQW9CLEVBQXhCO0FBQ0EsS0FBSXJULE1BQU0sRUFBVjtBQUNBLEtBQUlzVCxXQUFXLEVBQWY7QUFDQSxLQUFJQyxVQUFVLEtBQWQ7QUFDQSxLQUFJQyxXQUFXLEtBQWY7QUFDQSxLQUFJMWpCLFFBQVEsQ0FBWjs7QUFFQTs7O0FBR0EsVUFBUzJqQixtQkFBVCxHQUFnQztBQUM5QjNqQixXQUFRc2pCLE1BQU1ybkIsTUFBTixHQUFlc25CLGtCQUFrQnRuQixNQUFsQixHQUEyQixDQUFsRDtBQUNBaVUsU0FBTSxFQUFOO0FBQ0EsT0FBSTVHLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2dhLGdCQUFXLEVBQVg7QUFDRDtBQUNEQyxhQUFVQyxXQUFXLEtBQXJCO0FBQ0Q7O0FBRUQ7OztBQUdBLFVBQVNFLG1CQUFULEdBQWdDO0FBQzlCRixjQUFXLElBQVg7QUFDQSxPQUFJRyxPQUFKLEVBQWFqakIsRUFBYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EwaUIsU0FBTVEsSUFBTixDQUFXLFVBQVVoZCxDQUFWLEVBQWFXLENBQWIsRUFBZ0I7QUFBRSxZQUFPWCxFQUFFbEcsRUFBRixHQUFPNkcsRUFBRTdHLEVBQWhCO0FBQXFCLElBQWxEOztBQUVBO0FBQ0E7QUFDQSxRQUFLWixRQUFRLENBQWIsRUFBZ0JBLFFBQVFzakIsTUFBTXJuQixNQUE5QixFQUFzQytELE9BQXRDLEVBQStDO0FBQzdDNmpCLGVBQVVQLE1BQU10akIsS0FBTixDQUFWO0FBQ0FZLFVBQUtpakIsUUFBUWpqQixFQUFiO0FBQ0FzUCxTQUFJdFAsRUFBSixJQUFVLElBQVY7QUFDQWlqQixhQUFRRSxHQUFSO0FBQ0E7QUFDQSxTQUFJemEsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDMEcsSUFBSXRQLEVBQUosS0FBVyxJQUF4RCxFQUE4RDtBQUM1RDRpQixnQkFBUzVpQixFQUFULElBQWUsQ0FBQzRpQixTQUFTNWlCLEVBQVQsS0FBZ0IsQ0FBakIsSUFBc0IsQ0FBckM7QUFDQSxXQUFJNGlCLFNBQVM1aUIsRUFBVCxJQUFleWlCLGdCQUFuQixFQUFxQztBQUNuQ2pZLGNBQ0UsMkNBQ0V5WSxRQUFRRyxJQUFSLEdBQ0ssa0NBQW1DSCxRQUFRSSxVQUEzQyxHQUF5RCxJQUQ5RCxHQUVJLGlDQUhOLENBREYsRUFNRUosUUFBUWxZLEVBTlY7QUFRQTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBLE9BQUl1WSxpQkFBaUJYLGtCQUFrQjNsQixLQUFsQixFQUFyQjtBQUNBLE9BQUl1bUIsZUFBZWIsTUFBTTFsQixLQUFOLEVBQW5COztBQUVBK2xCOztBQUVBO0FBQ0FTLHNCQUFtQkYsY0FBbkI7QUFDQUcsb0JBQWlCRixZQUFqQjs7QUFFQTtBQUNBO0FBQ0EsT0FBSTFhLFlBQVlQLE9BQU9PLFFBQXZCLEVBQWlDO0FBQy9CQSxjQUFTNmEsSUFBVCxDQUFjLE9BQWQ7QUFDRDtBQUNGOztBQUVELFVBQVNELGdCQUFULENBQTJCZixLQUEzQixFQUFrQztBQUNoQyxPQUFJdG5CLElBQUlzbkIsTUFBTXJuQixNQUFkO0FBQ0EsVUFBT0QsR0FBUCxFQUFZO0FBQ1YsU0FBSTZuQixVQUFVUCxNQUFNdG5CLENBQU4sQ0FBZDtBQUNBLFNBQUkyUCxLQUFLa1ksUUFBUWxZLEVBQWpCO0FBQ0EsU0FBSUEsR0FBR3lVLFFBQUgsS0FBZ0J5RCxPQUFoQixJQUEyQmxZLEdBQUc0VSxVQUFsQyxFQUE4QztBQUM1Q00sZ0JBQVNsVixFQUFULEVBQWEsU0FBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVM0WSx1QkFBVCxDQUFrQzVZLEVBQWxDLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQUEsTUFBRzBVLFNBQUgsR0FBZSxLQUFmO0FBQ0FrRCxxQkFBa0IzVyxJQUFsQixDQUF1QmpCLEVBQXZCO0FBQ0Q7O0FBRUQsVUFBU3lZLGtCQUFULENBQTZCZCxLQUE3QixFQUFvQztBQUNsQyxRQUFLLElBQUl0bkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc25CLE1BQU1ybkIsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3JDc25CLFdBQU10bkIsQ0FBTixFQUFTcWtCLFNBQVQsR0FBcUIsSUFBckI7QUFDQTRDLDRCQUF1QkssTUFBTXRuQixDQUFOLENBQXZCLEVBQWlDLElBQWpDLENBQXNDLFVBQXRDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7QUFLQSxVQUFTd29CLFlBQVQsQ0FBdUJYLE9BQXZCLEVBQWdDO0FBQzlCLE9BQUlqakIsS0FBS2lqQixRQUFRampCLEVBQWpCO0FBQ0EsT0FBSXNQLElBQUl0UCxFQUFKLEtBQVcsSUFBZixFQUFxQjtBQUNuQnNQLFNBQUl0UCxFQUFKLElBQVUsSUFBVjtBQUNBLFNBQUksQ0FBQzhpQixRQUFMLEVBQWU7QUFDYkosYUFBTTFXLElBQU4sQ0FBV2lYLE9BQVg7QUFDRCxNQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EsV0FBSTduQixJQUFJc25CLE1BQU1ybkIsTUFBTixHQUFlLENBQXZCO0FBQ0EsY0FBT0QsSUFBSWdFLEtBQUosSUFBYXNqQixNQUFNdG5CLENBQU4sRUFBUzRFLEVBQVQsR0FBY2lqQixRQUFRampCLEVBQTFDLEVBQThDO0FBQzVDNUU7QUFDRDtBQUNEc25CLGFBQU01ZCxNQUFOLENBQWExSixJQUFJLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCNm5CLE9BQXZCO0FBQ0Q7QUFDRDtBQUNBLFNBQUksQ0FBQ0osT0FBTCxFQUFjO0FBQ1pBLGlCQUFVLElBQVY7QUFDQTlVLGdCQUFTaVYsbUJBQVQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSWEsUUFBUSxDQUFaOztBQUVBOzs7OztBQUtBLEtBQUl2QyxVQUFVLFNBQVNBLE9BQVQsQ0FDWnZXLEVBRFksRUFFWitZLE9BRlksRUFHWjdVLEVBSFksRUFJWjlELE9BSlksRUFLWjtBQUNBLFFBQUtKLEVBQUwsR0FBVUEsRUFBVjtBQUNBQSxNQUFHK1YsU0FBSCxDQUFhOVUsSUFBYixDQUFrQixJQUFsQjtBQUNBO0FBQ0EsT0FBSWIsT0FBSixFQUFhO0FBQ1gsVUFBSzRZLElBQUwsR0FBWSxDQUFDLENBQUM1WSxRQUFRNFksSUFBdEI7QUFDQSxVQUFLWCxJQUFMLEdBQVksQ0FBQyxDQUFDalksUUFBUWlZLElBQXRCO0FBQ0EsVUFBS1ksSUFBTCxHQUFZLENBQUMsQ0FBQzdZLFFBQVE2WSxJQUF0QjtBQUNBLFVBQUsvRyxJQUFMLEdBQVksQ0FBQyxDQUFDOVIsUUFBUThSLElBQXRCO0FBQ0QsSUFMRCxNQUtPO0FBQ0wsVUFBSzhHLElBQUwsR0FBWSxLQUFLWCxJQUFMLEdBQVksS0FBS1ksSUFBTCxHQUFZLEtBQUsvRyxJQUFMLEdBQVksS0FBaEQ7QUFDRDtBQUNELFFBQUtoTyxFQUFMLEdBQVVBLEVBQVY7QUFDQSxRQUFLalAsRUFBTCxHQUFVLEVBQUU2akIsS0FBWixDQWJBLENBYW1CO0FBQ25CLFFBQUtoa0IsTUFBTCxHQUFjLElBQWQ7QUFDQSxRQUFLb2tCLEtBQUwsR0FBYSxLQUFLRCxJQUFsQixDQWZBLENBZXdCO0FBQ3hCLFFBQUtFLElBQUwsR0FBWSxFQUFaO0FBQ0EsUUFBS0MsT0FBTCxHQUFlLEVBQWY7QUFDQSxRQUFLQyxNQUFMLEdBQWMsSUFBSWpWLElBQUosRUFBZDtBQUNBLFFBQUtrVixTQUFMLEdBQWlCLElBQUlsVixJQUFKLEVBQWpCO0FBQ0EsUUFBS2tVLFVBQUwsR0FBa0IzYSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsR0FDZGtiLFFBQVE1Z0IsUUFBUixFQURjLEdBRWQsRUFGSjtBQUdBO0FBQ0EsT0FBSSxPQUFPNGdCLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakMsVUFBS3JSLE1BQUwsR0FBY3FSLE9BQWQ7QUFDRCxJQUZELE1BRU87QUFDTCxVQUFLclIsTUFBTCxHQUFjckksVUFBVTBaLE9BQVYsQ0FBZDtBQUNBLFNBQUksQ0FBQyxLQUFLclIsTUFBVixFQUFrQjtBQUNoQixZQUFLQSxNQUFMLEdBQWMsWUFBWSxDQUFFLENBQTVCO0FBQ0EvSixlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2Qyw2QkFBNkJzWixPQUE3QixHQUF1QyxLQUF2QyxHQUNBLG1EQURBLEdBRUEsMkNBSHVDLEVBSXZDL1ksRUFKdUMsQ0FBekM7QUFNRDtBQUNGO0FBQ0QsUUFBS2hJLEtBQUwsR0FBYSxLQUFLaWhCLElBQUwsR0FDVGhwQixTQURTLEdBRVQsS0FBS2tTLEdBQUwsRUFGSjtBQUdELEVBOUNEOztBQWdEQTs7O0FBR0FvVSxTQUFRN21CLFNBQVIsQ0FBa0J5UyxHQUFsQixHQUF3QixTQUFTQSxHQUFULEdBQWdCO0FBQ3RDbUQsY0FBVyxJQUFYO0FBQ0EsT0FBSXROLEtBQUo7QUFDQSxPQUFJZ0ksS0FBSyxLQUFLQSxFQUFkO0FBQ0EsT0FBSTtBQUNGaEksYUFBUSxLQUFLMFAsTUFBTCxDQUFZL1gsSUFBWixDQUFpQnFRLEVBQWpCLEVBQXFCQSxFQUFyQixDQUFSO0FBQ0QsSUFGRCxDQUVFLE9BQU9wUSxDQUFQLEVBQVU7QUFDVixTQUFJLEtBQUt5b0IsSUFBVCxFQUFlO0FBQ2JuWCxtQkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBb0IsMEJBQTJCLEtBQUtzWSxVQUFoQyxHQUE4QyxJQUFsRTtBQUNELE1BRkQsTUFFTztBQUNMLGFBQU0xb0IsQ0FBTjtBQUNEO0FBQ0YsSUFSRCxTQVFVO0FBQ1I7QUFDQTtBQUNBLFNBQUksS0FBS29wQixJQUFULEVBQWU7QUFDYk8sZ0JBQVN2aEIsS0FBVDtBQUNEO0FBQ0R3TjtBQUNBLFVBQUtnVSxXQUFMO0FBQ0Q7QUFDRCxVQUFPeGhCLEtBQVA7QUFDRCxFQXRCRDs7QUF3QkE7OztBQUdBdWUsU0FBUTdtQixTQUFSLENBQWtCd1YsTUFBbEIsR0FBMkIsU0FBU0EsTUFBVCxDQUFpQm1CLEdBQWpCLEVBQXNCO0FBQy9DLE9BQUlwUixLQUFLb1IsSUFBSXBSLEVBQWI7QUFDQSxPQUFJLENBQUMsS0FBS3FrQixTQUFMLENBQWUvVSxHQUFmLENBQW1CdFAsRUFBbkIsQ0FBTCxFQUE2QjtBQUMzQixVQUFLcWtCLFNBQUwsQ0FBZTlVLEdBQWYsQ0FBbUJ2UCxFQUFuQjtBQUNBLFVBQUtta0IsT0FBTCxDQUFhblksSUFBYixDQUFrQm9GLEdBQWxCO0FBQ0EsU0FBSSxDQUFDLEtBQUtnVCxNQUFMLENBQVk5VSxHQUFaLENBQWdCdFAsRUFBaEIsQ0FBTCxFQUEwQjtBQUN4Qm9SLFdBQUl4QixNQUFKLENBQVcsSUFBWDtBQUNEO0FBQ0Y7QUFDRixFQVREOztBQVdBOzs7QUFHQTBSLFNBQVE3bUIsU0FBUixDQUFrQjhwQixXQUFsQixHQUFnQyxTQUFTQSxXQUFULEdBQXdCO0FBQ3BELE9BQUloRyxTQUFTLElBQWI7O0FBRUYsT0FBSW5qQixJQUFJLEtBQUs4b0IsSUFBTCxDQUFVN29CLE1BQWxCO0FBQ0EsVUFBT0QsR0FBUCxFQUFZO0FBQ1YsU0FBSWdXLE1BQU1tTixPQUFPMkYsSUFBUCxDQUFZOW9CLENBQVosQ0FBVjtBQUNBLFNBQUksQ0FBQ21qQixPQUFPOEYsU0FBUCxDQUFpQi9VLEdBQWpCLENBQXFCOEIsSUFBSXBSLEVBQXpCLENBQUwsRUFBbUM7QUFDakNvUixXQUFJdEIsU0FBSixDQUFjeU8sTUFBZDtBQUNEO0FBQ0Y7QUFDRCxPQUFJaUcsTUFBTSxLQUFLSixNQUFmO0FBQ0EsUUFBS0EsTUFBTCxHQUFjLEtBQUtDLFNBQW5CO0FBQ0EsUUFBS0EsU0FBTCxHQUFpQkcsR0FBakI7QUFDQSxRQUFLSCxTQUFMLENBQWU3VSxLQUFmO0FBQ0FnVixTQUFNLEtBQUtOLElBQVg7QUFDQSxRQUFLQSxJQUFMLEdBQVksS0FBS0MsT0FBakI7QUFDQSxRQUFLQSxPQUFMLEdBQWVLLEdBQWY7QUFDQSxRQUFLTCxPQUFMLENBQWE5b0IsTUFBYixHQUFzQixDQUF0QjtBQUNELEVBbEJEOztBQW9CQTs7OztBQUlBaW1CLFNBQVE3bUIsU0FBUixDQUFrQjBWLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsR0FBbUI7QUFDNUM7QUFDQSxPQUFJLEtBQUs2VCxJQUFULEVBQWU7QUFDYixVQUFLQyxLQUFMLEdBQWEsSUFBYjtBQUNELElBRkQsTUFFTyxJQUFJLEtBQUtoSCxJQUFULEVBQWU7QUFDcEIsVUFBS2tHLEdBQUw7QUFDRCxJQUZNLE1BRUE7QUFDTFMsa0JBQWEsSUFBYjtBQUNEO0FBQ0YsRUFURDs7QUFXQTs7OztBQUlBdEMsU0FBUTdtQixTQUFSLENBQWtCMG9CLEdBQWxCLEdBQXdCLFNBQVNBLEdBQVQsR0FBZ0I7QUFDdEMsT0FBSSxLQUFLdGpCLE1BQVQsRUFBaUI7QUFDZixTQUFJa0QsUUFBUSxLQUFLbUssR0FBTCxFQUFaO0FBQ0EsU0FDRW5LLFVBQVUsS0FBS0EsS0FBZjtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxjQUFTRCxLQUFULENBSkEsSUFLQSxLQUFLZ2hCLElBTlAsRUFPRTtBQUNBO0FBQ0EsV0FBSVUsV0FBVyxLQUFLMWhCLEtBQXBCO0FBQ0EsWUFBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsV0FBSSxLQUFLcWdCLElBQVQsRUFBZTtBQUNiLGFBQUk7QUFDRixnQkFBS25VLEVBQUwsQ0FBUXZVLElBQVIsQ0FBYSxLQUFLcVEsRUFBbEIsRUFBc0JoSSxLQUF0QixFQUE2QjBoQixRQUE3QjtBQUNELFVBRkQsQ0FFRSxPQUFPOXBCLENBQVAsRUFBVTtBQUNWc1IsdUJBQVl0UixDQUFaLEVBQWUsS0FBS29RLEVBQXBCLEVBQXlCLDRCQUE2QixLQUFLc1ksVUFBbEMsR0FBZ0QsSUFBekU7QUFDRDtBQUNGLFFBTkQsTUFNTztBQUNMLGNBQUtwVSxFQUFMLENBQVF2VSxJQUFSLENBQWEsS0FBS3FRLEVBQWxCLEVBQXNCaEksS0FBdEIsRUFBNkIwaEIsUUFBN0I7QUFDRDtBQUNGO0FBQ0Y7QUFDRixFQXpCRDs7QUEyQkE7Ozs7QUFJQW5ELFNBQVE3bUIsU0FBUixDQUFrQmlxQixRQUFsQixHQUE2QixTQUFTQSxRQUFULEdBQXFCO0FBQ2hELFFBQUszaEIsS0FBTCxHQUFhLEtBQUttSyxHQUFMLEVBQWI7QUFDQSxRQUFLK1csS0FBTCxHQUFhLEtBQWI7QUFDRCxFQUhEOztBQUtBOzs7QUFHQTNDLFNBQVE3bUIsU0FBUixDQUFrQnNWLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsR0FBbUI7QUFDMUMsT0FBSXdPLFNBQVMsSUFBYjs7QUFFRixPQUFJbmpCLElBQUksS0FBSzhvQixJQUFMLENBQVU3b0IsTUFBbEI7QUFDQSxVQUFPRCxHQUFQLEVBQVk7QUFDVm1qQixZQUFPMkYsSUFBUCxDQUFZOW9CLENBQVosRUFBZTJVLE1BQWY7QUFDRDtBQUNGLEVBUEQ7O0FBU0E7OztBQUdBdVIsU0FBUTdtQixTQUFSLENBQWtCb21CLFFBQWxCLEdBQTZCLFNBQVNBLFFBQVQsR0FBcUI7QUFDOUMsT0FBSXRDLFNBQVMsSUFBYjs7QUFFRixPQUFJLEtBQUsxZSxNQUFULEVBQWlCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBSSxDQUFDLEtBQUtrTCxFQUFMLENBQVE4VSxpQkFBYixFQUFnQztBQUM5QmxiLGNBQU8sS0FBS29HLEVBQUwsQ0FBUStWLFNBQWYsRUFBMEIsSUFBMUI7QUFDRDtBQUNELFNBQUkxbEIsSUFBSSxLQUFLOG9CLElBQUwsQ0FBVTdvQixNQUFsQjtBQUNBLFlBQU9ELEdBQVAsRUFBWTtBQUNWbWpCLGNBQU8yRixJQUFQLENBQVk5b0IsQ0FBWixFQUFlMFUsU0FBZixDQUF5QnlPLE1BQXpCO0FBQ0Q7QUFDRCxVQUFLMWUsTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGLEVBaEJEOztBQWtCQTs7Ozs7QUFLQSxLQUFJOGtCLGNBQWMsSUFBSXhWLElBQUosRUFBbEI7QUFDQSxVQUFTbVYsUUFBVCxDQUFtQmhoQixHQUFuQixFQUF3QjtBQUN0QnFoQixlQUFZblYsS0FBWjtBQUNBb1YsYUFBVXRoQixHQUFWLEVBQWVxaEIsV0FBZjtBQUNEOztBQUVELFVBQVNDLFNBQVQsQ0FBb0J0aEIsR0FBcEIsRUFBeUJ1aEIsSUFBekIsRUFBK0I7QUFDN0IsT0FBSXpwQixDQUFKLEVBQU82RyxJQUFQO0FBQ0EsT0FBSTZpQixNQUFNdGUsTUFBTW1CLE9BQU4sQ0FBY3JFLEdBQWQsQ0FBVjtBQUNBLE9BQUssQ0FBQ3doQixHQUFELElBQVEsQ0FBQzloQixTQUFTTSxHQUFULENBQVYsSUFBNEIsQ0FBQ3RCLE9BQU9vUSxZQUFQLENBQW9COU8sR0FBcEIsQ0FBakMsRUFBMkQ7QUFDekQ7QUFDRDtBQUNELE9BQUlBLElBQUkyTixNQUFSLEVBQWdCO0FBQ2QsU0FBSThULFFBQVF6aEIsSUFBSTJOLE1BQUosQ0FBV0csR0FBWCxDQUFlcFIsRUFBM0I7QUFDQSxTQUFJNmtCLEtBQUt2VixHQUFMLENBQVN5VixLQUFULENBQUosRUFBcUI7QUFDbkI7QUFDRDtBQUNERixVQUFLdFYsR0FBTCxDQUFTd1YsS0FBVDtBQUNEO0FBQ0QsT0FBSUQsR0FBSixFQUFTO0FBQ1AxcEIsU0FBSWtJLElBQUlqSSxNQUFSO0FBQ0EsWUFBT0QsR0FBUCxFQUFZO0FBQUV3cEIsaUJBQVV0aEIsSUFBSWxJLENBQUosQ0FBVixFQUFrQnlwQixJQUFsQjtBQUEwQjtBQUN6QyxJQUhELE1BR087QUFDTDVpQixZQUFPRCxPQUFPQyxJQUFQLENBQVlxQixHQUFaLENBQVA7QUFDQWxJLFNBQUk2RyxLQUFLNUcsTUFBVDtBQUNBLFlBQU9ELEdBQVAsRUFBWTtBQUFFd3BCLGlCQUFVdGhCLElBQUlyQixLQUFLN0csQ0FBTCxDQUFKLENBQVYsRUFBd0J5cEIsSUFBeEI7QUFBZ0M7QUFDL0M7QUFDRjs7QUFFRDs7QUFFQSxLQUFJRywyQkFBMkI7QUFDN0JqYixlQUFZLElBRGlCO0FBRTdCRyxpQkFBYyxJQUZlO0FBRzdCZ0QsUUFBS2xULElBSHdCO0FBSTdCcVYsUUFBS3JWO0FBSndCLEVBQS9COztBQU9BLFVBQVNpckIsS0FBVCxDQUFnQmpWLE1BQWhCLEVBQXdCa1YsU0FBeEIsRUFBbUNqZ0IsR0FBbkMsRUFBd0M7QUFDdEMrZiw0QkFBeUI5WCxHQUF6QixHQUErQixTQUFTaVksV0FBVCxHQUF3QjtBQUNyRCxZQUFPLEtBQUtELFNBQUwsRUFBZ0JqZ0IsR0FBaEIsQ0FBUDtBQUNELElBRkQ7QUFHQStmLDRCQUF5QjNWLEdBQXpCLEdBQStCLFNBQVMrVixXQUFULENBQXNCOWhCLEdBQXRCLEVBQTJCO0FBQ3hELFVBQUs0aEIsU0FBTCxFQUFnQmpnQixHQUFoQixJQUF1QjNCLEdBQXZCO0FBQ0QsSUFGRDtBQUdBdEIsVUFBT2dJLGNBQVAsQ0FBc0JnRyxNQUF0QixFQUE4Qi9LLEdBQTlCLEVBQW1DK2Ysd0JBQW5DO0FBQ0Q7O0FBRUQsVUFBU0ssU0FBVCxDQUFvQnRhLEVBQXBCLEVBQXdCO0FBQ3RCQSxNQUFHK1YsU0FBSCxHQUFlLEVBQWY7QUFDQSxPQUFJN1QsT0FBT2xDLEdBQUdNLFFBQWQ7QUFDQSxPQUFJNEIsS0FBS3NILEtBQVQsRUFBZ0I7QUFBRStRLGVBQVV2YSxFQUFWLEVBQWNrQyxLQUFLc0gsS0FBbkI7QUFBNEI7QUFDOUMsT0FBSXRILEtBQUt1SCxPQUFULEVBQWtCO0FBQUUrUSxpQkFBWXhhLEVBQVosRUFBZ0JrQyxLQUFLdUgsT0FBckI7QUFBZ0M7QUFDcEQsT0FBSXZILEtBQUt0TSxJQUFULEVBQWU7QUFDYjZrQixjQUFTemEsRUFBVDtBQUNELElBRkQsTUFFTztBQUNMK0QsYUFBUS9ELEdBQUdnVyxLQUFILEdBQVcsRUFBbkIsRUFBdUIsSUFBdkIsQ0FBNEIsZ0JBQTVCO0FBQ0Q7QUFDRCxPQUFJOVQsS0FBS3lILFFBQVQsRUFBbUI7QUFBRStRLGtCQUFhMWEsRUFBYixFQUFpQmtDLEtBQUt5SCxRQUF0QjtBQUFrQztBQUN2RCxPQUFJekgsS0FBS0YsS0FBTCxJQUFjRSxLQUFLRixLQUFMLEtBQWVELFdBQWpDLEVBQThDO0FBQzVDNFksZUFBVTNhLEVBQVYsRUFBY2tDLEtBQUtGLEtBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTNFksZUFBVCxDQUEwQjVhLEVBQTFCLEVBQThCcFAsSUFBOUIsRUFBb0M7QUFDbEMsT0FBSWlxQixTQUFTN2EsR0FBR00sUUFBSCxDQUFZMVAsSUFBWixDQUFiO0FBQ0EsT0FBSSxDQUFDd0gsY0FBY3lpQixNQUFkLENBQUwsRUFBNEI7QUFDMUJwYixVQUNHLHdCQUF3QjdPLElBQXhCLEdBQStCLHlCQURsQyxFQUVFb1AsRUFGRjtBQUlEO0FBQ0Y7O0FBRUQsVUFBU3VhLFNBQVQsQ0FBb0J2YSxFQUFwQixFQUF3QjhhLFlBQXhCLEVBQXNDO0FBQ3BDLE9BQUl6UyxZQUFZckksR0FBR00sUUFBSCxDQUFZK0gsU0FBWixJQUF5QixFQUF6QztBQUNBLE9BQUltQixRQUFReEosR0FBRzJMLE1BQUgsR0FBWSxFQUF4QjtBQUNBO0FBQ0E7QUFDQSxPQUFJelUsT0FBTzhJLEdBQUdNLFFBQUgsQ0FBWTZXLFNBQVosR0FBd0IsRUFBbkM7QUFDQSxPQUFJNEQsU0FBUyxDQUFDL2EsR0FBR1ksT0FBakI7QUFDQTtBQUNBNEYsaUJBQWNDLGFBQWQsR0FBOEJzVSxNQUE5QjtBQUNBLE9BQUlDLE9BQU8sU0FBUEEsSUFBTyxDQUFXOWdCLEdBQVgsRUFBaUI7QUFDMUJoRCxVQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNBLFNBQUlsQyxRQUFRaVQsYUFBYS9RLEdBQWIsRUFBa0I0Z0IsWUFBbEIsRUFBZ0N6UyxTQUFoQyxFQUEyQ3JJLEVBQTNDLENBQVo7QUFDQTtBQUNBLFNBQUlyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsV0FBSWxFLG9CQUFvQk8sR0FBcEIsS0FBNEJxRCxPQUFPYyxjQUFQLENBQXNCbkUsR0FBdEIsQ0FBaEMsRUFBNEQ7QUFDMUR1RixjQUNHLE9BQU92RixHQUFQLEdBQWEsa0VBRGhCLEVBRUU4RixFQUZGO0FBSUQ7QUFDRGdILHlCQUFrQndDLEtBQWxCLEVBQXlCdFAsR0FBekIsRUFBOEJsQyxLQUE5QixFQUFxQyxZQUFZO0FBQy9DLGFBQUlnSSxHQUFHWSxPQUFILElBQWMsQ0FBQ3dULHdCQUFuQixFQUE2QztBQUMzQzNVLGdCQUNFLDREQUNBLHdEQURBLEdBRUEsK0RBRkEsR0FHQSwrQkFIQSxHQUdrQ3ZGLEdBSGxDLEdBR3dDLElBSjFDLEVBS0U4RixFQUxGO0FBT0Q7QUFDRixRQVZEO0FBV0QsTUFsQkQsTUFrQk87QUFDTGdILHlCQUFrQndDLEtBQWxCLEVBQXlCdFAsR0FBekIsRUFBOEJsQyxLQUE5QjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsU0FBSSxFQUFFa0MsT0FBTzhGLEVBQVQsQ0FBSixFQUFrQjtBQUNoQmthLGFBQU1sYSxFQUFOLEVBQVUsUUFBVixFQUFvQjlGLEdBQXBCO0FBQ0Q7QUFDRixJQS9CRDs7QUFpQ0EsUUFBSyxJQUFJQSxHQUFULElBQWdCNGdCLFlBQWhCO0FBQThCRSxVQUFNOWdCLEdBQU47QUFBOUIsSUFDQXNNLGNBQWNDLGFBQWQsR0FBOEIsSUFBOUI7QUFDRDs7QUFFRCxVQUFTZ1UsUUFBVCxDQUFtQnphLEVBQW5CLEVBQXVCO0FBQ3JCLE9BQUlwSyxPQUFPb0ssR0FBR00sUUFBSCxDQUFZMUssSUFBdkI7QUFDQUEsVUFBT29LLEdBQUdnVyxLQUFILEdBQVcsT0FBT3BnQixJQUFQLEtBQWdCLFVBQWhCLEdBQ2RxbEIsUUFBUXJsQixJQUFSLEVBQWNvSyxFQUFkLENBRGMsR0FFZHBLLFFBQVEsRUFGWjtBQUdBLE9BQUksQ0FBQ3dDLGNBQWN4QyxJQUFkLENBQUwsRUFBMEI7QUFDeEJBLFlBQU8sRUFBUDtBQUNBK0gsYUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsOENBQ0Esb0VBRnVDLEVBR3ZDTyxFQUh1QyxDQUF6QztBQUtEO0FBQ0Q7QUFDQSxPQUFJOUksT0FBT0QsT0FBT0MsSUFBUCxDQUFZdEIsSUFBWixDQUFYO0FBQ0EsT0FBSTRULFFBQVF4SixHQUFHTSxRQUFILENBQVlrSixLQUF4QjtBQUNBLE9BQUlDLFVBQVV6SixHQUFHTSxRQUFILENBQVltSixPQUExQjtBQUNBLE9BQUlwWixJQUFJNkcsS0FBSzVHLE1BQWI7QUFDQSxVQUFPRCxHQUFQLEVBQVk7QUFDVixTQUFJNkosTUFBTWhELEtBQUs3RyxDQUFMLENBQVY7QUFDQSxTQUFJc04sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFdBQUk0TCxXQUFXeFAsT0FBT3dQLE9BQVAsRUFBZ0J2UCxHQUFoQixDQUFmLEVBQXFDO0FBQ25DdUYsY0FDRyxjQUFjdkYsR0FBZCxHQUFvQixpREFEdkIsRUFFRThGLEVBRkY7QUFJRDtBQUNGO0FBQ0QsU0FBSXdKLFNBQVN2UCxPQUFPdVAsS0FBUCxFQUFjdFAsR0FBZCxDQUFiLEVBQWlDO0FBQy9CeUQsZUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMseUJBQXlCdkYsR0FBekIsR0FBK0Isb0NBQS9CLEdBQ0EsaUNBRnVDLEVBR3ZDOEYsRUFIdUMsQ0FBekM7QUFLRCxNQU5ELE1BTU8sSUFBSSxDQUFDbkIsV0FBVzNFLEdBQVgsQ0FBTCxFQUFzQjtBQUMzQmdnQixhQUFNbGEsRUFBTixFQUFVLE9BQVYsRUFBbUI5RixHQUFuQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBNkosV0FBUW5PLElBQVIsRUFBYyxJQUFkLENBQW1CLGdCQUFuQjtBQUNEOztBQUVELFVBQVNxbEIsT0FBVCxDQUFrQnJsQixJQUFsQixFQUF3Qm9LLEVBQXhCLEVBQTRCO0FBQzFCLE9BQUk7QUFDRixZQUFPcEssS0FBS2pHLElBQUwsQ0FBVXFRLEVBQVYsQ0FBUDtBQUNELElBRkQsQ0FFRSxPQUFPcFEsQ0FBUCxFQUFVO0FBQ1ZzUixpQkFBWXRSLENBQVosRUFBZW9RLEVBQWYsRUFBbUIsUUFBbkI7QUFDQSxZQUFPLEVBQVA7QUFDRDtBQUNGOztBQUVELEtBQUlrYix5QkFBeUIsRUFBRWpDLE1BQU0sSUFBUixFQUE3Qjs7QUFFQSxVQUFTeUIsWUFBVCxDQUF1QjFhLEVBQXZCLEVBQTJCMkosUUFBM0IsRUFBcUM7QUFDbkNoTSxXQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMrYyxnQkFBZ0I1YSxFQUFoQixFQUFvQixVQUFwQixDQUF6QztBQUNBLE9BQUltYixXQUFXbmIsR0FBR29iLGlCQUFILEdBQXVCbmtCLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUF0Qzs7QUFFQSxRQUFLLElBQUlZLEdBQVQsSUFBZ0J5UCxRQUFoQixFQUEwQjtBQUN4QixTQUFJMFIsVUFBVTFSLFNBQVN6UCxHQUFULENBQWQ7QUFDQSxTQUFJd04sU0FBUyxPQUFPMlQsT0FBUCxLQUFtQixVQUFuQixHQUFnQ0EsT0FBaEMsR0FBMENBLFFBQVFsWixHQUEvRDtBQUNBLFNBQUl4RSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM2SixVQUFVLElBQXZELEVBQTZEO0FBQzNEakksWUFDRywrQ0FBK0N2RixHQUEvQyxHQUFxRCxLQUR4RCxFQUVFOEYsRUFGRjtBQUlEO0FBQ0Q7QUFDQW1iLGNBQVNqaEIsR0FBVCxJQUFnQixJQUFJcWMsT0FBSixDQUFZdlcsRUFBWixFQUFnQjBILFVBQVV6WSxJQUExQixFQUFnQ0EsSUFBaEMsRUFBc0Npc0Isc0JBQXRDLENBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQUksRUFBRWhoQixPQUFPOEYsRUFBVCxDQUFKLEVBQWtCO0FBQ2hCc2Isc0JBQWV0YixFQUFmLEVBQW1COUYsR0FBbkIsRUFBd0JtaEIsT0FBeEI7QUFDRCxNQUZELE1BRU8sSUFBSTFkLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRCxXQUFJM0QsT0FBTzhGLEdBQUd1YixLQUFkLEVBQXFCO0FBQ25COWIsY0FBTSw2QkFBNkJ2RixHQUE3QixHQUFtQyxnQ0FBekMsRUFBNEU4RixFQUE1RTtBQUNELFFBRkQsTUFFTyxJQUFJQSxHQUFHTSxRQUFILENBQVlrSixLQUFaLElBQXFCdFAsT0FBTzhGLEdBQUdNLFFBQUgsQ0FBWWtKLEtBQTVDLEVBQW1EO0FBQ3hEL0osY0FBTSw2QkFBNkJ2RixHQUE3QixHQUFtQyxrQ0FBekMsRUFBOEU4RixFQUE5RTtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVNzYixjQUFULENBQXlCclcsTUFBekIsRUFBaUMvSyxHQUFqQyxFQUFzQ21oQixPQUF0QyxFQUErQztBQUM3QyxPQUFJLE9BQU9BLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakNwQiw4QkFBeUI5WCxHQUF6QixHQUErQnFaLHFCQUFxQnRoQixHQUFyQixDQUEvQjtBQUNBK2YsOEJBQXlCM1YsR0FBekIsR0FBK0JyVixJQUEvQjtBQUNELElBSEQsTUFHTztBQUNMZ3JCLDhCQUF5QjlYLEdBQXpCLEdBQStCa1osUUFBUWxaLEdBQVIsR0FDM0JrWixRQUFRaGhCLEtBQVIsS0FBa0IsS0FBbEIsR0FDRW1oQixxQkFBcUJ0aEIsR0FBckIsQ0FERixHQUVFbWhCLFFBQVFsWixHQUhpQixHQUkzQmxULElBSko7QUFLQWdyQiw4QkFBeUIzVixHQUF6QixHQUErQitXLFFBQVEvVyxHQUFSLEdBQzNCK1csUUFBUS9XLEdBRG1CLEdBRTNCclYsSUFGSjtBQUdEO0FBQ0QsT0FBSTBPLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUNBb2MseUJBQXlCM1YsR0FBekIsS0FBaUNyVixJQURyQyxFQUMyQztBQUN6Q2dyQiw4QkFBeUIzVixHQUF6QixHQUErQixZQUFZO0FBQ3pDN0UsWUFDRyx5QkFBeUJ2RixHQUF6QixHQUErQiwwQ0FEbEMsRUFFRSxJQUZGO0FBSUQsTUFMRDtBQU1EO0FBQ0RqRCxVQUFPZ0ksY0FBUCxDQUFzQmdHLE1BQXRCLEVBQThCL0ssR0FBOUIsRUFBbUMrZix3QkFBbkM7QUFDRDs7QUFFRCxVQUFTdUIsb0JBQVQsQ0FBK0J0aEIsR0FBL0IsRUFBb0M7QUFDbEMsVUFBTyxTQUFTdWhCLGNBQVQsR0FBMkI7QUFDaEMsU0FBSXZELFVBQVUsS0FBS2tELGlCQUFMLElBQTBCLEtBQUtBLGlCQUFMLENBQXVCbGhCLEdBQXZCLENBQXhDO0FBQ0EsU0FBSWdlLE9BQUosRUFBYTtBQUNYLFdBQUlBLFFBQVFnQixLQUFaLEVBQW1CO0FBQ2pCaEIsaUJBQVF5QixRQUFSO0FBQ0Q7QUFDRCxXQUFJaFYsSUFBSU0sTUFBUixFQUFnQjtBQUNkaVQsaUJBQVFsVCxNQUFSO0FBQ0Q7QUFDRCxjQUFPa1QsUUFBUWxnQixLQUFmO0FBQ0Q7QUFDRixJQVhEO0FBWUQ7O0FBRUQsVUFBU3dpQixXQUFULENBQXNCeGEsRUFBdEIsRUFBMEJ5SixPQUExQixFQUFtQztBQUNqQzlMLFdBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QytjLGdCQUFnQjVhLEVBQWhCLEVBQW9CLFNBQXBCLENBQXpDO0FBQ0EsT0FBSXdKLFFBQVF4SixHQUFHTSxRQUFILENBQVlrSixLQUF4QjtBQUNBLFFBQUssSUFBSXRQLEdBQVQsSUFBZ0J1UCxPQUFoQixFQUF5QjtBQUN2QnpKLFFBQUc5RixHQUFILElBQVV1UCxRQUFRdlAsR0FBUixLQUFnQixJQUFoQixHQUF1QmpMLElBQXZCLEdBQThCTyxLQUFLaWEsUUFBUXZQLEdBQVIsQ0FBTCxFQUFtQjhGLEVBQW5CLENBQXhDO0FBQ0EsU0FBSXJDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJNEwsUUFBUXZQLEdBQVIsS0FBZ0IsSUFBcEIsRUFBMEI7QUFDeEJ1RixjQUNFLGNBQWN2RixHQUFkLEdBQW9CLHlEQUFwQixHQUNBLDJDQUZGLEVBR0U4RixFQUhGO0FBS0Q7QUFDRCxXQUFJd0osU0FBU3ZQLE9BQU91UCxLQUFQLEVBQWN0UCxHQUFkLENBQWIsRUFBaUM7QUFDL0J1RixjQUNHLGNBQWN2RixHQUFkLEdBQW9CLHdDQUR2QixFQUVFOEYsRUFGRjtBQUlEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVMyYSxTQUFULENBQW9CM2EsRUFBcEIsRUFBd0JnQyxLQUF4QixFQUErQjtBQUM3QnJFLFdBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QytjLGdCQUFnQjVhLEVBQWhCLEVBQW9CLE9BQXBCLENBQXpDO0FBQ0EsUUFBSyxJQUFJOUYsR0FBVCxJQUFnQjhILEtBQWhCLEVBQXVCO0FBQ3JCLFNBQUkwWixVQUFVMVosTUFBTTlILEdBQU4sQ0FBZDtBQUNBLFNBQUl1QixNQUFNbUIsT0FBTixDQUFjOGUsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFlBQUssSUFBSXJyQixJQUFJLENBQWIsRUFBZ0JBLElBQUlxckIsUUFBUXByQixNQUE1QixFQUFvQ0QsR0FBcEMsRUFBeUM7QUFDdkNzckIsdUJBQWMzYixFQUFkLEVBQWtCOUYsR0FBbEIsRUFBdUJ3aEIsUUFBUXJyQixDQUFSLENBQXZCO0FBQ0Q7QUFDRixNQUpELE1BSU87QUFDTHNyQixxQkFBYzNiLEVBQWQsRUFBa0I5RixHQUFsQixFQUF1QndoQixPQUF2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxVQUFTQyxhQUFULENBQ0UzYixFQURGLEVBRUU0YixPQUZGLEVBR0VGLE9BSEYsRUFJRXRiLE9BSkYsRUFLRTtBQUNBLE9BQUloSSxjQUFjc2pCLE9BQWQsQ0FBSixFQUE0QjtBQUMxQnRiLGVBQVVzYixPQUFWO0FBQ0FBLGVBQVVBLFFBQVFBLE9BQWxCO0FBQ0Q7QUFDRCxPQUFJLE9BQU9BLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0JBLGVBQVUxYixHQUFHMGIsT0FBSCxDQUFWO0FBQ0Q7QUFDRCxVQUFPMWIsR0FBRzZiLE1BQUgsQ0FBVUQsT0FBVixFQUFtQkYsT0FBbkIsRUFBNEJ0YixPQUE1QixDQUFQO0FBQ0Q7O0FBRUQsVUFBUzBiLFVBQVQsQ0FBcUJ4SSxHQUFyQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFJeUksVUFBVSxFQUFkO0FBQ0FBLFdBQVE1WixHQUFSLEdBQWMsWUFBWTtBQUFFLFlBQU8sS0FBSzZULEtBQVo7QUFBbUIsSUFBL0M7QUFDQSxPQUFJZ0csV0FBVyxFQUFmO0FBQ0FBLFlBQVM3WixHQUFULEdBQWUsWUFBWTtBQUFFLFlBQU8sS0FBS3dKLE1BQVo7QUFBb0IsSUFBakQ7QUFDQSxPQUFJaE8sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDa2UsYUFBUXpYLEdBQVIsR0FBYyxVQUFVMlgsT0FBVixFQUFtQjtBQUMvQnhjLFlBQ0UsMENBQ0EscUNBRkYsRUFHRSxJQUhGO0FBS0QsTUFORDtBQU9BdWMsY0FBUzFYLEdBQVQsR0FBZSxZQUFZO0FBQ3pCN0UsWUFBSyxxQkFBTCxFQUE0QixJQUE1QjtBQUNELE1BRkQ7QUFHRDtBQUNEeEksVUFBT2dJLGNBQVAsQ0FBc0JxVSxJQUFJNWpCLFNBQTFCLEVBQXFDLE9BQXJDLEVBQThDcXNCLE9BQTlDO0FBQ0E5a0IsVUFBT2dJLGNBQVAsQ0FBc0JxVSxJQUFJNWpCLFNBQTFCLEVBQXFDLFFBQXJDLEVBQStDc3NCLFFBQS9DOztBQUVBMUksT0FBSTVqQixTQUFKLENBQWN3c0IsSUFBZCxHQUFxQjVYLEdBQXJCO0FBQ0FnUCxPQUFJNWpCLFNBQUosQ0FBY3lzQixPQUFkLEdBQXdCalUsR0FBeEI7O0FBRUFvTCxPQUFJNWpCLFNBQUosQ0FBY21zQixNQUFkLEdBQXVCLFVBQ3JCOUMsT0FEcUIsRUFFckI3VSxFQUZxQixFQUdyQjlELE9BSHFCLEVBSXJCO0FBQ0EsU0FBSUosS0FBSyxJQUFUO0FBQ0EsU0FBSTVILGNBQWM4TCxFQUFkLENBQUosRUFBdUI7QUFDckIsY0FBT3lYLGNBQWMzYixFQUFkLEVBQWtCK1ksT0FBbEIsRUFBMkI3VSxFQUEzQixFQUErQjlELE9BQS9CLENBQVA7QUFDRDtBQUNEQSxlQUFVQSxXQUFXLEVBQXJCO0FBQ0FBLGFBQVFpWSxJQUFSLEdBQWUsSUFBZjtBQUNBLFNBQUlILFVBQVUsSUFBSTNCLE9BQUosQ0FBWXZXLEVBQVosRUFBZ0IrWSxPQUFoQixFQUF5QjdVLEVBQXpCLEVBQTZCOUQsT0FBN0IsQ0FBZDtBQUNBLFNBQUlBLFFBQVFnYyxTQUFaLEVBQXVCO0FBQ3JCbFksVUFBR3ZVLElBQUgsQ0FBUXFRLEVBQVIsRUFBWWtZLFFBQVFsZ0IsS0FBcEI7QUFDRDtBQUNELFlBQU8sU0FBU3FrQixTQUFULEdBQXNCO0FBQzNCbkUsZUFBUXBDLFFBQVI7QUFDRCxNQUZEO0FBR0QsSUFsQkQ7QUFtQkQ7O0FBRUQ7O0FBRUEsVUFBU3dHLFdBQVQsQ0FBc0J0YyxFQUF0QixFQUEwQjtBQUN4QixPQUFJNEosVUFBVTVKLEdBQUdNLFFBQUgsQ0FBWXNKLE9BQTFCO0FBQ0EsT0FBSUEsT0FBSixFQUFhO0FBQ1g1SixRQUFHdWMsU0FBSCxHQUFlLE9BQU8zUyxPQUFQLEtBQW1CLFVBQW5CLEdBQ1hBLFFBQVFqYSxJQUFSLENBQWFxUSxFQUFiLENBRFcsR0FFWDRKLE9BRko7QUFHRDtBQUNGOztBQUVELFVBQVM0UyxjQUFULENBQXlCeGMsRUFBekIsRUFBNkI7QUFDM0IsT0FBSWdHLFNBQVN5VyxjQUFjemMsR0FBR00sUUFBSCxDQUFZb0osTUFBMUIsRUFBa0MxSixFQUFsQyxDQUFiO0FBQ0EsT0FBSWdHLE1BQUosRUFBWTtBQUNWUSxtQkFBY0MsYUFBZCxHQUE4QixLQUE5QjtBQUNBeFAsWUFBT0MsSUFBUCxDQUFZOE8sTUFBWixFQUFvQjdPLE9BQXBCLENBQTRCLFVBQVUrQyxHQUFWLEVBQWU7QUFDekM7QUFDQSxXQUFJeUQsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbUosMkJBQWtCaEgsRUFBbEIsRUFBc0I5RixHQUF0QixFQUEyQjhMLE9BQU85TCxHQUFQLENBQTNCLEVBQXdDLFlBQVk7QUFDbER1RixnQkFDRSx5RUFDQSwwREFEQSxHQUVBLDZCQUZBLEdBRWdDdkYsR0FGaEMsR0FFc0MsSUFIeEMsRUFJRThGLEVBSkY7QUFNRCxVQVBEO0FBUUQsUUFURCxNQVNPO0FBQ0xnSCwyQkFBa0JoSCxFQUFsQixFQUFzQjlGLEdBQXRCLEVBQTJCOEwsT0FBTzlMLEdBQVAsQ0FBM0I7QUFDRDtBQUNGLE1BZEQ7QUFlQXNNLG1CQUFjQyxhQUFkLEdBQThCLElBQTlCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTZ1csYUFBVCxDQUF3Qi9TLE1BQXhCLEVBQWdDMUosRUFBaEMsRUFBb0M7QUFDbEMsT0FBSTBKLE1BQUosRUFBWTtBQUNWO0FBQ0EsU0FBSTFELFNBQVMvTyxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNBLFNBQUlwQyxPQUFPMEwsWUFDTEUsUUFBUUMsT0FBUixDQUFnQjJHLE1BQWhCLENBREssR0FFTHpTLE9BQU9DLElBQVAsQ0FBWXdTLE1BQVosQ0FGTjs7QUFJQSxVQUFLLElBQUlyWixJQUFJLENBQWIsRUFBZ0JBLElBQUk2RyxLQUFLNUcsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDLFdBQUk2SixNQUFNaEQsS0FBSzdHLENBQUwsQ0FBVjtBQUNBLFdBQUlxc0IsYUFBYWhULE9BQU94UCxHQUFQLENBQWpCO0FBQ0EsV0FBSXlpQixTQUFTM2MsRUFBYjtBQUNBLGNBQU8yYyxNQUFQLEVBQWU7QUFDYixhQUFJQSxPQUFPSixTQUFQLElBQW9CRyxjQUFjQyxPQUFPSixTQUE3QyxFQUF3RDtBQUN0RHZXLGtCQUFPOUwsR0FBUCxJQUFjeWlCLE9BQU9KLFNBQVAsQ0FBaUJHLFVBQWpCLENBQWQ7QUFDQTtBQUNEO0FBQ0RDLGtCQUFTQSxPQUFPL2IsT0FBaEI7QUFDRDtBQUNELFdBQUlqRCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQzhlLE1BQTlDLEVBQXNEO0FBQ3BEbGQsY0FBTSxpQkFBaUJ2RixHQUFqQixHQUF1QixjQUE3QixFQUE4QzhGLEVBQTlDO0FBQ0Q7QUFDRjtBQUNELFlBQU9nRyxNQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxVQUFTNFcseUJBQVQsQ0FDRWphLElBREYsRUFFRTBGLFNBRkYsRUFHRXpTLElBSEYsRUFJRWtZLE9BSkYsRUFLRUgsUUFMRixFQU1FO0FBQ0EsT0FBSW5FLFFBQVEsRUFBWjtBQUNBLE9BQUkwQixjQUFjdkksS0FBS3ZDLE9BQUwsQ0FBYW9KLEtBQS9CO0FBQ0EsT0FBSTVSLE1BQU1zVCxXQUFOLENBQUosRUFBd0I7QUFDdEIsVUFBSyxJQUFJaFIsR0FBVCxJQUFnQmdSLFdBQWhCLEVBQTZCO0FBQzNCMUIsYUFBTXRQLEdBQU4sSUFBYStRLGFBQWEvUSxHQUFiLEVBQWtCZ1IsV0FBbEIsRUFBK0I3QyxhQUFhLEVBQTVDLENBQWI7QUFDRDtBQUNGLElBSkQsTUFJTztBQUNMLFNBQUl6USxNQUFNaEMsS0FBSzhhLEtBQVgsQ0FBSixFQUF1QjtBQUFFbU0sa0JBQVdyVCxLQUFYLEVBQWtCNVQsS0FBSzhhLEtBQXZCO0FBQWdDO0FBQ3pELFNBQUk5WSxNQUFNaEMsS0FBSzRULEtBQVgsQ0FBSixFQUF1QjtBQUFFcVQsa0JBQVdyVCxLQUFYLEVBQWtCNVQsS0FBSzRULEtBQXZCO0FBQWdDO0FBQzFEO0FBQ0Q7QUFDQTtBQUNBLE9BQUlzVCxXQUFXN2xCLE9BQU9xQyxNQUFQLENBQWN3VSxPQUFkLENBQWY7QUFDQSxPQUFJaVAsSUFBSSxTQUFKQSxDQUFJLENBQVU1aEIsQ0FBVixFQUFhVyxDQUFiLEVBQWdCbEIsQ0FBaEIsRUFBbUJyRSxDQUFuQixFQUFzQjtBQUFFLFlBQU95bUIsY0FBY0YsUUFBZCxFQUF3QjNoQixDQUF4QixFQUEyQlcsQ0FBM0IsRUFBOEJsQixDQUE5QixFQUFpQ3JFLENBQWpDLEVBQW9DLElBQXBDLENBQVA7QUFBbUQsSUFBbkY7QUFDQSxPQUFJMlksUUFBUXZNLEtBQUt2QyxPQUFMLENBQWFtTixNQUFiLENBQW9CNWQsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0JvdEIsQ0FBL0IsRUFBa0M7QUFDNUNubkIsV0FBTUEsSUFEc0M7QUFFNUM0VCxZQUFPQSxLQUZxQztBQUc1Q21FLGVBQVVBLFFBSGtDO0FBSTVDckYsYUFBUXdGLE9BSm9DO0FBSzVDK0UsZ0JBQVdqZCxLQUFLbWEsRUFBTCxJQUFXLEVBTHNCO0FBTTVDa04saUJBQVlSLGNBQWM5WixLQUFLdkMsT0FBTCxDQUFhc0osTUFBM0IsRUFBbUNvRSxPQUFuQyxDQU5nQztBQU81Q2dHLFlBQU8saUJBQVk7QUFBRSxjQUFPRCxhQUFhbEcsUUFBYixFQUF1QkcsT0FBdkIsQ0FBUDtBQUF5QztBQVBsQixJQUFsQyxDQUFaO0FBU0EsT0FBSW9CLGlCQUFpQnhCLEtBQXJCLEVBQTRCO0FBQzFCd0IsV0FBTWhCLGlCQUFOLEdBQTBCSixPQUExQjtBQUNBb0IsV0FBTWdPLGlCQUFOLEdBQTBCdmEsS0FBS3ZDLE9BQS9CO0FBQ0EsU0FBSXhLLEtBQUtvZSxJQUFULEVBQWU7QUFDYixRQUFDOUUsTUFBTXRaLElBQU4sS0FBZXNaLE1BQU10WixJQUFOLEdBQWEsRUFBNUIsQ0FBRCxFQUFrQ29lLElBQWxDLEdBQXlDcGUsS0FBS29lLElBQTlDO0FBQ0Q7QUFDRjtBQUNELFVBQU85RSxLQUFQO0FBQ0Q7O0FBRUQsVUFBUzJOLFVBQVQsQ0FBcUJsaEIsRUFBckIsRUFBeUIrTSxJQUF6QixFQUErQjtBQUM3QixRQUFLLElBQUl4TyxHQUFULElBQWdCd08sSUFBaEIsRUFBc0I7QUFDcEIvTSxRQUFHbEIsU0FBU1AsR0FBVCxDQUFILElBQW9Cd08sS0FBS3hPLEdBQUwsQ0FBcEI7QUFDRDtBQUNGOztBQUVEOztBQUVBO0FBQ0EsS0FBSWlqQixzQkFBc0I7QUFDeEJDLFNBQU0sU0FBU0EsSUFBVCxDQUNKbE8sS0FESSxFQUVKK0YsU0FGSSxFQUdKb0ksU0FISSxFQUlKQyxNQUpJLEVBS0o7QUFDQSxTQUFJLENBQUNwTyxNQUFNZixpQkFBUCxJQUE0QmUsTUFBTWYsaUJBQU4sQ0FBd0IwRyxZQUF4RCxFQUFzRTtBQUNwRSxXQUFJdE0sUUFBUTJHLE1BQU1mLGlCQUFOLEdBQTBCb1AsZ0NBQ3BDck8sS0FEb0MsRUFFcENpRixjQUZvQyxFQUdwQ2tKLFNBSG9DLEVBSXBDQyxNQUpvQyxDQUF0QztBQU1BL1UsYUFBTWlWLE1BQU4sQ0FBYXZJLFlBQVkvRixNQUFNckIsR0FBbEIsR0FBd0I1ZCxTQUFyQyxFQUFnRGdsQixTQUFoRDtBQUNELE1BUkQsTUFRTyxJQUFJL0YsTUFBTXRaLElBQU4sQ0FBVzZuQixTQUFmLEVBQTBCO0FBQy9CO0FBQ0EsV0FBSUMsY0FBY3hPLEtBQWxCLENBRitCLENBRU47QUFDekJpTywyQkFBb0JRLFFBQXBCLENBQTZCRCxXQUE3QixFQUEwQ0EsV0FBMUM7QUFDRDtBQUNGLElBcEJ1Qjs7QUFzQnhCQyxhQUFVLFNBQVNBLFFBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCMU8sS0FBN0IsRUFBb0M7QUFDNUMsU0FBSTlPLFVBQVU4TyxNQUFNbkIsZ0JBQXBCO0FBQ0EsU0FBSXhGLFFBQVEyRyxNQUFNZixpQkFBTixHQUEwQnlQLFNBQVN6UCxpQkFBL0M7QUFDQXFJLDBCQUNFak8sS0FERixFQUVFbkksUUFBUWlJLFNBRlYsRUFFcUI7QUFDbkJqSSxhQUFReVMsU0FIVixFQUdxQjtBQUNuQjNELFVBSkYsRUFJUztBQUNQOU8sYUFBUXVOLFFBTFYsQ0FLbUI7QUFMbkI7QUFPRCxJQWhDdUI7O0FBa0N4QmtRLFdBQVEsU0FBU0EsTUFBVCxDQUFpQjNPLEtBQWpCLEVBQXdCO0FBQzlCLFNBQUlwQixVQUFVb0IsTUFBTXBCLE9BQXBCO0FBQ0EsU0FBSUssb0JBQW9CZSxNQUFNZixpQkFBOUI7QUFDQSxTQUFJLENBQUNBLGtCQUFrQnlHLFVBQXZCLEVBQW1DO0FBQ2pDekcseUJBQWtCeUcsVUFBbEIsR0FBK0IsSUFBL0I7QUFDQU0sZ0JBQVMvRyxpQkFBVCxFQUE0QixTQUE1QjtBQUNEO0FBQ0QsU0FBSWUsTUFBTXRaLElBQU4sQ0FBVzZuQixTQUFmLEVBQTBCO0FBQ3hCLFdBQUkzUCxRQUFROEcsVUFBWixFQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FnRSxpQ0FBd0J6SyxpQkFBeEI7QUFDRCxRQVBELE1BT087QUFDTG1KLGdDQUF1Qm5KLGlCQUF2QixFQUEwQyxJQUExQyxDQUErQyxZQUEvQztBQUNEO0FBQ0Y7QUFDRixJQXJEdUI7O0FBdUR4QjJQLFlBQVMsU0FBU0EsT0FBVCxDQUFrQjVPLEtBQWxCLEVBQXlCO0FBQ2hDLFNBQUlmLG9CQUFvQmUsTUFBTWYsaUJBQTlCO0FBQ0EsU0FBSSxDQUFDQSxrQkFBa0IwRyxZQUF2QixFQUFxQztBQUNuQyxXQUFJLENBQUMzRixNQUFNdFosSUFBTixDQUFXNm5CLFNBQWhCLEVBQTJCO0FBQ3pCdFAsMkJBQWtCMEgsUUFBbEI7QUFDRCxRQUZELE1BRU87QUFDTDJCLGtDQUF5QnJKLGlCQUF6QixFQUE0QyxJQUE1QyxDQUFpRCxZQUFqRDtBQUNEO0FBQ0Y7QUFDRjtBQWhFdUIsRUFBMUI7O0FBbUVBLEtBQUk0UCxlQUFlOW1CLE9BQU9DLElBQVAsQ0FBWWltQixtQkFBWixDQUFuQjs7QUFFQSxVQUFTYSxlQUFULENBQ0VyYixJQURGLEVBRUUvTSxJQUZGLEVBR0VrWSxPQUhGLEVBSUVILFFBSkYsRUFLRWpCLEdBTEYsRUFNRTtBQUNBLE9BQUloVixRQUFRaUwsSUFBUixDQUFKLEVBQW1CO0FBQ2pCO0FBQ0Q7O0FBRUQsT0FBSWlQLFdBQVc5RCxRQUFReE4sUUFBUixDQUFpQjJkLEtBQWhDOztBQUVBO0FBQ0EsT0FBSWhtQixTQUFTMEssSUFBVCxDQUFKLEVBQW9CO0FBQ2xCQSxZQUFPaVAsU0FBU2xXLE1BQVQsQ0FBZ0JpSCxJQUFoQixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQUksT0FBT0EsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QixTQUFJaEYsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNEIsWUFBTSxtQ0FBb0MxRyxPQUFPNEosSUFBUCxDQUExQyxFQUEwRG1MLE9BQTFEO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBSUUsWUFBSjtBQUNBLE9BQUl0VyxRQUFRaUwsS0FBS3ViLEdBQWIsQ0FBSixFQUF1QjtBQUNyQmxRLG9CQUFlckwsSUFBZjtBQUNBQSxZQUFPZ1Asc0JBQXNCM0QsWUFBdEIsRUFBb0M0RCxRQUFwQyxFQUE4QzlELE9BQTlDLENBQVA7QUFDQSxTQUFJbkwsU0FBUzFTLFNBQWIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBT3loQix1QkFDTDFELFlBREssRUFFTHBZLElBRkssRUFHTGtZLE9BSEssRUFJTEgsUUFKSyxFQUtMakIsR0FMSyxDQUFQO0FBT0Q7QUFDRjs7QUFFRDlXLFVBQU9BLFFBQVEsRUFBZjs7QUFFQTtBQUNBO0FBQ0F1b0IsNkJBQTBCeGIsSUFBMUI7O0FBRUE7QUFDQSxPQUFJL0ssTUFBTWhDLEtBQUt3b0IsS0FBWCxDQUFKLEVBQXVCO0FBQ3JCQyxvQkFBZTFiLEtBQUt2QyxPQUFwQixFQUE2QnhLLElBQTdCO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFJeVMsWUFBWW9JLDBCQUEwQjdhLElBQTFCLEVBQWdDK00sSUFBaEMsRUFBc0MrSixHQUF0QyxDQUFoQjs7QUFFQTtBQUNBLE9BQUk3VSxPQUFPOEssS0FBS3ZDLE9BQUwsQ0FBYWtlLFVBQXBCLENBQUosRUFBcUM7QUFDbkMsWUFBTzFCLDBCQUEwQmphLElBQTFCLEVBQWdDMEYsU0FBaEMsRUFBMkN6UyxJQUEzQyxFQUFpRGtZLE9BQWpELEVBQTBESCxRQUExRCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQUlrRixZQUFZamQsS0FBS21hLEVBQXJCO0FBQ0E7QUFDQTtBQUNBbmEsUUFBS21hLEVBQUwsR0FBVW5hLEtBQUsyb0IsUUFBZjs7QUFFQSxPQUFJMW1CLE9BQU84SyxLQUFLdkMsT0FBTCxDQUFha1UsUUFBcEIsQ0FBSixFQUFtQztBQUNqQztBQUNBOztBQUVBO0FBQ0EsU0FBSU4sT0FBT3BlLEtBQUtvZSxJQUFoQjtBQUNBcGUsWUFBTyxFQUFQO0FBQ0EsU0FBSW9lLElBQUosRUFBVTtBQUNScGUsWUFBS29lLElBQUwsR0FBWUEsSUFBWjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQXdLLGNBQVc1b0IsSUFBWDs7QUFFQTtBQUNBLE9BQUloRixPQUFPK1IsS0FBS3ZDLE9BQUwsQ0FBYXhQLElBQWIsSUFBcUI4YixHQUFoQztBQUNBLE9BQUl3QyxRQUFRLElBQUl4QixLQUFKLENBQ1QsbUJBQW9CL0ssS0FBS3ViLEdBQXpCLElBQWlDdHRCLE9BQVEsTUFBTUEsSUFBZCxHQUFzQixFQUF2RCxDQURTLEVBRVZnRixJQUZVLEVBRUozRixTQUZJLEVBRU9BLFNBRlAsRUFFa0JBLFNBRmxCLEVBRTZCNmQsT0FGN0IsRUFHVixFQUFFbkwsTUFBTUEsSUFBUixFQUFjMEYsV0FBV0EsU0FBekIsRUFBb0N3SyxXQUFXQSxTQUEvQyxFQUEwRG5HLEtBQUtBLEdBQS9ELEVBQW9FaUIsVUFBVUEsUUFBOUUsRUFIVSxFQUlWSyxZQUpVLENBQVo7QUFNQSxVQUFPa0IsS0FBUDtBQUNEOztBQUVELFVBQVNxTywrQkFBVCxDQUNFck8sS0FERixFQUNTO0FBQ1A1RyxPQUZGLEVBRVU7QUFDUitVLFVBSEYsRUFJRUMsTUFKRixFQUtFO0FBQ0EsT0FBSW1CLHdCQUF3QnZQLE1BQU1uQixnQkFBbEM7QUFDQSxPQUFJM04sVUFBVTtBQUNac2UsbUJBQWMsSUFERjtBQUVacFcsYUFBUUEsTUFGSTtBQUdaRCxnQkFBV29XLHNCQUFzQnBXLFNBSHJCO0FBSVo5SCxvQkFBZWtlLHNCQUFzQi9SLEdBSnpCO0FBS1pxSyxtQkFBYzdILEtBTEY7QUFNWjRELHVCQUFrQjJMLHNCQUFzQjVMLFNBTjVCO0FBT1orRCxzQkFBaUI2SCxzQkFBc0I5USxRQVAzQjtBQVFaOEgsaUJBQVk0SCxhQUFhLElBUmI7QUFTWjNILGNBQVM0SCxVQUFVO0FBVFAsSUFBZDtBQVdBO0FBQ0EsT0FBSXFCLGlCQUFpQnpQLE1BQU10WixJQUFOLENBQVcrb0IsY0FBaEM7QUFDQSxPQUFJL21CLE1BQU0rbUIsY0FBTixDQUFKLEVBQTJCO0FBQ3pCdmUsYUFBUW1OLE1BQVIsR0FBaUJvUixlQUFlcFIsTUFBaEM7QUFDQW5OLGFBQVF3ZSxlQUFSLEdBQTBCRCxlQUFlQyxlQUF6QztBQUNEO0FBQ0QsVUFBTyxJQUFJSCxzQkFBc0I5YixJQUExQixDQUErQnZDLE9BQS9CLENBQVA7QUFDRDs7QUFFRCxVQUFTb2UsVUFBVCxDQUFxQjVvQixJQUFyQixFQUEyQjtBQUN6QixPQUFJLENBQUNBLEtBQUt5VCxJQUFWLEVBQWdCO0FBQ2R6VCxVQUFLeVQsSUFBTCxHQUFZLEVBQVo7QUFDRDtBQUNELFFBQUssSUFBSWhaLElBQUksQ0FBYixFQUFnQkEsSUFBSTB0QixhQUFhenRCLE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1QyxTQUFJNkosTUFBTTZqQixhQUFhMXRCLENBQWIsQ0FBVjtBQUNBLFNBQUl3dUIsYUFBYWpwQixLQUFLeVQsSUFBTCxDQUFVblAsR0FBVixDQUFqQjtBQUNBLFNBQUk0a0IsT0FBTzNCLG9CQUFvQmpqQixHQUFwQixDQUFYO0FBQ0F0RSxVQUFLeVQsSUFBTCxDQUFVblAsR0FBVixJQUFpQjJrQixhQUFhRSxZQUFZRCxJQUFaLEVBQWtCRCxVQUFsQixDQUFiLEdBQTZDQyxJQUE5RDtBQUNEO0FBQ0Y7O0FBRUQsVUFBU0MsV0FBVCxDQUFzQkMsR0FBdEIsRUFBMkJDLEdBQTNCLEVBQWdDO0FBQzlCLFVBQU8sVUFBVTlqQixDQUFWLEVBQWFXLENBQWIsRUFBZ0JsQixDQUFoQixFQUFtQnJFLENBQW5CLEVBQXNCO0FBQzNCeW9CLFNBQUk3akIsQ0FBSixFQUFPVyxDQUFQLEVBQVVsQixDQUFWLEVBQWFyRSxDQUFiO0FBQ0Ewb0IsU0FBSTlqQixDQUFKLEVBQU9XLENBQVAsRUFBVWxCLENBQVYsRUFBYXJFLENBQWI7QUFDRCxJQUhEO0FBSUQ7O0FBRUQ7QUFDQTtBQUNBLFVBQVM4bkIsY0FBVCxDQUF5QmplLE9BQXpCLEVBQWtDeEssSUFBbEMsRUFBd0M7QUFDdEMsT0FBSXVWLE9BQVEvSyxRQUFRZ2UsS0FBUixJQUFpQmhlLFFBQVFnZSxLQUFSLENBQWNqVCxJQUFoQyxJQUF5QyxPQUFwRDtBQUNBLE9BQUk5VSxRQUFTK0osUUFBUWdlLEtBQVIsSUFBaUJoZSxRQUFRZ2UsS0FBUixDQUFjL25CLEtBQWhDLElBQTBDLE9BQXRELENBQThELENBQUNULEtBQUs0VCxLQUFMLEtBQWU1VCxLQUFLNFQsS0FBTCxHQUFhLEVBQTVCLENBQUQsRUFBa0MyQixJQUFsQyxJQUEwQ3ZWLEtBQUt3b0IsS0FBTCxDQUFXcG1CLEtBQXJEO0FBQzlELE9BQUkrWCxLQUFLbmEsS0FBS21hLEVBQUwsS0FBWW5hLEtBQUttYSxFQUFMLEdBQVUsRUFBdEIsQ0FBVDtBQUNBLE9BQUluWSxNQUFNbVksR0FBRzFaLEtBQUgsQ0FBTixDQUFKLEVBQXNCO0FBQ3BCMFosUUFBRzFaLEtBQUgsSUFBWSxDQUFDVCxLQUFLd29CLEtBQUwsQ0FBV2MsUUFBWixFQUFzQjdpQixNQUF0QixDQUE2QjBULEdBQUcxWixLQUFILENBQTdCLENBQVo7QUFDRCxJQUZELE1BRU87QUFDTDBaLFFBQUcxWixLQUFILElBQVlULEtBQUt3b0IsS0FBTCxDQUFXYyxRQUF2QjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSUMsbUJBQW1CLENBQXZCO0FBQ0EsS0FBSUMsbUJBQW1CLENBQXZCOztBQUVBO0FBQ0E7QUFDQSxVQUFTcEMsYUFBVCxDQUNFbFAsT0FERixFQUVFcEIsR0FGRixFQUdFOVcsSUFIRixFQUlFK1gsUUFKRixFQUtFMFIsaUJBTEYsRUFNRUMsZUFORixFQU9FO0FBQ0EsT0FBSTdqQixNQUFNbUIsT0FBTixDQUFjaEgsSUFBZCxLQUF1Qm1DLFlBQVluQyxJQUFaLENBQTNCLEVBQThDO0FBQzVDeXBCLHlCQUFvQjFSLFFBQXBCO0FBQ0FBLGdCQUFXL1gsSUFBWDtBQUNBQSxZQUFPM0YsU0FBUDtBQUNEO0FBQ0QsT0FBSTRILE9BQU95bkIsZUFBUCxDQUFKLEVBQTZCO0FBQzNCRCx5QkFBb0JELGdCQUFwQjtBQUNEO0FBQ0QsVUFBT0csZUFBZXpSLE9BQWYsRUFBd0JwQixHQUF4QixFQUE2QjlXLElBQTdCLEVBQW1DK1gsUUFBbkMsRUFBNkMwUixpQkFBN0MsQ0FBUDtBQUNEOztBQUVELFVBQVNFLGNBQVQsQ0FDRXpSLE9BREYsRUFFRXBCLEdBRkYsRUFHRTlXLElBSEYsRUFJRStYLFFBSkYsRUFLRTBSLGlCQUxGLEVBTUU7QUFDQSxPQUFJem5CLE1BQU1oQyxJQUFOLEtBQWVnQyxNQUFPaEMsSUFBRCxDQUFPc1EsTUFBYixDQUFuQixFQUF5QztBQUN2Q3ZJLGFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLHFEQUFzRDVHLEtBQUtDLFNBQUwsQ0FBZWxELElBQWYsQ0FBdEQsR0FBOEUsSUFBOUUsR0FDQSx3REFGdUMsRUFHdkNrWSxPQUh1QyxDQUF6QztBQUtBLFlBQU9nQixrQkFBUDtBQUNEO0FBQ0Q7QUFDQSxPQUFJbFgsTUFBTWhDLElBQU4sS0FBZWdDLE1BQU1oQyxLQUFLNHBCLEVBQVgsQ0FBbkIsRUFBbUM7QUFDakM5UyxXQUFNOVcsS0FBSzRwQixFQUFYO0FBQ0Q7QUFDRCxPQUFJLENBQUM5UyxHQUFMLEVBQVU7QUFDUjtBQUNBLFlBQU9vQyxrQkFBUDtBQUNEO0FBQ0Q7QUFDQSxPQUFJblIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0ZqRyxNQUFNaEMsSUFBTixDQURFLElBQ2FnQyxNQUFNaEMsS0FBS3NFLEdBQVgsQ0FEYixJQUNnQyxDQUFDbkMsWUFBWW5DLEtBQUtzRSxHQUFqQixDQURyQyxFQUVFO0FBQ0F1RixVQUNFLDZDQUNBLGtDQUZGLEVBR0VxTyxPQUhGO0FBS0Q7QUFDRDtBQUNBLE9BQUlyUyxNQUFNbUIsT0FBTixDQUFjK1EsUUFBZCxLQUNGLE9BQU9BLFNBQVMsQ0FBVCxDQUFQLEtBQXVCLFVBRHpCLEVBRUU7QUFDQS9YLFlBQU9BLFFBQVEsRUFBZjtBQUNBQSxVQUFLaWhCLFdBQUwsR0FBbUIsRUFBRW5MLFNBQVNpQyxTQUFTLENBQVQsQ0FBWCxFQUFuQjtBQUNBQSxjQUFTcmQsTUFBVCxHQUFrQixDQUFsQjtBQUNEO0FBQ0QsT0FBSSt1QixzQkFBc0JELGdCQUExQixFQUE0QztBQUMxQ3pSLGdCQUFXc0Qsa0JBQWtCdEQsUUFBbEIsQ0FBWDtBQUNELElBRkQsTUFFTyxJQUFJMFIsc0JBQXNCRixnQkFBMUIsRUFBNEM7QUFDakR4UixnQkFBV3FELHdCQUF3QnJELFFBQXhCLENBQVg7QUFDRDtBQUNELE9BQUl1QixLQUFKLEVBQVdqQixFQUFYO0FBQ0EsT0FBSSxPQUFPdkIsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFNBQUkvSixJQUFKO0FBQ0FzTCxVQUFLMVEsT0FBT2dCLGVBQVAsQ0FBdUJtTyxHQUF2QixDQUFMO0FBQ0EsU0FBSW5QLE9BQU9hLGFBQVAsQ0FBcUJzTyxHQUFyQixDQUFKLEVBQStCO0FBQzdCO0FBQ0F3QyxlQUFRLElBQUl4QixLQUFKLENBQ05uUSxPQUFPaUIsb0JBQVAsQ0FBNEJrTyxHQUE1QixDQURNLEVBQzRCOVcsSUFENUIsRUFDa0MrWCxRQURsQyxFQUVOMWQsU0FGTSxFQUVLQSxTQUZMLEVBRWdCNmQsT0FGaEIsQ0FBUjtBQUlELE1BTkQsTUFNTyxJQUFJbFcsTUFBTStLLE9BQU9pSSxhQUFha0QsUUFBUXhOLFFBQXJCLEVBQStCLFlBQS9CLEVBQTZDb00sR0FBN0MsQ0FBYixDQUFKLEVBQXFFO0FBQzFFO0FBQ0F3QyxlQUFROE8sZ0JBQWdCcmIsSUFBaEIsRUFBc0IvTSxJQUF0QixFQUE0QmtZLE9BQTVCLEVBQXFDSCxRQUFyQyxFQUErQ2pCLEdBQS9DLENBQVI7QUFDRCxNQUhNLE1BR0E7QUFDTDtBQUNBO0FBQ0E7QUFDQXdDLGVBQVEsSUFBSXhCLEtBQUosQ0FDTmhCLEdBRE0sRUFDRDlXLElBREMsRUFDSytYLFFBREwsRUFFTjFkLFNBRk0sRUFFS0EsU0FGTCxFQUVnQjZkLE9BRmhCLENBQVI7QUFJRDtBQUNGLElBckJELE1BcUJPO0FBQ0w7QUFDQW9CLGFBQVE4TyxnQkFBZ0J0UixHQUFoQixFQUFxQjlXLElBQXJCLEVBQTJCa1ksT0FBM0IsRUFBb0NILFFBQXBDLENBQVI7QUFDRDtBQUNELE9BQUkvVixNQUFNc1gsS0FBTixDQUFKLEVBQWtCO0FBQ2hCLFNBQUlqQixFQUFKLEVBQVE7QUFBRXdSLGVBQVF2USxLQUFSLEVBQWVqQixFQUFmO0FBQXFCO0FBQy9CLFlBQU9pQixLQUFQO0FBQ0QsSUFIRCxNQUdPO0FBQ0wsWUFBT0osa0JBQVA7QUFDRDtBQUNGOztBQUVELFVBQVMyUSxPQUFULENBQWtCdlEsS0FBbEIsRUFBeUJqQixFQUF6QixFQUE2QjtBQUMzQmlCLFNBQU1qQixFQUFOLEdBQVdBLEVBQVg7QUFDQSxPQUFJaUIsTUFBTXhDLEdBQU4sS0FBYyxlQUFsQixFQUFtQztBQUNqQztBQUNBO0FBQ0Q7QUFDRCxPQUFJOVUsTUFBTXNYLE1BQU12QixRQUFaLENBQUosRUFBMkI7QUFDekIsVUFBSyxJQUFJdGQsSUFBSSxDQUFSLEVBQVcrSyxJQUFJOFQsTUFBTXZCLFFBQU4sQ0FBZXJkLE1BQW5DLEVBQTJDRCxJQUFJK0ssQ0FBL0MsRUFBa0QvSyxHQUFsRCxFQUF1RDtBQUNyRCxXQUFJa1ksUUFBUTJHLE1BQU12QixRQUFOLENBQWV0ZCxDQUFmLENBQVo7QUFDQSxXQUFJdUgsTUFBTTJRLE1BQU1tRSxHQUFaLEtBQW9CaFYsUUFBUTZRLE1BQU0wRixFQUFkLENBQXhCLEVBQTJDO0FBQ3pDd1IsaUJBQVFsWCxLQUFSLEVBQWUwRixFQUFmO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUE7OztBQUdBLFVBQVN5UixVQUFULENBQ0VubkIsR0FERixFQUVFZ1YsTUFGRixFQUdFO0FBQ0EsT0FBSS9SLEdBQUosRUFBU25MLENBQVQsRUFBWStLLENBQVosRUFBZWxFLElBQWYsRUFBcUJnRCxHQUFyQjtBQUNBLE9BQUl1QixNQUFNbUIsT0FBTixDQUFjckUsR0FBZCxLQUFzQixPQUFPQSxHQUFQLEtBQWUsUUFBekMsRUFBbUQ7QUFDakRpRCxXQUFNLElBQUlDLEtBQUosQ0FBVWxELElBQUlqSSxNQUFkLENBQU47QUFDQSxVQUFLRCxJQUFJLENBQUosRUFBTytLLElBQUk3QyxJQUFJakksTUFBcEIsRUFBNEJELElBQUkrSyxDQUFoQyxFQUFtQy9LLEdBQW5DLEVBQXdDO0FBQ3RDbUwsV0FBSW5MLENBQUosSUFBU2tkLE9BQU9oVixJQUFJbEksQ0FBSixDQUFQLEVBQWVBLENBQWYsQ0FBVDtBQUNEO0FBQ0YsSUFMRCxNQUtPLElBQUksT0FBT2tJLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQ2lELFdBQU0sSUFBSUMsS0FBSixDQUFVbEQsR0FBVixDQUFOO0FBQ0EsVUFBS2xJLElBQUksQ0FBVCxFQUFZQSxJQUFJa0ksR0FBaEIsRUFBcUJsSSxHQUFyQixFQUEwQjtBQUN4Qm1MLFdBQUluTCxDQUFKLElBQVNrZCxPQUFPbGQsSUFBSSxDQUFYLEVBQWNBLENBQWQsQ0FBVDtBQUNEO0FBQ0YsSUFMTSxNQUtBLElBQUk0SCxTQUFTTSxHQUFULENBQUosRUFBbUI7QUFDeEJyQixZQUFPRCxPQUFPQyxJQUFQLENBQVlxQixHQUFaLENBQVA7QUFDQWlELFdBQU0sSUFBSUMsS0FBSixDQUFVdkUsS0FBSzVHLE1BQWYsQ0FBTjtBQUNBLFVBQUtELElBQUksQ0FBSixFQUFPK0ssSUFBSWxFLEtBQUs1RyxNQUFyQixFQUE2QkQsSUFBSStLLENBQWpDLEVBQW9DL0ssR0FBcEMsRUFBeUM7QUFDdkM2SixhQUFNaEQsS0FBSzdHLENBQUwsQ0FBTjtBQUNBbUwsV0FBSW5MLENBQUosSUFBU2tkLE9BQU9oVixJQUFJMkIsR0FBSixDQUFQLEVBQWlCQSxHQUFqQixFQUFzQjdKLENBQXRCLENBQVQ7QUFDRDtBQUNGO0FBQ0QsT0FBSXVILE1BQU00RCxHQUFOLENBQUosRUFBZ0I7QUFDYkEsUUFBRCxDQUFNNlYsUUFBTixHQUFpQixJQUFqQjtBQUNEO0FBQ0QsVUFBTzdWLEdBQVA7QUFDRDs7QUFFRDs7QUFFQTs7O0FBR0EsVUFBU21rQixVQUFULENBQ0UvdUIsSUFERixFQUVFZ3ZCLFFBRkYsRUFHRXBXLEtBSEYsRUFJRXFXLFVBSkYsRUFLRTtBQUNBLE9BQUlDLGVBQWUsS0FBS2hKLFlBQUwsQ0FBa0JsbUIsSUFBbEIsQ0FBbkI7QUFDQSxPQUFJa3ZCLFlBQUosRUFBa0I7QUFBRTtBQUNsQnRXLGFBQVFBLFNBQVMsRUFBakI7QUFDQSxTQUFJcVcsVUFBSixFQUFnQjtBQUNkclcsZUFBUTlOLE9BQU9BLE9BQU8sRUFBUCxFQUFXbWtCLFVBQVgsQ0FBUCxFQUErQnJXLEtBQS9CLENBQVI7QUFDRDtBQUNELFlBQU9zVyxhQUFhdFcsS0FBYixLQUF1Qm9XLFFBQTlCO0FBQ0QsSUFORCxNQU1PO0FBQ0wsU0FBSUcsWUFBWSxLQUFLM0ksTUFBTCxDQUFZeG1CLElBQVosQ0FBaEI7QUFDQTtBQUNBLFNBQUltdkIsYUFBYXBpQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBMUMsRUFBd0Q7QUFDdERraUIsaUJBQVVDLFNBQVYsSUFBdUJ2Z0IsS0FDckIsa0NBQWtDN08sSUFBbEMsR0FBeUMsbUNBQXpDLEdBQ0EseUNBRnFCLEVBR3JCLElBSHFCLENBQXZCO0FBS0FtdkIsaUJBQVVDLFNBQVYsR0FBc0IsSUFBdEI7QUFDRDtBQUNELFlBQU9ELGFBQWFILFFBQXBCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7O0FBR0EsVUFBU0ssYUFBVCxDQUF3QmhyQixFQUF4QixFQUE0QjtBQUMxQixVQUFPMlYsYUFBYSxLQUFLdEssUUFBbEIsRUFBNEIsU0FBNUIsRUFBdUNyTCxFQUF2QyxFQUEyQyxJQUEzQyxLQUFvRCtHLFFBQTNEO0FBQ0Q7O0FBRUQ7O0FBRUE7OztBQUdBLFVBQVNra0IsYUFBVCxDQUNFQyxZQURGLEVBRUVqbUIsR0FGRixFQUdFa21CLFlBSEYsRUFJRTtBQUNBLE9BQUlqaUIsV0FBV1osT0FBT1ksUUFBUCxDQUFnQmpFLEdBQWhCLEtBQXdCa21CLFlBQXZDO0FBQ0EsT0FBSTNrQixNQUFNbUIsT0FBTixDQUFjdUIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFlBQU9BLFNBQVNwTSxPQUFULENBQWlCb3VCLFlBQWpCLE1BQW1DLENBQUMsQ0FBM0M7QUFDRCxJQUZELE1BRU87QUFDTCxZQUFPaGlCLGFBQWFnaUIsWUFBcEI7QUFDRDtBQUNGOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTRSxlQUFULENBQ0V6cUIsSUFERixFQUVFOFcsR0FGRixFQUdFMVUsS0FIRixFQUlFc29CLE1BSkYsRUFLRUMsTUFMRixFQU1FO0FBQ0EsT0FBSXZvQixLQUFKLEVBQVc7QUFDVCxTQUFJLENBQUNDLFNBQVNELEtBQVQsQ0FBTCxFQUFzQjtBQUNwQjJGLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLDBEQUR1QyxFQUV2QyxJQUZ1QyxDQUF6QztBQUlELE1BTEQsTUFLTztBQUNMLFdBQUloRSxNQUFNbUIsT0FBTixDQUFjNUUsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCQSxpQkFBUTZELFNBQVM3RCxLQUFULENBQVI7QUFDRDtBQUNELFdBQUk4WSxJQUFKO0FBQ0EsV0FBSWtLLE9BQU8sU0FBUEEsSUFBTyxDQUFXOWdCLEdBQVgsRUFBaUI7QUFDMUIsYUFDRUEsUUFBUSxPQUFSLElBQ0FBLFFBQVEsT0FEUixJQUVBUCxvQkFBb0JPLEdBQXBCLENBSEYsRUFJRTtBQUNBNFcsa0JBQU9sYixJQUFQO0FBQ0QsVUFORCxNQU1PO0FBQ0wsZUFBSTJULE9BQU8zVCxLQUFLOGEsS0FBTCxJQUFjOWEsS0FBSzhhLEtBQUwsQ0FBV25ILElBQXBDO0FBQ0F1SCxrQkFBT3dQLFVBQVUvaUIsT0FBT2tCLFdBQVAsQ0FBbUJpTyxHQUFuQixFQUF3Qm5ELElBQXhCLEVBQThCclAsR0FBOUIsQ0FBVixHQUNIdEUsS0FBSzRxQixRQUFMLEtBQWtCNXFCLEtBQUs0cUIsUUFBTCxHQUFnQixFQUFsQyxDQURHLEdBRUg1cUIsS0FBSzhhLEtBQUwsS0FBZTlhLEtBQUs4YSxLQUFMLEdBQWEsRUFBNUIsQ0FGSjtBQUdEO0FBQ0QsYUFBSSxFQUFFeFcsT0FBTzRXLElBQVQsQ0FBSixFQUFvQjtBQUNsQkEsZ0JBQUs1VyxHQUFMLElBQVlsQyxNQUFNa0MsR0FBTixDQUFaOztBQUVBLGVBQUlxbUIsTUFBSixFQUFZO0FBQ1YsaUJBQUl4USxLQUFLbmEsS0FBS21hLEVBQUwsS0FBWW5hLEtBQUttYSxFQUFMLEdBQVUsRUFBdEIsQ0FBVDtBQUNBQSxnQkFBSSxZQUFZN1YsR0FBaEIsSUFBd0IsVUFBVXVtQixNQUFWLEVBQWtCO0FBQ3hDem9CLHFCQUFNa0MsR0FBTixJQUFhdW1CLE1BQWI7QUFDRCxjQUZEO0FBR0Q7QUFDRjtBQUNGLFFBdkJEOztBQXlCQSxZQUFLLElBQUl2bUIsR0FBVCxJQUFnQmxDLEtBQWhCO0FBQXVCZ2pCLGNBQU05Z0IsR0FBTjtBQUF2QjtBQUNEO0FBQ0Y7QUFDRCxVQUFPdEUsSUFBUDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTOHFCLFlBQVQsQ0FDRXJzQixLQURGLEVBRUVzc0IsT0FGRixFQUdFO0FBQ0EsT0FBSTlmLE9BQU8sS0FBSytmLFlBQUwsQ0FBa0J2c0IsS0FBbEIsQ0FBWDtBQUNBO0FBQ0E7QUFDQSxPQUFJd00sUUFBUSxDQUFDOGYsT0FBYixFQUFzQjtBQUNwQixZQUFPbGxCLE1BQU1tQixPQUFOLENBQWNpRSxJQUFkLElBQ0h1TyxZQUFZdk8sSUFBWixDQURHLEdBRUhvTyxXQUFXcE8sSUFBWCxDQUZKO0FBR0Q7QUFDRDtBQUNBQSxVQUFPLEtBQUsrZixZQUFMLENBQWtCdnNCLEtBQWxCLElBQ0wsS0FBS2lNLFFBQUwsQ0FBY3NlLGVBQWQsQ0FBOEJ2cUIsS0FBOUIsRUFBcUMxRSxJQUFyQyxDQUEwQyxLQUFLOGQsWUFBL0MsQ0FERjtBQUVBb1QsY0FBV2hnQixJQUFYLEVBQWtCLGVBQWV4TSxLQUFqQyxFQUF5QyxLQUF6QztBQUNBLFVBQU93TSxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTaWdCLFFBQVQsQ0FDRWpnQixJQURGLEVBRUV4TSxLQUZGLEVBR0U2RixHQUhGLEVBSUU7QUFDQTJtQixjQUFXaGdCLElBQVgsRUFBa0IsYUFBYXhNLEtBQWIsSUFBc0I2RixNQUFPLE1BQU1BLEdBQWIsR0FBb0IsRUFBMUMsQ0FBbEIsRUFBa0UsSUFBbEU7QUFDQSxVQUFPMkcsSUFBUDtBQUNEOztBQUVELFVBQVNnZ0IsVUFBVCxDQUNFaGdCLElBREYsRUFFRTNHLEdBRkYsRUFHRXVVLE1BSEYsRUFJRTtBQUNBLE9BQUloVCxNQUFNbUIsT0FBTixDQUFjaUUsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFVBQUssSUFBSXhRLElBQUksQ0FBYixFQUFnQkEsSUFBSXdRLEtBQUt2USxNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDcEMsV0FBSXdRLEtBQUt4USxDQUFMLEtBQVcsT0FBT3dRLEtBQUt4USxDQUFMLENBQVAsS0FBbUIsUUFBbEMsRUFBNEM7QUFDMUMwd0Isd0JBQWVsZ0IsS0FBS3hRLENBQUwsQ0FBZixFQUF5QjZKLE1BQU0sR0FBTixHQUFZN0osQ0FBckMsRUFBeUNvZSxNQUF6QztBQUNEO0FBQ0Y7QUFDRixJQU5ELE1BTU87QUFDTHNTLG9CQUFlbGdCLElBQWYsRUFBcUIzRyxHQUFyQixFQUEwQnVVLE1BQTFCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTc1MsY0FBVCxDQUF5QmhTLElBQXpCLEVBQStCN1UsR0FBL0IsRUFBb0N1VSxNQUFwQyxFQUE0QztBQUMxQ00sUUFBS1YsUUFBTCxHQUFnQixJQUFoQjtBQUNBVSxRQUFLN1UsR0FBTCxHQUFXQSxHQUFYO0FBQ0E2VSxRQUFLTixNQUFMLEdBQWNBLE1BQWQ7QUFDRDs7QUFFRDs7QUFFQSxVQUFTdVMsbUJBQVQsQ0FBOEJwckIsSUFBOUIsRUFBb0NvQyxLQUFwQyxFQUEyQztBQUN6QyxPQUFJQSxLQUFKLEVBQVc7QUFDVCxTQUFJLENBQUNJLGNBQWNKLEtBQWQsQ0FBTCxFQUEyQjtBQUN6QjJGLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLCtDQUR1QyxFQUV2QyxJQUZ1QyxDQUF6QztBQUlELE1BTEQsTUFLTztBQUNMLFdBQUlzUSxLQUFLbmEsS0FBS21hLEVBQUwsR0FBVW5hLEtBQUttYSxFQUFMLEdBQVVyVSxPQUFPLEVBQVAsRUFBVzlGLEtBQUttYSxFQUFoQixDQUFWLEdBQWdDLEVBQW5EO0FBQ0EsWUFBSyxJQUFJN1YsR0FBVCxJQUFnQmxDLEtBQWhCLEVBQXVCO0FBQ3JCLGFBQUlpcEIsV0FBV2xSLEdBQUc3VixHQUFILENBQWY7QUFDQSxhQUFJNGtCLE9BQU85bUIsTUFBTWtDLEdBQU4sQ0FBWDtBQUNBNlYsWUFBRzdWLEdBQUgsSUFBVSttQixXQUFXLEdBQUc1a0IsTUFBSCxDQUFVeWlCLElBQVYsRUFBZ0JtQyxRQUFoQixDQUFYLEdBQXVDbkMsSUFBakQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPbHBCLElBQVA7QUFDRDs7QUFFRDs7QUFFQSxVQUFTc3JCLFVBQVQsQ0FBcUJsaEIsRUFBckIsRUFBeUI7QUFDdkJBLE1BQUdzVixNQUFILEdBQVksSUFBWixDQUR1QixDQUNMO0FBQ2xCdFYsTUFBRzRnQixZQUFILEdBQWtCLElBQWxCO0FBQ0EsT0FBSW5LLGNBQWN6VyxHQUFHNFYsTUFBSCxHQUFZNVYsR0FBR00sUUFBSCxDQUFZeVcsWUFBMUMsQ0FIdUIsQ0FHaUM7QUFDeEQsT0FBSW9LLGdCQUFnQjFLLGVBQWVBLFlBQVkzSSxPQUEvQztBQUNBOU4sTUFBR29YLE1BQUgsR0FBWXZELGFBQWE3VCxHQUFHTSxRQUFILENBQVlzVyxlQUF6QixFQUEwQ3VLLGFBQTFDLENBQVo7QUFDQW5oQixNQUFHOFcsWUFBSCxHQUFrQm5ZLFdBQWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXFCLE1BQUdvaEIsRUFBSCxHQUFRLFVBQVVqbUIsQ0FBVixFQUFhVyxDQUFiLEVBQWdCbEIsQ0FBaEIsRUFBbUJyRSxDQUFuQixFQUFzQjtBQUFFLFlBQU95bUIsY0FBY2hkLEVBQWQsRUFBa0I3RSxDQUFsQixFQUFxQlcsQ0FBckIsRUFBd0JsQixDQUF4QixFQUEyQnJFLENBQTNCLEVBQThCLEtBQTlCLENBQVA7QUFBOEMsSUFBOUU7QUFDQTtBQUNBO0FBQ0F5SixNQUFHcWhCLGNBQUgsR0FBb0IsVUFBVWxtQixDQUFWLEVBQWFXLENBQWIsRUFBZ0JsQixDQUFoQixFQUFtQnJFLENBQW5CLEVBQXNCO0FBQUUsWUFBT3ltQixjQUFjaGQsRUFBZCxFQUFrQjdFLENBQWxCLEVBQXFCVyxDQUFyQixFQUF3QmxCLENBQXhCLEVBQTJCckUsQ0FBM0IsRUFBOEIsSUFBOUIsQ0FBUDtBQUE2QyxJQUF6Rjs7QUFFQTtBQUNBO0FBQ0EsT0FBSStxQixhQUFhN0ssZUFBZUEsWUFBWTdnQixJQUE1QztBQUNBO0FBQ0EsT0FBSStILFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q21KLHVCQUFrQmhILEVBQWxCLEVBQXNCLFFBQXRCLEVBQWdDc2hCLGNBQWNBLFdBQVc1USxLQUF6RCxFQUFnRSxZQUFZO0FBQzFFLFFBQUMwRCx3QkFBRCxJQUE2QjNVLEtBQUsscUJBQUwsRUFBNEJPLEVBQTVCLENBQTdCO0FBQ0QsTUFGRCxFQUVHLElBRkg7QUFHQWdILHVCQUFrQmhILEVBQWxCLEVBQXNCLFlBQXRCLEVBQW9DQSxHQUFHTSxRQUFILENBQVl3UyxnQkFBaEQsRUFBa0UsWUFBWTtBQUM1RSxRQUFDc0Isd0JBQUQsSUFBNkIzVSxLQUFLLHlCQUFMLEVBQWdDTyxFQUFoQyxDQUE3QjtBQUNELE1BRkQsRUFFRyxJQUZIO0FBR0QsSUFQRCxNQU9PO0FBQ0xnSCx1QkFBa0JoSCxFQUFsQixFQUFzQixRQUF0QixFQUFnQ3NoQixjQUFjQSxXQUFXNVEsS0FBekQsRUFBZ0UsSUFBaEUsRUFBc0UsSUFBdEU7QUFDQTFKLHVCQUFrQmhILEVBQWxCLEVBQXNCLFlBQXRCLEVBQW9DQSxHQUFHTSxRQUFILENBQVl3UyxnQkFBaEQsRUFBa0UsSUFBbEUsRUFBd0UsSUFBeEU7QUFDRDtBQUNGOztBQUVELFVBQVN5TyxXQUFULENBQXNCak8sR0FBdEIsRUFBMkI7QUFDekJBLE9BQUk1akIsU0FBSixDQUFjOHhCLFNBQWQsR0FBMEIsVUFBVXBuQixFQUFWLEVBQWM7QUFDdEMsWUFBTzRJLFNBQVM1SSxFQUFULEVBQWEsSUFBYixDQUFQO0FBQ0QsSUFGRDs7QUFJQWtaLE9BQUk1akIsU0FBSixDQUFjNG1CLE9BQWQsR0FBd0IsWUFBWTtBQUNsQyxTQUFJdFcsS0FBSyxJQUFUO0FBQ0EsU0FBSXloQixNQUFNemhCLEdBQUdNLFFBQWI7QUFDQSxTQUFJaU4sU0FBU2tVLElBQUlsVSxNQUFqQjtBQUNBLFNBQUlxUixrQkFBa0I2QyxJQUFJN0MsZUFBMUI7QUFDQSxTQUFJN0gsZUFBZTBLLElBQUkxSyxZQUF2Qjs7QUFFQSxTQUFJL1csR0FBRzRVLFVBQVAsRUFBbUI7QUFDakI7QUFDQSxZQUFLLElBQUkxYSxHQUFULElBQWdCOEYsR0FBR29YLE1BQW5CLEVBQTJCO0FBQ3pCcFgsWUFBR29YLE1BQUgsQ0FBVWxkLEdBQVYsSUFBaUJrVixZQUFZcFAsR0FBR29YLE1BQUgsQ0FBVWxkLEdBQVYsQ0FBWixDQUFqQjtBQUNEO0FBQ0Y7O0FBRUQ4RixRQUFHOFcsWUFBSCxHQUFtQkMsZ0JBQWdCQSxhQUFhbmhCLElBQWIsQ0FBa0JpaEIsV0FBbkMsSUFBbURsWSxXQUFyRTs7QUFFQSxTQUFJaWdCLG1CQUFtQixDQUFDNWUsR0FBRzRnQixZQUEzQixFQUF5QztBQUN2QzVnQixVQUFHNGdCLFlBQUgsR0FBa0IsRUFBbEI7QUFDRDtBQUNEO0FBQ0E7QUFDQTVnQixRQUFHNFYsTUFBSCxHQUFZbUIsWUFBWjtBQUNBO0FBQ0EsU0FBSTdILEtBQUo7QUFDQSxTQUFJO0FBQ0ZBLGVBQVEzQixPQUFPNWQsSUFBUCxDQUFZcVEsR0FBR3lOLFlBQWYsRUFBNkJ6TixHQUFHcWhCLGNBQWhDLENBQVI7QUFDRCxNQUZELENBRUUsT0FBT3p4QixDQUFQLEVBQVU7QUFDVnNSLG1CQUFZdFIsQ0FBWixFQUFlb1EsRUFBZixFQUFtQixpQkFBbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFJckMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDcVIsaUJBQVFsUCxHQUFHTSxRQUFILENBQVlvaEIsV0FBWixHQUNKMWhCLEdBQUdNLFFBQUgsQ0FBWW9oQixXQUFaLENBQXdCL3hCLElBQXhCLENBQTZCcVEsR0FBR3lOLFlBQWhDLEVBQThDek4sR0FBR3FoQixjQUFqRCxFQUFpRXp4QixDQUFqRSxDQURJLEdBRUpvUSxHQUFHc1YsTUFGUDtBQUdELFFBSkQsTUFJTztBQUNMcEcsaUJBQVFsUCxHQUFHc1YsTUFBWDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFNBQUksRUFBRXBHLGlCQUFpQnhCLEtBQW5CLENBQUosRUFBK0I7QUFDN0IsV0FBSS9QLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5Q3BDLE1BQU1tQixPQUFOLENBQWNzUyxLQUFkLENBQTdDLEVBQW1FO0FBQ2pFelAsY0FDRSx3RUFDQSxtQ0FGRixFQUdFTyxFQUhGO0FBS0Q7QUFDRGtQLGVBQVFKLGtCQUFSO0FBQ0Q7QUFDRDtBQUNBSSxXQUFNNUcsTUFBTixHQUFleU8sWUFBZjtBQUNBLFlBQU83SCxLQUFQO0FBQ0QsSUFyREQ7O0FBdURBO0FBQ0E7QUFDQTtBQUNBb0UsT0FBSTVqQixTQUFKLENBQWNpeUIsRUFBZCxHQUFtQmIsUUFBbkI7QUFDQXhOLE9BQUk1akIsU0FBSixDQUFja3lCLEVBQWQsR0FBbUI1b0IsUUFBbkI7QUFDQXNhLE9BQUk1akIsU0FBSixDQUFjbXlCLEVBQWQsR0FBbUIxcEIsUUFBbkI7QUFDQW1iLE9BQUk1akIsU0FBSixDQUFjb3lCLEVBQWQsR0FBbUJwQyxVQUFuQjtBQUNBcE0sT0FBSTVqQixTQUFKLENBQWNxeUIsRUFBZCxHQUFtQnBDLFVBQW5CO0FBQ0FyTSxPQUFJNWpCLFNBQUosQ0FBY3N5QixFQUFkLEdBQW1CeGxCLFVBQW5CO0FBQ0E4VyxPQUFJNWpCLFNBQUosQ0FBY3V5QixFQUFkLEdBQW1CaGxCLFlBQW5CO0FBQ0FxVyxPQUFJNWpCLFNBQUosQ0FBY3d5QixFQUFkLEdBQW1CeEIsWUFBbkI7QUFDQXBOLE9BQUk1akIsU0FBSixDQUFjeXlCLEVBQWQsR0FBbUJsQyxhQUFuQjtBQUNBM00sT0FBSTVqQixTQUFKLENBQWMweUIsRUFBZCxHQUFtQmxDLGFBQW5CO0FBQ0E1TSxPQUFJNWpCLFNBQUosQ0FBYzJ5QixFQUFkLEdBQW1CaEMsZUFBbkI7QUFDQS9NLE9BQUk1akIsU0FBSixDQUFjNHlCLEVBQWQsR0FBbUJ0VCxlQUFuQjtBQUNBc0UsT0FBSTVqQixTQUFKLENBQWM2eUIsRUFBZCxHQUFtQnpULGdCQUFuQjtBQUNBd0UsT0FBSTVqQixTQUFKLENBQWM4eUIsRUFBZCxHQUFtQnRPLGtCQUFuQjtBQUNBWixPQUFJNWpCLFNBQUosQ0FBYyt5QixFQUFkLEdBQW1CekIsbUJBQW5CO0FBQ0Q7O0FBRUQ7O0FBRUEsS0FBSTBCLFFBQVEsQ0FBWjs7QUFFQSxVQUFTQyxTQUFULENBQW9CclAsR0FBcEIsRUFBeUI7QUFDdkJBLE9BQUk1akIsU0FBSixDQUFja3pCLEtBQWQsR0FBc0IsVUFBVXhpQixPQUFWLEVBQW1CO0FBQ3ZDLFNBQUlKLEtBQUssSUFBVDtBQUNBO0FBQ0FBLFFBQUdxVyxJQUFILEdBQVVxTSxPQUFWOztBQUVBLFNBQUkvVixRQUFKLEVBQWNDLE1BQWQ7QUFDQTtBQUNBLFNBQUlqUCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkVNLGtCQUFXLG1CQUFvQjNNLEdBQUdxVyxJQUFsQztBQUNBekosZ0JBQVMsa0JBQW1CNU0sR0FBR3FXLElBQS9CO0FBQ0FoSyxZQUFLTSxRQUFMO0FBQ0Q7O0FBRUQ7QUFDQTNNLFFBQUdLLE1BQUgsR0FBWSxJQUFaO0FBQ0E7QUFDQSxTQUFJRCxXQUFXQSxRQUFRc2UsWUFBdkIsRUFBcUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0FtRSw2QkFBc0I3aUIsRUFBdEIsRUFBMEJJLE9BQTFCO0FBQ0QsTUFMRCxNQUtPO0FBQ0xKLFVBQUdNLFFBQUgsR0FBY2dLLGFBQ1o2VCwwQkFBMEJuZSxHQUFHZ0IsV0FBN0IsQ0FEWSxFQUVaWixXQUFXLEVBRkMsRUFHWkosRUFIWSxDQUFkO0FBS0Q7QUFDRDtBQUNBLFNBQUlyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnUCxpQkFBVTdNLEVBQVY7QUFDRCxNQUZELE1BRU87QUFDTEEsVUFBR3lOLFlBQUgsR0FBa0J6TixFQUFsQjtBQUNEO0FBQ0Q7QUFDQUEsUUFBRzhpQixLQUFILEdBQVc5aUIsRUFBWDtBQUNBcVUsbUJBQWNyVSxFQUFkO0FBQ0EwUyxnQkFBVzFTLEVBQVg7QUFDQWtoQixnQkFBV2xoQixFQUFYO0FBQ0FrVixjQUFTbFYsRUFBVCxFQUFhLGNBQWI7QUFDQXdjLG9CQUFleGMsRUFBZixFQXhDdUMsQ0F3Q25CO0FBQ3BCc2EsZUFBVXRhLEVBQVY7QUFDQXNjLGlCQUFZdGMsRUFBWixFQTFDdUMsQ0EwQ3RCO0FBQ2pCa1YsY0FBU2xWLEVBQVQsRUFBYSxTQUFiOztBQUVBO0FBQ0EsU0FBSXJDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5Q04sT0FBT1EsV0FBaEQsSUFBK0RzTyxJQUFuRSxFQUF5RTtBQUN2RXJNLFVBQUdvVyxLQUFILEdBQVd6VyxvQkFBb0JLLEVBQXBCLEVBQXdCLEtBQXhCLENBQVg7QUFDQXFNLFlBQUtPLE1BQUw7QUFDQU4sZUFBVXRNLEdBQUdvVyxLQUFKLEdBQWEsT0FBdEIsRUFBZ0N6SixRQUFoQyxFQUEwQ0MsTUFBMUM7QUFDRDs7QUFFRCxTQUFJNU0sR0FBR00sUUFBSCxDQUFZOEgsRUFBaEIsRUFBb0I7QUFDbEJwSSxVQUFHd2QsTUFBSCxDQUFVeGQsR0FBR00sUUFBSCxDQUFZOEgsRUFBdEI7QUFDRDtBQUNGLElBdkREO0FBd0REOztBQUVELFVBQVN5YSxxQkFBVCxDQUFnQzdpQixFQUFoQyxFQUFvQ0ksT0FBcEMsRUFBNkM7QUFDM0MsT0FBSThCLE9BQU9sQyxHQUFHTSxRQUFILEdBQWNySixPQUFPcUMsTUFBUCxDQUFjMEcsR0FBR2dCLFdBQUgsQ0FBZVosT0FBN0IsQ0FBekI7QUFDQTtBQUNBOEIsUUFBS29HLE1BQUwsR0FBY2xJLFFBQVFrSSxNQUF0QjtBQUNBcEcsUUFBS21HLFNBQUwsR0FBaUJqSSxRQUFRaUksU0FBekI7QUFDQW5HLFFBQUs2VSxZQUFMLEdBQW9CM1csUUFBUTJXLFlBQTVCO0FBQ0E3VSxRQUFLNFEsZ0JBQUwsR0FBd0IxUyxRQUFRMFMsZ0JBQWhDO0FBQ0E1USxRQUFLMFUsZUFBTCxHQUF1QnhXLFFBQVF3VyxlQUEvQjtBQUNBMVUsUUFBSzNCLGFBQUwsR0FBcUJILFFBQVFHLGFBQTdCO0FBQ0EyQixRQUFLdVQsVUFBTCxHQUFrQnJWLFFBQVFxVixVQUExQjtBQUNBdlQsUUFBS3dULE9BQUwsR0FBZXRWLFFBQVFzVixPQUF2QjtBQUNBLE9BQUl0VixRQUFRbU4sTUFBWixFQUFvQjtBQUNsQnJMLFVBQUtxTCxNQUFMLEdBQWNuTixRQUFRbU4sTUFBdEI7QUFDQXJMLFVBQUswYyxlQUFMLEdBQXVCeGUsUUFBUXdlLGVBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTVCx5QkFBVCxDQUFvQ3hiLElBQXBDLEVBQTBDO0FBQ3hDLE9BQUl2QyxVQUFVdUMsS0FBS3ZDLE9BQW5CO0FBQ0EsT0FBSXVDLEtBQUtvZ0IsS0FBVCxFQUFnQjtBQUNkLFNBQUlDLGVBQWU3RSwwQkFBMEJ4YixLQUFLb2dCLEtBQS9CLENBQW5CO0FBQ0EsU0FBSUUscUJBQXFCdGdCLEtBQUtxZ0IsWUFBOUI7QUFDQSxTQUFJQSxpQkFBaUJDLGtCQUFyQixFQUF5QztBQUN2QztBQUNBO0FBQ0F0Z0IsWUFBS3FnQixZQUFMLEdBQW9CQSxZQUFwQjtBQUNBO0FBQ0EsV0FBSUUsa0JBQWtCQyx1QkFBdUJ4Z0IsSUFBdkIsQ0FBdEI7QUFDQTtBQUNBLFdBQUl1Z0IsZUFBSixFQUFxQjtBQUNuQnhuQixnQkFBT2lILEtBQUt5Z0IsYUFBWixFQUEyQkYsZUFBM0I7QUFDRDtBQUNEOWlCLGlCQUFVdUMsS0FBS3ZDLE9BQUwsR0FBZWtLLGFBQWEwWSxZQUFiLEVBQTJCcmdCLEtBQUt5Z0IsYUFBaEMsQ0FBekI7QUFDQSxXQUFJaGpCLFFBQVF4UCxJQUFaLEVBQWtCO0FBQ2hCd1AsaUJBQVEwSixVQUFSLENBQW1CMUosUUFBUXhQLElBQTNCLElBQW1DK1IsSUFBbkM7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPdkMsT0FBUDtBQUNEOztBQUVELFVBQVMraUIsc0JBQVQsQ0FBaUN4Z0IsSUFBakMsRUFBdUM7QUFDckMsT0FBSTBnQixRQUFKO0FBQ0EsT0FBSUMsU0FBUzNnQixLQUFLdkMsT0FBbEI7QUFDQSxPQUFJbWpCLFdBQVc1Z0IsS0FBS3lnQixhQUFwQjtBQUNBLE9BQUlJLFNBQVM3Z0IsS0FBSzhnQixhQUFsQjtBQUNBLFFBQUssSUFBSXZwQixHQUFULElBQWdCb3BCLE1BQWhCLEVBQXdCO0FBQ3RCLFNBQUlBLE9BQU9wcEIsR0FBUCxNQUFnQnNwQixPQUFPdHBCLEdBQVAsQ0FBcEIsRUFBaUM7QUFDL0IsV0FBSSxDQUFDbXBCLFFBQUwsRUFBZTtBQUFFQSxvQkFBVyxFQUFYO0FBQWdCO0FBQ2pDQSxnQkFBU25wQixHQUFULElBQWdCd3BCLE9BQU9KLE9BQU9wcEIsR0FBUCxDQUFQLEVBQW9CcXBCLFNBQVNycEIsR0FBVCxDQUFwQixFQUFtQ3NwQixPQUFPdHBCLEdBQVAsQ0FBbkMsQ0FBaEI7QUFDRDtBQUNGO0FBQ0QsVUFBT21wQixRQUFQO0FBQ0Q7O0FBRUQsVUFBU0ssTUFBVCxDQUFpQkosTUFBakIsRUFBeUJDLFFBQXpCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6QztBQUNBO0FBQ0EsT0FBSS9uQixNQUFNbUIsT0FBTixDQUFjMG1CLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixTQUFJbnVCLE1BQU0sRUFBVjtBQUNBcXVCLGNBQVMvbkIsTUFBTW1CLE9BQU4sQ0FBYzRtQixNQUFkLElBQXdCQSxNQUF4QixHQUFpQyxDQUFDQSxNQUFELENBQTFDO0FBQ0FELGdCQUFXOW5CLE1BQU1tQixPQUFOLENBQWMybUIsUUFBZCxJQUEwQkEsUUFBMUIsR0FBcUMsQ0FBQ0EsUUFBRCxDQUFoRDtBQUNBLFVBQUssSUFBSWx6QixJQUFJLENBQWIsRUFBZ0JBLElBQUlpekIsT0FBT2h6QixNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDdEM7QUFDQSxXQUFJa3pCLFNBQVN4eEIsT0FBVCxDQUFpQnV4QixPQUFPanpCLENBQVAsQ0FBakIsS0FBK0IsQ0FBL0IsSUFBb0NtekIsT0FBT3p4QixPQUFQLENBQWV1eEIsT0FBT2p6QixDQUFQLENBQWYsSUFBNEIsQ0FBcEUsRUFBdUU7QUFDckU4RSxhQUFJOEwsSUFBSixDQUFTcWlCLE9BQU9qekIsQ0FBUCxDQUFUO0FBQ0Q7QUFDRjtBQUNELFlBQU84RSxHQUFQO0FBQ0QsSUFYRCxNQVdPO0FBQ0wsWUFBT211QixNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTSyxLQUFULENBQWdCdmpCLE9BQWhCLEVBQXlCO0FBQ3ZCLE9BQUl6QyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFDRixFQUFFLGdCQUFnQjhsQixLQUFsQixDQURGLEVBRUU7QUFDQWxrQixVQUFLLGtFQUFMO0FBQ0Q7QUFDRCxRQUFLbWpCLEtBQUwsQ0FBV3hpQixPQUFYO0FBQ0Q7O0FBRUR1aUIsV0FBVWdCLEtBQVY7QUFDQTdILFlBQVc2SCxLQUFYO0FBQ0F0USxhQUFZc1EsS0FBWjtBQUNBNU8sZ0JBQWU0TyxLQUFmO0FBQ0FwQyxhQUFZb0MsS0FBWjs7QUFFQTs7QUFFQSxVQUFTQyxPQUFULENBQWtCdFEsR0FBbEIsRUFBdUI7QUFDckJBLE9BQUloZixHQUFKLEdBQVUsVUFBVXV2QixNQUFWLEVBQWtCO0FBQzFCLFNBQUlDLG1CQUFvQixLQUFLQyxpQkFBTCxLQUEyQixLQUFLQSxpQkFBTCxHQUF5QixFQUFwRCxDQUF4QjtBQUNBLFNBQUlELGlCQUFpQi94QixPQUFqQixDQUF5Qjh4QixNQUF6QixJQUFtQyxDQUFDLENBQXhDLEVBQTJDO0FBQ3pDLGNBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0EsU0FBSS9kLE9BQU94SyxRQUFReEwsU0FBUixFQUFtQixDQUFuQixDQUFYO0FBQ0FnVyxVQUFLa2UsT0FBTCxDQUFhLElBQWI7QUFDQSxTQUFJLE9BQU9ILE9BQU9JLE9BQWQsS0FBMEIsVUFBOUIsRUFBMEM7QUFDeENKLGNBQU9JLE9BQVAsQ0FBZXAwQixLQUFmLENBQXFCZzBCLE1BQXJCLEVBQTZCL2QsSUFBN0I7QUFDRCxNQUZELE1BRU8sSUFBSSxPQUFPK2QsTUFBUCxLQUFrQixVQUF0QixFQUFrQztBQUN2Q0EsY0FBT2gwQixLQUFQLENBQWEsSUFBYixFQUFtQmlXLElBQW5CO0FBQ0Q7QUFDRGdlLHNCQUFpQjdpQixJQUFqQixDQUFzQjRpQixNQUF0QjtBQUNBLFlBQU8sSUFBUDtBQUNELElBaEJEO0FBaUJEOztBQUVEOztBQUVBLFVBQVNLLFdBQVQsQ0FBc0I1USxHQUF0QixFQUEyQjtBQUN6QkEsT0FBSTZRLEtBQUosR0FBWSxVQUFVQSxLQUFWLEVBQWlCO0FBQzNCLFVBQUsvakIsT0FBTCxHQUFla0ssYUFBYSxLQUFLbEssT0FBbEIsRUFBMkIrakIsS0FBM0IsQ0FBZjtBQUNBLFlBQU8sSUFBUDtBQUNELElBSEQ7QUFJRDs7QUFFRDs7QUFFQSxVQUFTQyxVQUFULENBQXFCOVEsR0FBckIsRUFBMEI7QUFDeEI7Ozs7O0FBS0FBLE9BQUk0SyxHQUFKLEdBQVUsQ0FBVjtBQUNBLE9BQUlBLE1BQU0sQ0FBVjs7QUFFQTs7O0FBR0E1SyxPQUFJNVgsTUFBSixHQUFhLFVBQVUwbkIsYUFBVixFQUF5QjtBQUNwQ0EscUJBQWdCQSxpQkFBaUIsRUFBakM7QUFDQSxTQUFJaUIsUUFBUSxJQUFaO0FBQ0EsU0FBSUMsVUFBVUQsTUFBTW5HLEdBQXBCO0FBQ0EsU0FBSXFHLGNBQWNuQixjQUFjb0IsS0FBZCxLQUF3QnBCLGNBQWNvQixLQUFkLEdBQXNCLEVBQTlDLENBQWxCO0FBQ0EsU0FBSUQsWUFBWUQsT0FBWixDQUFKLEVBQTBCO0FBQ3hCLGNBQU9DLFlBQVlELE9BQVosQ0FBUDtBQUNEOztBQUVELFNBQUkxekIsT0FBT3d5QixjQUFjeHlCLElBQWQsSUFBc0J5ekIsTUFBTWprQixPQUFOLENBQWN4UCxJQUEvQztBQUNBLFNBQUkrTSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsV0FBSSxDQUFDLG1CQUFtQjBCLElBQW5CLENBQXdCM08sSUFBeEIsQ0FBTCxFQUFvQztBQUNsQzZPLGNBQ0UsOEJBQThCN08sSUFBOUIsR0FBcUMscUJBQXJDLEdBQ0EsMkRBREEsR0FFQSwrQkFIRjtBQUtEO0FBQ0Y7O0FBRUQsU0FBSTZ6QixNQUFNLFNBQVNDLFlBQVQsQ0FBdUJ0a0IsT0FBdkIsRUFBZ0M7QUFDeEMsWUFBS3dpQixLQUFMLENBQVd4aUIsT0FBWDtBQUNELE1BRkQ7QUFHQXFrQixTQUFJLzBCLFNBQUosR0FBZ0J1SCxPQUFPcUMsTUFBUCxDQUFjK3FCLE1BQU0zMEIsU0FBcEIsQ0FBaEI7QUFDQSswQixTQUFJLzBCLFNBQUosQ0FBY3NSLFdBQWQsR0FBNEJ5akIsR0FBNUI7QUFDQUEsU0FBSXZHLEdBQUosR0FBVUEsS0FBVjtBQUNBdUcsU0FBSXJrQixPQUFKLEdBQWNrSyxhQUNaK1osTUFBTWprQixPQURNLEVBRVpnakIsYUFGWSxDQUFkO0FBSUFxQixTQUFJLE9BQUosSUFBZUosS0FBZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFJSSxJQUFJcmtCLE9BQUosQ0FBWW9KLEtBQWhCLEVBQXVCO0FBQ3JCbWIsbUJBQVlGLEdBQVo7QUFDRDtBQUNELFNBQUlBLElBQUlya0IsT0FBSixDQUFZdUosUUFBaEIsRUFBMEI7QUFDeEJpYixzQkFBZUgsR0FBZjtBQUNEOztBQUVEO0FBQ0FBLFNBQUkvb0IsTUFBSixHQUFhMm9CLE1BQU0zb0IsTUFBbkI7QUFDQStvQixTQUFJTixLQUFKLEdBQVlFLE1BQU1GLEtBQWxCO0FBQ0FNLFNBQUlud0IsR0FBSixHQUFVK3ZCLE1BQU0vdkIsR0FBaEI7O0FBRUE7QUFDQTtBQUNBK0ksaUJBQVlsRyxPQUFaLENBQW9CLFVBQVVvUyxJQUFWLEVBQWdCO0FBQ2xDa2IsV0FBSWxiLElBQUosSUFBWThhLE1BQU05YSxJQUFOLENBQVo7QUFDRCxNQUZEO0FBR0E7QUFDQSxTQUFJM1ksSUFBSixFQUFVO0FBQ1I2ekIsV0FBSXJrQixPQUFKLENBQVkwSixVQUFaLENBQXVCbFosSUFBdkIsSUFBK0I2ekIsR0FBL0I7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQUEsU0FBSXpCLFlBQUosR0FBbUJxQixNQUFNamtCLE9BQXpCO0FBQ0Fxa0IsU0FBSXJCLGFBQUosR0FBb0JBLGFBQXBCO0FBQ0FxQixTQUFJaEIsYUFBSixHQUFvQi9uQixPQUFPLEVBQVAsRUFBVytvQixJQUFJcmtCLE9BQWYsQ0FBcEI7O0FBRUE7QUFDQW1rQixpQkFBWUQsT0FBWixJQUF1QkcsR0FBdkI7QUFDQSxZQUFPQSxHQUFQO0FBQ0QsSUFuRUQ7QUFvRUQ7O0FBRUQsVUFBU0UsV0FBVCxDQUFzQkUsSUFBdEIsRUFBNEI7QUFDMUIsT0FBSXJiLFFBQVFxYixLQUFLemtCLE9BQUwsQ0FBYW9KLEtBQXpCO0FBQ0EsUUFBSyxJQUFJdFAsR0FBVCxJQUFnQnNQLEtBQWhCLEVBQXVCO0FBQ3JCMFEsV0FBTTJLLEtBQUtuMUIsU0FBWCxFQUFzQixRQUF0QixFQUFnQ3dLLEdBQWhDO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTMHFCLGNBQVQsQ0FBeUJDLElBQXpCLEVBQStCO0FBQzdCLE9BQUlsYixXQUFXa2IsS0FBS3prQixPQUFMLENBQWF1SixRQUE1QjtBQUNBLFFBQUssSUFBSXpQLEdBQVQsSUFBZ0J5UCxRQUFoQixFQUEwQjtBQUN4QjJSLG9CQUFldUosS0FBS24xQixTQUFwQixFQUErQndLLEdBQS9CLEVBQW9DeVAsU0FBU3pQLEdBQVQsQ0FBcEM7QUFDRDtBQUNGOztBQUVEOztBQUVBLFVBQVM0cUIsa0JBQVQsQ0FBNkJ4UixHQUE3QixFQUFrQztBQUNoQzs7O0FBR0FqVyxlQUFZbEcsT0FBWixDQUFvQixVQUFVb1MsSUFBVixFQUFnQjtBQUNsQytKLFNBQUkvSixJQUFKLElBQVksVUFDVnRVLEVBRFUsRUFFVnJHLFVBRlUsRUFHVjtBQUNBLFdBQUksQ0FBQ0EsVUFBTCxFQUFpQjtBQUNmLGdCQUFPLEtBQUt3UixPQUFMLENBQWFtSixPQUFPLEdBQXBCLEVBQXlCdFUsRUFBekIsQ0FBUDtBQUNELFFBRkQsTUFFTztBQUNMO0FBQ0EsYUFBSTBJLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxlQUFJMEwsU0FBUyxXQUFULElBQXdCaE0sT0FBT2EsYUFBUCxDQUFxQm5KLEVBQXJCLENBQTVCLEVBQXNEO0FBQ3BEd0ssa0JBQ0UsZ0VBQ0EsTUFEQSxHQUNTeEssRUFGWDtBQUlEO0FBQ0Y7QUFDRCxhQUFJc1UsU0FBUyxXQUFULElBQXdCblIsY0FBY3hKLFVBQWQsQ0FBNUIsRUFBdUQ7QUFDckRBLHNCQUFXZ0MsSUFBWCxHQUFrQmhDLFdBQVdnQyxJQUFYLElBQW1CcUUsRUFBckM7QUFDQXJHLHdCQUFhLEtBQUt3UixPQUFMLENBQWE2ZCxLQUFiLENBQW1CdmlCLE1BQW5CLENBQTBCOU0sVUFBMUIsQ0FBYjtBQUNEO0FBQ0QsYUFBSTJhLFNBQVMsV0FBVCxJQUF3QixPQUFPM2EsVUFBUCxLQUFzQixVQUFsRCxFQUE4RDtBQUM1REEsd0JBQWEsRUFBRVksTUFBTVosVUFBUixFQUFvQndXLFFBQVF4VyxVQUE1QixFQUFiO0FBQ0Q7QUFDRCxjQUFLd1IsT0FBTCxDQUFhbUosT0FBTyxHQUFwQixFQUF5QnRVLEVBQXpCLElBQStCckcsVUFBL0I7QUFDQSxnQkFBT0EsVUFBUDtBQUNEO0FBQ0YsTUExQkQ7QUEyQkQsSUE1QkQ7QUE2QkQ7O0FBRUQ7O0FBRUEsS0FBSW0yQixlQUFlLENBQUNoc0IsTUFBRCxFQUFTaXNCLE1BQVQsRUFBaUJ2cEIsS0FBakIsQ0FBbkI7O0FBRUEsVUFBU3dwQixnQkFBVCxDQUEyQi9pQixJQUEzQixFQUFpQztBQUMvQixVQUFPQSxTQUFTQSxLQUFLUyxJQUFMLENBQVV2QyxPQUFWLENBQWtCeFAsSUFBbEIsSUFBMEJzUixLQUFLd0ssR0FBeEMsQ0FBUDtBQUNEOztBQUVELFVBQVN3WSxPQUFULENBQWtCQyxPQUFsQixFQUEyQnYwQixJQUEzQixFQUFpQztBQUMvQixPQUFJNkssTUFBTW1CLE9BQU4sQ0FBY3VvQixPQUFkLENBQUosRUFBNEI7QUFDMUIsWUFBT0EsUUFBUXB6QixPQUFSLENBQWdCbkIsSUFBaEIsSUFBd0IsQ0FBQyxDQUFoQztBQUNELElBRkQsTUFFTyxJQUFJLE9BQU91MEIsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUN0QyxZQUFPQSxRQUFRM3JCLEtBQVIsQ0FBYyxHQUFkLEVBQW1CekgsT0FBbkIsQ0FBMkJuQixJQUEzQixJQUFtQyxDQUFDLENBQTNDO0FBQ0QsSUFGTSxNQUVBLElBQUl5SCxTQUFTOHNCLE9BQVQsQ0FBSixFQUF1QjtBQUM1QixZQUFPQSxRQUFRNWxCLElBQVIsQ0FBYTNPLElBQWIsQ0FBUDtBQUNEO0FBQ0Q7QUFDQSxVQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFTdzBCLFVBQVQsQ0FBcUIvcUIsS0FBckIsRUFBNEJnckIsT0FBNUIsRUFBcUNodUIsTUFBckMsRUFBNkM7QUFDM0MsUUFBSyxJQUFJNkMsR0FBVCxJQUFnQkcsS0FBaEIsRUFBdUI7QUFDckIsU0FBSWlyQixhQUFhanJCLE1BQU1ILEdBQU4sQ0FBakI7QUFDQSxTQUFJb3JCLFVBQUosRUFBZ0I7QUFDZCxXQUFJMTBCLE9BQU9xMEIsaUJBQWlCSyxXQUFXdlgsZ0JBQTVCLENBQVg7QUFDQSxXQUFJbmQsUUFBUSxDQUFDeUcsT0FBT3pHLElBQVAsQ0FBYixFQUEyQjtBQUN6QixhQUFJMDBCLGVBQWVELE9BQW5CLEVBQTRCO0FBQzFCRSwyQkFBZ0JELFVBQWhCO0FBQ0Q7QUFDRGpyQixlQUFNSCxHQUFOLElBQWEsSUFBYjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVNxckIsZUFBVCxDQUEwQnJXLEtBQTFCLEVBQWlDO0FBQy9CLE9BQUlBLEtBQUosRUFBVztBQUNUQSxXQUFNZixpQkFBTixDQUF3QjBILFFBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxLQUFJMlAsWUFBWTtBQUNkNTBCLFNBQU0sWUFEUTtBQUVkMGpCLGFBQVUsSUFGSTs7QUFJZDlLLFVBQU87QUFDTGljLGNBQVNWLFlBREo7QUFFTFcsY0FBU1g7QUFGSixJQUpPOztBQVNkWSxZQUFTLFNBQVNBLE9BQVQsR0FBb0I7QUFDM0IsVUFBS3RyQixLQUFMLEdBQWFwRCxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBYjtBQUNELElBWGE7O0FBYWRzc0IsY0FBVyxTQUFTQSxTQUFULEdBQXNCO0FBQy9CLFNBQUlwUyxTQUFTLElBQWI7O0FBRUEsVUFBSyxJQUFJdFosR0FBVCxJQUFnQnNaLE9BQU9uWixLQUF2QixFQUE4QjtBQUM1QmtyQix1QkFBZ0IvUixPQUFPblosS0FBUCxDQUFhSCxHQUFiLENBQWhCO0FBQ0Q7QUFDRixJQW5CYTs7QUFxQmQ4SCxVQUFPO0FBQ0x5akIsY0FBUyxTQUFTQSxPQUFULENBQWtCbHRCLEdBQWxCLEVBQXVCO0FBQzlCNnNCLGtCQUFXLEtBQUsvcUIsS0FBaEIsRUFBdUIsS0FBS2liLE1BQTVCLEVBQW9DLFVBQVUxa0IsSUFBVixFQUFnQjtBQUFFLGdCQUFPczBCLFFBQVEzc0IsR0FBUixFQUFhM0gsSUFBYixDQUFQO0FBQTRCLFFBQWxGO0FBQ0QsTUFISTtBQUlMODBCLGNBQVMsU0FBU0EsT0FBVCxDQUFrQm50QixHQUFsQixFQUF1QjtBQUM5QjZzQixrQkFBVyxLQUFLL3FCLEtBQWhCLEVBQXVCLEtBQUtpYixNQUE1QixFQUFvQyxVQUFVMWtCLElBQVYsRUFBZ0I7QUFBRSxnQkFBTyxDQUFDczBCLFFBQVEzc0IsR0FBUixFQUFhM0gsSUFBYixDQUFSO0FBQTZCLFFBQW5GO0FBQ0Q7QUFOSSxJQXJCTzs7QUE4QmQyYyxXQUFRLFNBQVNBLE1BQVQsR0FBbUI7QUFDekIsU0FBSTJCLFFBQVF1RCx1QkFBdUIsS0FBSzJFLE1BQUwsQ0FBWTFMLE9BQW5DLENBQVo7QUFDQSxTQUFJcUMsbUJBQW1CbUIsU0FBU0EsTUFBTW5CLGdCQUF0QztBQUNBLFNBQUlBLGdCQUFKLEVBQXNCO0FBQ3BCO0FBQ0EsV0FBSW5kLE9BQU9xMEIsaUJBQWlCbFgsZ0JBQWpCLENBQVg7QUFDQSxXQUFJbmQsU0FDRCxLQUFLNjBCLE9BQUwsSUFBZ0IsQ0FBQ1AsUUFBUSxLQUFLTyxPQUFiLEVBQXNCNzBCLElBQXRCLENBQWxCLElBQ0MsS0FBSzgwQixPQUFMLElBQWdCUixRQUFRLEtBQUtRLE9BQWIsRUFBc0I5MEIsSUFBdEIsQ0FGZixDQUFKLEVBR0c7QUFDRCxnQkFBT3NlLEtBQVA7QUFDRDtBQUNELFdBQUloVixNQUFNZ1YsTUFBTWhWLEdBQU4sSUFBYTtBQUNyQjtBQUNBO0FBRlEsU0FHTjZULGlCQUFpQnBMLElBQWpCLENBQXNCdWIsR0FBdEIsSUFBNkJuUSxpQkFBaUJyQixHQUFqQixHQUF3QixPQUFRcUIsaUJBQWlCckIsR0FBakQsR0FBeUQsRUFBdEYsQ0FITSxHQUlOd0MsTUFBTWhWLEdBSlY7QUFLQSxXQUFJLEtBQUtHLEtBQUwsQ0FBV0gsR0FBWCxDQUFKLEVBQXFCO0FBQ25CZ1YsZUFBTWYsaUJBQU4sR0FBMEIsS0FBSzlULEtBQUwsQ0FBV0gsR0FBWCxFQUFnQmlVLGlCQUExQztBQUNELFFBRkQsTUFFTztBQUNMLGNBQUs5VCxLQUFMLENBQVdILEdBQVgsSUFBa0JnVixLQUFsQjtBQUNEO0FBQ0RBLGFBQU10WixJQUFOLENBQVc2bkIsU0FBWCxHQUF1QixJQUF2QjtBQUNEO0FBQ0QsWUFBT3ZPLEtBQVA7QUFDRDtBQXZEYSxFQUFoQjs7QUEwREEsS0FBSTJXLG9CQUFvQjtBQUN0QkwsY0FBV0E7QUFEVyxFQUF4Qjs7QUFJQTs7QUFFQSxVQUFTTSxhQUFULENBQXdCeFMsR0FBeEIsRUFBNkI7QUFDM0I7QUFDQSxPQUFJeVMsWUFBWSxFQUFoQjtBQUNBQSxhQUFVNWpCLEdBQVYsR0FBZ0IsWUFBWTtBQUFFLFlBQU81RSxNQUFQO0FBQWdCLElBQTlDO0FBQ0EsT0FBSUksUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDa29CLGVBQVV6aEIsR0FBVixHQUFnQixZQUFZO0FBQzFCN0UsWUFDRSxzRUFERjtBQUdELE1BSkQ7QUFLRDtBQUNEeEksVUFBT2dJLGNBQVAsQ0FBc0JxVSxHQUF0QixFQUEyQixRQUEzQixFQUFxQ3lTLFNBQXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBelMsT0FBSTBTLElBQUosR0FBVztBQUNUdm1CLFdBQU1BLElBREc7QUFFVC9ELGFBQVFBLE1BRkM7QUFHVDRPLG1CQUFjQSxZQUhMO0FBSVQyYixxQkFBZ0JqZjtBQUpQLElBQVg7O0FBT0FzTSxPQUFJaFAsR0FBSixHQUFVQSxHQUFWO0FBQ0FnUCxPQUFJNFMsTUFBSixHQUFhaGUsR0FBYjtBQUNBb0wsT0FBSXRRLFFBQUosR0FBZUEsUUFBZjs7QUFFQXNRLE9BQUlsVCxPQUFKLEdBQWNuSixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBZDtBQUNBK0QsZUFBWWxHLE9BQVosQ0FBb0IsVUFBVW9TLElBQVYsRUFBZ0I7QUFDbEMrSixTQUFJbFQsT0FBSixDQUFZbUosT0FBTyxHQUFuQixJQUEwQnRTLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUExQjtBQUNELElBRkQ7O0FBSUE7QUFDQTtBQUNBZ2EsT0FBSWxULE9BQUosQ0FBWTZkLEtBQVosR0FBb0IzSyxHQUFwQjs7QUFFQTVYLFVBQU80WCxJQUFJbFQsT0FBSixDQUFZMEosVUFBbkIsRUFBK0IrYixpQkFBL0I7O0FBRUFqQyxXQUFRdFEsR0FBUjtBQUNBNFEsZUFBWTVRLEdBQVo7QUFDQThRLGNBQVc5USxHQUFYO0FBQ0F3UixzQkFBbUJ4UixHQUFuQjtBQUNEOztBQUVEd1MsZUFBY25DLEtBQWQ7O0FBRUExc0IsUUFBT2dJLGNBQVAsQ0FBc0Iwa0IsTUFBTWowQixTQUE1QixFQUF1QyxXQUF2QyxFQUFvRDtBQUNsRHlTLFFBQUtHO0FBRDZDLEVBQXBEOztBQUlBckwsUUFBT2dJLGNBQVAsQ0FBc0Iwa0IsTUFBTWowQixTQUE1QixFQUF1QyxhQUF2QyxFQUFzRDtBQUNwRHlTLFFBQUssU0FBU0EsR0FBVCxHQUFnQjtBQUNuQjtBQUNBLFlBQU8sS0FBS3lULE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVl1USxVQUFsQztBQUNEO0FBSm1ELEVBQXREOztBQU9BeEMsT0FBTXlDLE9BQU4sR0FBZ0IsT0FBaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUkvbkIsaUJBQWlCbkYsUUFBUSxhQUFSLENBQXJCOztBQUVBO0FBQ0EsS0FBSW10QixjQUFjbnRCLFFBQVEsOEJBQVIsQ0FBbEI7QUFDQSxLQUFJdUYsY0FBYyxTQUFkQSxXQUFjLENBQVVpTyxHQUFWLEVBQWVuRCxJQUFmLEVBQXFCK2MsSUFBckIsRUFBMkI7QUFDM0MsVUFDR0EsU0FBUyxPQUFULElBQW9CRCxZQUFZM1osR0FBWixDQUFyQixJQUEwQ25ELFNBQVMsUUFBbkQsSUFDQytjLFNBQVMsVUFBVCxJQUF1QjVaLFFBQVEsUUFEaEMsSUFFQzRaLFNBQVMsU0FBVCxJQUFzQjVaLFFBQVEsT0FGL0IsSUFHQzRaLFNBQVMsT0FBVCxJQUFvQjVaLFFBQVEsT0FKL0I7QUFNRCxFQVBEOztBQVNBLEtBQUk2WixtQkFBbUJydEIsUUFBUSxzQ0FBUixDQUF2Qjs7QUFFQSxLQUFJc3RCLGdCQUFnQnR0QixRQUNsQiwrRUFDQSxxRUFEQSxHQUVBLGtGQUZBLEdBR0EsNEVBSEEsR0FJQSxnRUFKQSxHQUtBLGlDQU5rQixDQUFwQjs7QUFTQSxLQUFJdXRCLFVBQVUsOEJBQWQ7O0FBRUEsS0FBSUMsVUFBVSxTQUFWQSxPQUFVLENBQVU5MUIsSUFBVixFQUFnQjtBQUM1QixVQUFPQSxLQUFLa0ssTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBbkIsSUFBMEJsSyxLQUFLcUIsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFkLE1BQXFCLE9BQXREO0FBQ0QsRUFGRDs7QUFJQSxLQUFJMDBCLGVBQWUsU0FBZkEsWUFBZSxDQUFVLzFCLElBQVYsRUFBZ0I7QUFDakMsVUFBTzgxQixRQUFROTFCLElBQVIsSUFBZ0JBLEtBQUtxQixLQUFMLENBQVcsQ0FBWCxFQUFjckIsS0FBS04sTUFBbkIsQ0FBaEIsR0FBNkMsRUFBcEQ7QUFDRCxFQUZEOztBQUlBLEtBQUlzMkIsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBVXJ1QixHQUFWLEVBQWU7QUFDcEMsVUFBT0EsT0FBTyxJQUFQLElBQWVBLFFBQVEsS0FBOUI7QUFDRCxFQUZEOztBQUlBOztBQUVBLFVBQVNzdUIsZ0JBQVQsQ0FBMkIzWCxLQUEzQixFQUFrQztBQUNoQyxPQUFJdFosT0FBT3NaLE1BQU10WixJQUFqQjtBQUNBLE9BQUlreEIsYUFBYTVYLEtBQWpCO0FBQ0EsT0FBSTZYLFlBQVk3WCxLQUFoQjtBQUNBLFVBQU90WCxNQUFNbXZCLFVBQVU1WSxpQkFBaEIsQ0FBUCxFQUEyQztBQUN6QzRZLGlCQUFZQSxVQUFVNVksaUJBQVYsQ0FBNEJtSCxNQUF4QztBQUNBLFNBQUl5UixVQUFVbnhCLElBQWQsRUFBb0I7QUFDbEJBLGNBQU9veEIsZUFBZUQsVUFBVW54QixJQUF6QixFQUErQkEsSUFBL0IsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxVQUFPZ0MsTUFBTWt2QixhQUFhQSxXQUFXeGUsTUFBOUIsQ0FBUCxFQUE4QztBQUM1QyxTQUFJd2UsV0FBV2x4QixJQUFmLEVBQXFCO0FBQ25CQSxjQUFPb3hCLGVBQWVweEIsSUFBZixFQUFxQmt4QixXQUFXbHhCLElBQWhDLENBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBT3F4QixZQUFZcnhCLEtBQUtzeEIsV0FBakIsRUFBOEJ0eEIsS0FBS3V4QixLQUFuQyxDQUFQO0FBQ0Q7O0FBRUQsVUFBU0gsY0FBVCxDQUF5QnplLEtBQXpCLEVBQWdDRCxNQUFoQyxFQUF3QztBQUN0QyxVQUFPO0FBQ0w0ZSxrQkFBYTdxQixPQUFPa00sTUFBTTJlLFdBQWIsRUFBMEI1ZSxPQUFPNGUsV0FBakMsQ0FEUjtBQUVMQyxZQUFPdnZCLE1BQU0yUSxNQUFNNGUsS0FBWixJQUNILENBQUM1ZSxNQUFNNGUsS0FBUCxFQUFjN2UsT0FBTzZlLEtBQXJCLENBREcsR0FFSDdlLE9BQU82ZTtBQUpOLElBQVA7QUFNRDs7QUFFRCxVQUFTRixXQUFULENBQ0VDLFdBREYsRUFFRUUsWUFGRixFQUdFO0FBQ0EsT0FBSXh2QixNQUFNc3ZCLFdBQU4sS0FBc0J0dkIsTUFBTXd2QixZQUFOLENBQTFCLEVBQStDO0FBQzdDLFlBQU8vcUIsT0FBTzZxQixXQUFQLEVBQW9CRyxlQUFlRCxZQUFmLENBQXBCLENBQVA7QUFDRDtBQUNEO0FBQ0EsVUFBTyxFQUFQO0FBQ0Q7O0FBRUQsVUFBUy9xQixNQUFULENBQWlCbEIsQ0FBakIsRUFBb0JXLENBQXBCLEVBQXVCO0FBQ3JCLFVBQU9YLElBQUlXLElBQUtYLElBQUksR0FBSixHQUFVVyxDQUFmLEdBQW9CWCxDQUF4QixHQUE2QlcsS0FBSyxFQUF6QztBQUNEOztBQUVELFVBQVN1ckIsY0FBVCxDQUF5QnJ2QixLQUF6QixFQUFnQztBQUM5QixPQUFJeUQsTUFBTW1CLE9BQU4sQ0FBYzVFLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixZQUFPc3ZCLGVBQWV0dkIsS0FBZixDQUFQO0FBQ0Q7QUFDRCxPQUFJQyxTQUFTRCxLQUFULENBQUosRUFBcUI7QUFDbkIsWUFBT3V2QixnQkFBZ0J2dkIsS0FBaEIsQ0FBUDtBQUNEO0FBQ0QsT0FBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFlBQU9BLEtBQVA7QUFDRDtBQUNEO0FBQ0EsVUFBTyxFQUFQO0FBQ0Q7O0FBRUQsVUFBU3N2QixjQUFULENBQXlCdHZCLEtBQXpCLEVBQWdDO0FBQzlCLE9BQUk3QyxNQUFNLEVBQVY7QUFDQSxPQUFJcXlCLFdBQUo7QUFDQSxRQUFLLElBQUluM0IsSUFBSSxDQUFSLEVBQVcrSyxJQUFJcEQsTUFBTTFILE1BQTFCLEVBQWtDRCxJQUFJK0ssQ0FBdEMsRUFBeUMvSyxHQUF6QyxFQUE4QztBQUM1QyxTQUFJdUgsTUFBTTR2QixjQUFjSCxlQUFlcnZCLE1BQU0zSCxDQUFOLENBQWYsQ0FBcEIsS0FBaURtM0IsZ0JBQWdCLEVBQXJFLEVBQXlFO0FBQ3ZFLFdBQUlyeUIsR0FBSixFQUFTO0FBQUVBLGdCQUFPLEdBQVA7QUFBYTtBQUN4QkEsY0FBT3F5QixXQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQU9yeUIsR0FBUDtBQUNEOztBQUVELFVBQVNveUIsZUFBVCxDQUEwQnZ2QixLQUExQixFQUFpQztBQUMvQixPQUFJN0MsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJK0UsR0FBVCxJQUFnQmxDLEtBQWhCLEVBQXVCO0FBQ3JCLFNBQUlBLE1BQU1rQyxHQUFOLENBQUosRUFBZ0I7QUFDZCxXQUFJL0UsR0FBSixFQUFTO0FBQUVBLGdCQUFPLEdBQVA7QUFBYTtBQUN4QkEsY0FBTytFLEdBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBTy9FLEdBQVA7QUFDRDs7QUFFRDs7QUFFQSxLQUFJc3lCLGVBQWU7QUFDakJDLFFBQUssNEJBRFk7QUFFakJDLFNBQU07QUFGVyxFQUFuQjs7QUFLQSxLQUFJQyxZQUFZMXVCLFFBQ2QsK0NBQ0EsMkVBREEsR0FFQSxvRUFGQSxHQUdBLHdFQUhBLEdBSUEsNkVBSkEsR0FLQSwyREFMQSxHQU1BLGtEQU5BLEdBT0EseUVBUEEsR0FRQSxrQ0FSQSxHQVNBLHVDQVRBLEdBVUEseURBWGMsQ0FBaEI7O0FBY0E7QUFDQTtBQUNBLEtBQUkydUIsUUFBUTN1QixRQUNWLDJFQUNBLDBFQURBLEdBRUEsa0VBSFUsRUFJVixJQUpVLENBQVo7O0FBT0EsS0FBSTR1QixXQUFXLFNBQVhBLFFBQVcsQ0FBVXBiLEdBQVYsRUFBZTtBQUFFLFVBQU9BLFFBQVEsS0FBZjtBQUF1QixFQUF2RDs7QUFFQSxLQUFJdE8sZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFVc08sR0FBVixFQUFlO0FBQ2pDLFVBQU9rYixVQUFVbGIsR0FBVixLQUFrQm1iLE1BQU1uYixHQUFOLENBQXpCO0FBQ0QsRUFGRDs7QUFJQSxVQUFTbk8sZUFBVCxDQUEwQm1PLEdBQTFCLEVBQStCO0FBQzdCLE9BQUltYixNQUFNbmIsR0FBTixDQUFKLEVBQWdCO0FBQ2QsWUFBTyxLQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsT0FBSUEsUUFBUSxNQUFaLEVBQW9CO0FBQ2xCLFlBQU8sTUFBUDtBQUNEO0FBQ0Y7O0FBRUQsS0FBSXFiLHNCQUFzQjl3QixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBMUI7QUFDQSxVQUFTZ0YsZ0JBQVQsQ0FBMkJvTyxHQUEzQixFQUFnQztBQUM5QjtBQUNBLE9BQUksQ0FBQ3RMLFNBQUwsRUFBZ0I7QUFDZCxZQUFPLElBQVA7QUFDRDtBQUNELE9BQUloRCxjQUFjc08sR0FBZCxDQUFKLEVBQXdCO0FBQ3RCLFlBQU8sS0FBUDtBQUNEO0FBQ0RBLFNBQU1BLElBQUlqVCxXQUFKLEVBQU47QUFDQTtBQUNBLE9BQUlzdUIsb0JBQW9CcmIsR0FBcEIsS0FBNEIsSUFBaEMsRUFBc0M7QUFDcEMsWUFBT3FiLG9CQUFvQnJiLEdBQXBCLENBQVA7QUFDRDtBQUNELE9BQUl0RSxLQUFLM1csU0FBU3VyQixhQUFULENBQXVCdFEsR0FBdkIsQ0FBVDtBQUNBLE9BQUlBLElBQUkzYSxPQUFKLENBQVksR0FBWixJQUFtQixDQUFDLENBQXhCLEVBQTJCO0FBQ3pCO0FBQ0EsWUFBUWcyQixvQkFBb0JyYixHQUFwQixJQUNOdEUsR0FBR3BILFdBQUgsS0FBbUIxUCxPQUFPMDJCLGtCQUExQixJQUNBNWYsR0FBR3BILFdBQUgsS0FBbUIxUCxPQUFPMjJCLFdBRjVCO0FBSUQsSUFORCxNQU1PO0FBQ0wsWUFBUUYsb0JBQW9CcmIsR0FBcEIsSUFBMkIscUJBQXFCbk4sSUFBckIsQ0FBMEI2SSxHQUFHalEsUUFBSCxFQUExQixDQUFuQztBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7OztBQUdBLFVBQVN0RCxLQUFULENBQWdCdVQsRUFBaEIsRUFBb0I7QUFDbEIsT0FBSSxPQUFPQSxFQUFQLEtBQWMsUUFBbEIsRUFBNEI7QUFDMUIsU0FBSThmLFdBQVd6MkIsU0FBUzAyQixhQUFULENBQXVCL2YsRUFBdkIsQ0FBZjtBQUNBLFNBQUksQ0FBQzhmLFFBQUwsRUFBZTtBQUNidnFCLGVBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzRCLEtBQ3ZDLDBCQUEwQjJJLEVBRGEsQ0FBekM7QUFHQSxjQUFPM1csU0FBU3VyQixhQUFULENBQXVCLEtBQXZCLENBQVA7QUFDRDtBQUNELFlBQU9rTCxRQUFQO0FBQ0QsSUFURCxNQVNPO0FBQ0wsWUFBTzlmLEVBQVA7QUFDRDtBQUNGOztBQUVEOztBQUVBLFVBQVNnZ0IsZUFBVCxDQUEwQkMsT0FBMUIsRUFBbUNuWixLQUFuQyxFQUEwQztBQUN4QyxPQUFJckIsTUFBTXBjLFNBQVN1ckIsYUFBVCxDQUF1QnFMLE9BQXZCLENBQVY7QUFDQSxPQUFJQSxZQUFZLFFBQWhCLEVBQTBCO0FBQ3hCLFlBQU94YSxHQUFQO0FBQ0Q7QUFDRDtBQUNBLE9BQUlxQixNQUFNdFosSUFBTixJQUFjc1osTUFBTXRaLElBQU4sQ0FBVzhhLEtBQXpCLElBQWtDeEIsTUFBTXRaLElBQU4sQ0FBVzhhLEtBQVgsQ0FBaUI0WCxRQUFqQixLQUE4QnI0QixTQUFwRSxFQUErRTtBQUM3RTRkLFNBQUkwYSxZQUFKLENBQWlCLFVBQWpCLEVBQTZCLFVBQTdCO0FBQ0Q7QUFDRCxVQUFPMWEsR0FBUDtBQUNEOztBQUVELFVBQVMyYSxlQUFULENBQTBCQyxTQUExQixFQUFxQ0osT0FBckMsRUFBOEM7QUFDNUMsVUFBTzUyQixTQUFTKzJCLGVBQVQsQ0FBeUJmLGFBQWFnQixTQUFiLENBQXpCLEVBQWtESixPQUFsRCxDQUFQO0FBQ0Q7O0FBRUQsVUFBU3ZrQixjQUFULENBQXlCOEosSUFBekIsRUFBK0I7QUFDN0IsVUFBT25jLFNBQVNxUyxjQUFULENBQXdCOEosSUFBeEIsQ0FBUDtBQUNEOztBQUVELFVBQVM4YSxhQUFULENBQXdCOWEsSUFBeEIsRUFBOEI7QUFDNUIsVUFBT25jLFNBQVNpM0IsYUFBVCxDQUF1QjlhLElBQXZCLENBQVA7QUFDRDs7QUFFRCxVQUFTK2EsWUFBVCxDQUF1QjdCLFVBQXZCLEVBQW1DOEIsT0FBbkMsRUFBNENDLGFBQTVDLEVBQTJEO0FBQ3pEL0IsY0FBVzZCLFlBQVgsQ0FBd0JDLE9BQXhCLEVBQWlDQyxhQUFqQztBQUNEOztBQUVELFVBQVNDLFdBQVQsQ0FBc0IvWixJQUF0QixFQUE0QnhHLEtBQTVCLEVBQW1DO0FBQ2pDd0csUUFBSytaLFdBQUwsQ0FBaUJ2Z0IsS0FBakI7QUFDRDs7QUFFRCxVQUFTd2dCLFdBQVQsQ0FBc0JoYSxJQUF0QixFQUE0QnhHLEtBQTVCLEVBQW1DO0FBQ2pDd0csUUFBS2dhLFdBQUwsQ0FBaUJ4Z0IsS0FBakI7QUFDRDs7QUFFRCxVQUFTdWUsVUFBVCxDQUFxQi9YLElBQXJCLEVBQTJCO0FBQ3pCLFVBQU9BLEtBQUsrWCxVQUFaO0FBQ0Q7O0FBRUQsVUFBU2tDLFdBQVQsQ0FBc0JqYSxJQUF0QixFQUE0QjtBQUMxQixVQUFPQSxLQUFLaWEsV0FBWjtBQUNEOztBQUVELFVBQVNYLE9BQVQsQ0FBa0J0WixJQUFsQixFQUF3QjtBQUN0QixVQUFPQSxLQUFLc1osT0FBWjtBQUNEOztBQUVELFVBQVNZLGNBQVQsQ0FBeUJsYSxJQUF6QixFQUErQm5CLElBQS9CLEVBQXFDO0FBQ25DbUIsUUFBS21hLFdBQUwsR0FBbUJ0YixJQUFuQjtBQUNEOztBQUVELFVBQVMyYSxZQUFULENBQXVCeFosSUFBdkIsRUFBNkI3VSxHQUE3QixFQUFrQzNCLEdBQWxDLEVBQXVDO0FBQ3JDd1csUUFBS3daLFlBQUwsQ0FBa0JydUIsR0FBbEIsRUFBdUIzQixHQUF2QjtBQUNEOztBQUdELEtBQUk0d0IsVUFBVWx5QixPQUFPMkgsTUFBUCxDQUFjO0FBQzNCb2Usa0JBQWVvTCxlQURZO0FBRTNCSSxvQkFBaUJBLGVBRlU7QUFHM0Ixa0IsbUJBQWdCQSxjQUhXO0FBSTNCNGtCLGtCQUFlQSxhQUpZO0FBSzNCQyxpQkFBY0EsWUFMYTtBQU0zQkcsZ0JBQWFBLFdBTmM7QUFPM0JDLGdCQUFhQSxXQVBjO0FBUTNCakMsZUFBWUEsVUFSZTtBQVMzQmtDLGdCQUFhQSxXQVRjO0FBVTNCWCxZQUFTQSxPQVZrQjtBQVczQlksbUJBQWdCQSxjQVhXO0FBWTNCVixpQkFBY0E7QUFaYSxFQUFkLENBQWQ7O0FBZUE7O0FBRUEsS0FBSTlHLE1BQU07QUFDUm5vQixXQUFRLFNBQVNBLE1BQVQsQ0FBaUJxQixDQUFqQixFQUFvQnVVLEtBQXBCLEVBQTJCO0FBQ2pDa2EsaUJBQVlsYSxLQUFaO0FBQ0QsSUFITztBQUlSOUosV0FBUSxTQUFTQSxNQUFULENBQWlCd1ksUUFBakIsRUFBMkIxTyxLQUEzQixFQUFrQztBQUN4QyxTQUFJME8sU0FBU2hvQixJQUFULENBQWM2ckIsR0FBZCxLQUFzQnZTLE1BQU10WixJQUFOLENBQVc2ckIsR0FBckMsRUFBMEM7QUFDeEMySCxtQkFBWXhMLFFBQVosRUFBc0IsSUFBdEI7QUFDQXdMLG1CQUFZbGEsS0FBWjtBQUNEO0FBQ0YsSUFUTztBQVVSNE8sWUFBUyxTQUFTQSxPQUFULENBQWtCNU8sS0FBbEIsRUFBeUI7QUFDaENrYSxpQkFBWWxhLEtBQVosRUFBbUIsSUFBbkI7QUFDRDtBQVpPLEVBQVY7O0FBZUEsVUFBU2thLFdBQVQsQ0FBc0JsYSxLQUF0QixFQUE2Qm1hLFNBQTdCLEVBQXdDO0FBQ3RDLE9BQUludkIsTUFBTWdWLE1BQU10WixJQUFOLENBQVc2ckIsR0FBckI7QUFDQSxPQUFJLENBQUN2bkIsR0FBTCxFQUFVO0FBQUU7QUFBUTs7QUFFcEIsT0FBSThGLEtBQUtrUCxNQUFNcEIsT0FBZjtBQUNBLE9BQUkyVCxNQUFNdlMsTUFBTWYsaUJBQU4sSUFBMkJlLE1BQU1yQixHQUEzQztBQUNBLE9BQUl5YixPQUFPdHBCLEdBQUd3VSxLQUFkO0FBQ0EsT0FBSTZVLFNBQUosRUFBZTtBQUNiLFNBQUk1dEIsTUFBTW1CLE9BQU4sQ0FBYzBzQixLQUFLcHZCLEdBQUwsQ0FBZCxDQUFKLEVBQThCO0FBQzVCTixjQUFPMHZCLEtBQUtwdkIsR0FBTCxDQUFQLEVBQWtCdW5CLEdBQWxCO0FBQ0QsTUFGRCxNQUVPLElBQUk2SCxLQUFLcHZCLEdBQUwsTUFBY3VuQixHQUFsQixFQUF1QjtBQUM1QjZILFlBQUtwdkIsR0FBTCxJQUFZakssU0FBWjtBQUNEO0FBQ0YsSUFORCxNQU1PO0FBQ0wsU0FBSWlmLE1BQU10WixJQUFOLENBQVcyekIsUUFBZixFQUF5QjtBQUN2QixXQUFJLENBQUM5dEIsTUFBTW1CLE9BQU4sQ0FBYzBzQixLQUFLcHZCLEdBQUwsQ0FBZCxDQUFMLEVBQStCO0FBQzdCb3ZCLGNBQUtwdkIsR0FBTCxJQUFZLENBQUN1bkIsR0FBRCxDQUFaO0FBQ0QsUUFGRCxNQUVPLElBQUk2SCxLQUFLcHZCLEdBQUwsRUFBVW5JLE9BQVYsQ0FBa0IwdkIsR0FBbEIsSUFBeUIsQ0FBN0IsRUFBZ0M7QUFDckM7QUFDQTZILGNBQUtwdkIsR0FBTCxFQUFVK0csSUFBVixDQUFld2dCLEdBQWY7QUFDRDtBQUNGLE1BUEQsTUFPTztBQUNMNkgsWUFBS3B2QixHQUFMLElBQVl1bkIsR0FBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxLQUFJK0gsWUFBWSxJQUFJOWIsS0FBSixDQUFVLEVBQVYsRUFBYyxFQUFkLEVBQWtCLEVBQWxCLENBQWhCOztBQUVBLEtBQUkrYixRQUFRLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsUUFBdkIsRUFBaUMsUUFBakMsRUFBMkMsU0FBM0MsQ0FBWjs7QUFFQSxVQUFTQyxTQUFULENBQW9CdnVCLENBQXBCLEVBQXVCVyxDQUF2QixFQUEwQjtBQUN4QixVQUNFWCxFQUFFakIsR0FBRixLQUFVNEIsRUFBRTVCLEdBQVosS0FFSWlCLEVBQUV1UixHQUFGLEtBQVU1USxFQUFFNFEsR0FBWixJQUNBdlIsRUFBRW9ULFNBQUYsS0FBZ0J6UyxFQUFFeVMsU0FEbEIsSUFFQTNXLE1BQU11RCxFQUFFdkYsSUFBUixNQUFrQmdDLE1BQU1rRSxFQUFFbEcsSUFBUixDQUZsQixJQUdBK3pCLGNBQWN4dUIsQ0FBZCxFQUFpQlcsQ0FBakIsQ0FKRixJQU1FakUsT0FBT3NELEVBQUV3VCxrQkFBVCxLQUNBeFQsRUFBRTZTLFlBQUYsS0FBbUJsUyxFQUFFa1MsWUFEckIsSUFFQXRXLFFBQVFvRSxFQUFFa1MsWUFBRixDQUFlN1gsS0FBdkIsQ0FUSixDQURGO0FBY0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQVN3ekIsYUFBVCxDQUF3Qnh1QixDQUF4QixFQUEyQlcsQ0FBM0IsRUFBOEI7QUFDNUIsT0FBSVgsRUFBRXVSLEdBQUYsS0FBVSxPQUFkLEVBQXVCO0FBQUUsWUFBTyxJQUFQO0FBQWE7QUFDdEMsT0FBSXJjLENBQUo7QUFDQSxPQUFJdTVCLFFBQVFoeUIsTUFBTXZILElBQUk4SyxFQUFFdkYsSUFBWixLQUFxQmdDLE1BQU12SCxJQUFJQSxFQUFFcWdCLEtBQVosQ0FBckIsSUFBMkNyZ0IsRUFBRWtaLElBQXpEO0FBQ0EsT0FBSXNnQixRQUFRanlCLE1BQU12SCxJQUFJeUwsRUFBRWxHLElBQVosS0FBcUJnQyxNQUFNdkgsSUFBSUEsRUFBRXFnQixLQUFaLENBQXJCLElBQTJDcmdCLEVBQUVrWixJQUF6RDtBQUNBLFVBQU9xZ0IsVUFBVUMsS0FBakI7QUFDRDs7QUFFRCxVQUFTQyxpQkFBVCxDQUE0Qm5jLFFBQTVCLEVBQXNDb2MsUUFBdEMsRUFBZ0RDLE1BQWhELEVBQXdEO0FBQ3RELE9BQUkzNUIsQ0FBSixFQUFPNkosR0FBUDtBQUNBLE9BQUliLE1BQU0sRUFBVjtBQUNBLFFBQUtoSixJQUFJMDVCLFFBQVQsRUFBbUIxNUIsS0FBSzI1QixNQUF4QixFQUFnQyxFQUFFMzVCLENBQWxDLEVBQXFDO0FBQ25DNkosV0FBTXlULFNBQVN0ZCxDQUFULEVBQVk2SixHQUFsQjtBQUNBLFNBQUl0QyxNQUFNc0MsR0FBTixDQUFKLEVBQWdCO0FBQUViLFdBQUlhLEdBQUosSUFBVzdKLENBQVg7QUFBZTtBQUNsQztBQUNELFVBQU9nSixHQUFQO0FBQ0Q7O0FBRUQsVUFBUzR3QixtQkFBVCxDQUE4QkMsT0FBOUIsRUFBdUM7QUFDckMsT0FBSTc1QixDQUFKLEVBQU9vbkIsQ0FBUDtBQUNBLE9BQUkvRCxNQUFNLEVBQVY7O0FBRUEsT0FBSXhYLFVBQVVndUIsUUFBUWh1QixPQUF0QjtBQUNBLE9BQUlpdEIsVUFBVWUsUUFBUWYsT0FBdEI7O0FBRUEsUUFBSzk0QixJQUFJLENBQVQsRUFBWUEsSUFBSW81QixNQUFNbjVCLE1BQXRCLEVBQThCLEVBQUVELENBQWhDLEVBQW1DO0FBQ2pDcWpCLFNBQUkrVixNQUFNcDVCLENBQU4sQ0FBSixJQUFnQixFQUFoQjtBQUNBLFVBQUtvbkIsSUFBSSxDQUFULEVBQVlBLElBQUl2YixRQUFRNUwsTUFBeEIsRUFBZ0MsRUFBRW1uQixDQUFsQyxFQUFxQztBQUNuQyxXQUFJN2YsTUFBTXNFLFFBQVF1YixDQUFSLEVBQVdnUyxNQUFNcDVCLENBQU4sQ0FBWCxDQUFOLENBQUosRUFBaUM7QUFDL0JxakIsYUFBSStWLE1BQU1wNUIsQ0FBTixDQUFKLEVBQWM0USxJQUFkLENBQW1CL0UsUUFBUXViLENBQVIsRUFBV2dTLE1BQU1wNUIsQ0FBTixDQUFYLENBQW5CO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFlBQVM4NUIsV0FBVCxDQUFzQnRjLEdBQXRCLEVBQTJCO0FBQ3pCLFlBQU8sSUFBSUgsS0FBSixDQUFVeWIsUUFBUWQsT0FBUixDQUFnQnhhLEdBQWhCLEVBQXFCcFUsV0FBckIsRUFBVixFQUE4QyxFQUE5QyxFQUFrRCxFQUFsRCxFQUFzRHhKLFNBQXRELEVBQWlFNGQsR0FBakUsQ0FBUDtBQUNEOztBQUVELFlBQVN1YyxVQUFULENBQXFCQyxRQUFyQixFQUErQnhYLFNBQS9CLEVBQTBDO0FBQ3hDLGNBQVM1QyxTQUFULEdBQXNCO0FBQ3BCLFdBQUksRUFBRUEsVUFBVTRDLFNBQVosS0FBMEIsQ0FBOUIsRUFBaUM7QUFDL0J5WCxvQkFBV0QsUUFBWDtBQUNEO0FBQ0Y7QUFDRHBhLGVBQVU0QyxTQUFWLEdBQXNCQSxTQUF0QjtBQUNBLFlBQU81QyxTQUFQO0FBQ0Q7O0FBRUQsWUFBU3FhLFVBQVQsQ0FBcUJsaUIsRUFBckIsRUFBeUI7QUFDdkIsU0FBSUUsU0FBUzZnQixRQUFRckMsVUFBUixDQUFtQjFlLEVBQW5CLENBQWI7QUFDQTtBQUNBLFNBQUl4USxNQUFNMFEsTUFBTixDQUFKLEVBQW1CO0FBQ2pCNmdCLGVBQVFMLFdBQVIsQ0FBb0J4Z0IsTUFBcEIsRUFBNEJGLEVBQTVCO0FBQ0Q7QUFDRjs7QUFFRCxPQUFJbWlCLFFBQVEsQ0FBWjtBQUNBLFlBQVNDLFNBQVQsQ0FBb0J0YixLQUFwQixFQUEyQnViLGtCQUEzQixFQUErQ3BOLFNBQS9DLEVBQTBEQyxNQUExRCxFQUFrRW9OLE1BQWxFLEVBQTBFO0FBQ3hFeGIsV0FBTVosWUFBTixHQUFxQixDQUFDb2MsTUFBdEIsQ0FEd0UsQ0FDMUM7QUFDOUIsU0FBSTFNLGdCQUFnQjlPLEtBQWhCLEVBQXVCdWIsa0JBQXZCLEVBQTJDcE4sU0FBM0MsRUFBc0RDLE1BQXRELENBQUosRUFBbUU7QUFDakU7QUFDRDs7QUFFRCxTQUFJMW5CLE9BQU9zWixNQUFNdFosSUFBakI7QUFDQSxTQUFJK1gsV0FBV3VCLE1BQU12QixRQUFyQjtBQUNBLFNBQUlqQixNQUFNd0MsTUFBTXhDLEdBQWhCO0FBQ0EsU0FBSTlVLE1BQU04VSxHQUFOLENBQUosRUFBZ0I7QUFDZCxXQUFJL08sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGFBQUlqSSxRQUFRQSxLQUFLKzBCLEdBQWpCLEVBQXNCO0FBQ3BCSjtBQUNEO0FBQ0QsYUFDRSxDQUFDQSxLQUFELElBQ0EsQ0FBQ3JiLE1BQU1qQixFQURQLElBRUEsRUFBRTFRLE9BQU9XLGVBQVAsQ0FBdUI1TixNQUF2QixJQUFpQ2lOLE9BQU9XLGVBQVAsQ0FBdUJuTSxPQUF2QixDQUErQjJhLEdBQS9CLElBQXNDLENBQUMsQ0FBMUUsQ0FGQSxJQUdBblAsT0FBT2UsZ0JBQVAsQ0FBd0JvTyxHQUF4QixDQUpGLEVBS0U7QUFDQWpOLGdCQUNFLDhCQUE4QmlOLEdBQTlCLEdBQW9DLGNBQXBDLEdBQ0EsOERBREEsR0FFQSx5Q0FIRixFQUlFd0MsTUFBTXBCLE9BSlI7QUFNRDtBQUNGO0FBQ0RvQixhQUFNckIsR0FBTixHQUFZcUIsTUFBTWpCLEVBQU4sR0FDUmtiLFFBQVFYLGVBQVIsQ0FBd0J0WixNQUFNakIsRUFBOUIsRUFBa0N2QixHQUFsQyxDQURRLEdBRVJ5YyxRQUFRbk0sYUFBUixDQUFzQnRRLEdBQXRCLEVBQTJCd0MsS0FBM0IsQ0FGSjtBQUdBMGIsZ0JBQVMxYixLQUFUOztBQUVBO0FBQ0E7QUFDRTJiLHdCQUFlM2IsS0FBZixFQUFzQnZCLFFBQXRCLEVBQWdDOGMsa0JBQWhDO0FBQ0EsYUFBSTd5QixNQUFNaEMsSUFBTixDQUFKLEVBQWlCO0FBQ2ZrMUIsNkJBQWtCNWIsS0FBbEIsRUFBeUJ1YixrQkFBekI7QUFDRDtBQUNENU0sZ0JBQU9SLFNBQVAsRUFBa0JuTyxNQUFNckIsR0FBeEIsRUFBNkJ5UCxNQUE3QjtBQUNEOztBQUVELFdBQUkzZixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNqSSxJQUF6QyxJQUFpREEsS0FBSyswQixHQUExRCxFQUErRDtBQUM3REo7QUFDRDtBQUNGLE1BcENELE1Bb0NPLElBQUkxeUIsT0FBT3FYLE1BQU1YLFNBQWIsQ0FBSixFQUE2QjtBQUNsQ1csYUFBTXJCLEdBQU4sR0FBWXNiLFFBQVFULGFBQVIsQ0FBc0J4WixNQUFNdEIsSUFBNUIsQ0FBWjtBQUNBaVEsY0FBT1IsU0FBUCxFQUFrQm5PLE1BQU1yQixHQUF4QixFQUE2QnlQLE1BQTdCO0FBQ0QsTUFITSxNQUdBO0FBQ0xwTyxhQUFNckIsR0FBTixHQUFZc2IsUUFBUXJsQixjQUFSLENBQXVCb0wsTUFBTXRCLElBQTdCLENBQVo7QUFDQWlRLGNBQU9SLFNBQVAsRUFBa0JuTyxNQUFNckIsR0FBeEIsRUFBNkJ5UCxNQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsWUFBU1UsZUFBVCxDQUEwQjlPLEtBQTFCLEVBQWlDdWIsa0JBQWpDLEVBQXFEcE4sU0FBckQsRUFBZ0VDLE1BQWhFLEVBQXdFO0FBQ3RFLFNBQUlqdEIsSUFBSTZlLE1BQU10WixJQUFkO0FBQ0EsU0FBSWdDLE1BQU12SCxDQUFOLENBQUosRUFBYztBQUNaLFdBQUkwNkIsZ0JBQWdCbnpCLE1BQU1zWCxNQUFNZixpQkFBWixLQUFrQzlkLEVBQUVvdEIsU0FBeEQ7QUFDQSxXQUFJN2xCLE1BQU12SCxJQUFJQSxFQUFFZ1osSUFBWixLQUFxQnpSLE1BQU12SCxJQUFJQSxFQUFFK3NCLElBQVosQ0FBekIsRUFBNEM7QUFDMUMvc0IsV0FBRTZlLEtBQUYsRUFBUyxLQUFULENBQWUsZUFBZixFQUFnQ21PLFNBQWhDLEVBQTJDQyxNQUEzQztBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFJMWxCLE1BQU1zWCxNQUFNZixpQkFBWixDQUFKLEVBQW9DO0FBQ2xDNmMsdUJBQWM5YixLQUFkLEVBQXFCdWIsa0JBQXJCO0FBQ0EsYUFBSTV5QixPQUFPa3pCLGFBQVAsQ0FBSixFQUEyQjtBQUN6QkUsK0JBQW9CL2IsS0FBcEIsRUFBMkJ1YixrQkFBM0IsRUFBK0NwTixTQUEvQyxFQUEwREMsTUFBMUQ7QUFDRDtBQUNELGdCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBUzBOLGFBQVQsQ0FBd0I5YixLQUF4QixFQUErQnViLGtCQUEvQixFQUFtRDtBQUNqRCxTQUFJN3lCLE1BQU1zWCxNQUFNdFosSUFBTixDQUFXczFCLGFBQWpCLENBQUosRUFBcUM7QUFDbkNULDBCQUFtQnhwQixJQUFuQixDQUF3QnBSLEtBQXhCLENBQThCNDZCLGtCQUE5QixFQUFrRHZiLE1BQU10WixJQUFOLENBQVdzMUIsYUFBN0Q7QUFDQWhjLGFBQU10WixJQUFOLENBQVdzMUIsYUFBWCxHQUEyQixJQUEzQjtBQUNEO0FBQ0RoYyxXQUFNckIsR0FBTixHQUFZcUIsTUFBTWYsaUJBQU4sQ0FBd0JpSCxHQUFwQztBQUNBLFNBQUkrVixZQUFZamMsS0FBWixDQUFKLEVBQXdCO0FBQ3RCNGIseUJBQWtCNWIsS0FBbEIsRUFBeUJ1YixrQkFBekI7QUFDQUcsZ0JBQVMxYixLQUFUO0FBQ0QsTUFIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBa2EsbUJBQVlsYSxLQUFaO0FBQ0E7QUFDQXViLDBCQUFtQnhwQixJQUFuQixDQUF3QmlPLEtBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTK2IsbUJBQVQsQ0FBOEIvYixLQUE5QixFQUFxQ3ViLGtCQUFyQyxFQUF5RHBOLFNBQXpELEVBQW9FQyxNQUFwRSxFQUE0RTtBQUMxRSxTQUFJanRCLENBQUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUkrNkIsWUFBWWxjLEtBQWhCO0FBQ0EsWUFBT2tjLFVBQVVqZCxpQkFBakIsRUFBb0M7QUFDbENpZCxtQkFBWUEsVUFBVWpkLGlCQUFWLENBQTRCbUgsTUFBeEM7QUFDQSxXQUFJMWQsTUFBTXZILElBQUkrNkIsVUFBVXgxQixJQUFwQixLQUE2QmdDLE1BQU12SCxJQUFJQSxFQUFFZzdCLFVBQVosQ0FBakMsRUFBMEQ7QUFDeEQsY0FBS2g3QixJQUFJLENBQVQsRUFBWUEsSUFBSXFqQixJQUFJNFgsUUFBSixDQUFhaDdCLE1BQTdCLEVBQXFDLEVBQUVELENBQXZDLEVBQTBDO0FBQ3hDcWpCLGVBQUk0WCxRQUFKLENBQWFqN0IsQ0FBYixFQUFnQm01QixTQUFoQixFQUEyQjRCLFNBQTNCO0FBQ0Q7QUFDRFgsNEJBQW1CeHBCLElBQW5CLENBQXdCbXFCLFNBQXhCO0FBQ0E7QUFDRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBdk4sWUFBT1IsU0FBUCxFQUFrQm5PLE1BQU1yQixHQUF4QixFQUE2QnlQLE1BQTdCO0FBQ0Q7O0FBRUQsWUFBU08sTUFBVCxDQUFpQnZWLE1BQWpCLEVBQXlCdUYsR0FBekIsRUFBOEIwZCxNQUE5QixFQUFzQztBQUNwQyxTQUFJM3pCLE1BQU0wUSxNQUFOLENBQUosRUFBbUI7QUFDakIsV0FBSTFRLE1BQU0yekIsTUFBTixDQUFKLEVBQW1CO0FBQ2pCLGFBQUlBLE9BQU96RSxVQUFQLEtBQXNCeGUsTUFBMUIsRUFBa0M7QUFDaEM2Z0IsbUJBQVFSLFlBQVIsQ0FBcUJyZ0IsTUFBckIsRUFBNkJ1RixHQUE3QixFQUFrQzBkLE1BQWxDO0FBQ0Q7QUFDRixRQUpELE1BSU87QUFDTHBDLGlCQUFRSixXQUFSLENBQW9CemdCLE1BQXBCLEVBQTRCdUYsR0FBNUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBU2dkLGNBQVQsQ0FBeUIzYixLQUF6QixFQUFnQ3ZCLFFBQWhDLEVBQTBDOGMsa0JBQTFDLEVBQThEO0FBQzVELFNBQUlodkIsTUFBTW1CLE9BQU4sQ0FBYytRLFFBQWQsQ0FBSixFQUE2QjtBQUMzQixZQUFLLElBQUl0ZCxJQUFJLENBQWIsRUFBZ0JBLElBQUlzZCxTQUFTcmQsTUFBN0IsRUFBcUMsRUFBRUQsQ0FBdkMsRUFBMEM7QUFDeENtNkIsbUJBQVU3YyxTQUFTdGQsQ0FBVCxDQUFWLEVBQXVCbzZCLGtCQUF2QixFQUEyQ3ZiLE1BQU1yQixHQUFqRCxFQUFzRCxJQUF0RCxFQUE0RCxJQUE1RDtBQUNEO0FBQ0YsTUFKRCxNQUlPLElBQUk5VixZQUFZbVgsTUFBTXRCLElBQWxCLENBQUosRUFBNkI7QUFDbEN1YixlQUFRSixXQUFSLENBQW9CN1osTUFBTXJCLEdBQTFCLEVBQStCc2IsUUFBUXJsQixjQUFSLENBQXVCb0wsTUFBTXRCLElBQTdCLENBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTdWQsV0FBVCxDQUFzQmpjLEtBQXRCLEVBQTZCO0FBQzNCLFlBQU9BLE1BQU1mLGlCQUFiLEVBQWdDO0FBQzlCZSxlQUFRQSxNQUFNZixpQkFBTixDQUF3Qm1ILE1BQWhDO0FBQ0Q7QUFDRCxZQUFPMWQsTUFBTXNYLE1BQU14QyxHQUFaLENBQVA7QUFDRDs7QUFFRCxZQUFTb2UsaUJBQVQsQ0FBNEI1YixLQUE1QixFQUFtQ3ViLGtCQUFuQyxFQUF1RDtBQUNyRCxVQUFLLElBQUloWCxNQUFNLENBQWYsRUFBa0JBLE1BQU1DLElBQUlwYSxNQUFKLENBQVdoSixNQUFuQyxFQUEyQyxFQUFFbWpCLEdBQTdDLEVBQWtEO0FBQ2hEQyxXQUFJcGEsTUFBSixDQUFXbWEsR0FBWCxFQUFnQitWLFNBQWhCLEVBQTJCdGEsS0FBM0I7QUFDRDtBQUNEN2UsU0FBSTZlLE1BQU10WixJQUFOLENBQVd5VCxJQUFmLENBSnFELENBSWhDO0FBQ3JCLFNBQUl6UixNQUFNdkgsQ0FBTixDQUFKLEVBQWM7QUFDWixXQUFJdUgsTUFBTXZILEVBQUVpSixNQUFSLENBQUosRUFBcUI7QUFBRWpKLFdBQUVpSixNQUFGLENBQVNrd0IsU0FBVCxFQUFvQnRhLEtBQXBCO0FBQTZCO0FBQ3BELFdBQUl0WCxNQUFNdkgsRUFBRXd0QixNQUFSLENBQUosRUFBcUI7QUFBRTRNLDRCQUFtQnhwQixJQUFuQixDQUF3QmlPLEtBQXhCO0FBQWlDO0FBQ3pEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBUzBiLFFBQVQsQ0FBbUIxYixLQUFuQixFQUEwQjtBQUN4QixTQUFJN2UsQ0FBSjtBQUNBLFNBQUltN0IsV0FBV3RjLEtBQWY7QUFDQSxZQUFPc2MsUUFBUCxFQUFpQjtBQUNmLFdBQUk1ekIsTUFBTXZILElBQUltN0IsU0FBUzFkLE9BQW5CLEtBQStCbFcsTUFBTXZILElBQUlBLEVBQUVpUSxRQUFGLENBQVdtckIsUUFBckIsQ0FBbkMsRUFBbUU7QUFDakV0QyxpQkFBUVosWUFBUixDQUFxQnJaLE1BQU1yQixHQUEzQixFQUFnQ3hkLENBQWhDLEVBQW1DLEVBQW5DO0FBQ0Q7QUFDRG03QixrQkFBV0EsU0FBU2xqQixNQUFwQjtBQUNEO0FBQ0Q7QUFDQSxTQUFJMVEsTUFBTXZILElBQUk4akIsY0FBVixLQUNGOWpCLE1BQU02ZSxNQUFNcEIsT0FEVixJQUVGbFcsTUFBTXZILElBQUlBLEVBQUVpUSxRQUFGLENBQVdtckIsUUFBckIsQ0FGRixFQUdFO0FBQ0F0QyxlQUFRWixZQUFSLENBQXFCclosTUFBTXJCLEdBQTNCLEVBQWdDeGQsQ0FBaEMsRUFBbUMsRUFBbkM7QUFDRDtBQUNGOztBQUVELFlBQVNxN0IsU0FBVCxDQUFvQnJPLFNBQXBCLEVBQStCQyxNQUEvQixFQUF1Q2pPLE1BQXZDLEVBQStDc2MsUUFBL0MsRUFBeUQzQixNQUF6RCxFQUFpRVMsa0JBQWpFLEVBQXFGO0FBQ25GLFlBQU9rQixZQUFZM0IsTUFBbkIsRUFBMkIsRUFBRTJCLFFBQTdCLEVBQXVDO0FBQ3JDbkIsaUJBQVVuYixPQUFPc2MsUUFBUCxDQUFWLEVBQTRCbEIsa0JBQTVCLEVBQWdEcE4sU0FBaEQsRUFBMkRDLE1BQTNEO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTc08saUJBQVQsQ0FBNEIxYyxLQUE1QixFQUFtQztBQUNqQyxTQUFJN2UsQ0FBSixFQUFPb25CLENBQVA7QUFDQSxTQUFJN2hCLE9BQU9zWixNQUFNdFosSUFBakI7QUFDQSxTQUFJZ0MsTUFBTWhDLElBQU4sQ0FBSixFQUFpQjtBQUNmLFdBQUlnQyxNQUFNdkgsSUFBSXVGLEtBQUt5VCxJQUFmLEtBQXdCelIsTUFBTXZILElBQUlBLEVBQUV5dEIsT0FBWixDQUE1QixFQUFrRDtBQUFFenRCLFdBQUU2ZSxLQUFGO0FBQVc7QUFDL0QsWUFBSzdlLElBQUksQ0FBVCxFQUFZQSxJQUFJcWpCLElBQUlvSyxPQUFKLENBQVl4dEIsTUFBNUIsRUFBb0MsRUFBRUQsQ0FBdEMsRUFBeUM7QUFBRXFqQixhQUFJb0ssT0FBSixDQUFZenRCLENBQVosRUFBZTZlLEtBQWY7QUFBd0I7QUFDcEU7QUFDRCxTQUFJdFgsTUFBTXZILElBQUk2ZSxNQUFNdkIsUUFBaEIsQ0FBSixFQUErQjtBQUM3QixZQUFLOEosSUFBSSxDQUFULEVBQVlBLElBQUl2SSxNQUFNdkIsUUFBTixDQUFlcmQsTUFBL0IsRUFBdUMsRUFBRW1uQixDQUF6QyxFQUE0QztBQUMxQ21VLDJCQUFrQjFjLE1BQU12QixRQUFOLENBQWU4SixDQUFmLENBQWxCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFlBQVNvVSxZQUFULENBQXVCeE8sU0FBdkIsRUFBa0NoTyxNQUFsQyxFQUEwQ3NjLFFBQTFDLEVBQW9EM0IsTUFBcEQsRUFBNEQ7QUFDMUQsWUFBTzJCLFlBQVkzQixNQUFuQixFQUEyQixFQUFFMkIsUUFBN0IsRUFBdUM7QUFDckMsV0FBSUcsS0FBS3pjLE9BQU9zYyxRQUFQLENBQVQ7QUFDQSxXQUFJL3pCLE1BQU1rMEIsRUFBTixDQUFKLEVBQWU7QUFDYixhQUFJbDBCLE1BQU1rMEIsR0FBR3BmLEdBQVQsQ0FBSixFQUFtQjtBQUNqQnFmLHFDQUEwQkQsRUFBMUI7QUFDQUYsNkJBQWtCRSxFQUFsQjtBQUNELFVBSEQsTUFHTztBQUFFO0FBQ1B4QixzQkFBV3dCLEdBQUdqZSxHQUFkO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsWUFBU2tlLHlCQUFULENBQW9DN2MsS0FBcEMsRUFBMkM4YyxFQUEzQyxFQUErQztBQUM3QyxTQUFJcDBCLE1BQU1vMEIsRUFBTixLQUFhcDBCLE1BQU1zWCxNQUFNdFosSUFBWixDQUFqQixFQUFvQztBQUNsQyxXQUFJdkYsQ0FBSjtBQUNBLFdBQUl3aUIsWUFBWWEsSUFBSTlaLE1BQUosQ0FBV3RKLE1BQVgsR0FBb0IsQ0FBcEM7QUFDQSxXQUFJc0gsTUFBTW8wQixFQUFOLENBQUosRUFBZTtBQUNiO0FBQ0E7QUFDQUEsWUFBR25aLFNBQUgsSUFBZ0JBLFNBQWhCO0FBQ0QsUUFKRCxNQUlPO0FBQ0w7QUFDQW1aLGNBQUs1QixXQUFXbGIsTUFBTXJCLEdBQWpCLEVBQXNCZ0YsU0FBdEIsQ0FBTDtBQUNEO0FBQ0Q7QUFDQSxXQUFJamIsTUFBTXZILElBQUk2ZSxNQUFNZixpQkFBaEIsS0FBc0N2VyxNQUFNdkgsSUFBSUEsRUFBRWlsQixNQUFaLENBQXRDLElBQTZEMWQsTUFBTXZILEVBQUV1RixJQUFSLENBQWpFLEVBQWdGO0FBQzlFbTJCLG1DQUEwQjE3QixDQUExQixFQUE2QjI3QixFQUE3QjtBQUNEO0FBQ0QsWUFBSzM3QixJQUFJLENBQVQsRUFBWUEsSUFBSXFqQixJQUFJOVosTUFBSixDQUFXdEosTUFBM0IsRUFBbUMsRUFBRUQsQ0FBckMsRUFBd0M7QUFDdENxakIsYUFBSTlaLE1BQUosQ0FBV3ZKLENBQVgsRUFBYzZlLEtBQWQsRUFBcUI4YyxFQUFyQjtBQUNEO0FBQ0QsV0FBSXAwQixNQUFNdkgsSUFBSTZlLE1BQU10WixJQUFOLENBQVd5VCxJQUFyQixLQUE4QnpSLE1BQU12SCxJQUFJQSxFQUFFdUosTUFBWixDQUFsQyxFQUF1RDtBQUNyRHZKLFdBQUU2ZSxLQUFGLEVBQVM4YyxFQUFUO0FBQ0QsUUFGRCxNQUVPO0FBQ0xBO0FBQ0Q7QUFDRixNQXZCRCxNQXVCTztBQUNMMUIsa0JBQVdwYixNQUFNckIsR0FBakI7QUFDRDtBQUNGOztBQUVELFlBQVNvZSxjQUFULENBQXlCNU8sU0FBekIsRUFBb0M2TyxLQUFwQyxFQUEyQ0MsS0FBM0MsRUFBa0QxQixrQkFBbEQsRUFBc0UyQixVQUF0RSxFQUFrRjtBQUNoRixTQUFJQyxjQUFjLENBQWxCO0FBQ0EsU0FBSUMsY0FBYyxDQUFsQjtBQUNBLFNBQUlDLFlBQVlMLE1BQU01N0IsTUFBTixHQUFlLENBQS9CO0FBQ0EsU0FBSWs4QixnQkFBZ0JOLE1BQU0sQ0FBTixDQUFwQjtBQUNBLFNBQUlPLGNBQWNQLE1BQU1LLFNBQU4sQ0FBbEI7QUFDQSxTQUFJRyxZQUFZUCxNQUFNNzdCLE1BQU4sR0FBZSxDQUEvQjtBQUNBLFNBQUlxOEIsZ0JBQWdCUixNQUFNLENBQU4sQ0FBcEI7QUFDQSxTQUFJUyxjQUFjVCxNQUFNTyxTQUFOLENBQWxCO0FBQ0EsU0FBSUcsV0FBSixFQUFpQkMsUUFBakIsRUFBMkJDLFNBQTNCLEVBQXNDelAsTUFBdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBSTBQLFVBQVUsQ0FBQ1osVUFBZjs7QUFFQSxZQUFPQyxlQUFlRSxTQUFmLElBQTRCRCxlQUFlSSxTQUFsRCxFQUE2RDtBQUMzRCxXQUFJaDFCLFFBQVE4MEIsYUFBUixDQUFKLEVBQTRCO0FBQzFCQSx5QkFBZ0JOLE1BQU0sRUFBRUcsV0FBUixDQUFoQixDQUQwQixDQUNZO0FBQ3ZDLFFBRkQsTUFFTyxJQUFJMzBCLFFBQVErMEIsV0FBUixDQUFKLEVBQTBCO0FBQy9CQSx1QkFBY1AsTUFBTSxFQUFFSyxTQUFSLENBQWQ7QUFDRCxRQUZNLE1BRUEsSUFBSTdDLFVBQVU4QyxhQUFWLEVBQXlCRyxhQUF6QixDQUFKLEVBQTZDO0FBQ2xETSxvQkFBV1QsYUFBWCxFQUEwQkcsYUFBMUIsRUFBeUNsQyxrQkFBekM7QUFDQStCLHlCQUFnQk4sTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0FNLHlCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsUUFKTSxNQUlBLElBQUk1QyxVQUFVK0MsV0FBVixFQUF1QkcsV0FBdkIsQ0FBSixFQUF5QztBQUM5Q0ssb0JBQVdSLFdBQVgsRUFBd0JHLFdBQXhCLEVBQXFDbkMsa0JBQXJDO0FBQ0FnQyx1QkFBY1AsTUFBTSxFQUFFSyxTQUFSLENBQWQ7QUFDQUssdUJBQWNULE1BQU0sRUFBRU8sU0FBUixDQUFkO0FBQ0QsUUFKTSxNQUlBLElBQUloRCxVQUFVOEMsYUFBVixFQUF5QkksV0FBekIsQ0FBSixFQUEyQztBQUFFO0FBQ2xESyxvQkFBV1QsYUFBWCxFQUEwQkksV0FBMUIsRUFBdUNuQyxrQkFBdkM7QUFDQXVDLG9CQUFXN0QsUUFBUVIsWUFBUixDQUFxQnRMLFNBQXJCLEVBQWdDbVAsY0FBYzNlLEdBQTlDLEVBQW1Ec2IsUUFBUUgsV0FBUixDQUFvQnlELFlBQVk1ZSxHQUFoQyxDQUFuRCxDQUFYO0FBQ0EyZSx5QkFBZ0JOLE1BQU0sRUFBRUcsV0FBUixDQUFoQjtBQUNBTyx1QkFBY1QsTUFBTSxFQUFFTyxTQUFSLENBQWQ7QUFDRCxRQUxNLE1BS0EsSUFBSWhELFVBQVUrQyxXQUFWLEVBQXVCRSxhQUF2QixDQUFKLEVBQTJDO0FBQUU7QUFDbERNLG9CQUFXUixXQUFYLEVBQXdCRSxhQUF4QixFQUF1Q2xDLGtCQUF2QztBQUNBdUMsb0JBQVc3RCxRQUFRUixZQUFSLENBQXFCdEwsU0FBckIsRUFBZ0NvUCxZQUFZNWUsR0FBNUMsRUFBaUQyZSxjQUFjM2UsR0FBL0QsQ0FBWDtBQUNBNGUsdUJBQWNQLE1BQU0sRUFBRUssU0FBUixDQUFkO0FBQ0FJLHlCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0QsUUFMTSxNQUtBO0FBQ0wsYUFBSTUwQixRQUFRbTFCLFdBQVIsQ0FBSixFQUEwQjtBQUFFQSx5QkFBYy9DLGtCQUFrQm9DLEtBQWxCLEVBQXlCRyxXQUF6QixFQUFzQ0UsU0FBdEMsQ0FBZDtBQUFpRTtBQUM3Rk8sb0JBQVdsMUIsTUFBTSswQixjQUFjenlCLEdBQXBCLElBQTJCMnlCLFlBQVlGLGNBQWN6eUIsR0FBMUIsQ0FBM0IsR0FBNEQsSUFBdkU7QUFDQSxhQUFJeEMsUUFBUW8xQixRQUFSLENBQUosRUFBdUI7QUFBRTtBQUN2QnRDLHFCQUFVbUMsYUFBVixFQUF5QmxDLGtCQUF6QixFQUE2Q3BOLFNBQTdDLEVBQXdEbVAsY0FBYzNlLEdBQXRFO0FBQ0E4ZSwyQkFBZ0JSLE1BQU0sRUFBRUcsV0FBUixDQUFoQjtBQUNELFVBSEQsTUFHTztBQUNMUyx1QkFBWWIsTUFBTVksUUFBTixDQUFaO0FBQ0E7QUFDQSxlQUFJbnZCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QyxDQUFDa3ZCLFNBQTlDLEVBQXlEO0FBQ3ZEdHRCLGtCQUNFLHdFQUNBLDZDQUZGO0FBSUQ7QUFDRCxlQUFJaXFCLFVBQVVxRCxTQUFWLEVBQXFCSixhQUFyQixDQUFKLEVBQXlDO0FBQ3ZDTSx3QkFBV0YsU0FBWCxFQUFzQkosYUFBdEIsRUFBcUNsQyxrQkFBckM7QUFDQXlCLG1CQUFNWSxRQUFOLElBQWtCNzhCLFNBQWxCO0FBQ0ErOEIsd0JBQVc3RCxRQUFRUixZQUFSLENBQXFCdEwsU0FBckIsRUFBZ0MwUCxVQUFVbGYsR0FBMUMsRUFBK0MyZSxjQUFjM2UsR0FBN0QsQ0FBWDtBQUNBOGUsNkJBQWdCUixNQUFNLEVBQUVHLFdBQVIsQ0FBaEI7QUFDRCxZQUxELE1BS087QUFDTDtBQUNBOUIsdUJBQVVtQyxhQUFWLEVBQXlCbEMsa0JBQXpCLEVBQTZDcE4sU0FBN0MsRUFBd0RtUCxjQUFjM2UsR0FBdEU7QUFDQThlLDZCQUFnQlIsTUFBTSxFQUFFRyxXQUFSLENBQWhCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxTQUFJRCxjQUFjRSxTQUFsQixFQUE2QjtBQUMzQmpQLGdCQUFTNWxCLFFBQVF5MEIsTUFBTU8sWUFBWSxDQUFsQixDQUFSLElBQWdDLElBQWhDLEdBQXVDUCxNQUFNTyxZQUFZLENBQWxCLEVBQXFCN2UsR0FBckU7QUFDQTZkLGlCQUFVck8sU0FBVixFQUFxQkMsTUFBckIsRUFBNkI2TyxLQUE3QixFQUFvQ0csV0FBcEMsRUFBaURJLFNBQWpELEVBQTREakMsa0JBQTVEO0FBQ0QsTUFIRCxNQUdPLElBQUk2QixjQUFjSSxTQUFsQixFQUE2QjtBQUNsQ2Isb0JBQWF4TyxTQUFiLEVBQXdCNk8sS0FBeEIsRUFBK0JHLFdBQS9CLEVBQTRDRSxTQUE1QztBQUNEO0FBQ0Y7O0FBRUQsWUFBU1UsVUFBVCxDQUFxQnJQLFFBQXJCLEVBQStCMU8sS0FBL0IsRUFBc0N1YixrQkFBdEMsRUFBMEQyQixVQUExRCxFQUFzRTtBQUNwRSxTQUFJeE8sYUFBYTFPLEtBQWpCLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBRUQsU0FBSXJCLE1BQU1xQixNQUFNckIsR0FBTixHQUFZK1AsU0FBUy9QLEdBQS9COztBQUVBLFNBQUloVyxPQUFPK2xCLFNBQVNqUCxrQkFBaEIsQ0FBSixFQUF5QztBQUN2QyxXQUFJL1csTUFBTXNYLE1BQU1sQixZQUFOLENBQW1COEQsUUFBekIsQ0FBSixFQUF3QztBQUN0Q29iLGlCQUFRdFAsU0FBUy9QLEdBQWpCLEVBQXNCcUIsS0FBdEIsRUFBNkJ1YixrQkFBN0I7QUFDRCxRQUZELE1BRU87QUFDTHZiLGVBQU1QLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBSTlXLE9BQU9xWCxNQUFNYixRQUFiLEtBQ0Z4VyxPQUFPK2xCLFNBQVN2UCxRQUFoQixDQURFLElBRUZhLE1BQU1oVixHQUFOLEtBQWMwakIsU0FBUzFqQixHQUZyQixLQUdEckMsT0FBT3FYLE1BQU1WLFFBQWIsS0FBMEIzVyxPQUFPcVgsTUFBTVQsTUFBYixDQUh6QixDQUFKLEVBSUU7QUFDQVMsYUFBTWYsaUJBQU4sR0FBMEJ5UCxTQUFTelAsaUJBQW5DO0FBQ0E7QUFDRDs7QUFFRCxTQUFJOWQsQ0FBSjtBQUNBLFNBQUl1RixPQUFPc1osTUFBTXRaLElBQWpCO0FBQ0EsU0FBSWdDLE1BQU1oQyxJQUFOLEtBQWVnQyxNQUFNdkgsSUFBSXVGLEtBQUt5VCxJQUFmLENBQWYsSUFBdUN6UixNQUFNdkgsSUFBSUEsRUFBRXN0QixRQUFaLENBQTNDLEVBQWtFO0FBQ2hFdHRCLFNBQUV1dEIsUUFBRixFQUFZMU8sS0FBWjtBQUNEOztBQUVELFNBQUlnZCxRQUFRdE8sU0FBU2pRLFFBQXJCO0FBQ0EsU0FBSW1lLEtBQUs1YyxNQUFNdkIsUUFBZjtBQUNBLFNBQUkvVixNQUFNaEMsSUFBTixLQUFldTFCLFlBQVlqYyxLQUFaLENBQW5CLEVBQXVDO0FBQ3JDLFlBQUs3ZSxJQUFJLENBQVQsRUFBWUEsSUFBSXFqQixJQUFJdE8sTUFBSixDQUFXOVUsTUFBM0IsRUFBbUMsRUFBRUQsQ0FBckMsRUFBd0M7QUFBRXFqQixhQUFJdE8sTUFBSixDQUFXL1UsQ0FBWCxFQUFjdXRCLFFBQWQsRUFBd0IxTyxLQUF4QjtBQUFpQztBQUMzRSxXQUFJdFgsTUFBTXZILElBQUl1RixLQUFLeVQsSUFBZixLQUF3QnpSLE1BQU12SCxJQUFJQSxFQUFFK1UsTUFBWixDQUE1QixFQUFpRDtBQUFFL1UsV0FBRXV0QixRQUFGLEVBQVkxTyxLQUFaO0FBQXFCO0FBQ3pFO0FBQ0QsU0FBSXhYLFFBQVF3WCxNQUFNdEIsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFdBQUloVyxNQUFNczBCLEtBQU4sS0FBZ0J0MEIsTUFBTWswQixFQUFOLENBQXBCLEVBQStCO0FBQzdCLGFBQUlJLFVBQVVKLEVBQWQsRUFBa0I7QUFBRUcsMEJBQWVwZSxHQUFmLEVBQW9CcWUsS0FBcEIsRUFBMkJKLEVBQTNCLEVBQStCckIsa0JBQS9CLEVBQW1EMkIsVUFBbkQ7QUFBaUU7QUFDdEYsUUFGRCxNQUVPLElBQUl4MEIsTUFBTWswQixFQUFOLENBQUosRUFBZTtBQUNwQixhQUFJbDBCLE1BQU1nbUIsU0FBU2hRLElBQWYsQ0FBSixFQUEwQjtBQUFFdWIsbUJBQVFGLGNBQVIsQ0FBdUJwYixHQUF2QixFQUE0QixFQUE1QjtBQUFrQztBQUM5RDZkLG1CQUFVN2QsR0FBVixFQUFlLElBQWYsRUFBcUJpZSxFQUFyQixFQUF5QixDQUF6QixFQUE0QkEsR0FBR3g3QixNQUFILEdBQVksQ0FBeEMsRUFBMkNtNkIsa0JBQTNDO0FBQ0QsUUFITSxNQUdBLElBQUk3eUIsTUFBTXMwQixLQUFOLENBQUosRUFBa0I7QUFDdkJMLHNCQUFhaGUsR0FBYixFQUFrQnFlLEtBQWxCLEVBQXlCLENBQXpCLEVBQTRCQSxNQUFNNTdCLE1BQU4sR0FBZSxDQUEzQztBQUNELFFBRk0sTUFFQSxJQUFJc0gsTUFBTWdtQixTQUFTaFEsSUFBZixDQUFKLEVBQTBCO0FBQy9CdWIsaUJBQVFGLGNBQVIsQ0FBdUJwYixHQUF2QixFQUE0QixFQUE1QjtBQUNEO0FBQ0YsTUFYRCxNQVdPLElBQUkrUCxTQUFTaFEsSUFBVCxLQUFrQnNCLE1BQU10QixJQUE1QixFQUFrQztBQUN2Q3ViLGVBQVFGLGNBQVIsQ0FBdUJwYixHQUF2QixFQUE0QnFCLE1BQU10QixJQUFsQztBQUNEO0FBQ0QsU0FBSWhXLE1BQU1oQyxJQUFOLENBQUosRUFBaUI7QUFDZixXQUFJZ0MsTUFBTXZILElBQUl1RixLQUFLeVQsSUFBZixLQUF3QnpSLE1BQU12SCxJQUFJQSxFQUFFODhCLFNBQVosQ0FBNUIsRUFBb0Q7QUFBRTk4QixXQUFFdXRCLFFBQUYsRUFBWTFPLEtBQVo7QUFBcUI7QUFDNUU7QUFDRjs7QUFFRCxZQUFTa2UsZ0JBQVQsQ0FBMkJsZSxLQUEzQixFQUFrQ3lJLEtBQWxDLEVBQXlDMFYsT0FBekMsRUFBa0Q7QUFDaEQ7QUFDQTtBQUNBLFNBQUl4MUIsT0FBT3cxQixPQUFQLEtBQW1CejFCLE1BQU1zWCxNQUFNNUcsTUFBWixDQUF2QixFQUE0QztBQUMxQzRHLGFBQU01RyxNQUFOLENBQWExUyxJQUFiLENBQWtCczFCLGFBQWxCLEdBQWtDdlQsS0FBbEM7QUFDRCxNQUZELE1BRU87QUFDTCxZQUFLLElBQUl0bkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc25CLE1BQU1ybkIsTUFBMUIsRUFBa0MsRUFBRUQsQ0FBcEMsRUFBdUM7QUFDckNzbkIsZUFBTXRuQixDQUFOLEVBQVN1RixJQUFULENBQWN5VCxJQUFkLENBQW1Cd1UsTUFBbkIsQ0FBMEJsRyxNQUFNdG5CLENBQU4sQ0FBMUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsT0FBSWk5QixTQUFTLEtBQWI7QUFDQTtBQUNBO0FBQ0EsT0FBSUMsbUJBQW1CcjBCLFFBQVEsK0NBQVIsQ0FBdkI7O0FBRUE7QUFDQSxZQUFTZzBCLE9BQVQsQ0FBa0JyZixHQUFsQixFQUF1QnFCLEtBQXZCLEVBQThCdWIsa0JBQTlCLEVBQWtEO0FBQ2hELFNBQUk1eUIsT0FBT3FYLE1BQU1YLFNBQWIsS0FBMkIzVyxNQUFNc1gsTUFBTWxCLFlBQVosQ0FBL0IsRUFBMEQ7QUFDeERrQixhQUFNckIsR0FBTixHQUFZQSxHQUFaO0FBQ0FxQixhQUFNUCxrQkFBTixHQUEyQixJQUEzQjtBQUNBLGNBQU8sSUFBUDtBQUNEO0FBQ0QsU0FBSWhSLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJLENBQUMydkIsZ0JBQWdCM2YsR0FBaEIsRUFBcUJxQixLQUFyQixDQUFMLEVBQWtDO0FBQ2hDLGdCQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0RBLFdBQU1yQixHQUFOLEdBQVlBLEdBQVo7QUFDQSxTQUFJbkIsTUFBTXdDLE1BQU14QyxHQUFoQjtBQUNBLFNBQUk5VyxPQUFPc1osTUFBTXRaLElBQWpCO0FBQ0EsU0FBSStYLFdBQVd1QixNQUFNdkIsUUFBckI7QUFDQSxTQUFJL1YsTUFBTWhDLElBQU4sQ0FBSixFQUFpQjtBQUNmLFdBQUlnQyxNQUFNdkgsSUFBSXVGLEtBQUt5VCxJQUFmLEtBQXdCelIsTUFBTXZILElBQUlBLEVBQUUrc0IsSUFBWixDQUE1QixFQUErQztBQUFFL3NCLFdBQUU2ZSxLQUFGLEVBQVMsSUFBVCxDQUFjLGVBQWQ7QUFBaUM7QUFDbEYsV0FBSXRYLE1BQU12SCxJQUFJNmUsTUFBTWYsaUJBQWhCLENBQUosRUFBd0M7QUFDdEM7QUFDQTZjLHVCQUFjOWIsS0FBZCxFQUFxQnViLGtCQUFyQjtBQUNBLGdCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBSTd5QixNQUFNOFUsR0FBTixDQUFKLEVBQWdCO0FBQ2QsV0FBSTlVLE1BQU0rVixRQUFOLENBQUosRUFBcUI7QUFDbkI7QUFDQSxhQUFJLENBQUNFLElBQUk0ZixhQUFKLEVBQUwsRUFBMEI7QUFDeEI1QywwQkFBZTNiLEtBQWYsRUFBc0J2QixRQUF0QixFQUFnQzhjLGtCQUFoQztBQUNELFVBRkQsTUFFTztBQUNMLGVBQUlpRCxnQkFBZ0IsSUFBcEI7QUFDQSxlQUFJM0csWUFBWWxaLElBQUk4ZixVQUFwQjtBQUNBLGdCQUFLLElBQUlsYSxNQUFNLENBQWYsRUFBa0JBLE1BQU05RixTQUFTcmQsTUFBakMsRUFBeUNtakIsS0FBekMsRUFBZ0Q7QUFDOUMsaUJBQUksQ0FBQ3NULFNBQUQsSUFBYyxDQUFDbUcsUUFBUW5HLFNBQVIsRUFBbUJwWixTQUFTOEYsR0FBVCxDQUFuQixFQUFrQ2dYLGtCQUFsQyxDQUFuQixFQUEwRTtBQUN4RWlELCtCQUFnQixLQUFoQjtBQUNBO0FBQ0Q7QUFDRDNHLHlCQUFZQSxVQUFVaUMsV0FBdEI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxlQUFJLENBQUMwRSxhQUFELElBQWtCM0csU0FBdEIsRUFBaUM7QUFDL0IsaUJBQUlwcEIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0YsT0FBTzdOLE9BQVAsS0FBbUIsV0FEakIsSUFFRixDQUFDczlCLE1BRkgsRUFHRTtBQUNBQSx3QkFBUyxJQUFUO0FBQ0F0OUIsdUJBQVF5UCxJQUFSLENBQWEsVUFBYixFQUF5Qm9PLEdBQXpCO0FBQ0E3ZCx1QkFBUXlQLElBQVIsQ0FBYSxxQ0FBYixFQUFvRG9PLElBQUkrZixVQUF4RCxFQUFvRWpnQixRQUFwRTtBQUNEO0FBQ0Qsb0JBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFdBQUkvVixNQUFNaEMsSUFBTixDQUFKLEVBQWlCO0FBQ2YsY0FBSyxJQUFJc0UsR0FBVCxJQUFnQnRFLElBQWhCLEVBQXNCO0FBQ3BCLGVBQUksQ0FBQzIzQixpQkFBaUJyekIsR0FBakIsQ0FBTCxFQUE0QjtBQUMxQjR3QiwrQkFBa0I1YixLQUFsQixFQUF5QnViLGtCQUF6QjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsTUF0Q0QsTUFzQ08sSUFBSTVjLElBQUlqWSxJQUFKLEtBQWFzWixNQUFNdEIsSUFBdkIsRUFBNkI7QUFDbENDLFdBQUlqWSxJQUFKLEdBQVdzWixNQUFNdEIsSUFBakI7QUFDRDtBQUNELFlBQU8sSUFBUDtBQUNEOztBQUVELFlBQVM0ZixlQUFULENBQTBCemUsSUFBMUIsRUFBZ0NHLEtBQWhDLEVBQXVDO0FBQ3JDLFNBQUl0WCxNQUFNc1gsTUFBTXhDLEdBQVosQ0FBSixFQUFzQjtBQUNwQixjQUNFd0MsTUFBTXhDLEdBQU4sQ0FBVTNhLE9BQVYsQ0FBa0IsZUFBbEIsTUFBdUMsQ0FBdkMsSUFDQW1kLE1BQU14QyxHQUFOLENBQVVqVCxXQUFWLFFBQTZCc1YsS0FBS3NaLE9BQUwsSUFBZ0J0WixLQUFLc1osT0FBTCxDQUFhNXVCLFdBQWIsRUFBN0MsQ0FGRjtBQUlELE1BTEQsTUFLTztBQUNMLGNBQU9zVixLQUFLOGUsUUFBTCxNQUFtQjNlLE1BQU1YLFNBQU4sR0FBa0IsQ0FBbEIsR0FBc0IsQ0FBekMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsVUFBTyxTQUFTdWYsS0FBVCxDQUFnQmxRLFFBQWhCLEVBQTBCMU8sS0FBMUIsRUFBaUMrRixTQUFqQyxFQUE0Q21YLFVBQTVDLEVBQXdEL08sU0FBeEQsRUFBbUVDLE1BQW5FLEVBQTJFO0FBQ2hGLFNBQUk1bEIsUUFBUXdYLEtBQVIsQ0FBSixFQUFvQjtBQUNsQixXQUFJdFgsTUFBTWdtQixRQUFOLENBQUosRUFBcUI7QUFBRWdPLDJCQUFrQmhPLFFBQWxCO0FBQThCO0FBQ3JEO0FBQ0Q7O0FBRUQsU0FBSW1RLGlCQUFpQixLQUFyQjtBQUNBLFNBQUl0RCxxQkFBcUIsRUFBekI7O0FBRUEsU0FBSS95QixRQUFRa21CLFFBQVIsQ0FBSixFQUF1QjtBQUNyQjtBQUNBbVEsd0JBQWlCLElBQWpCO0FBQ0F2RCxpQkFBVXRiLEtBQVYsRUFBaUJ1YixrQkFBakIsRUFBcUNwTixTQUFyQyxFQUFnREMsTUFBaEQ7QUFDRCxNQUpELE1BSU87QUFDTCxXQUFJMFEsZ0JBQWdCcDJCLE1BQU1nbUIsU0FBU2lRLFFBQWYsQ0FBcEI7QUFDQSxXQUFJLENBQUNHLGFBQUQsSUFBa0J0RSxVQUFVOUwsUUFBVixFQUFvQjFPLEtBQXBCLENBQXRCLEVBQWtEO0FBQ2hEO0FBQ0ErZCxvQkFBV3JQLFFBQVgsRUFBcUIxTyxLQUFyQixFQUE0QnViLGtCQUE1QixFQUFnRDJCLFVBQWhEO0FBQ0QsUUFIRCxNQUdPO0FBQ0wsYUFBSTRCLGFBQUosRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBSXBRLFNBQVNpUSxRQUFULEtBQXNCLENBQXRCLElBQTJCalEsU0FBU3FRLFlBQVQsQ0FBc0I3d0IsUUFBdEIsQ0FBL0IsRUFBZ0U7QUFDOUR3Z0Isc0JBQVNzUSxlQUFULENBQXlCOXdCLFFBQXpCO0FBQ0E2WCx5QkFBWSxJQUFaO0FBQ0Q7QUFDRCxlQUFJcGQsT0FBT29kLFNBQVAsQ0FBSixFQUF1QjtBQUNyQixpQkFBSWlZLFFBQVF0UCxRQUFSLEVBQWtCMU8sS0FBbEIsRUFBeUJ1YixrQkFBekIsQ0FBSixFQUFrRDtBQUNoRDJDLGdDQUFpQmxlLEtBQWpCLEVBQXdCdWIsa0JBQXhCLEVBQTRDLElBQTVDO0FBQ0Esc0JBQU83TSxRQUFQO0FBQ0QsY0FIRCxNQUdPLElBQUlqZ0IsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hENEIsb0JBQ0UsK0RBQ0EsOERBREEsR0FFQSwrREFGQSxHQUdBLDREQUhBLEdBSUEsMEJBTEY7QUFPRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBbWUsc0JBQVd1TSxZQUFZdk0sUUFBWixDQUFYO0FBQ0Q7QUFDRDtBQUNBLGFBQUl1USxTQUFTdlEsU0FBUy9QLEdBQXRCO0FBQ0EsYUFBSXVnQixjQUFjakYsUUFBUXJDLFVBQVIsQ0FBbUJxSCxNQUFuQixDQUFsQjtBQUNBM0QsbUJBQ0V0YixLQURGLEVBRUV1YixrQkFGRjtBQUdFO0FBQ0E7QUFDQTtBQUNBMEQsZ0JBQU9FLFFBQVAsR0FBa0IsSUFBbEIsR0FBeUJELFdBTjNCLEVBT0VqRixRQUFRSCxXQUFSLENBQW9CbUYsTUFBcEIsQ0FQRjs7QUFVQSxhQUFJdjJCLE1BQU1zWCxNQUFNNUcsTUFBWixDQUFKLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFJa2pCLFdBQVd0YyxNQUFNNUcsTUFBckI7QUFDQSxrQkFBT2tqQixRQUFQLEVBQWlCO0FBQ2ZBLHNCQUFTM2QsR0FBVCxHQUFlcUIsTUFBTXJCLEdBQXJCO0FBQ0EyZCx3QkFBV0EsU0FBU2xqQixNQUFwQjtBQUNEO0FBQ0QsZUFBSTZpQixZQUFZamMsS0FBWixDQUFKLEVBQXdCO0FBQ3RCLGtCQUFLLElBQUk3ZSxJQUFJLENBQWIsRUFBZ0JBLElBQUlxakIsSUFBSXBhLE1BQUosQ0FBV2hKLE1BQS9CLEVBQXVDLEVBQUVELENBQXpDLEVBQTRDO0FBQzFDcWpCLG1CQUFJcGEsTUFBSixDQUFXakosQ0FBWCxFQUFjbTVCLFNBQWQsRUFBeUJ0YSxNQUFNNUcsTUFBL0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBSTFRLE1BQU13MkIsV0FBTixDQUFKLEVBQXdCO0FBQ3RCdkMsd0JBQWF1QyxXQUFiLEVBQTBCLENBQUN4USxRQUFELENBQTFCLEVBQXNDLENBQXRDLEVBQXlDLENBQXpDO0FBQ0QsVUFGRCxNQUVPLElBQUlobUIsTUFBTWdtQixTQUFTbFIsR0FBZixDQUFKLEVBQXlCO0FBQzlCa2YsNkJBQWtCaE8sUUFBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUR3UCxzQkFBaUJsZSxLQUFqQixFQUF3QnViLGtCQUF4QixFQUE0Q3NELGNBQTVDO0FBQ0EsWUFBTzdlLE1BQU1yQixHQUFiO0FBQ0QsSUFuRkQ7QUFvRkQ7O0FBRUQ7O0FBRUEsS0FBSXhELGFBQWE7QUFDZi9RLFdBQVFnMUIsZ0JBRE87QUFFZmxwQixXQUFRa3BCLGdCQUZPO0FBR2Z4USxZQUFTLFNBQVN5USxnQkFBVCxDQUEyQnJmLEtBQTNCLEVBQWtDO0FBQ3pDb2Ysc0JBQWlCcGYsS0FBakIsRUFBd0JzYSxTQUF4QjtBQUNEO0FBTGMsRUFBakI7O0FBUUEsVUFBUzhFLGdCQUFULENBQTJCMVEsUUFBM0IsRUFBcUMxTyxLQUFyQyxFQUE0QztBQUMxQyxPQUFJME8sU0FBU2hvQixJQUFULENBQWN5VSxVQUFkLElBQTRCNkUsTUFBTXRaLElBQU4sQ0FBV3lVLFVBQTNDLEVBQXVEO0FBQ3JEMkssYUFBUTRJLFFBQVIsRUFBa0IxTyxLQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzhGLE9BQVQsQ0FBa0I0SSxRQUFsQixFQUE0QjFPLEtBQTVCLEVBQW1DO0FBQ2pDLE9BQUlzZixXQUFXNVEsYUFBYTRMLFNBQTVCO0FBQ0EsT0FBSWlGLFlBQVl2ZixVQUFVc2EsU0FBMUI7QUFDQSxPQUFJa0YsVUFBVUMsc0JBQXNCL1EsU0FBU2hvQixJQUFULENBQWN5VSxVQUFwQyxFQUFnRHVULFNBQVM5UCxPQUF6RCxDQUFkO0FBQ0EsT0FBSThnQixVQUFVRCxzQkFBc0J6ZixNQUFNdFosSUFBTixDQUFXeVUsVUFBakMsRUFBNkM2RSxNQUFNcEIsT0FBbkQsQ0FBZDs7QUFFQSxPQUFJK2dCLGlCQUFpQixFQUFyQjtBQUNBLE9BQUlDLG9CQUFvQixFQUF4Qjs7QUFFQSxPQUFJNTBCLEdBQUosRUFBUzYwQixNQUFULEVBQWlCQyxHQUFqQjtBQUNBLFFBQUs5MEIsR0FBTCxJQUFZMDBCLE9BQVosRUFBcUI7QUFDbkJHLGNBQVNMLFFBQVF4MEIsR0FBUixDQUFUO0FBQ0E4MEIsV0FBTUosUUFBUTEwQixHQUFSLENBQU47QUFDQSxTQUFJLENBQUM2MEIsTUFBTCxFQUFhO0FBQ1g7QUFDQUUsa0JBQVdELEdBQVgsRUFBZ0IsTUFBaEIsRUFBd0I5ZixLQUF4QixFQUErQjBPLFFBQS9CO0FBQ0EsV0FBSW9SLElBQUlqd0IsR0FBSixJQUFXaXdCLElBQUlqd0IsR0FBSixDQUFRb0gsUUFBdkIsRUFBaUM7QUFDL0Iwb0Isd0JBQWU1dEIsSUFBZixDQUFvQit0QixHQUFwQjtBQUNEO0FBQ0YsTUFORCxNQU1PO0FBQ0w7QUFDQUEsV0FBSXRWLFFBQUosR0FBZXFWLE9BQU8vMkIsS0FBdEI7QUFDQWkzQixrQkFBV0QsR0FBWCxFQUFnQixRQUFoQixFQUEwQjlmLEtBQTFCLEVBQWlDME8sUUFBakM7QUFDQSxXQUFJb1IsSUFBSWp3QixHQUFKLElBQVdpd0IsSUFBSWp3QixHQUFKLENBQVFtd0IsZ0JBQXZCLEVBQXlDO0FBQ3ZDSiwyQkFBa0I3dEIsSUFBbEIsQ0FBdUIrdEIsR0FBdkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsT0FBSUgsZUFBZXYrQixNQUFuQixFQUEyQjtBQUN6QixTQUFJNitCLGFBQWEsU0FBYkEsVUFBYSxHQUFZO0FBQzNCLFlBQUssSUFBSTkrQixJQUFJLENBQWIsRUFBZ0JBLElBQUl3K0IsZUFBZXYrQixNQUFuQyxFQUEyQ0QsR0FBM0MsRUFBZ0Q7QUFDOUM0K0Isb0JBQVdKLGVBQWV4K0IsQ0FBZixDQUFYLEVBQThCLFVBQTlCLEVBQTBDNmUsS0FBMUMsRUFBaUQwTyxRQUFqRDtBQUNEO0FBQ0YsTUFKRDtBQUtBLFNBQUk0USxRQUFKLEVBQWM7QUFDWnBlLHNCQUFlbEIsTUFBTXRaLElBQU4sQ0FBV3lULElBQVgsS0FBb0I2RixNQUFNdFosSUFBTixDQUFXeVQsSUFBWCxHQUFrQixFQUF0QyxDQUFmLEVBQTBELFFBQTFELEVBQW9FOGxCLFVBQXBFO0FBQ0QsTUFGRCxNQUVPO0FBQ0xBO0FBQ0Q7QUFDRjs7QUFFRCxPQUFJTCxrQkFBa0J4K0IsTUFBdEIsRUFBOEI7QUFDNUI4ZixvQkFBZWxCLE1BQU10WixJQUFOLENBQVd5VCxJQUFYLEtBQW9CNkYsTUFBTXRaLElBQU4sQ0FBV3lULElBQVgsR0FBa0IsRUFBdEMsQ0FBZixFQUEwRCxXQUExRCxFQUF1RSxZQUFZO0FBQ2pGLFlBQUssSUFBSWhaLElBQUksQ0FBYixFQUFnQkEsSUFBSXkrQixrQkFBa0J4K0IsTUFBdEMsRUFBOENELEdBQTlDLEVBQW1EO0FBQ2pENCtCLG9CQUFXSCxrQkFBa0J6K0IsQ0FBbEIsQ0FBWCxFQUFpQyxrQkFBakMsRUFBcUQ2ZSxLQUFyRCxFQUE0RDBPLFFBQTVEO0FBQ0Q7QUFDRixNQUpEO0FBS0Q7O0FBRUQsT0FBSSxDQUFDNFEsUUFBTCxFQUFlO0FBQ2IsVUFBS3QwQixHQUFMLElBQVl3MEIsT0FBWixFQUFxQjtBQUNuQixXQUFJLENBQUNFLFFBQVExMEIsR0FBUixDQUFMLEVBQW1CO0FBQ2pCO0FBQ0ErMEIsb0JBQVdQLFFBQVF4MEIsR0FBUixDQUFYLEVBQXlCLFFBQXpCLEVBQW1DMGpCLFFBQW5DLEVBQTZDQSxRQUE3QyxFQUF1RDZRLFNBQXZEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsS0FBSVcsaUJBQWlCbjRCLE9BQU9xQyxNQUFQLENBQWMsSUFBZCxDQUFyQjs7QUFFQSxVQUFTcTFCLHFCQUFULENBQ0V2a0IsSUFERixFQUVFcEssRUFGRixFQUdFO0FBQ0EsT0FBSTdLLE1BQU04QixPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLE9BQUksQ0FBQzhRLElBQUwsRUFBVztBQUNULFlBQU9qVixHQUFQO0FBQ0Q7QUFDRCxPQUFJOUUsQ0FBSixFQUFPMitCLEdBQVA7QUFDQSxRQUFLMytCLElBQUksQ0FBVCxFQUFZQSxJQUFJK1osS0FBSzlaLE1BQXJCLEVBQTZCRCxHQUE3QixFQUFrQztBQUNoQzIrQixXQUFNNWtCLEtBQUsvWixDQUFMLENBQU47QUFDQSxTQUFJLENBQUMyK0IsSUFBSUssU0FBVCxFQUFvQjtBQUNsQkwsV0FBSUssU0FBSixHQUFnQkQsY0FBaEI7QUFDRDtBQUNEajZCLFNBQUltNkIsY0FBY04sR0FBZCxDQUFKLElBQTBCQSxHQUExQjtBQUNBQSxTQUFJandCLEdBQUosR0FBVTZMLGFBQWE1SyxHQUFHTSxRQUFoQixFQUEwQixZQUExQixFQUF3QzB1QixJQUFJcCtCLElBQTVDLEVBQWtELElBQWxELENBQVY7QUFDRDtBQUNELFVBQU91RSxHQUFQO0FBQ0Q7O0FBRUQsVUFBU202QixhQUFULENBQXdCTixHQUF4QixFQUE2QjtBQUMzQixVQUFPQSxJQUFJTyxPQUFKLElBQWlCUCxJQUFJcCtCLElBQUwsR0FBYSxHQUFiLEdBQW9CcUcsT0FBT0MsSUFBUCxDQUFZODNCLElBQUlLLFNBQUosSUFBaUIsRUFBN0IsRUFBaUM5eUIsSUFBakMsQ0FBc0MsR0FBdEMsQ0FBM0M7QUFDRDs7QUFFRCxVQUFTMHlCLFVBQVQsQ0FBcUJELEdBQXJCLEVBQTBCM2xCLElBQTFCLEVBQWdDNkYsS0FBaEMsRUFBdUMwTyxRQUF2QyxFQUFpRDZRLFNBQWpELEVBQTREO0FBQzFELE9BQUlyMEIsS0FBSzQwQixJQUFJandCLEdBQUosSUFBV2l3QixJQUFJandCLEdBQUosQ0FBUXNLLElBQVIsQ0FBcEI7QUFDQSxPQUFJalAsRUFBSixFQUFRO0FBQ04sU0FBSTtBQUNGQSxVQUFHOFUsTUFBTXJCLEdBQVQsRUFBY21oQixHQUFkLEVBQW1COWYsS0FBbkIsRUFBMEIwTyxRQUExQixFQUFvQzZRLFNBQXBDO0FBQ0QsTUFGRCxDQUVFLE9BQU83K0IsQ0FBUCxFQUFVO0FBQ1ZzUixtQkFBWXRSLENBQVosRUFBZXNmLE1BQU1wQixPQUFyQixFQUErQixlQUFnQmtoQixJQUFJcCtCLElBQXBCLEdBQTRCLEdBQTVCLEdBQWtDeVksSUFBbEMsR0FBeUMsT0FBeEU7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsS0FBSW1tQixjQUFjLENBQ2hCL04sR0FEZ0IsRUFFaEJwWCxVQUZnQixDQUFsQjs7QUFLQTs7QUFFQSxVQUFTb2xCLFdBQVQsQ0FBc0I3UixRQUF0QixFQUFnQzFPLEtBQWhDLEVBQXVDO0FBQ3JDLE9BQUloTixPQUFPZ04sTUFBTW5CLGdCQUFqQjtBQUNBLE9BQUluVyxNQUFNc0ssSUFBTixLQUFlQSxLQUFLUyxJQUFMLENBQVV2QyxPQUFWLENBQWtCc3ZCLFlBQWxCLEtBQW1DLEtBQXRELEVBQTZEO0FBQzNEO0FBQ0Q7QUFDRCxPQUFJaDRCLFFBQVFrbUIsU0FBU2hvQixJQUFULENBQWM4YSxLQUF0QixLQUFnQ2haLFFBQVF3WCxNQUFNdFosSUFBTixDQUFXOGEsS0FBbkIsQ0FBcEMsRUFBK0Q7QUFDN0Q7QUFDRDtBQUNELE9BQUl4VyxHQUFKLEVBQVNnVyxHQUFULEVBQWNDLEdBQWQ7QUFDQSxPQUFJdEMsTUFBTXFCLE1BQU1yQixHQUFoQjtBQUNBLE9BQUk4aEIsV0FBVy9SLFNBQVNob0IsSUFBVCxDQUFjOGEsS0FBZCxJQUF1QixFQUF0QztBQUNBLE9BQUlBLFFBQVF4QixNQUFNdFosSUFBTixDQUFXOGEsS0FBWCxJQUFvQixFQUFoQztBQUNBO0FBQ0EsT0FBSTlZLE1BQU04WSxNQUFNeEssTUFBWixDQUFKLEVBQXlCO0FBQ3ZCd0ssYUFBUXhCLE1BQU10WixJQUFOLENBQVc4YSxLQUFYLEdBQW1CaFYsT0FBTyxFQUFQLEVBQVdnVixLQUFYLENBQTNCO0FBQ0Q7O0FBRUQsUUFBS3hXLEdBQUwsSUFBWXdXLEtBQVosRUFBbUI7QUFDakJSLFdBQU1RLE1BQU14VyxHQUFOLENBQU47QUFDQWlXLFdBQU13ZixTQUFTejFCLEdBQVQsQ0FBTjtBQUNBLFNBQUlpVyxRQUFRRCxHQUFaLEVBQWlCO0FBQ2YwZixlQUFRL2hCLEdBQVIsRUFBYTNULEdBQWIsRUFBa0JnVyxHQUFsQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBO0FBQ0EsT0FBSXhPLFNBQVNnUCxNQUFNMVksS0FBTixLQUFnQjIzQixTQUFTMzNCLEtBQXRDLEVBQTZDO0FBQzNDNDNCLGFBQVEvaEIsR0FBUixFQUFhLE9BQWIsRUFBc0I2QyxNQUFNMVksS0FBNUI7QUFDRDtBQUNELFFBQUtrQyxHQUFMLElBQVl5MUIsUUFBWixFQUFzQjtBQUNwQixTQUFJajRCLFFBQVFnWixNQUFNeFcsR0FBTixDQUFSLENBQUosRUFBeUI7QUFDdkIsV0FBSXdzQixRQUFReHNCLEdBQVIsQ0FBSixFQUFrQjtBQUNoQjJULGFBQUlnaUIsaUJBQUosQ0FBc0JwSixPQUF0QixFQUErQkUsYUFBYXpzQixHQUFiLENBQS9CO0FBQ0QsUUFGRCxNQUVPLElBQUksQ0FBQ3FzQixpQkFBaUJyc0IsR0FBakIsQ0FBTCxFQUE0QjtBQUNqQzJULGFBQUlxZ0IsZUFBSixDQUFvQmgwQixHQUFwQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVMwMUIsT0FBVCxDQUFrQnhuQixFQUFsQixFQUFzQmxPLEdBQXRCLEVBQTJCbEMsS0FBM0IsRUFBa0M7QUFDaEMsT0FBSXd1QixjQUFjdHNCLEdBQWQsQ0FBSixFQUF3QjtBQUN0QjtBQUNBO0FBQ0EsU0FBSTBzQixpQkFBaUI1dUIsS0FBakIsQ0FBSixFQUE2QjtBQUMzQm9RLFVBQUc4bEIsZUFBSCxDQUFtQmgwQixHQUFuQjtBQUNELE1BRkQsTUFFTztBQUNMa08sVUFBR21nQixZQUFILENBQWdCcnVCLEdBQWhCLEVBQXFCQSxHQUFyQjtBQUNEO0FBQ0YsSUFSRCxNQVFPLElBQUlxc0IsaUJBQWlCcnNCLEdBQWpCLENBQUosRUFBMkI7QUFDaENrTyxRQUFHbWdCLFlBQUgsQ0FBZ0JydUIsR0FBaEIsRUFBcUIwc0IsaUJBQWlCNXVCLEtBQWpCLEtBQTJCQSxVQUFVLE9BQXJDLEdBQStDLE9BQS9DLEdBQXlELE1BQTlFO0FBQ0QsSUFGTSxNQUVBLElBQUkwdUIsUUFBUXhzQixHQUFSLENBQUosRUFBa0I7QUFDdkIsU0FBSTBzQixpQkFBaUI1dUIsS0FBakIsQ0FBSixFQUE2QjtBQUMzQm9RLFVBQUd5bkIsaUJBQUgsQ0FBcUJwSixPQUFyQixFQUE4QkUsYUFBYXpzQixHQUFiLENBQTlCO0FBQ0QsTUFGRCxNQUVPO0FBQ0xrTyxVQUFHMG5CLGNBQUgsQ0FBa0JySixPQUFsQixFQUEyQnZzQixHQUEzQixFQUFnQ2xDLEtBQWhDO0FBQ0Q7QUFDRixJQU5NLE1BTUE7QUFDTCxTQUFJNHVCLGlCQUFpQjV1QixLQUFqQixDQUFKLEVBQTZCO0FBQzNCb1EsVUFBRzhsQixlQUFILENBQW1CaDBCLEdBQW5CO0FBQ0QsTUFGRCxNQUVPO0FBQ0xrTyxVQUFHbWdCLFlBQUgsQ0FBZ0JydUIsR0FBaEIsRUFBcUJsQyxLQUFyQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxLQUFJMFksUUFBUTtBQUNWcFgsV0FBUW0yQixXQURFO0FBRVZycUIsV0FBUXFxQjtBQUZFLEVBQVo7O0FBS0E7O0FBRUEsVUFBU00sV0FBVCxDQUFzQm5TLFFBQXRCLEVBQWdDMU8sS0FBaEMsRUFBdUM7QUFDckMsT0FBSTlHLEtBQUs4RyxNQUFNckIsR0FBZjtBQUNBLE9BQUlqWSxPQUFPc1osTUFBTXRaLElBQWpCO0FBQ0EsT0FBSW82QixVQUFVcFMsU0FBU2hvQixJQUF2QjtBQUNBLE9BQ0U4QixRQUFROUIsS0FBS3N4QixXQUFiLEtBQ0F4dkIsUUFBUTlCLEtBQUt1eEIsS0FBYixDQURBLEtBRUV6dkIsUUFBUXM0QixPQUFSLEtBQ0V0NEIsUUFBUXM0QixRQUFROUksV0FBaEIsS0FDQXh2QixRQUFRczRCLFFBQVE3SSxLQUFoQixDQUpKLENBREYsRUFRRTtBQUNBO0FBQ0Q7O0FBRUQsT0FBSThJLE1BQU1wSixpQkFBaUIzWCxLQUFqQixDQUFWOztBQUVBO0FBQ0EsT0FBSWdoQixrQkFBa0I5bkIsR0FBRytuQixrQkFBekI7QUFDQSxPQUFJdjRCLE1BQU1zNEIsZUFBTixDQUFKLEVBQTRCO0FBQzFCRCxXQUFNNXpCLE9BQU80ekIsR0FBUCxFQUFZNUksZUFBZTZJLGVBQWYsQ0FBWixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFJRCxRQUFRN25CLEdBQUdnb0IsVUFBZixFQUEyQjtBQUN6QmhvQixRQUFHbWdCLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIwSCxHQUF6QjtBQUNBN25CLFFBQUdnb0IsVUFBSCxHQUFnQkgsR0FBaEI7QUFDRDtBQUNGOztBQUVELEtBQUlJLFFBQVE7QUFDVi8yQixXQUFReTJCLFdBREU7QUFFVjNxQixXQUFRMnFCO0FBRkUsRUFBWjs7QUFLQTs7QUFFQSxLQUFJTyxzQkFBc0IsZUFBMUI7O0FBRUEsVUFBU0MsWUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFDMUIsT0FBSUMsV0FBVyxLQUFmO0FBQ0EsT0FBSUMsV0FBVyxLQUFmO0FBQ0EsT0FBSUMsbUJBQW1CLEtBQXZCO0FBQ0EsT0FBSUMsVUFBVSxLQUFkO0FBQ0EsT0FBSUMsUUFBUSxDQUFaO0FBQ0EsT0FBSUMsU0FBUyxDQUFiO0FBQ0EsT0FBSUMsUUFBUSxDQUFaO0FBQ0EsT0FBSUMsa0JBQWtCLENBQXRCO0FBQ0EsT0FBSXAyQixDQUFKLEVBQU9xMkIsSUFBUCxFQUFhNWdDLENBQWIsRUFBZ0Jpb0IsVUFBaEIsRUFBNEI0WSxPQUE1Qjs7QUFFQSxRQUFLN2dDLElBQUksQ0FBVCxFQUFZQSxJQUFJbWdDLElBQUlsZ0MsTUFBcEIsRUFBNEJELEdBQTVCLEVBQWlDO0FBQy9CNGdDLFlBQU9yMkIsQ0FBUDtBQUNBQSxTQUFJNDFCLElBQUkxeEIsVUFBSixDQUFlek8sQ0FBZixDQUFKO0FBQ0EsU0FBSW9nQyxRQUFKLEVBQWM7QUFDWixXQUFJNzFCLE1BQU0sSUFBTixJQUFjcTJCLFNBQVMsSUFBM0IsRUFBaUM7QUFBRVIsb0JBQVcsS0FBWDtBQUFtQjtBQUN2RCxNQUZELE1BRU8sSUFBSUMsUUFBSixFQUFjO0FBQ25CLFdBQUk5MUIsTUFBTSxJQUFOLElBQWNxMkIsU0FBUyxJQUEzQixFQUFpQztBQUFFUCxvQkFBVyxLQUFYO0FBQW1CO0FBQ3ZELE1BRk0sTUFFQSxJQUFJQyxnQkFBSixFQUFzQjtBQUMzQixXQUFJLzFCLE1BQU0sSUFBTixJQUFjcTJCLFNBQVMsSUFBM0IsRUFBaUM7QUFBRU4sNEJBQW1CLEtBQW5CO0FBQTJCO0FBQy9ELE1BRk0sTUFFQSxJQUFJQyxPQUFKLEVBQWE7QUFDbEIsV0FBSWgyQixNQUFNLElBQU4sSUFBY3EyQixTQUFTLElBQTNCLEVBQWlDO0FBQUVMLG1CQUFVLEtBQVY7QUFBa0I7QUFDdEQsTUFGTSxNQUVBLElBQ0xoMkIsTUFBTSxJQUFOLElBQWM7QUFDZDQxQixTQUFJMXhCLFVBQUosQ0FBZXpPLElBQUksQ0FBbkIsTUFBMEIsSUFEMUIsSUFFQW1nQyxJQUFJMXhCLFVBQUosQ0FBZXpPLElBQUksQ0FBbkIsTUFBMEIsSUFGMUIsSUFHQSxDQUFDd2dDLEtBSEQsSUFHVSxDQUFDQyxNQUhYLElBR3FCLENBQUNDLEtBSmpCLEVBS0w7QUFDQSxXQUFJelksZUFBZXJvQixTQUFuQixFQUE4QjtBQUM1QjtBQUNBK2dDLDJCQUFrQjNnQyxJQUFJLENBQXRCO0FBQ0Fpb0Isc0JBQWFrWSxJQUFJditCLEtBQUosQ0FBVSxDQUFWLEVBQWE1QixDQUFiLEVBQWdCOGdDLElBQWhCLEVBQWI7QUFDRCxRQUpELE1BSU87QUFDTEM7QUFDRDtBQUNGLE1BYk0sTUFhQTtBQUNMLGVBQVF4MkIsQ0FBUjtBQUNFLGNBQUssSUFBTDtBQUFXODFCLHNCQUFXLElBQVgsQ0FBaUIsTUFEOUIsQ0FDNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdELHNCQUFXLElBQVgsQ0FBaUIsTUFGOUIsQ0FFNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdFLDhCQUFtQixJQUFuQixDQUF5QixNQUh0QyxDQUc0QztBQUMxQyxjQUFLLElBQUw7QUFBV0ksbUJBQVMsTUFKdEIsQ0FJNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdBLG1CQUFTLE1BTHRCLENBSzRDO0FBQzFDLGNBQUssSUFBTDtBQUFXRCxvQkFBVSxNQU52QixDQU00QztBQUMxQyxjQUFLLElBQUw7QUFBV0Esb0JBQVUsTUFQdkIsQ0FPNEM7QUFDMUMsY0FBSyxJQUFMO0FBQVdELG1CQUFTLE1BUnRCLENBUTRDO0FBQzFDLGNBQUssSUFBTDtBQUFXQSxtQkFBUyxNQVR0QixDQVM0QztBQVQ1QztBQVdBLFdBQUlqMkIsTUFBTSxJQUFWLEVBQWdCO0FBQUU7QUFDaEIsYUFBSTZjLElBQUlwbkIsSUFBSSxDQUFaO0FBQ0EsYUFBSWtULElBQUssS0FBSyxDQUFkO0FBQ0E7QUFDQSxnQkFBT2tVLEtBQUssQ0FBWixFQUFlQSxHQUFmLEVBQW9CO0FBQ2xCbFUsZUFBSWl0QixJQUFJMTFCLE1BQUosQ0FBVzJjLENBQVgsQ0FBSjtBQUNBLGVBQUlsVSxNQUFNLEdBQVYsRUFBZTtBQUFFO0FBQU87QUFDekI7QUFDRCxhQUFJLENBQUNBLENBQUQsSUFBTSxDQUFDK3NCLG9CQUFvQi93QixJQUFwQixDQUF5QmdFLENBQXpCLENBQVgsRUFBd0M7QUFDdENxdEIscUJBQVUsSUFBVjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELE9BQUl0WSxlQUFlcm9CLFNBQW5CLEVBQThCO0FBQzVCcW9CLGtCQUFha1ksSUFBSXYrQixLQUFKLENBQVUsQ0FBVixFQUFhNUIsQ0FBYixFQUFnQjhnQyxJQUFoQixFQUFiO0FBQ0QsSUFGRCxNQUVPLElBQUlILG9CQUFvQixDQUF4QixFQUEyQjtBQUNoQ0k7QUFDRDs7QUFFRCxZQUFTQSxVQUFULEdBQXVCO0FBQ3JCLE1BQUNGLFlBQVlBLFVBQVUsRUFBdEIsQ0FBRCxFQUE0Qmp3QixJQUE1QixDQUFpQ3V2QixJQUFJditCLEtBQUosQ0FBVSsrQixlQUFWLEVBQTJCM2dDLENBQTNCLEVBQThCOGdDLElBQTlCLEVBQWpDO0FBQ0FILHVCQUFrQjNnQyxJQUFJLENBQXRCO0FBQ0Q7O0FBRUQsT0FBSTZnQyxPQUFKLEVBQWE7QUFDWCxVQUFLN2dDLElBQUksQ0FBVCxFQUFZQSxJQUFJNmdDLFFBQVE1Z0MsTUFBeEIsRUFBZ0NELEdBQWhDLEVBQXFDO0FBQ25DaW9CLG9CQUFhK1ksV0FBVy9ZLFVBQVgsRUFBdUI0WSxRQUFRN2dDLENBQVIsQ0FBdkIsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsVUFBT2lvQixVQUFQO0FBQ0Q7O0FBRUQsVUFBUytZLFVBQVQsQ0FBcUJiLEdBQXJCLEVBQTBCbjVCLE1BQTFCLEVBQWtDO0FBQ2hDLE9BQUloSCxJQUFJZ0gsT0FBT3RGLE9BQVAsQ0FBZSxHQUFmLENBQVI7QUFDQSxPQUFJMUIsSUFBSSxDQUFSLEVBQVc7QUFDVDtBQUNBLFlBQVEsVUFBVWdILE1BQVYsR0FBbUIsTUFBbkIsR0FBNEJtNUIsR0FBNUIsR0FBa0MsR0FBMUM7QUFDRCxJQUhELE1BR087QUFDTCxTQUFJNS9CLE9BQU95RyxPQUFPcEYsS0FBUCxDQUFhLENBQWIsRUFBZ0I1QixDQUFoQixDQUFYO0FBQ0EsU0FBSXlWLE9BQU96TyxPQUFPcEYsS0FBUCxDQUFhNUIsSUFBSSxDQUFqQixDQUFYO0FBQ0EsWUFBUSxVQUFVTyxJQUFWLEdBQWlCLE1BQWpCLEdBQTBCNC9CLEdBQTFCLEdBQWdDLEdBQWhDLEdBQXNDMXFCLElBQTlDO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQSxVQUFTd3JCLFFBQVQsQ0FBbUJ2eEIsR0FBbkIsRUFBd0I7QUFDdEIvUCxXQUFRbUcsS0FBUixDQUFlLHFCQUFxQjRKLEdBQXBDO0FBQ0Q7O0FBRUQsVUFBU3d4QixtQkFBVCxDQUNFcjFCLE9BREYsRUFFRWhDLEdBRkYsRUFHRTtBQUNBLFVBQU9nQyxVQUNIQSxRQUFRN0MsR0FBUixDQUFZLFVBQVUrQyxDQUFWLEVBQWE7QUFBRSxZQUFPQSxFQUFFbEMsR0FBRixDQUFQO0FBQWdCLElBQTNDLEVBQTZDN0MsTUFBN0MsQ0FBb0QsVUFBVXNELENBQVYsRUFBYTtBQUFFLFlBQU9BLENBQVA7QUFBVyxJQUE5RSxDQURHLEdBRUgsRUFGSjtBQUdEOztBQUVELFVBQVM2MkIsT0FBVCxDQUFrQnBwQixFQUFsQixFQUFzQnhYLElBQXRCLEVBQTRCb0gsS0FBNUIsRUFBbUM7QUFDakMsSUFBQ29RLEdBQUdvQixLQUFILEtBQWFwQixHQUFHb0IsS0FBSCxHQUFXLEVBQXhCLENBQUQsRUFBOEJ2SSxJQUE5QixDQUFtQyxFQUFFclEsTUFBTUEsSUFBUixFQUFjb0gsT0FBT0EsS0FBckIsRUFBbkM7QUFDRDs7QUFFRCxVQUFTeTVCLE9BQVQsQ0FBa0JycEIsRUFBbEIsRUFBc0J4WCxJQUF0QixFQUE0Qm9ILEtBQTVCLEVBQW1DO0FBQ2pDLElBQUNvUSxHQUFHc0ksS0FBSCxLQUFhdEksR0FBR3NJLEtBQUgsR0FBVyxFQUF4QixDQUFELEVBQThCelAsSUFBOUIsQ0FBbUMsRUFBRXJRLE1BQU1BLElBQVIsRUFBY29ILE9BQU9BLEtBQXJCLEVBQW5DO0FBQ0Q7O0FBRUQsVUFBUzA1QixZQUFULENBQ0V0cEIsRUFERixFQUVFeFgsSUFGRixFQUdFMitCLE9BSEYsRUFJRXYzQixLQUpGLEVBS0UyNUIsR0FMRixFQU1FdEMsU0FORixFQU9FO0FBQ0EsSUFBQ2puQixHQUFHaUMsVUFBSCxLQUFrQmpDLEdBQUdpQyxVQUFILEdBQWdCLEVBQWxDLENBQUQsRUFBd0NwSixJQUF4QyxDQUE2QyxFQUFFclEsTUFBTUEsSUFBUixFQUFjMitCLFNBQVNBLE9BQXZCLEVBQWdDdjNCLE9BQU9BLEtBQXZDLEVBQThDMjVCLEtBQUtBLEdBQW5ELEVBQXdEdEMsV0FBV0EsU0FBbkUsRUFBN0M7QUFDRDs7QUFFRCxVQUFTdUMsVUFBVCxDQUNFeHBCLEVBREYsRUFFRXhYLElBRkYsRUFHRW9ILEtBSEYsRUFJRXEzQixTQUpGLEVBS0V3QyxTQUxGLEVBTUVweUIsSUFORixFQU9FO0FBQ0E7QUFDQTtBQUNBLE9BQ0U5QixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixJQUF6QyxJQUNBNHZCLFNBREEsSUFDYUEsVUFBVXlDLE9BRHZCLElBQ2tDekMsVUFBVTlmLE9BRjlDLEVBR0U7QUFDQTlQLFVBQ0Usa0RBQ0EsK0NBRkY7QUFJRDtBQUNEO0FBQ0EsT0FBSTR2QixhQUFhQSxVQUFVNWYsT0FBM0IsRUFBb0M7QUFDbEMsWUFBTzRmLFVBQVU1ZixPQUFqQjtBQUNBN2UsWUFBTyxNQUFNQSxJQUFiLENBRmtDLENBRWY7QUFDcEI7QUFDRCxPQUFJeStCLGFBQWFBLFVBQVVueUIsSUFBM0IsRUFBaUM7QUFDL0IsWUFBT215QixVQUFVbnlCLElBQWpCO0FBQ0F0TSxZQUFPLE1BQU1BLElBQWIsQ0FGK0IsQ0FFWjtBQUNwQjtBQUNEO0FBQ0EsT0FBSXkrQixhQUFhQSxVQUFVOWYsT0FBM0IsRUFBb0M7QUFDbEMsWUFBTzhmLFVBQVU5ZixPQUFqQjtBQUNBM2UsWUFBTyxNQUFNQSxJQUFiLENBRmtDLENBRWY7QUFDcEI7QUFDRCxPQUFJbWhDLE1BQUo7QUFDQSxPQUFJMUMsYUFBYUEsVUFBVTJDLE1BQTNCLEVBQW1DO0FBQ2pDLFlBQU8zQyxVQUFVMkMsTUFBakI7QUFDQUQsY0FBUzNwQixHQUFHNnBCLFlBQUgsS0FBb0I3cEIsR0FBRzZwQixZQUFILEdBQWtCLEVBQXRDLENBQVQ7QUFDRCxJQUhELE1BR087QUFDTEYsY0FBUzNwQixHQUFHMnBCLE1BQUgsS0FBYzNwQixHQUFHMnBCLE1BQUgsR0FBWSxFQUExQixDQUFUO0FBQ0Q7QUFDRCxPQUFJRyxhQUFhLEVBQUVsNkIsT0FBT0EsS0FBVCxFQUFnQnEzQixXQUFXQSxTQUEzQixFQUFqQjtBQUNBLE9BQUkvaEIsV0FBV3lrQixPQUFPbmhDLElBQVAsQ0FBZjtBQUNBO0FBQ0EsT0FBSTZLLE1BQU1tQixPQUFOLENBQWMwUSxRQUFkLENBQUosRUFBNkI7QUFDM0J1a0IsaUJBQVl2a0IsU0FBUzBXLE9BQVQsQ0FBaUJrTyxVQUFqQixDQUFaLEdBQTJDNWtCLFNBQVNyTSxJQUFULENBQWNpeEIsVUFBZCxDQUEzQztBQUNELElBRkQsTUFFTyxJQUFJNWtCLFFBQUosRUFBYztBQUNuQnlrQixZQUFPbmhDLElBQVAsSUFBZWloQyxZQUFZLENBQUNLLFVBQUQsRUFBYTVrQixRQUFiLENBQVosR0FBcUMsQ0FBQ0EsUUFBRCxFQUFXNGtCLFVBQVgsQ0FBcEQ7QUFDRCxJQUZNLE1BRUE7QUFDTEgsWUFBT25oQyxJQUFQLElBQWVzaEMsVUFBZjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU0MsY0FBVCxDQUNFL3BCLEVBREYsRUFFRXhYLElBRkYsRUFHRXdoQyxTQUhGLEVBSUU7QUFDQSxPQUFJQyxlQUNGQyxpQkFBaUJscUIsRUFBakIsRUFBcUIsTUFBTXhYLElBQTNCLEtBQ0EwaEMsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLFlBQVl4WCxJQUFqQyxDQUZGO0FBR0EsT0FBSXloQyxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsWUFBTzlCLGFBQWE4QixZQUFiLENBQVA7QUFDRCxJQUZELE1BRU8sSUFBSUQsY0FBYyxLQUFsQixFQUF5QjtBQUM5QixTQUFJRyxjQUFjRCxpQkFBaUJscUIsRUFBakIsRUFBcUJ4WCxJQUFyQixDQUFsQjtBQUNBLFNBQUkyaEMsZUFBZSxJQUFuQixFQUF5QjtBQUN2QixjQUFPMTVCLEtBQUtDLFNBQUwsQ0FBZXk1QixXQUFmLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU0QsZ0JBQVQsQ0FBMkJscUIsRUFBM0IsRUFBK0J4WCxJQUEvQixFQUFxQztBQUNuQyxPQUFJMkgsR0FBSjtBQUNBLE9BQUksQ0FBQ0EsTUFBTTZQLEdBQUdvcUIsUUFBSCxDQUFZNWhDLElBQVosQ0FBUCxLQUE2QixJQUFqQyxFQUF1QztBQUNyQyxTQUFJMkksT0FBTzZPLEdBQUdxcUIsU0FBZDtBQUNBLFVBQUssSUFBSXBpQyxJQUFJLENBQVIsRUFBVytLLElBQUk3QixLQUFLakosTUFBekIsRUFBaUNELElBQUkrSyxDQUFyQyxFQUF3Qy9LLEdBQXhDLEVBQTZDO0FBQzNDLFdBQUlrSixLQUFLbEosQ0FBTCxFQUFRTyxJQUFSLEtBQWlCQSxJQUFyQixFQUEyQjtBQUN6QjJJLGNBQUtRLE1BQUwsQ0FBWTFKLENBQVosRUFBZSxDQUFmO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFPa0ksR0FBUDtBQUNEOztBQUVEOztBQUVBOzs7QUFHQSxVQUFTbTZCLGlCQUFULENBQ0V0cUIsRUFERixFQUVFcFEsS0FGRixFQUdFcTNCLFNBSEYsRUFJRTtBQUNBLE9BQUk1TixNQUFNNE4sYUFBYSxFQUF2QjtBQUNBLE9BQUlzRCxTQUFTbFIsSUFBSWtSLE1BQWpCO0FBQ0EsT0FBSXhCLE9BQU8xUCxJQUFJMFAsSUFBZjs7QUFFQSxPQUFJeUIsc0JBQXNCLEtBQTFCO0FBQ0EsT0FBSUMsa0JBQWtCRCxtQkFBdEI7QUFDQSxPQUFJekIsSUFBSixFQUFVO0FBQ1IwQix1QkFDRSxhQUFhRCxtQkFBYixHQUFtQyxlQUFuQyxHQUNFLElBREYsR0FDU0EsbUJBRFQsR0FDK0IsU0FEL0IsR0FFRSxJQUZGLEdBRVNBLG1CQUZULEdBRStCLEdBSGpDO0FBSUQ7QUFDRCxPQUFJRCxNQUFKLEVBQVk7QUFDVkUsdUJBQWtCLFFBQVFBLGVBQVIsR0FBMEIsR0FBNUM7QUFDRDtBQUNELE9BQUlDLGFBQWFDLGtCQUFrQi82QixLQUFsQixFQUF5QjY2QixlQUF6QixDQUFqQjs7QUFFQXpxQixNQUFHZ1csS0FBSCxHQUFXO0FBQ1RwbUIsWUFBUSxNQUFNQSxLQUFOLEdBQWMsR0FEYjtBQUVUc2dCLGlCQUFhLE9BQU90Z0IsS0FBUCxHQUFlLElBRm5CO0FBR1RrbkIsZUFBVyxlQUFlMFQsbUJBQWYsR0FBcUMsS0FBckMsR0FBNkNFLFVBQTdDLEdBQTBEO0FBSDVELElBQVg7QUFLRDs7QUFFRDs7O0FBR0EsVUFBU0MsaUJBQVQsQ0FDRS82QixLQURGLEVBRUU4NkIsVUFGRixFQUdFO0FBQ0EsT0FBSUUsVUFBVUMsV0FBV2o3QixLQUFYLENBQWQ7QUFDQSxPQUFJZzdCLFFBQVFFLEdBQVIsS0FBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsWUFBUWw3QixRQUFRLEdBQVIsR0FBYzg2QixVQUF0QjtBQUNELElBRkQsTUFFTztBQUNMLFlBQVEsVUFBV0UsUUFBUXhDLEdBQW5CLEdBQTBCLElBQTFCLEdBQWtDd0MsUUFBUUUsR0FBMUMsR0FBaUQsSUFBakQsR0FBd0RKLFVBQXhELEdBQXFFLEdBQTdFO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxLQUFJL3NCLEdBQUo7QUFDQSxLQUFJNU0sR0FBSjtBQUNBLEtBQUlnNkIsR0FBSjtBQUNBLEtBQUlDLE9BQUo7QUFDQSxLQUFJQyxhQUFKO0FBQ0EsS0FBSUMsZ0JBQUo7O0FBRUEsVUFBU0wsVUFBVCxDQUFxQjE2QixHQUFyQixFQUEwQjtBQUN4QlksU0FBTVosR0FBTjtBQUNBd04sU0FBTTVNLElBQUk3SSxNQUFWO0FBQ0E4aUMsYUFBVUMsZ0JBQWdCQyxtQkFBbUIsQ0FBN0M7O0FBRUEsT0FBSS82QixJQUFJeEcsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBbkIsSUFBd0J3RyxJQUFJZzdCLFdBQUosQ0FBZ0IsR0FBaEIsSUFBdUJ4dEIsTUFBTSxDQUF6RCxFQUE0RDtBQUMxRCxZQUFPO0FBQ0x5cUIsWUFBS2o0QixHQURBO0FBRUwyNkIsWUFBSztBQUZBLE1BQVA7QUFJRDs7QUFFRCxVQUFPLENBQUNNLEtBQVIsRUFBZTtBQUNiTCxXQUFNTSxNQUFOO0FBQ0E7QUFDQSxTQUFJQyxjQUFjUCxHQUFkLENBQUosRUFBd0I7QUFDdEJRLG1CQUFZUixHQUFaO0FBQ0QsTUFGRCxNQUVPLElBQUlBLFFBQVEsSUFBWixFQUFrQjtBQUN2QlMsb0JBQWFULEdBQWI7QUFDRDtBQUNGOztBQUVELFVBQU87QUFDTDNDLFVBQUtqNEIsSUFBSXM3QixTQUFKLENBQWMsQ0FBZCxFQUFpQlIsYUFBakIsQ0FEQTtBQUVMSCxVQUFLMzZCLElBQUlzN0IsU0FBSixDQUFjUixnQkFBZ0IsQ0FBOUIsRUFBaUNDLGdCQUFqQztBQUZBLElBQVA7QUFJRDs7QUFFRCxVQUFTRyxJQUFULEdBQWlCO0FBQ2YsVUFBT3Q2QixJQUFJMkYsVUFBSixDQUFlLEVBQUVzMEIsT0FBakIsQ0FBUDtBQUNEOztBQUVELFVBQVNJLEdBQVQsR0FBZ0I7QUFDZCxVQUFPSixXQUFXcnRCLEdBQWxCO0FBQ0Q7O0FBRUQsVUFBUzJ0QixhQUFULENBQXdCUCxHQUF4QixFQUE2QjtBQUMzQixVQUFPQSxRQUFRLElBQVIsSUFBZ0JBLFFBQVEsSUFBL0I7QUFDRDs7QUFFRCxVQUFTUyxZQUFULENBQXVCVCxHQUF2QixFQUE0QjtBQUMxQixPQUFJVyxZQUFZLENBQWhCO0FBQ0FULG1CQUFnQkQsT0FBaEI7QUFDQSxVQUFPLENBQUNJLEtBQVIsRUFBZTtBQUNiTCxXQUFNTSxNQUFOO0FBQ0EsU0FBSUMsY0FBY1AsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCUSxtQkFBWVIsR0FBWjtBQUNBO0FBQ0Q7QUFDRCxTQUFJQSxRQUFRLElBQVosRUFBa0I7QUFBRVc7QUFBYztBQUNsQyxTQUFJWCxRQUFRLElBQVosRUFBa0I7QUFBRVc7QUFBYztBQUNsQyxTQUFJQSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CUiwwQkFBbUJGLE9BQW5CO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU08sV0FBVCxDQUFzQlIsR0FBdEIsRUFBMkI7QUFDekIsT0FBSVksY0FBY1osR0FBbEI7QUFDQSxVQUFPLENBQUNLLEtBQVIsRUFBZTtBQUNiTCxXQUFNTSxNQUFOO0FBQ0EsU0FBSU4sUUFBUVksV0FBWixFQUF5QjtBQUN2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxLQUFJQyxNQUFKOztBQUVBO0FBQ0E7QUFDQSxLQUFJQyxjQUFjLEtBQWxCO0FBQ0EsS0FBSUMsdUJBQXVCLEtBQTNCOztBQUVBLFVBQVM5VixLQUFULENBQ0VoVyxFQURGLEVBRUU0bUIsR0FGRixFQUdFbUYsS0FIRixFQUlFO0FBQ0FILFlBQVNHLEtBQVQ7QUFDQSxPQUFJbjhCLFFBQVFnM0IsSUFBSWgzQixLQUFoQjtBQUNBLE9BQUlxM0IsWUFBWUwsSUFBSUssU0FBcEI7QUFDQSxPQUFJM2lCLE1BQU10RSxHQUFHc0UsR0FBYjtBQUNBLE9BQUluRCxPQUFPbkIsR0FBR29xQixRQUFILENBQVlqcEIsSUFBdkI7O0FBRUEsT0FBSTVMLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxTQUFJdTJCLGNBQWNoc0IsR0FBR29xQixRQUFILENBQVksYUFBWixLQUE4QnBxQixHQUFHb3FCLFFBQUgsQ0FBWSxPQUFaLENBQWhEO0FBQ0EsU0FBSTlsQixRQUFRLE9BQVIsSUFBbUIwbkIsV0FBdkIsRUFBb0M7QUFDbENKLGNBQ0Usb0JBQW9CSSxXQUFwQixHQUFrQyxlQUFsQyxHQUFvRHA4QixLQUFwRCxHQUE0RCxRQUE1RCxHQUNBLDBFQUZGO0FBSUQ7QUFDRDtBQUNBO0FBQ0EsU0FBSTBVLFFBQVEsT0FBUixJQUFtQm5ELFNBQVMsTUFBaEMsRUFBd0M7QUFDdEN5cUIsY0FDRSxNQUFPNXJCLEdBQUdzRSxHQUFWLEdBQWlCLGFBQWpCLEdBQWlDMVUsS0FBakMsR0FBeUMsc0JBQXpDLEdBQ0EsZ0VBRkY7QUFJRDtBQUNGOztBQUVELE9BQUlvUSxHQUFHa0ssU0FBUCxFQUFrQjtBQUNoQm9nQix1QkFBa0J0cUIsRUFBbEIsRUFBc0JwUSxLQUF0QixFQUE2QnEzQixTQUE3QjtBQUNBO0FBQ0EsWUFBTyxLQUFQO0FBQ0QsSUFKRCxNQUlPLElBQUkzaUIsUUFBUSxRQUFaLEVBQXNCO0FBQzNCMm5CLGVBQVVqc0IsRUFBVixFQUFjcFEsS0FBZCxFQUFxQnEzQixTQUFyQjtBQUNELElBRk0sTUFFQSxJQUFJM2lCLFFBQVEsT0FBUixJQUFtQm5ELFNBQVMsVUFBaEMsRUFBNEM7QUFDakQrcUIsc0JBQWlCbHNCLEVBQWpCLEVBQXFCcFEsS0FBckIsRUFBNEJxM0IsU0FBNUI7QUFDRCxJQUZNLE1BRUEsSUFBSTNpQixRQUFRLE9BQVIsSUFBbUJuRCxTQUFTLE9BQWhDLEVBQXlDO0FBQzlDZ3JCLG1CQUFjbnNCLEVBQWQsRUFBa0JwUSxLQUFsQixFQUF5QnEzQixTQUF6QjtBQUNELElBRk0sTUFFQSxJQUFJM2lCLFFBQVEsT0FBUixJQUFtQkEsUUFBUSxVQUEvQixFQUEyQztBQUNoRDhuQixxQkFBZ0Jwc0IsRUFBaEIsRUFBb0JwUSxLQUFwQixFQUEyQnEzQixTQUEzQjtBQUNELElBRk0sTUFFQSxJQUFJLENBQUM5eEIsT0FBT2EsYUFBUCxDQUFxQnNPLEdBQXJCLENBQUwsRUFBZ0M7QUFDckNnbUIsdUJBQWtCdHFCLEVBQWxCLEVBQXNCcFEsS0FBdEIsRUFBNkJxM0IsU0FBN0I7QUFDQTtBQUNBLFlBQU8sS0FBUDtBQUNELElBSk0sTUFJQSxJQUFJMXhCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRG0yQixZQUNFLE1BQU81ckIsR0FBR3NFLEdBQVYsR0FBaUIsYUFBakIsR0FBaUMxVSxLQUFqQyxHQUF5QyxPQUF6QyxHQUNBLGlEQURBLEdBRUEsZ0VBRkEsR0FHQSxzRUFKRjtBQU1EOztBQUVEO0FBQ0EsVUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBU3M4QixnQkFBVCxDQUNFbHNCLEVBREYsRUFFRXBRLEtBRkYsRUFHRXEzQixTQUhGLEVBSUU7QUFDQSxPQUFJc0QsU0FBU3RELGFBQWFBLFVBQVVzRCxNQUFwQztBQUNBLE9BQUk4QixlQUFldEMsZUFBZS9wQixFQUFmLEVBQW1CLE9BQW5CLEtBQStCLE1BQWxEO0FBQ0EsT0FBSXNzQixtQkFBbUJ2QyxlQUFlL3BCLEVBQWYsRUFBbUIsWUFBbkIsS0FBb0MsTUFBM0Q7QUFDQSxPQUFJdXNCLG9CQUFvQnhDLGVBQWUvcEIsRUFBZixFQUFtQixhQUFuQixLQUFxQyxPQUE3RDtBQUNBb3BCLFdBQVFwcEIsRUFBUixFQUFZLFNBQVosRUFDRSxtQkFBbUJwUSxLQUFuQixHQUEyQixHQUEzQixHQUNFLE1BREYsR0FDV0EsS0FEWCxHQUNtQixHQURuQixHQUN5Qnk4QixZQUR6QixHQUN3QyxNQUR4QyxJQUVJQyxxQkFBcUIsTUFBckIsR0FDSyxPQUFPMThCLEtBQVAsR0FBZSxHQURwQixHQUVLLFNBQVNBLEtBQVQsR0FBaUIsR0FBakIsR0FBdUIwOEIsZ0JBQXZCLEdBQTBDLEdBSm5ELENBREY7QUFRQTlDLGNBQVd4cEIsRUFBWCxFQUFlOHJCLG9CQUFmLEVBQ0UsYUFBYWw4QixLQUFiLEdBQXFCLEdBQXJCLEdBQ0kscUJBREosR0FFSSxvQkFGSixHQUUyQjA4QixnQkFGM0IsR0FFOEMsS0FGOUMsR0FFc0RDLGlCQUZ0RCxHQUUwRSxJQUYxRSxHQUdBLHlCQUhBLEdBSUUsVUFKRixJQUlnQmhDLFNBQVMsUUFBUThCLFlBQVIsR0FBdUIsR0FBaEMsR0FBc0NBLFlBSnRELElBSXNFLEdBSnRFLEdBS00sa0JBTE4sR0FNRSwyQkFORixHQU1nQ3o4QixLQU5oQyxHQU13QyxvQkFOeEMsR0FPRSxnQkFQRixHQU9xQkEsS0FQckIsR0FPNkIsOENBUDdCLEdBUUEsUUFSQSxHQVFZKzZCLGtCQUFrQi82QixLQUFsQixFQUF5QixLQUF6QixDQVJaLEdBUStDLEdBVGpELEVBVUUsSUFWRixFQVVRLElBVlI7QUFZRDs7QUFFRCxVQUFTdThCLGFBQVQsQ0FDSW5zQixFQURKLEVBRUlwUSxLQUZKLEVBR0lxM0IsU0FISixFQUlFO0FBQ0EsT0FBSXNELFNBQVN0RCxhQUFhQSxVQUFVc0QsTUFBcEM7QUFDQSxPQUFJOEIsZUFBZXRDLGVBQWUvcEIsRUFBZixFQUFtQixPQUFuQixLQUErQixNQUFsRDtBQUNBcXNCLGtCQUFlOUIsU0FBVSxRQUFROEIsWUFBUixHQUF1QixHQUFqQyxHQUF3Q0EsWUFBdkQ7QUFDQWpELFdBQVFwcEIsRUFBUixFQUFZLFNBQVosRUFBd0IsUUFBUXBRLEtBQVIsR0FBZ0IsR0FBaEIsR0FBc0J5OEIsWUFBdEIsR0FBcUMsR0FBN0Q7QUFDQTdDLGNBQVd4cEIsRUFBWCxFQUFlOHJCLG9CQUFmLEVBQXFDbkIsa0JBQWtCLzZCLEtBQWxCLEVBQXlCeThCLFlBQXpCLENBQXJDLEVBQTZFLElBQTdFLEVBQW1GLElBQW5GO0FBQ0Q7O0FBRUQsVUFBU0osU0FBVCxDQUNJanNCLEVBREosRUFFSXBRLEtBRkosRUFHSXEzQixTQUhKLEVBSUU7QUFDQSxPQUFJc0QsU0FBU3RELGFBQWFBLFVBQVVzRCxNQUFwQztBQUNBLE9BQUlpQyxjQUFjLDJCQUNoQiw2REFEZ0IsR0FFaEIsa0VBRmdCLEdBR2hCLFNBSGdCLElBR0hqQyxTQUFTLFNBQVQsR0FBcUIsS0FIbEIsSUFHMkIsSUFIN0M7O0FBS0EsT0FBSUcsYUFBYSwyREFBakI7QUFDQSxPQUFJK0IsT0FBTyx5QkFBeUJELFdBQXpCLEdBQXVDLEdBQWxEO0FBQ0FDLFVBQU9BLE9BQU8sR0FBUCxHQUFjOUIsa0JBQWtCLzZCLEtBQWxCLEVBQXlCODZCLFVBQXpCLENBQXJCO0FBQ0FsQixjQUFXeHBCLEVBQVgsRUFBZSxRQUFmLEVBQXlCeXNCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLElBQXJDO0FBQ0Q7O0FBRUQsVUFBU0wsZUFBVCxDQUNFcHNCLEVBREYsRUFFRXBRLEtBRkYsRUFHRXEzQixTQUhGLEVBSUU7QUFDQSxPQUFJOWxCLE9BQU9uQixHQUFHb3FCLFFBQUgsQ0FBWWpwQixJQUF2QjtBQUNBLE9BQUlrWSxNQUFNNE4sYUFBYSxFQUF2QjtBQUNBLE9BQUlwVyxPQUFPd0ksSUFBSXhJLElBQWY7QUFDQSxPQUFJMFosU0FBU2xSLElBQUlrUixNQUFqQjtBQUNBLE9BQUl4QixPQUFPMVAsSUFBSTBQLElBQWY7QUFDQSxPQUFJMkQsdUJBQXVCLENBQUM3YixJQUFELElBQVMxUCxTQUFTLE9BQTdDO0FBQ0EsT0FBSWxULFFBQVE0aUIsT0FDUixRQURRLEdBRVIxUCxTQUFTLE9BQVQsR0FDRTBxQixXQURGLEdBRUUsT0FKTjs7QUFNQSxPQUFJcEIsa0JBQWtCLHFCQUF0QjtBQUNBLE9BQUkxQixJQUFKLEVBQVU7QUFDUjBCLHVCQUFrQiw0QkFBbEI7QUFDRDtBQUNELE9BQUlGLE1BQUosRUFBWTtBQUNWRSx1QkFBa0IsUUFBUUEsZUFBUixHQUEwQixHQUE1QztBQUNEOztBQUVELE9BQUlnQyxPQUFPOUIsa0JBQWtCLzZCLEtBQWxCLEVBQXlCNjZCLGVBQXpCLENBQVg7QUFDQSxPQUFJaUMsb0JBQUosRUFBMEI7QUFDeEJELFlBQU8sdUNBQXVDQSxJQUE5QztBQUNEOztBQUVEckQsV0FBUXBwQixFQUFSLEVBQVksT0FBWixFQUFzQixNQUFNcFEsS0FBTixHQUFjLEdBQXBDO0FBQ0E0NUIsY0FBV3hwQixFQUFYLEVBQWUvUixLQUFmLEVBQXNCdytCLElBQXRCLEVBQTRCLElBQTVCLEVBQWtDLElBQWxDO0FBQ0EsT0FBSTFELFFBQVF3QixNQUFaLEVBQW9CO0FBQ2xCZixnQkFBV3hwQixFQUFYLEVBQWUsTUFBZixFQUF1QixnQkFBdkI7QUFDRDtBQUNGOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzJzQixlQUFULENBQTBCaGxCLEVBQTFCLEVBQThCO0FBQzVCLE9BQUkxWixLQUFKO0FBQ0E7QUFDQSxPQUFJdUIsTUFBTW1ZLEdBQUdra0IsV0FBSCxDQUFOLENBQUosRUFBNEI7QUFDMUI7QUFDQTU5QixhQUFRb0wsT0FBTyxRQUFQLEdBQWtCLE9BQTFCO0FBQ0FzTyxRQUFHMVosS0FBSCxJQUFZLEdBQUdnRyxNQUFILENBQVUwVCxHQUFHa2tCLFdBQUgsQ0FBVixFQUEyQmxrQixHQUFHMVosS0FBSCxLQUFhLEVBQXhDLENBQVo7QUFDQSxZQUFPMFosR0FBR2trQixXQUFILENBQVA7QUFDRDtBQUNELE9BQUlyOEIsTUFBTW1ZLEdBQUdta0Isb0JBQUgsQ0FBTixDQUFKLEVBQXFDO0FBQ25DO0FBQ0E3OUIsYUFBUXlMLFdBQVcsT0FBWCxHQUFxQixRQUE3QjtBQUNBaU8sUUFBRzFaLEtBQUgsSUFBWSxHQUFHZ0csTUFBSCxDQUFVMFQsR0FBR21rQixvQkFBSCxDQUFWLEVBQW9DbmtCLEdBQUcxWixLQUFILEtBQWEsRUFBakQsQ0FBWjtBQUNBLFlBQU8wWixHQUFHbWtCLG9CQUFILENBQVA7QUFDRDtBQUNGOztBQUVELEtBQUljLFFBQUo7O0FBRUEsVUFBU0MsS0FBVCxDQUNFNStCLEtBREYsRUFFRXFsQixRQUZGLEVBR0VsTSxPQUhGLEVBSUVDLE9BSkYsRUFLRUYsT0FMRixFQU1FO0FBQ0EsT0FBSUMsT0FBSixFQUFhO0FBQ1gsU0FBSTBsQixhQUFheFosUUFBakI7QUFDQSxTQUFJblcsVUFBVXl2QixRQUFkLENBRlcsQ0FFYTtBQUN4QnRaLGdCQUFVLGlCQUFVeVosRUFBVixFQUFjO0FBQ3RCLFdBQUloZ0MsTUFBTXJGLFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsR0FDTjRrQyxXQUFXQyxFQUFYLENBRE0sR0FFTkQsV0FBV3JsQyxLQUFYLENBQWlCLElBQWpCLEVBQXVCQyxTQUF2QixDQUZKO0FBR0EsV0FBSXFGLFFBQVEsSUFBWixFQUFrQjtBQUNoQmlnQyxrQkFBUy8rQixLQUFULEVBQWdCcWxCLFFBQWhCLEVBQXlCak0sT0FBekIsRUFBa0NsSyxPQUFsQztBQUNEO0FBQ0YsTUFQRDtBQVFEO0FBQ0R5dkIsWUFBUzV5QixnQkFBVCxDQUNFL0wsS0FERixFQUVFcWxCLFFBRkYsRUFHRXpaLGtCQUNJLEVBQUV3TixTQUFTQSxPQUFYLEVBQW9CRixTQUFTQSxPQUE3QixFQURKLEdBRUlFLE9BTE47QUFPRDs7QUFFRCxVQUFTMmxCLFFBQVQsQ0FDRS8rQixLQURGLEVBRUVxbEIsT0FGRixFQUdFak0sT0FIRixFQUlFbEssT0FKRixFQUtFO0FBQ0EsSUFBQ0EsV0FBV3l2QixRQUFaLEVBQXNCSyxtQkFBdEIsQ0FBMENoL0IsS0FBMUMsRUFBaURxbEIsT0FBakQsRUFBMERqTSxPQUExRDtBQUNEOztBQUVELFVBQVM2bEIsa0JBQVQsQ0FBNkIxWCxRQUE3QixFQUF1QzFPLEtBQXZDLEVBQThDO0FBQzVDLE9BQUl4WCxRQUFRa21CLFNBQVNob0IsSUFBVCxDQUFjbWEsRUFBdEIsS0FBNkJyWSxRQUFRd1gsTUFBTXRaLElBQU4sQ0FBV21hLEVBQW5CLENBQWpDLEVBQXlEO0FBQ3ZEO0FBQ0Q7QUFDRCxPQUFJQSxLQUFLYixNQUFNdFosSUFBTixDQUFXbWEsRUFBWCxJQUFpQixFQUExQjtBQUNBLE9BQUlDLFFBQVE0TixTQUFTaG9CLElBQVQsQ0FBY21hLEVBQWQsSUFBb0IsRUFBaEM7QUFDQWlsQixjQUFXOWxCLE1BQU1yQixHQUFqQjtBQUNBa25CLG1CQUFnQmhsQixFQUFoQjtBQUNBRCxtQkFBZ0JDLEVBQWhCLEVBQW9CQyxLQUFwQixFQUEyQmlsQixLQUEzQixFQUFrQ0csUUFBbEMsRUFBNENsbUIsTUFBTXBCLE9BQWxEO0FBQ0Q7O0FBRUQsS0FBSWlrQixTQUFTO0FBQ1h6NEIsV0FBUWc4QixrQkFERztBQUVYbHdCLFdBQVFrd0I7QUFGRyxFQUFiOztBQUtBOztBQUVBLFVBQVNDLGNBQVQsQ0FBeUIzWCxRQUF6QixFQUFtQzFPLEtBQW5DLEVBQTBDO0FBQ3hDLE9BQUl4WCxRQUFRa21CLFNBQVNob0IsSUFBVCxDQUFjNHFCLFFBQXRCLEtBQW1DOW9CLFFBQVF3WCxNQUFNdFosSUFBTixDQUFXNHFCLFFBQW5CLENBQXZDLEVBQXFFO0FBQ25FO0FBQ0Q7QUFDRCxPQUFJdG1CLEdBQUosRUFBU2dXLEdBQVQ7QUFDQSxPQUFJckMsTUFBTXFCLE1BQU1yQixHQUFoQjtBQUNBLE9BQUkybkIsV0FBVzVYLFNBQVNob0IsSUFBVCxDQUFjNHFCLFFBQWQsSUFBMEIsRUFBekM7QUFDQSxPQUFJaFgsUUFBUTBGLE1BQU10WixJQUFOLENBQVc0cUIsUUFBWCxJQUF1QixFQUFuQztBQUNBO0FBQ0EsT0FBSTVvQixNQUFNNFIsTUFBTXRELE1BQVosQ0FBSixFQUF5QjtBQUN2QnNELGFBQVEwRixNQUFNdFosSUFBTixDQUFXNHFCLFFBQVgsR0FBc0I5a0IsT0FBTyxFQUFQLEVBQVc4TixLQUFYLENBQTlCO0FBQ0Q7O0FBRUQsUUFBS3RQLEdBQUwsSUFBWXM3QixRQUFaLEVBQXNCO0FBQ3BCLFNBQUk5OUIsUUFBUThSLE1BQU10UCxHQUFOLENBQVIsQ0FBSixFQUF5QjtBQUN2QjJULFdBQUkzVCxHQUFKLElBQVcsRUFBWDtBQUNEO0FBQ0Y7QUFDRCxRQUFLQSxHQUFMLElBQVlzUCxLQUFaLEVBQW1CO0FBQ2pCMEcsV0FBTTFHLE1BQU10UCxHQUFOLENBQU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFJQSxRQUFRLGFBQVIsSUFBeUJBLFFBQVEsV0FBckMsRUFBa0Q7QUFDaEQsV0FBSWdWLE1BQU12QixRQUFWLEVBQW9CO0FBQUV1QixlQUFNdkIsUUFBTixDQUFlcmQsTUFBZixHQUF3QixDQUF4QjtBQUE0QjtBQUNsRCxXQUFJNGYsUUFBUXNsQixTQUFTdDdCLEdBQVQsQ0FBWixFQUEyQjtBQUFFO0FBQVU7QUFDeEM7O0FBRUQsU0FBSUEsUUFBUSxPQUFaLEVBQXFCO0FBQ25CO0FBQ0E7QUFDQTJULFdBQUk0bkIsTUFBSixHQUFhdmxCLEdBQWI7QUFDQTtBQUNBLFdBQUl3bEIsU0FBU2grQixRQUFRd1ksR0FBUixJQUFlLEVBQWYsR0FBb0JuWCxPQUFPbVgsR0FBUCxDQUFqQztBQUNBLFdBQUl5bEIsa0JBQWtCOW5CLEdBQWxCLEVBQXVCcUIsS0FBdkIsRUFBOEJ3bUIsTUFBOUIsQ0FBSixFQUEyQztBQUN6QzduQixhQUFJN1YsS0FBSixHQUFZMDlCLE1BQVo7QUFDRDtBQUNGLE1BVEQsTUFTTztBQUNMN25CLFdBQUkzVCxHQUFKLElBQVdnVyxHQUFYO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7QUFHQSxVQUFTeWxCLGlCQUFULENBQ0U5bkIsR0FERixFQUVFcUIsS0FGRixFQUdFMG1CLFFBSEYsRUFJRTtBQUNBLFVBQVEsQ0FBQy9uQixJQUFJZ29CLFNBQUwsS0FDTjNtQixNQUFNeEMsR0FBTixLQUFjLFFBQWQsSUFDQW9wQixRQUFRam9CLEdBQVIsRUFBYStuQixRQUFiLENBREEsSUFFQUcsZUFBZWxvQixHQUFmLEVBQW9CK25CLFFBQXBCLENBSE0sQ0FBUjtBQUtEOztBQUVELFVBQVNFLE9BQVQsQ0FBa0Jqb0IsR0FBbEIsRUFBdUIrbkIsUUFBdkIsRUFBaUM7QUFDL0I7QUFDQTtBQUNBLE9BQUlJLGFBQWEsSUFBakI7QUFDQTtBQUNBO0FBQ0EsT0FBSTtBQUFFQSxrQkFBYXZrQyxTQUFTd2tDLGFBQVQsS0FBMkJwb0IsR0FBeEM7QUFBOEMsSUFBcEQsQ0FBcUQsT0FBT2plLENBQVAsRUFBVSxDQUFFO0FBQ2pFLFVBQU9vbUMsY0FBY25vQixJQUFJN1YsS0FBSixLQUFjNDlCLFFBQW5DO0FBQ0Q7O0FBRUQsVUFBU0csY0FBVCxDQUF5QmxvQixHQUF6QixFQUE4QjdGLE1BQTlCLEVBQXNDO0FBQ3BDLE9BQUloUSxRQUFRNlYsSUFBSTdWLEtBQWhCO0FBQ0EsT0FBSXEzQixZQUFZeGhCLElBQUlxb0IsV0FBcEIsQ0FGb0MsQ0FFSDtBQUNqQyxPQUFJdCtCLE1BQU15M0IsU0FBTixLQUFvQkEsVUFBVXNELE1BQWxDLEVBQTBDO0FBQ3hDLFlBQU8zNUIsU0FBU2hCLEtBQVQsTUFBb0JnQixTQUFTZ1AsTUFBVCxDQUEzQjtBQUNEO0FBQ0QsT0FBSXBRLE1BQU15M0IsU0FBTixLQUFvQkEsVUFBVThCLElBQWxDLEVBQXdDO0FBQ3RDLFlBQU9uNUIsTUFBTW01QixJQUFOLE9BQWlCbnBCLE9BQU9tcEIsSUFBUCxFQUF4QjtBQUNEO0FBQ0QsVUFBT241QixVQUFVZ1EsTUFBakI7QUFDRDs7QUFFRCxLQUFJd1ksV0FBVztBQUNibG5CLFdBQVFpOEIsY0FESztBQUVibndCLFdBQVFtd0I7QUFGSyxFQUFmOztBQUtBOztBQUVBLEtBQUlZLGlCQUFpQmg4QixPQUFPLFVBQVVpOEIsT0FBVixFQUFtQjtBQUM3QyxPQUFJamhDLE1BQU0sRUFBVjtBQUNBLE9BQUlraEMsZ0JBQWdCLGVBQXBCO0FBQ0EsT0FBSUMsb0JBQW9CLE9BQXhCO0FBQ0FGLFdBQVE1OEIsS0FBUixDQUFjNjhCLGFBQWQsRUFBNkJsL0IsT0FBN0IsQ0FBcUMsVUFBVTJDLElBQVYsRUFBZ0I7QUFDbkQsU0FBSUEsSUFBSixFQUFVO0FBQ1IsV0FBSTJmLE1BQU0zZixLQUFLTixLQUFMLENBQVc4OEIsaUJBQVgsQ0FBVjtBQUNBN2MsV0FBSW5wQixNQUFKLEdBQWEsQ0FBYixLQUFtQjZFLElBQUlza0IsSUFBSSxDQUFKLEVBQU8wWCxJQUFQLEVBQUosSUFBcUIxWCxJQUFJLENBQUosRUFBTzBYLElBQVAsRUFBeEM7QUFDRDtBQUNGLElBTEQ7QUFNQSxVQUFPaDhCLEdBQVA7QUFDRCxFQVhvQixDQUFyQjs7QUFhQTtBQUNBLFVBQVNvaEMsa0JBQVQsQ0FBNkIzZ0MsSUFBN0IsRUFBbUM7QUFDakMsT0FBSTRnQyxRQUFRQyxzQkFBc0I3Z0MsS0FBSzRnQyxLQUEzQixDQUFaO0FBQ0E7QUFDQTtBQUNBLFVBQU81Z0MsS0FBSzhnQyxXQUFMLEdBQ0hoN0IsT0FBTzlGLEtBQUs4Z0MsV0FBWixFQUF5QkYsS0FBekIsQ0FERyxHQUVIQSxLQUZKO0FBR0Q7O0FBRUQ7QUFDQSxVQUFTQyxxQkFBVCxDQUFnQ0UsWUFBaEMsRUFBOEM7QUFDNUMsT0FBSWw3QixNQUFNbUIsT0FBTixDQUFjKzVCLFlBQWQsQ0FBSixFQUFpQztBQUMvQixZQUFPOTZCLFNBQVM4NkIsWUFBVCxDQUFQO0FBQ0Q7QUFDRCxPQUFJLE9BQU9BLFlBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDcEMsWUFBT1IsZUFBZVEsWUFBZixDQUFQO0FBQ0Q7QUFDRCxVQUFPQSxZQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTQyxRQUFULENBQW1CMW5CLEtBQW5CLEVBQTBCMm5CLFVBQTFCLEVBQXNDO0FBQ3BDLE9BQUkxaEMsTUFBTSxFQUFWO0FBQ0EsT0FBSTJoQyxTQUFKOztBQUVBLE9BQUlELFVBQUosRUFBZ0I7QUFDZCxTQUFJOVAsWUFBWTdYLEtBQWhCO0FBQ0EsWUFBTzZYLFVBQVU1WSxpQkFBakIsRUFBb0M7QUFDbEM0WSxtQkFBWUEsVUFBVTVZLGlCQUFWLENBQTRCbUgsTUFBeEM7QUFDQSxXQUFJeVIsVUFBVW54QixJQUFWLEtBQW1Ca2hDLFlBQVlQLG1CQUFtQnhQLFVBQVVueEIsSUFBN0IsQ0FBL0IsQ0FBSixFQUF3RTtBQUN0RThGLGdCQUFPdkcsR0FBUCxFQUFZMmhDLFNBQVo7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsT0FBS0EsWUFBWVAsbUJBQW1Ccm5CLE1BQU10WixJQUF6QixDQUFqQixFQUFrRDtBQUNoRDhGLFlBQU92RyxHQUFQLEVBQVkyaEMsU0FBWjtBQUNEOztBQUVELE9BQUloUSxhQUFhNVgsS0FBakI7QUFDQSxVQUFRNFgsYUFBYUEsV0FBV3hlLE1BQWhDLEVBQXlDO0FBQ3ZDLFNBQUl3ZSxXQUFXbHhCLElBQVgsS0FBb0JraEMsWUFBWVAsbUJBQW1CelAsV0FBV2x4QixJQUE5QixDQUFoQyxDQUFKLEVBQTBFO0FBQ3hFOEYsY0FBT3ZHLEdBQVAsRUFBWTJoQyxTQUFaO0FBQ0Q7QUFDRjtBQUNELFVBQU8zaEMsR0FBUDtBQUNEOztBQUVEOztBQUVBLEtBQUk0aEMsV0FBVyxLQUFmO0FBQ0EsS0FBSUMsY0FBYyxnQkFBbEI7QUFDQSxLQUFJQyxVQUFVLFNBQVZBLE9BQVUsQ0FBVTd1QixFQUFWLEVBQWN4WCxJQUFkLEVBQW9CMkgsR0FBcEIsRUFBeUI7QUFDckM7QUFDQSxPQUFJdytCLFNBQVN4M0IsSUFBVCxDQUFjM08sSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCd1gsUUFBR291QixLQUFILENBQVNVLFdBQVQsQ0FBcUJ0bUMsSUFBckIsRUFBMkIySCxHQUEzQjtBQUNELElBRkQsTUFFTyxJQUFJeStCLFlBQVl6M0IsSUFBWixDQUFpQmhILEdBQWpCLENBQUosRUFBMkI7QUFDaEM2UCxRQUFHb3VCLEtBQUgsQ0FBU1UsV0FBVCxDQUFxQnRtQyxJQUFyQixFQUEyQjJILElBQUltQyxPQUFKLENBQVlzOEIsV0FBWixFQUF5QixFQUF6QixDQUEzQixFQUF5RCxXQUF6RDtBQUNELElBRk0sTUFFQTtBQUNMLFNBQUlHLGlCQUFpQkMsVUFBVXhtQyxJQUFWLENBQXJCO0FBQ0EsU0FBSTZLLE1BQU1tQixPQUFOLENBQWNyRSxHQUFkLENBQUosRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBSyxJQUFJbEksSUFBSSxDQUFSLEVBQVcwVixNQUFNeE4sSUFBSWpJLE1BQTFCLEVBQWtDRCxJQUFJMFYsR0FBdEMsRUFBMkMxVixHQUEzQyxFQUFnRDtBQUM5QytYLFlBQUdvdUIsS0FBSCxDQUFTVyxjQUFULElBQTJCNStCLElBQUlsSSxDQUFKLENBQTNCO0FBQ0Q7QUFDRixNQVBELE1BT087QUFDTCtYLFVBQUdvdUIsS0FBSCxDQUFTVyxjQUFULElBQTJCNStCLEdBQTNCO0FBQ0Q7QUFDRjtBQUNGLEVBbkJEOztBQXFCQSxLQUFJOCtCLGNBQWMsQ0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixJQUFsQixDQUFsQjs7QUFFQSxLQUFJQyxVQUFKO0FBQ0EsS0FBSUYsWUFBWWo5QixPQUFPLFVBQVVnUixJQUFWLEVBQWdCO0FBQ3JDbXNCLGdCQUFhQSxjQUFjN2xDLFNBQVN1ckIsYUFBVCxDQUF1QixLQUF2QixFQUE4QndaLEtBQXpEO0FBQ0FyckIsVUFBTzFRLFNBQVMwUSxJQUFULENBQVA7QUFDQSxPQUFJQSxTQUFTLFFBQVQsSUFBc0JBLFFBQVFtc0IsVUFBbEMsRUFBK0M7QUFDN0MsWUFBT25zQixJQUFQO0FBQ0Q7QUFDRCxPQUFJb3NCLFVBQVVwc0IsS0FBS3JRLE1BQUwsQ0FBWSxDQUFaLEVBQWV6SixXQUFmLEtBQStCOFosS0FBS2xaLEtBQUwsQ0FBVyxDQUFYLENBQTdDO0FBQ0EsUUFBSyxJQUFJNUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZ25DLFlBQVkvbUMsTUFBaEMsRUFBd0NELEdBQXhDLEVBQTZDO0FBQzNDLFNBQUlPLE9BQU95bUMsWUFBWWhuQyxDQUFaLElBQWlCa25DLE9BQTVCO0FBQ0EsU0FBSTNtQyxRQUFRMG1DLFVBQVosRUFBd0I7QUFDdEIsY0FBTzFtQyxJQUFQO0FBQ0Q7QUFDRjtBQUNGLEVBYmUsQ0FBaEI7O0FBZUEsVUFBUzRtQyxXQUFULENBQXNCNVosUUFBdEIsRUFBZ0MxTyxLQUFoQyxFQUF1QztBQUNyQyxPQUFJdFosT0FBT3NaLE1BQU10WixJQUFqQjtBQUNBLE9BQUlvNkIsVUFBVXBTLFNBQVNob0IsSUFBdkI7O0FBRUEsT0FBSThCLFFBQVE5QixLQUFLOGdDLFdBQWIsS0FBNkJoL0IsUUFBUTlCLEtBQUs0Z0MsS0FBYixDQUE3QixJQUNGOStCLFFBQVFzNEIsUUFBUTBHLFdBQWhCLENBREUsSUFDOEJoL0IsUUFBUXM0QixRQUFRd0csS0FBaEIsQ0FEbEMsRUFFRTtBQUNBO0FBQ0Q7O0FBRUQsT0FBSXRtQixHQUFKLEVBQVN0ZixJQUFUO0FBQ0EsT0FBSXdYLEtBQUs4RyxNQUFNckIsR0FBZjtBQUNBLE9BQUk0cEIsaUJBQWlCekgsUUFBUTBHLFdBQTdCO0FBQ0EsT0FBSWdCLGtCQUFrQjFILFFBQVEySCxlQUFSLElBQTJCM0gsUUFBUXdHLEtBQW5DLElBQTRDLEVBQWxFOztBQUVBO0FBQ0EsT0FBSW9CLFdBQVdILGtCQUFrQkMsZUFBakM7O0FBRUEsT0FBSWxCLFFBQVFDLHNCQUFzQnZuQixNQUFNdFosSUFBTixDQUFXNGdDLEtBQWpDLEtBQTJDLEVBQXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBdG5CLFNBQU10WixJQUFOLENBQVcraEMsZUFBWCxHQUE2Qi8vQixNQUFNNCtCLE1BQU10d0IsTUFBWixJQUN6QnhLLE9BQU8sRUFBUCxFQUFXODZCLEtBQVgsQ0FEeUIsR0FFekJBLEtBRko7O0FBSUEsT0FBSXFCLFdBQVdqQixTQUFTMW5CLEtBQVQsRUFBZ0IsSUFBaEIsQ0FBZjs7QUFFQSxRQUFLdGUsSUFBTCxJQUFhZ25DLFFBQWIsRUFBdUI7QUFDckIsU0FBSWxnQyxRQUFRbWdDLFNBQVNqbkMsSUFBVCxDQUFSLENBQUosRUFBNkI7QUFDM0JxbUMsZUFBUTd1QixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCLEVBQWxCO0FBQ0Q7QUFDRjtBQUNELFFBQUtBLElBQUwsSUFBYWluQyxRQUFiLEVBQXVCO0FBQ3JCM25CLFdBQU0ybkIsU0FBU2puQyxJQUFULENBQU47QUFDQSxTQUFJc2YsUUFBUTBuQixTQUFTaG5DLElBQVQsQ0FBWixFQUE0QjtBQUMxQjtBQUNBcW1DLGVBQVE3dUIsRUFBUixFQUFZeFgsSUFBWixFQUFrQnNmLE9BQU8sSUFBUCxHQUFjLEVBQWQsR0FBbUJBLEdBQXJDO0FBQ0Q7QUFDRjtBQUNGOztBQUVELEtBQUlzbUIsUUFBUTtBQUNWbDlCLFdBQVFrK0IsV0FERTtBQUVWcHlCLFdBQVFveUI7QUFGRSxFQUFaOztBQUtBOztBQUVBOzs7O0FBSUEsVUFBU00sUUFBVCxDQUFtQjF2QixFQUFuQixFQUF1QjZuQixHQUF2QixFQUE0QjtBQUMxQjtBQUNBLE9BQUksQ0FBQ0EsR0FBRCxJQUFRLEVBQUVBLE1BQU1BLElBQUlrQixJQUFKLEVBQVIsQ0FBWixFQUFpQztBQUMvQjtBQUNEOztBQUVEO0FBQ0EsT0FBSS9vQixHQUFHMnZCLFNBQVAsRUFBa0I7QUFDaEIsU0FBSTlILElBQUlsK0IsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBQyxDQUF4QixFQUEyQjtBQUN6QmsrQixXQUFJejJCLEtBQUosQ0FBVSxLQUFWLEVBQWlCckMsT0FBakIsQ0FBeUIsVUFBVXlELENBQVYsRUFBYTtBQUFFLGdCQUFPd04sR0FBRzJ2QixTQUFILENBQWF2ekIsR0FBYixDQUFpQjVKLENBQWpCLENBQVA7QUFBNkIsUUFBckU7QUFDRCxNQUZELE1BRU87QUFDTHdOLFVBQUcydkIsU0FBSCxDQUFhdnpCLEdBQWIsQ0FBaUJ5ckIsR0FBakI7QUFDRDtBQUNGLElBTkQsTUFNTztBQUNMLFNBQUkvZixNQUFNLE9BQU85SCxHQUFHNHZCLFlBQUgsQ0FBZ0IsT0FBaEIsS0FBNEIsRUFBbkMsSUFBeUMsR0FBbkQ7QUFDQSxTQUFJOW5CLElBQUluZSxPQUFKLENBQVksTUFBTWsrQixHQUFOLEdBQVksR0FBeEIsSUFBK0IsQ0FBbkMsRUFBc0M7QUFDcEM3bkIsVUFBR21nQixZQUFILENBQWdCLE9BQWhCLEVBQXlCLENBQUNyWSxNQUFNK2YsR0FBUCxFQUFZa0IsSUFBWixFQUF6QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBLFVBQVM4RyxXQUFULENBQXNCN3ZCLEVBQXRCLEVBQTBCNm5CLEdBQTFCLEVBQStCO0FBQzdCO0FBQ0EsT0FBSSxDQUFDQSxHQUFELElBQVEsRUFBRUEsTUFBTUEsSUFBSWtCLElBQUosRUFBUixDQUFaLEVBQWlDO0FBQy9CO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFJL29CLEdBQUcydkIsU0FBUCxFQUFrQjtBQUNoQixTQUFJOUgsSUFBSWwrQixPQUFKLENBQVksR0FBWixJQUFtQixDQUFDLENBQXhCLEVBQTJCO0FBQ3pCaytCLFdBQUl6MkIsS0FBSixDQUFVLEtBQVYsRUFBaUJyQyxPQUFqQixDQUF5QixVQUFVeUQsQ0FBVixFQUFhO0FBQUUsZ0JBQU93TixHQUFHMnZCLFNBQUgsQ0FBYW4rQixNQUFiLENBQW9CZ0IsQ0FBcEIsQ0FBUDtBQUFnQyxRQUF4RTtBQUNELE1BRkQsTUFFTztBQUNMd04sVUFBRzJ2QixTQUFILENBQWFuK0IsTUFBYixDQUFvQnEyQixHQUFwQjtBQUNEO0FBQ0QsU0FBSSxDQUFDN25CLEdBQUcydkIsU0FBSCxDQUFhem5DLE1BQWxCLEVBQTBCO0FBQ3hCOFgsVUFBRzhsQixlQUFILENBQW1CLE9BQW5CO0FBQ0Q7QUFDRixJQVRELE1BU087QUFDTCxTQUFJaGUsTUFBTSxPQUFPOUgsR0FBRzR2QixZQUFILENBQWdCLE9BQWhCLEtBQTRCLEVBQW5DLElBQXlDLEdBQW5EO0FBQ0EsU0FBSUUsTUFBTSxNQUFNakksR0FBTixHQUFZLEdBQXRCO0FBQ0EsWUFBTy9mLElBQUluZSxPQUFKLENBQVltbUMsR0FBWixLQUFvQixDQUEzQixFQUE4QjtBQUM1QmhvQixhQUFNQSxJQUFJeFYsT0FBSixDQUFZdzlCLEdBQVosRUFBaUIsR0FBakIsQ0FBTjtBQUNEO0FBQ0Rob0IsV0FBTUEsSUFBSWloQixJQUFKLEVBQU47QUFDQSxTQUFJamhCLEdBQUosRUFBUztBQUNQOUgsVUFBR21nQixZQUFILENBQWdCLE9BQWhCLEVBQXlCclksR0FBekI7QUFDRCxNQUZELE1BRU87QUFDTDlILFVBQUc4bEIsZUFBSCxDQUFtQixPQUFuQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxVQUFTaUssaUJBQVQsQ0FBNEJDLE1BQTVCLEVBQW9DO0FBQ2xDLE9BQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1g7QUFDRDtBQUNEO0FBQ0EsT0FBSSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDO0FBQzlCLFNBQUlqakMsTUFBTSxFQUFWO0FBQ0EsU0FBSWlqQyxPQUFPQyxHQUFQLEtBQWUsS0FBbkIsRUFBMEI7QUFDeEIzOEIsY0FBT3ZHLEdBQVAsRUFBWW1qQyxrQkFBa0JGLE9BQU94bkMsSUFBUCxJQUFlLEdBQWpDLENBQVo7QUFDRDtBQUNEOEssWUFBT3ZHLEdBQVAsRUFBWWlqQyxNQUFaO0FBQ0EsWUFBT2pqQyxHQUFQO0FBQ0QsSUFQRCxNQU9PLElBQUksT0FBT2lqQyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQ3JDLFlBQU9FLGtCQUFrQkYsTUFBbEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsS0FBSUUsb0JBQW9CbitCLE9BQU8sVUFBVXZKLElBQVYsRUFBZ0I7QUFDN0MsVUFBTztBQUNMMm5DLGlCQUFhM25DLE9BQU8sUUFEZjtBQUVMNG5DLG1CQUFlNW5DLE9BQU8sV0FGakI7QUFHTDZuQyx1QkFBbUI3bkMsT0FBTyxlQUhyQjtBQUlMOG5DLGlCQUFhOW5DLE9BQU8sUUFKZjtBQUtMK25DLG1CQUFlL25DLE9BQU8sV0FMakI7QUFNTGdvQyx1QkFBbUJob0MsT0FBTztBQU5yQixJQUFQO0FBUUQsRUFUdUIsQ0FBeEI7O0FBV0EsS0FBSWlvQyxnQkFBZ0J6M0IsYUFBYSxDQUFDTSxLQUFsQztBQUNBLEtBQUlvM0IsYUFBYSxZQUFqQjtBQUNBLEtBQUlDLFlBQVksV0FBaEI7O0FBRUE7QUFDQSxLQUFJQyxpQkFBaUIsWUFBckI7QUFDQSxLQUFJQyxxQkFBcUIsZUFBekI7QUFDQSxLQUFJQyxnQkFBZ0IsV0FBcEI7QUFDQSxLQUFJQyxvQkFBb0IsY0FBeEI7QUFDQSxLQUFJTixhQUFKLEVBQW1CO0FBQ2pCO0FBQ0EsT0FBSXZuQyxPQUFPOG5DLGVBQVAsS0FBMkJucEMsU0FBM0IsSUFDRnFCLE9BQU8rbkMscUJBQVAsS0FBaUNwcEMsU0FEbkMsRUFFRTtBQUNBK29DLHNCQUFpQixrQkFBakI7QUFDQUMsMEJBQXFCLHFCQUFyQjtBQUNEO0FBQ0QsT0FBSTNuQyxPQUFPZ29DLGNBQVAsS0FBMEJycEMsU0FBMUIsSUFDRnFCLE9BQU9pb0Msb0JBQVAsS0FBZ0N0cEMsU0FEbEMsRUFFRTtBQUNBaXBDLHFCQUFnQixpQkFBaEI7QUFDQUMseUJBQW9CLG9CQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxLQUFJSyxNQUFNcDRCLGFBQWE5UCxPQUFPbW9DLHFCQUFwQixHQUNObm9DLE9BQU9tb0MscUJBQVAsQ0FBNkJqcUMsSUFBN0IsQ0FBa0M4QixNQUFsQyxDQURNLEdBRU5tUyxVQUZKOztBQUlBLFVBQVNpMkIsU0FBVCxDQUFvQnQvQixFQUFwQixFQUF3QjtBQUN0Qm8vQixPQUFJLFlBQVk7QUFDZEEsU0FBSXAvQixFQUFKO0FBQ0QsSUFGRDtBQUdEOztBQUVELFVBQVN1L0Isa0JBQVQsQ0FBNkJ2eEIsRUFBN0IsRUFBaUM2bkIsR0FBakMsRUFBc0M7QUFDcEMsT0FBSTJKLG9CQUFvQnh4QixHQUFHK25CLGtCQUFILEtBQTBCL25CLEdBQUcrbkIsa0JBQUgsR0FBd0IsRUFBbEQsQ0FBeEI7QUFDQSxPQUFJeUosa0JBQWtCN25DLE9BQWxCLENBQTBCaytCLEdBQTFCLElBQWlDLENBQXJDLEVBQXdDO0FBQ3RDMkosdUJBQWtCMzRCLElBQWxCLENBQXVCZ3ZCLEdBQXZCO0FBQ0E2SCxjQUFTMXZCLEVBQVQsRUFBYTZuQixHQUFiO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTNEoscUJBQVQsQ0FBZ0N6eEIsRUFBaEMsRUFBb0M2bkIsR0FBcEMsRUFBeUM7QUFDdkMsT0FBSTduQixHQUFHK25CLGtCQUFQLEVBQTJCO0FBQ3pCdjJCLFlBQU93TyxHQUFHK25CLGtCQUFWLEVBQThCRixHQUE5QjtBQUNEO0FBQ0RnSSxlQUFZN3ZCLEVBQVosRUFBZ0I2bkIsR0FBaEI7QUFDRDs7QUFFRCxVQUFTNkosa0JBQVQsQ0FDRTF4QixFQURGLEVBRUU4RCxZQUZGLEVBR0VoSSxFQUhGLEVBSUU7QUFDQSxPQUFJdWQsTUFBTXNZLGtCQUFrQjN4QixFQUFsQixFQUFzQjhELFlBQXRCLENBQVY7QUFDQSxPQUFJM0MsT0FBT2tZLElBQUlsWSxJQUFmO0FBQ0EsT0FBSWlKLFVBQVVpUCxJQUFJalAsT0FBbEI7QUFDQSxPQUFJd25CLFlBQVl2WSxJQUFJdVksU0FBcEI7QUFDQSxPQUFJLENBQUN6d0IsSUFBTCxFQUFXO0FBQUUsWUFBT3JGLElBQVA7QUFBYTtBQUMxQixPQUFJN04sUUFBUWtULFNBQVN1dkIsVUFBVCxHQUFzQkcsa0JBQXRCLEdBQTJDRSxpQkFBdkQ7QUFDQSxPQUFJYyxRQUFRLENBQVo7QUFDQSxPQUFJQyxNQUFNLFNBQU5BLEdBQU0sR0FBWTtBQUNwQjl4QixRQUFHaXRCLG1CQUFILENBQXVCaC9CLEtBQXZCLEVBQThCOGpDLEtBQTlCO0FBQ0FqMkI7QUFDRCxJQUhEO0FBSUEsT0FBSWkyQixRQUFRLFNBQVJBLEtBQVEsQ0FBVXZxQyxDQUFWLEVBQWE7QUFDdkIsU0FBSUEsRUFBRXFWLE1BQUYsS0FBYW1ELEVBQWpCLEVBQXFCO0FBQ25CLFdBQUksRUFBRTZ4QixLQUFGLElBQVdELFNBQWYsRUFBMEI7QUFDeEJFO0FBQ0Q7QUFDRjtBQUNGLElBTkQ7QUFPQXoyQixjQUFXLFlBQVk7QUFDckIsU0FBSXcyQixRQUFRRCxTQUFaLEVBQXVCO0FBQ3JCRTtBQUNEO0FBQ0YsSUFKRCxFQUlHMW5CLFVBQVUsQ0FKYjtBQUtBcEssTUFBR2hHLGdCQUFILENBQW9CL0wsS0FBcEIsRUFBMkI4akMsS0FBM0I7QUFDRDs7QUFFRCxLQUFJQyxjQUFjLHdCQUFsQjs7QUFFQSxVQUFTTCxpQkFBVCxDQUE0QjN4QixFQUE1QixFQUFnQzhELFlBQWhDLEVBQThDO0FBQzVDLE9BQUltdUIsU0FBUy9vQyxPQUFPZ3BDLGdCQUFQLENBQXdCbHlCLEVBQXhCLENBQWI7QUFDQSxPQUFJbXlCLG1CQUFtQkYsT0FBT3JCLGlCQUFpQixPQUF4QixFQUFpQ3gvQixLQUFqQyxDQUF1QyxJQUF2QyxDQUF2QjtBQUNBLE9BQUlnaEMsc0JBQXNCSCxPQUFPckIsaUJBQWlCLFVBQXhCLEVBQW9DeC9CLEtBQXBDLENBQTBDLElBQTFDLENBQTFCO0FBQ0EsT0FBSWloQyxvQkFBb0JDLFdBQVdILGdCQUFYLEVBQTZCQyxtQkFBN0IsQ0FBeEI7QUFDQSxPQUFJRyxrQkFBa0JOLE9BQU9uQixnQkFBZ0IsT0FBdkIsRUFBZ0MxL0IsS0FBaEMsQ0FBc0MsSUFBdEMsQ0FBdEI7QUFDQSxPQUFJb2hDLHFCQUFxQlAsT0FBT25CLGdCQUFnQixVQUF2QixFQUFtQzEvQixLQUFuQyxDQUF5QyxJQUF6QyxDQUF6QjtBQUNBLE9BQUlxaEMsbUJBQW1CSCxXQUFXQyxlQUFYLEVBQTRCQyxrQkFBNUIsQ0FBdkI7O0FBRUEsT0FBSXJ4QixJQUFKO0FBQ0EsT0FBSWlKLFVBQVUsQ0FBZDtBQUNBLE9BQUl3bkIsWUFBWSxDQUFoQjtBQUNBO0FBQ0EsT0FBSTl0QixpQkFBaUI0c0IsVUFBckIsRUFBaUM7QUFDL0IsU0FBSTJCLG9CQUFvQixDQUF4QixFQUEyQjtBQUN6Qmx4QixjQUFPdXZCLFVBQVA7QUFDQXRtQixpQkFBVWlvQixpQkFBVjtBQUNBVCxtQkFBWVEsb0JBQW9CbHFDLE1BQWhDO0FBQ0Q7QUFDRixJQU5ELE1BTU8sSUFBSTRiLGlCQUFpQjZzQixTQUFyQixFQUFnQztBQUNyQyxTQUFJOEIsbUJBQW1CLENBQXZCLEVBQTBCO0FBQ3hCdHhCLGNBQU93dkIsU0FBUDtBQUNBdm1CLGlCQUFVcW9CLGdCQUFWO0FBQ0FiLG1CQUFZWSxtQkFBbUJ0cUMsTUFBL0I7QUFDRDtBQUNGLElBTk0sTUFNQTtBQUNMa2lCLGVBQVU5WixLQUFLdVAsR0FBTCxDQUFTd3lCLGlCQUFULEVBQTRCSSxnQkFBNUIsQ0FBVjtBQUNBdHhCLFlBQU9pSixVQUFVLENBQVYsR0FDSGlvQixvQkFBb0JJLGdCQUFwQixHQUNFL0IsVUFERixHQUVFQyxTQUhDLEdBSUgsSUFKSjtBQUtBaUIsaUJBQVl6d0IsT0FDUkEsU0FBU3V2QixVQUFULEdBQ0UwQixvQkFBb0JscUMsTUFEdEIsR0FFRXNxQyxtQkFBbUJ0cUMsTUFIYixHQUlSLENBSko7QUFLRDtBQUNELE9BQUl3cUMsZUFDRnZ4QixTQUFTdXZCLFVBQVQsSUFDQXNCLFlBQVk3NkIsSUFBWixDQUFpQjg2QixPQUFPckIsaUJBQWlCLFVBQXhCLENBQWpCLENBRkY7QUFHQSxVQUFPO0FBQ0x6dkIsV0FBTUEsSUFERDtBQUVMaUosY0FBU0EsT0FGSjtBQUdMd25CLGdCQUFXQSxTQUhOO0FBSUxjLG1CQUFjQTtBQUpULElBQVA7QUFNRDs7QUFFRCxVQUFTSixVQUFULENBQXFCSyxNQUFyQixFQUE2QkMsU0FBN0IsRUFBd0M7QUFDdEM7QUFDQSxVQUFPRCxPQUFPenFDLE1BQVAsR0FBZ0IwcUMsVUFBVTFxQyxNQUFqQyxFQUF5QztBQUN2Q3lxQyxjQUFTQSxPQUFPMStCLE1BQVAsQ0FBYzArQixNQUFkLENBQVQ7QUFDRDs7QUFFRCxVQUFPcmlDLEtBQUt1UCxHQUFMLENBQVNwWSxLQUFULENBQWUsSUFBZixFQUFxQm1yQyxVQUFVM2hDLEdBQVYsQ0FBYyxVQUFVOUMsQ0FBVixFQUFhbEcsQ0FBYixFQUFnQjtBQUN4RCxZQUFPNHFDLEtBQUsxa0MsQ0FBTCxJQUFVMGtDLEtBQUtGLE9BQU8xcUMsQ0FBUCxDQUFMLENBQWpCO0FBQ0QsSUFGMkIsQ0FBckIsQ0FBUDtBQUdEOztBQUVELFVBQVM0cUMsSUFBVCxDQUFlQyxDQUFmLEVBQWtCO0FBQ2hCLFVBQU9DLE9BQU9ELEVBQUVqcEMsS0FBRixDQUFRLENBQVIsRUFBVyxDQUFDLENBQVosQ0FBUCxJQUF5QixJQUFoQztBQUNEOztBQUVEOztBQUVBLFVBQVNtcEMsS0FBVCxDQUFnQmxzQixLQUFoQixFQUF1Qm1zQixhQUF2QixFQUFzQztBQUNwQyxPQUFJanpCLEtBQUs4RyxNQUFNckIsR0FBZjs7QUFFQTtBQUNBLE9BQUlqVyxNQUFNd1EsR0FBR2ltQixRQUFULENBQUosRUFBd0I7QUFDdEJqbUIsUUFBR2ltQixRQUFILENBQVlpTixTQUFaLEdBQXdCLElBQXhCO0FBQ0FsekIsUUFBR2ltQixRQUFIO0FBQ0Q7O0FBRUQsT0FBSXo0QixPQUFPdWlDLGtCQUFrQmpwQixNQUFNdFosSUFBTixDQUFXeTFCLFVBQTdCLENBQVg7QUFDQSxPQUFJM3pCLFFBQVE5QixJQUFSLENBQUosRUFBbUI7QUFDakI7QUFDRDs7QUFFRDtBQUNBLE9BQUlnQyxNQUFNd1EsR0FBR216QixRQUFULEtBQXNCbnpCLEdBQUd5bEIsUUFBSCxLQUFnQixDQUExQyxFQUE2QztBQUMzQztBQUNEOztBQUVELE9BQUl3SyxNQUFNemlDLEtBQUt5aUMsR0FBZjtBQUNBLE9BQUk5dUIsT0FBTzNULEtBQUsyVCxJQUFoQjtBQUNBLE9BQUlndkIsYUFBYTNpQyxLQUFLMmlDLFVBQXRCO0FBQ0EsT0FBSUMsZUFBZTVpQyxLQUFLNGlDLFlBQXhCO0FBQ0EsT0FBSUMsbUJBQW1CN2lDLEtBQUs2aUMsZ0JBQTVCO0FBQ0EsT0FBSStDLGNBQWM1bEMsS0FBSzRsQyxXQUF2QjtBQUNBLE9BQUlDLGdCQUFnQjdsQyxLQUFLNmxDLGFBQXpCO0FBQ0EsT0FBSUMsb0JBQW9COWxDLEtBQUs4bEMsaUJBQTdCO0FBQ0EsT0FBSUMsY0FBYy9sQyxLQUFLK2xDLFdBQXZCO0FBQ0EsT0FBSVAsUUFBUXhsQyxLQUFLd2xDLEtBQWpCO0FBQ0EsT0FBSVEsYUFBYWhtQyxLQUFLZ21DLFVBQXRCO0FBQ0EsT0FBSUMsaUJBQWlCam1DLEtBQUtpbUMsY0FBMUI7QUFDQSxPQUFJQyxlQUFlbG1DLEtBQUtrbUMsWUFBeEI7QUFDQSxPQUFJQyxTQUFTbm1DLEtBQUttbUMsTUFBbEI7QUFDQSxPQUFJQyxjQUFjcG1DLEtBQUtvbUMsV0FBdkI7QUFDQSxPQUFJQyxrQkFBa0JybUMsS0FBS3FtQyxlQUEzQjtBQUNBLE9BQUlDLFdBQVd0bUMsS0FBS3NtQyxRQUFwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQUlwdUIsVUFBVXFHLGNBQWQ7QUFDQSxPQUFJZ29CLGlCQUFpQmhvQixlQUFleUIsTUFBcEM7QUFDQSxVQUFPdW1CLGtCQUFrQkEsZUFBZTd6QixNQUF4QyxFQUFnRDtBQUM5QzZ6QixzQkFBaUJBLGVBQWU3ekIsTUFBaEM7QUFDQXdGLGVBQVVxdUIsZUFBZXJ1QixPQUF6QjtBQUNEOztBQUVELE9BQUlzdUIsV0FBVyxDQUFDdHVCLFFBQVE4RyxVQUFULElBQXVCLENBQUMxRixNQUFNWixZQUE3Qzs7QUFFQSxPQUFJOHRCLFlBQVksQ0FBQ0wsTUFBYixJQUF1QkEsV0FBVyxFQUF0QyxFQUEwQztBQUN4QztBQUNEOztBQUVELE9BQUlNLGFBQWFELFlBQVlaLFdBQVosR0FDYkEsV0FEYSxHQUViakQsVUFGSjtBQUdBLE9BQUkrRCxjQUFjRixZQUFZVixpQkFBWixHQUNkQSxpQkFEYyxHQUVkakQsZ0JBRko7QUFHQSxPQUFJOEQsVUFBVUgsWUFBWVgsYUFBWixHQUNWQSxhQURVLEdBRVZqRCxZQUZKOztBQUlBLE9BQUlnRSxrQkFBa0JKLFdBQ2pCTixnQkFBZ0JILFdBREMsR0FFbEJBLFdBRko7QUFHQSxPQUFJYyxZQUFZTCxXQUNYLE9BQU9MLE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQS9CLEdBQXdDWCxLQUQ3QixHQUVaQSxLQUZKO0FBR0EsT0FBSXNCLGlCQUFpQk4sV0FDaEJKLGVBQWVKLFVBREMsR0FFakJBLFVBRko7QUFHQSxPQUFJZSxxQkFBcUJQLFdBQ3BCSCxtQkFBbUJKLGNBREMsR0FFckJBLGNBRko7O0FBSUEsT0FBSWUsd0JBQXdCNWpDLFNBQzFCZixTQUFTaWtDLFFBQVQsSUFDSUEsU0FBU2QsS0FEYixHQUVJYyxRQUhzQixDQUE1Qjs7QUFNQSxPQUFJditCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QysrQix5QkFBeUIsSUFBdEUsRUFBNEU7QUFDMUVDLG1CQUFjRCxxQkFBZCxFQUFxQyxPQUFyQyxFQUE4QzF0QixLQUE5QztBQUNEOztBQUVELE9BQUk0dEIsYUFBYXpFLFFBQVEsS0FBUixJQUFpQixDQUFDMzJCLEtBQW5DO0FBQ0EsT0FBSXE3QixtQkFBbUJDLHVCQUF1QlAsU0FBdkIsQ0FBdkI7O0FBRUEsT0FBSXY0QixLQUFLa0UsR0FBR216QixRQUFILEdBQWNyK0IsS0FBSyxZQUFZO0FBQ3RDLFNBQUk0L0IsVUFBSixFQUFnQjtBQUNkakQsNkJBQXNCenhCLEVBQXRCLEVBQTBCbTBCLE9BQTFCO0FBQ0ExQyw2QkFBc0J6eEIsRUFBdEIsRUFBMEJrMEIsV0FBMUI7QUFDRDtBQUNELFNBQUlwNEIsR0FBR28zQixTQUFQLEVBQWtCO0FBQ2hCLFdBQUl3QixVQUFKLEVBQWdCO0FBQ2RqRCwrQkFBc0J6eEIsRUFBdEIsRUFBMEJpMEIsVUFBMUI7QUFDRDtBQUNETSw2QkFBc0JBLG1CQUFtQnYwQixFQUFuQixDQUF0QjtBQUNELE1BTEQsTUFLTztBQUNMczBCLHlCQUFrQkEsZUFBZXQwQixFQUFmLENBQWxCO0FBQ0Q7QUFDREEsUUFBR216QixRQUFILEdBQWMsSUFBZDtBQUNELElBZHNCLENBQXZCOztBQWdCQSxPQUFJLENBQUNyc0IsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFoQixFQUFzQjtBQUNwQjtBQUNBN3NCLG9CQUFlbEIsTUFBTXRaLElBQU4sQ0FBV3lULElBQVgsS0FBb0I2RixNQUFNdFosSUFBTixDQUFXeVQsSUFBWCxHQUFrQixFQUF0QyxDQUFmLEVBQTBELFFBQTFELEVBQW9FLFlBQVk7QUFDOUUsV0FBSWYsU0FBU0YsR0FBRzBlLFVBQWhCO0FBQ0EsV0FBSW9XLGNBQWM1MEIsVUFBVUEsT0FBTzYwQixRQUFqQixJQUE2QjcwQixPQUFPNjBCLFFBQVAsQ0FBZ0JqdUIsTUFBTWhWLEdBQXRCLENBQS9DO0FBQ0EsV0FBSWdqQyxlQUNGQSxZQUFZeHdCLEdBQVosS0FBb0J3QyxNQUFNeEMsR0FEeEIsSUFFRnd3QixZQUFZcnZCLEdBQVosQ0FBZ0J3Z0IsUUFGbEIsRUFHRTtBQUNBNk8scUJBQVlydkIsR0FBWixDQUFnQndnQixRQUFoQjtBQUNEO0FBQ0RvTyxvQkFBYUEsVUFBVXIwQixFQUFWLEVBQWNsRSxFQUFkLENBQWI7QUFDRCxNQVZEO0FBV0Q7O0FBRUQ7QUFDQXM0QixzQkFBbUJBLGdCQUFnQnAwQixFQUFoQixDQUFuQjtBQUNBLE9BQUkwMEIsVUFBSixFQUFnQjtBQUNkbkQsd0JBQW1CdnhCLEVBQW5CLEVBQXVCaTBCLFVBQXZCO0FBQ0ExQyx3QkFBbUJ2eEIsRUFBbkIsRUFBdUJrMEIsV0FBdkI7QUFDQTVDLGVBQVUsWUFBWTtBQUNwQkMsMEJBQW1CdnhCLEVBQW5CLEVBQXVCbTBCLE9BQXZCO0FBQ0ExQyw2QkFBc0J6eEIsRUFBdEIsRUFBMEJpMEIsVUFBMUI7QUFDQSxXQUFJLENBQUNuNEIsR0FBR28zQixTQUFKLElBQWlCLENBQUN5QixnQkFBdEIsRUFBd0M7QUFDdEMsYUFBSUssZ0JBQWdCUixxQkFBaEIsQ0FBSixFQUE0QztBQUMxQ241QixzQkFBV1MsRUFBWCxFQUFlMDRCLHFCQUFmO0FBQ0QsVUFGRCxNQUVPO0FBQ0w5Qyw4QkFBbUIxeEIsRUFBbkIsRUFBdUJtQixJQUF2QixFQUE2QnJGLEVBQTdCO0FBQ0Q7QUFDRjtBQUNGLE1BVkQ7QUFXRDs7QUFFRCxPQUFJZ0wsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFmLEVBQXFCO0FBQ25CNUIsc0JBQWlCQSxlQUFqQjtBQUNBb0Isa0JBQWFBLFVBQVVyMEIsRUFBVixFQUFjbEUsRUFBZCxDQUFiO0FBQ0Q7O0FBRUQsT0FBSSxDQUFDNDRCLFVBQUQsSUFBZSxDQUFDQyxnQkFBcEIsRUFBc0M7QUFDcEM3NEI7QUFDRDtBQUNGOztBQUVELFVBQVNtNUIsS0FBVCxDQUFnQm51QixLQUFoQixFQUF1QjhjLEVBQXZCLEVBQTJCO0FBQ3pCLE9BQUk1akIsS0FBSzhHLE1BQU1yQixHQUFmOztBQUVBO0FBQ0EsT0FBSWpXLE1BQU13USxHQUFHbXpCLFFBQVQsQ0FBSixFQUF3QjtBQUN0Qm56QixRQUFHbXpCLFFBQUgsQ0FBWUQsU0FBWixHQUF3QixJQUF4QjtBQUNBbHpCLFFBQUdtekIsUUFBSDtBQUNEOztBQUVELE9BQUkzbEMsT0FBT3VpQyxrQkFBa0JqcEIsTUFBTXRaLElBQU4sQ0FBV3kxQixVQUE3QixDQUFYO0FBQ0EsT0FBSTN6QixRQUFROUIsSUFBUixDQUFKLEVBQW1CO0FBQ2pCLFlBQU9vMkIsSUFBUDtBQUNEOztBQUVEO0FBQ0EsT0FBSXAwQixNQUFNd1EsR0FBR2ltQixRQUFULEtBQXNCam1CLEdBQUd5bEIsUUFBSCxLQUFnQixDQUExQyxFQUE2QztBQUMzQztBQUNEOztBQUVELE9BQUl3SyxNQUFNemlDLEtBQUt5aUMsR0FBZjtBQUNBLE9BQUk5dUIsT0FBTzNULEtBQUsyVCxJQUFoQjtBQUNBLE9BQUltdkIsYUFBYTlpQyxLQUFLOGlDLFVBQXRCO0FBQ0EsT0FBSUMsZUFBZS9pQyxLQUFLK2lDLFlBQXhCO0FBQ0EsT0FBSUMsbUJBQW1CaGpDLEtBQUtnakMsZ0JBQTVCO0FBQ0EsT0FBSTBFLGNBQWMxbkMsS0FBSzBuQyxXQUF2QjtBQUNBLE9BQUlELFFBQVF6bkMsS0FBS3luQyxLQUFqQjtBQUNBLE9BQUlFLGFBQWEzbkMsS0FBSzJuQyxVQUF0QjtBQUNBLE9BQUlDLGlCQUFpQjVuQyxLQUFLNG5DLGNBQTFCO0FBQ0EsT0FBSUMsYUFBYTduQyxLQUFLNm5DLFVBQXRCO0FBQ0EsT0FBSXZCLFdBQVd0bUMsS0FBS3NtQyxRQUFwQjs7QUFFQSxPQUFJWSxhQUFhekUsUUFBUSxLQUFSLElBQWlCLENBQUMzMkIsS0FBbkM7QUFDQSxPQUFJcTdCLG1CQUFtQkMsdUJBQXVCSyxLQUF2QixDQUF2Qjs7QUFFQSxPQUFJSyx3QkFBd0Ixa0MsU0FDMUJmLFNBQVNpa0MsUUFBVCxJQUNJQSxTQUFTbUIsS0FEYixHQUVJbkIsUUFIc0IsQ0FBNUI7O0FBTUEsT0FBSXYrQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNqRyxNQUFNOGxDLHFCQUFOLENBQTdDLEVBQTJFO0FBQ3pFYixtQkFBY2EscUJBQWQsRUFBcUMsT0FBckMsRUFBOEN4dUIsS0FBOUM7QUFDRDs7QUFFRCxPQUFJaEwsS0FBS2tFLEdBQUdpbUIsUUFBSCxHQUFjbnhCLEtBQUssWUFBWTtBQUN0QyxTQUFJa0wsR0FBRzBlLFVBQUgsSUFBaUIxZSxHQUFHMGUsVUFBSCxDQUFjcVcsUUFBbkMsRUFBNkM7QUFDM0MvMEIsVUFBRzBlLFVBQUgsQ0FBY3FXLFFBQWQsQ0FBdUJqdUIsTUFBTWhWLEdBQTdCLElBQW9DLElBQXBDO0FBQ0Q7QUFDRCxTQUFJNGlDLFVBQUosRUFBZ0I7QUFDZGpELDZCQUFzQnp4QixFQUF0QixFQUEwQnV3QixZQUExQjtBQUNBa0IsNkJBQXNCenhCLEVBQXRCLEVBQTBCd3dCLGdCQUExQjtBQUNEO0FBQ0QsU0FBSTEwQixHQUFHbzNCLFNBQVAsRUFBa0I7QUFDaEIsV0FBSXdCLFVBQUosRUFBZ0I7QUFDZGpELCtCQUFzQnp4QixFQUF0QixFQUEwQnN3QixVQUExQjtBQUNEO0FBQ0Q4RSx5QkFBa0JBLGVBQWVwMUIsRUFBZixDQUFsQjtBQUNELE1BTEQsTUFLTztBQUNMNGpCO0FBQ0F1UixxQkFBY0EsV0FBV24xQixFQUFYLENBQWQ7QUFDRDtBQUNEQSxRQUFHaW1CLFFBQUgsR0FBYyxJQUFkO0FBQ0QsSUFsQnNCLENBQXZCOztBQW9CQSxPQUFJb1AsVUFBSixFQUFnQjtBQUNkQSxnQkFBV0UsWUFBWDtBQUNELElBRkQsTUFFTztBQUNMQTtBQUNEOztBQUVELFlBQVNBLFlBQVQsR0FBeUI7QUFDdkI7QUFDQSxTQUFJejVCLEdBQUdvM0IsU0FBUCxFQUFrQjtBQUNoQjtBQUNEO0FBQ0Q7QUFDQSxTQUFJLENBQUNwc0IsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFoQixFQUFzQjtBQUNwQixRQUFDNzBCLEdBQUcwZSxVQUFILENBQWNxVyxRQUFkLEtBQTJCLzBCLEdBQUcwZSxVQUFILENBQWNxVyxRQUFkLEdBQXlCLEVBQXBELENBQUQsRUFBMkRqdUIsTUFBTWhWLEdBQWpFLElBQXlFZ1YsS0FBekU7QUFDRDtBQUNEb3VCLG9CQUFlQSxZQUFZbDFCLEVBQVosQ0FBZjtBQUNBLFNBQUkwMEIsVUFBSixFQUFnQjtBQUNkbkQsMEJBQW1CdnhCLEVBQW5CLEVBQXVCc3dCLFVBQXZCO0FBQ0FpQiwwQkFBbUJ2eEIsRUFBbkIsRUFBdUJ3d0IsZ0JBQXZCO0FBQ0FjLGlCQUFVLFlBQVk7QUFDcEJDLDRCQUFtQnZ4QixFQUFuQixFQUF1QnV3QixZQUF2QjtBQUNBa0IsK0JBQXNCenhCLEVBQXRCLEVBQTBCc3dCLFVBQTFCO0FBQ0EsYUFBSSxDQUFDeDBCLEdBQUdvM0IsU0FBSixJQUFpQixDQUFDeUIsZ0JBQXRCLEVBQXdDO0FBQ3RDLGVBQUlLLGdCQUFnQk0scUJBQWhCLENBQUosRUFBNEM7QUFDMUNqNkIsd0JBQVdTLEVBQVgsRUFBZXc1QixxQkFBZjtBQUNELFlBRkQsTUFFTztBQUNMNUQsZ0NBQW1CMXhCLEVBQW5CLEVBQXVCbUIsSUFBdkIsRUFBNkJyRixFQUE3QjtBQUNEO0FBQ0Y7QUFDRixRQVZEO0FBV0Q7QUFDRG01QixjQUFTQSxNQUFNajFCLEVBQU4sRUFBVWxFLEVBQVYsQ0FBVDtBQUNBLFNBQUksQ0FBQzQ0QixVQUFELElBQWUsQ0FBQ0MsZ0JBQXBCLEVBQXNDO0FBQ3BDNzRCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsVUFBUzI0QixhQUFULENBQXdCdGtDLEdBQXhCLEVBQTZCM0gsSUFBN0IsRUFBbUNzZSxLQUFuQyxFQUEwQztBQUN4QyxPQUFJLE9BQU8zVyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0JrSCxVQUNFLDJCQUEyQjdPLElBQTNCLEdBQWtDLG9DQUFsQyxHQUNBLE1BREEsR0FDVWlJLEtBQUtDLFNBQUwsQ0FBZVAsR0FBZixDQURWLEdBQ2lDLEdBRm5DLEVBR0UyVyxNQUFNcEIsT0FIUjtBQUtELElBTkQsTUFNTyxJQUFJN1UsTUFBTVYsR0FBTixDQUFKLEVBQWdCO0FBQ3JCa0gsVUFDRSwyQkFBMkI3TyxJQUEzQixHQUFrQyxxQkFBbEMsR0FDQSw2Q0FGRixFQUdFc2UsTUFBTXBCLE9BSFI7QUFLRDtBQUNGOztBQUVELFVBQVNzdkIsZUFBVCxDQUEwQjdrQyxHQUExQixFQUErQjtBQUM3QixVQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLENBQUNVLE1BQU1WLEdBQU4sQ0FBbkM7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsVUFBU3lrQyxzQkFBVCxDQUFpQzVpQyxFQUFqQyxFQUFxQztBQUNuQyxPQUFJMUMsUUFBUTBDLEVBQVIsQ0FBSixFQUFpQjtBQUNmLFlBQU8sS0FBUDtBQUNEO0FBQ0QsT0FBSXdqQyxhQUFheGpDLEdBQUd1VixHQUFwQjtBQUNBLE9BQUkvWCxNQUFNZ21DLFVBQU4sQ0FBSixFQUF1QjtBQUNyQjtBQUNBLFlBQU9aLHVCQUNMdmhDLE1BQU1tQixPQUFOLENBQWNnaEMsVUFBZCxJQUNJQSxXQUFXLENBQVgsQ0FESixHQUVJQSxVQUhDLENBQVA7QUFLRCxJQVBELE1BT087QUFDTCxZQUFPLENBQUN4akMsR0FBR2lCLE9BQUgsSUFBY2pCLEdBQUc5SixNQUFsQixJQUE0QixDQUFuQztBQUNEO0FBQ0Y7O0FBRUQsVUFBU3V0QyxNQUFULENBQWlCbGpDLENBQWpCLEVBQW9CdVUsS0FBcEIsRUFBMkI7QUFDekIsT0FBSUEsTUFBTXRaLElBQU4sQ0FBV3FuQyxJQUFYLEtBQW9CLElBQXhCLEVBQThCO0FBQzVCN0IsV0FBTWxzQixLQUFOO0FBQ0Q7QUFDRjs7QUFFRCxLQUFJbWMsYUFBYWpxQixZQUFZO0FBQzNCOUgsV0FBUXVrQyxNQURtQjtBQUUzQnZTLGFBQVV1UyxNQUZpQjtBQUczQmprQyxXQUFRLFNBQVNxVyxTQUFULENBQW9CZixLQUFwQixFQUEyQjhjLEVBQTNCLEVBQStCO0FBQ3JDO0FBQ0EsU0FBSTljLE1BQU10WixJQUFOLENBQVdxbkMsSUFBWCxLQUFvQixJQUF4QixFQUE4QjtBQUM1QkksYUFBTW51QixLQUFOLEVBQWE4YyxFQUFiO0FBQ0QsTUFGRCxNQUVPO0FBQ0xBO0FBQ0Q7QUFDRjtBQVYwQixFQUFaLEdBV2IsRUFYSjs7QUFhQSxLQUFJOFIsa0JBQWtCLENBQ3BCcHRCLEtBRG9CLEVBRXBCMmYsS0FGb0IsRUFHcEIwQixNQUhvQixFQUlwQnZSLFFBSm9CLEVBS3BCZ1csS0FMb0IsRUFNcEJuTCxVQU5vQixDQUF0Qjs7QUFTQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSW52QixVQUFVNGhDLGdCQUFnQnpoQyxNQUFoQixDQUF1Qm16QixXQUF2QixDQUFkOztBQUVBLEtBQUkxQixRQUFRN0Qsb0JBQW9CLEVBQUVkLFNBQVNBLE9BQVgsRUFBb0JqdEIsU0FBU0EsT0FBN0IsRUFBcEIsQ0FBWjs7QUFFQTs7Ozs7QUFLQSxLQUFJNmhDLGtCQUFrQjdrQyxRQUFRLDJDQUFSLENBQXRCOztBQUVBO0FBQ0EsS0FBSXdJLEtBQUosRUFBVztBQUNUO0FBQ0FqUSxZQUFTMlEsZ0JBQVQsQ0FBMEIsaUJBQTFCLEVBQTZDLFlBQVk7QUFDdkQsU0FBSWdHLEtBQUszVyxTQUFTd2tDLGFBQWxCO0FBQ0EsU0FBSTd0QixNQUFNQSxHQUFHNDFCLE1BQWIsRUFBcUI7QUFDbkJDLGVBQVE3MUIsRUFBUixFQUFZLE9BQVo7QUFDRDtBQUNGLElBTEQ7QUFNRDs7QUFFRCxLQUFJODFCLFVBQVU7QUFDWi8zQixhQUFVLFNBQVNBLFFBQVQsQ0FBbUJpQyxFQUFuQixFQUF1QisxQixPQUF2QixFQUFnQ2p2QixLQUFoQyxFQUF1QztBQUMvQyxTQUFJQSxNQUFNeEMsR0FBTixLQUFjLFFBQWxCLEVBQTRCO0FBQzFCLFdBQUl4SSxLQUFLLFNBQUxBLEVBQUssR0FBWTtBQUNuQms2QixxQkFBWWgyQixFQUFaLEVBQWdCKzFCLE9BQWhCLEVBQXlCanZCLE1BQU1wQixPQUEvQjtBQUNELFFBRkQ7QUFHQTVKO0FBQ0E7QUFDQSxXQUFJekMsUUFBUUUsTUFBWixFQUFvQjtBQUNsQjhCLG9CQUFXUyxFQUFYLEVBQWUsQ0FBZjtBQUNEO0FBQ0RrRSxVQUFHaTJCLFNBQUgsR0FBZSxHQUFHaGxDLEdBQUgsQ0FBTzFKLElBQVAsQ0FBWXlZLEdBQUdoSSxPQUFmLEVBQXdCaytCLFFBQXhCLENBQWY7QUFDRCxNQVZELE1BVU8sSUFBSXB2QixNQUFNeEMsR0FBTixLQUFjLFVBQWQsSUFBNEJxeEIsZ0JBQWdCMzFCLEdBQUdtQixJQUFuQixDQUFoQyxFQUEwRDtBQUMvRG5CLFVBQUc4dEIsV0FBSCxHQUFpQmlJLFFBQVE5TyxTQUF6QjtBQUNBLFdBQUksQ0FBQzhPLFFBQVE5TyxTQUFSLENBQWtCcFcsSUFBdkIsRUFBNkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTdRLFlBQUdoRyxnQkFBSCxDQUFvQixRQUFwQixFQUE4Qm04QixnQkFBOUI7QUFDQSxhQUFJLENBQUMzOEIsU0FBTCxFQUFnQjtBQUNkd0csY0FBR2hHLGdCQUFILENBQW9CLGtCQUFwQixFQUF3Q284QixrQkFBeEM7QUFDQXAyQixjQUFHaEcsZ0JBQUgsQ0FBb0IsZ0JBQXBCLEVBQXNDbThCLGdCQUF0QztBQUNEO0FBQ0Q7QUFDQSxhQUFJNzhCLEtBQUosRUFBVztBQUNUMEcsY0FBRzQxQixNQUFILEdBQVksSUFBWjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLElBOUJXO0FBK0JaOU8scUJBQWtCLFNBQVNBLGdCQUFULENBQTJCOW1CLEVBQTNCLEVBQStCKzFCLE9BQS9CLEVBQXdDanZCLEtBQXhDLEVBQStDO0FBQy9ELFNBQUlBLE1BQU14QyxHQUFOLEtBQWMsUUFBbEIsRUFBNEI7QUFDMUIweEIsbUJBQVloMkIsRUFBWixFQUFnQisxQixPQUFoQixFQUF5Qmp2QixNQUFNcEIsT0FBL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUkyd0IsY0FBY3IyQixHQUFHaTJCLFNBQXJCO0FBQ0EsV0FBSUssYUFBYXQyQixHQUFHaTJCLFNBQUgsR0FBZSxHQUFHaGxDLEdBQUgsQ0FBTzFKLElBQVAsQ0FBWXlZLEdBQUdoSSxPQUFmLEVBQXdCaytCLFFBQXhCLENBQWhDO0FBQ0EsV0FBSUksV0FBV0MsSUFBWCxDQUFnQixVQUFVQyxDQUFWLEVBQWF2dUMsQ0FBYixFQUFnQjtBQUFFLGdCQUFPLENBQUNtTSxXQUFXb2lDLENBQVgsRUFBY0gsWUFBWXB1QyxDQUFaLENBQWQsQ0FBUjtBQUF3QyxRQUExRSxDQUFKLEVBQWlGO0FBQy9FNHRDLGlCQUFRNzFCLEVBQVIsRUFBWSxRQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBNUNXLEVBQWQ7O0FBK0NBLFVBQVNnMkIsV0FBVCxDQUFzQmgyQixFQUF0QixFQUEwQisxQixPQUExQixFQUFtQ24rQixFQUFuQyxFQUF1QztBQUNyQyxPQUFJaEksUUFBUW1tQyxRQUFRbm1DLEtBQXBCO0FBQ0EsT0FBSTZtQyxhQUFhejJCLEdBQUdrZ0IsUUFBcEI7QUFDQSxPQUFJdVcsY0FBYyxDQUFDcGpDLE1BQU1tQixPQUFOLENBQWM1RSxLQUFkLENBQW5CLEVBQXlDO0FBQ3ZDMkYsYUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDNEIsS0FDdkMsZ0NBQWlDMCtCLFFBQVE3bEIsVUFBekMsR0FBdUQsTUFBdkQsR0FDQSxrREFEQSxHQUNzRHJoQixPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpCLENBQTBCeEksSUFBMUIsQ0FBK0JxSSxLQUEvQixFQUFzQy9GLEtBQXRDLENBQTRDLENBQTVDLEVBQStDLENBQUMsQ0FBaEQsQ0FGZixFQUd2QytOLEVBSHVDLENBQXpDO0FBS0E7QUFDRDtBQUNELE9BQUlrb0IsUUFBSixFQUFjck4sTUFBZDtBQUNBLFFBQUssSUFBSXhxQixJQUFJLENBQVIsRUFBVytLLElBQUlnTixHQUFHaEksT0FBSCxDQUFXOVAsTUFBL0IsRUFBdUNELElBQUkrSyxDQUEzQyxFQUE4Qy9LLEdBQTlDLEVBQW1EO0FBQ2pEd3FCLGNBQVN6UyxHQUFHaEksT0FBSCxDQUFXL1AsQ0FBWCxDQUFUO0FBQ0EsU0FBSXd1QyxVQUFKLEVBQWdCO0FBQ2QzVyxrQkFBV2pyQixhQUFhakYsS0FBYixFQUFvQnNtQyxTQUFTempCLE1BQVQsQ0FBcEIsSUFBd0MsQ0FBQyxDQUFwRDtBQUNBLFdBQUlBLE9BQU9xTixRQUFQLEtBQW9CQSxRQUF4QixFQUFrQztBQUNoQ3JOLGdCQUFPcU4sUUFBUCxHQUFrQkEsUUFBbEI7QUFDRDtBQUNGLE1BTEQsTUFLTztBQUNMLFdBQUkxckIsV0FBVzhoQyxTQUFTempCLE1BQVQsQ0FBWCxFQUE2QjdpQixLQUE3QixDQUFKLEVBQXlDO0FBQ3ZDLGFBQUlvUSxHQUFHMDJCLGFBQUgsS0FBcUJ6dUMsQ0FBekIsRUFBNEI7QUFDMUIrWCxjQUFHMDJCLGFBQUgsR0FBbUJ6dUMsQ0FBbkI7QUFDRDtBQUNEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsT0FBSSxDQUFDd3VDLFVBQUwsRUFBaUI7QUFDZnoyQixRQUFHMDJCLGFBQUgsR0FBbUIsQ0FBQyxDQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU1IsUUFBVCxDQUFtQnpqQixNQUFuQixFQUEyQjtBQUN6QixVQUFPLFlBQVlBLE1BQVosR0FDSEEsT0FBTzRhLE1BREosR0FFSDVhLE9BQU83aUIsS0FGWDtBQUdEOztBQUVELFVBQVN3bUMsa0JBQVQsQ0FBNkI1dUMsQ0FBN0IsRUFBZ0M7QUFDOUJBLEtBQUVxVixNQUFGLENBQVM0d0IsU0FBVCxHQUFxQixJQUFyQjtBQUNEOztBQUVELFVBQVMwSSxnQkFBVCxDQUEyQjN1QyxDQUEzQixFQUE4QjtBQUM1QjtBQUNBLE9BQUksQ0FBQ0EsRUFBRXFWLE1BQUYsQ0FBUzR3QixTQUFkLEVBQXlCO0FBQUU7QUFBUTtBQUNuQ2ptQyxLQUFFcVYsTUFBRixDQUFTNHdCLFNBQVQsR0FBcUIsS0FBckI7QUFDQW9JLFdBQVFydUMsRUFBRXFWLE1BQVYsRUFBa0IsT0FBbEI7QUFDRDs7QUFFRCxVQUFTZzVCLE9BQVQsQ0FBa0I3MUIsRUFBbEIsRUFBc0JtQixJQUF0QixFQUE0QjtBQUMxQixPQUFJM1osSUFBSTZCLFNBQVNzdEMsV0FBVCxDQUFxQixZQUFyQixDQUFSO0FBQ0FudkMsS0FBRW92QyxTQUFGLENBQVl6MUIsSUFBWixFQUFrQixJQUFsQixFQUF3QixJQUF4QjtBQUNBbkIsTUFBRzYyQixhQUFILENBQWlCcnZDLENBQWpCO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQSxVQUFTc3ZDLFVBQVQsQ0FBcUJod0IsS0FBckIsRUFBNEI7QUFDMUIsVUFBT0EsTUFBTWYsaUJBQU4sS0FBNEIsQ0FBQ2UsTUFBTXRaLElBQVAsSUFBZSxDQUFDc1osTUFBTXRaLElBQU4sQ0FBV3kxQixVQUF2RCxJQUNINlQsV0FBV2h3QixNQUFNZixpQkFBTixDQUF3Qm1ILE1BQW5DLENBREcsR0FFSHBHLEtBRko7QUFHRDs7QUFFRCxLQUFJK3RCLE9BQU87QUFDVHp0QyxTQUFNLFNBQVNBLElBQVQsQ0FBZTRZLEVBQWYsRUFBbUJxWixHQUFuQixFQUF3QnZTLEtBQXhCLEVBQStCO0FBQ25DLFNBQUlsWCxRQUFReXBCLElBQUl6cEIsS0FBaEI7O0FBRUFrWCxhQUFRZ3dCLFdBQVdod0IsS0FBWCxDQUFSO0FBQ0EsU0FBSWl3QixnQkFBZ0Jqd0IsTUFBTXRaLElBQU4sSUFBY3NaLE1BQU10WixJQUFOLENBQVd5MUIsVUFBN0M7QUFDQSxTQUFJK1Qsa0JBQWtCaDNCLEdBQUdpM0Isa0JBQUgsR0FDcEJqM0IsR0FBR291QixLQUFILENBQVM4SSxPQUFULEtBQXFCLE1BQXJCLEdBQThCLEVBQTlCLEdBQW1DbDNCLEdBQUdvdUIsS0FBSCxDQUFTOEksT0FEOUM7QUFFQSxTQUFJdG5DLFNBQVNtbkMsYUFBYixFQUE0QjtBQUMxQmp3QixhQUFNdFosSUFBTixDQUFXcW5DLElBQVgsR0FBa0IsSUFBbEI7QUFDQTdCLGFBQU1sc0IsS0FBTixFQUFhLFlBQVk7QUFDdkI5RyxZQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUJGLGVBQW5CO0FBQ0QsUUFGRDtBQUdELE1BTEQsTUFLTztBQUNMaDNCLFVBQUdvdUIsS0FBSCxDQUFTOEksT0FBVCxHQUFtQnRuQyxRQUFRb25DLGVBQVIsR0FBMEIsTUFBN0M7QUFDRDtBQUNGLElBaEJROztBQWtCVGg2QixXQUFRLFNBQVNBLE1BQVQsQ0FBaUJnRCxFQUFqQixFQUFxQnFaLEdBQXJCLEVBQTBCdlMsS0FBMUIsRUFBaUM7QUFDdkMsU0FBSWxYLFFBQVF5cEIsSUFBSXpwQixLQUFoQjtBQUNBLFNBQUkwaEIsV0FBVytILElBQUkvSCxRQUFuQjs7QUFFQTtBQUNBLFNBQUkxaEIsVUFBVTBoQixRQUFkLEVBQXdCO0FBQUU7QUFBUTtBQUNsQ3hLLGFBQVFnd0IsV0FBV2h3QixLQUFYLENBQVI7QUFDQSxTQUFJaXdCLGdCQUFnQmp3QixNQUFNdFosSUFBTixJQUFjc1osTUFBTXRaLElBQU4sQ0FBV3kxQixVQUE3QztBQUNBLFNBQUk4VCxhQUFKLEVBQW1CO0FBQ2pCandCLGFBQU10WixJQUFOLENBQVdxbkMsSUFBWCxHQUFrQixJQUFsQjtBQUNBLFdBQUlqbEMsS0FBSixFQUFXO0FBQ1RvakMsZUFBTWxzQixLQUFOLEVBQWEsWUFBWTtBQUN2QjlHLGNBQUdvdUIsS0FBSCxDQUFTOEksT0FBVCxHQUFtQmwzQixHQUFHaTNCLGtCQUF0QjtBQUNELFVBRkQ7QUFHRCxRQUpELE1BSU87QUFDTGhDLGVBQU1udUIsS0FBTixFQUFhLFlBQVk7QUFDdkI5RyxjQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUIsTUFBbkI7QUFDRCxVQUZEO0FBR0Q7QUFDRixNQVhELE1BV087QUFDTGwzQixVQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUJ0bkMsUUFBUW9RLEdBQUdpM0Isa0JBQVgsR0FBZ0MsTUFBbkQ7QUFDRDtBQUNGLElBeENROztBQTBDVEUsV0FBUSxTQUFTQSxNQUFULENBQ05uM0IsRUFETSxFQUVOKzFCLE9BRk0sRUFHTmp2QixLQUhNLEVBSU4wTyxRQUpNLEVBS042USxTQUxNLEVBTU47QUFDQSxTQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZHJtQixVQUFHb3VCLEtBQUgsQ0FBUzhJLE9BQVQsR0FBbUJsM0IsR0FBR2kzQixrQkFBdEI7QUFDRDtBQUNGO0FBcERRLEVBQVg7O0FBdURBLEtBQUlHLHFCQUFxQjtBQUN2QnBoQixVQUFPOGYsT0FEZ0I7QUFFdkJqQixTQUFNQTtBQUZpQixFQUF6Qjs7QUFLQTs7QUFFQTtBQUNBOztBQUVBLEtBQUl3QyxrQkFBa0I7QUFDcEI3dUMsU0FBTW1JLE1BRGM7QUFFcEJnakMsV0FBUXp3QixPQUZZO0FBR3BCK3NCLFFBQUsvc0IsT0FIZTtBQUlwQm8wQixTQUFNM21DLE1BSmM7QUFLcEJ3USxTQUFNeFEsTUFMYztBQU1wQncvQixlQUFZeC9CLE1BTlE7QUFPcEIyL0IsZUFBWTMvQixNQVBRO0FBUXBCeS9CLGlCQUFjei9CLE1BUk07QUFTcEI0L0IsaUJBQWM1L0IsTUFUTTtBQVVwQjAvQixxQkFBa0IxL0IsTUFWRTtBQVdwQjYvQixxQkFBa0I3L0IsTUFYRTtBQVlwQnlpQyxnQkFBYXppQyxNQVpPO0FBYXBCMmlDLHNCQUFtQjNpQyxNQWJDO0FBY3BCMGlDLGtCQUFlMWlDLE1BZEs7QUFlcEJtakMsYUFBVSxDQUFDZixNQUFELEVBQVNwaUMsTUFBVCxFQUFpQjlCLE1BQWpCO0FBZlUsRUFBdEI7O0FBa0JBO0FBQ0E7QUFDQSxVQUFTMG9DLFlBQVQsQ0FBdUJ6d0IsS0FBdkIsRUFBOEI7QUFDNUIsT0FBSTB3QixjQUFjMXdCLFNBQVNBLE1BQU1uQixnQkFBakM7QUFDQSxPQUFJNnhCLGVBQWVBLFlBQVlqOUIsSUFBWixDQUFpQnZDLE9BQWpCLENBQXlCa1UsUUFBNUMsRUFBc0Q7QUFDcEQsWUFBT3FyQixhQUFhbHRCLHVCQUF1Qm10QixZQUFZanlCLFFBQW5DLENBQWIsQ0FBUDtBQUNELElBRkQsTUFFTztBQUNMLFlBQU91QixLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTMndCLHFCQUFULENBQWdDdHVCLElBQWhDLEVBQXNDO0FBQ3BDLE9BQUkzYixPQUFPLEVBQVg7QUFDQSxPQUFJd0ssVUFBVW1SLEtBQUtqUixRQUFuQjtBQUNBO0FBQ0EsUUFBSyxJQUFJcEcsR0FBVCxJQUFnQmtHLFFBQVFpSSxTQUF4QixFQUFtQztBQUNqQ3pTLFVBQUtzRSxHQUFMLElBQVlxWCxLQUFLclgsR0FBTCxDQUFaO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsT0FBSTJZLFlBQVl6UyxRQUFRMFMsZ0JBQXhCO0FBQ0EsUUFBSyxJQUFJZ3RCLEtBQVQsSUFBa0JqdEIsU0FBbEIsRUFBNkI7QUFDM0JqZCxVQUFLNkUsU0FBU3FsQyxLQUFULENBQUwsSUFBd0JqdEIsVUFBVWl0QixLQUFWLENBQXhCO0FBQ0Q7QUFDRCxVQUFPbHFDLElBQVA7QUFDRDs7QUFFRCxVQUFTbXFDLFdBQVQsQ0FBc0JoakIsQ0FBdEIsRUFBeUJpakIsUUFBekIsRUFBbUM7QUFDakMsT0FBSSxpQkFBaUJ6Z0MsSUFBakIsQ0FBc0J5Z0MsU0FBU3R6QixHQUEvQixDQUFKLEVBQXlDO0FBQ3ZDLFlBQU9xUSxFQUFFLFlBQUYsRUFBZ0I7QUFDckJ2VCxjQUFPdzJCLFNBQVNqeUIsZ0JBQVQsQ0FBMEIxRjtBQURaLE1BQWhCLENBQVA7QUFHRDtBQUNGOztBQUVELFVBQVM0M0IsbUJBQVQsQ0FBOEIvd0IsS0FBOUIsRUFBcUM7QUFDbkMsVUFBUUEsUUFBUUEsTUFBTTVHLE1BQXRCLEVBQStCO0FBQzdCLFNBQUk0RyxNQUFNdFosSUFBTixDQUFXeTFCLFVBQWYsRUFBMkI7QUFDekIsY0FBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVM2VSxXQUFULENBQXNCMzNCLEtBQXRCLEVBQTZCNDNCLFFBQTdCLEVBQXVDO0FBQ3JDLFVBQU9BLFNBQVNqbUMsR0FBVCxLQUFpQnFPLE1BQU1yTyxHQUF2QixJQUE4QmltQyxTQUFTenpCLEdBQVQsS0FBaUJuRSxNQUFNbUUsR0FBNUQ7QUFDRDs7QUFFRCxVQUFTaUMsa0JBQVQsQ0FBNkJJLElBQTdCLEVBQW1DO0FBQ2pDLFVBQU9BLEtBQUtSLFNBQUwsSUFBa0JRLEtBQUtmLFlBQTlCO0FBQ0Q7O0FBRUQsS0FBSW95QixhQUFhO0FBQ2Z4dkMsU0FBTSxZQURTO0FBRWY0WSxVQUFPaTJCLGVBRlE7QUFHZm5yQixhQUFVLElBSEs7O0FBS2YvRyxXQUFRLFNBQVNBLE1BQVQsQ0FBaUJ3UCxDQUFqQixFQUFvQjtBQUMxQixTQUFJdkosU0FBUyxJQUFiOztBQUVBLFNBQUk3RixXQUFXLEtBQUtyTixRQUFMLENBQWNzVyxlQUE3QjtBQUNBLFNBQUksQ0FBQ2pKLFFBQUwsRUFBZTtBQUNiO0FBQ0Q7O0FBRUQ7QUFDQUEsZ0JBQVdBLFNBQVN0VyxNQUFULENBQWdCLFVBQVV1RCxDQUFWLEVBQWE7QUFBRSxjQUFPQSxFQUFFOFIsR0FBRixJQUFTaUMsbUJBQW1CL1QsQ0FBbkIsQ0FBaEI7QUFBd0MsTUFBdkUsQ0FBWDtBQUNBO0FBQ0EsU0FBSSxDQUFDK1MsU0FBU3JkLE1BQWQsRUFBc0I7QUFDcEI7QUFDRDs7QUFFRDtBQUNBLFNBQUlxTixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM4UCxTQUFTcmQsTUFBVCxHQUFrQixDQUEvRCxFQUFrRTtBQUNoRW1QLFlBQ0UsNERBQ0EsK0JBRkYsRUFHRSxLQUFLbUIsT0FIUDtBQUtEOztBQUVELFNBQUk4K0IsT0FBTyxLQUFLQSxJQUFoQjs7QUFFQTtBQUNBLFNBQUkvaEMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0Y2aEMsSUFERSxJQUNNQSxTQUFTLFFBRGYsSUFDMkJBLFNBQVMsUUFEeEMsRUFFRTtBQUNBamdDLFlBQ0UsZ0NBQWdDaWdDLElBRGxDLEVBRUUsS0FBSzkrQixPQUZQO0FBSUQ7O0FBRUQsU0FBSW8vQixXQUFXcnlCLFNBQVMsQ0FBVCxDQUFmOztBQUVBO0FBQ0E7QUFDQSxTQUFJc3lCLG9CQUFvQixLQUFLcnFCLE1BQXpCLENBQUosRUFBc0M7QUFDcEMsY0FBT29xQixRQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQUl6M0IsUUFBUW8zQixhQUFhSyxRQUFiLENBQVo7QUFDQTtBQUNBLFNBQUksQ0FBQ3ozQixLQUFMLEVBQVk7QUFDVixjQUFPeTNCLFFBQVA7QUFDRDs7QUFFRCxTQUFJLEtBQUtLLFFBQVQsRUFBbUI7QUFDakIsY0FBT04sWUFBWWhqQixDQUFaLEVBQWVpakIsUUFBZixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsU0FBSS9xQyxLQUFLLGtCQUFtQixLQUFLb2hCLElBQXhCLEdBQWdDLEdBQXpDO0FBQ0E5TixXQUFNck8sR0FBTixHQUFZcU8sTUFBTXJPLEdBQU4sSUFBYSxJQUFiLEdBQ1JxTyxNQUFNZ0csU0FBTixHQUNFdFosS0FBSyxTQURQLEdBRUVBLEtBQUtzVCxNQUFNbUUsR0FITCxHQUlSM1UsWUFBWXdRLE1BQU1yTyxHQUFsQixJQUNHbkIsT0FBT3dQLE1BQU1yTyxHQUFiLEVBQWtCbkksT0FBbEIsQ0FBMEJrRCxFQUExQixNQUFrQyxDQUFsQyxHQUFzQ3NULE1BQU1yTyxHQUE1QyxHQUFrRGpGLEtBQUtzVCxNQUFNck8sR0FEaEUsR0FFRXFPLE1BQU1yTyxHQU5aOztBQVFBLFNBQUl0RSxPQUFPLENBQUMyUyxNQUFNM1MsSUFBTixLQUFlMlMsTUFBTTNTLElBQU4sR0FBYSxFQUE1QixDQUFELEVBQWtDeTFCLFVBQWxDLEdBQStDd1Usc0JBQXNCLElBQXRCLENBQTFEO0FBQ0EsU0FBSVMsY0FBYyxLQUFLaHJCLE1BQXZCO0FBQ0EsU0FBSTZxQixXQUFXUixhQUFhVyxXQUFiLENBQWY7O0FBRUE7QUFDQTtBQUNBLFNBQUkvM0IsTUFBTTNTLElBQU4sQ0FBV3lVLFVBQVgsSUFBeUI5QixNQUFNM1MsSUFBTixDQUFXeVUsVUFBWCxDQUFzQnMwQixJQUF0QixDQUEyQixVQUFVcG9DLENBQVYsRUFBYTtBQUFFLGNBQU9BLEVBQUUzRixJQUFGLEtBQVcsTUFBbEI7QUFBMkIsTUFBckUsQ0FBN0IsRUFBcUc7QUFDbkcyWCxhQUFNM1MsSUFBTixDQUFXcW5DLElBQVgsR0FBa0IsSUFBbEI7QUFDRDs7QUFFRCxTQUNFa0QsWUFDQUEsU0FBU3ZxQyxJQURULElBRUEsQ0FBQ3NxQyxZQUFZMzNCLEtBQVosRUFBbUI0M0IsUUFBbkIsQ0FGRCxJQUdBLENBQUN4eEIsbUJBQW1Cd3hCLFFBQW5CLENBSkgsRUFLRTtBQUNBO0FBQ0E7QUFDQSxXQUFJblEsVUFBVW1RLGFBQWFBLFNBQVN2cUMsSUFBVCxDQUFjeTFCLFVBQWQsR0FBMkIzdkIsT0FBTyxFQUFQLEVBQVc5RixJQUFYLENBQXhDLENBQWQ7QUFDQTtBQUNBLFdBQUk4cEMsU0FBUyxRQUFiLEVBQXVCO0FBQ3JCO0FBQ0EsY0FBS1csUUFBTCxHQUFnQixJQUFoQjtBQUNBandCLHdCQUFlNGYsT0FBZixFQUF3QixZQUF4QixFQUFzQyxZQUFZO0FBQ2hEeGMsa0JBQU82c0IsUUFBUCxHQUFrQixLQUFsQjtBQUNBN3NCLGtCQUFPcEIsWUFBUDtBQUNELFVBSEQ7QUFJQSxnQkFBTzJ0QixZQUFZaGpCLENBQVosRUFBZWlqQixRQUFmLENBQVA7QUFDRCxRQVJELE1BUU8sSUFBSU4sU0FBUyxRQUFiLEVBQXVCO0FBQzVCLGFBQUkvd0IsbUJBQW1CcEcsS0FBbkIsQ0FBSixFQUErQjtBQUM3QixrQkFBTyszQixXQUFQO0FBQ0Q7QUFDRCxhQUFJQyxZQUFKO0FBQ0EsYUFBSTVDLGVBQWUsU0FBZkEsWUFBZSxHQUFZO0FBQUU0QztBQUFpQixVQUFsRDtBQUNBbndCLHdCQUFleGEsSUFBZixFQUFxQixZQUFyQixFQUFtQytuQyxZQUFuQztBQUNBdnRCLHdCQUFleGEsSUFBZixFQUFxQixnQkFBckIsRUFBdUMrbkMsWUFBdkM7QUFDQXZ0Qix3QkFBZTRmLE9BQWYsRUFBd0IsWUFBeEIsRUFBc0MsVUFBVXFOLEtBQVYsRUFBaUI7QUFBRWtELDBCQUFlbEQsS0FBZjtBQUF1QixVQUFoRjtBQUNEO0FBQ0Y7O0FBRUQsWUFBTzJDLFFBQVA7QUFDRDtBQWxIYyxFQUFqQjs7QUFxSEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJeDJCLFFBQVE5TixPQUFPO0FBQ2pCZ1IsUUFBSzNULE1BRFk7QUFFakJ5bkMsY0FBV3puQztBQUZNLEVBQVAsRUFHVDBtQyxlQUhTLENBQVo7O0FBS0EsUUFBT2oyQixNQUFNazJCLElBQWI7O0FBRUEsS0FBSWUsa0JBQWtCO0FBQ3BCajNCLFVBQU9BLEtBRGE7O0FBR3BCK0QsV0FBUSxTQUFTQSxNQUFULENBQWlCd1AsQ0FBakIsRUFBb0I7QUFDMUIsU0FBSXJRLE1BQU0sS0FBS0EsR0FBTCxJQUFZLEtBQUtrSixNQUFMLENBQVloZ0IsSUFBWixDQUFpQjhXLEdBQTdCLElBQW9DLE1BQTlDO0FBQ0EsU0FBSXJULE1BQU1wQyxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLFNBQUlvbkMsZUFBZSxLQUFLQSxZQUFMLEdBQW9CLEtBQUsveUIsUUFBNUM7QUFDQSxTQUFJZ3pCLGNBQWMsS0FBS3ZwQixNQUFMLENBQVkxTCxPQUFaLElBQXVCLEVBQXpDO0FBQ0EsU0FBSWlDLFdBQVcsS0FBS0EsUUFBTCxHQUFnQixFQUEvQjtBQUNBLFNBQUlpekIsaUJBQWlCZixzQkFBc0IsSUFBdEIsQ0FBckI7O0FBRUEsVUFBSyxJQUFJeHZDLElBQUksQ0FBYixFQUFnQkEsSUFBSXN3QyxZQUFZcndDLE1BQWhDLEVBQXdDRCxHQUF4QyxFQUE2QztBQUMzQyxXQUFJdUssSUFBSStsQyxZQUFZdHdDLENBQVosQ0FBUjtBQUNBLFdBQUl1SyxFQUFFOFIsR0FBTixFQUFXO0FBQ1QsYUFBSTlSLEVBQUVWLEdBQUYsSUFBUyxJQUFULElBQWlCbkIsT0FBTzZCLEVBQUVWLEdBQVQsRUFBY25JLE9BQWQsQ0FBc0IsU0FBdEIsTUFBcUMsQ0FBMUQsRUFBNkQ7QUFDM0Q0YixvQkFBUzFNLElBQVQsQ0FBY3JHLENBQWQ7QUFDQXZCLGVBQUl1QixFQUFFVixHQUFOLElBQWFVLENBQWIsQ0FDQyxDQUFDQSxFQUFFaEYsSUFBRixLQUFXZ0YsRUFBRWhGLElBQUYsR0FBUyxFQUFwQixDQUFELEVBQTBCeTFCLFVBQTFCLEdBQXVDdVYsY0FBdkM7QUFDRixVQUpELE1BSU8sSUFBSWpqQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDaEQsZUFBSXFFLE9BQU90SCxFQUFFbVQsZ0JBQWI7QUFDQSxlQUFJbmQsT0FBT3NSLE9BQVFBLEtBQUtTLElBQUwsQ0FBVXZDLE9BQVYsQ0FBa0J4UCxJQUFsQixJQUEwQnNSLEtBQUt3SyxHQUEvQixJQUFzQyxFQUE5QyxHQUFvRDlSLEVBQUU4UixHQUFqRTtBQUNBak4sZ0JBQU0saURBQWlEN08sSUFBakQsR0FBd0QsR0FBOUQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBSTh2QyxZQUFKLEVBQWtCO0FBQ2hCLFdBQUlHLE9BQU8sRUFBWDtBQUNBLFdBQUlDLFVBQVUsRUFBZDtBQUNBLFlBQUssSUFBSXJ0QixNQUFNLENBQWYsRUFBa0JBLE1BQU1pdEIsYUFBYXB3QyxNQUFyQyxFQUE2Q21qQixLQUE3QyxFQUFvRDtBQUNsRCxhQUFJc3RCLE1BQU1MLGFBQWFqdEIsR0FBYixDQUFWO0FBQ0FzdEIsYUFBSW5yQyxJQUFKLENBQVN5MUIsVUFBVCxHQUFzQnVWLGNBQXRCO0FBQ0FHLGFBQUluckMsSUFBSixDQUFTb3JDLEdBQVQsR0FBZUQsSUFBSWx6QixHQUFKLENBQVFvekIscUJBQVIsRUFBZjtBQUNBLGFBQUk1bkMsSUFBSTBuQyxJQUFJN21DLEdBQVIsQ0FBSixFQUFrQjtBQUNoQjJtQyxnQkFBSzUvQixJQUFMLENBQVU4L0IsR0FBVjtBQUNELFVBRkQsTUFFTztBQUNMRCxtQkFBUTcvQixJQUFSLENBQWE4L0IsR0FBYjtBQUNEO0FBQ0Y7QUFDRCxZQUFLRixJQUFMLEdBQVk5akIsRUFBRXJRLEdBQUYsRUFBTyxJQUFQLEVBQWFtMEIsSUFBYixDQUFaO0FBQ0EsWUFBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRUQsWUFBTy9qQixFQUFFclEsR0FBRixFQUFPLElBQVAsRUFBYWlCLFFBQWIsQ0FBUDtBQUNELElBNUNtQjs7QUE4Q3BCdXpCLGlCQUFjLFNBQVNBLFlBQVQsR0FBeUI7QUFDckM7QUFDQSxVQUFLMXJCLFNBQUwsQ0FDRSxLQUFLRixNQURQLEVBRUUsS0FBS3VyQixJQUZQLEVBR0UsS0FIRixFQUdTO0FBQ1AsU0FKRixDQUlPO0FBSlA7QUFNQSxVQUFLdnJCLE1BQUwsR0FBYyxLQUFLdXJCLElBQW5CO0FBQ0QsSUF2RG1COztBQXlEcEJNLFlBQVMsU0FBU0EsT0FBVCxHQUFvQjtBQUMzQixTQUFJeHpCLFdBQVcsS0FBSyt5QixZQUFwQjtBQUNBLFNBQUlGLFlBQVksS0FBS0EsU0FBTCxJQUFtQixDQUFDLEtBQUs1dkMsSUFBTCxJQUFhLEdBQWQsSUFBcUIsT0FBeEQ7QUFDQSxTQUFJLENBQUMrYyxTQUFTcmQsTUFBVixJQUFvQixDQUFDLEtBQUs4d0MsT0FBTCxDQUFhenpCLFNBQVMsQ0FBVCxFQUFZRSxHQUF6QixFQUE4QjJ5QixTQUE5QixDQUF6QixFQUFtRTtBQUNqRTtBQUNEOztBQUVEO0FBQ0E7QUFDQTd5QixjQUFTeFcsT0FBVCxDQUFpQmtxQyxjQUFqQjtBQUNBMXpCLGNBQVN4VyxPQUFULENBQWlCbXFDLGNBQWpCO0FBQ0EzekIsY0FBU3hXLE9BQVQsQ0FBaUJvcUMsZ0JBQWpCOztBQUVBO0FBQ0EsU0FBSUMsT0FBTy92QyxTQUFTK3ZDLElBQXBCO0FBQ0EsU0FBSUMsSUFBSUQsS0FBS0UsWUFBYixDQWYyQixDQWVBOztBQUUzQi96QixjQUFTeFcsT0FBVCxDQUFpQixVQUFVeUQsQ0FBVixFQUFhO0FBQzVCLFdBQUlBLEVBQUVoRixJQUFGLENBQU8rckMsS0FBWCxFQUFrQjtBQUNoQixhQUFJdjVCLEtBQUt4TixFQUFFaVQsR0FBWDtBQUNBLGFBQUlxdEIsSUFBSTl5QixHQUFHb3VCLEtBQVg7QUFDQW1ELDRCQUFtQnZ4QixFQUFuQixFQUF1Qm80QixTQUF2QjtBQUNBdEYsV0FBRTBHLFNBQUYsR0FBYzFHLEVBQUUyRyxlQUFGLEdBQW9CM0csRUFBRTRHLGtCQUFGLEdBQXVCLEVBQXpEO0FBQ0ExNUIsWUFBR2hHLGdCQUFILENBQW9CNjJCLGtCQUFwQixFQUF3Qzd3QixHQUFHMjVCLE9BQUgsR0FBYSxTQUFTNzlCLEVBQVQsQ0FBYXRVLENBQWIsRUFBZ0I7QUFDbkUsZUFBSSxDQUFDQSxDQUFELElBQU0sYUFBYTJQLElBQWIsQ0FBa0IzUCxFQUFFb3lDLFlBQXBCLENBQVYsRUFBNkM7QUFDM0M1NUIsZ0JBQUdpdEIsbUJBQUgsQ0FBdUI0RCxrQkFBdkIsRUFBMkMvMEIsRUFBM0M7QUFDQWtFLGdCQUFHMjVCLE9BQUgsR0FBYSxJQUFiO0FBQ0FsSSxtQ0FBc0J6eEIsRUFBdEIsRUFBMEJvNEIsU0FBMUI7QUFDRDtBQUNGLFVBTkQ7QUFPRDtBQUNGLE1BZEQ7QUFlRCxJQXpGbUI7O0FBMkZwQi8yQixZQUFTO0FBQ1AyM0IsY0FBUyxTQUFTQSxPQUFULENBQWtCaDVCLEVBQWxCLEVBQXNCbzRCLFNBQXRCLEVBQWlDO0FBQ3hDO0FBQ0EsV0FBSSxDQUFDM0gsYUFBTCxFQUFvQjtBQUNsQixnQkFBTyxLQUFQO0FBQ0Q7QUFDRDtBQUNBLFdBQUksS0FBS29KLFFBQVQsRUFBbUI7QUFDakIsZ0JBQU8sS0FBS0EsUUFBWjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUlDLFFBQVE5NUIsR0FBRys1QixTQUFILEVBQVo7QUFDQSxXQUFJLzVCLEdBQUcrbkIsa0JBQVAsRUFBMkI7QUFDekIvbkIsWUFBRytuQixrQkFBSCxDQUFzQmg1QixPQUF0QixDQUE4QixVQUFVODRCLEdBQVYsRUFBZTtBQUFFZ0ksdUJBQVlpSyxLQUFaLEVBQW1CalMsR0FBbkI7QUFBMEIsVUFBekU7QUFDRDtBQUNENkgsZ0JBQVNvSyxLQUFULEVBQWdCMUIsU0FBaEI7QUFDQTBCLGFBQU0xTCxLQUFOLENBQVk4SSxPQUFaLEdBQXNCLE1BQXRCO0FBQ0EsWUFBS2xxQixHQUFMLENBQVMyVCxXQUFULENBQXFCbVosS0FBckI7QUFDQSxXQUFJOXNDLE9BQU8ya0Msa0JBQWtCbUksS0FBbEIsQ0FBWDtBQUNBLFlBQUs5c0IsR0FBTCxDQUFTMFQsV0FBVCxDQUFxQm9aLEtBQXJCO0FBQ0EsY0FBUSxLQUFLRCxRQUFMLEdBQWdCN3NDLEtBQUswbEMsWUFBN0I7QUFDRDtBQXpCTTtBQTNGVyxFQUF0Qjs7QUF3SEEsVUFBU3VHLGNBQVQsQ0FBeUJ6bUMsQ0FBekIsRUFBNEI7QUFDMUI7QUFDQSxPQUFJQSxFQUFFaVQsR0FBRixDQUFNazBCLE9BQVYsRUFBbUI7QUFDakJubkMsT0FBRWlULEdBQUYsQ0FBTWswQixPQUFOO0FBQ0Q7QUFDRDtBQUNBLE9BQUlubkMsRUFBRWlULEdBQUYsQ0FBTTB0QixRQUFWLEVBQW9CO0FBQ2xCM2dDLE9BQUVpVCxHQUFGLENBQU0wdEIsUUFBTjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUytGLGNBQVQsQ0FBeUIxbUMsQ0FBekIsRUFBNEI7QUFDMUJBLEtBQUVoRixJQUFGLENBQU93c0MsTUFBUCxHQUFnQnhuQyxFQUFFaVQsR0FBRixDQUFNb3pCLHFCQUFOLEVBQWhCO0FBQ0Q7O0FBRUQsVUFBU00sZ0JBQVQsQ0FBMkIzbUMsQ0FBM0IsRUFBOEI7QUFDNUIsT0FBSXluQyxTQUFTem5DLEVBQUVoRixJQUFGLENBQU9vckMsR0FBcEI7QUFDQSxPQUFJb0IsU0FBU3huQyxFQUFFaEYsSUFBRixDQUFPd3NDLE1BQXBCO0FBQ0EsT0FBSUUsS0FBS0QsT0FBT0UsSUFBUCxHQUFjSCxPQUFPRyxJQUE5QjtBQUNBLE9BQUlDLEtBQUtILE9BQU9JLEdBQVAsR0FBYUwsT0FBT0ssR0FBN0I7QUFDQSxPQUFJSCxNQUFNRSxFQUFWLEVBQWM7QUFDWjVuQyxPQUFFaEYsSUFBRixDQUFPK3JDLEtBQVAsR0FBZSxJQUFmO0FBQ0EsU0FBSXpHLElBQUl0Z0MsRUFBRWlULEdBQUYsQ0FBTTJvQixLQUFkO0FBQ0EwRSxPQUFFMEcsU0FBRixHQUFjMUcsRUFBRTJHLGVBQUYsR0FBb0IsZUFBZVMsRUFBZixHQUFvQixLQUFwQixHQUE0QkUsRUFBNUIsR0FBaUMsS0FBbkU7QUFDQXRILE9BQUU0RyxrQkFBRixHQUF1QixJQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsS0FBSVkscUJBQXFCO0FBQ3ZCdEMsZUFBWUEsVUFEVztBQUV2Qkssb0JBQWlCQTtBQUZNLEVBQXpCOztBQUtBOztBQUVBO0FBQ0E5YyxPQUFNcG1CLE1BQU4sQ0FBYWtCLFdBQWIsR0FBMkJBLFdBQTNCO0FBQ0FrbEIsT0FBTXBtQixNQUFOLENBQWFhLGFBQWIsR0FBNkJBLGFBQTdCO0FBQ0F1bEIsT0FBTXBtQixNQUFOLENBQWFjLGNBQWIsR0FBOEJBLGNBQTlCO0FBQ0FzbEIsT0FBTXBtQixNQUFOLENBQWFnQixlQUFiLEdBQStCQSxlQUEvQjtBQUNBb2xCLE9BQU1wbUIsTUFBTixDQUFhZSxnQkFBYixHQUFnQ0EsZ0JBQWhDOztBQUVBO0FBQ0E1QyxRQUFPaW9CLE1BQU12akIsT0FBTixDQUFjaUssVUFBckIsRUFBaUNtMUIsa0JBQWpDO0FBQ0E5akMsUUFBT2lvQixNQUFNdmpCLE9BQU4sQ0FBYzBKLFVBQXJCLEVBQWlDNDRCLGtCQUFqQzs7QUFFQTtBQUNBL2UsT0FBTWowQixTQUFOLENBQWdCOGxCLFNBQWhCLEdBQTRCcFUsWUFBWTBzQixLQUFaLEdBQW9CNytCLElBQWhEOztBQUVBO0FBQ0EwMEIsT0FBTWowQixTQUFOLENBQWdCOHRCLE1BQWhCLEdBQXlCLFVBQ3ZCcFYsRUFEdUIsRUFFdkI2TSxTQUZ1QixFQUd2QjtBQUNBN00sUUFBS0EsTUFBTWhILFNBQU4sR0FBa0J2TSxNQUFNdVQsRUFBTixDQUFsQixHQUE4Qm5ZLFNBQW5DO0FBQ0EsVUFBT2dtQixlQUFlLElBQWYsRUFBcUI3TixFQUFyQixFQUF5QjZNLFNBQXpCLENBQVA7QUFDRCxFQU5EOztBQVFBO0FBQ0E7QUFDQXhSLFlBQVcsWUFBWTtBQUNyQixPQUFJbEcsT0FBT08sUUFBWCxFQUFxQjtBQUNuQixTQUFJQSxRQUFKLEVBQWM7QUFDWkEsZ0JBQVM2YSxJQUFULENBQWMsTUFBZCxFQUFzQmdMLEtBQXRCO0FBQ0QsTUFGRCxNQUVPLElBQUlobUIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDaUUsUUFBN0MsRUFBdUQ7QUFDNUQ5UixlQUFRQSxRQUFRb0YsSUFBUixHQUFlLE1BQWYsR0FBd0IsS0FBaEMsRUFDRSwrRUFDQSx1Q0FGRjtBQUlEO0FBQ0Y7QUFDRCxPQUFJdUksUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0ZOLE9BQU9HLGFBQVAsS0FBeUIsS0FEdkIsSUFFRjBELFNBRkUsSUFFVyxPQUFPcFIsT0FBUCxLQUFtQixXQUZsQyxFQUdFO0FBQ0FBLGFBQVFBLFFBQVFvRixJQUFSLEdBQWUsTUFBZixHQUF3QixLQUFoQyxFQUNFLCtDQUNBLHVFQURBLEdBRUEsMERBSEY7QUFLRDtBQUNGLEVBckJELEVBcUJHLENBckJIOztBQXVCQTs7QUFFQTtBQUNBLFVBQVN1dEMsWUFBVCxDQUF1QkMsT0FBdkIsRUFBZ0NDLE9BQWhDLEVBQXlDO0FBQ3ZDLE9BQUlDLE1BQU1yeEMsU0FBU3VyQixhQUFULENBQXVCLEtBQXZCLENBQVY7QUFDQThsQixPQUFJQyxTQUFKLEdBQWdCLGNBQWNILE9BQWQsR0FBd0IsTUFBeEM7QUFDQSxVQUFPRSxJQUFJQyxTQUFKLENBQWNoeEMsT0FBZCxDQUFzQjh3QyxPQUF0QixJQUFpQyxDQUF4QztBQUNEOztBQUVEO0FBQ0E7QUFDQSxLQUFJRyx1QkFBdUI1aEMsWUFBWXVoQyxhQUFhLElBQWIsRUFBbUIsT0FBbkIsQ0FBWixHQUEwQyxLQUFyRTs7QUFFQTs7QUFFQSxLQUFJTSxlQUFlLHVCQUFuQjtBQUNBLEtBQUlDLGdCQUFnQix3QkFBcEI7O0FBRUEsS0FBSUMsYUFBYWhwQyxPQUFPLFVBQVVpcEMsVUFBVixFQUFzQjtBQUM1QyxPQUFJQyxPQUFPRCxXQUFXLENBQVgsRUFBYzFvQyxPQUFkLENBQXNCd29DLGFBQXRCLEVBQXFDLE1BQXJDLENBQVg7QUFDQSxPQUFJSSxRQUFRRixXQUFXLENBQVgsRUFBYzFvQyxPQUFkLENBQXNCd29DLGFBQXRCLEVBQXFDLE1BQXJDLENBQVo7QUFDQSxVQUFPLElBQUlsZSxNQUFKLENBQVdxZSxPQUFPLGVBQVAsR0FBeUJDLEtBQXBDLEVBQTJDLEdBQTNDLENBQVA7QUFDRCxFQUpnQixDQUFqQjs7QUFNQSxVQUFTQyxTQUFULENBQ0UzMUIsSUFERixFQUVFdzFCLFVBRkYsRUFHRTtBQUNBLE9BQUlJLFFBQVFKLGFBQWFELFdBQVdDLFVBQVgsQ0FBYixHQUFzQ0gsWUFBbEQ7QUFDQSxPQUFJLENBQUNPLE1BQU1qa0MsSUFBTixDQUFXcU8sSUFBWCxDQUFMLEVBQXVCO0FBQ3JCO0FBQ0Q7QUFDRCxPQUFJNjFCLFNBQVMsRUFBYjtBQUNBLE9BQUlDLFlBQVlGLE1BQU1FLFNBQU4sR0FBa0IsQ0FBbEM7QUFDQSxPQUFJaGpDLEtBQUosRUFBV3JNLEtBQVg7QUFDQSxVQUFRcU0sUUFBUThpQyxNQUFNeHhDLElBQU4sQ0FBVzRiLElBQVgsQ0FBaEIsRUFBbUM7QUFDakN2WixhQUFRcU0sTUFBTXJNLEtBQWQ7QUFDQTtBQUNBLFNBQUlBLFFBQVFxdkMsU0FBWixFQUF1QjtBQUNyQkQsY0FBT3hpQyxJQUFQLENBQVlwSSxLQUFLQyxTQUFMLENBQWU4VSxLQUFLM2IsS0FBTCxDQUFXeXhDLFNBQVgsRUFBc0JydkMsS0FBdEIsQ0FBZixDQUFaO0FBQ0Q7QUFDRDtBQUNBLFNBQUltOEIsTUFBTUQsYUFBYTd2QixNQUFNLENBQU4sRUFBU3l3QixJQUFULEVBQWIsQ0FBVjtBQUNBc1MsWUFBT3hpQyxJQUFQLENBQWEsUUFBUXV2QixHQUFSLEdBQWMsR0FBM0I7QUFDQWtULGlCQUFZcnZDLFFBQVFxTSxNQUFNLENBQU4sRUFBU3BRLE1BQTdCO0FBQ0Q7QUFDRCxPQUFJb3pDLFlBQVk5MUIsS0FBS3RkLE1BQXJCLEVBQTZCO0FBQzNCbXpDLFlBQU94aUMsSUFBUCxDQUFZcEksS0FBS0MsU0FBTCxDQUFlOFUsS0FBSzNiLEtBQUwsQ0FBV3l4QyxTQUFYLENBQWYsQ0FBWjtBQUNEO0FBQ0QsVUFBT0QsT0FBT2xuQyxJQUFQLENBQVksR0FBWixDQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsVUFBU29uQyxhQUFULENBQXdCdjdCLEVBQXhCLEVBQTRCaEksT0FBNUIsRUFBcUM7QUFDbkMsT0FBSVgsT0FBT1csUUFBUVgsSUFBUixJQUFnQjZ4QixRQUEzQjtBQUNBLE9BQUlwSyxjQUFjb0wsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE9BQXJCLENBQWxCO0FBQ0EsT0FBSXpLLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5Q3FwQixXQUE3QyxFQUEwRDtBQUN4RCxTQUFJNU8sYUFBYWlyQixVQUFVcmMsV0FBVixFQUF1QjltQixRQUFRZ2pDLFVBQS9CLENBQWpCO0FBQ0EsU0FBSTlxQixVQUFKLEVBQWdCO0FBQ2Q3WSxZQUNFLGFBQWF5bkIsV0FBYixHQUEyQixNQUEzQixHQUNBLG9EQURBLEdBRUEsMERBRkEsR0FHQSw2REFKRjtBQU1EO0FBQ0Y7QUFDRCxPQUFJQSxXQUFKLEVBQWlCO0FBQ2Y5ZSxRQUFHOGUsV0FBSCxHQUFpQnJ1QixLQUFLQyxTQUFMLENBQWVvdUIsV0FBZixDQUFqQjtBQUNEO0FBQ0QsT0FBSTBjLGVBQWV6UixlQUFlL3BCLEVBQWYsRUFBbUIsT0FBbkIsRUFBNEIsS0FBNUIsQ0FBa0MsZUFBbEMsQ0FBbkI7QUFDQSxPQUFJdzdCLFlBQUosRUFBa0I7QUFDaEJ4N0IsUUFBR3c3QixZQUFILEdBQWtCQSxZQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBU0MsT0FBVCxDQUFrQno3QixFQUFsQixFQUFzQjtBQUNwQixPQUFJeFMsT0FBTyxFQUFYO0FBQ0EsT0FBSXdTLEdBQUc4ZSxXQUFQLEVBQW9CO0FBQ2xCdHhCLGFBQVEsaUJBQWtCd1MsR0FBRzhlLFdBQXJCLEdBQW9DLEdBQTVDO0FBQ0Q7QUFDRCxPQUFJOWUsR0FBR3c3QixZQUFQLEVBQXFCO0FBQ25CaHVDLGFBQVEsV0FBWXdTLEdBQUd3N0IsWUFBZixHQUErQixHQUF2QztBQUNEO0FBQ0QsVUFBT2h1QyxJQUFQO0FBQ0Q7O0FBRUQsS0FBSWt1QyxVQUFVO0FBQ1p4bkMsZUFBWSxDQUFDLGFBQUQsQ0FEQTtBQUVacW5DLGtCQUFlQSxhQUZIO0FBR1pFLFlBQVNBO0FBSEcsRUFBZDs7QUFNQTs7QUFFQSxVQUFTRSxlQUFULENBQTBCMzdCLEVBQTFCLEVBQThCaEksT0FBOUIsRUFBdUM7QUFDckMsT0FBSVgsT0FBT1csUUFBUVgsSUFBUixJQUFnQjZ4QixRQUEzQjtBQUNBLE9BQUlvRixjQUFjcEUsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE9BQXJCLENBQWxCO0FBQ0EsT0FBSXN1QixXQUFKLEVBQWlCO0FBQ2Y7QUFDQSxTQUFJLzRCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJeWEsYUFBYWlyQixVQUFVN00sV0FBVixFQUF1QnQyQixRQUFRZ2pDLFVBQS9CLENBQWpCO0FBQ0EsV0FBSTlxQixVQUFKLEVBQWdCO0FBQ2Q3WSxjQUNFLGFBQWFpM0IsV0FBYixHQUEyQixNQUEzQixHQUNBLG9EQURBLEdBRUEsMERBRkEsR0FHQSw2REFKRjtBQU1EO0FBQ0Y7QUFDRHR1QixRQUFHc3VCLFdBQUgsR0FBaUI3OUIsS0FBS0MsU0FBTCxDQUFlcTlCLGVBQWVPLFdBQWYsQ0FBZixDQUFqQjtBQUNEOztBQUVELE9BQUlzTixlQUFlN1IsZUFBZS9wQixFQUFmLEVBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLENBQWtDLGVBQWxDLENBQW5CO0FBQ0EsT0FBSTQ3QixZQUFKLEVBQWtCO0FBQ2hCNTdCLFFBQUc0N0IsWUFBSCxHQUFrQkEsWUFBbEI7QUFDRDtBQUNGOztBQUVELFVBQVNDLFNBQVQsQ0FBb0I3N0IsRUFBcEIsRUFBd0I7QUFDdEIsT0FBSXhTLE9BQU8sRUFBWDtBQUNBLE9BQUl3UyxHQUFHc3VCLFdBQVAsRUFBb0I7QUFDbEI5Z0MsYUFBUSxpQkFBa0J3UyxHQUFHc3VCLFdBQXJCLEdBQW9DLEdBQTVDO0FBQ0Q7QUFDRCxPQUFJdHVCLEdBQUc0N0IsWUFBUCxFQUFxQjtBQUNuQnB1QyxhQUFRLFlBQWF3UyxHQUFHNDdCLFlBQWhCLEdBQWdDLElBQXhDO0FBQ0Q7QUFDRCxVQUFPcHVDLElBQVA7QUFDRDs7QUFFRCxLQUFJc3VDLFVBQVU7QUFDWjVuQyxlQUFZLENBQUMsYUFBRCxDQURBO0FBRVpxbkMsa0JBQWVJLGVBRkg7QUFHWkYsWUFBU0k7QUFIRyxFQUFkOztBQU1BLEtBQUlFLFlBQVksQ0FDZEwsT0FEYyxFQUVkSSxPQUZjLENBQWhCOztBQUtBOztBQUVBLFVBQVN0MkIsSUFBVCxDQUFleEYsRUFBZixFQUFtQjRtQixHQUFuQixFQUF3QjtBQUN0QixPQUFJQSxJQUFJaDNCLEtBQVIsRUFBZTtBQUNidzVCLGFBQVFwcEIsRUFBUixFQUFZLGFBQVosRUFBNEIsUUFBUzRtQixJQUFJaDNCLEtBQWIsR0FBc0IsR0FBbEQ7QUFDRDtBQUNGOztBQUVEOztBQUVBLFVBQVNvc0MsSUFBVCxDQUFlaDhCLEVBQWYsRUFBbUI0bUIsR0FBbkIsRUFBd0I7QUFDdEIsT0FBSUEsSUFBSWgzQixLQUFSLEVBQWU7QUFDYnc1QixhQUFRcHBCLEVBQVIsRUFBWSxXQUFaLEVBQTBCLFFBQVM0bUIsSUFBSWgzQixLQUFiLEdBQXNCLEdBQWhEO0FBQ0Q7QUFDRjs7QUFFRCxLQUFJcXNDLGVBQWU7QUFDakJqbUIsVUFBT0EsS0FEVTtBQUVqQnhRLFNBQU1BLElBRlc7QUFHakJ3MkIsU0FBTUE7QUFIVyxFQUFuQjs7QUFNQTs7QUFFQSxLQUFJRSxhQUFhcHJDLFFBQ2YsOERBQ0Esa0NBRmUsQ0FBakI7O0FBS0E7QUFDQTtBQUNBLEtBQUlxckMsbUJBQW1CcnJDLFFBQ3JCLHlEQURxQixDQUF2Qjs7QUFJQTtBQUNBO0FBQ0EsS0FBSXNyQyxtQkFBbUJ0ckMsUUFDckIsd0VBQ0Esa0VBREEsR0FFQSx1RUFGQSxHQUdBLDJFQUhBLEdBSUEsZ0JBTHFCLENBQXZCOztBQVFBOztBQUVBLEtBQUl1ckMsY0FBYztBQUNoQkMsZUFBWSxJQURJO0FBRWhCeG9DLFlBQVNpb0MsU0FGTztBQUdoQjk1QixlQUFZZzZCLFlBSEk7QUFJaEJ2YyxhQUFVQSxRQUpNO0FBS2hCd2MsZUFBWUEsVUFMSTtBQU1oQjdsQyxnQkFBYUEsV0FORztBQU9oQjhsQyxxQkFBa0JBLGdCQVBGO0FBUWhCbm1DLGtCQUFlQSxhQVJDO0FBU2hCRyxvQkFBaUJBLGVBVEQ7QUFVaEJqQyxlQUFZTCxjQUFja29DLFNBQWQ7QUFWSSxFQUFsQjs7QUFhQTs7QUFFQSxLQUFJUSxPQUFKOztBQUVBLEtBQUlDLEtBQUs7QUFDUEMsV0FBUSxTQUFTQSxNQUFULENBQWlCVCxJQUFqQixFQUF1QjtBQUM3Qk8sZUFBVUEsV0FBV2x6QyxTQUFTdXJCLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBckI7QUFDQTJuQixhQUFRNUIsU0FBUixHQUFvQnFCLElBQXBCO0FBQ0EsWUFBT08sUUFBUXpiLFdBQWY7QUFDRDtBQUxNLEVBQVQ7O0FBUUE7Ozs7QUFJQTs7Ozs7OztBQU9BO0FBQ0EsS0FBSTRiLHVCQUF1QixnQkFBM0I7QUFDQSxLQUFJQyxtQkFBbUIsT0FBdkI7QUFDQSxLQUFJQyxtQkFBbUI7QUFDckI7QUFDQSxjQUFhcm9CLE1BRlE7QUFHckI7QUFDQSxjQUFhQSxNQUpRO0FBS3JCO0FBQ0Esa0JBQWlCQSxNQU5JLENBQXZCO0FBUUEsS0FBSXNvQixZQUFZLElBQUlqZ0IsTUFBSixDQUNkLFVBQVU4ZixxQkFBcUJub0IsTUFBL0IsR0FDQSxVQURBLEdBQ2Fvb0IsaUJBQWlCcG9CLE1BRDlCLEdBQ3VDLEdBRHZDLEdBRUEsU0FGQSxHQUVZcW9CLGlCQUFpQnpvQyxJQUFqQixDQUFzQixHQUF0QixDQUZaLEdBRXlDLEtBSDNCLENBQWhCOztBQU1BO0FBQ0E7QUFDQSxLQUFJMm9DLFNBQVMsdUJBQWI7QUFDQSxLQUFJQyxlQUFlLFNBQVNELE1BQVQsR0FBa0IsT0FBbEIsR0FBNEJBLE1BQTVCLEdBQXFDLEdBQXhEO0FBQ0EsS0FBSUUsZUFBZSxJQUFJcGdCLE1BQUosQ0FBVyxPQUFPbWdCLFlBQWxCLENBQW5CO0FBQ0EsS0FBSUUsZ0JBQWdCLFlBQXBCO0FBQ0EsS0FBSXo0QixTQUFTLElBQUlvWSxNQUFKLENBQVcsVUFBVW1nQixZQUFWLEdBQXlCLFFBQXBDLENBQWI7QUFDQSxLQUFJRyxVQUFVLG9CQUFkO0FBQ0EsS0FBSUMsVUFBVSxPQUFkO0FBQ0EsS0FBSUMscUJBQXFCLE9BQXpCOztBQUVBLEtBQUlDLDRCQUE0QixLQUFoQztBQUNBLEtBQUkvcUMsT0FBSixDQUFZLFFBQVosRUFBc0IsVUFBVTBCLENBQVYsRUFBYXNwQyxDQUFiLEVBQWdCO0FBQ3BDRCwrQkFBNEJDLE1BQU0sRUFBbEM7QUFDRCxFQUZEOztBQUlBO0FBQ0EsS0FBSUMscUJBQXFCenNDLFFBQVEsdUJBQVIsRUFBaUMsSUFBakMsQ0FBekI7QUFDQSxLQUFJMHNDLFVBQVUsRUFBZDs7QUFFQSxLQUFJQyxjQUFjO0FBQ2hCLFdBQVEsR0FEUTtBQUVoQixXQUFRLEdBRlE7QUFHaEIsYUFBVSxHQUhNO0FBSWhCLFlBQVMsR0FKTztBQUtoQixZQUFTO0FBTE8sRUFBbEI7QUFPQSxLQUFJQyxjQUFjLHVCQUFsQjtBQUNBLEtBQUlDLDBCQUEwQiwyQkFBOUI7O0FBRUE7QUFDQSxLQUFJQyxxQkFBcUI5c0MsUUFBUSxjQUFSLEVBQXdCLElBQXhCLENBQXpCO0FBQ0EsS0FBSStzQywyQkFBMkIsU0FBM0JBLHdCQUEyQixDQUFVdjVCLEdBQVYsRUFBZTAzQixJQUFmLEVBQXFCO0FBQUUsVUFBTzEzQixPQUFPczVCLG1CQUFtQnQ1QixHQUFuQixDQUFQLElBQWtDMDNCLEtBQUssQ0FBTCxNQUFZLElBQXJEO0FBQTRELEVBQWxIOztBQUVBLFVBQVM4QixVQUFULENBQXFCbHVDLEtBQXJCLEVBQTRCZ3JDLG9CQUE1QixFQUFrRDtBQUNoRCxPQUFJbUQsS0FBS25ELHVCQUF1QitDLHVCQUF2QixHQUFpREQsV0FBMUQ7QUFDQSxVQUFPOXRDLE1BQU0wQyxPQUFOLENBQWN5ckMsRUFBZCxFQUFrQixVQUFVemxDLEtBQVYsRUFBaUI7QUFBRSxZQUFPbWxDLFlBQVlubEMsS0FBWixDQUFQO0FBQTRCLElBQWpFLENBQVA7QUFDRDs7QUFFRCxVQUFTMGxDLFNBQVQsQ0FBb0JoQyxJQUFwQixFQUEwQmhrQyxPQUExQixFQUFtQztBQUNqQyxPQUFJaW1DLFFBQVEsRUFBWjtBQUNBLE9BQUkzQixhQUFhdGtDLFFBQVFza0MsVUFBekI7QUFDQSxPQUFJNEIsZ0JBQWdCbG1DLFFBQVFra0MsVUFBUixJQUFzQnZvQyxFQUExQztBQUNBLE9BQUl3cUMsc0JBQXNCbm1DLFFBQVFta0MsZ0JBQVIsSUFBNEJ4b0MsRUFBdEQ7QUFDQSxPQUFJMUgsUUFBUSxDQUFaO0FBQ0EsT0FBSTBNLElBQUosRUFBVXlsQyxPQUFWO0FBQ0EsVUFBT3BDLElBQVAsRUFBYTtBQUNYcmpDLFlBQU9xakMsSUFBUDtBQUNBO0FBQ0EsU0FBSSxDQUFDb0MsT0FBRCxJQUFZLENBQUNiLG1CQUFtQmEsT0FBbkIsQ0FBakIsRUFBOEM7QUFDNUMsV0FBSUMsVUFBVXJDLEtBQUtyeUMsT0FBTCxDQUFhLEdBQWIsQ0FBZDtBQUNBLFdBQUkwMEMsWUFBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNBLGFBQUlsQixRQUFRaG1DLElBQVIsQ0FBYTZrQyxJQUFiLENBQUosRUFBd0I7QUFDdEIsZUFBSXNDLGFBQWF0QyxLQUFLcnlDLE9BQUwsQ0FBYSxLQUFiLENBQWpCOztBQUVBLGVBQUkyMEMsY0FBYyxDQUFsQixFQUFxQjtBQUNuQixpQkFBSXRtQyxRQUFRdW1DLGlCQUFaLEVBQStCO0FBQzdCdm1DLHVCQUFRbWxDLE9BQVIsQ0FBZ0JuQixLQUFLdlEsU0FBTCxDQUFlLENBQWYsRUFBa0I2UyxVQUFsQixDQUFoQjtBQUNEO0FBQ0RFLHFCQUFRRixhQUFhLENBQXJCO0FBQ0E7QUFDRDtBQUNGOztBQUVEO0FBQ0EsYUFBSWxCLG1CQUFtQmptQyxJQUFuQixDQUF3QjZrQyxJQUF4QixDQUFKLEVBQW1DO0FBQ2pDLGVBQUl5QyxpQkFBaUJ6QyxLQUFLcnlDLE9BQUwsQ0FBYSxJQUFiLENBQXJCOztBQUVBLGVBQUk4MEMsa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCRCxxQkFBUUMsaUJBQWlCLENBQXpCO0FBQ0E7QUFDRDtBQUNGOztBQUVEO0FBQ0EsYUFBSUMsZUFBZTFDLEtBQUsxakMsS0FBTCxDQUFXNGtDLE9BQVgsQ0FBbkI7QUFDQSxhQUFJd0IsWUFBSixFQUFrQjtBQUNoQkYsbUJBQVFFLGFBQWEsQ0FBYixFQUFnQngyQyxNQUF4QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxhQUFJeTJDLGNBQWMzQyxLQUFLMWpDLEtBQUwsQ0FBV2tNLE1BQVgsQ0FBbEI7QUFDQSxhQUFJbTZCLFdBQUosRUFBaUI7QUFDZixlQUFJQyxXQUFXM3lDLEtBQWY7QUFDQXV5QyxtQkFBUUcsWUFBWSxDQUFaLEVBQWV6MkMsTUFBdkI7QUFDQTIyQyx1QkFBWUYsWUFBWSxDQUFaLENBQVosRUFBNEJDLFFBQTVCLEVBQXNDM3lDLEtBQXRDO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLGFBQUk2eUMsZ0JBQWdCQyxlQUFwQjtBQUNBLGFBQUlELGFBQUosRUFBbUI7QUFDakJFLDBCQUFlRixhQUFmO0FBQ0EsZUFBSWpCLHlCQUF5Qk8sT0FBekIsRUFBa0NwQyxJQUFsQyxDQUFKLEVBQTZDO0FBQzNDd0MscUJBQVEsQ0FBUjtBQUNEO0FBQ0Q7QUFDRDtBQUNGOztBQUVELFdBQUloNUIsT0FBUSxLQUFLLENBQWpCO0FBQUEsV0FBcUJ5NUIsT0FBUSxLQUFLLENBQWxDO0FBQUEsV0FBc0M1VCxPQUFRLEtBQUssQ0FBbkQ7QUFDQSxXQUFJZ1QsV0FBVyxDQUFmLEVBQWtCO0FBQ2hCWSxnQkFBT2pELEtBQUtueUMsS0FBTCxDQUFXdzBDLE9BQVgsQ0FBUDtBQUNBLGdCQUNFLENBQUM3NUIsT0FBT3JOLElBQVAsQ0FBWThuQyxJQUFaLENBQUQsSUFDQSxDQUFDakMsYUFBYTdsQyxJQUFiLENBQWtCOG5DLElBQWxCLENBREQsSUFFQSxDQUFDOUIsUUFBUWhtQyxJQUFSLENBQWE4bkMsSUFBYixDQUZELElBR0EsQ0FBQzdCLG1CQUFtQmptQyxJQUFuQixDQUF3QjhuQyxJQUF4QixDQUpILEVBS0U7QUFDQTtBQUNBNVQsa0JBQU80VCxLQUFLdDFDLE9BQUwsQ0FBYSxHQUFiLEVBQWtCLENBQWxCLENBQVA7QUFDQSxlQUFJMGhDLE9BQU8sQ0FBWCxFQUFjO0FBQUU7QUFBTztBQUN2QmdULHNCQUFXaFQsSUFBWDtBQUNBNFQsa0JBQU9qRCxLQUFLbnlDLEtBQUwsQ0FBV3cwQyxPQUFYLENBQVA7QUFDRDtBQUNENzRCLGdCQUFPdzJCLEtBQUt2USxTQUFMLENBQWUsQ0FBZixFQUFrQjRTLE9BQWxCLENBQVA7QUFDQUcsaUJBQVFILE9BQVI7QUFDRDs7QUFFRCxXQUFJQSxVQUFVLENBQWQsRUFBaUI7QUFDZjc0QixnQkFBT3cyQixJQUFQO0FBQ0FBLGdCQUFPLEVBQVA7QUFDRDs7QUFFRCxXQUFJaGtDLFFBQVFrbkMsS0FBUixJQUFpQjE1QixJQUFyQixFQUEyQjtBQUN6QnhOLGlCQUFRa25DLEtBQVIsQ0FBYzE1QixJQUFkO0FBQ0Q7QUFDRixNQWhGRCxNQWdGTztBQUNMLFdBQUkyNUIsZUFBZSxDQUFuQjtBQUNBLFdBQUlDLGFBQWFoQixRQUFRL3NDLFdBQVIsRUFBakI7QUFDQSxXQUFJZ3VDLGVBQWU3QixRQUFRNEIsVUFBUixNQUF3QjVCLFFBQVE0QixVQUFSLElBQXNCLElBQUl4aUIsTUFBSixDQUFXLG9CQUFvQndpQixVQUFwQixHQUFpQyxTQUE1QyxFQUF1RCxHQUF2RCxDQUE5QyxDQUFuQjtBQUNBLFdBQUlFLFNBQVN0RCxLQUFLMXBDLE9BQUwsQ0FBYStzQyxZQUFiLEVBQTJCLFVBQVVFLEdBQVYsRUFBZS81QixJQUFmLEVBQXFCaEIsTUFBckIsRUFBNkI7QUFDbkUyNkIsd0JBQWUzNkIsT0FBT3RjLE1BQXRCO0FBQ0EsYUFBSSxDQUFDcTFDLG1CQUFtQjZCLFVBQW5CLENBQUQsSUFBbUNBLGVBQWUsVUFBdEQsRUFBa0U7QUFDaEU1NUIsa0JBQU9BLEtBQ0psVCxPQURJLENBQ0ksb0JBREosRUFDMEIsSUFEMUIsRUFFSkEsT0FGSSxDQUVJLDJCQUZKLEVBRWlDLElBRmpDLENBQVA7QUFHRDtBQUNELGFBQUl1ckMseUJBQXlCdUIsVUFBekIsRUFBcUM1NUIsSUFBckMsQ0FBSixFQUFnRDtBQUM5Q0Esa0JBQU9BLEtBQUszYixLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0Q7QUFDRCxhQUFJbU8sUUFBUWtuQyxLQUFaLEVBQW1CO0FBQ2pCbG5DLG1CQUFRa25DLEtBQVIsQ0FBYzE1QixJQUFkO0FBQ0Q7QUFDRCxnQkFBTyxFQUFQO0FBQ0QsUUFkWSxDQUFiO0FBZUF2WixnQkFBUyt2QyxLQUFLOXpDLE1BQUwsR0FBY28zQyxPQUFPcDNDLE1BQTlCO0FBQ0E4ekMsY0FBT3NELE1BQVA7QUFDQVQsbUJBQVlPLFVBQVosRUFBd0JuekMsUUFBUWt6QyxZQUFoQyxFQUE4Q2x6QyxLQUE5QztBQUNEOztBQUVELFNBQUkrdkMsU0FBU3JqQyxJQUFiLEVBQW1CO0FBQ2pCWCxlQUFRa25DLEtBQVIsSUFBaUJsbkMsUUFBUWtuQyxLQUFSLENBQWNsRCxJQUFkLENBQWpCO0FBQ0EsV0FBSXptQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQ3dvQyxNQUFNLzFDLE1BQWhELElBQTBEOFAsUUFBUVgsSUFBdEUsRUFBNEU7QUFDMUVXLGlCQUFRWCxJQUFSLENBQWMsNkNBQTZDMmtDLElBQTdDLEdBQW9ELElBQWxFO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTZDOztBQUVBLFlBQVNMLE9BQVQsQ0FBa0JwdUMsQ0FBbEIsRUFBcUI7QUFDbkJuRSxjQUFTbUUsQ0FBVDtBQUNBNHJDLFlBQU9BLEtBQUt2USxTQUFMLENBQWVyN0IsQ0FBZixDQUFQO0FBQ0Q7O0FBRUQsWUFBUzJ1QyxhQUFULEdBQTBCO0FBQ3hCLFNBQUk1ckMsUUFBUTZvQyxLQUFLMWpDLEtBQUwsQ0FBVzBrQyxZQUFYLENBQVo7QUFDQSxTQUFJN3BDLEtBQUosRUFBVztBQUNULFdBQUltRixRQUFRO0FBQ1YybkIsa0JBQVM5c0IsTUFBTSxDQUFOLENBREM7QUFFVm1WLGdCQUFPLEVBRkc7QUFHVm5WLGdCQUFPbEg7QUFIRyxRQUFaO0FBS0F1eUMsZUFBUXJyQyxNQUFNLENBQU4sRUFBU2pMLE1BQWpCO0FBQ0EsV0FBSTRwQyxHQUFKLEVBQVM1VCxJQUFUO0FBQ0EsY0FBTyxFQUFFNFQsTUFBTWtLLEtBQUsxakMsS0FBTCxDQUFXMmtDLGFBQVgsQ0FBUixNQUF1Qy9lLE9BQU84ZCxLQUFLMWpDLEtBQUwsQ0FBV3VrQyxTQUFYLENBQTlDLENBQVAsRUFBNkU7QUFDM0UyQixpQkFBUXRnQixLQUFLLENBQUwsRUFBUWgyQixNQUFoQjtBQUNBb1EsZUFBTWdRLEtBQU4sQ0FBWXpQLElBQVosQ0FBaUJxbEIsSUFBakI7QUFDRDtBQUNELFdBQUk0VCxHQUFKLEVBQVM7QUFDUHg1QixlQUFNa25DLFVBQU4sR0FBbUIxTixJQUFJLENBQUosQ0FBbkI7QUFDQTBNLGlCQUFRMU0sSUFBSSxDQUFKLEVBQU81cEMsTUFBZjtBQUNBb1EsZUFBTXc1QixHQUFOLEdBQVk3bEMsS0FBWjtBQUNBLGdCQUFPcU0sS0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFTMG1DLGNBQVQsQ0FBeUIxbUMsS0FBekIsRUFBZ0M7QUFDOUIsU0FBSTJuQixVQUFVM25CLE1BQU0ybkIsT0FBcEI7QUFDQSxTQUFJdWYsYUFBYWxuQyxNQUFNa25DLFVBQXZCOztBQUVBLFNBQUlsRCxVQUFKLEVBQWdCO0FBQ2QsV0FBSThCLFlBQVksR0FBWixJQUFtQmhDLGlCQUFpQm5jLE9BQWpCLENBQXZCLEVBQWtEO0FBQ2hENGUscUJBQVlULE9BQVo7QUFDRDtBQUNELFdBQUlELG9CQUFvQmxlLE9BQXBCLEtBQWdDbWUsWUFBWW5lLE9BQWhELEVBQXlEO0FBQ3ZENGUscUJBQVk1ZSxPQUFaO0FBQ0Q7QUFDRjs7QUFFRCxTQUFJd2YsUUFBUXZCLGNBQWNqZSxPQUFkLEtBQTBCLENBQUMsQ0FBQ3VmLFVBQXhDOztBQUVBLFNBQUl4c0MsSUFBSXNGLE1BQU1nUSxLQUFOLENBQVlwZ0IsTUFBcEI7QUFDQSxTQUFJb2dCLFFBQVEsSUFBSWpWLEtBQUosQ0FBVUwsQ0FBVixDQUFaO0FBQ0EsVUFBSyxJQUFJL0ssSUFBSSxDQUFiLEVBQWdCQSxJQUFJK0ssQ0FBcEIsRUFBdUIvSyxHQUF2QixFQUE0QjtBQUMxQixXQUFJeVYsT0FBT3BGLE1BQU1nUSxLQUFOLENBQVlyZ0IsQ0FBWixDQUFYO0FBQ0E7QUFDQSxXQUFJbzFDLDZCQUE2QjMvQixLQUFLLENBQUwsRUFBUS9ULE9BQVIsQ0FBZ0IsSUFBaEIsTUFBMEIsQ0FBQyxDQUE1RCxFQUErRDtBQUM3RCxhQUFJK1QsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxrQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDdkMsYUFBSUEsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxrQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDdkMsYUFBSUEsS0FBSyxDQUFMLE1BQVksRUFBaEIsRUFBb0I7QUFBRSxrQkFBT0EsS0FBSyxDQUFMLENBQVA7QUFBaUI7QUFDeEM7QUFDRCxXQUFJOU4sUUFBUThOLEtBQUssQ0FBTCxLQUFXQSxLQUFLLENBQUwsQ0FBWCxJQUFzQkEsS0FBSyxDQUFMLENBQXRCLElBQWlDLEVBQTdDO0FBQ0E0SyxhQUFNcmdCLENBQU4sSUFBVztBQUNUTyxlQUFNa1YsS0FBSyxDQUFMLENBREc7QUFFVDlOLGdCQUFPa3VDLFdBQ0xsdUMsS0FESyxFQUVMb0ksUUFBUTRpQyxvQkFGSDtBQUZFLFFBQVg7QUFPRDs7QUFFRCxTQUFJLENBQUM2RSxLQUFMLEVBQVk7QUFDVnhCLGFBQU1wbEMsSUFBTixDQUFXLEVBQUV5TCxLQUFLMmIsT0FBUCxFQUFnQnlmLGVBQWV6ZixRQUFRNXVCLFdBQVIsRUFBL0IsRUFBc0RpWCxPQUFPQSxLQUE3RCxFQUFYO0FBQ0E4MUIsaUJBQVVuZSxPQUFWO0FBQ0Q7O0FBRUQsU0FBSWpvQixRQUFRN0UsS0FBWixFQUFtQjtBQUNqQjZFLGVBQVE3RSxLQUFSLENBQWM4c0IsT0FBZCxFQUF1QjNYLEtBQXZCLEVBQThCbTNCLEtBQTlCLEVBQXFDbm5DLE1BQU1uRixLQUEzQyxFQUFrRG1GLE1BQU13NUIsR0FBeEQ7QUFDRDtBQUNGOztBQUVELFlBQVMrTSxXQUFULENBQXNCNWUsT0FBdEIsRUFBK0I5c0IsS0FBL0IsRUFBc0MyK0IsR0FBdEMsRUFBMkM7QUFDekMsU0FBSThHLEdBQUosRUFBUytHLGlCQUFUO0FBQ0EsU0FBSXhzQyxTQUFTLElBQWIsRUFBbUI7QUFBRUEsZUFBUWxILEtBQVI7QUFBZ0I7QUFDckMsU0FBSTZsQyxPQUFPLElBQVgsRUFBaUI7QUFBRUEsYUFBTTdsQyxLQUFOO0FBQWM7O0FBRWpDLFNBQUlnMEIsT0FBSixFQUFhO0FBQ1gwZiwyQkFBb0IxZixRQUFRNXVCLFdBQVIsRUFBcEI7QUFDRDs7QUFFRDtBQUNBLFNBQUk0dUIsT0FBSixFQUFhO0FBQ1gsWUFBSzJZLE1BQU1xRixNQUFNLzFDLE1BQU4sR0FBZSxDQUExQixFQUE2QjB3QyxPQUFPLENBQXBDLEVBQXVDQSxLQUF2QyxFQUE4QztBQUM1QyxhQUFJcUYsTUFBTXJGLEdBQU4sRUFBVzhHLGFBQVgsS0FBNkJDLGlCQUFqQyxFQUFvRDtBQUNsRDtBQUNEO0FBQ0Y7QUFDRixNQU5ELE1BTU87QUFDTDtBQUNBL0csYUFBTSxDQUFOO0FBQ0Q7O0FBRUQsU0FBSUEsT0FBTyxDQUFYLEVBQWM7QUFDWjtBQUNBLFlBQUssSUFBSTN3QyxJQUFJZzJDLE1BQU0vMUMsTUFBTixHQUFlLENBQTVCLEVBQStCRCxLQUFLMndDLEdBQXBDLEVBQXlDM3dDLEdBQXpDLEVBQThDO0FBQzVDLGFBQUlzTixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsS0FDRHhOLElBQUkyd0MsR0FBSixJQUFXLENBQUMzWSxPQURYLEtBRUZqb0IsUUFBUVgsSUFGVixFQUdFO0FBQ0FXLG1CQUFRWCxJQUFSLENBQ0csVUFBVzRtQyxNQUFNaDJDLENBQU4sRUFBU3FjLEdBQXBCLEdBQTJCLDRCQUQ5QjtBQUdEO0FBQ0QsYUFBSXRNLFFBQVE4NUIsR0FBWixFQUFpQjtBQUNmOTVCLG1CQUFRODVCLEdBQVIsQ0FBWW1NLE1BQU1oMkMsQ0FBTixFQUFTcWMsR0FBckIsRUFBMEJuUixLQUExQixFQUFpQzIrQixHQUFqQztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQW1NLGFBQU0vMUMsTUFBTixHQUFlMHdDLEdBQWY7QUFDQXdGLGlCQUFVeEYsT0FBT3FGLE1BQU1yRixNQUFNLENBQVosRUFBZXQwQixHQUFoQztBQUNELE1BbkJELE1BbUJPLElBQUlxN0Isc0JBQXNCLElBQTFCLEVBQWdDO0FBQ3JDLFdBQUkzbkMsUUFBUTdFLEtBQVosRUFBbUI7QUFDakI2RSxpQkFBUTdFLEtBQVIsQ0FBYzhzQixPQUFkLEVBQXVCLEVBQXZCLEVBQTJCLElBQTNCLEVBQWlDOXNCLEtBQWpDLEVBQXdDMitCLEdBQXhDO0FBQ0Q7QUFDRixNQUpNLE1BSUEsSUFBSTZOLHNCQUFzQixHQUExQixFQUErQjtBQUNwQyxXQUFJM25DLFFBQVE3RSxLQUFaLEVBQW1CO0FBQ2pCNkUsaUJBQVE3RSxLQUFSLENBQWM4c0IsT0FBZCxFQUF1QixFQUF2QixFQUEyQixLQUEzQixFQUFrQzlzQixLQUFsQyxFQUF5QzIrQixHQUF6QztBQUNEO0FBQ0QsV0FBSTk1QixRQUFRODVCLEdBQVosRUFBaUI7QUFDZjk1QixpQkFBUTg1QixHQUFSLENBQVk3UixPQUFaLEVBQXFCOXNCLEtBQXJCLEVBQTRCMitCLEdBQTVCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSThOLE9BQU8sV0FBWDtBQUNBLEtBQUlDLFFBQVEsV0FBWjtBQUNBLEtBQUlDLGFBQWEsMEJBQWpCO0FBQ0EsS0FBSUMsZ0JBQWdCLDRDQUFwQjs7QUFFQSxLQUFJQyxRQUFRLFFBQVo7QUFDQSxLQUFJQyxTQUFTLGFBQWI7QUFDQSxLQUFJQyxhQUFhLFVBQWpCOztBQUVBLEtBQUlDLG1CQUFtQnB1QyxPQUFPeXFDLEdBQUdDLE1BQVYsQ0FBdkI7O0FBRUE7QUFDQSxLQUFJMkQsTUFBSjtBQUNBLEtBQUlwRixVQUFKO0FBQ0EsS0FBSXFGLFVBQUo7QUFDQSxLQUFJQyxhQUFKO0FBQ0EsS0FBSUMsY0FBSjtBQUNBLEtBQUlDLGdCQUFKO0FBQ0EsS0FBSUMsbUJBQUo7QUFDQSxLQUFJQyx1QkFBSjs7QUFFQTs7O0FBR0EsVUFBU0MsS0FBVCxDQUNFN3lCLFFBREYsRUFFRTlWLE9BRkYsRUFHRTtBQUNBb29DLFlBQVNwb0MsUUFBUVgsSUFBUixJQUFnQjZ4QixRQUF6Qjs7QUFFQXNYLHNCQUFtQnhvQyxRQUFRMG5CLFFBQVIsSUFBb0IvckIsRUFBdkM7QUFDQThzQyx5QkFBc0J6b0MsUUFBUTNCLFdBQVIsSUFBdUIxQyxFQUE3QztBQUNBK3NDLDZCQUEwQjFvQyxRQUFRN0IsZUFBUixJQUEyQnhDLEVBQXJEOztBQUVBMHNDLGdCQUFhbFgsb0JBQW9CbnhCLFFBQVFsRSxPQUE1QixFQUFxQyxlQUFyQyxDQUFiO0FBQ0F3c0MsbUJBQWdCblgsb0JBQW9CbnhCLFFBQVFsRSxPQUE1QixFQUFxQyxrQkFBckMsQ0FBaEI7QUFDQXlzQyxvQkFBaUJwWCxvQkFBb0JueEIsUUFBUWxFLE9BQTVCLEVBQXFDLG1CQUFyQyxDQUFqQjs7QUFFQWtuQyxnQkFBYWhqQyxRQUFRZ2pDLFVBQXJCOztBQUVBLE9BQUlpRCxRQUFRLEVBQVo7QUFDQSxPQUFJMkMscUJBQXFCNW9DLFFBQVE0b0Msa0JBQVIsS0FBK0IsS0FBeEQ7QUFDQSxPQUFJcjZDLElBQUo7QUFDQSxPQUFJczZDLGFBQUo7QUFDQSxPQUFJQyxTQUFTLEtBQWI7QUFDQSxPQUFJM2UsUUFBUSxLQUFaO0FBQ0EsT0FBSTRlLFNBQVMsS0FBYjs7QUFFQSxZQUFTQyxRQUFULENBQW1CcnBDLEdBQW5CLEVBQXdCO0FBQ3RCLFNBQUksQ0FBQ29wQyxNQUFMLEVBQWE7QUFDWEEsZ0JBQVMsSUFBVDtBQUNBWCxjQUFPem9DLEdBQVA7QUFDRDtBQUNGOztBQUVELFlBQVNzcEMsTUFBVCxDQUFpQkMsT0FBakIsRUFBMEI7QUFDeEI7QUFDQSxTQUFJQSxRQUFRM2UsR0FBWixFQUFpQjtBQUNmdWUsZ0JBQVMsS0FBVDtBQUNEO0FBQ0QsU0FBSU4saUJBQWlCVSxRQUFRNThCLEdBQXpCLENBQUosRUFBbUM7QUFDakM2ZCxlQUFRLEtBQVI7QUFDRDtBQUNGOztBQUVENmIsYUFBVWx3QixRQUFWLEVBQW9CO0FBQ2xCelcsV0FBTStvQyxNQURZO0FBRWxCOUQsaUJBQVl0a0MsUUFBUXNrQyxVQUZGO0FBR2xCSixpQkFBWWxrQyxRQUFRa2tDLFVBSEY7QUFJbEJDLHVCQUFrQm5rQyxRQUFRbWtDLGdCQUpSO0FBS2xCdkIsMkJBQXNCNWlDLFFBQVE0aUMsb0JBTFo7QUFNbEIyRCx3QkFBbUJ2bUMsUUFBUW1wQyxRQU5UO0FBT2xCaHVDLFlBQU8sU0FBU0EsS0FBVCxDQUFnQm1SLEdBQWhCLEVBQXFCZ0UsS0FBckIsRUFBNEJtM0IsS0FBNUIsRUFBbUM7QUFDeEM7QUFDQTtBQUNBLFdBQUk1NUIsS0FBTWc3QixpQkFBaUJBLGNBQWNoN0IsRUFBaEMsSUFBdUM2NkIsd0JBQXdCcDhCLEdBQXhCLENBQWhEOztBQUVBO0FBQ0E7QUFDQSxXQUFJakwsUUFBUXdNLE9BQU8sS0FBbkIsRUFBMEI7QUFDeEJ5QyxpQkFBUTg0QixjQUFjOTRCLEtBQWQsQ0FBUjtBQUNEOztBQUVELFdBQUk0NEIsVUFBVTtBQUNaLy9CLGVBQU0sQ0FETTtBQUVabUQsY0FBS0EsR0FGTztBQUdaK2xCLG9CQUFXL2hCLEtBSEM7QUFJWjhoQixtQkFBVWlYLGFBQWEvNEIsS0FBYixDQUpFO0FBS1pwSSxpQkFBUTJnQyxhQUxJO0FBTVp0N0IsbUJBQVU7QUFORSxRQUFkO0FBUUEsV0FBSU0sRUFBSixFQUFRO0FBQ05xN0IsaUJBQVFyN0IsRUFBUixHQUFhQSxFQUFiO0FBQ0Q7O0FBRUQsV0FBSXk3QixlQUFlSixPQUFmLEtBQTJCLENBQUNobkMsbUJBQWhDLEVBQXFEO0FBQ25EZ25DLGlCQUFRSyxTQUFSLEdBQW9CLElBQXBCO0FBQ0Foc0MsaUJBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzJxQyxPQUN2Qyx1RUFDQSxzRUFEQSxHQUVBLEdBRkEsR0FFTTk3QixHQUZOLEdBRVksR0FGWixHQUVrQiwrQkFIcUIsQ0FBekM7QUFLRDs7QUFFRDtBQUNBLFlBQUssSUFBSXJjLElBQUksQ0FBYixFQUFnQkEsSUFBSXE0QyxjQUFjcDRDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztBQUM3Q3E0Qyx1QkFBY3I0QyxDQUFkLEVBQWlCaTVDLE9BQWpCLEVBQTBCbHBDLE9BQTFCO0FBQ0Q7O0FBRUQsV0FBSSxDQUFDOG9DLE1BQUwsRUFBYTtBQUNYVSxvQkFBV04sT0FBWDtBQUNBLGFBQUlBLFFBQVEzZSxHQUFaLEVBQWlCO0FBQ2Z1ZSxvQkFBUyxJQUFUO0FBQ0Q7QUFDRjtBQUNELFdBQUlOLGlCQUFpQlUsUUFBUTU4QixHQUF6QixDQUFKLEVBQW1DO0FBQ2pDNmQsaUJBQVEsSUFBUjtBQUNEO0FBQ0QsV0FBSTJlLE1BQUosRUFBWTtBQUNWVyx5QkFBZ0JQLE9BQWhCO0FBQ0QsUUFGRCxNQUVPO0FBQ0xRLG9CQUFXUixPQUFYO0FBQ0FTLG1CQUFVVCxPQUFWO0FBQ0FVLHFCQUFZVixPQUFaO0FBQ0FXLG9CQUFXWCxPQUFYOztBQUVBO0FBQ0E7QUFDQUEsaUJBQVFZLEtBQVIsR0FBZ0IsQ0FBQ1osUUFBUXB2QyxHQUFULElBQWdCLENBQUN3VyxNQUFNcGdCLE1BQXZDOztBQUVBNjVDLG9CQUFXYixPQUFYO0FBQ0FjLHFCQUFZZCxPQUFaO0FBQ0FlLDBCQUFpQmYsT0FBakI7QUFDQSxjQUFLLElBQUk3MUIsTUFBTSxDQUFmLEVBQWtCQSxNQUFNZzFCLFdBQVduNEMsTUFBbkMsRUFBMkNtakIsS0FBM0MsRUFBa0Q7QUFDaERnMUIsc0JBQVdoMUIsR0FBWCxFQUFnQjYxQixPQUFoQixFQUF5QmxwQyxPQUF6QjtBQUNEO0FBQ0RrcUMsc0JBQWFoQixPQUFiO0FBQ0Q7O0FBRUQsZ0JBQVNpQixvQkFBVCxDQUErQm5pQyxFQUEvQixFQUFtQztBQUNqQyxhQUFJekssUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGVBQUl1SyxHQUFHc0UsR0FBSCxLQUFXLE1BQVgsSUFBcUJ0RSxHQUFHc0UsR0FBSCxLQUFXLFVBQXBDLEVBQWdEO0FBQzlDMDhCLHNCQUNFLGlCQUFrQmhoQyxHQUFHc0UsR0FBckIsR0FBNEIsNkNBQTVCLEdBQ0EseUJBRkY7QUFJRDtBQUNELGVBQUl0RSxHQUFHb3FCLFFBQUgsQ0FBWXg0QixjQUFaLENBQTJCLE9BQTNCLENBQUosRUFBeUM7QUFDdkNvdkMsc0JBQ0UsaUVBQ0EsK0JBRkY7QUFJRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxXQUFJLENBQUN6NkMsSUFBTCxFQUFXO0FBQ1RBLGdCQUFPMjZDLE9BQVA7QUFDQWlCLDhCQUFxQjU3QyxJQUFyQjtBQUNELFFBSEQsTUFHTyxJQUFJLENBQUMwM0MsTUFBTS8xQyxNQUFYLEVBQW1CO0FBQ3hCO0FBQ0EsYUFBSTNCLEtBQUs2N0MsRUFBTCxLQUFZbEIsUUFBUW1CLE1BQVIsSUFBa0JuQixRQUFRb0IsSUFBdEMsQ0FBSixFQUFpRDtBQUMvQ0gsZ0NBQXFCakIsT0FBckI7QUFDQXFCLDBCQUFlaDhDLElBQWYsRUFBcUI7QUFDbkI2aEMsa0JBQUs4WSxRQUFRbUIsTUFETTtBQUVuQkcsb0JBQU90QjtBQUZZLFlBQXJCO0FBSUQsVUFORCxNQU1PLElBQUkzckMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ2hEdXJDLG9CQUNFLGlFQUNBLDhDQURBLEdBRUEsc0NBSEY7QUFLRDtBQUNGO0FBQ0QsV0FBSUgsaUJBQWlCLENBQUNLLFFBQVFLLFNBQTlCLEVBQXlDO0FBQ3ZDLGFBQUlMLFFBQVFtQixNQUFSLElBQWtCbkIsUUFBUW9CLElBQTlCLEVBQW9DO0FBQ2xDRywrQkFBb0J2QixPQUFwQixFQUE2QkwsYUFBN0I7QUFDRCxVQUZELE1BRU8sSUFBSUssUUFBUXdCLFNBQVosRUFBdUI7QUFBRTtBQUM5QjdCLHlCQUFjaUIsS0FBZCxHQUFzQixLQUF0QjtBQUNBLGVBQUl0NUMsT0FBTzA0QyxRQUFReUIsVUFBUixJQUFzQixXQUFqQyxDQUE2QyxDQUFDOUIsY0FBY3B5QixXQUFkLEtBQThCb3lCLGNBQWNweUIsV0FBZCxHQUE0QixFQUExRCxDQUFELEVBQWdFam1CLElBQWhFLElBQXdFMDRDLE9BQXhFO0FBQzlDLFVBSE0sTUFHQTtBQUNMTCx5QkFBY3Q3QixRQUFkLENBQXVCMU0sSUFBdkIsQ0FBNEJxb0MsT0FBNUI7QUFDQUEsbUJBQVFoaEMsTUFBUixHQUFpQjJnQyxhQUFqQjtBQUNEO0FBQ0Y7QUFDRCxXQUFJLENBQUNwQixLQUFMLEVBQVk7QUFDVm9CLHlCQUFnQkssT0FBaEI7QUFDQWpELGVBQU1wbEMsSUFBTixDQUFXcW9DLE9BQVg7QUFDRCxRQUhELE1BR087QUFDTEQsZ0JBQU9DLE9BQVA7QUFDRDtBQUNEO0FBQ0EsWUFBSyxJQUFJMEIsTUFBTSxDQUFmLEVBQWtCQSxNQUFNckMsZUFBZXI0QyxNQUF2QyxFQUErQzA2QyxLQUEvQyxFQUFzRDtBQUNwRHJDLHdCQUFlcUMsR0FBZixFQUFvQjFCLE9BQXBCLEVBQTZCbHBDLE9BQTdCO0FBQ0Q7QUFDRixNQXBJaUI7O0FBc0lsQjg1QixVQUFLLFNBQVNBLEdBQVQsR0FBZ0I7QUFDbkI7QUFDQSxXQUFJb1AsVUFBVWpELE1BQU1BLE1BQU0vMUMsTUFBTixHQUFlLENBQXJCLENBQWQ7QUFDQSxXQUFJMjZDLFdBQVczQixRQUFRMzdCLFFBQVIsQ0FBaUIyN0IsUUFBUTM3QixRQUFSLENBQWlCcmQsTUFBakIsR0FBMEIsQ0FBM0MsQ0FBZjtBQUNBLFdBQUkyNkMsWUFBWUEsU0FBUzFoQyxJQUFULEtBQWtCLENBQTlCLElBQW1DMGhDLFNBQVNyOUIsSUFBVCxLQUFrQixHQUFyRCxJQUE0RCxDQUFDMmMsS0FBakUsRUFBd0U7QUFDdEUrZSxpQkFBUTM3QixRQUFSLENBQWlCbEksR0FBakI7QUFDRDtBQUNEO0FBQ0E0Z0MsYUFBTS8xQyxNQUFOLElBQWdCLENBQWhCO0FBQ0EyNEMsdUJBQWdCNUMsTUFBTUEsTUFBTS8xQyxNQUFOLEdBQWUsQ0FBckIsQ0FBaEI7QUFDQSs0QyxjQUFPQyxPQUFQO0FBQ0QsTUFqSmlCOztBQW1KbEJoQyxZQUFPLFNBQVNBLEtBQVQsQ0FBZ0IxNUIsSUFBaEIsRUFBc0I7QUFDM0IsV0FBSSxDQUFDcTdCLGFBQUwsRUFBb0I7QUFDbEIsYUFBSXRyQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsZUFBSStQLFNBQVNzSSxRQUFiLEVBQXVCO0FBQ3JCa3pCLHNCQUNFLG9FQURGO0FBR0QsWUFKRCxNQUlPLElBQUt4N0IsT0FBT0EsS0FBS3VqQixJQUFMLEVBQVosRUFBMEI7QUFDL0JpWSxzQkFDRyxZQUFZeDdCLElBQVosR0FBbUIsMENBRHRCO0FBR0Q7QUFDRjtBQUNEO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsV0FBSW5NLFFBQ0Z3bkMsY0FBY3Y4QixHQUFkLEtBQXNCLFVBRHBCLElBRUZ1OEIsY0FBY3pXLFFBQWQsQ0FBdUJ1TixXQUF2QixLQUF1Q255QixJQUZ6QyxFQUdFO0FBQ0E7QUFDRDtBQUNELFdBQUlELFdBQVdzN0IsY0FBY3Q3QixRQUE3QjtBQUNBQyxjQUFPMmMsU0FBUzNjLEtBQUt1akIsSUFBTCxFQUFULEdBQ0grWixVQUFVakMsYUFBVixJQUEyQnI3QixJQUEzQixHQUFrQzI2QixpQkFBaUIzNkIsSUFBakI7QUFDcEM7QUFGSyxTQUdIbzdCLHNCQUFzQnI3QixTQUFTcmQsTUFBL0IsR0FBd0MsR0FBeEMsR0FBOEMsRUFIbEQ7QUFJQSxXQUFJc2QsSUFBSixFQUFVO0FBQ1IsYUFBSTBLLFVBQUo7QUFDQSxhQUFJLENBQUM0d0IsTUFBRCxJQUFXdDdCLFNBQVMsR0FBcEIsS0FBNEIwSyxhQUFhaXJCLFVBQVUzMUIsSUFBVixFQUFnQncxQixVQUFoQixDQUF6QyxDQUFKLEVBQTJFO0FBQ3pFejFCLG9CQUFTMU0sSUFBVCxDQUFjO0FBQ1pzSSxtQkFBTSxDQURNO0FBRVorTyx5QkFBWUEsVUFGQTtBQUdaMUssbUJBQU1BO0FBSE0sWUFBZDtBQUtELFVBTkQsTUFNTyxJQUFJQSxTQUFTLEdBQVQsSUFBZ0IsQ0FBQ0QsU0FBU3JkLE1BQTFCLElBQW9DcWQsU0FBU0EsU0FBU3JkLE1BQVQsR0FBa0IsQ0FBM0IsRUFBOEJzZCxJQUE5QixLQUF1QyxHQUEvRSxFQUFvRjtBQUN6RkQsb0JBQVMxTSxJQUFULENBQWM7QUFDWnNJLG1CQUFNLENBRE07QUFFWnFFLG1CQUFNQTtBQUZNLFlBQWQ7QUFJRDtBQUNGO0FBQ0YsTUE5TGlCO0FBK0xsQjIzQixjQUFTLFNBQVNBLE9BQVQsQ0FBa0IzM0IsSUFBbEIsRUFBd0I7QUFDL0JxN0IscUJBQWN0N0IsUUFBZCxDQUF1QjFNLElBQXZCLENBQTRCO0FBQzFCc0ksZUFBTSxDQURvQjtBQUUxQnFFLGVBQU1BLElBRm9CO0FBRzFCVyxvQkFBVztBQUhlLFFBQTVCO0FBS0Q7QUFyTWlCLElBQXBCO0FBdU1BLFVBQU81ZixJQUFQO0FBQ0Q7O0FBRUQsVUFBU2k3QyxVQUFULENBQXFCeGhDLEVBQXJCLEVBQXlCO0FBQ3ZCLE9BQUlrcUIsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE9BQXJCLEtBQWlDLElBQXJDLEVBQTJDO0FBQ3pDQSxRQUFHdWlCLEdBQUgsR0FBUyxJQUFUO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTa2YsZUFBVCxDQUEwQnpoQyxFQUExQixFQUE4QjtBQUM1QixPQUFJaE4sSUFBSWdOLEdBQUdxcUIsU0FBSCxDQUFhbmlDLE1BQXJCO0FBQ0EsT0FBSThLLENBQUosRUFBTztBQUNMLFNBQUlzVixRQUFRdEksR0FBR3NJLEtBQUgsR0FBVyxJQUFJalYsS0FBSixDQUFVTCxDQUFWLENBQXZCO0FBQ0EsVUFBSyxJQUFJL0ssSUFBSSxDQUFiLEVBQWdCQSxJQUFJK0ssQ0FBcEIsRUFBdUIvSyxHQUF2QixFQUE0QjtBQUMxQnFnQixhQUFNcmdCLENBQU4sSUFBVztBQUNUTyxlQUFNd1gsR0FBR3FxQixTQUFILENBQWFwaUMsQ0FBYixFQUFnQk8sSUFEYjtBQUVUb0gsZ0JBQU9hLEtBQUtDLFNBQUwsQ0FBZXNQLEdBQUdxcUIsU0FBSCxDQUFhcGlDLENBQWIsRUFBZ0IySCxLQUEvQjtBQUZFLFFBQVg7QUFJRDtBQUNGLElBUkQsTUFRTyxJQUFJLENBQUNvUSxHQUFHdWlCLEdBQVIsRUFBYTtBQUNsQjtBQUNBdmlCLFFBQUc4aEMsS0FBSCxHQUFXLElBQVg7QUFDRDtBQUNGOztBQUVELFVBQVNELFVBQVQsQ0FBcUI3aEMsRUFBckIsRUFBeUI7QUFDdkIsT0FBSW9vQixNQUFNMkIsZUFBZS9wQixFQUFmLEVBQW1CLEtBQW5CLENBQVY7QUFDQSxPQUFJb29CLEdBQUosRUFBUztBQUNQLFNBQUk3eUIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDdUssR0FBR3NFLEdBQUgsS0FBVyxVQUF4RCxFQUFvRTtBQUNsRTg3QixjQUFPLHFFQUFQO0FBQ0Q7QUFDRHBnQyxRQUFHbE8sR0FBSCxHQUFTczJCLEdBQVQ7QUFDRDtBQUNGOztBQUVELFVBQVMyWixVQUFULENBQXFCL2hDLEVBQXJCLEVBQXlCO0FBQ3ZCLE9BQUlxWixNQUFNMFEsZUFBZS9wQixFQUFmLEVBQW1CLEtBQW5CLENBQVY7QUFDQSxPQUFJcVosR0FBSixFQUFTO0FBQ1ByWixRQUFHcVosR0FBSCxHQUFTQSxHQUFUO0FBQ0FyWixRQUFHbWhCLFFBQUgsR0FBYzRoQixXQUFXL2lDLEVBQVgsQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzBoQyxVQUFULENBQXFCMWhDLEVBQXJCLEVBQXlCO0FBQ3ZCLE9BQUlvb0IsR0FBSjtBQUNBLE9BQUtBLE1BQU04QixpQkFBaUJscUIsRUFBakIsRUFBcUIsT0FBckIsQ0FBWCxFQUEyQztBQUN6QyxTQUFJZ2pDLFVBQVU1YSxJQUFJOXZCLEtBQUosQ0FBVXduQyxVQUFWLENBQWQ7QUFDQSxTQUFJLENBQUNrRCxPQUFMLEVBQWM7QUFDWnp0QyxlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMycUMsT0FDdEMsK0JBQStCaFksR0FETyxDQUF6QztBQUdBO0FBQ0Q7QUFDRHBvQixRQUFHaWpDLEdBQUgsR0FBU0QsUUFBUSxDQUFSLEVBQVdqYSxJQUFYLEVBQVQ7QUFDQSxTQUFJbWEsUUFBUUYsUUFBUSxDQUFSLEVBQVdqYSxJQUFYLEVBQVo7QUFDQSxTQUFJb2EsZ0JBQWdCRCxNQUFNNXFDLEtBQU4sQ0FBWXluQyxhQUFaLENBQXBCO0FBQ0EsU0FBSW9ELGFBQUosRUFBbUI7QUFDakJuakMsVUFBR2tqQyxLQUFILEdBQVdDLGNBQWMsQ0FBZCxFQUFpQnBhLElBQWpCLEVBQVg7QUFDQS9vQixVQUFHb2pDLFNBQUgsR0FBZUQsY0FBYyxDQUFkLEVBQWlCcGEsSUFBakIsRUFBZjtBQUNBLFdBQUlvYSxjQUFjLENBQWQsQ0FBSixFQUFzQjtBQUNwQm5qQyxZQUFHcWpDLFNBQUgsR0FBZUYsY0FBYyxDQUFkLEVBQWlCcGEsSUFBakIsRUFBZjtBQUNEO0FBQ0YsTUFORCxNQU1PO0FBQ0wvb0IsVUFBR2tqQyxLQUFILEdBQVdBLEtBQVg7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU3ZCLFNBQVQsQ0FBb0IzaEMsRUFBcEIsRUFBd0I7QUFDdEIsT0FBSW9vQixNQUFNOEIsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLE1BQXJCLENBQVY7QUFDQSxPQUFJb29CLEdBQUosRUFBUztBQUNQcG9CLFFBQUdvaUMsRUFBSCxHQUFRaGEsR0FBUjtBQUNBbWEsb0JBQWV2aUMsRUFBZixFQUFtQjtBQUNqQm9vQixZQUFLQSxHQURZO0FBRWpCb2EsY0FBT3hpQztBQUZVLE1BQW5CO0FBSUQsSUFORCxNQU1PO0FBQ0wsU0FBSWtxQixpQkFBaUJscUIsRUFBakIsRUFBcUIsUUFBckIsS0FBa0MsSUFBdEMsRUFBNEM7QUFDMUNBLFVBQUdzaUMsSUFBSCxHQUFVLElBQVY7QUFDRDtBQUNELFNBQUlELFNBQVNuWSxpQkFBaUJscUIsRUFBakIsRUFBcUIsV0FBckIsQ0FBYjtBQUNBLFNBQUlxaUMsTUFBSixFQUFZO0FBQ1ZyaUMsVUFBR3FpQyxNQUFILEdBQVlBLE1BQVo7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBU0ksbUJBQVQsQ0FBOEJ6aUMsRUFBOUIsRUFBa0NFLE1BQWxDLEVBQTBDO0FBQ3hDLE9BQUkyb0IsT0FBT3lhLGdCQUFnQnBqQyxPQUFPcUYsUUFBdkIsQ0FBWDtBQUNBLE9BQUlzakIsUUFBUUEsS0FBS3VaLEVBQWpCLEVBQXFCO0FBQ25CRyxvQkFBZTFaLElBQWYsRUFBcUI7QUFDbkJULFlBQUtwb0IsR0FBR3FpQyxNQURXO0FBRW5CRyxjQUFPeGlDO0FBRlksTUFBckI7QUFJRCxJQUxELE1BS08sSUFBSXpLLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUNoRDJxQyxZQUNFLFFBQVFwZ0MsR0FBR3FpQyxNQUFILEdBQWEsY0FBY3JpQyxHQUFHcWlDLE1BQWpCLEdBQTBCLEdBQXZDLEdBQThDLE1BQXRELElBQWdFLEdBQWhFLEdBQ0EsbUJBREEsR0FDdUJyaUMsR0FBR3NFLEdBRDFCLEdBQ2lDLCtCQUZuQztBQUlEO0FBQ0Y7O0FBRUQsVUFBU2cvQixlQUFULENBQTBCLzlCLFFBQTFCLEVBQW9DO0FBQ2xDLE9BQUl0ZCxJQUFJc2QsU0FBU3JkLE1BQWpCO0FBQ0EsVUFBT0QsR0FBUCxFQUFZO0FBQ1YsU0FBSXNkLFNBQVN0ZCxDQUFULEVBQVlrWixJQUFaLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGNBQU9vRSxTQUFTdGQsQ0FBVCxDQUFQO0FBQ0QsTUFGRCxNQUVPO0FBQ0wsV0FBSXNOLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QzhQLFNBQVN0ZCxDQUFULEVBQVl1ZCxJQUFaLEtBQXFCLEdBQWxFLEVBQXVFO0FBQ3JFNDZCLGdCQUNFLFlBQWE3NkIsU0FBU3RkLENBQVQsRUFBWXVkLElBQVosQ0FBaUJ1akIsSUFBakIsRUFBYixHQUF3QyxrQ0FBeEMsR0FDQSxrQkFGRjtBQUlEO0FBQ0R4akIsZ0JBQVNsSSxHQUFUO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVNrbEMsY0FBVCxDQUF5QnZpQyxFQUF6QixFQUE2QnVqQyxTQUE3QixFQUF3QztBQUN0QyxPQUFJLENBQUN2akMsR0FBR3dqQyxZQUFSLEVBQXNCO0FBQ3BCeGpDLFFBQUd3akMsWUFBSCxHQUFrQixFQUFsQjtBQUNEO0FBQ0R4akMsTUFBR3dqQyxZQUFILENBQWdCM3FDLElBQWhCLENBQXFCMHFDLFNBQXJCO0FBQ0Q7O0FBRUQsVUFBUzNCLFdBQVQsQ0FBc0I1aEMsRUFBdEIsRUFBMEI7QUFDeEIsT0FBSW9ILFVBQVU4aUIsaUJBQWlCbHFCLEVBQWpCLEVBQXFCLFFBQXJCLENBQWQ7QUFDQSxPQUFJb0gsV0FBVyxJQUFmLEVBQXFCO0FBQ25CcEgsUUFBR2xMLElBQUgsR0FBVSxJQUFWO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTa3RDLFdBQVQsQ0FBc0JoaUMsRUFBdEIsRUFBMEI7QUFDeEIsT0FBSUEsR0FBR3NFLEdBQUgsS0FBVyxNQUFmLEVBQXVCO0FBQ3JCdEUsUUFBR3lqQyxRQUFILEdBQWMxWixlQUFlL3BCLEVBQWYsRUFBbUIsTUFBbkIsQ0FBZDtBQUNBLFNBQUl6SyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUN1SyxHQUFHbE8sR0FBaEQsRUFBcUQ7QUFDbkRzdUMsY0FDRSxzRUFDQSxrREFEQSxHQUVBLDRDQUhGO0FBS0Q7QUFDRixJQVRELE1BU087QUFDTCxTQUFJdUMsYUFBYTVZLGVBQWUvcEIsRUFBZixFQUFtQixNQUFuQixDQUFqQjtBQUNBLFNBQUkyaUMsVUFBSixFQUFnQjtBQUNkM2lDLFVBQUcyaUMsVUFBSCxHQUFnQkEsZUFBZSxJQUFmLEdBQXNCLFdBQXRCLEdBQW9DQSxVQUFwRDtBQUNEO0FBQ0QsU0FBSTNpQyxHQUFHc0UsR0FBSCxLQUFXLFVBQWYsRUFBMkI7QUFDekJ0RSxVQUFHMGlDLFNBQUgsR0FBZXhZLGlCQUFpQmxxQixFQUFqQixFQUFxQixPQUFyQixDQUFmO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVNpaUMsZ0JBQVQsQ0FBMkJqaUMsRUFBM0IsRUFBK0I7QUFDN0IsT0FBSSsxQixPQUFKO0FBQ0EsT0FBS0EsVUFBVWhNLGVBQWUvcEIsRUFBZixFQUFtQixJQUFuQixDQUFmLEVBQTBDO0FBQ3hDQSxRQUFHa0ssU0FBSCxHQUFlNnJCLE9BQWY7QUFDRDtBQUNELE9BQUk3TCxpQkFBaUJscUIsRUFBakIsRUFBcUIsaUJBQXJCLEtBQTJDLElBQS9DLEVBQXFEO0FBQ25EQSxRQUFHdVcsY0FBSCxHQUFvQixJQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzJyQixZQUFULENBQXVCbGlDLEVBQXZCLEVBQTJCO0FBQ3pCLE9BQUk3TyxPQUFPNk8sR0FBR3FxQixTQUFkO0FBQ0EsT0FBSXBpQyxDQUFKLEVBQU8rSyxDQUFQLEVBQVV4SyxJQUFWLEVBQWdCMitCLE9BQWhCLEVBQXlCdjNCLEtBQXpCLEVBQWdDcTNCLFNBQWhDLEVBQTJDeWMsTUFBM0M7QUFDQSxRQUFLejdDLElBQUksQ0FBSixFQUFPK0ssSUFBSTdCLEtBQUtqSixNQUFyQixFQUE2QkQsSUFBSStLLENBQWpDLEVBQW9DL0ssR0FBcEMsRUFBeUM7QUFDdkNPLFlBQU8yK0IsVUFBVWgyQixLQUFLbEosQ0FBTCxFQUFRTyxJQUF6QjtBQUNBb0gsYUFBUXVCLEtBQUtsSixDQUFMLEVBQVEySCxLQUFoQjtBQUNBLFNBQUlpd0MsTUFBTTFvQyxJQUFOLENBQVczTyxJQUFYLENBQUosRUFBc0I7QUFDcEI7QUFDQXdYLFVBQUcyakMsV0FBSCxHQUFpQixJQUFqQjtBQUNBO0FBQ0ExYyxtQkFBWTJjLGVBQWVwN0MsSUFBZixDQUFaO0FBQ0EsV0FBSXkrQixTQUFKLEVBQWU7QUFDYnorQixnQkFBT0EsS0FBSzhKLE9BQUwsQ0FBYTR0QyxVQUFiLEVBQXlCLEVBQXpCLENBQVA7QUFDRDtBQUNELFdBQUlELE9BQU85b0MsSUFBUCxDQUFZM08sSUFBWixDQUFKLEVBQXVCO0FBQUU7QUFDdkJBLGdCQUFPQSxLQUFLOEosT0FBTCxDQUFhMnRDLE1BQWIsRUFBcUIsRUFBckIsQ0FBUDtBQUNBcndDLGlCQUFRdTRCLGFBQWF2NEIsS0FBYixDQUFSO0FBQ0E4ekMsa0JBQVMsS0FBVDtBQUNBLGFBQUl6YyxTQUFKLEVBQWU7QUFDYixlQUFJQSxVQUFVbGtCLElBQWQsRUFBb0I7QUFDbEIyZ0Msc0JBQVMsSUFBVDtBQUNBbDdDLG9CQUFPNkosU0FBUzdKLElBQVQsQ0FBUDtBQUNBLGlCQUFJQSxTQUFTLFdBQWIsRUFBMEI7QUFBRUEsc0JBQU8sV0FBUDtBQUFxQjtBQUNsRDtBQUNELGVBQUl5K0IsVUFBVTRjLEtBQWQsRUFBcUI7QUFDbkJyN0Msb0JBQU82SixTQUFTN0osSUFBVCxDQUFQO0FBQ0Q7QUFDRCxlQUFJeStCLFVBQVVuZCxJQUFkLEVBQW9CO0FBQ2xCMGYsd0JBQ0V4cEIsRUFERixFQUVHLFlBQWEzTixTQUFTN0osSUFBVCxDQUZoQixFQUdFbWlDLGtCQUFrQi82QixLQUFsQixFQUF5QixRQUF6QixDQUhGO0FBS0Q7QUFDRjtBQUNELGFBQUk4ekMsVUFDRixDQUFDMWpDLEdBQUdrSyxTQUFKLElBQWlCdTJCLG9CQUFvQnpnQyxHQUFHc0UsR0FBdkIsRUFBNEJ0RSxHQUFHb3FCLFFBQUgsQ0FBWWpwQixJQUF4QyxFQUE4QzNZLElBQTlDLENBRG5CLEVBRUc7QUFDRDRnQyxtQkFBUXBwQixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCb0gsS0FBbEI7QUFDRCxVQUpELE1BSU87QUFDTHk1QixtQkFBUXJwQixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCb0gsS0FBbEI7QUFDRDtBQUNGLFFBNUJELE1BNEJPLElBQUlnd0MsS0FBS3pvQyxJQUFMLENBQVUzTyxJQUFWLENBQUosRUFBcUI7QUFBRTtBQUM1QkEsZ0JBQU9BLEtBQUs4SixPQUFMLENBQWFzdEMsSUFBYixFQUFtQixFQUFuQixDQUFQO0FBQ0FwVyxvQkFBV3hwQixFQUFYLEVBQWV4WCxJQUFmLEVBQXFCb0gsS0FBckIsRUFBNEJxM0IsU0FBNUIsRUFBdUMsS0FBdkMsRUFBOENtWixNQUE5QztBQUNELFFBSE0sTUFHQTtBQUFFO0FBQ1A1M0MsZ0JBQU9BLEtBQUs4SixPQUFMLENBQWF1dEMsS0FBYixFQUFvQixFQUFwQixDQUFQO0FBQ0E7QUFDQSxhQUFJaUUsV0FBV3Q3QyxLQUFLOFAsS0FBTCxDQUFXMG5DLEtBQVgsQ0FBZjtBQUNBLGFBQUl6VyxNQUFNdWEsWUFBWUEsU0FBUyxDQUFULENBQXRCO0FBQ0EsYUFBSXZhLEdBQUosRUFBUztBQUNQL2dDLGtCQUFPQSxLQUFLcUIsS0FBTCxDQUFXLENBQVgsRUFBYyxFQUFFMC9CLElBQUlyaEMsTUFBSixHQUFhLENBQWYsQ0FBZCxDQUFQO0FBQ0Q7QUFDRG9oQyxzQkFBYXRwQixFQUFiLEVBQWlCeFgsSUFBakIsRUFBdUIyK0IsT0FBdkIsRUFBZ0N2M0IsS0FBaEMsRUFBdUMyNUIsR0FBdkMsRUFBNEN0QyxTQUE1QztBQUNBLGFBQUkxeEIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDak4sU0FBUyxPQUF0RCxFQUErRDtBQUM3RHU3Qyw4QkFBbUIvakMsRUFBbkIsRUFBdUJwUSxLQUF2QjtBQUNEO0FBQ0Y7QUFDRixNQXBERCxNQW9ETztBQUNMO0FBQ0EsV0FBSTJGLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxhQUFJeWEsYUFBYWlyQixVQUFVdnJDLEtBQVYsRUFBaUJvckMsVUFBakIsQ0FBakI7QUFDQSxhQUFJOXFCLFVBQUosRUFBZ0I7QUFDZGt3QixrQkFDRTUzQyxPQUFPLEtBQVAsR0FBZW9ILEtBQWYsR0FBdUIsTUFBdkIsR0FDQSxvREFEQSxHQUVBLDBEQUZBLEdBR0EsdURBSkY7QUFNRDtBQUNGO0FBQ0R5NUIsZUFBUXJwQixFQUFSLEVBQVl4WCxJQUFaLEVBQWtCaUksS0FBS0MsU0FBTCxDQUFlZCxLQUFmLENBQWxCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQVNtekMsVUFBVCxDQUFxQi9pQyxFQUFyQixFQUF5QjtBQUN2QixPQUFJRSxTQUFTRixFQUFiO0FBQ0EsVUFBT0UsTUFBUCxFQUFlO0FBQ2IsU0FBSUEsT0FBTytpQyxHQUFQLEtBQWVwN0MsU0FBbkIsRUFBOEI7QUFDNUIsY0FBTyxJQUFQO0FBQ0Q7QUFDRHFZLGNBQVNBLE9BQU9BLE1BQWhCO0FBQ0Q7QUFDRCxVQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFTMGpDLGNBQVQsQ0FBeUJwN0MsSUFBekIsRUFBK0I7QUFDN0IsT0FBSThQLFFBQVE5UCxLQUFLOFAsS0FBTCxDQUFXNG5DLFVBQVgsQ0FBWjtBQUNBLE9BQUk1bkMsS0FBSixFQUFXO0FBQ1QsU0FBSWxGLE1BQU0sRUFBVjtBQUNBa0YsV0FBTXZKLE9BQU4sQ0FBYyxVQUFVaUYsQ0FBVixFQUFhO0FBQUVaLFdBQUlZLEVBQUVuSyxLQUFGLENBQVEsQ0FBUixDQUFKLElBQWtCLElBQWxCO0FBQXlCLE1BQXREO0FBQ0EsWUFBT3VKLEdBQVA7QUFDRDtBQUNGOztBQUVELFVBQVNpdUMsWUFBVCxDQUF1Qi80QixLQUF2QixFQUE4QjtBQUM1QixPQUFJclgsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJaEosSUFBSSxDQUFSLEVBQVcrSyxJQUFJc1YsTUFBTXBnQixNQUExQixFQUFrQ0QsSUFBSStLLENBQXRDLEVBQXlDL0ssR0FBekMsRUFBOEM7QUFDNUMsU0FDRXNOLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUNBeEUsSUFBSXFYLE1BQU1yZ0IsQ0FBTixFQUFTTyxJQUFiLENBREEsSUFDc0IsQ0FBQzZRLElBRHZCLElBQytCLENBQUNFLE1BRmxDLEVBR0U7QUFDQTZtQyxjQUFPLDBCQUEwQjkzQixNQUFNcmdCLENBQU4sRUFBU08sSUFBMUM7QUFDRDtBQUNEeUksU0FBSXFYLE1BQU1yZ0IsQ0FBTixFQUFTTyxJQUFiLElBQXFCOGYsTUFBTXJnQixDQUFOLEVBQVMySCxLQUE5QjtBQUNEO0FBQ0QsVUFBT3FCLEdBQVA7QUFDRDs7QUFFRDtBQUNBLFVBQVM2eEMsU0FBVCxDQUFvQjlpQyxFQUFwQixFQUF3QjtBQUN0QixVQUFPQSxHQUFHc0UsR0FBSCxLQUFXLFFBQVgsSUFBdUJ0RSxHQUFHc0UsR0FBSCxLQUFXLE9BQXpDO0FBQ0Q7O0FBRUQsVUFBU2c5QixjQUFULENBQXlCdGhDLEVBQXpCLEVBQTZCO0FBQzNCLFVBQ0VBLEdBQUdzRSxHQUFILEtBQVcsT0FBWCxJQUNDdEUsR0FBR3NFLEdBQUgsS0FBVyxRQUFYLEtBQ0MsQ0FBQ3RFLEdBQUdvcUIsUUFBSCxDQUFZanBCLElBQWIsSUFDQW5CLEdBQUdvcUIsUUFBSCxDQUFZanBCLElBQVosS0FBcUIsaUJBRnRCLENBRkg7QUFPRDs7QUFFRCxLQUFJNmlDLFVBQVUsY0FBZDtBQUNBLEtBQUlDLGFBQWEsU0FBakI7O0FBRUE7QUFDQSxVQUFTN0MsYUFBVCxDQUF3Qjk0QixLQUF4QixFQUErQjtBQUM3QixPQUFJdmIsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJOUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJcWdCLE1BQU1wZ0IsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3JDLFNBQUlpMkIsT0FBTzVWLE1BQU1yZ0IsQ0FBTixDQUFYO0FBQ0EsU0FBSSxDQUFDKzdDLFFBQVE3c0MsSUFBUixDQUFhK21CLEtBQUsxMUIsSUFBbEIsQ0FBTCxFQUE4QjtBQUM1QjAxQixZQUFLMTFCLElBQUwsR0FBWTAxQixLQUFLMTFCLElBQUwsQ0FBVThKLE9BQVYsQ0FBa0IyeEMsVUFBbEIsRUFBOEIsRUFBOUIsQ0FBWjtBQUNBbDNDLFdBQUk4TCxJQUFKLENBQVNxbEIsSUFBVDtBQUNEO0FBQ0Y7QUFDRCxVQUFPbnhCLEdBQVA7QUFDRDs7QUFFRCxVQUFTZzNDLGtCQUFULENBQTZCL2pDLEVBQTdCLEVBQWlDcFEsS0FBakMsRUFBd0M7QUFDdEMsT0FBSXMwQyxNQUFNbGtDLEVBQVY7QUFDQSxVQUFPa2tDLEdBQVAsRUFBWTtBQUNWLFNBQUlBLElBQUlqQixHQUFKLElBQVdpQixJQUFJaEIsS0FBSixLQUFjdHpDLEtBQTdCLEVBQW9DO0FBQ2xDd3dDLGNBQ0UsTUFBT3BnQyxHQUFHc0UsR0FBVixHQUFpQixhQUFqQixHQUFpQzFVLEtBQWpDLEdBQXlDLE9BQXpDLEdBQ0EsK0RBREEsR0FFQSxpRUFGQSxHQUdBLG9FQUhBLEdBSUEsbUZBTEY7QUFPRDtBQUNEczBDLFdBQU1BLElBQUloa0MsTUFBVjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUEsS0FBSWlrQyxXQUFKO0FBQ0EsS0FBSUMscUJBQUo7O0FBRUEsS0FBSUMsc0JBQXNCdHlDLE9BQU91eUMsZUFBUCxDQUExQjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxVQUFTQyxRQUFULENBQW1CaCtDLElBQW5CLEVBQXlCeVIsT0FBekIsRUFBa0M7QUFDaEMsT0FBSSxDQUFDelIsSUFBTCxFQUFXO0FBQUU7QUFBUTtBQUNyQjQ5QyxpQkFBY0Usb0JBQW9CcnNDLFFBQVE5RCxVQUFSLElBQXNCLEVBQTFDLENBQWQ7QUFDQWt3QywyQkFBd0Jwc0MsUUFBUWhDLGFBQVIsSUFBeUJyQyxFQUFqRDtBQUNBO0FBQ0E2d0MsZ0JBQWFqK0MsSUFBYjtBQUNBO0FBQ0FrK0MsbUJBQWdCbCtDLElBQWhCLEVBQXNCLEtBQXRCO0FBQ0Q7O0FBRUQsVUFBUys5QyxlQUFULENBQTBCeDFDLElBQTFCLEVBQWdDO0FBQzlCLFVBQU9nQyxRQUNMLDZEQUNDaEMsT0FBTyxNQUFNQSxJQUFiLEdBQW9CLEVBRHJCLENBREssQ0FBUDtBQUlEOztBQUVELFVBQVMwMUMsWUFBVCxDQUF1Qjc5QixJQUF2QixFQUE2QjtBQUMzQkEsUUFBSys5QixNQUFMLEdBQWN6K0IsU0FBU1UsSUFBVCxDQUFkO0FBQ0EsT0FBSUEsS0FBS3hGLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUNFLENBQUNpakMsc0JBQXNCejlCLEtBQUtyQyxHQUEzQixDQUFELElBQ0FxQyxLQUFLckMsR0FBTCxLQUFhLE1BRGIsSUFFQXFDLEtBQUt5akIsUUFBTCxDQUFjLGlCQUFkLEtBQW9DLElBSHRDLEVBSUU7QUFDQTtBQUNEO0FBQ0QsVUFBSyxJQUFJbmlDLElBQUksQ0FBUixFQUFXK0ssSUFBSTJULEtBQUtwQixRQUFMLENBQWNyZCxNQUFsQyxFQUEwQ0QsSUFBSStLLENBQTlDLEVBQWlEL0ssR0FBakQsRUFBc0Q7QUFDcEQsV0FBSWtZLFFBQVF3RyxLQUFLcEIsUUFBTCxDQUFjdGQsQ0FBZCxDQUFaO0FBQ0F1OEMsb0JBQWFya0MsS0FBYjtBQUNBLFdBQUksQ0FBQ0EsTUFBTXVrQyxNQUFYLEVBQW1CO0FBQ2pCLzlCLGNBQUsrOUIsTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGO0FBQ0QsU0FBSS85QixLQUFLNjhCLFlBQVQsRUFBdUI7QUFDckIsWUFBSyxJQUFJbjRCLE1BQU0sQ0FBVixFQUFhczVCLE1BQU1oK0IsS0FBSzY4QixZQUFMLENBQWtCdDdDLE1BQTFDLEVBQWtEbWpCLE1BQU1zNUIsR0FBeEQsRUFBNkR0NUIsS0FBN0QsRUFBb0U7QUFDbEUsYUFBSW0zQixRQUFRNzdCLEtBQUs2OEIsWUFBTCxDQUFrQm40QixHQUFsQixFQUF1Qm0zQixLQUFuQztBQUNBZ0Msc0JBQWFoQyxLQUFiO0FBQ0EsYUFBSSxDQUFDQSxNQUFNa0MsTUFBWCxFQUFtQjtBQUNqQi85QixnQkFBSys5QixNQUFMLEdBQWMsS0FBZDtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsVUFBU0QsZUFBVCxDQUEwQjk5QixJQUExQixFQUFnQzRSLE9BQWhDLEVBQXlDO0FBQ3ZDLE9BQUk1UixLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLFNBQUl3RixLQUFLKzlCLE1BQUwsSUFBZS85QixLQUFLN1IsSUFBeEIsRUFBOEI7QUFDNUI2UixZQUFLaStCLFdBQUwsR0FBbUJyc0IsT0FBbkI7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBLFNBQUk1UixLQUFLKzlCLE1BQUwsSUFBZS85QixLQUFLcEIsUUFBTCxDQUFjcmQsTUFBN0IsSUFBdUMsRUFDekN5ZSxLQUFLcEIsUUFBTCxDQUFjcmQsTUFBZCxLQUF5QixDQUF6QixJQUNBeWUsS0FBS3BCLFFBQUwsQ0FBYyxDQUFkLEVBQWlCcEUsSUFBakIsS0FBMEIsQ0FGZSxDQUEzQyxFQUdHO0FBQ0R3RixZQUFLaytCLFVBQUwsR0FBa0IsSUFBbEI7QUFDQTtBQUNELE1BTkQsTUFNTztBQUNMbCtCLFlBQUtrK0IsVUFBTCxHQUFrQixLQUFsQjtBQUNEO0FBQ0QsU0FBSWwrQixLQUFLcEIsUUFBVCxFQUFtQjtBQUNqQixZQUFLLElBQUl0ZCxJQUFJLENBQVIsRUFBVytLLElBQUkyVCxLQUFLcEIsUUFBTCxDQUFjcmQsTUFBbEMsRUFBMENELElBQUkrSyxDQUE5QyxFQUFpRC9LLEdBQWpELEVBQXNEO0FBQ3BEdzhDLHlCQUFnQjk5QixLQUFLcEIsUUFBTCxDQUFjdGQsQ0FBZCxDQUFoQixFQUFrQ3N3QixXQUFXLENBQUMsQ0FBQzVSLEtBQUtzOEIsR0FBcEQ7QUFDRDtBQUNGO0FBQ0QsU0FBSXQ4QixLQUFLNjhCLFlBQVQsRUFBdUI7QUFDckIsWUFBSyxJQUFJbjRCLE1BQU0sQ0FBVixFQUFhczVCLE1BQU1oK0IsS0FBSzY4QixZQUFMLENBQWtCdDdDLE1BQTFDLEVBQWtEbWpCLE1BQU1zNUIsR0FBeEQsRUFBNkR0NUIsS0FBN0QsRUFBb0U7QUFDbEVvNUIseUJBQWdCOTlCLEtBQUs2OEIsWUFBTCxDQUFrQm40QixHQUFsQixFQUF1Qm0zQixLQUF2QyxFQUE4Q2pxQixPQUE5QztBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFVBQVN0UyxRQUFULENBQW1CVSxJQUFuQixFQUF5QjtBQUN2QixPQUFJQSxLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQUU7QUFDckIsWUFBTyxLQUFQO0FBQ0Q7QUFDRCxPQUFJd0YsS0FBS3hGLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUFFO0FBQ3JCLFlBQU8sSUFBUDtBQUNEO0FBQ0QsVUFBTyxDQUFDLEVBQUV3RixLQUFLNGIsR0FBTCxJQUNSLENBQUM1YixLQUFLZzlCLFdBQU4sSUFBcUI7QUFDckIsSUFBQ2g5QixLQUFLeTdCLEVBRE4sSUFDWSxDQUFDejdCLEtBQUtzOEIsR0FEbEIsSUFDeUI7QUFDekIsSUFBQzN4QyxhQUFhcVYsS0FBS3JDLEdBQWxCLENBRkQsSUFFMkI7QUFDM0I4L0IseUJBQXNCejlCLEtBQUtyQyxHQUEzQixDQUhBLElBR21DO0FBQ25DLElBQUN3Z0MsMkJBQTJCbitCLElBQTNCLENBSkQsSUFLQTlYLE9BQU9DLElBQVAsQ0FBWTZYLElBQVosRUFBa0JqUyxLQUFsQixDQUF3Qnl2QyxXQUF4QixDQU5NLENBQVI7QUFRRDs7QUFFRCxVQUFTVywwQkFBVCxDQUFxQ24rQixJQUFyQyxFQUEyQztBQUN6QyxVQUFPQSxLQUFLekcsTUFBWixFQUFvQjtBQUNsQnlHLFlBQU9BLEtBQUt6RyxNQUFaO0FBQ0EsU0FBSXlHLEtBQUtyQyxHQUFMLEtBQWEsVUFBakIsRUFBNkI7QUFDM0IsY0FBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFJcUMsS0FBS3M4QixHQUFULEVBQWM7QUFDWixjQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsS0FBSThCLFVBQVUsOENBQWQ7QUFDQSxLQUFJQyxlQUFlLDhGQUFuQjs7QUFFQTtBQUNBLEtBQUlqdkMsV0FBVztBQUNia3ZDLFFBQUssRUFEUTtBQUViMTRDLFFBQUssQ0FGUTtBQUdieW1DLFVBQU8sRUFITTtBQUlia1MsVUFBTyxFQUpNO0FBS2JDLE9BQUksRUFMUztBQU1iaEwsU0FBTSxFQU5PO0FBT2JpTCxVQUFPLEVBUE07QUFRYkMsU0FBTSxFQVJPO0FBU2IsYUFBVSxDQUFDLENBQUQsRUFBSSxFQUFKO0FBVEcsRUFBZjs7QUFZQTtBQUNBO0FBQ0E7QUFDQSxLQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVS9CLFNBQVYsRUFBcUI7QUFBRSxVQUFRLFFBQVFBLFNBQVIsR0FBb0IsZUFBNUI7QUFBK0MsRUFBckY7O0FBRUEsS0FBSWdDLGVBQWU7QUFDakJDLFNBQU0sMkJBRFc7QUFFakI5YixZQUFTLDBCQUZRO0FBR2pCL2dDLFNBQU0yOEMsU0FBUyx3Q0FBVCxDQUhXO0FBSWpCRyxTQUFNSCxTQUFTLGlCQUFULENBSlc7QUFLakJJLFVBQU9KLFNBQVMsa0JBQVQsQ0FMVTtBQU1qQkssUUFBS0wsU0FBUyxnQkFBVCxDQU5ZO0FBT2pCTSxTQUFNTixTQUFTLGlCQUFULENBUFc7QUFRakJuTCxTQUFNbUwsU0FBUywyQ0FBVCxDQVJXO0FBU2pCTyxXQUFRUCxTQUFTLDJDQUFULENBVFM7QUFVakJGLFVBQU9FLFNBQVMsMkNBQVQ7QUFWVSxFQUFuQjs7QUFhQSxVQUFTUSxXQUFULENBQ0VuYyxNQURGLEVBRUVydkIsUUFGRixFQUdFakQsSUFIRixFQUlFO0FBQ0EsT0FBSXRLLE1BQU11TixXQUFXLFlBQVgsR0FBMEIsTUFBcEM7QUFDQSxRQUFLLElBQUk5UixJQUFULElBQWlCbWhDLE1BQWpCLEVBQXlCO0FBQ3ZCLFNBQUlyVyxVQUFVcVcsT0FBT25oQyxJQUFQLENBQWQ7QUFDQTtBQUNBLFNBQUkrTSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFDRmpOLFNBQVMsT0FEUCxJQUVGOHFCLE9BRkUsSUFFU0EsUUFBUTJULFNBRmpCLElBRThCM1QsUUFBUTJULFNBQVIsQ0FBa0JtZSxLQUZwRCxFQUdFO0FBQ0EvdEMsWUFDRSx1RUFDQSx3Q0FGRjtBQUlEO0FBQ0R0SyxZQUFPLE9BQU92RSxJQUFQLEdBQWMsS0FBZCxHQUF1QnU5QyxXQUFXdjlDLElBQVgsRUFBaUI4cUIsT0FBakIsQ0FBdkIsR0FBb0QsR0FBM0Q7QUFDRDtBQUNELFVBQU92bUIsSUFBSWxELEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLElBQW1CLEdBQTFCO0FBQ0Q7O0FBRUQsVUFBU2s4QyxVQUFULENBQ0V2OUMsSUFERixFQUVFOHFCLE9BRkYsRUFHRTtBQUNBLE9BQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1osWUFBTyxjQUFQO0FBQ0Q7O0FBRUQsT0FBSWpnQixNQUFNbUIsT0FBTixDQUFjOGUsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFlBQVEsTUFBT0EsUUFBUXJpQixHQUFSLENBQVksVUFBVXFpQixPQUFWLEVBQW1CO0FBQUUsY0FBT3l5QixXQUFXdjlDLElBQVgsRUFBaUI4cUIsT0FBakIsQ0FBUDtBQUFtQyxNQUFwRSxFQUFzRW5mLElBQXRFLENBQTJFLEdBQTNFLENBQVAsR0FBMEYsR0FBbEc7QUFDRDs7QUFFRCxPQUFJNnhDLGVBQWVoQixhQUFhN3RDLElBQWIsQ0FBa0JtYyxRQUFRMWpCLEtBQTFCLENBQW5CO0FBQ0EsT0FBSXEyQyx1QkFBdUJsQixRQUFRNXRDLElBQVIsQ0FBYW1jLFFBQVExakIsS0FBckIsQ0FBM0I7O0FBRUEsT0FBSSxDQUFDMGpCLFFBQVEyVCxTQUFiLEVBQXdCO0FBQ3RCLFlBQU8rZSxnQkFBZ0JDLG9CQUFoQixHQUNIM3lCLFFBQVExakIsS0FETCxHQUVGLHNCQUF1QjBqQixRQUFRMWpCLEtBQS9CLEdBQXdDLEdBRjdDLENBRHNCLENBRzRCO0FBQ25ELElBSkQsTUFJTztBQUNMLFNBQUk2OEIsT0FBTyxFQUFYO0FBQ0EsU0FBSXlaLGtCQUFrQixFQUF0QjtBQUNBLFNBQUlwM0MsT0FBTyxFQUFYO0FBQ0EsVUFBSyxJQUFJZ0QsR0FBVCxJQUFnQndoQixRQUFRMlQsU0FBeEIsRUFBbUM7QUFDakMsV0FBSXNlLGFBQWF6ekMsR0FBYixDQUFKLEVBQXVCO0FBQ3JCbzBDLDRCQUFtQlgsYUFBYXp6QyxHQUFiLENBQW5CO0FBQ0E7QUFDQSxhQUFJaUUsU0FBU2pFLEdBQVQsQ0FBSixFQUFtQjtBQUNqQmhELGdCQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNEO0FBQ0YsUUFORCxNQU1PO0FBQ0xoRCxjQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNEO0FBQ0Y7QUFDRCxTQUFJaEQsS0FBSzVHLE1BQVQsRUFBaUI7QUFDZnVrQyxlQUFRMFosYUFBYXIzQyxJQUFiLENBQVI7QUFDRDtBQUNEO0FBQ0EsU0FBSW8zQyxlQUFKLEVBQXFCO0FBQ25CelosZUFBUXlaLGVBQVI7QUFDRDtBQUNELFNBQUlFLGNBQWNKLGVBQ2QxeUIsUUFBUTFqQixLQUFSLEdBQWdCLFVBREYsR0FFZHEyQyx1QkFDRyxNQUFPM3lCLFFBQVExakIsS0FBZixHQUF3QixXQUQzQixHQUVFMGpCLFFBQVExakIsS0FKZDtBQUtBLFlBQVEsc0JBQXNCNjhCLElBQXRCLEdBQTZCMlosV0FBN0IsR0FBMkMsR0FBbkQ7QUFDRDtBQUNGOztBQUVELFVBQVNELFlBQVQsQ0FBdUJyM0MsSUFBdkIsRUFBNkI7QUFDM0IsVUFBUSwrQkFBZ0NBLEtBQUttQyxHQUFMLENBQVNvMUMsYUFBVCxFQUF3Qmx5QyxJQUF4QixDQUE2QixJQUE3QixDQUFoQyxHQUFzRSxlQUE5RTtBQUNEOztBQUVELFVBQVNreUMsYUFBVCxDQUF3QnYwQyxHQUF4QixFQUE2QjtBQUMzQixPQUFJdzBDLFNBQVNDLFNBQVN6MEMsR0FBVCxFQUFjLEVBQWQsQ0FBYjtBQUNBLE9BQUl3MEMsTUFBSixFQUFZO0FBQ1YsWUFBUSxzQkFBc0JBLE1BQTlCO0FBQ0Q7QUFDRCxPQUFJcEQsUUFBUW50QyxTQUFTakUsR0FBVCxDQUFaO0FBQ0EsVUFBUSx1QkFBd0JyQixLQUFLQyxTQUFMLENBQWVvQixHQUFmLENBQXhCLElBQWdEb3hDLFFBQVEsTUFBTXp5QyxLQUFLQyxTQUFMLENBQWV3eUMsS0FBZixDQUFkLEdBQXNDLEVBQXRGLElBQTRGLEdBQXBHO0FBQ0Q7O0FBRUQ7O0FBRUEsVUFBU3Y3QixFQUFULENBQWEzSCxFQUFiLEVBQWlCNG1CLEdBQWpCLEVBQXNCO0FBQ3BCLE9BQUlyeEIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDbXhCLElBQUlLLFNBQWpELEVBQTREO0FBQzFENXZCLFVBQUssbURBQUw7QUFDRDtBQUNEMkksTUFBR3dtQyxhQUFILEdBQW1CLFVBQVUvWixJQUFWLEVBQWdCO0FBQUUsWUFBUSxRQUFRQSxJQUFSLEdBQWUsR0FBZixHQUFzQjdGLElBQUloM0IsS0FBMUIsR0FBbUMsR0FBM0M7QUFBa0QsSUFBdkY7QUFDRDs7QUFFRDs7QUFFQSxVQUFTNjJDLE1BQVQsQ0FBaUJ6bUMsRUFBakIsRUFBcUI0bUIsR0FBckIsRUFBMEI7QUFDeEI1bUIsTUFBRzBtQyxRQUFILEdBQWMsVUFBVWphLElBQVYsRUFBZ0I7QUFDNUIsWUFBUSxRQUFRQSxJQUFSLEdBQWUsSUFBZixHQUF1QnpzQixHQUFHc0UsR0FBMUIsR0FBaUMsSUFBakMsR0FBeUNzaUIsSUFBSWgzQixLQUE3QyxHQUFzRCxHQUF0RCxJQUE2RGczQixJQUFJSyxTQUFKLElBQWlCTCxJQUFJSyxTQUFKLENBQWNsa0IsSUFBL0IsR0FBc0MsTUFBdEMsR0FBK0MsT0FBNUcsS0FBd0g2akIsSUFBSUssU0FBSixJQUFpQkwsSUFBSUssU0FBSixDQUFjbmQsSUFBL0IsR0FBc0MsT0FBdEMsR0FBZ0QsRUFBeEssSUFBOEssR0FBdEw7QUFDRCxJQUZEO0FBR0Q7O0FBRUQ7O0FBRUEsS0FBSTY4QixpQkFBaUI7QUFDbkJoL0IsT0FBSUEsRUFEZTtBQUVuQnZnQixTQUFNcS9DLE1BRmE7QUFHbkJHLFVBQU8vL0M7QUFIWSxFQUFyQjs7QUFNQTs7QUFFQSxLQUFJZ2dELGVBQWUsU0FBU0EsWUFBVCxDQUF1Qjd1QyxPQUF2QixFQUFnQztBQUNqRCxRQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxRQUFLWCxJQUFMLEdBQVlXLFFBQVFYLElBQVIsSUFBZ0I2eEIsUUFBNUI7QUFDQSxRQUFLbVgsVUFBTCxHQUFrQmxYLG9CQUFvQm54QixRQUFRbEUsT0FBNUIsRUFBcUMsZUFBckMsQ0FBbEI7QUFDQSxRQUFLZ3pDLFVBQUwsR0FBa0IzZCxvQkFBb0JueEIsUUFBUWxFLE9BQTVCLEVBQXFDLFNBQXJDLENBQWxCO0FBQ0EsUUFBS21PLFVBQUwsR0FBa0IzTyxPQUFPQSxPQUFPLEVBQVAsRUFBV3F6QyxjQUFYLENBQVAsRUFBbUMzdUMsUUFBUWlLLFVBQTNDLENBQWxCO0FBQ0EsT0FBSWpNLGdCQUFnQmdDLFFBQVFoQyxhQUFSLElBQXlCckMsRUFBN0M7QUFDQSxRQUFLb3pDLGNBQUwsR0FBc0IsVUFBVS9tQyxFQUFWLEVBQWM7QUFBRSxZQUFPLENBQUNoSyxjQUFjZ0ssR0FBR3NFLEdBQWpCLENBQVI7QUFBZ0MsSUFBdEU7QUFDQSxRQUFLMGlDLE1BQUwsR0FBYyxDQUFkO0FBQ0EsUUFBS3h3QixlQUFMLEdBQXVCLEVBQXZCO0FBQ0QsRUFWRDs7QUFjQSxVQUFTeXdCLFFBQVQsQ0FDRUMsR0FERixFQUVFbHZDLE9BRkYsRUFHRTtBQUNBLE9BQUltdkMsUUFBUSxJQUFJTixZQUFKLENBQWlCN3VDLE9BQWpCLENBQVo7QUFDQSxPQUFJeTBCLE9BQU95YSxNQUFNRSxXQUFXRixHQUFYLEVBQWdCQyxLQUFoQixDQUFOLEdBQStCLFdBQTFDO0FBQ0EsVUFBTztBQUNMaGlDLGFBQVMsdUJBQXVCc25CLElBQXZCLEdBQThCLEdBRGxDO0FBRUxqVyxzQkFBaUIyd0IsTUFBTTN3QjtBQUZsQixJQUFQO0FBSUQ7O0FBRUQsVUFBUzR3QixVQUFULENBQXFCcG5DLEVBQXJCLEVBQXlCbW5DLEtBQXpCLEVBQWdDO0FBQzlCLE9BQUlubkMsR0FBRzZrQyxVQUFILElBQWlCLENBQUM3a0MsR0FBR3FuQyxlQUF6QixFQUEwQztBQUN4QyxZQUFPQyxVQUFVdG5DLEVBQVYsRUFBY21uQyxLQUFkLENBQVA7QUFDRCxJQUZELE1BRU8sSUFBSW5uQyxHQUFHbEwsSUFBSCxJQUFXLENBQUNrTCxHQUFHdW5DLGFBQW5CLEVBQWtDO0FBQ3ZDLFlBQU9DLFFBQVF4bkMsRUFBUixFQUFZbW5DLEtBQVosQ0FBUDtBQUNELElBRk0sTUFFQSxJQUFJbm5DLEdBQUdpakMsR0FBSCxJQUFVLENBQUNqakMsR0FBR3luQyxZQUFsQixFQUFnQztBQUNyQyxZQUFPQyxPQUFPMW5DLEVBQVAsRUFBV21uQyxLQUFYLENBQVA7QUFDRCxJQUZNLE1BRUEsSUFBSW5uQyxHQUFHb2lDLEVBQUgsSUFBUyxDQUFDcGlDLEdBQUcybkMsV0FBakIsRUFBOEI7QUFDbkMsWUFBT0MsTUFBTTVuQyxFQUFOLEVBQVVtbkMsS0FBVixDQUFQO0FBQ0QsSUFGTSxNQUVBLElBQUlubkMsR0FBR3NFLEdBQUgsS0FBVyxVQUFYLElBQXlCLENBQUN0RSxHQUFHMmlDLFVBQWpDLEVBQTZDO0FBQ2xELFlBQU9rRixZQUFZN25DLEVBQVosRUFBZ0JtbkMsS0FBaEIsS0FBMEIsUUFBakM7QUFDRCxJQUZNLE1BRUEsSUFBSW5uQyxHQUFHc0UsR0FBSCxLQUFXLE1BQWYsRUFBdUI7QUFDNUIsWUFBT3dqQyxRQUFROW5DLEVBQVIsRUFBWW1uQyxLQUFaLENBQVA7QUFDRCxJQUZNLE1BRUE7QUFDTDtBQUNBLFNBQUkxYSxJQUFKO0FBQ0EsU0FBSXpzQixHQUFHa0ssU0FBUCxFQUFrQjtBQUNoQnVpQixjQUFPc2IsYUFBYS9uQyxHQUFHa0ssU0FBaEIsRUFBMkJsSyxFQUEzQixFQUErQm1uQyxLQUEvQixDQUFQO0FBQ0QsTUFGRCxNQUVPO0FBQ0wsV0FBSTM1QyxPQUFPd1MsR0FBRzhoQyxLQUFILEdBQVdqNkMsU0FBWCxHQUF1Qm1nRCxVQUFVaG9DLEVBQVYsRUFBY21uQyxLQUFkLENBQWxDOztBQUVBLFdBQUk1aEMsV0FBV3ZGLEdBQUd1VyxjQUFILEdBQW9CLElBQXBCLEdBQTJCc3hCLFlBQVk3bkMsRUFBWixFQUFnQm1uQyxLQUFoQixFQUF1QixJQUF2QixDQUExQztBQUNBMWEsY0FBTyxTQUFVenNCLEdBQUdzRSxHQUFiLEdBQW9CLEdBQXBCLElBQTJCOVcsT0FBUSxNQUFNQSxJQUFkLEdBQXNCLEVBQWpELEtBQXdEK1gsV0FBWSxNQUFNQSxRQUFsQixHQUE4QixFQUF0RixJQUE0RixHQUFuRztBQUNEO0FBQ0Q7QUFDQSxVQUFLLElBQUl0ZCxJQUFJLENBQWIsRUFBZ0JBLElBQUlrL0MsTUFBTTlHLFVBQU4sQ0FBaUJuNEMsTUFBckMsRUFBNkNELEdBQTdDLEVBQWtEO0FBQ2hEd2tDLGNBQU8wYSxNQUFNOUcsVUFBTixDQUFpQnA0QyxDQUFqQixFQUFvQitYLEVBQXBCLEVBQXdCeXNCLElBQXhCLENBQVA7QUFDRDtBQUNELFlBQU9BLElBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0EsVUFBUzZhLFNBQVQsQ0FBb0J0bkMsRUFBcEIsRUFBd0JtbkMsS0FBeEIsRUFBK0I7QUFDN0JubkMsTUFBR3FuQyxlQUFILEdBQXFCLElBQXJCO0FBQ0FGLFNBQU0zd0IsZUFBTixDQUFzQjNkLElBQXRCLENBQTRCLHVCQUF3QnV1QyxXQUFXcG5DLEVBQVgsRUFBZW1uQyxLQUFmLENBQXhCLEdBQWlELEdBQTdFO0FBQ0EsVUFBUSxTQUFTQSxNQUFNM3dCLGVBQU4sQ0FBc0J0dUIsTUFBdEIsR0FBK0IsQ0FBeEMsS0FBOEM4WCxHQUFHNGtDLFdBQUgsR0FBaUIsT0FBakIsR0FBMkIsRUFBekUsSUFBK0UsR0FBdkY7QUFDRDs7QUFFRDtBQUNBLFVBQVM0QyxPQUFULENBQWtCeG5DLEVBQWxCLEVBQXNCbW5DLEtBQXRCLEVBQTZCO0FBQzNCbm5DLE1BQUd1bkMsYUFBSCxHQUFtQixJQUFuQjtBQUNBLE9BQUl2bkMsR0FBR29pQyxFQUFILElBQVMsQ0FBQ3BpQyxHQUFHMm5DLFdBQWpCLEVBQThCO0FBQzVCLFlBQU9DLE1BQU01bkMsRUFBTixFQUFVbW5DLEtBQVYsQ0FBUDtBQUNELElBRkQsTUFFTyxJQUFJbm5DLEdBQUc0a0MsV0FBUCxFQUFvQjtBQUN6QixTQUFJOXlDLE1BQU0sRUFBVjtBQUNBLFNBQUlvTyxTQUFTRixHQUFHRSxNQUFoQjtBQUNBLFlBQU9BLE1BQVAsRUFBZTtBQUNiLFdBQUlBLE9BQU8raUMsR0FBWCxFQUFnQjtBQUNkbnhDLGVBQU1vTyxPQUFPcE8sR0FBYjtBQUNBO0FBQ0Q7QUFDRG9PLGdCQUFTQSxPQUFPQSxNQUFoQjtBQUNEO0FBQ0QsU0FBSSxDQUFDcE8sR0FBTCxFQUFVO0FBQ1J5RCxlQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMweEMsTUFBTTl2QyxJQUFOLENBQ3ZDLHNEQUR1QyxDQUF6QztBQUdBLGNBQU8rdkMsV0FBV3BuQyxFQUFYLEVBQWVtbkMsS0FBZixDQUFQO0FBQ0Q7QUFDRCxZQUFRLFFBQVNDLFdBQVdwbkMsRUFBWCxFQUFlbW5DLEtBQWYsQ0FBVCxHQUFrQyxHQUFsQyxHQUF5Q0EsTUFBTUgsTUFBTixFQUF6QyxJQUE0RGwxQyxNQUFPLE1BQU1BLEdBQWIsR0FBb0IsRUFBaEYsSUFBc0YsR0FBOUY7QUFDRCxJQWpCTSxNQWlCQTtBQUNMLFlBQU93MUMsVUFBVXRuQyxFQUFWLEVBQWNtbkMsS0FBZCxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTUyxLQUFULENBQ0U1bkMsRUFERixFQUVFbW5DLEtBRkYsRUFHRWMsTUFIRixFQUlFQyxRQUpGLEVBS0U7QUFDQWxvQyxNQUFHMm5DLFdBQUgsR0FBaUIsSUFBakIsQ0FEQSxDQUN1QjtBQUN2QixVQUFPUSxnQkFBZ0Jub0MsR0FBR3dqQyxZQUFILENBQWdCMzVDLEtBQWhCLEVBQWhCLEVBQXlDczlDLEtBQXpDLEVBQWdEYyxNQUFoRCxFQUF3REMsUUFBeEQsQ0FBUDtBQUNEOztBQUVELFVBQVNDLGVBQVQsQ0FDRUMsVUFERixFQUVFakIsS0FGRixFQUdFYyxNQUhGLEVBSUVDLFFBSkYsRUFLRTtBQUNBLE9BQUksQ0FBQ0UsV0FBV2xnRCxNQUFoQixFQUF3QjtBQUN0QixZQUFPZ2dELFlBQVksTUFBbkI7QUFDRDs7QUFFRCxPQUFJM0UsWUFBWTZFLFdBQVcxQyxLQUFYLEVBQWhCO0FBQ0EsT0FBSW5DLFVBQVVuYixHQUFkLEVBQW1CO0FBQ2pCLFlBQVEsTUFBT21iLFVBQVVuYixHQUFqQixHQUF3QixJQUF4QixHQUFnQ2lnQixjQUFjOUUsVUFBVWYsS0FBeEIsQ0FBaEMsR0FBa0UsR0FBbEUsR0FBeUUyRixnQkFBZ0JDLFVBQWhCLEVBQTRCakIsS0FBNUIsRUFBbUNjLE1BQW5DLEVBQTJDQyxRQUEzQyxDQUFqRjtBQUNELElBRkQsTUFFTztBQUNMLFlBQVEsS0FBTUcsY0FBYzlFLFVBQVVmLEtBQXhCLENBQWQ7QUFDRDs7QUFFRDtBQUNBLFlBQVM2RixhQUFULENBQXdCcm9DLEVBQXhCLEVBQTRCO0FBQzFCLFlBQU9pb0MsU0FDSEEsT0FBT2pvQyxFQUFQLEVBQVdtbkMsS0FBWCxDQURHLEdBRUhubkMsR0FBR2xMLElBQUgsR0FDRTB5QyxRQUFReG5DLEVBQVIsRUFBWW1uQyxLQUFaLENBREYsR0FFRUMsV0FBV3BuQyxFQUFYLEVBQWVtbkMsS0FBZixDQUpOO0FBS0Q7QUFDRjs7QUFFRCxVQUFTTyxNQUFULENBQ0UxbkMsRUFERixFQUVFbW5DLEtBRkYsRUFHRWMsTUFIRixFQUlFSyxTQUpGLEVBS0U7QUFDQSxPQUFJbGdCLE1BQU1wb0IsR0FBR2lqQyxHQUFiO0FBQ0EsT0FBSUMsUUFBUWxqQyxHQUFHa2pDLEtBQWY7QUFDQSxPQUFJRSxZQUFZcGpDLEdBQUdvakMsU0FBSCxHQUFnQixNQUFPcGpDLEdBQUdvakMsU0FBMUIsR0FBd0MsRUFBeEQ7QUFDQSxPQUFJQyxZQUFZcmpDLEdBQUdxakMsU0FBSCxHQUFnQixNQUFPcmpDLEdBQUdxakMsU0FBMUIsR0FBd0MsRUFBeEQ7O0FBRUEsT0FBSTl0QyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFDRjB4QyxNQUFNSixjQUFOLENBQXFCL21DLEVBQXJCLENBREUsSUFFRkEsR0FBR3NFLEdBQUgsS0FBVyxNQUZULElBR0Z0RSxHQUFHc0UsR0FBSCxLQUFXLFVBSFQsSUFJRixDQUFDdEUsR0FBR2xPLEdBSk4sRUFLRTtBQUNBcTFDLFdBQU05dkMsSUFBTixDQUNFLE1BQU8ySSxHQUFHc0UsR0FBVixHQUFpQixXQUFqQixHQUErQjQrQixLQUEvQixHQUF1QyxNQUF2QyxHQUFnRDlhLEdBQWhELEdBQXNELHFDQUF0RCxHQUNBLG1DQURBLEdBRUEsMERBSEYsRUFJRSxJQUpGLENBSU87QUFKUDtBQU1EOztBQUVEcG9CLE1BQUd5bkMsWUFBSCxHQUFrQixJQUFsQixDQXBCQSxDQW9Cd0I7QUFDeEIsVUFBTyxDQUFDYSxhQUFhLElBQWQsSUFBc0IsSUFBdEIsR0FBNkJsZ0IsR0FBN0IsR0FBbUMsSUFBbkMsR0FDTCxXQURLLEdBQ1M4YSxLQURULEdBQ2lCRSxTQURqQixHQUM2QkMsU0FEN0IsR0FDeUMsSUFEekMsR0FFSCxTQUZHLEdBRVUsQ0FBQzRFLFVBQVViLFVBQVgsRUFBdUJwbkMsRUFBdkIsRUFBMkJtbkMsS0FBM0IsQ0FGVixHQUdMLElBSEY7QUFJRDs7QUFFRCxVQUFTYSxTQUFULENBQW9CaG9DLEVBQXBCLEVBQXdCbW5DLEtBQXhCLEVBQStCO0FBQzdCLE9BQUkzNUMsT0FBTyxHQUFYOztBQUVBO0FBQ0E7QUFDQSxPQUFJd1UsT0FBT3VtQyxjQUFjdm9DLEVBQWQsRUFBa0JtbkMsS0FBbEIsQ0FBWDtBQUNBLE9BQUlubEMsSUFBSixFQUFVO0FBQUV4VSxhQUFRd1UsT0FBTyxHQUFmO0FBQXFCOztBQUVqQztBQUNBLE9BQUloQyxHQUFHbE8sR0FBUCxFQUFZO0FBQ1Z0RSxhQUFRLFNBQVV3UyxHQUFHbE8sR0FBYixHQUFvQixHQUE1QjtBQUNEO0FBQ0Q7QUFDQSxPQUFJa08sR0FBR3FaLEdBQVAsRUFBWTtBQUNWN3JCLGFBQVEsU0FBVXdTLEdBQUdxWixHQUFiLEdBQW9CLEdBQTVCO0FBQ0Q7QUFDRCxPQUFJclosR0FBR21oQixRQUFQLEVBQWlCO0FBQ2YzekIsYUFBUSxnQkFBUjtBQUNEO0FBQ0Q7QUFDQSxPQUFJd1MsR0FBR3VpQixHQUFQLEVBQVk7QUFDVi8wQixhQUFRLFdBQVI7QUFDRDtBQUNEO0FBQ0EsT0FBSXdTLEdBQUdrSyxTQUFQLEVBQWtCO0FBQ2hCMWMsYUFBUSxXQUFZd1MsR0FBR3NFLEdBQWYsR0FBc0IsS0FBOUI7QUFDRDtBQUNEO0FBQ0EsUUFBSyxJQUFJcmMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJay9DLE1BQU1MLFVBQU4sQ0FBaUI1K0MsTUFBckMsRUFBNkNELEdBQTdDLEVBQWtEO0FBQ2hEdUYsYUFBUTI1QyxNQUFNTCxVQUFOLENBQWlCNytDLENBQWpCLEVBQW9CK1gsRUFBcEIsQ0FBUjtBQUNEO0FBQ0Q7QUFDQSxPQUFJQSxHQUFHc0ksS0FBUCxFQUFjO0FBQ1o5YSxhQUFRLFlBQWFnN0MsU0FBU3hvQyxHQUFHc0ksS0FBWixDQUFiLEdBQW1DLElBQTNDO0FBQ0Q7QUFDRDtBQUNBLE9BQUl0SSxHQUFHb0IsS0FBUCxFQUFjO0FBQ1o1VCxhQUFRLGVBQWdCZzdDLFNBQVN4b0MsR0FBR29CLEtBQVosQ0FBaEIsR0FBc0MsSUFBOUM7QUFDRDtBQUNEO0FBQ0EsT0FBSXBCLEdBQUcycEIsTUFBUCxFQUFlO0FBQ2JuOEIsYUFBU3M0QyxZQUFZOWxDLEdBQUcycEIsTUFBZixFQUF1QixLQUF2QixFQUE4QndkLE1BQU05dkMsSUFBcEMsQ0FBRCxHQUE4QyxHQUF0RDtBQUNEO0FBQ0QsT0FBSTJJLEdBQUc2cEIsWUFBUCxFQUFxQjtBQUNuQnI4QixhQUFTczRDLFlBQVk5bEMsR0FBRzZwQixZQUFmLEVBQTZCLElBQTdCLEVBQW1Dc2QsTUFBTTl2QyxJQUF6QyxDQUFELEdBQW1ELEdBQTNEO0FBQ0Q7QUFDRDtBQUNBLE9BQUkySSxHQUFHMmlDLFVBQVAsRUFBbUI7QUFDakJuMUMsYUFBUSxVQUFXd1MsR0FBRzJpQyxVQUFkLEdBQTRCLEdBQXBDO0FBQ0Q7QUFDRDtBQUNBLE9BQUkzaUMsR0FBR3lPLFdBQVAsRUFBb0I7QUFDbEJqaEIsYUFBU2k3QyxlQUFlem9DLEdBQUd5TyxXQUFsQixFQUErQjA0QixLQUEvQixDQUFELEdBQTBDLEdBQWxEO0FBQ0Q7QUFDRDtBQUNBLE9BQUlubkMsR0FBR2dXLEtBQVAsRUFBYztBQUNaeG9CLGFBQVEsa0JBQW1Cd1MsR0FBR2dXLEtBQUgsQ0FBU3BtQixLQUE1QixHQUFxQyxZQUFyQyxHQUFxRG9RLEdBQUdnVyxLQUFILENBQVNjLFFBQTlELEdBQTBFLGNBQTFFLEdBQTRGOVcsR0FBR2dXLEtBQUgsQ0FBUzlGLFVBQXJHLEdBQW1ILElBQTNIO0FBQ0Q7QUFDRDtBQUNBLE9BQUlsUSxHQUFHdVcsY0FBUCxFQUF1QjtBQUNyQixTQUFJQSxpQkFBaUJteUIsa0JBQWtCMW9DLEVBQWxCLEVBQXNCbW5DLEtBQXRCLENBQXJCO0FBQ0EsU0FBSTV3QixjQUFKLEVBQW9CO0FBQ2xCL29CLGVBQVErb0IsaUJBQWlCLEdBQXpCO0FBQ0Q7QUFDRjtBQUNEL29CLFVBQU9BLEtBQUs4RSxPQUFMLENBQWEsSUFBYixFQUFtQixFQUFuQixJQUF5QixHQUFoQztBQUNBO0FBQ0EsT0FBSTBOLEdBQUcwbUMsUUFBUCxFQUFpQjtBQUNmbDVDLFlBQU93UyxHQUFHMG1DLFFBQUgsQ0FBWWw1QyxJQUFaLENBQVA7QUFDRDtBQUNEO0FBQ0EsT0FBSXdTLEdBQUd3bUMsYUFBUCxFQUFzQjtBQUNwQmg1QyxZQUFPd1MsR0FBR3dtQyxhQUFILENBQWlCaDVDLElBQWpCLENBQVA7QUFDRDtBQUNELFVBQU9BLElBQVA7QUFDRDs7QUFFRCxVQUFTKzZDLGFBQVQsQ0FBd0J2b0MsRUFBeEIsRUFBNEJtbkMsS0FBNUIsRUFBbUM7QUFDakMsT0FBSW5sQyxPQUFPaEMsR0FBR2lDLFVBQWQ7QUFDQSxPQUFJLENBQUNELElBQUwsRUFBVztBQUFFO0FBQVE7QUFDckIsT0FBSWpWLE1BQU0sY0FBVjtBQUNBLE9BQUk0N0MsYUFBYSxLQUFqQjtBQUNBLE9BQUkxZ0QsQ0FBSixFQUFPK0ssQ0FBUCxFQUFVNHpCLEdBQVYsRUFBZWdpQixXQUFmO0FBQ0EsUUFBSzNnRCxJQUFJLENBQUosRUFBTytLLElBQUlnUCxLQUFLOVosTUFBckIsRUFBNkJELElBQUkrSyxDQUFqQyxFQUFvQy9LLEdBQXBDLEVBQXlDO0FBQ3ZDMitCLFdBQU01a0IsS0FBSy9aLENBQUwsQ0FBTjtBQUNBMmdELG1CQUFjLElBQWQ7QUFDQSxTQUFJQyxNQUFNMUIsTUFBTWxsQyxVQUFOLENBQWlCMmtCLElBQUlwK0IsSUFBckIsQ0FBVjtBQUNBLFNBQUlxZ0QsR0FBSixFQUFTO0FBQ1A7QUFDQTtBQUNBRCxxQkFBYyxDQUFDLENBQUNDLElBQUk3b0MsRUFBSixFQUFRNG1CLEdBQVIsRUFBYXVnQixNQUFNOXZDLElBQW5CLENBQWhCO0FBQ0Q7QUFDRCxTQUFJdXhDLFdBQUosRUFBaUI7QUFDZkQsb0JBQWEsSUFBYjtBQUNBNTdDLGNBQU8sYUFBYzY1QixJQUFJcCtCLElBQWxCLEdBQTBCLGVBQTFCLEdBQTZDbytCLElBQUlPLE9BQWpELEdBQTRELElBQTVELElBQW9FUCxJQUFJaDNCLEtBQUosR0FBYSxhQUFjZzNCLElBQUloM0IsS0FBbEIsR0FBMkIsZUFBM0IsR0FBOENhLEtBQUtDLFNBQUwsQ0FBZWsyQixJQUFJaDNCLEtBQW5CLENBQTNELEdBQXlGLEVBQTdKLEtBQW9LZzNCLElBQUkyQyxHQUFKLEdBQVcsWUFBYTNDLElBQUkyQyxHQUFqQixHQUF3QixJQUFuQyxHQUEyQyxFQUEvTSxLQUFzTjNDLElBQUlLLFNBQUosR0FBaUIsZ0JBQWlCeDJCLEtBQUtDLFNBQUwsQ0FBZWsyQixJQUFJSyxTQUFuQixDQUFsQyxHQUFvRSxFQUExUixJQUFnUyxJQUF2UztBQUNEO0FBQ0Y7QUFDRCxPQUFJMGhCLFVBQUosRUFBZ0I7QUFDZCxZQUFPNTdDLElBQUlsRCxLQUFKLENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxJQUFtQixHQUExQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUzYrQyxpQkFBVCxDQUE0QjFvQyxFQUE1QixFQUFnQ21uQyxLQUFoQyxFQUF1QztBQUNyQyxPQUFJRCxNQUFNbG5DLEdBQUd1RixRQUFILENBQVksQ0FBWixDQUFWO0FBQ0EsT0FBSWhRLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixLQUNGdUssR0FBR3VGLFFBQUgsQ0FBWXJkLE1BQVosR0FBcUIsQ0FBckIsSUFBMEJnL0MsSUFBSS9sQyxJQUFKLEtBQWEsQ0FEckMsQ0FBSixFQUVHO0FBQ0RnbUMsV0FBTTl2QyxJQUFOLENBQVcsaUVBQVg7QUFDRDtBQUNELE9BQUk2dkMsSUFBSS9sQyxJQUFKLEtBQWEsQ0FBakIsRUFBb0I7QUFDbEIsU0FBSTJuQyxrQkFBa0I3QixTQUFTQyxHQUFULEVBQWNDLE1BQU1udkMsT0FBcEIsQ0FBdEI7QUFDQSxZQUFRLHVDQUF3Qzh3QyxnQkFBZ0IzakMsTUFBeEQsR0FBa0UscUJBQWxFLEdBQTJGMmpDLGdCQUFnQnR5QixlQUFoQixDQUFnQ3ZsQixHQUFoQyxDQUFvQyxVQUFVdzdCLElBQVYsRUFBZ0I7QUFBRSxjQUFRLGdCQUFnQkEsSUFBaEIsR0FBdUIsR0FBL0I7QUFBc0MsTUFBNUYsRUFBOEZ0NEIsSUFBOUYsQ0FBbUcsR0FBbkcsQ0FBM0YsR0FBc00sSUFBOU07QUFDRDtBQUNGOztBQUVELFVBQVNzMEMsY0FBVCxDQUNFLzhCLEtBREYsRUFFRXk3QixLQUZGLEVBR0U7QUFDQSxVQUFRLHFCQUFzQnQ0QyxPQUFPQyxJQUFQLENBQVk0YyxLQUFaLEVBQW1CemEsR0FBbkIsQ0FBdUIsVUFBVWEsR0FBVixFQUFlO0FBQ2hFLFlBQU9pM0MsY0FBY2ozQyxHQUFkLEVBQW1CNFosTUFBTTVaLEdBQU4sQ0FBbkIsRUFBK0JxMUMsS0FBL0IsQ0FBUDtBQUNELElBRjJCLEVBRXpCaHpDLElBRnlCLENBRXBCLEdBRm9CLENBQXRCLEdBRVUsSUFGbEI7QUFHRDs7QUFFRCxVQUFTNDBDLGFBQVQsQ0FDRWozQyxHQURGLEVBRUVrTyxFQUZGLEVBR0VtbkMsS0FIRixFQUlFO0FBQ0EsT0FBSW5uQyxHQUFHaWpDLEdBQUgsSUFBVSxDQUFDampDLEdBQUd5bkMsWUFBbEIsRUFBZ0M7QUFDOUIsWUFBT3VCLGlCQUFpQmwzQyxHQUFqQixFQUFzQmtPLEVBQXRCLEVBQTBCbW5DLEtBQTFCLENBQVA7QUFDRDtBQUNELFVBQU8sVUFBVXIxQyxHQUFWLEdBQWdCLGVBQWhCLEdBQW1DbkIsT0FBT3FQLEdBQUdvcUIsUUFBSCxDQUFZNmUsS0FBbkIsQ0FBbkMsR0FBZ0UsSUFBaEUsR0FDTCxTQURLLElBQ1FqcEMsR0FBR3NFLEdBQUgsS0FBVyxVQUFYLEdBQ1R1akMsWUFBWTduQyxFQUFaLEVBQWdCbW5DLEtBQWhCLEtBQTBCLFFBRGpCLEdBRVRDLFdBQVdwbkMsRUFBWCxFQUFlbW5DLEtBQWYsQ0FIQyxJQUd3QixJQUgvQjtBQUlEOztBQUVELFVBQVM2QixnQkFBVCxDQUNFbDNDLEdBREYsRUFFRWtPLEVBRkYsRUFHRW1uQyxLQUhGLEVBSUU7QUFDQSxPQUFJL2UsTUFBTXBvQixHQUFHaWpDLEdBQWI7QUFDQSxPQUFJQyxRQUFRbGpDLEdBQUdrakMsS0FBZjtBQUNBLE9BQUlFLFlBQVlwakMsR0FBR29qQyxTQUFILEdBQWdCLE1BQU9wakMsR0FBR29qQyxTQUExQixHQUF3QyxFQUF4RDtBQUNBLE9BQUlDLFlBQVlyakMsR0FBR3FqQyxTQUFILEdBQWdCLE1BQU9yakMsR0FBR3FqQyxTQUExQixHQUF3QyxFQUF4RDtBQUNBcmpDLE1BQUd5bkMsWUFBSCxHQUFrQixJQUFsQixDQUxBLENBS3dCO0FBQ3hCLFVBQU8sU0FBU3JmLEdBQVQsR0FBZSxJQUFmLEdBQ0wsV0FESyxHQUNTOGEsS0FEVCxHQUNpQkUsU0FEakIsR0FDNkJDLFNBRDdCLEdBQ3lDLElBRHpDLEdBRUgsU0FGRyxHQUVVMEYsY0FBY2ozQyxHQUFkLEVBQW1Ca08sRUFBbkIsRUFBdUJtbkMsS0FBdkIsQ0FGVixHQUdMLElBSEY7QUFJRDs7QUFFRCxVQUFTVSxXQUFULENBQ0U3bkMsRUFERixFQUVFbW5DLEtBRkYsRUFHRStCLFNBSEYsRUFJRUMsYUFKRixFQUtFQyxVQUxGLEVBTUU7QUFDQSxPQUFJN2pDLFdBQVd2RixHQUFHdUYsUUFBbEI7QUFDQSxPQUFJQSxTQUFTcmQsTUFBYixFQUFxQjtBQUNuQixTQUFJbWhELE9BQU85akMsU0FBUyxDQUFULENBQVg7QUFDQTtBQUNBLFNBQUlBLFNBQVNyZCxNQUFULEtBQW9CLENBQXBCLElBQ0ZtaEQsS0FBS3BHLEdBREgsSUFFRm9HLEtBQUsva0MsR0FBTCxLQUFhLFVBRlgsSUFHRitrQyxLQUFLL2tDLEdBQUwsS0FBYSxNQUhmLEVBSUU7QUFDQSxjQUFPLENBQUM2a0MsaUJBQWlCL0IsVUFBbEIsRUFBOEJpQyxJQUE5QixFQUFvQ2xDLEtBQXBDLENBQVA7QUFDRDtBQUNELFNBQUlsd0Isb0JBQW9CaXlCLFlBQ3BCSSxxQkFBcUIvakMsUUFBckIsRUFBK0I0aEMsTUFBTUosY0FBckMsQ0FEb0IsR0FFcEIsQ0FGSjtBQUdBLFNBQUk4QixNQUFNTyxjQUFjRyxPQUF4QjtBQUNBLFlBQVEsTUFBT2hrQyxTQUFTdFUsR0FBVCxDQUFhLFVBQVV1QixDQUFWLEVBQWE7QUFBRSxjQUFPcTJDLElBQUlyMkMsQ0FBSixFQUFPMjBDLEtBQVAsQ0FBUDtBQUF1QixNQUFuRCxFQUFxRGh6QyxJQUFyRCxDQUEwRCxHQUExRCxDQUFQLEdBQXlFLEdBQXpFLElBQWdGOGlCLG9CQUFxQixNQUFNQSxpQkFBM0IsR0FBZ0QsRUFBaEksQ0FBUjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTcXlCLG9CQUFULENBQ0UvakMsUUFERixFQUVFd2hDLGNBRkYsRUFHRTtBQUNBLE9BQUloNkMsTUFBTSxDQUFWO0FBQ0EsUUFBSyxJQUFJOUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc2QsU0FBU3JkLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4QyxTQUFJK1gsS0FBS3VGLFNBQVN0ZCxDQUFULENBQVQ7QUFDQSxTQUFJK1gsR0FBR21CLElBQUgsS0FBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNEO0FBQ0QsU0FBSXFvQyxtQkFBbUJ4cEMsRUFBbkIsS0FDQ0EsR0FBR3dqQyxZQUFILElBQW1CeGpDLEdBQUd3akMsWUFBSCxDQUFnQmpOLElBQWhCLENBQXFCLFVBQVUvakMsQ0FBVixFQUFhO0FBQUUsY0FBT2czQyxtQkFBbUJoM0MsRUFBRWd3QyxLQUFyQixDQUFQO0FBQXFDLE1BQXpFLENBRHhCLEVBQ3FHO0FBQ25HejFDLGFBQU0sQ0FBTjtBQUNBO0FBQ0Q7QUFDRCxTQUFJZzZDLGVBQWUvbUMsRUFBZixLQUNDQSxHQUFHd2pDLFlBQUgsSUFBbUJ4akMsR0FBR3dqQyxZQUFILENBQWdCak4sSUFBaEIsQ0FBcUIsVUFBVS9qQyxDQUFWLEVBQWE7QUFBRSxjQUFPdTBDLGVBQWV2MEMsRUFBRWd3QyxLQUFqQixDQUFQO0FBQWlDLE1BQXJFLENBRHhCLEVBQ2lHO0FBQy9GejFDLGFBQU0sQ0FBTjtBQUNEO0FBQ0Y7QUFDRCxVQUFPQSxHQUFQO0FBQ0Q7O0FBRUQsVUFBU3k4QyxrQkFBVCxDQUE2QnhwQyxFQUE3QixFQUFpQztBQUMvQixVQUFPQSxHQUFHaWpDLEdBQUgsS0FBV3A3QyxTQUFYLElBQXdCbVksR0FBR3NFLEdBQUgsS0FBVyxVQUFuQyxJQUFpRHRFLEdBQUdzRSxHQUFILEtBQVcsTUFBbkU7QUFDRDs7QUFFRCxVQUFTaWxDLE9BQVQsQ0FBa0I1aUMsSUFBbEIsRUFBd0J3Z0MsS0FBeEIsRUFBK0I7QUFDN0IsT0FBSXhnQyxLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLFlBQU9pbUMsV0FBV3pnQyxJQUFYLEVBQWlCd2dDLEtBQWpCLENBQVA7QUFDRCxJQUFDLElBQUl4Z0MsS0FBS3hGLElBQUwsS0FBYyxDQUFkLElBQW1Cd0YsS0FBS1IsU0FBNUIsRUFBdUM7QUFDdkMsWUFBT3NqQyxXQUFXOWlDLElBQVgsQ0FBUDtBQUNELElBRkMsTUFFSztBQUNMLFlBQU8raUMsUUFBUS9pQyxJQUFSLENBQVA7QUFDRDtBQUNGOztBQUVELFVBQVMraUMsT0FBVCxDQUFrQmxrQyxJQUFsQixFQUF3QjtBQUN0QixVQUFRLFNBQVNBLEtBQUtyRSxJQUFMLEtBQWMsQ0FBZCxHQUNicUUsS0FBSzBLLFVBRFEsQ0FDRztBQURILEtBRWJ5NUIseUJBQXlCbDVDLEtBQUtDLFNBQUwsQ0FBZThVLEtBQUtBLElBQXBCLENBQXpCLENBRkksSUFFbUQsR0FGM0Q7QUFHRDs7QUFFRCxVQUFTaWtDLFVBQVQsQ0FBcUJ0TSxPQUFyQixFQUE4QjtBQUM1QixVQUFRLFFBQVMxc0MsS0FBS0MsU0FBTCxDQUFleXNDLFFBQVEzM0IsSUFBdkIsQ0FBVCxHQUF5QyxHQUFqRDtBQUNEOztBQUVELFVBQVNzaUMsT0FBVCxDQUFrQjluQyxFQUFsQixFQUFzQm1uQyxLQUF0QixFQUE2QjtBQUMzQixPQUFJMUQsV0FBV3pqQyxHQUFHeWpDLFFBQUgsSUFBZSxXQUE5QjtBQUNBLE9BQUlsK0IsV0FBV3NpQyxZQUFZN25DLEVBQVosRUFBZ0JtbkMsS0FBaEIsQ0FBZjtBQUNBLE9BQUlwNkMsTUFBTSxRQUFRMDJDLFFBQVIsSUFBb0JsK0IsV0FBWSxNQUFNQSxRQUFsQixHQUE4QixFQUFsRCxDQUFWO0FBQ0EsT0FBSStDLFFBQVF0SSxHQUFHc0ksS0FBSCxJQUFhLE1BQU90SSxHQUFHc0ksS0FBSCxDQUFTclgsR0FBVCxDQUFhLFVBQVU4QixDQUFWLEVBQWE7QUFBRSxZQUFTVixTQUFTVSxFQUFFdkssSUFBWCxDQUFELEdBQXFCLEdBQXJCLEdBQTRCdUssRUFBRW5ELEtBQXRDO0FBQWdELElBQTVFLEVBQThFdUUsSUFBOUUsQ0FBbUYsR0FBbkYsQ0FBUCxHQUFrRyxHQUEzSDtBQUNBLE9BQUl5MUMsVUFBVTVwQyxHQUFHb3FCLFFBQUgsQ0FBWSxRQUFaLENBQWQ7QUFDQSxPQUFJLENBQUM5aEIsU0FBU3NoQyxPQUFWLEtBQXNCLENBQUNya0MsUUFBM0IsRUFBcUM7QUFDbkN4WSxZQUFPLE9BQVA7QUFDRDtBQUNELE9BQUl1YixLQUFKLEVBQVc7QUFDVHZiLFlBQU8sTUFBTXViLEtBQWI7QUFDRDtBQUNELE9BQUlzaEMsT0FBSixFQUFhO0FBQ1g3OEMsWUFBTyxDQUFDdWIsUUFBUSxFQUFSLEdBQWEsT0FBZCxJQUF5QixHQUF6QixHQUErQnNoQyxPQUF0QztBQUNEO0FBQ0QsVUFBTzc4QyxNQUFNLEdBQWI7QUFDRDs7QUFFRDtBQUNBLFVBQVNnN0MsWUFBVCxDQUNFOEIsYUFERixFQUVFN3BDLEVBRkYsRUFHRW1uQyxLQUhGLEVBSUU7QUFDQSxPQUFJNWhDLFdBQVd2RixHQUFHdVcsY0FBSCxHQUFvQixJQUFwQixHQUEyQnN4QixZQUFZN25DLEVBQVosRUFBZ0JtbkMsS0FBaEIsRUFBdUIsSUFBdkIsQ0FBMUM7QUFDQSxVQUFRLFFBQVEwQyxhQUFSLEdBQXdCLEdBQXhCLEdBQStCN0IsVUFBVWhvQyxFQUFWLEVBQWNtbkMsS0FBZCxDQUEvQixJQUF3RDVoQyxXQUFZLE1BQU1BLFFBQWxCLEdBQThCLEVBQXRGLElBQTRGLEdBQXBHO0FBQ0Q7O0FBRUQsVUFBU2lqQyxRQUFULENBQW1CcG5DLEtBQW5CLEVBQTBCO0FBQ3hCLE9BQUlyVSxNQUFNLEVBQVY7QUFDQSxRQUFLLElBQUk5RSxJQUFJLENBQWIsRUFBZ0JBLElBQUltWixNQUFNbFosTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ3JDLFNBQUk4YSxPQUFPM0IsTUFBTW5aLENBQU4sQ0FBWDtBQUNBOEUsWUFBTyxPQUFRZ1csS0FBS3ZhLElBQWIsR0FBcUIsS0FBckIsR0FBOEJtaEQseUJBQXlCNW1DLEtBQUtuVCxLQUE5QixDQUE5QixHQUFzRSxHQUE3RTtBQUNEO0FBQ0QsVUFBTzdDLElBQUlsRCxLQUFKLENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFTOC9DLHdCQUFULENBQW1DbmtDLElBQW5DLEVBQXlDO0FBQ3ZDLFVBQU9BLEtBQ0psVCxPQURJLENBQ0ksU0FESixFQUNlLFNBRGYsRUFFSkEsT0FGSSxDQUVJLFNBRkosRUFFZSxTQUZmLENBQVA7QUFHRDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSXczQyxzQkFBc0IsSUFBSWx0QixNQUFKLENBQVcsUUFBUSxDQUMzQyw0RUFDQSxxRUFEQSxHQUVBLHNEQUgyQyxFQUkzQ3hyQixLQUoyQyxDQUlyQyxHQUpxQyxFQUloQytDLElBSmdDLENBSTNCLFNBSjJCLENBQVIsR0FJTixLQUpMLENBQTFCOztBQU1BO0FBQ0EsS0FBSTQxQyxtQkFBbUIsSUFBSW50QixNQUFKLENBQVcsUUFDaEMsb0JBRHdDLENBRXhDeHJCLEtBRndDLENBRWxDLEdBRmtDLEVBRTdCK0MsSUFGNkIsQ0FFeEIsdUJBRndCLENBQVIsR0FFVyxtQkFGdEIsQ0FBdkI7O0FBSUE7QUFDQSxLQUFJNjFDLFVBQVUsa0JBQWQ7O0FBRUE7QUFDQSxLQUFJQyxnQkFBZ0IsZ0dBQXBCOztBQUVBO0FBQ0EsVUFBU0MsWUFBVCxDQUF1QmhELEdBQXZCLEVBQTRCO0FBQzFCLE9BQUlpRCxTQUFTLEVBQWI7QUFDQSxPQUFJakQsR0FBSixFQUFTO0FBQ1BrRCxlQUFVbEQsR0FBVixFQUFlaUQsTUFBZjtBQUNEO0FBQ0QsVUFBT0EsTUFBUDtBQUNEOztBQUVELFVBQVNDLFNBQVQsQ0FBb0J6akMsSUFBcEIsRUFBMEJ3akMsTUFBMUIsRUFBa0M7QUFDaEMsT0FBSXhqQyxLQUFLeEYsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLFVBQUssSUFBSTNZLElBQVQsSUFBaUJtZSxLQUFLeWpCLFFBQXRCLEVBQWdDO0FBQzlCLFdBQUl5VixNQUFNMW9DLElBQU4sQ0FBVzNPLElBQVgsQ0FBSixFQUFzQjtBQUNwQixhQUFJb0gsUUFBUStXLEtBQUt5akIsUUFBTCxDQUFjNWhDLElBQWQsQ0FBWjtBQUNBLGFBQUlvSCxLQUFKLEVBQVc7QUFDVCxlQUFJcEgsU0FBUyxPQUFiLEVBQXNCO0FBQ3BCNmhELHNCQUFTMWpDLElBQVQsRUFBZ0IsYUFBYS9XLEtBQWIsR0FBcUIsSUFBckMsRUFBNEN1NkMsTUFBNUM7QUFDRCxZQUZELE1BRU8sSUFBSXZLLEtBQUt6b0MsSUFBTCxDQUFVM08sSUFBVixDQUFKLEVBQXFCO0FBQzFCOGhELHdCQUFXMTZDLEtBQVgsRUFBbUJwSCxPQUFPLEtBQVAsR0FBZW9ILEtBQWYsR0FBdUIsSUFBMUMsRUFBaUR1NkMsTUFBakQ7QUFDRCxZQUZNLE1BRUE7QUFDTEksNkJBQWdCMzZDLEtBQWhCLEVBQXdCcEgsT0FBTyxLQUFQLEdBQWVvSCxLQUFmLEdBQXVCLElBQS9DLEVBQXNEdTZDLE1BQXREO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxTQUFJeGpDLEtBQUtwQixRQUFULEVBQW1CO0FBQ2pCLFlBQUssSUFBSXRkLElBQUksQ0FBYixFQUFnQkEsSUFBSTBlLEtBQUtwQixRQUFMLENBQWNyZCxNQUFsQyxFQUEwQ0QsR0FBMUMsRUFBK0M7QUFDN0NtaUQsbUJBQVV6akMsS0FBS3BCLFFBQUwsQ0FBY3RkLENBQWQsQ0FBVixFQUE0QmtpRCxNQUE1QjtBQUNEO0FBQ0Y7QUFDRixJQXBCRCxNQW9CTyxJQUFJeGpDLEtBQUt4RixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDMUJvcEMscUJBQWdCNWpDLEtBQUt1SixVQUFyQixFQUFpQ3ZKLEtBQUtuQixJQUF0QyxFQUE0QzJrQyxNQUE1QztBQUNEO0FBQ0Y7O0FBRUQsVUFBU0csVUFBVCxDQUFxQmxpQixHQUFyQixFQUEwQjVpQixJQUExQixFQUFnQzJrQyxNQUFoQyxFQUF3QztBQUN0QyxPQUFJSyxVQUFVcGlCLElBQUk5MUIsT0FBSixDQUFZMjNDLGFBQVosRUFBMkIsRUFBM0IsQ0FBZDtBQUNBLE9BQUlRLGVBQWVELFFBQVFseUMsS0FBUixDQUFjeXhDLGdCQUFkLENBQW5CO0FBQ0EsT0FBSVUsZ0JBQWdCRCxRQUFROTNDLE1BQVIsQ0FBZSszQyxhQUFheCtDLEtBQWIsR0FBcUIsQ0FBcEMsTUFBMkMsR0FBL0QsRUFBb0U7QUFDbEVrK0MsWUFBT3R4QyxJQUFQLENBQ0UsNkRBQ0EsSUFEQSxHQUNRNHhDLGFBQWEsQ0FBYixDQURSLEdBQzJCLG1CQUQzQixHQUNrRGpsQyxLQUFLdWpCLElBQUwsRUFGcEQ7QUFJRDtBQUNEd2hCLG1CQUFnQm5pQixHQUFoQixFQUFxQjVpQixJQUFyQixFQUEyQjJrQyxNQUEzQjtBQUNEOztBQUVELFVBQVNFLFFBQVQsQ0FBbUIxakMsSUFBbkIsRUFBeUJuQixJQUF6QixFQUErQjJrQyxNQUEvQixFQUF1QztBQUNyQ0ksbUJBQWdCNWpDLEtBQUtzOEIsR0FBTCxJQUFZLEVBQTVCLEVBQWdDejlCLElBQWhDLEVBQXNDMmtDLE1BQXRDO0FBQ0FPLG1CQUFnQi9qQyxLQUFLdThCLEtBQXJCLEVBQTRCLGFBQTVCLEVBQTJDMTlCLElBQTNDLEVBQWlEMmtDLE1BQWpEO0FBQ0FPLG1CQUFnQi9qQyxLQUFLeThCLFNBQXJCLEVBQWdDLGdCQUFoQyxFQUFrRDU5QixJQUFsRCxFQUF3RDJrQyxNQUF4RDtBQUNBTyxtQkFBZ0IvakMsS0FBSzA4QixTQUFyQixFQUFnQyxnQkFBaEMsRUFBa0Q3OUIsSUFBbEQsRUFBd0Qya0MsTUFBeEQ7QUFDRDs7QUFFRCxVQUFTTyxlQUFULENBQTBCQyxLQUExQixFQUFpQ3hwQyxJQUFqQyxFQUF1Q3FFLElBQXZDLEVBQTZDMmtDLE1BQTdDLEVBQXFEO0FBQ25ELE9BQUksT0FBT1EsS0FBUCxLQUFpQixRQUFqQixJQUE2QixDQUFDWCxRQUFRN3lDLElBQVIsQ0FBYXd6QyxLQUFiLENBQWxDLEVBQXVEO0FBQ3JEUixZQUFPdHhDLElBQVAsQ0FBYSxhQUFhc0ksSUFBYixHQUFvQixLQUFwQixHQUE0QndwQyxLQUE1QixHQUFvQyxvQkFBcEMsR0FBNERubEMsS0FBS3VqQixJQUFMLEVBQXpFO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTd2hCLGVBQVQsQ0FBMEJuaUIsR0FBMUIsRUFBK0I1aUIsSUFBL0IsRUFBcUMya0MsTUFBckMsRUFBNkM7QUFDM0MsT0FBSTtBQUNGLFNBQUk5aUQsUUFBSixDQUFjLFlBQVkrZ0MsR0FBMUI7QUFDRCxJQUZELENBRUUsT0FBTzVnQyxDQUFQLEVBQVU7QUFDVixTQUFJaWpELGVBQWVyaUIsSUFBSTkxQixPQUFKLENBQVkyM0MsYUFBWixFQUEyQixFQUEzQixFQUErQjN4QyxLQUEvQixDQUFxQ3d4QyxtQkFBckMsQ0FBbkI7QUFDQSxTQUFJVyxZQUFKLEVBQWtCO0FBQ2hCTixjQUFPdHhDLElBQVAsQ0FDRSxzREFDQSxJQURBLEdBQ1E0eEMsYUFBYSxDQUFiLENBRFIsR0FDMkIsbUJBRDNCLEdBQ2tEamxDLEtBQUt1akIsSUFBTCxFQUZwRDtBQUlELE1BTEQsTUFLTztBQUNMb2hCLGNBQU90eEMsSUFBUCxDQUFhLHlCQUEwQjJNLEtBQUt1akIsSUFBTCxFQUF2QztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7QUFFQSxVQUFTNmhCLGNBQVQsQ0FBeUJuZSxJQUF6QixFQUErQjBkLE1BQS9CLEVBQXVDO0FBQ3JDLE9BQUk7QUFDRixZQUFPLElBQUk5aUQsUUFBSixDQUFhb2xDLElBQWIsQ0FBUDtBQUNELElBRkQsQ0FFRSxPQUFPMXpCLEdBQVAsRUFBWTtBQUNab3hDLFlBQU90eEMsSUFBUCxDQUFZLEVBQUVFLEtBQUtBLEdBQVAsRUFBWTB6QixNQUFNQSxJQUFsQixFQUFaO0FBQ0EsWUFBTzVsQyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFTZ2tELHlCQUFULENBQW9DQyxPQUFwQyxFQUE2QztBQUMzQyxPQUFJNzRDLFFBQVFwRCxPQUFPcUMsTUFBUCxDQUFjLElBQWQsQ0FBWjs7QUFFQSxVQUFPLFNBQVM2NUMsa0JBQVQsQ0FDTGo5QixRQURLLEVBRUw5VixPQUZLLEVBR0xKLEVBSEssRUFJTDtBQUNBSSxlQUFVQSxXQUFXLEVBQXJCOztBQUVBO0FBQ0EsU0FBSXpDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBLFdBQUk7QUFDRixhQUFJcE8sUUFBSixDQUFhLFVBQWI7QUFDRCxRQUZELENBRUUsT0FBT0csQ0FBUCxFQUFVO0FBQ1YsYUFBSUEsRUFBRXVJLFFBQUYsR0FBYXVJLEtBQWIsQ0FBbUIsaUJBQW5CLENBQUosRUFBMkM7QUFDekNqQixnQkFDRSxpRUFDQSx1RUFEQSxHQUVBLGtFQUZBLEdBR0EsaUVBSEEsR0FJQSxrQ0FMRjtBQU9EO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBLFNBQUl2RixNQUFNa0csUUFBUWdqQyxVQUFSLEdBQ05ycUMsT0FBT3FILFFBQVFnakMsVUFBZixJQUE2Qmx0QixRQUR2QixHQUVOQSxRQUZKO0FBR0EsU0FBSTdiLE1BQU1ILEdBQU4sQ0FBSixFQUFnQjtBQUNkLGNBQU9HLE1BQU1ILEdBQU4sQ0FBUDtBQUNEOztBQUVEO0FBQ0EsU0FBSWs1QyxXQUFXRixRQUFRaDlCLFFBQVIsRUFBa0I5VixPQUFsQixDQUFmOztBQUVBO0FBQ0EsU0FBSXpDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFJdTFDLFNBQVNiLE1BQVQsSUFBbUJhLFNBQVNiLE1BQVQsQ0FBZ0JqaUQsTUFBdkMsRUFBK0M7QUFDN0NtUCxjQUNFLGtDQUFrQ3lXLFFBQWxDLEdBQTZDLE1BQTdDLEdBQ0FrOUIsU0FBU2IsTUFBVCxDQUFnQmw1QyxHQUFoQixDQUFvQixVQUFVekosQ0FBVixFQUFhO0FBQUUsa0JBQVEsT0FBT0EsQ0FBZjtBQUFvQixVQUF2RCxFQUF5RDJNLElBQXpELENBQThELElBQTlELENBREEsR0FDc0UsSUFGeEUsRUFHRXlELEVBSEY7QUFLRDtBQUNELFdBQUlvekMsU0FBU0MsSUFBVCxJQUFpQkQsU0FBU0MsSUFBVCxDQUFjL2lELE1BQW5DLEVBQTJDO0FBQ3pDOGlELGtCQUFTQyxJQUFULENBQWNsOEMsT0FBZCxDQUFzQixVQUFVNEksR0FBVixFQUFlO0FBQUUsa0JBQU9MLElBQUlLLEdBQUosRUFBU0MsRUFBVCxDQUFQO0FBQXNCLFVBQTdEO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFNBQUk3SyxNQUFNLEVBQVY7QUFDQSxTQUFJbStDLGNBQWMsRUFBbEI7QUFDQW4rQyxTQUFJb1ksTUFBSixHQUFheWxDLGVBQWVJLFNBQVM3bEMsTUFBeEIsRUFBZ0MrbEMsV0FBaEMsQ0FBYjtBQUNBbitDLFNBQUl5cEIsZUFBSixHQUFzQncwQixTQUFTeDBCLGVBQVQsQ0FBeUJ2bEIsR0FBekIsQ0FBNkIsVUFBVXc3QixJQUFWLEVBQWdCO0FBQ2pFLGNBQU9tZSxlQUFlbmUsSUFBZixFQUFxQnllLFdBQXJCLENBQVA7QUFDRCxNQUZxQixDQUF0Qjs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUkzMUMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFdBQUksQ0FBQyxDQUFDdTFDLFNBQVNiLE1BQVYsSUFBb0IsQ0FBQ2EsU0FBU2IsTUFBVCxDQUFnQmppRCxNQUF0QyxLQUFpRGdqRCxZQUFZaGpELE1BQWpFLEVBQXlFO0FBQ3ZFbVAsY0FDRSw0Q0FDQTZ6QyxZQUFZajZDLEdBQVosQ0FBZ0IsVUFBVW9vQixHQUFWLEVBQWU7QUFDN0IsZUFBSXRnQixNQUFNc2dCLElBQUl0Z0IsR0FBZDtBQUNBLGVBQUkwekIsT0FBT3BULElBQUlvVCxJQUFmOztBQUVBLGtCQUFTMXpCLElBQUloSixRQUFKLEVBQUQsR0FBbUIsU0FBbkIsR0FBK0IwOEIsSUFBL0IsR0FBc0MsSUFBOUM7QUFDSCxVQUxDLEVBS0N0NEIsSUFMRCxDQUtNLElBTE4sQ0FGRixFQVFFeUQsRUFSRjtBQVVEO0FBQ0Y7O0FBRUQsWUFBUTNGLE1BQU1ILEdBQU4sSUFBYS9FLEdBQXJCO0FBQ0QsSUE5RUQ7QUErRUQ7O0FBRUQ7O0FBRUEsVUFBU28rQyxxQkFBVCxDQUFnQ0MsV0FBaEMsRUFBNkM7QUFDM0MsVUFBTyxTQUFTQyxjQUFULENBQXlCaFAsV0FBekIsRUFBc0M7QUFDM0MsY0FBU3lPLE9BQVQsQ0FDRWg5QixRQURGLEVBRUU5VixPQUZGLEVBR0U7QUFDQSxXQUFJc3pDLGVBQWV6OEMsT0FBT3FDLE1BQVAsQ0FBY21yQyxXQUFkLENBQW5CO0FBQ0EsV0FBSThOLFNBQVMsRUFBYjtBQUNBLFdBQUljLE9BQU8sRUFBWDtBQUNBSyxvQkFBYWowQyxJQUFiLEdBQW9CLFVBQVVNLEdBQVYsRUFBZUwsR0FBZixFQUFvQjtBQUN0QyxVQUFDQSxNQUFNMnpDLElBQU4sR0FBYWQsTUFBZCxFQUFzQnR4QyxJQUF0QixDQUEyQmxCLEdBQTNCO0FBQ0QsUUFGRDs7QUFJQSxXQUFJSyxPQUFKLEVBQWE7QUFDWDtBQUNBLGFBQUlBLFFBQVFsRSxPQUFaLEVBQXFCO0FBQ25CdzNDLHdCQUFheDNDLE9BQWIsR0FDRSxDQUFDdW9DLFlBQVl2b0MsT0FBWixJQUF1QixFQUF4QixFQUE0QkcsTUFBNUIsQ0FBbUMrRCxRQUFRbEUsT0FBM0MsQ0FERjtBQUVEO0FBQ0Q7QUFDQSxhQUFJa0UsUUFBUWlLLFVBQVosRUFBd0I7QUFDdEJxcEMsd0JBQWFycEMsVUFBYixHQUEwQjNPLE9BQ3hCekUsT0FBT3FDLE1BQVAsQ0FBY21yQyxZQUFZcDZCLFVBQTFCLENBRHdCLEVBRXhCakssUUFBUWlLLFVBRmdCLENBQTFCO0FBSUQ7QUFDRDtBQUNBLGNBQUssSUFBSW5RLEdBQVQsSUFBZ0JrRyxPQUFoQixFQUF5QjtBQUN2QixlQUFJbEcsUUFBUSxTQUFSLElBQXFCQSxRQUFRLFlBQWpDLEVBQStDO0FBQzdDdzVDLDBCQUFheDVDLEdBQWIsSUFBb0JrRyxRQUFRbEcsR0FBUixDQUFwQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFJazVDLFdBQVdJLFlBQVl0OUIsUUFBWixFQUFzQnc5QixZQUF0QixDQUFmO0FBQ0EsV0FBSS8xQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMwMEMsZ0JBQU90eEMsSUFBUCxDQUFZcFIsS0FBWixDQUFrQjBpRCxNQUFsQixFQUEwQkQsYUFBYWMsU0FBUzlELEdBQXRCLENBQTFCO0FBQ0Q7QUFDRDhELGdCQUFTYixNQUFULEdBQWtCQSxNQUFsQjtBQUNBYSxnQkFBU0MsSUFBVCxHQUFnQkEsSUFBaEI7QUFDQSxjQUFPRCxRQUFQO0FBQ0Q7O0FBRUQsWUFBTztBQUNMRixnQkFBU0EsT0FESjtBQUVMQywyQkFBb0JGLDBCQUEwQkMsT0FBMUI7QUFGZixNQUFQO0FBSUQsSUE5Q0Q7QUErQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSU8saUJBQWlCRixzQkFBc0IsU0FBU0MsV0FBVCxDQUN6Q3Q5QixRQUR5QyxFQUV6QzlWLE9BRnlDLEVBR3pDO0FBQ0EsT0FBSWt2QyxNQUFNdkcsTUFBTTd5QixTQUFTaWIsSUFBVCxFQUFOLEVBQXVCL3dCLE9BQXZCLENBQVY7QUFDQXVzQyxZQUFTMkMsR0FBVCxFQUFjbHZDLE9BQWQ7QUFDQSxPQUFJeTBCLE9BQU93YSxTQUFTQyxHQUFULEVBQWNsdkMsT0FBZCxDQUFYO0FBQ0EsVUFBTztBQUNMa3ZDLFVBQUtBLEdBREE7QUFFTC9oQyxhQUFRc25CLEtBQUt0bkIsTUFGUjtBQUdMcVIsc0JBQWlCaVcsS0FBS2pXO0FBSGpCLElBQVA7QUFLRCxFQVpvQixDQUFyQjs7QUFjQTs7QUFFQSxLQUFJKzBCLFFBQVFGLGVBQWVoUCxXQUFmLENBQVo7QUFDQSxLQUFJME8scUJBQXFCUSxNQUFNUixrQkFBL0I7O0FBRUE7O0FBRUEsS0FBSVMsZUFBZXo1QyxPQUFPLFVBQVVsRixFQUFWLEVBQWM7QUFDdEMsT0FBSW1ULEtBQUt2VCxNQUFNSSxFQUFOLENBQVQ7QUFDQSxVQUFPbVQsTUFBTUEsR0FBRzI2QixTQUFoQjtBQUNELEVBSGtCLENBQW5COztBQUtBLEtBQUk4USxRQUFRbHdCLE1BQU1qMEIsU0FBTixDQUFnQjh0QixNQUE1QjtBQUNBbUcsT0FBTWowQixTQUFOLENBQWdCOHRCLE1BQWhCLEdBQXlCLFVBQ3ZCcFYsRUFEdUIsRUFFdkI2TSxTQUZ1QixFQUd2QjtBQUNBN00sUUFBS0EsTUFBTXZULE1BQU11VCxFQUFOLENBQVg7O0FBRUE7QUFDQSxPQUFJQSxPQUFPM1csU0FBUyt2QyxJQUFoQixJQUF3QnA1QixPQUFPM1csU0FBU3FpRCxlQUE1QyxFQUE2RDtBQUMzRG4yQyxhQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUM0QixLQUN2QywwRUFEdUMsQ0FBekM7QUFHQSxZQUFPLElBQVA7QUFDRDs7QUFFRCxPQUFJVyxVQUFVLEtBQUtFLFFBQW5CO0FBQ0E7QUFDQSxPQUFJLENBQUNGLFFBQVFtTixNQUFiLEVBQXFCO0FBQ25CLFNBQUkySSxXQUFXOVYsUUFBUThWLFFBQXZCO0FBQ0EsU0FBSUEsUUFBSixFQUFjO0FBQ1osV0FBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLGFBQUlBLFNBQVNwYixNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQTNCLEVBQWdDO0FBQzlCb2Isc0JBQVcwOUIsYUFBYTE5QixRQUFiLENBQVg7QUFDQTtBQUNBLGVBQUl2WSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQ3FZLFFBQTlDLEVBQXdEO0FBQ3REelcsa0JBQ0csNkNBQThDVyxRQUFROFYsUUFEekQsRUFFRSxJQUZGO0FBSUQ7QUFDRjtBQUNGLFFBWEQsTUFXTyxJQUFJQSxTQUFTMlgsUUFBYixFQUF1QjtBQUM1QjNYLG9CQUFXQSxTQUFTNnNCLFNBQXBCO0FBQ0QsUUFGTSxNQUVBO0FBQ0wsYUFBSXBsQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM0QixnQkFBSyw2QkFBNkJ5VyxRQUFsQyxFQUE0QyxJQUE1QztBQUNEO0FBQ0QsZ0JBQU8sSUFBUDtBQUNEO0FBQ0YsTUFwQkQsTUFvQk8sSUFBSTlOLEVBQUosRUFBUTtBQUNiOE4sa0JBQVc2OUIsYUFBYTNyQyxFQUFiLENBQVg7QUFDRDtBQUNELFNBQUk4TixRQUFKLEVBQWM7QUFDWjtBQUNBLFdBQUl2WSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkVBLGNBQUssU0FBTDtBQUNEOztBQUVELFdBQUlvVixNQUFNMHhCLG1CQUFtQmo5QixRQUFuQixFQUE2QjtBQUNyQzhzQiwrQkFBc0JBLG9CQURlO0FBRXJDSSxxQkFBWWhqQyxRQUFRZ2pDLFVBRmlCO0FBR3JDbUcsbUJBQVVucEMsUUFBUW1wQztBQUhtQixRQUE3QixFQUlQLElBSk8sQ0FBVjtBQUtBLFdBQUloOEIsU0FBU2tVLElBQUlsVSxNQUFqQjtBQUNBLFdBQUlxUixrQkFBa0I2QyxJQUFJN0MsZUFBMUI7QUFDQXhlLGVBQVFtTixNQUFSLEdBQWlCQSxNQUFqQjtBQUNBbk4sZUFBUXdlLGVBQVIsR0FBMEJBLGVBQTFCOztBQUVBO0FBQ0EsV0FBSWpoQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUNOLE9BQU9RLFdBQWhELElBQStEc08sSUFBbkUsRUFBeUU7QUFDdkVBLGNBQUssYUFBTDtBQUNBQyxpQkFBVSxLQUFLOEosS0FBTixHQUFlLFVBQXhCLEVBQXFDLFNBQXJDLEVBQWdELGFBQWhEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsVUFBT3k5QixNQUFNbGtELElBQU4sQ0FBVyxJQUFYLEVBQWlCeVksRUFBakIsRUFBcUI2TSxTQUFyQixDQUFQO0FBQ0QsRUFqRUQ7O0FBbUVBOzs7O0FBSUEsVUFBUzgrQixZQUFULENBQXVCM3JDLEVBQXZCLEVBQTJCO0FBQ3pCLE9BQUlBLEdBQUc0ckMsU0FBUCxFQUFrQjtBQUNoQixZQUFPNXJDLEdBQUc0ckMsU0FBVjtBQUNELElBRkQsTUFFTztBQUNMLFNBQUlDLFlBQVl4aUQsU0FBU3VyQixhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FpM0IsZUFBVWxyQixXQUFWLENBQXNCM2dCLEdBQUcrNUIsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxZQUFPOFIsVUFBVWxSLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRHBmLE9BQU11dkIsT0FBTixHQUFnQkMsa0JBQWhCOzttQkFFZXh2QixLOzs7Ozs7Ozs7QUNwMlRmO0FBQ0EsS0FBSWhtQixVQUFVN08sT0FBT0MsT0FBUCxHQUFpQixFQUEvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJbWxELGdCQUFKO0FBQ0EsS0FBSUMsa0JBQUo7O0FBRUEsVUFBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsV0FBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIO0FBQ0QsVUFBU0MsbUJBQVQsR0FBZ0M7QUFDNUIsV0FBTSxJQUFJRCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNIO0FBQ0EsY0FBWTtBQUNULFNBQUk7QUFDQSxhQUFJLE9BQU81d0MsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNsQ3l3QyxnQ0FBbUJ6d0MsVUFBbkI7QUFDSCxVQUZELE1BRU87QUFDSHl3QyxnQ0FBbUJFLGdCQUFuQjtBQUNIO0FBQ0osTUFORCxDQU1FLE9BQU94a0QsQ0FBUCxFQUFVO0FBQ1Jza0QsNEJBQW1CRSxnQkFBbkI7QUFDSDtBQUNELFNBQUk7QUFDQSxhQUFJLE9BQU9HLFlBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDcENKLGtDQUFxQkksWUFBckI7QUFDSCxVQUZELE1BRU87QUFDSEosa0NBQXFCRyxtQkFBckI7QUFDSDtBQUNKLE1BTkQsQ0FNRSxPQUFPMWtELENBQVAsRUFBVTtBQUNSdWtELDhCQUFxQkcsbUJBQXJCO0FBQ0g7QUFDSixFQW5CQSxHQUFEO0FBb0JBLFVBQVNFLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3JCLFNBQUlQLHFCQUFxQnp3QyxVQUF6QixFQUFxQztBQUNqQztBQUNBLGdCQUFPQSxXQUFXZ3hDLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxTQUFJLENBQUNQLHFCQUFxQkUsZ0JBQXJCLElBQXlDLENBQUNGLGdCQUEzQyxLQUFnRXp3QyxVQUFwRSxFQUFnRjtBQUM1RXl3Qyw0QkFBbUJ6d0MsVUFBbkI7QUFDQSxnQkFBT0EsV0FBV2d4QyxHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNELFNBQUk7QUFDQTtBQUNBLGdCQUFPUCxpQkFBaUJPLEdBQWpCLEVBQXNCLENBQXRCLENBQVA7QUFDSCxNQUhELENBR0UsT0FBTTdrRCxDQUFOLEVBQVE7QUFDTixhQUFJO0FBQ0E7QUFDQSxvQkFBT3NrRCxpQkFBaUJ2a0QsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEI4a0QsR0FBNUIsRUFBaUMsQ0FBakMsQ0FBUDtBQUNILFVBSEQsQ0FHRSxPQUFNN2tELENBQU4sRUFBUTtBQUNOO0FBQ0Esb0JBQU9za0QsaUJBQWlCdmtELElBQWpCLENBQXNCLElBQXRCLEVBQTRCOGtELEdBQTVCLEVBQWlDLENBQWpDLENBQVA7QUFDSDtBQUNKO0FBR0o7QUFDRCxVQUFTQyxlQUFULENBQXlCQyxNQUF6QixFQUFpQztBQUM3QixTQUFJUix1QkFBdUJJLFlBQTNCLEVBQXlDO0FBQ3JDO0FBQ0EsZ0JBQU9BLGFBQWFJLE1BQWIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxTQUFJLENBQUNSLHVCQUF1QkcsbUJBQXZCLElBQThDLENBQUNILGtCQUFoRCxLQUF1RUksWUFBM0UsRUFBeUY7QUFDckZKLDhCQUFxQkksWUFBckI7QUFDQSxnQkFBT0EsYUFBYUksTUFBYixDQUFQO0FBQ0g7QUFDRCxTQUFJO0FBQ0E7QUFDQSxnQkFBT1IsbUJBQW1CUSxNQUFuQixDQUFQO0FBQ0gsTUFIRCxDQUdFLE9BQU8va0QsQ0FBUCxFQUFTO0FBQ1AsYUFBSTtBQUNBO0FBQ0Esb0JBQU91a0QsbUJBQW1CeGtELElBQW5CLENBQXdCLElBQXhCLEVBQThCZ2xELE1BQTlCLENBQVA7QUFDSCxVQUhELENBR0UsT0FBTy9rRCxDQUFQLEVBQVM7QUFDUDtBQUNBO0FBQ0Esb0JBQU91a0QsbUJBQW1CeGtELElBQW5CLENBQXdCLElBQXhCLEVBQThCZ2xELE1BQTlCLENBQVA7QUFDSDtBQUNKO0FBSUo7QUFDRCxLQUFJaDlCLFFBQVEsRUFBWjtBQUNBLEtBQUlpOUIsV0FBVyxLQUFmO0FBQ0EsS0FBSUMsWUFBSjtBQUNBLEtBQUlDLGFBQWEsQ0FBQyxDQUFsQjs7QUFFQSxVQUFTQyxlQUFULEdBQTJCO0FBQ3ZCLFNBQUksQ0FBQ0gsUUFBRCxJQUFhLENBQUNDLFlBQWxCLEVBQWdDO0FBQzVCO0FBQ0g7QUFDREQsZ0JBQVcsS0FBWDtBQUNBLFNBQUlDLGFBQWF2a0QsTUFBakIsRUFBeUI7QUFDckJxbkIsaUJBQVFrOUIsYUFBYXg0QyxNQUFiLENBQW9Cc2IsS0FBcEIsQ0FBUjtBQUNILE1BRkQsTUFFTztBQUNIbTlCLHNCQUFhLENBQUMsQ0FBZDtBQUNIO0FBQ0QsU0FBSW45QixNQUFNcm5CLE1BQVYsRUFBa0I7QUFDZDBrRDtBQUNIO0FBQ0o7O0FBRUQsVUFBU0EsVUFBVCxHQUFzQjtBQUNsQixTQUFJSixRQUFKLEVBQWM7QUFDVjtBQUNIO0FBQ0QsU0FBSXBpQyxVQUFVZ2lDLFdBQVdPLGVBQVgsQ0FBZDtBQUNBSCxnQkFBVyxJQUFYOztBQUVBLFNBQUk3dUMsTUFBTTRSLE1BQU1ybkIsTUFBaEI7QUFDQSxZQUFNeVYsR0FBTixFQUFXO0FBQ1A4dUMsd0JBQWVsOUIsS0FBZjtBQUNBQSxpQkFBUSxFQUFSO0FBQ0EsZ0JBQU8sRUFBRW05QixVQUFGLEdBQWUvdUMsR0FBdEIsRUFBMkI7QUFDdkIsaUJBQUk4dUMsWUFBSixFQUFrQjtBQUNkQSw4QkFBYUMsVUFBYixFQUF5QjE4QixHQUF6QjtBQUNIO0FBQ0o7QUFDRDA4QixzQkFBYSxDQUFDLENBQWQ7QUFDQS91QyxlQUFNNFIsTUFBTXJuQixNQUFaO0FBQ0g7QUFDRHVrRCxvQkFBZSxJQUFmO0FBQ0FELGdCQUFXLEtBQVg7QUFDQUYscUJBQWdCbGlDLE9BQWhCO0FBQ0g7O0FBRUQ3VSxTQUFRcUYsUUFBUixHQUFtQixVQUFVeXhDLEdBQVYsRUFBZTtBQUM5QixTQUFJM3VDLE9BQU8sSUFBSXJLLEtBQUosQ0FBVTNMLFVBQVVRLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBLFNBQUlSLFVBQVVRLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsY0FBSyxJQUFJRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlQLFVBQVVRLE1BQTlCLEVBQXNDRCxHQUF0QyxFQUEyQztBQUN2Q3lWLGtCQUFLelYsSUFBSSxDQUFULElBQWNQLFVBQVVPLENBQVYsQ0FBZDtBQUNIO0FBQ0o7QUFDRHNuQixXQUFNMVcsSUFBTixDQUFXLElBQUlnMEMsSUFBSixDQUFTUixHQUFULEVBQWMzdUMsSUFBZCxDQUFYO0FBQ0EsU0FBSTZSLE1BQU1ybkIsTUFBTixLQUFpQixDQUFqQixJQUFzQixDQUFDc2tELFFBQTNCLEVBQXFDO0FBQ2pDSixvQkFBV1EsVUFBWDtBQUNIO0FBQ0osRUFYRDs7QUFhQTtBQUNBLFVBQVNDLElBQVQsQ0FBY1IsR0FBZCxFQUFtQlMsS0FBbkIsRUFBMEI7QUFDdEIsVUFBS1QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsVUFBS1MsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7QUFDREQsTUFBS3ZsRCxTQUFMLENBQWUwb0IsR0FBZixHQUFxQixZQUFZO0FBQzdCLFVBQUtxOEIsR0FBTCxDQUFTNWtELEtBQVQsQ0FBZSxJQUFmLEVBQXFCLEtBQUtxbEQsS0FBMUI7QUFDSCxFQUZEO0FBR0F2M0MsU0FBUXczQyxLQUFSLEdBQWdCLFNBQWhCO0FBQ0F4M0MsU0FBUXkzQyxPQUFSLEdBQWtCLElBQWxCO0FBQ0F6M0MsU0FBUUMsR0FBUixHQUFjLEVBQWQ7QUFDQUQsU0FBUTAzQyxJQUFSLEdBQWUsRUFBZjtBQUNBMTNDLFNBQVF5b0IsT0FBUixHQUFrQixFQUFsQixDLENBQXNCO0FBQ3RCem9CLFNBQVEyM0MsUUFBUixHQUFtQixFQUFuQjs7QUFFQSxVQUFTcm1ELElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIwTyxTQUFRb1MsRUFBUixHQUFhOWdCLElBQWI7QUFDQTBPLFNBQVFqSixXQUFSLEdBQXNCekYsSUFBdEI7QUFDQTBPLFNBQVFULElBQVIsR0FBZWpPLElBQWY7QUFDQTBPLFNBQVE0M0MsR0FBUixHQUFjdG1ELElBQWQ7QUFDQTBPLFNBQVE2M0MsY0FBUixHQUF5QnZtRCxJQUF6QjtBQUNBME8sU0FBUTgzQyxrQkFBUixHQUE2QnhtRCxJQUE3QjtBQUNBME8sU0FBUWdiLElBQVIsR0FBZTFwQixJQUFmO0FBQ0EwTyxTQUFRKzNDLGVBQVIsR0FBMEJ6bUQsSUFBMUI7QUFDQTBPLFNBQVFnNEMsbUJBQVIsR0FBOEIxbUQsSUFBOUI7O0FBRUEwTyxTQUFRa1YsU0FBUixHQUFvQixVQUFVamlCLElBQVYsRUFBZ0I7QUFBRSxZQUFPLEVBQVA7QUFBVyxFQUFqRDs7QUFFQStNLFNBQVF3Z0MsT0FBUixHQUFrQixVQUFVdnRDLElBQVYsRUFBZ0I7QUFDOUIsV0FBTSxJQUFJeWpELEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsRUFGRDs7QUFJQTEyQyxTQUFRaTRDLEdBQVIsR0FBYyxZQUFZO0FBQUUsWUFBTyxHQUFQO0FBQVksRUFBeEM7QUFDQWo0QyxTQUFRazRDLEtBQVIsR0FBZ0IsVUFBVTdtQixHQUFWLEVBQWU7QUFDM0IsV0FBTSxJQUFJcWxCLEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQ0gsRUFGRDtBQUdBMTJDLFNBQVFtNEMsS0FBUixHQUFnQixZQUFXO0FBQUUsWUFBTyxDQUFQO0FBQVcsRUFBeEMsQzs7Ozs7Ozs7OztBQ3ZMQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsRUFBQyxVQUFVbG5ELFVBQVYsRUFBc0I7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0EsU0FBSSxPQUFPbW5ELFNBQVAsS0FBcUIsVUFBekIsRUFBcUM7QUFDakNBLG1CQUFVLFNBQVYsRUFBcUJubkQsVUFBckI7O0FBRUo7QUFDQyxNQUpELE1BSU8sSUFBSSxnQ0FBT0csT0FBUCxPQUFtQixRQUFuQixJQUErQixnQ0FBT0QsTUFBUCxPQUFrQixRQUFyRCxFQUErRDtBQUNsRUEsZ0JBQU9DLE9BQVAsR0FBaUJILFlBQWpCOztBQUVKO0FBQ0MsTUFKTSxNQUlBLElBQUksSUFBSixFQUFnRDtBQUNuREMsU0FBQSxvQ0FBT0QsVUFBUDs7QUFFSjtBQUNDLE1BSk0sTUFJQSxJQUFJLE9BQU9vbkQsR0FBUCxLQUFlLFdBQW5CLEVBQWdDO0FBQ25DLGFBQUksQ0FBQ0EsSUFBSUMsRUFBSixFQUFMLEVBQWU7QUFDWDtBQUNILFVBRkQsTUFFTztBQUNIRCxpQkFBSUUsS0FBSixHQUFZdG5ELFVBQVo7QUFDSDs7QUFFTDtBQUNDLE1BUk0sTUFRQSxJQUFJLE9BQU8wQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDLE9BQU9QLElBQVAsS0FBZ0IsV0FBckQsRUFBa0U7QUFDckU7QUFDQTtBQUNBLGFBQUl3UixTQUFTLE9BQU9qUixNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5Q1AsSUFBdEQ7O0FBRUE7QUFDQTtBQUNBLGFBQUlvbEQsWUFBWTV6QyxPQUFPNnpDLENBQXZCO0FBQ0E3ekMsZ0JBQU82ekMsQ0FBUCxHQUFXeG5ELFlBQVg7O0FBRUE7QUFDQTtBQUNBMlQsZ0JBQU82ekMsQ0FBUCxDQUFTbGpELFVBQVQsR0FBc0IsWUFBWTtBQUM5QnFQLG9CQUFPNnpDLENBQVAsR0FBV0QsU0FBWDtBQUNBLG9CQUFPLElBQVA7QUFDSCxVQUhEO0FBS0gsTUFqQk0sTUFpQkE7QUFDSCxlQUFNLElBQUk5QixLQUFKLENBQVUsK0RBQVYsQ0FBTjtBQUNIO0FBRUosRUFsREQsRUFrREcsWUFBWTtBQUNmOztBQUVBLFNBQUlnQyxZQUFZLEtBQWhCO0FBQ0EsU0FBSTtBQUNBLGVBQU0sSUFBSWhDLEtBQUosRUFBTjtBQUNILE1BRkQsQ0FFRSxPQUFPemtELENBQVAsRUFBVTtBQUNSeW1ELHFCQUFZLENBQUMsQ0FBQ3ptRCxFQUFFeTJDLEtBQWhCO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLFNBQUlpUSxnQkFBZ0JDLGFBQXBCO0FBQ0EsU0FBSUMsU0FBSjs7QUFFQTs7QUFFQTtBQUNBLFNBQUl2bkQsT0FBTyxTQUFQQSxJQUFPLEdBQVksQ0FBRSxDQUF6Qjs7QUFFQTtBQUNBO0FBQ0EsU0FBSStULFdBQVcsWUFBWTtBQUN2QjtBQUNBLGFBQUl5ekMsT0FBTyxFQUFDQyxNQUFNLEtBQUssQ0FBWixFQUFlampCLE1BQU0sSUFBckIsRUFBWDtBQUNBLGFBQUlrakIsT0FBT0YsSUFBWDtBQUNBLGFBQUkxK0IsV0FBVyxLQUFmO0FBQ0EsYUFBSTYrQixjQUFjLEtBQUssQ0FBdkI7QUFDQSxhQUFJQyxXQUFXLEtBQWY7QUFDQTtBQUNBLGFBQUlDLGFBQWEsRUFBakI7O0FBRUEsa0JBQVNDLEtBQVQsR0FBaUI7QUFDYjtBQUNBLGlCQUFJTCxJQUFKLEVBQVVNLE1BQVY7O0FBRUEsb0JBQU9QLEtBQUtoakIsSUFBWixFQUFrQjtBQUNkZ2pCLHdCQUFPQSxLQUFLaGpCLElBQVo7QUFDQWlqQix3QkFBT0QsS0FBS0MsSUFBWjtBQUNBRCxzQkFBS0MsSUFBTCxHQUFZLEtBQUssQ0FBakI7QUFDQU0sMEJBQVNQLEtBQUtPLE1BQWQ7O0FBRUEscUJBQUlBLE1BQUosRUFBWTtBQUNSUCwwQkFBS08sTUFBTCxHQUFjLEtBQUssQ0FBbkI7QUFDQUEsNEJBQU81YixLQUFQO0FBQ0g7QUFDRDZiLDJCQUFVUCxJQUFWLEVBQWdCTSxNQUFoQjtBQUVIO0FBQ0Qsb0JBQU9GLFdBQVd4bUQsTUFBbEIsRUFBMEI7QUFDdEJvbUQsd0JBQU9JLFdBQVdyeEMsR0FBWCxFQUFQO0FBQ0F3eEMsMkJBQVVQLElBQVY7QUFDSDtBQUNEMytCLHdCQUFXLEtBQVg7QUFDSDtBQUNEO0FBQ0Esa0JBQVNrL0IsU0FBVCxDQUFtQlAsSUFBbkIsRUFBeUJNLE1BQXpCLEVBQWlDO0FBQzdCLGlCQUFJO0FBQ0FOO0FBRUgsY0FIRCxDQUdFLE9BQU85bUQsQ0FBUCxFQUFVO0FBQ1IscUJBQUlpbkQsUUFBSixFQUFjO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBSUcsTUFBSixFQUFZO0FBQ1JBLGdDQUFPRSxJQUFQO0FBQ0g7QUFDRHp6QyxnQ0FBV3N6QyxLQUFYLEVBQWtCLENBQWxCO0FBQ0EseUJBQUlDLE1BQUosRUFBWTtBQUNSQSxnQ0FBTzViLEtBQVA7QUFDSDs7QUFFRCwyQkFBTXhyQyxDQUFOO0FBRUgsa0JBakJELE1BaUJPO0FBQ0g7QUFDQTtBQUNBNlQsZ0NBQVcsWUFBWTtBQUNuQiwrQkFBTTdULENBQU47QUFDSCxzQkFGRCxFQUVHLENBRkg7QUFHSDtBQUNKOztBQUVELGlCQUFJb25ELE1BQUosRUFBWTtBQUNSQSx3QkFBT0UsSUFBUDtBQUNIO0FBQ0o7O0FBRURsMEMsb0JBQVcsa0JBQVUwekMsSUFBVixFQUFnQjtBQUN2QkMsb0JBQU9BLEtBQUtsakIsSUFBTCxHQUFZO0FBQ2ZpakIsdUJBQU1BLElBRFM7QUFFZk0seUJBQVFILFlBQVlsNUMsUUFBUXE1QyxNQUZiO0FBR2Z2akIsdUJBQU07QUFIUyxjQUFuQjs7QUFNQSxpQkFBSSxDQUFDMWIsUUFBTCxFQUFlO0FBQ1hBLDRCQUFXLElBQVg7QUFDQTYrQjtBQUNIO0FBQ0osVUFYRDs7QUFhQSxhQUFJLFFBQU9qNUMsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUNBQSxRQUFReEYsUUFBUixPQUF1QixrQkFEdkIsSUFDNkN3RixRQUFRcUYsUUFEekQsRUFDbUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBNnpDLHdCQUFXLElBQVg7O0FBRUFELDJCQUFjLHVCQUFZO0FBQ3RCajVDLHlCQUFRcUYsUUFBUixDQUFpQit6QyxLQUFqQjtBQUNILGNBRkQ7QUFJSCxVQWhCRCxNQWdCTyxJQUFJLE9BQU9JLFlBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDM0M7QUFDQSxpQkFBSSxPQUFPN2xELE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDL0JzbEQsK0JBQWNPLGFBQWEzbkQsSUFBYixDQUFrQjhCLE1BQWxCLEVBQTBCeWxELEtBQTFCLENBQWQ7QUFDSCxjQUZELE1BRU87QUFDSEgsK0JBQWMsdUJBQVk7QUFDdEJPLGtDQUFhSixLQUFiO0FBQ0gsa0JBRkQ7QUFHSDtBQUVKLFVBVk0sTUFVQSxJQUFJLE9BQU9LLGNBQVAsS0FBMEIsV0FBOUIsRUFBMkM7QUFDOUM7QUFDQTtBQUNBLGlCQUFJQyxVQUFVLElBQUlELGNBQUosRUFBZDtBQUNBO0FBQ0E7QUFDQUMscUJBQVFDLEtBQVIsQ0FBY0MsU0FBZCxHQUEwQixZQUFZO0FBQ2xDWCwrQkFBY1ksZUFBZDtBQUNBSCx5QkFBUUMsS0FBUixDQUFjQyxTQUFkLEdBQTBCUixLQUExQjtBQUNBQTtBQUNILGNBSkQ7QUFLQSxpQkFBSVMsa0JBQWtCLFNBQWxCQSxlQUFrQixHQUFZO0FBQzlCO0FBQ0E7QUFDQUgseUJBQVFJLEtBQVIsQ0FBY0MsV0FBZCxDQUEwQixDQUExQjtBQUNILGNBSkQ7QUFLQWQsMkJBQWMsdUJBQVk7QUFDdEJuekMsNEJBQVdzekMsS0FBWCxFQUFrQixDQUFsQjtBQUNBUztBQUNILGNBSEQ7QUFLSCxVQXJCTSxNQXFCQTtBQUNIO0FBQ0FaLDJCQUFjLHVCQUFZO0FBQ3RCbnpDLDRCQUFXc3pDLEtBQVgsRUFBa0IsQ0FBbEI7QUFDSCxjQUZEO0FBR0g7QUFDRDtBQUNBO0FBQ0E7QUFDQS96QyxrQkFBUzIwQyxRQUFULEdBQW9CLFVBQVVqQixJQUFWLEVBQWdCO0FBQ2hDSSx3QkFBVzcxQyxJQUFYLENBQWdCeTFDLElBQWhCO0FBQ0EsaUJBQUksQ0FBQzMrQixRQUFMLEVBQWU7QUFDWEEsNEJBQVcsSUFBWDtBQUNBNitCO0FBQ0g7QUFDSixVQU5EO0FBT0EsZ0JBQU81ekMsUUFBUDtBQUNILE1BbkphLEVBQWQ7O0FBcUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBSXJULE9BQU9GLFNBQVNFLElBQXBCO0FBQ0EsY0FBU2lvRCxXQUFULENBQXFCblcsQ0FBckIsRUFBd0I7QUFDcEIsZ0JBQU8sWUFBWTtBQUNmLG9CQUFPOXhDLEtBQUtFLEtBQUwsQ0FBVzR4QyxDQUFYLEVBQWMzeEMsU0FBZCxDQUFQO0FBQ0gsVUFGRDtBQUdIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLFNBQUkrbkQsY0FBY0QsWUFBWW44QyxNQUFNL0wsU0FBTixDQUFnQnVDLEtBQTVCLENBQWxCOztBQUVBLFNBQUk2bEQsZUFBZUYsWUFDZm44QyxNQUFNL0wsU0FBTixDQUFnQnlNLE1BQWhCLElBQTBCLFVBQVUraUIsUUFBVixFQUFvQjY0QixLQUFwQixFQUEyQjtBQUNqRCxhQUFJMWpELFFBQVEsQ0FBWjtBQUFBLGFBQ0kvRCxTQUFTLEtBQUtBLE1BRGxCO0FBRUE7QUFDQSxhQUFJUixVQUFVUSxNQUFWLEtBQXFCLENBQXpCLEVBQTRCO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBRztBQUNDLHFCQUFJK0QsU0FBUyxJQUFiLEVBQW1CO0FBQ2YwakQsNkJBQVEsS0FBSzFqRCxPQUFMLENBQVI7QUFDQTtBQUNIO0FBQ0QscUJBQUksRUFBRUEsS0FBRixJQUFXL0QsTUFBZixFQUF1QjtBQUNuQiwyQkFBTSxJQUFJeUMsU0FBSixFQUFOO0FBQ0g7QUFDSixjQVJELFFBUVMsQ0FSVDtBQVNIO0FBQ0Q7QUFDQSxnQkFBT3NCLFFBQVEvRCxNQUFmLEVBQXVCK0QsT0FBdkIsRUFBZ0M7QUFDNUI7QUFDQSxpQkFBSUEsU0FBUyxJQUFiLEVBQW1CO0FBQ2YwakQseUJBQVE3NEIsU0FBUzY0QixLQUFULEVBQWdCLEtBQUsxakQsS0FBTCxDQUFoQixFQUE2QkEsS0FBN0IsQ0FBUjtBQUNIO0FBQ0o7QUFDRCxnQkFBTzBqRCxLQUFQO0FBQ0gsTUExQmMsQ0FBbkI7O0FBNkJBLFNBQUlDLGdCQUFnQkosWUFDaEJuOEMsTUFBTS9MLFNBQU4sQ0FBZ0JxQyxPQUFoQixJQUEyQixVQUFVaUcsS0FBVixFQUFpQjtBQUN4QztBQUNBLGNBQUssSUFBSTNILElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLQyxNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDbEMsaUJBQUksS0FBS0EsQ0FBTCxNQUFZMkgsS0FBaEIsRUFBdUI7QUFDbkIsd0JBQU8zSCxDQUFQO0FBQ0g7QUFDSjtBQUNELGdCQUFPLENBQUMsQ0FBUjtBQUNILE1BVGUsQ0FBcEI7O0FBWUEsU0FBSTRuRCxZQUFZTCxZQUNabjhDLE1BQU0vTCxTQUFOLENBQWdCMkosR0FBaEIsSUFBdUIsVUFBVTZsQixRQUFWLEVBQW9CZzVCLEtBQXBCLEVBQTJCO0FBQzlDLGFBQUlubkQsT0FBTyxJQUFYO0FBQ0EsYUFBSW9uRCxVQUFVLEVBQWQ7QUFDQUwsc0JBQWEvbUQsSUFBYixFQUFtQixVQUFVZCxTQUFWLEVBQXFCK0gsS0FBckIsRUFBNEIzRCxLQUE1QixFQUFtQztBQUNsRDhqRCxxQkFBUWwzQyxJQUFSLENBQWFpZSxTQUFTdnZCLElBQVQsQ0FBY3VvRCxLQUFkLEVBQXFCbGdELEtBQXJCLEVBQTRCM0QsS0FBNUIsRUFBbUN0RCxJQUFuQyxDQUFiO0FBQ0gsVUFGRCxFQUVHLEtBQUssQ0FGUjtBQUdBLGdCQUFPb25ELE9BQVA7QUFDSCxNQVJXLENBQWhCOztBQVdBLFNBQUlDLGdCQUFnQm5oRCxPQUFPcUMsTUFBUCxJQUFpQixVQUFVNUosU0FBVixFQUFxQjtBQUN0RCxrQkFBUzJvRCxJQUFULEdBQWdCLENBQUc7QUFDbkJBLGNBQUszb0QsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxnQkFBTyxJQUFJMm9ELElBQUosRUFBUDtBQUNILE1BSkQ7O0FBTUEsU0FBSUMsd0JBQXdCcmhELE9BQU9nSSxjQUFQLElBQXlCLFVBQVU1UCxHQUFWLEVBQWU4YixJQUFmLEVBQXFCb3RDLFVBQXJCLEVBQWlDO0FBQ2xGbHBELGFBQUk4YixJQUFKLElBQVlvdEMsV0FBV3ZnRCxLQUF2QjtBQUNBLGdCQUFPM0ksR0FBUDtBQUNILE1BSEQ7O0FBS0EsU0FBSW1wRCx3QkFBd0JaLFlBQVkzZ0QsT0FBT3ZILFNBQVAsQ0FBaUJzSyxjQUE3QixDQUE1Qjs7QUFFQSxTQUFJeStDLGNBQWN4aEQsT0FBT0MsSUFBUCxJQUFlLFVBQVV3aEQsTUFBVixFQUFrQjtBQUMvQyxhQUFJeGhELE9BQU8sRUFBWDtBQUNBLGNBQUssSUFBSWdELEdBQVQsSUFBZ0J3K0MsTUFBaEIsRUFBd0I7QUFDcEIsaUJBQUlGLHNCQUFzQkUsTUFBdEIsRUFBOEJ4K0MsR0FBOUIsQ0FBSixFQUF3QztBQUNwQ2hELHNCQUFLK0osSUFBTCxDQUFVL0csR0FBVjtBQUNIO0FBQ0o7QUFDRCxnQkFBT2hELElBQVA7QUFDSCxNQVJEOztBQVVBLFNBQUl5aEQsa0JBQWtCZixZQUFZM2dELE9BQU92SCxTQUFQLENBQWlCeUksUUFBN0IsQ0FBdEI7O0FBRUEsY0FBU0YsUUFBVCxDQUFrQkQsS0FBbEIsRUFBeUI7QUFDckIsZ0JBQU9BLFVBQVVmLE9BQU9lLEtBQVAsQ0FBakI7QUFDSDs7QUFFRDs7QUFFQTtBQUNBLGNBQVM0Z0QsZUFBVCxDQUF5QkMsU0FBekIsRUFBb0M7QUFDaEMsZ0JBQ0lGLGdCQUFnQkUsU0FBaEIsTUFBK0Isd0JBQS9CLElBQ0FBLHFCQUFxQkMsWUFGekI7QUFJSDs7QUFFRDtBQUNBO0FBQ0EsU0FBSUEsWUFBSjtBQUNBLFNBQUksT0FBT0MsV0FBUCxLQUF1QixXQUEzQixFQUF3QztBQUNwQ0Qsd0JBQWVDLFdBQWY7QUFDSCxNQUZELE1BRU87QUFDSEQsd0JBQWUsc0JBQVU5Z0QsS0FBVixFQUFpQjtBQUM1QixrQkFBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0gsVUFGRDtBQUdIOztBQUVEOztBQUVBLFNBQUlnaEQsdUJBQXVCLHNCQUEzQjs7QUFFQSxjQUFTQyxrQkFBVCxDQUE0QjlpRCxLQUE1QixFQUFtQ1csT0FBbkMsRUFBNEM7QUFDeEM7QUFDQTtBQUNBLGFBQUl1L0MsYUFDQXYvQyxRQUFRdXZDLEtBRFIsSUFFQSxRQUFPbHdDLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFGakIsSUFHQUEsVUFBVSxJQUhWLElBSUFBLE1BQU1rd0MsS0FKVixFQUtFO0FBQ0UsaUJBQUk2UyxTQUFTLEVBQWI7QUFDQSxrQkFBSyxJQUFJMzFDLElBQUl6TSxPQUFiLEVBQXNCLENBQUMsQ0FBQ3lNLENBQXhCLEVBQTJCQSxJQUFJQSxFQUFFb1osTUFBakMsRUFBeUM7QUFDckMscUJBQUlwWixFQUFFOGlDLEtBQUYsS0FBWSxDQUFDbHdDLE1BQU1nakQsdUJBQVAsSUFBa0NoakQsTUFBTWdqRCx1QkFBTixHQUFnQzUxQyxFQUFFNjFDLFlBQWhGLENBQUosRUFBbUc7QUFDL0ZkLDJDQUFzQm5pRCxLQUF0QixFQUE2Qix5QkFBN0IsRUFBd0QsRUFBQzZCLE9BQU91TCxFQUFFNjFDLFlBQVYsRUFBd0JqNkMsY0FBYyxJQUF0QyxFQUF4RDtBQUNBKzVDLDRCQUFPbDFCLE9BQVAsQ0FBZXpnQixFQUFFOGlDLEtBQWpCO0FBQ0g7QUFDSjtBQUNENlMsb0JBQU9sMUIsT0FBUCxDQUFlN3RCLE1BQU1rd0MsS0FBckI7O0FBRUEsaUJBQUlnVCxpQkFBaUJILE9BQU8zOEMsSUFBUCxDQUFZLE9BQU95OEMsb0JBQVAsR0FBOEIsSUFBMUMsQ0FBckI7QUFDQSxpQkFBSTNTLFFBQVFpVCxrQkFBa0JELGNBQWxCLENBQVo7QUFDQWYsbUNBQXNCbmlELEtBQXRCLEVBQTZCLE9BQTdCLEVBQXNDLEVBQUM2QixPQUFPcXVDLEtBQVIsRUFBZWxuQyxjQUFjLElBQTdCLEVBQXRDO0FBQ0g7QUFDSjs7QUFFRCxjQUFTbTZDLGlCQUFULENBQTJCQyxXQUEzQixFQUF3QztBQUNwQyxhQUFJQyxRQUFRRCxZQUFZLy9DLEtBQVosQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBLGFBQUlpZ0QsZUFBZSxFQUFuQjtBQUNBLGNBQUssSUFBSXBwRCxJQUFJLENBQWIsRUFBZ0JBLElBQUltcEQsTUFBTWxwRCxNQUExQixFQUFrQyxFQUFFRCxDQUFwQyxFQUF1QztBQUNuQyxpQkFBSXFwRCxPQUFPRixNQUFNbnBELENBQU4sQ0FBWDs7QUFFQSxpQkFBSSxDQUFDc3BELGdCQUFnQkQsSUFBaEIsQ0FBRCxJQUEwQixDQUFDRSxZQUFZRixJQUFaLENBQTNCLElBQWdEQSxJQUFwRCxFQUEwRDtBQUN0REQsOEJBQWF4NEMsSUFBYixDQUFrQnk0QyxJQUFsQjtBQUNIO0FBQ0o7QUFDRCxnQkFBT0QsYUFBYWw5QyxJQUFiLENBQWtCLElBQWxCLENBQVA7QUFDSDs7QUFFRCxjQUFTcTlDLFdBQVQsQ0FBcUJDLFNBQXJCLEVBQWdDO0FBQzVCLGdCQUFPQSxVQUFVOW5ELE9BQVYsQ0FBa0IsYUFBbEIsTUFBcUMsQ0FBQyxDQUF0QyxJQUNBOG5ELFVBQVU5bkQsT0FBVixDQUFrQixXQUFsQixNQUFtQyxDQUFDLENBRDNDO0FBRUg7O0FBRUQsY0FBUytuRCx3QkFBVCxDQUFrQ0QsU0FBbEMsRUFBNkM7QUFDekM7QUFDQTtBQUNBLGFBQUlFLFdBQVcsZ0NBQWdDL25ELElBQWhDLENBQXFDNm5ELFNBQXJDLENBQWY7QUFDQSxhQUFJRSxRQUFKLEVBQWM7QUFDVixvQkFBTyxDQUFDQSxTQUFTLENBQVQsQ0FBRCxFQUFjNWUsT0FBTzRlLFNBQVMsQ0FBVCxDQUFQLENBQWQsQ0FBUDtBQUNIOztBQUVEO0FBQ0EsYUFBSUMsV0FBVyw0QkFBNEJob0QsSUFBNUIsQ0FBaUM2bkQsU0FBakMsQ0FBZjtBQUNBLGFBQUlHLFFBQUosRUFBYztBQUNWLG9CQUFPLENBQUNBLFNBQVMsQ0FBVCxDQUFELEVBQWM3ZSxPQUFPNmUsU0FBUyxDQUFULENBQVAsQ0FBZCxDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxhQUFJQyxXQUFXLGlCQUFpQmpvRCxJQUFqQixDQUFzQjZuRCxTQUF0QixDQUFmO0FBQ0EsYUFBSUksUUFBSixFQUFjO0FBQ1Ysb0JBQU8sQ0FBQ0EsU0FBUyxDQUFULENBQUQsRUFBYzllLE9BQU84ZSxTQUFTLENBQVQsQ0FBUCxDQUFkLENBQVA7QUFDSDtBQUNKOztBQUVELGNBQVNOLGVBQVQsQ0FBeUJFLFNBQXpCLEVBQW9DO0FBQ2hDLGFBQUlLLHdCQUF3QkoseUJBQXlCRCxTQUF6QixDQUE1Qjs7QUFFQSxhQUFJLENBQUNLLHFCQUFMLEVBQTRCO0FBQ3hCLG9CQUFPLEtBQVA7QUFDSDs7QUFFRCxhQUFJQyxXQUFXRCxzQkFBc0IsQ0FBdEIsQ0FBZjtBQUNBLGFBQUlFLGFBQWFGLHNCQUFzQixDQUF0QixDQUFqQjs7QUFFQSxnQkFBT0MsYUFBYTNELFNBQWIsSUFDSDRELGNBQWM5RCxhQURYLElBRUg4RCxjQUFjQyxXQUZsQjtBQUdIOztBQUVEO0FBQ0E7QUFDQSxjQUFTOUQsV0FBVCxHQUF1QjtBQUNuQixhQUFJLENBQUNGLFNBQUwsRUFBZ0I7QUFDWjtBQUNIOztBQUVELGFBQUk7QUFDQSxtQkFBTSxJQUFJaEMsS0FBSixFQUFOO0FBQ0gsVUFGRCxDQUVFLE9BQU96a0QsQ0FBUCxFQUFVO0FBQ1IsaUJBQUk0cEQsUUFBUTVwRCxFQUFFeTJDLEtBQUYsQ0FBUTdzQyxLQUFSLENBQWMsSUFBZCxDQUFaO0FBQ0EsaUJBQUk4Z0QsWUFBWWQsTUFBTSxDQUFOLEVBQVN6bkQsT0FBVCxDQUFpQixHQUFqQixJQUF3QixDQUF4QixHQUE0QnluRCxNQUFNLENBQU4sQ0FBNUIsR0FBdUNBLE1BQU0sQ0FBTixDQUF2RDtBQUNBLGlCQUFJVSx3QkFBd0JKLHlCQUF5QlEsU0FBekIsQ0FBNUI7QUFDQSxpQkFBSSxDQUFDSixxQkFBTCxFQUE0QjtBQUN4QjtBQUNIOztBQUVEMUQseUJBQVkwRCxzQkFBc0IsQ0FBdEIsQ0FBWjtBQUNBLG9CQUFPQSxzQkFBc0IsQ0FBdEIsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsY0FBU0ssU0FBVCxDQUFtQnI3QixRQUFuQixFQUE2QnR1QixJQUE3QixFQUFtQzRwRCxXQUFuQyxFQUFnRDtBQUM1QyxnQkFBTyxZQUFZO0FBQ2YsaUJBQUksT0FBT3hxRCxPQUFQLEtBQW1CLFdBQW5CLElBQ0EsT0FBT0EsUUFBUXlQLElBQWYsS0FBd0IsVUFENUIsRUFDd0M7QUFDcEN6UCx5QkFBUXlQLElBQVIsQ0FBYTdPLE9BQU8sc0JBQVAsR0FBZ0M0cEQsV0FBaEMsR0FDQSxXQURiLEVBQzBCLElBQUluRyxLQUFKLENBQVUsRUFBVixFQUFjaE8sS0FEeEM7QUFFSDtBQUNELG9CQUFPbm5CLFNBQVNydkIsS0FBVCxDQUFlcXZCLFFBQWYsRUFBeUJwdkIsU0FBekIsQ0FBUDtBQUNILFVBUEQ7QUFRSDs7QUFFRDtBQUNBOztBQUVBOzs7OztBQUtBLGNBQVNzbUQsQ0FBVCxDQUFXcCtDLEtBQVgsRUFBa0I7QUFDZDtBQUNBO0FBQ0E7QUFDQSxhQUFJQSxpQkFBaUJzTCxPQUFyQixFQUE4QjtBQUMxQixvQkFBT3RMLEtBQVA7QUFDSDs7QUFFRDtBQUNBLGFBQUl5aUQsZUFBZXppRCxLQUFmLENBQUosRUFBMkI7QUFDdkIsb0JBQU8waUQsT0FBTzFpRCxLQUFQLENBQVA7QUFDSCxVQUZELE1BRU87QUFDSCxvQkFBTzJpRCxRQUFRM2lELEtBQVIsQ0FBUDtBQUNIO0FBQ0o7QUFDRG8rQyxPQUFFei9DLE9BQUYsR0FBWXkvQyxDQUFaOztBQUVBOzs7O0FBSUFBLE9BQUVwekMsUUFBRixHQUFhQSxRQUFiOztBQUVBOzs7QUFHQW96QyxPQUFFd0UsZ0JBQUYsR0FBcUIsS0FBckI7O0FBRUE7Ozs7OztBQU1BLFNBQUlDLG1CQUFtQixDQUF2Qjs7QUFFQTtBQUNBLFNBQUksUUFBT2w5QyxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQStCQSxPQUEvQixJQUEwQ0EsUUFBUUMsR0FBbEQsSUFBeURELFFBQVFDLEdBQVIsQ0FBWWs5QyxPQUF6RSxFQUFrRjtBQUM5RTFFLFdBQUV3RSxnQkFBRixHQUFxQixJQUFyQjtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUF4RSxPQUFFNS9DLEtBQUYsR0FBVUEsS0FBVjtBQUNBLGNBQVNBLEtBQVQsR0FBaUI7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFJdWtELFdBQVcsRUFBZjtBQUFBLGFBQW1CQyxvQkFBb0IsRUFBdkM7QUFBQSxhQUEyQ0MsZUFBM0M7O0FBRUEsYUFBSUMsV0FBVzlDLGNBQWM1aEQsTUFBTTlHLFNBQXBCLENBQWY7QUFDQSxhQUFJb0gsVUFBVXNoRCxjQUFjOTBDLFFBQVE1VCxTQUF0QixDQUFkOztBQUVBb0gsaUJBQVFxa0QsZUFBUixHQUEwQixVQUFVeGtELE9BQVYsRUFBbUJ5a0QsRUFBbkIsRUFBdUJDLFFBQXZCLEVBQWlDO0FBQ3ZELGlCQUFJdjFDLE9BQU8reEMsWUFBWS9uRCxTQUFaLENBQVg7QUFDQSxpQkFBSWlyRCxRQUFKLEVBQWM7QUFDVkEsMEJBQVM5NUMsSUFBVCxDQUFjNkUsSUFBZDtBQUNBLHFCQUFJczFDLE9BQU8sTUFBUCxJQUFpQkMsU0FBUyxDQUFULENBQXJCLEVBQWtDO0FBQUU7QUFDaENMLHVDQUFrQi81QyxJQUFsQixDQUF1Qm82QyxTQUFTLENBQVQsQ0FBdkI7QUFDSDtBQUNKLGNBTEQsTUFLTztBQUNIakYsbUJBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkJpNEMscUNBQWdCRSxlQUFoQixDQUFnQ3RyRCxLQUFoQyxDQUFzQ29yRCxlQUF0QyxFQUF1RG4xQyxJQUF2RDtBQUNILGtCQUZEO0FBR0g7QUFDSixVQVpEOztBQWNBO0FBQ0FoUCxpQkFBUXdrRCxPQUFSLEdBQWtCLFlBQVk7QUFDMUIsaUJBQUlQLFFBQUosRUFBYztBQUNWLHdCQUFPamtELE9BQVA7QUFDSDtBQUNELGlCQUFJeWtELGNBQWNDLE9BQU9QLGVBQVAsQ0FBbEI7QUFDQSxpQkFBSVEsVUFBVUYsV0FBVixDQUFKLEVBQTRCO0FBQ3hCTixtQ0FBa0JNLFdBQWxCLENBRHdCLENBQ087QUFDbEM7QUFDRCxvQkFBT0EsV0FBUDtBQUNILFVBVEQ7O0FBV0F6a0QsaUJBQVE0a0QsT0FBUixHQUFrQixZQUFZO0FBQzFCLGlCQUFJLENBQUNULGVBQUwsRUFBc0I7QUFDbEIsd0JBQU8sRUFBRTFMLE9BQU8sU0FBVCxFQUFQO0FBQ0g7QUFDRCxvQkFBTzBMLGdCQUFnQlMsT0FBaEIsRUFBUDtBQUNILFVBTEQ7O0FBT0EsYUFBSXRGLEVBQUV3RSxnQkFBRixJQUFzQnZFLFNBQTFCLEVBQXFDO0FBQ2pDLGlCQUFJO0FBQ0EsdUJBQU0sSUFBSWhDLEtBQUosRUFBTjtBQUNILGNBRkQsQ0FFRSxPQUFPemtELENBQVAsRUFBVTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBa0gseUJBQVF1dkMsS0FBUixHQUFnQnoyQyxFQUFFeTJDLEtBQUYsQ0FBUXhTLFNBQVIsQ0FBa0Jqa0MsRUFBRXkyQyxLQUFGLENBQVF0MEMsT0FBUixDQUFnQixJQUFoQixJQUF3QixDQUExQyxDQUFoQjtBQUNBK0UseUJBQVFzaUQsWUFBUixHQUF1QnlCLGtCQUF2QjtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGtCQUFTYyxNQUFULENBQWdCQyxVQUFoQixFQUE0QjtBQUN4QlgsK0JBQWtCVyxVQUFsQjs7QUFFQSxpQkFBSXhGLEVBQUV3RSxnQkFBRixJQUFzQnZFLFNBQTFCLEVBQXFDO0FBQ2pDO0FBQ0E7QUFDQXYvQyx5QkFBUTZsQixNQUFSLEdBQWlCaS9CLFVBQWpCO0FBQ0g7O0FBRUQ5RCwwQkFBYWlELFFBQWIsRUFBdUIsVUFBVTlxRCxTQUFWLEVBQXFCNHJELE9BQXJCLEVBQThCO0FBQ2pEekYsbUJBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkI0NEMsZ0NBQVdULGVBQVgsQ0FBMkJ0ckQsS0FBM0IsQ0FBaUMrckQsVUFBakMsRUFBNkNDLE9BQTdDO0FBQ0gsa0JBRkQ7QUFHSCxjQUpELEVBSUcsS0FBSyxDQUpSOztBQU1BZCx3QkFBVyxLQUFLLENBQWhCO0FBQ0FDLGlDQUFvQixLQUFLLENBQXpCO0FBQ0g7O0FBRURFLGtCQUFTcGtELE9BQVQsR0FBbUJBLE9BQW5CO0FBQ0Fva0Qsa0JBQVN2a0QsT0FBVCxHQUFtQixVQUFVcUIsS0FBVixFQUFpQjtBQUNoQyxpQkFBSWlqRCxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRURVLG9CQUFPdkYsRUFBRXArQyxLQUFGLENBQVA7QUFDSCxVQU5EOztBQVFBa2pELGtCQUFTUCxPQUFULEdBQW1CLFVBQVUzaUQsS0FBVixFQUFpQjtBQUNoQyxpQkFBSWlqRCxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRURVLG9CQUFPaEIsUUFBUTNpRCxLQUFSLENBQVA7QUFDSCxVQU5EO0FBT0FrakQsa0JBQVNya0QsTUFBVCxHQUFrQixVQUFVd2IsTUFBVixFQUFrQjtBQUNoQyxpQkFBSTRvQyxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRURVLG9CQUFPOWtELE9BQU93YixNQUFQLENBQVA7QUFDSCxVQU5EO0FBT0E2b0Msa0JBQVMvMUMsTUFBVCxHQUFrQixVQUFVMjJDLFFBQVYsRUFBb0I7QUFDbEMsaUJBQUliLGVBQUosRUFBcUI7QUFDakI7QUFDSDs7QUFFRG5ELDBCQUFha0QsaUJBQWIsRUFBZ0MsVUFBVS9xRCxTQUFWLEVBQXFCOHJELGdCQUFyQixFQUF1QztBQUNuRTNGLG1CQUFFcHpDLFFBQUYsQ0FBVyxZQUFZO0FBQ25CKzRDLHNDQUFpQkQsUUFBakI7QUFDSCxrQkFGRDtBQUdILGNBSkQsRUFJRyxLQUFLLENBSlI7QUFLSCxVQVZEOztBQVlBLGdCQUFPWixRQUFQO0FBQ0g7O0FBRUQ7Ozs7O0FBS0Exa0QsV0FBTTlHLFNBQU4sQ0FBZ0Jzc0QsZ0JBQWhCLEdBQW1DLFlBQVk7QUFDM0MsYUFBSWpyRCxPQUFPLElBQVg7QUFDQSxnQkFBTyxVQUFVb0YsS0FBVixFQUFpQjZCLEtBQWpCLEVBQXdCO0FBQzNCLGlCQUFJN0IsS0FBSixFQUFXO0FBQ1BwRixzQkFBSzhGLE1BQUwsQ0FBWVYsS0FBWjtBQUNILGNBRkQsTUFFTyxJQUFJckcsVUFBVVEsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUM3QlMsc0JBQUs0RixPQUFMLENBQWFraEQsWUFBWS9uRCxTQUFaLEVBQXVCLENBQXZCLENBQWI7QUFDSCxjQUZNLE1BRUE7QUFDSGlCLHNCQUFLNEYsT0FBTCxDQUFhcUIsS0FBYjtBQUNIO0FBQ0osVUFSRDtBQVNILE1BWEQ7O0FBYUE7Ozs7OztBQU1BbytDLE9BQUU5eUMsT0FBRixHQUFZeE0sT0FBWixDQXZtQmUsQ0F1bUJNO0FBQ3JCcy9DLE9BQUV0L0MsT0FBRixHQUFZQSxPQUFaO0FBQ0EsY0FBU0EsT0FBVCxDQUFpQm1sRCxRQUFqQixFQUEyQjtBQUN2QixhQUFJLE9BQU9BLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDaEMsbUJBQU0sSUFBSWxwRCxTQUFKLENBQWMsOEJBQWQsQ0FBTjtBQUNIO0FBQ0QsYUFBSW1vRCxXQUFXMWtELE9BQWY7QUFDQSxhQUFJO0FBQ0F5bEQsc0JBQVNmLFNBQVN2a0QsT0FBbEIsRUFBMkJ1a0QsU0FBU3JrRCxNQUFwQyxFQUE0Q3FrRCxTQUFTLzFDLE1BQXJEO0FBQ0gsVUFGRCxDQUVFLE9BQU9rTixNQUFQLEVBQWU7QUFDYjZvQyxzQkFBU3JrRCxNQUFULENBQWdCd2IsTUFBaEI7QUFDSDtBQUNELGdCQUFPNm9DLFNBQVNwa0QsT0FBaEI7QUFDSDs7QUFFREEsYUFBUW9sRCxJQUFSLEdBQWVBLElBQWYsQ0F0bkJlLENBc25CTTtBQUNyQnBsRCxhQUFRNndDLEdBQVIsR0FBY0EsR0FBZCxDQXZuQmUsQ0F1bkJJO0FBQ25CN3dDLGFBQVFELE1BQVIsR0FBaUJBLE1BQWpCLENBeG5CZSxDQXduQlU7QUFDekJDLGFBQVFILE9BQVIsR0FBa0J5L0MsQ0FBbEIsQ0F6bkJlLENBeW5CTTs7QUFFckI7QUFDQTtBQUNBO0FBQ0FBLE9BQUUrRixVQUFGLEdBQWUsVUFBVXpELE1BQVYsRUFBa0I7QUFDN0I7QUFDQTtBQUNBLGdCQUFPQSxNQUFQO0FBQ0gsTUFKRDs7QUFNQXAxQyxhQUFRNVQsU0FBUixDQUFrQnlzRCxVQUFsQixHQUErQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBTyxJQUFQO0FBQ0gsTUFKRDs7QUFNQTs7Ozs7Ozs7O0FBU0EvRixPQUFFNzVDLElBQUYsR0FBUyxVQUFVNi9DLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUNyQixnQkFBT2pHLEVBQUVnRyxDQUFGLEVBQUs3L0MsSUFBTCxDQUFVOC9DLENBQVYsQ0FBUDtBQUNILE1BRkQ7O0FBSUEvNEMsYUFBUTVULFNBQVIsQ0FBa0I2TSxJQUFsQixHQUF5QixVQUFVKy9DLElBQVYsRUFBZ0I7QUFDckMsZ0JBQU9sRyxFQUFFLENBQUMsSUFBRCxFQUFPa0csSUFBUCxDQUFGLEVBQWdCQyxNQUFoQixDQUF1QixVQUFVSCxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDMUMsaUJBQUlELE1BQU1DLENBQVYsRUFBYTtBQUNUO0FBQ0Esd0JBQU9ELENBQVA7QUFDSCxjQUhELE1BR087QUFDSCx1QkFBTSxJQUFJL0gsS0FBSixDQUFVLGlDQUFpQytILENBQWpDLEdBQXFDLEdBQXJDLEdBQTJDQyxDQUFyRCxDQUFOO0FBQ0g7QUFDSixVQVBNLENBQVA7QUFRSCxNQVREOztBQVdBOzs7OztBQUtBakcsT0FBRThGLElBQUYsR0FBU0EsSUFBVDtBQUNBLGNBQVNBLElBQVQsQ0FBY00sUUFBZCxFQUF3QjtBQUNwQixnQkFBTzFsRCxRQUFRLFVBQVVILE9BQVYsRUFBbUJFLE1BQW5CLEVBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBSyxJQUFJeEcsSUFBSSxDQUFSLEVBQVcwVixNQUFNeTJDLFNBQVNsc0QsTUFBL0IsRUFBdUNELElBQUkwVixHQUEzQyxFQUFnRDFWLEdBQWhELEVBQXFEO0FBQ2pEK2xELG1CQUFFb0csU0FBU25zRCxDQUFULENBQUYsRUFBZXdGLElBQWYsQ0FBb0JjLE9BQXBCLEVBQTZCRSxNQUE3QjtBQUNIO0FBQ0osVUFUTSxDQUFQO0FBVUg7O0FBRUR5TSxhQUFRNVQsU0FBUixDQUFrQndzRCxJQUFsQixHQUF5QixZQUFZO0FBQ2pDLGdCQUFPLEtBQUtybUQsSUFBTCxDQUFVdWdELEVBQUU4RixJQUFaLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7Ozs7Ozs7OztBQVdBOUYsT0FBRXFHLFdBQUYsR0FBZ0JuNUMsT0FBaEI7QUFDQSxjQUFTQSxPQUFULENBQWlCaTFDLFVBQWpCLEVBQTZCMzRCLFFBQTdCLEVBQXVDODdCLE9BQXZDLEVBQWdEO0FBQzVDLGFBQUk5N0IsYUFBYSxLQUFLLENBQXRCLEVBQXlCO0FBQ3JCQSx3QkFBVyxrQkFBVXc3QixFQUFWLEVBQWM7QUFDckIsd0JBQU92a0QsT0FBTyxJQUFJdzlDLEtBQUosQ0FDVix5Q0FBeUMrRyxFQUQvQixDQUFQLENBQVA7QUFHSCxjQUpEO0FBS0g7QUFDRCxhQUFJTSxZQUFZLEtBQUssQ0FBckIsRUFBd0I7QUFDcEJBLHVCQUFVLG1CQUFZO0FBQ2xCLHdCQUFPLEVBQUNuTSxPQUFPLFNBQVIsRUFBUDtBQUNILGNBRkQ7QUFHSDs7QUFFRCxhQUFJejRDLFVBQVVzaEQsY0FBYzkwQyxRQUFRNVQsU0FBdEIsQ0FBZDs7QUFFQW9ILGlCQUFRcWtELGVBQVIsR0FBMEIsVUFBVXhrRCxPQUFWLEVBQW1CeWtELEVBQW5CLEVBQXVCdDFDLElBQXZCLEVBQTZCO0FBQ25ELGlCQUFJRSxNQUFKO0FBQ0EsaUJBQUk7QUFDQSxxQkFBSXV5QyxXQUFXNkMsRUFBWCxDQUFKLEVBQW9CO0FBQ2hCcDFDLDhCQUFTdXlDLFdBQVc2QyxFQUFYLEVBQWV2ckQsS0FBZixDQUFxQmlILE9BQXJCLEVBQThCZ1AsSUFBOUIsQ0FBVDtBQUNILGtCQUZELE1BRU87QUFDSEUsOEJBQVM0WixTQUFTandCLElBQVQsQ0FBY21ILE9BQWQsRUFBdUJza0QsRUFBdkIsRUFBMkJ0MUMsSUFBM0IsQ0FBVDtBQUNIO0FBQ0osY0FORCxDQU1FLE9BQU8reUMsU0FBUCxFQUFrQjtBQUNoQjd5QywwQkFBU25QLE9BQU9naUQsU0FBUCxDQUFUO0FBQ0g7QUFDRCxpQkFBSWxpRCxPQUFKLEVBQWE7QUFDVEEseUJBQVFxUCxNQUFSO0FBQ0g7QUFDSixVQWREOztBQWdCQWxQLGlCQUFRNGtELE9BQVIsR0FBa0JBLE9BQWxCOztBQUVBO0FBQ0EsYUFBSUEsT0FBSixFQUFhO0FBQ1QsaUJBQUlnQixZQUFZaEIsU0FBaEI7QUFDQSxpQkFBSWdCLFVBQVVuTixLQUFWLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2hDejRDLHlCQUFRK2hELFNBQVIsR0FBb0I2RCxVQUFVcnFDLE1BQTlCO0FBQ0g7O0FBRUR2YixxQkFBUXdrRCxPQUFSLEdBQWtCLFlBQVk7QUFDMUIscUJBQUlvQixZQUFZaEIsU0FBaEI7QUFDQSxxQkFBSWdCLFVBQVVuTixLQUFWLEtBQW9CLFNBQXBCLElBQ0FtTixVQUFVbk4sS0FBVixLQUFvQixVQUR4QixFQUNvQztBQUNoQyw0QkFBT3o0QyxPQUFQO0FBQ0g7QUFDRCx3QkFBTzRsRCxVQUFVMWtELEtBQWpCO0FBQ0gsY0FQRDtBQVFIOztBQUVELGdCQUFPbEIsT0FBUDtBQUNIOztBQUVEd00sYUFBUTVULFNBQVIsQ0FBa0J5SSxRQUFsQixHQUE2QixZQUFZO0FBQ3JDLGdCQUFPLGtCQUFQO0FBQ0gsTUFGRDs7QUFJQW1MLGFBQVE1VCxTQUFSLENBQWtCbUcsSUFBbEIsR0FBeUIsVUFBVThtRCxTQUFWLEVBQXFCQyxRQUFyQixFQUErQkMsVUFBL0IsRUFBMkM7QUFDaEUsYUFBSTlyRCxPQUFPLElBQVg7QUFDQSxhQUFJbXFELFdBQVcxa0QsT0FBZjtBQUNBLGFBQUlzbUQsT0FBTyxLQUFYLENBSGdFLENBRzVDO0FBQ0E7O0FBRXBCLGtCQUFTQyxVQUFULENBQW9CL2tELEtBQXBCLEVBQTJCO0FBQ3ZCLGlCQUFJO0FBQ0Esd0JBQU8sT0FBTzJrRCxTQUFQLEtBQXFCLFVBQXJCLEdBQWtDQSxVQUFVM2tELEtBQVYsQ0FBbEMsR0FBcURBLEtBQTVEO0FBQ0gsY0FGRCxDQUVFLE9BQU82Z0QsU0FBUCxFQUFrQjtBQUNoQix3QkFBT2hpRCxPQUFPZ2lELFNBQVAsQ0FBUDtBQUNIO0FBQ0o7O0FBRUQsa0JBQVNtRSxTQUFULENBQW1CbkUsU0FBbkIsRUFBOEI7QUFDMUIsaUJBQUksT0FBTytELFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDaEMzRCxvQ0FBbUJKLFNBQW5CLEVBQThCOW5ELElBQTlCO0FBQ0EscUJBQUk7QUFDQSw0QkFBTzZyRCxTQUFTL0QsU0FBVCxDQUFQO0FBQ0gsa0JBRkQsQ0FFRSxPQUFPb0UsWUFBUCxFQUFxQjtBQUNuQiw0QkFBT3BtRCxPQUFPb21ELFlBQVAsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxvQkFBT3BtRCxPQUFPZ2lELFNBQVAsQ0FBUDtBQUNIOztBQUVELGtCQUFTcUUsV0FBVCxDQUFxQmxsRCxLQUFyQixFQUE0QjtBQUN4QixvQkFBTyxPQUFPNmtELFVBQVAsS0FBc0IsVUFBdEIsR0FBbUNBLFdBQVc3a0QsS0FBWCxDQUFuQyxHQUF1REEsS0FBOUQ7QUFDSDs7QUFFRG8rQyxXQUFFcHpDLFFBQUYsQ0FBVyxZQUFZO0FBQ25CalMsa0JBQUtvcUQsZUFBTCxDQUFxQixVQUFVbmpELEtBQVYsRUFBaUI7QUFDbEMscUJBQUk4a0QsSUFBSixFQUFVO0FBQ047QUFDSDtBQUNEQSx3QkFBTyxJQUFQOztBQUVBNUIsMEJBQVN2a0QsT0FBVCxDQUFpQm9tRCxXQUFXL2tELEtBQVgsQ0FBakI7QUFDSCxjQVBELEVBT0csTUFQSCxFQU9XLENBQUMsVUFBVTZnRCxTQUFWLEVBQXFCO0FBQzdCLHFCQUFJaUUsSUFBSixFQUFVO0FBQ047QUFDSDtBQUNEQSx3QkFBTyxJQUFQOztBQUVBNUIsMEJBQVN2a0QsT0FBVCxDQUFpQnFtRCxVQUFVbkUsU0FBVixDQUFqQjtBQUNILGNBUFUsQ0FQWDtBQWVILFVBaEJEOztBQWtCQTtBQUNBOW5ELGNBQUtvcUQsZUFBTCxDQUFxQixLQUFLLENBQTFCLEVBQTZCLE1BQTdCLEVBQXFDLENBQUMsS0FBSyxDQUFOLEVBQVMsVUFBVW5qRCxLQUFWLEVBQWlCO0FBQzNELGlCQUFJbWxELFFBQUo7QUFDQSxpQkFBSUMsUUFBUSxLQUFaO0FBQ0EsaUJBQUk7QUFDQUQsNEJBQVdELFlBQVlsbEQsS0FBWixDQUFYO0FBQ0gsY0FGRCxDQUVFLE9BQU9wSSxDQUFQLEVBQVU7QUFDUnd0RCx5QkFBUSxJQUFSO0FBQ0EscUJBQUloSCxFQUFFaUgsT0FBTixFQUFlO0FBQ1hqSCx1QkFBRWlILE9BQUYsQ0FBVXp0RCxDQUFWO0FBQ0gsa0JBRkQsTUFFTztBQUNILDJCQUFNQSxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxpQkFBSSxDQUFDd3RELEtBQUwsRUFBWTtBQUNSbEMsMEJBQVMvMUMsTUFBVCxDQUFnQmc0QyxRQUFoQjtBQUNIO0FBQ0osVUFqQm9DLENBQXJDOztBQW1CQSxnQkFBT2pDLFNBQVNwa0QsT0FBaEI7QUFDSCxNQXJFRDs7QUF1RUFzL0MsT0FBRWtILEdBQUYsR0FBUSxVQUFVeG1ELE9BQVYsRUFBbUJvb0IsUUFBbkIsRUFBNkI7QUFDakMsZ0JBQU9rM0IsRUFBRXQvQyxPQUFGLEVBQVd3bUQsR0FBWCxDQUFlcCtCLFFBQWYsQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7Ozs7Ozs7OztBQVlBNWIsYUFBUTVULFNBQVIsQ0FBa0I0dEQsR0FBbEIsR0FBd0IsVUFBVXArQixRQUFWLEVBQW9CO0FBQ3hDQSxvQkFBV2szQixFQUFFbDNCLFFBQUYsQ0FBWDs7QUFFQSxnQkFBTyxLQUFLcnBCLElBQUwsQ0FBVSxVQUFVbUMsS0FBVixFQUFpQjtBQUM5QixvQkFBT2tuQixTQUFTcStCLEtBQVQsQ0FBZXZsRCxLQUFmLEVBQXNCd2xELFdBQXRCLENBQWtDeGxELEtBQWxDLENBQVA7QUFDSCxVQUZNLENBQVA7QUFHSCxNQU5EOztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBbytDLE9BQUVxSCxJQUFGLEdBQVNBLElBQVQ7QUFDQSxjQUFTQSxJQUFULENBQWN6bEQsS0FBZCxFQUFxQjJrRCxTQUFyQixFQUFnQ0MsUUFBaEMsRUFBMENDLFVBQTFDLEVBQXNEO0FBQ2xELGdCQUFPekcsRUFBRXArQyxLQUFGLEVBQVNuQyxJQUFULENBQWM4bUQsU0FBZCxFQUF5QkMsUUFBekIsRUFBbUNDLFVBQW5DLENBQVA7QUFDSDs7QUFFRHY1QyxhQUFRNVQsU0FBUixDQUFrQjh0RCxXQUFsQixHQUFnQyxVQUFVeGxELEtBQVYsRUFBaUI7QUFDN0MsZ0JBQU8sS0FBS25DLElBQUwsQ0FBVSxZQUFZO0FBQUUsb0JBQU9tQyxLQUFQO0FBQWUsVUFBdkMsQ0FBUDtBQUNILE1BRkQ7O0FBSUFvK0MsT0FBRW9ILFdBQUYsR0FBZ0IsVUFBVTFtRCxPQUFWLEVBQW1Ca0IsS0FBbkIsRUFBMEI7QUFDdEMsZ0JBQU9vK0MsRUFBRXQvQyxPQUFGLEVBQVcwbUQsV0FBWCxDQUF1QnhsRCxLQUF2QixDQUFQO0FBQ0gsTUFGRDs7QUFJQXNMLGFBQVE1VCxTQUFSLENBQWtCZ3VELFVBQWxCLEdBQStCLFVBQVVyckMsTUFBVixFQUFrQjtBQUM3QyxnQkFBTyxLQUFLeGMsSUFBTCxDQUFVLFlBQVk7QUFBRSxtQkFBTXdjLE1BQU47QUFBZSxVQUF2QyxDQUFQO0FBQ0gsTUFGRDs7QUFJQStqQyxPQUFFc0gsVUFBRixHQUFlLFVBQVU1bUQsT0FBVixFQUFtQnViLE1BQW5CLEVBQTJCO0FBQ3RDLGdCQUFPK2pDLEVBQUV0L0MsT0FBRixFQUFXNG1ELFVBQVgsQ0FBc0JyckMsTUFBdEIsQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBK2pDLE9BQUVvRixNQUFGLEdBQVdBLE1BQVg7QUFDQSxjQUFTQSxNQUFULENBQWdCeGpELEtBQWhCLEVBQXVCO0FBQ25CLGFBQUl5akQsVUFBVXpqRCxLQUFWLENBQUosRUFBc0I7QUFDbEIsaUJBQUkwa0QsWUFBWTFrRCxNQUFNMGpELE9BQU4sRUFBaEI7QUFDQSxpQkFBSWdCLFVBQVVuTixLQUFWLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ2pDLHdCQUFPbU4sVUFBVTFrRCxLQUFqQjtBQUNIO0FBQ0o7QUFDRCxnQkFBT0EsS0FBUDtBQUNIOztBQUVEOzs7O0FBSUFvK0MsT0FBRXFGLFNBQUYsR0FBY0EsU0FBZDtBQUNBLGNBQVNBLFNBQVQsQ0FBbUIvQyxNQUFuQixFQUEyQjtBQUN2QixnQkFBT0Esa0JBQWtCcDFDLE9BQXpCO0FBQ0g7O0FBRUQ4eUMsT0FBRXFFLGNBQUYsR0FBbUJBLGNBQW5CO0FBQ0EsY0FBU0EsY0FBVCxDQUF3Qi9CLE1BQXhCLEVBQWdDO0FBQzVCLGdCQUFPemdELFNBQVN5Z0QsTUFBVCxLQUFvQixPQUFPQSxPQUFPN2lELElBQWQsS0FBdUIsVUFBbEQ7QUFDSDs7QUFFRDs7OztBQUlBdWdELE9BQUV1SCxTQUFGLEdBQWNBLFNBQWQ7QUFDQSxjQUFTQSxTQUFULENBQW1CakYsTUFBbkIsRUFBMkI7QUFDdkIsZ0JBQU8rQyxVQUFVL0MsTUFBVixLQUFxQkEsT0FBT2dELE9BQVAsR0FBaUJuTSxLQUFqQixLQUEyQixTQUF2RDtBQUNIOztBQUVEanNDLGFBQVE1VCxTQUFSLENBQWtCaXVELFNBQWxCLEdBQThCLFlBQVk7QUFDdEMsZ0JBQU8sS0FBS2pDLE9BQUwsR0FBZW5NLEtBQWYsS0FBeUIsU0FBaEM7QUFDSCxNQUZEOztBQUlBOzs7O0FBSUE2RyxPQUFFd0gsV0FBRixHQUFnQkEsV0FBaEI7QUFDQSxjQUFTQSxXQUFULENBQXFCbEYsTUFBckIsRUFBNkI7QUFDekIsZ0JBQU8sQ0FBQytDLFVBQVUvQyxNQUFWLENBQUQsSUFBc0JBLE9BQU9nRCxPQUFQLEdBQWlCbk0sS0FBakIsS0FBMkIsV0FBeEQ7QUFDSDs7QUFFRGpzQyxhQUFRNVQsU0FBUixDQUFrQmt1RCxXQUFsQixHQUFnQyxZQUFZO0FBQ3hDLGdCQUFPLEtBQUtsQyxPQUFMLEdBQWVuTSxLQUFmLEtBQXlCLFdBQWhDO0FBQ0gsTUFGRDs7QUFJQTs7O0FBR0E2RyxPQUFFeUgsVUFBRixHQUFlQSxVQUFmO0FBQ0EsY0FBU0EsVUFBVCxDQUFvQm5GLE1BQXBCLEVBQTRCO0FBQ3hCLGdCQUFPK0MsVUFBVS9DLE1BQVYsS0FBcUJBLE9BQU9nRCxPQUFQLEdBQWlCbk0sS0FBakIsS0FBMkIsVUFBdkQ7QUFDSDs7QUFFRGpzQyxhQUFRNVQsU0FBUixDQUFrQm11RCxVQUFsQixHQUErQixZQUFZO0FBQ3ZDLGdCQUFPLEtBQUtuQyxPQUFMLEdBQWVuTSxLQUFmLEtBQXlCLFVBQWhDO0FBQ0gsTUFGRDs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQUl1TyxtQkFBbUIsRUFBdkI7QUFDQSxTQUFJQyxzQkFBc0IsRUFBMUI7QUFDQSxTQUFJQyw4QkFBOEIsRUFBbEM7QUFDQSxTQUFJQywyQkFBMkIsSUFBL0I7O0FBRUEsY0FBU0Msd0JBQVQsR0FBb0M7QUFDaENKLDBCQUFpQnh0RCxNQUFqQixHQUEwQixDQUExQjtBQUNBeXRELDZCQUFvQnp0RCxNQUFwQixHQUE2QixDQUE3Qjs7QUFFQSxhQUFJLENBQUMydEQsd0JBQUwsRUFBK0I7QUFDM0JBLHdDQUEyQixJQUEzQjtBQUNIO0FBQ0o7O0FBRUQsY0FBU0UsY0FBVCxDQUF3QnJuRCxPQUF4QixFQUFpQ3ViLE1BQWpDLEVBQXlDO0FBQ3JDLGFBQUksQ0FBQzRyQyx3QkFBTCxFQUErQjtBQUMzQjtBQUNIO0FBQ0QsYUFBSSxRQUFPdGdELE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsT0FBT0EsUUFBUWdiLElBQWYsS0FBd0IsVUFBM0QsRUFBdUU7QUFDbkV5OUIsZUFBRXB6QyxRQUFGLENBQVcyMEMsUUFBWCxDQUFvQixZQUFZO0FBQzVCLHFCQUFJSyxjQUFjK0YsbUJBQWQsRUFBbUNqbkQsT0FBbkMsTUFBZ0QsQ0FBQyxDQUFyRCxFQUF3RDtBQUNwRDZHLDZCQUFRZ2IsSUFBUixDQUFhLG9CQUFiLEVBQW1DdEcsTUFBbkMsRUFBMkN2YixPQUEzQztBQUNBa25ELGlEQUE0Qi84QyxJQUE1QixDQUFpQ25LLE9BQWpDO0FBQ0g7QUFDSixjQUxEO0FBTUg7O0FBRURpbkQsNkJBQW9COThDLElBQXBCLENBQXlCbkssT0FBekI7QUFDQSxhQUFJdWIsVUFBVSxPQUFPQSxPQUFPZzBCLEtBQWQsS0FBd0IsV0FBdEMsRUFBbUQ7QUFDL0N5WCw4QkFBaUI3OEMsSUFBakIsQ0FBc0JvUixPQUFPZzBCLEtBQTdCO0FBQ0gsVUFGRCxNQUVPO0FBQ0h5WCw4QkFBaUI3OEMsSUFBakIsQ0FBc0IsZ0JBQWdCb1IsTUFBdEM7QUFDSDtBQUNKOztBQUVELGNBQVMrckMsZ0JBQVQsQ0FBMEJ0bkQsT0FBMUIsRUFBbUM7QUFDL0IsYUFBSSxDQUFDbW5ELHdCQUFMLEVBQStCO0FBQzNCO0FBQ0g7O0FBRUQsYUFBSUksS0FBS3JHLGNBQWMrRixtQkFBZCxFQUFtQ2puRCxPQUFuQyxDQUFUO0FBQ0EsYUFBSXVuRCxPQUFPLENBQUMsQ0FBWixFQUFlO0FBQ1gsaUJBQUksUUFBTzFnRCxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQStCLE9BQU9BLFFBQVFnYixJQUFmLEtBQXdCLFVBQTNELEVBQXVFO0FBQ25FeTlCLG1CQUFFcHpDLFFBQUYsQ0FBVzIwQyxRQUFYLENBQW9CLFlBQVk7QUFDNUIseUJBQUkyRyxXQUFXdEcsY0FBY2dHLDJCQUFkLEVBQTJDbG5ELE9BQTNDLENBQWY7QUFDQSx5QkFBSXduRCxhQUFhLENBQUMsQ0FBbEIsRUFBcUI7QUFDakIzZ0QsaUNBQVFnYixJQUFSLENBQWEsa0JBQWIsRUFBaUNtbEMsaUJBQWlCTyxFQUFqQixDQUFqQyxFQUF1RHZuRCxPQUF2RDtBQUNBa25ELHFEQUE0QmprRCxNQUE1QixDQUFtQ3VrRCxRQUFuQyxFQUE2QyxDQUE3QztBQUNIO0FBQ0osa0JBTkQ7QUFPSDtBQUNEUCxpQ0FBb0Joa0QsTUFBcEIsQ0FBMkJza0QsRUFBM0IsRUFBK0IsQ0FBL0I7QUFDQVAsOEJBQWlCL2pELE1BQWpCLENBQXdCc2tELEVBQXhCLEVBQTRCLENBQTVCO0FBQ0g7QUFDSjs7QUFFRGpJLE9BQUU4SCx3QkFBRixHQUE2QkEsd0JBQTdCOztBQUVBOUgsT0FBRW1JLG1CQUFGLEdBQXdCLFlBQVk7QUFDaEM7QUFDQSxnQkFBT1QsaUJBQWlCN3JELEtBQWpCLEVBQVA7QUFDSCxNQUhEOztBQUtBbWtELE9BQUVvSSw4QkFBRixHQUFtQyxZQUFZO0FBQzNDTjtBQUNBRCxvQ0FBMkIsS0FBM0I7QUFDSCxNQUhEOztBQUtBQzs7QUFFQTs7QUFFQTs7OztBQUlBOUgsT0FBRXYvQyxNQUFGLEdBQVdBLE1BQVg7QUFDQSxjQUFTQSxNQUFULENBQWdCd2IsTUFBaEIsRUFBd0I7QUFDcEIsYUFBSW9zQyxZQUFZbjdDLFFBQVE7QUFDcEIscUJBQVEsY0FBVXM1QyxRQUFWLEVBQW9CO0FBQ3hCO0FBQ0EscUJBQUlBLFFBQUosRUFBYztBQUNWd0Isc0NBQWlCLElBQWpCO0FBQ0g7QUFDRCx3QkFBT3hCLFdBQVdBLFNBQVN2cUMsTUFBVCxDQUFYLEdBQThCLElBQXJDO0FBQ0g7QUFQbUIsVUFBUixFQVFiLFNBQVN1TixRQUFULEdBQW9CO0FBQ25CLG9CQUFPLElBQVA7QUFDSCxVQVZlLEVBVWIsU0FBUzg3QixPQUFULEdBQW1CO0FBQ2xCLG9CQUFPLEVBQUVuTSxPQUFPLFVBQVQsRUFBcUJsOUIsUUFBUUEsTUFBN0IsRUFBUDtBQUNILFVBWmUsQ0FBaEI7O0FBY0E7QUFDQThyQyx3QkFBZU0sU0FBZixFQUEwQnBzQyxNQUExQjs7QUFFQSxnQkFBT29zQyxTQUFQO0FBQ0g7O0FBRUQ7Ozs7QUFJQXJJLE9BQUV1RSxPQUFGLEdBQVlBLE9BQVo7QUFDQSxjQUFTQSxPQUFULENBQWlCM2lELEtBQWpCLEVBQXdCO0FBQ3BCLGdCQUFPc0wsUUFBUTtBQUNYLHFCQUFRLGdCQUFZO0FBQ2hCLHdCQUFPdEwsS0FBUDtBQUNILGNBSFU7QUFJWCxvQkFBTyxhQUFVcEgsSUFBVixFQUFnQjtBQUNuQix3QkFBT29ILE1BQU1wSCxJQUFOLENBQVA7QUFDSCxjQU5VO0FBT1gsb0JBQU8sYUFBVUEsSUFBVixFQUFnQjh0RCxHQUFoQixFQUFxQjtBQUN4QjFtRCx1QkFBTXBILElBQU4sSUFBYzh0RCxHQUFkO0FBQ0gsY0FUVTtBQVVYLHVCQUFVLGlCQUFVOXRELElBQVYsRUFBZ0I7QUFDdEIsd0JBQU9vSCxNQUFNcEgsSUFBTixDQUFQO0FBQ0gsY0FaVTtBQWFYLHFCQUFRLGNBQVVBLElBQVYsRUFBZ0JrVixJQUFoQixFQUFzQjtBQUMxQjtBQUNBO0FBQ0EscUJBQUlsVixTQUFTLElBQVQsSUFBaUJBLFNBQVMsS0FBSyxDQUFuQyxFQUFzQztBQUNsQyw0QkFBT29ILE1BQU1uSSxLQUFOLENBQVksS0FBSyxDQUFqQixFQUFvQmlXLElBQXBCLENBQVA7QUFDSCxrQkFGRCxNQUVPO0FBQ0gsNEJBQU85TixNQUFNcEgsSUFBTixFQUFZZixLQUFaLENBQWtCbUksS0FBbEIsRUFBeUI4TixJQUF6QixDQUFQO0FBQ0g7QUFDSixjQXJCVTtBQXNCWCxzQkFBUyxlQUFVb3lDLEtBQVYsRUFBaUJweUMsSUFBakIsRUFBdUI7QUFDNUIsd0JBQU85TixNQUFNbkksS0FBTixDQUFZcW9ELEtBQVosRUFBbUJweUMsSUFBbkIsQ0FBUDtBQUNILGNBeEJVO0FBeUJYLHFCQUFRLGdCQUFZO0FBQ2hCLHdCQUFPMnlDLFlBQVl6Z0QsS0FBWixDQUFQO0FBQ0g7QUEzQlUsVUFBUixFQTRCSixLQUFLLENBNUJELEVBNEJJLFNBQVMwakQsT0FBVCxHQUFtQjtBQUMxQixvQkFBTyxFQUFFbk0sT0FBTyxXQUFULEVBQXNCdjNDLE9BQU9BLEtBQTdCLEVBQVA7QUFDSCxVQTlCTSxDQUFQO0FBK0JIOztBQUVEOzs7OztBQUtBLGNBQVMwaUQsTUFBVCxDQUFnQjVqRCxPQUFoQixFQUF5QjtBQUNyQixhQUFJb2tELFdBQVcxa0QsT0FBZjtBQUNBNC9DLFdBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkIsaUJBQUk7QUFDQWxNLHlCQUFRakIsSUFBUixDQUFhcWxELFNBQVN2a0QsT0FBdEIsRUFBK0J1a0QsU0FBU3JrRCxNQUF4QyxFQUFnRHFrRCxTQUFTLzFDLE1BQXpEO0FBQ0gsY0FGRCxDQUVFLE9BQU8wekMsU0FBUCxFQUFrQjtBQUNoQnFDLDBCQUFTcmtELE1BQVQsQ0FBZ0JnaUQsU0FBaEI7QUFDSDtBQUNKLFVBTkQ7QUFPQSxnQkFBT3FDLFNBQVNwa0QsT0FBaEI7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0FzL0MsT0FBRXVJLE1BQUYsR0FBV0EsTUFBWDtBQUNBLGNBQVNBLE1BQVQsQ0FBZ0JqRyxNQUFoQixFQUF3QjtBQUNwQixnQkFBT3AxQyxRQUFRO0FBQ1gsc0JBQVMsaUJBQVksQ0FBRTtBQURaLFVBQVIsRUFFSixTQUFTc2MsUUFBVCxDQUFrQnc3QixFQUFsQixFQUFzQnQxQyxJQUF0QixFQUE0QjtBQUMzQixvQkFBTzg0QyxTQUFTbEcsTUFBVCxFQUFpQjBDLEVBQWpCLEVBQXFCdDFDLElBQXJCLENBQVA7QUFDSCxVQUpNLEVBSUosWUFBWTtBQUNYLG9CQUFPc3dDLEVBQUVzQyxNQUFGLEVBQVVnRCxPQUFWLEVBQVA7QUFDSCxVQU5NLENBQVA7QUFPSDs7QUFFRDs7Ozs7Ozs7OztBQVVBdEYsT0FBRW1HLE1BQUYsR0FBV0EsTUFBWDtBQUNBLGNBQVNBLE1BQVQsQ0FBZ0J2a0QsS0FBaEIsRUFBdUIya0QsU0FBdkIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQ3hDLGdCQUFPeEcsRUFBRXArQyxLQUFGLEVBQVN1a0QsTUFBVCxDQUFnQkksU0FBaEIsRUFBMkJDLFFBQTNCLENBQVA7QUFDSDs7QUFFRHQ1QyxhQUFRNVQsU0FBUixDQUFrQjZzRCxNQUFsQixHQUEyQixVQUFVSSxTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtBQUN0RCxnQkFBTyxLQUFLalYsR0FBTCxHQUFXOXhDLElBQVgsQ0FBZ0IsVUFBVXEvQyxLQUFWLEVBQWlCO0FBQ3BDLG9CQUFPeUgsVUFBVTlzRCxLQUFWLENBQWdCLEtBQUssQ0FBckIsRUFBd0JxbEQsS0FBeEIsQ0FBUDtBQUNILFVBRk0sRUFFSjBILFFBRkksQ0FBUDtBQUdILE1BSkQ7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBeEcsT0FBRXlJLEtBQUYsR0FBVUEsS0FBVjtBQUNBLGNBQVNBLEtBQVQsQ0FBZUMsYUFBZixFQUE4QjtBQUMxQixnQkFBTyxZQUFZO0FBQ2Y7QUFDQTtBQUNBLHNCQUFTQyxTQUFULENBQW1CQyxJQUFuQixFQUF5QnJ0QixHQUF6QixFQUE4QjtBQUMxQixxQkFBSTNyQixNQUFKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFJLE9BQU9pNUMsYUFBUCxLQUF5QixXQUE3QixFQUEwQztBQUN0QztBQUNBLHlCQUFJO0FBQ0FqNUMsa0NBQVNrNUMsVUFBVUYsSUFBVixFQUFnQnJ0QixHQUFoQixDQUFUO0FBQ0gsc0JBRkQsQ0FFRSxPQUFPa25CLFNBQVAsRUFBa0I7QUFDaEIsZ0NBQU9oaUQsT0FBT2dpRCxTQUFQLENBQVA7QUFDSDtBQUNELHlCQUFJN3lDLE9BQU84MkMsSUFBWCxFQUFpQjtBQUNiLGdDQUFPMUcsRUFBRXB3QyxPQUFPaE8sS0FBVCxDQUFQO0FBQ0gsc0JBRkQsTUFFTztBQUNILGdDQUFPeWxELEtBQUt6M0MsT0FBT2hPLEtBQVosRUFBbUJrbkIsUUFBbkIsRUFBNkJpZ0MsT0FBN0IsQ0FBUDtBQUNIO0FBQ0osa0JBWkQsTUFZTztBQUNIO0FBQ0E7QUFDQSx5QkFBSTtBQUNBbjVDLGtDQUFTazVDLFVBQVVGLElBQVYsRUFBZ0JydEIsR0FBaEIsQ0FBVDtBQUNILHNCQUZELENBRUUsT0FBT2tuQixTQUFQLEVBQWtCO0FBQ2hCLDZCQUFJRCxnQkFBZ0JDLFNBQWhCLENBQUosRUFBZ0M7QUFDNUIsb0NBQU96QyxFQUFFeUMsVUFBVTdnRCxLQUFaLENBQVA7QUFDSCwwQkFGRCxNQUVPO0FBQ0gsb0NBQU9uQixPQUFPZ2lELFNBQVAsQ0FBUDtBQUNIO0FBQ0o7QUFDRCw0QkFBTzRFLEtBQUt6M0MsTUFBTCxFQUFha1osUUFBYixFQUF1QmlnQyxPQUF2QixDQUFQO0FBQ0g7QUFDSjtBQUNELGlCQUFJRCxZQUFZSixjQUFjanZELEtBQWQsQ0FBb0IsSUFBcEIsRUFBMEJDLFNBQTFCLENBQWhCO0FBQ0EsaUJBQUlvdkIsV0FBVzYvQixVQUFVdnZELElBQVYsQ0FBZXV2RCxTQUFmLEVBQTBCLE1BQTFCLENBQWY7QUFDQSxpQkFBSUksVUFBVUosVUFBVXZ2RCxJQUFWLENBQWV1dkQsU0FBZixFQUEwQixPQUExQixDQUFkO0FBQ0Esb0JBQU83L0IsVUFBUDtBQUNILFVBN0NEO0FBOENIOztBQUVEOzs7Ozs7O0FBT0FrM0IsT0FBRWdKLEtBQUYsR0FBVUEsS0FBVjtBQUNBLGNBQVNBLEtBQVQsQ0FBZU4sYUFBZixFQUE4QjtBQUMxQjFJLFdBQUUwRyxJQUFGLENBQU8xRyxFQUFFeUksS0FBRixDQUFRQyxhQUFSLEdBQVA7QUFDSDs7QUFFRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkExSSxPQUFFLFFBQUYsSUFBY2lKLE9BQWQ7QUFDQSxjQUFTQSxPQUFULENBQWlCcm5ELEtBQWpCLEVBQXdCO0FBQ3BCLGVBQU0sSUFBSThnRCxZQUFKLENBQWlCOWdELEtBQWpCLENBQU47QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBZUFvK0MsT0FBRWtKLFFBQUYsR0FBYUEsUUFBYjtBQUNBLGNBQVNBLFFBQVQsQ0FBa0JwZ0MsUUFBbEIsRUFBNEI7QUFDeEIsZ0JBQU8sWUFBWTtBQUNmLG9CQUFPcTlCLE9BQU8sQ0FBQyxJQUFELEVBQU81VSxJQUFJNzNDLFNBQUosQ0FBUCxDQUFQLEVBQStCLFVBQVVpQixJQUFWLEVBQWdCK1UsSUFBaEIsRUFBc0I7QUFDeEQsd0JBQU9vWixTQUFTcnZCLEtBQVQsQ0FBZWtCLElBQWYsRUFBcUIrVSxJQUFyQixDQUFQO0FBQ0gsY0FGTSxDQUFQO0FBR0gsVUFKRDtBQUtIOztBQUVEOzs7Ozs7O0FBT0Fzd0MsT0FBRXdJLFFBQUYsR0FBYUEsUUFBYjtBQUNBLGNBQVNBLFFBQVQsQ0FBa0JsRyxNQUFsQixFQUEwQjBDLEVBQTFCLEVBQThCdDFDLElBQTlCLEVBQW9DO0FBQ2hDLGdCQUFPc3dDLEVBQUVzQyxNQUFGLEVBQVVrRyxRQUFWLENBQW1CeEQsRUFBbkIsRUFBdUJ0MUMsSUFBdkIsQ0FBUDtBQUNIOztBQUVEeEMsYUFBUTVULFNBQVIsQ0FBa0JrdkQsUUFBbEIsR0FBNkIsVUFBVXhELEVBQVYsRUFBY3QxQyxJQUFkLEVBQW9CO0FBQzdDLGFBQUkvVSxPQUFPLElBQVg7QUFDQSxhQUFJbXFELFdBQVcxa0QsT0FBZjtBQUNBNC9DLFdBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkJqUyxrQkFBS29xRCxlQUFMLENBQXFCRCxTQUFTdmtELE9BQTlCLEVBQXVDeWtELEVBQXZDLEVBQTJDdDFDLElBQTNDO0FBQ0gsVUFGRDtBQUdBLGdCQUFPbzFDLFNBQVNwa0QsT0FBaEI7QUFDSCxNQVBEOztBQVNBOzs7Ozs7QUFNQXMvQyxPQUFFajBDLEdBQUYsR0FBUSxVQUFVdTJDLE1BQVYsRUFBa0J4K0MsR0FBbEIsRUFBdUI7QUFDM0IsZ0JBQU9rOEMsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsS0FBbkIsRUFBMEIsQ0FBQzFrRCxHQUFELENBQTFCLENBQVA7QUFDSCxNQUZEOztBQUlBb0osYUFBUTVULFNBQVIsQ0FBa0J5UyxHQUFsQixHQUF3QixVQUFVakksR0FBVixFQUFlO0FBQ25DLGdCQUFPLEtBQUswa0QsUUFBTCxDQUFjLEtBQWQsRUFBcUIsQ0FBQzFrRCxHQUFELENBQXJCLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7Ozs7O0FBT0FrOEMsT0FBRTl4QyxHQUFGLEdBQVEsVUFBVW8wQyxNQUFWLEVBQWtCeCtDLEdBQWxCLEVBQXVCbEMsS0FBdkIsRUFBOEI7QUFDbEMsZ0JBQU9vK0MsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsS0FBbkIsRUFBMEIsQ0FBQzFrRCxHQUFELEVBQU1sQyxLQUFOLENBQTFCLENBQVA7QUFDSCxNQUZEOztBQUlBc0wsYUFBUTVULFNBQVIsQ0FBa0I0VSxHQUFsQixHQUF3QixVQUFVcEssR0FBVixFQUFlbEMsS0FBZixFQUFzQjtBQUMxQyxnQkFBTyxLQUFLNG1ELFFBQUwsQ0FBYyxLQUFkLEVBQXFCLENBQUMxa0QsR0FBRCxFQUFNbEMsS0FBTixDQUFyQixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7Ozs7O0FBTUFvK0MsT0FBRWx1QyxHQUFGLEdBQVE7QUFDUmt1QyxPQUFFLFFBQUYsSUFBYyxVQUFVc0MsTUFBVixFQUFrQngrQyxHQUFsQixFQUF1QjtBQUNqQyxnQkFBT2s4QyxFQUFFc0MsTUFBRixFQUFVa0csUUFBVixDQUFtQixRQUFuQixFQUE2QixDQUFDMWtELEdBQUQsQ0FBN0IsQ0FBUDtBQUNILE1BSEQ7O0FBS0FvSixhQUFRNVQsU0FBUixDQUFrQndZLEdBQWxCLEdBQXdCO0FBQ3hCNUUsYUFBUTVULFNBQVIsQ0FBa0IsUUFBbEIsSUFBOEIsVUFBVXdLLEdBQVYsRUFBZTtBQUN6QyxnQkFBTyxLQUFLMGtELFFBQUwsQ0FBYyxRQUFkLEVBQXdCLENBQUMxa0QsR0FBRCxDQUF4QixDQUFQO0FBQ0gsTUFIRDs7QUFLQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQWs4QyxPQUFFbUosTUFBRixHQUFXO0FBQ1huSixPQUFFb0osSUFBRixHQUFTLFVBQVU5RyxNQUFWLEVBQWtCOW5ELElBQWxCLEVBQXdCa1YsSUFBeEIsRUFBOEI7QUFDbkMsZ0JBQU9zd0MsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsTUFBbkIsRUFBMkIsQ0FBQ2h1RCxJQUFELEVBQU9rVixJQUFQLENBQTNCLENBQVA7QUFDSCxNQUhEOztBQUtBeEMsYUFBUTVULFNBQVIsQ0FBa0I2dkQsTUFBbEIsR0FBMkI7QUFDM0JqOEMsYUFBUTVULFNBQVIsQ0FBa0I4dkQsSUFBbEIsR0FBeUIsVUFBVTV1RCxJQUFWLEVBQWdCa1YsSUFBaEIsRUFBc0I7QUFDM0MsZ0JBQU8sS0FBSzg0QyxRQUFMLENBQWMsTUFBZCxFQUFzQixDQUFDaHVELElBQUQsRUFBT2tWLElBQVAsQ0FBdEIsQ0FBUDtBQUNILE1BSEQ7O0FBS0E7Ozs7Ozs7QUFPQXN3QyxPQUFFcUosSUFBRixHQUFTO0FBQ1RySixPQUFFc0osS0FBRixHQUFVO0FBQ1Z0SixPQUFFdUosTUFBRixHQUFXLFVBQVVqSCxNQUFWLEVBQWtCOW5ELElBQWxCLENBQXVCLFdBQXZCLEVBQW9DO0FBQzNDLGdCQUFPd2xELEVBQUVzQyxNQUFGLEVBQVVrRyxRQUFWLENBQW1CLE1BQW5CLEVBQTJCLENBQUNodUQsSUFBRCxFQUFPaW5ELFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFQLENBQTNCLENBQVA7QUFDSCxNQUpEOztBQU1Bd1QsYUFBUTVULFNBQVIsQ0FBa0IrdkQsSUFBbEIsR0FBeUI7QUFDekJuOEMsYUFBUTVULFNBQVIsQ0FBa0Jnd0QsS0FBbEIsR0FBMEI7QUFDMUJwOEMsYUFBUTVULFNBQVIsQ0FBa0Jpd0QsTUFBbEIsR0FBMkIsVUFBVS91RCxJQUFWLENBQWUsV0FBZixFQUE0QjtBQUNuRCxnQkFBTyxLQUFLZ3VELFFBQUwsQ0FBYyxNQUFkLEVBQXNCLENBQUNodUQsSUFBRCxFQUFPaW5ELFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFQLENBQXRCLENBQVA7QUFDSCxNQUpEOztBQU1BOzs7OztBQUtBc21ELE9BQUV3SixNQUFGLEdBQVcsVUFBVWxILE1BQVYsRUFBa0I1eUMsSUFBbEIsRUFBd0I7QUFDL0IsZ0JBQU9zd0MsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsT0FBbkIsRUFBNEIsQ0FBQyxLQUFLLENBQU4sRUFBUzk0QyxJQUFULENBQTVCLENBQVA7QUFDSCxNQUZEOztBQUlBeEMsYUFBUTVULFNBQVIsQ0FBa0Jrd0QsTUFBbEIsR0FBMkIsVUFBVTk1QyxJQUFWLEVBQWdCO0FBQ3ZDLGdCQUFPLEtBQUs4NEMsUUFBTCxDQUFjLE9BQWQsRUFBdUIsQ0FBQyxLQUFLLENBQU4sRUFBUzk0QyxJQUFULENBQXZCLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7OztBQUtBc3dDLE9BQUUsS0FBRixJQUNBQSxFQUFFbUgsS0FBRixHQUFVLFVBQVU3RSxNQUFWLENBQWlCLFlBQWpCLEVBQStCO0FBQ3JDLGdCQUFPdEMsRUFBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsT0FBbkIsRUFBNEIsQ0FBQyxLQUFLLENBQU4sRUFBUy9HLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFULENBQTVCLENBQVA7QUFDSCxNQUhEOztBQUtBd1QsYUFBUTVULFNBQVIsQ0FBa0I2dEQsS0FBbEIsR0FBMEIsWUFBVSxXQUFhO0FBQzdDLGdCQUFPLEtBQUtxQixRQUFMLENBQWMsT0FBZCxFQUF1QixDQUFDLEtBQUssQ0FBTixFQUFTL0csWUFBWS9uRCxTQUFaLENBQVQsQ0FBdkIsQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7OztBQU1Bc21ELE9BQUV5SixLQUFGLEdBQVUsVUFBVW5ILE1BQVYsQ0FBaUIsV0FBakIsRUFBOEI7QUFDcEMsYUFBSTVoRCxVQUFVcy9DLEVBQUVzQyxNQUFGLENBQWQ7QUFDQSxhQUFJNXlDLE9BQU8reEMsWUFBWS9uRCxTQUFaLEVBQXVCLENBQXZCLENBQVg7QUFDQSxnQkFBTyxTQUFTZ3dELE1BQVQsR0FBa0I7QUFDckIsb0JBQU9ocEQsUUFBUThuRCxRQUFSLENBQWlCLE9BQWpCLEVBQTBCLENBQzdCLElBRDZCLEVBRTdCOTRDLEtBQUt6SixNQUFMLENBQVl3N0MsWUFBWS9uRCxTQUFaLENBQVosQ0FGNkIsQ0FBMUIsQ0FBUDtBQUlILFVBTEQ7QUFNSCxNQVREO0FBVUF3VCxhQUFRNVQsU0FBUixDQUFrQm13RCxLQUFsQixHQUEwQixZQUFVLFdBQWE7QUFDN0MsYUFBSS9vRCxVQUFVLElBQWQ7QUFDQSxhQUFJZ1AsT0FBTyt4QyxZQUFZL25ELFNBQVosQ0FBWDtBQUNBLGdCQUFPLFNBQVNnd0QsTUFBVCxHQUFrQjtBQUNyQixvQkFBT2hwRCxRQUFROG5ELFFBQVIsQ0FBaUIsT0FBakIsRUFBMEIsQ0FDN0IsSUFENkIsRUFFN0I5NEMsS0FBS3pKLE1BQUwsQ0FBWXc3QyxZQUFZL25ELFNBQVosQ0FBWixDQUY2QixDQUExQixDQUFQO0FBSUgsVUFMRDtBQU1ILE1BVEQ7O0FBV0E7Ozs7OztBQU1Bc21ELE9BQUVsL0MsSUFBRixHQUFTLFVBQVV3aEQsTUFBVixFQUFrQjtBQUN2QixnQkFBT3RDLEVBQUVzQyxNQUFGLEVBQVVrRyxRQUFWLENBQW1CLE1BQW5CLEVBQTJCLEVBQTNCLENBQVA7QUFDSCxNQUZEOztBQUlBdDdDLGFBQVE1VCxTQUFSLENBQWtCd0gsSUFBbEIsR0FBeUIsWUFBWTtBQUNqQyxnQkFBTyxLQUFLMG5ELFFBQUwsQ0FBYyxNQUFkLEVBQXNCLEVBQXRCLENBQVA7QUFDSCxNQUZEOztBQUlBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBeEksT0FBRXpPLEdBQUYsR0FBUUEsR0FBUjtBQUNBLGNBQVNBLEdBQVQsQ0FBYW9ZLFFBQWIsRUFBdUI7QUFDbkIsZ0JBQU90QyxLQUFLc0MsUUFBTCxFQUFlLFVBQVVBLFFBQVYsRUFBb0I7QUFDdEMsaUJBQUlDLGVBQWUsQ0FBbkI7QUFDQSxpQkFBSTlFLFdBQVcxa0QsT0FBZjtBQUNBc2hELDBCQUFhaUksUUFBYixFQUF1QixVQUFVOXZELFNBQVYsRUFBcUI2RyxPQUFyQixFQUE4QnpDLEtBQTlCLEVBQXFDO0FBQ3hELHFCQUFJNHJELFFBQUo7QUFDQSxxQkFDSXhFLFVBQVUza0QsT0FBVixLQUNBLENBQUNtcEQsV0FBV25wRCxRQUFRNGtELE9BQVIsRUFBWixFQUErQm5NLEtBQS9CLEtBQXlDLFdBRjdDLEVBR0U7QUFDRXdRLDhCQUFTMXJELEtBQVQsSUFBa0I0ckQsU0FBU2pvRCxLQUEzQjtBQUNILGtCQUxELE1BS087QUFDSCx1QkFBRWdvRCxZQUFGO0FBQ0F2QywwQkFDSTNtRCxPQURKLEVBRUksVUFBVWtCLEtBQVYsRUFBaUI7QUFDYituRCxrQ0FBUzFyRCxLQUFULElBQWtCMkQsS0FBbEI7QUFDQSw2QkFBSSxFQUFFZ29ELFlBQUYsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEI5RSxzQ0FBU3ZrRCxPQUFULENBQWlCb3BELFFBQWpCO0FBQ0g7QUFDSixzQkFQTCxFQVFJN0UsU0FBU3JrRCxNQVJiLEVBU0ksVUFBVWlsRCxRQUFWLEVBQW9CO0FBQ2hCWixrQ0FBUy8xQyxNQUFULENBQWdCLEVBQUU5USxPQUFPQSxLQUFULEVBQWdCMkQsT0FBTzhqRCxRQUF2QixFQUFoQjtBQUNILHNCQVhMO0FBYUg7QUFDSixjQXZCRCxFQXVCRyxLQUFLLENBdkJSO0FBd0JBLGlCQUFJa0UsaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3BCOUUsMEJBQVN2a0QsT0FBVCxDQUFpQm9wRCxRQUFqQjtBQUNIO0FBQ0Qsb0JBQU83RSxTQUFTcGtELE9BQWhCO0FBQ0gsVUEvQk0sQ0FBUDtBQWdDSDs7QUFFRHdNLGFBQVE1VCxTQUFSLENBQWtCaTRDLEdBQWxCLEdBQXdCLFlBQVk7QUFDaEMsZ0JBQU9BLElBQUksSUFBSixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7Ozs7OztBQU9BeU8sT0FBRThKLEdBQUYsR0FBUUEsR0FBUjs7QUFFQSxjQUFTQSxHQUFULENBQWFILFFBQWIsRUFBdUI7QUFDbkIsYUFBSUEsU0FBU3p2RCxNQUFULEtBQW9CLENBQXhCLEVBQTJCO0FBQ3ZCLG9CQUFPOGxELEVBQUV6L0MsT0FBRixFQUFQO0FBQ0g7O0FBRUQsYUFBSXVrRCxXQUFXOUUsRUFBRTUvQyxLQUFGLEVBQWY7QUFDQSxhQUFJd3BELGVBQWUsQ0FBbkI7QUFDQWxJLHNCQUFhaUksUUFBYixFQUF1QixVQUFVOXVCLElBQVYsRUFBZ0I1TCxPQUFoQixFQUF5Qmh4QixLQUF6QixFQUFnQztBQUNuRCxpQkFBSXlDLFVBQVVpcEQsU0FBUzFyRCxLQUFULENBQWQ7O0FBRUEyckQ7O0FBRUF2QyxrQkFBSzNtRCxPQUFMLEVBQWNxcEQsV0FBZCxFQUEyQkMsVUFBM0IsRUFBdUNDLFVBQXZDO0FBQ0Esc0JBQVNGLFdBQVQsQ0FBcUJuNkMsTUFBckIsRUFBNkI7QUFDekJrMUMsMEJBQVN2a0QsT0FBVCxDQUFpQnFQLE1BQWpCO0FBQ0g7QUFDRCxzQkFBU282QyxVQUFULENBQW9Cai9DLEdBQXBCLEVBQXlCO0FBQ3JCNitDO0FBQ0EscUJBQUlBLGlCQUFpQixDQUFyQixFQUF3QjtBQUNwQjcrQyx5QkFBSTA2QyxPQUFKLEdBQWUseURBQ1gsOENBRFcsR0FDc0MxNkMsSUFBSTA2QyxPQUR6RDtBQUVBWCw4QkFBU3JrRCxNQUFULENBQWdCc0ssR0FBaEI7QUFDSDtBQUNKO0FBQ0Qsc0JBQVNrL0MsVUFBVCxDQUFvQnZFLFFBQXBCLEVBQThCO0FBQzFCWiwwQkFBUy8xQyxNQUFULENBQWdCO0FBQ1o5USw0QkFBT0EsS0FESztBQUVaMkQsNEJBQU84akQ7QUFGSyxrQkFBaEI7QUFJSDtBQUNKLFVBdkJELEVBdUJHN3JELFNBdkJIOztBQXlCQSxnQkFBT2lyRCxTQUFTcGtELE9BQWhCO0FBQ0g7O0FBRUR3TSxhQUFRNVQsU0FBUixDQUFrQnd3RCxHQUFsQixHQUF3QixZQUFZO0FBQ2hDLGdCQUFPQSxJQUFJLElBQUosQ0FBUDtBQUNILE1BRkQ7O0FBSUE7Ozs7Ozs7OztBQVNBOUosT0FBRWtLLFdBQUYsR0FBZ0IvRixVQUFVK0YsV0FBVixFQUF1QixhQUF2QixFQUFzQyxZQUF0QyxDQUFoQjtBQUNBLGNBQVNBLFdBQVQsQ0FBcUJQLFFBQXJCLEVBQStCO0FBQzNCLGdCQUFPdEMsS0FBS3NDLFFBQUwsRUFBZSxVQUFVQSxRQUFWLEVBQW9CO0FBQ3RDQSx3QkFBVzlILFVBQVU4SCxRQUFWLEVBQW9CM0osQ0FBcEIsQ0FBWDtBQUNBLG9CQUFPcUgsS0FBSzlWLElBQUlzUSxVQUFVOEgsUUFBVixFQUFvQixVQUFVanBELE9BQVYsRUFBbUI7QUFDbkQsd0JBQU8ybUQsS0FBSzNtRCxPQUFMLEVBQWM3SCxJQUFkLEVBQW9CQSxJQUFwQixDQUFQO0FBQ0gsY0FGZSxDQUFKLENBQUwsRUFFRixZQUFZO0FBQ2Isd0JBQU84d0QsUUFBUDtBQUNILGNBSk0sQ0FBUDtBQUtILFVBUE0sQ0FBUDtBQVFIOztBQUVEejhDLGFBQVE1VCxTQUFSLENBQWtCNHdELFdBQWxCLEdBQWdDLFlBQVk7QUFDeEMsZ0JBQU9BLFlBQVksSUFBWixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7O0FBR0FsSyxPQUFFbUssVUFBRixHQUFlQSxVQUFmO0FBQ0EsY0FBU0EsVUFBVCxDQUFvQlIsUUFBcEIsRUFBOEI7QUFDMUIsZ0JBQU8zSixFQUFFMkosUUFBRixFQUFZUSxVQUFaLEVBQVA7QUFDSDs7QUFFRDs7Ozs7OztBQU9BajlDLGFBQVE1VCxTQUFSLENBQWtCNndELFVBQWxCLEdBQStCLFlBQVk7QUFDdkMsZ0JBQU8sS0FBSzFxRCxJQUFMLENBQVUsVUFBVWtxRCxRQUFWLEVBQW9CO0FBQ2pDLG9CQUFPcFksSUFBSXNRLFVBQVU4SCxRQUFWLEVBQW9CLFVBQVVqcEQsT0FBVixFQUFtQjtBQUM5Q0EsMkJBQVVzL0MsRUFBRXQvQyxPQUFGLENBQVY7QUFDQSwwQkFBUzBwRCxVQUFULEdBQXNCO0FBQ2xCLDRCQUFPMXBELFFBQVE0a0QsT0FBUixFQUFQO0FBQ0g7QUFDRCx3QkFBTzVrRCxRQUFRakIsSUFBUixDQUFhMnFELFVBQWIsRUFBeUJBLFVBQXpCLENBQVA7QUFDSCxjQU5VLENBQUosQ0FBUDtBQU9ILFVBUk0sQ0FBUDtBQVNILE1BVkQ7O0FBWUE7Ozs7Ozs7OztBQVNBcEssT0FBRXFLLElBQUYsR0FBUztBQUNUckssT0FBRSxPQUFGLElBQWEsVUFBVXNDLE1BQVYsRUFBa0JrRSxRQUFsQixFQUE0QjtBQUNyQyxnQkFBT3hHLEVBQUVzQyxNQUFGLEVBQVU3aUQsSUFBVixDQUFlLEtBQUssQ0FBcEIsRUFBdUIrbUQsUUFBdkIsQ0FBUDtBQUNILE1BSEQ7O0FBS0F0NUMsYUFBUTVULFNBQVIsQ0FBa0Ird0QsSUFBbEIsR0FBeUI7QUFDekJuOUMsYUFBUTVULFNBQVIsQ0FBa0IsT0FBbEIsSUFBNkIsVUFBVWt0RCxRQUFWLEVBQW9CO0FBQzdDLGdCQUFPLEtBQUsvbUQsSUFBTCxDQUFVLEtBQUssQ0FBZixFQUFrQittRCxRQUFsQixDQUFQO0FBQ0gsTUFIRDs7QUFLQTs7Ozs7Ozs7QUFRQXhHLE9BQUUwRixRQUFGLEdBQWFBLFFBQWI7QUFDQSxjQUFTQSxRQUFULENBQWtCcEQsTUFBbEIsRUFBMEJtRSxVQUExQixFQUFzQztBQUNsQyxnQkFBT3pHLEVBQUVzQyxNQUFGLEVBQVU3aUQsSUFBVixDQUFlLEtBQUssQ0FBcEIsRUFBdUIsS0FBSyxDQUE1QixFQUErQmduRCxVQUEvQixDQUFQO0FBQ0g7O0FBRUR2NUMsYUFBUTVULFNBQVIsQ0FBa0Jvc0QsUUFBbEIsR0FBNkIsVUFBVWUsVUFBVixFQUFzQjtBQUMvQyxnQkFBTyxLQUFLaG5ELElBQUwsQ0FBVSxLQUFLLENBQWYsRUFBa0IsS0FBSyxDQUF2QixFQUEwQmduRCxVQUExQixDQUFQO0FBQ0gsTUFGRDs7QUFJQTs7Ozs7Ozs7Ozs7QUFXQXpHLE9BQUVzSyxHQUFGLEdBQVE7QUFDUnRLLE9BQUUsU0FBRixJQUFlLFVBQVVzQyxNQUFWLEVBQWtCeDVCLFFBQWxCLEVBQTRCO0FBQ3ZDLGdCQUFPazNCLEVBQUVzQyxNQUFGLEVBQVUsU0FBVixFQUFxQng1QixRQUFyQixDQUFQO0FBQ0gsTUFIRDs7QUFLQTViLGFBQVE1VCxTQUFSLENBQWtCZ3hELEdBQWxCLEdBQXdCO0FBQ3hCcDlDLGFBQVE1VCxTQUFSLENBQWtCLFNBQWxCLElBQStCLFVBQVV3dkIsUUFBVixFQUFvQjtBQUMvQyxhQUFJLENBQUNBLFFBQUQsSUFBYSxPQUFPQSxTQUFTcnZCLEtBQWhCLEtBQTBCLFVBQTNDLEVBQXVEO0FBQ25ELG1CQUFNLElBQUl3a0QsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSDtBQUNEbjFCLG9CQUFXazNCLEVBQUVsM0IsUUFBRixDQUFYO0FBQ0EsZ0JBQU8sS0FBS3JwQixJQUFMLENBQVUsVUFBVW1DLEtBQVYsRUFBaUI7QUFDOUIsb0JBQU9rbkIsU0FBU3ErQixLQUFULEdBQWlCMW5ELElBQWpCLENBQXNCLFlBQVk7QUFDckMsd0JBQU9tQyxLQUFQO0FBQ0gsY0FGTSxDQUFQO0FBR0gsVUFKTSxFQUlKLFVBQVVxYSxNQUFWLEVBQWtCO0FBQ2pCO0FBQ0Esb0JBQU82TSxTQUFTcStCLEtBQVQsR0FBaUIxbkQsSUFBakIsQ0FBc0IsWUFBWTtBQUNyQyx1QkFBTXdjLE1BQU47QUFDSCxjQUZNLENBQVA7QUFHSCxVQVRNLENBQVA7QUFVSCxNQWhCRDs7QUFrQkE7Ozs7OztBQU1BK2pDLE9BQUUwRyxJQUFGLEdBQVMsVUFBVXBFLE1BQVYsRUFBa0JpRSxTQUFsQixFQUE2QkMsUUFBN0IsRUFBdUNkLFFBQXZDLEVBQWlEO0FBQ3RELGdCQUFPMUYsRUFBRXNDLE1BQUYsRUFBVW9FLElBQVYsQ0FBZUgsU0FBZixFQUEwQkMsUUFBMUIsRUFBb0NkLFFBQXBDLENBQVA7QUFDSCxNQUZEOztBQUlBeDRDLGFBQVE1VCxTQUFSLENBQWtCb3RELElBQWxCLEdBQXlCLFVBQVVILFNBQVYsRUFBcUJDLFFBQXJCLEVBQStCZCxRQUEvQixFQUF5QztBQUM5RCxhQUFJNkUsbUJBQW1CLDBCQUFVeHFELEtBQVYsRUFBaUI7QUFDcEM7QUFDQTtBQUNBaWdELGVBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkJpMkMsb0NBQW1COWlELEtBQW5CLEVBQTBCVyxPQUExQjtBQUNBLHFCQUFJcy9DLEVBQUVpSCxPQUFOLEVBQWU7QUFDWGpILHVCQUFFaUgsT0FBRixDQUFVbG5ELEtBQVY7QUFDSCxrQkFGRCxNQUVPO0FBQ0gsMkJBQU1BLEtBQU47QUFDSDtBQUNKLGNBUEQ7QUFRSCxVQVhEOztBQWFBO0FBQ0EsYUFBSVcsVUFBVTZsRCxhQUFhQyxRQUFiLElBQXlCZCxRQUF6QixHQUNWLEtBQUtqbUQsSUFBTCxDQUFVOG1ELFNBQVYsRUFBcUJDLFFBQXJCLEVBQStCZCxRQUEvQixDQURVLEdBRVYsSUFGSjs7QUFJQSxhQUFJLFFBQU9uK0MsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUErQkEsT0FBL0IsSUFBMENBLFFBQVFxNUMsTUFBdEQsRUFBOEQ7QUFDMUQySixnQ0FBbUJoakQsUUFBUXE1QyxNQUFSLENBQWV4bkQsSUFBZixDQUFvQm14RCxnQkFBcEIsQ0FBbkI7QUFDSDs7QUFFRDdwRCxpQkFBUWpCLElBQVIsQ0FBYSxLQUFLLENBQWxCLEVBQXFCOHFELGdCQUFyQjtBQUNILE1BeEJEOztBQTBCQTs7Ozs7Ozs7O0FBU0F2SyxPQUFFNWpDLE9BQUYsR0FBWSxVQUFVa21DLE1BQVYsRUFBa0JrSSxFQUFsQixFQUFzQnpxRCxLQUF0QixFQUE2QjtBQUNyQyxnQkFBT2lnRCxFQUFFc0MsTUFBRixFQUFVbG1DLE9BQVYsQ0FBa0JvdUMsRUFBbEIsRUFBc0J6cUQsS0FBdEIsQ0FBUDtBQUNILE1BRkQ7O0FBSUFtTixhQUFRNVQsU0FBUixDQUFrQjhpQixPQUFsQixHQUE0QixVQUFVb3VDLEVBQVYsRUFBY3pxRCxLQUFkLEVBQXFCO0FBQzdDLGFBQUkra0QsV0FBVzFrRCxPQUFmO0FBQ0EsYUFBSXFxRCxZQUFZcDlDLFdBQVcsWUFBWTtBQUNuQyxpQkFBSSxDQUFDdE4sS0FBRCxJQUFVLGFBQWEsT0FBT0EsS0FBbEMsRUFBeUM7QUFDckNBLHlCQUFRLElBQUlrK0MsS0FBSixDQUFVbCtDLFNBQVMscUJBQXFCeXFELEVBQXJCLEdBQTBCLEtBQTdDLENBQVI7QUFDQXpxRCx1QkFBTTArQixJQUFOLEdBQWEsV0FBYjtBQUNIO0FBQ0RxbUIsc0JBQVNya0QsTUFBVCxDQUFnQlYsS0FBaEI7QUFDSCxVQU5lLEVBTWJ5cUQsRUFOYSxDQUFoQjs7QUFRQSxjQUFLL3FELElBQUwsQ0FBVSxVQUFVbUMsS0FBVixFQUFpQjtBQUN2QnU4QywwQkFBYXNNLFNBQWI7QUFDQTNGLHNCQUFTdmtELE9BQVQsQ0FBaUJxQixLQUFqQjtBQUNILFVBSEQsRUFHRyxVQUFVNmdELFNBQVYsRUFBcUI7QUFDcEJ0RSwwQkFBYXNNLFNBQWI7QUFDQTNGLHNCQUFTcmtELE1BQVQsQ0FBZ0JnaUQsU0FBaEI7QUFDSCxVQU5ELEVBTUdxQyxTQUFTLzFDLE1BTlo7O0FBUUEsZ0JBQU8rMUMsU0FBU3BrRCxPQUFoQjtBQUNILE1BbkJEOztBQXFCQTs7Ozs7Ozs7O0FBU0FzL0MsT0FBRTdqQyxLQUFGLEdBQVUsVUFBVW1tQyxNQUFWLEVBQWtCbG1DLE9BQWxCLEVBQTJCO0FBQ2pDLGFBQUlBLFlBQVksS0FBSyxDQUFyQixFQUF3QjtBQUNwQkEsdUJBQVVrbUMsTUFBVjtBQUNBQSxzQkFBUyxLQUFLLENBQWQ7QUFDSDtBQUNELGdCQUFPdEMsRUFBRXNDLE1BQUYsRUFBVW5tQyxLQUFWLENBQWdCQyxPQUFoQixDQUFQO0FBQ0gsTUFORDs7QUFRQWxQLGFBQVE1VCxTQUFSLENBQWtCNmlCLEtBQWxCLEdBQTBCLFVBQVVDLE9BQVYsRUFBbUI7QUFDekMsZ0JBQU8sS0FBSzNjLElBQUwsQ0FBVSxVQUFVbUMsS0FBVixFQUFpQjtBQUM5QixpQkFBSWtqRCxXQUFXMWtELE9BQWY7QUFDQWlOLHdCQUFXLFlBQVk7QUFDbkJ5M0MsMEJBQVN2a0QsT0FBVCxDQUFpQnFCLEtBQWpCO0FBQ0gsY0FGRCxFQUVHd2EsT0FGSDtBQUdBLG9CQUFPMG9DLFNBQVNwa0QsT0FBaEI7QUFDSCxVQU5NLENBQVA7QUFPSCxNQVJEOztBQVVBOzs7Ozs7Ozs7QUFTQXMvQyxPQUFFMEssT0FBRixHQUFZLFVBQVU1aEMsUUFBVixFQUFvQnBaLElBQXBCLEVBQTBCO0FBQ2xDLGdCQUFPc3dDLEVBQUVsM0IsUUFBRixFQUFZNGhDLE9BQVosQ0FBb0JoN0MsSUFBcEIsQ0FBUDtBQUNILE1BRkQ7O0FBSUF4QyxhQUFRNVQsU0FBUixDQUFrQm94RCxPQUFsQixHQUE0QixVQUFVaDdDLElBQVYsRUFBZ0I7QUFDeEMsYUFBSW8xQyxXQUFXMWtELE9BQWY7QUFDQSxhQUFJdXFELFdBQVdsSixZQUFZL3hDLElBQVosQ0FBZjtBQUNBaTdDLGtCQUFTOS9DLElBQVQsQ0FBY2k2QyxTQUFTYyxnQkFBVCxFQUFkO0FBQ0EsY0FBSzRELE1BQUwsQ0FBWW1CLFFBQVosRUFBc0JOLElBQXRCLENBQTJCdkYsU0FBU3JrRCxNQUFwQztBQUNBLGdCQUFPcWtELFNBQVNwa0QsT0FBaEI7QUFDSCxNQU5EOztBQVFBOzs7Ozs7Ozs7QUFTQXMvQyxPQUFFNEssTUFBRixHQUFXLFVBQVU5aEMsUUFBVixDQUFtQixXQUFuQixFQUFnQztBQUN2QyxhQUFJcFosT0FBTyt4QyxZQUFZL25ELFNBQVosRUFBdUIsQ0FBdkIsQ0FBWDtBQUNBLGdCQUFPc21ELEVBQUVsM0IsUUFBRixFQUFZNGhDLE9BQVosQ0FBb0JoN0MsSUFBcEIsQ0FBUDtBQUNILE1BSEQ7O0FBS0F4QyxhQUFRNVQsU0FBUixDQUFrQnN4RCxNQUFsQixHQUEyQixZQUFVLFdBQWE7QUFDOUMsYUFBSUQsV0FBV2xKLFlBQVkvbkQsU0FBWixDQUFmO0FBQ0EsYUFBSW9yRCxXQUFXMWtELE9BQWY7QUFDQXVxRCxrQkFBUzkvQyxJQUFULENBQWNpNkMsU0FBU2MsZ0JBQVQsRUFBZDtBQUNBLGNBQUs0RCxNQUFMLENBQVltQixRQUFaLEVBQXNCTixJQUF0QixDQUEyQnZGLFNBQVNya0QsTUFBcEM7QUFDQSxnQkFBT3FrRCxTQUFTcGtELE9BQWhCO0FBQ0gsTUFORDs7QUFRQTs7Ozs7Ozs7QUFRQXMvQyxPQUFFNkssTUFBRixHQUNBN0ssRUFBRThLLFNBQUYsR0FBYyxVQUFVaGlDLFFBQVYsQ0FBbUIsV0FBbkIsRUFBZ0M7QUFDMUMsYUFBSUEsYUFBYWp2QixTQUFqQixFQUE0QjtBQUN4QixtQkFBTSxJQUFJb2tELEtBQUosQ0FBVSxvQ0FBVixDQUFOO0FBQ0g7QUFDRCxhQUFJOE0sV0FBV3RKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsZ0JBQU8sWUFBWTtBQUNmLGlCQUFJaXhELFdBQVdJLFNBQVM5a0QsTUFBVCxDQUFnQnc3QyxZQUFZL25ELFNBQVosQ0FBaEIsQ0FBZjtBQUNBLGlCQUFJb3JELFdBQVcxa0QsT0FBZjtBQUNBdXFELHNCQUFTOS9DLElBQVQsQ0FBY2k2QyxTQUFTYyxnQkFBVCxFQUFkO0FBQ0E1RixlQUFFbDNCLFFBQUYsRUFBWTBnQyxNQUFaLENBQW1CbUIsUUFBbkIsRUFBNkJOLElBQTdCLENBQWtDdkYsU0FBU3JrRCxNQUEzQztBQUNBLG9CQUFPcWtELFNBQVNwa0QsT0FBaEI7QUFDSCxVQU5EO0FBT0gsTUFiRDs7QUFlQXdNLGFBQVE1VCxTQUFSLENBQWtCdXhELE1BQWxCLEdBQ0EzOUMsUUFBUTVULFNBQVIsQ0FBa0J3eEQsU0FBbEIsR0FBOEIsWUFBVSxXQUFhO0FBQ2pELGFBQUlwN0MsT0FBTyt4QyxZQUFZL25ELFNBQVosQ0FBWDtBQUNBZ1csY0FBS2tlLE9BQUwsQ0FBYSxJQUFiO0FBQ0EsZ0JBQU9veUIsRUFBRThLLFNBQUYsQ0FBWXJ4RCxLQUFaLENBQWtCLEtBQUssQ0FBdkIsRUFBMEJpVyxJQUExQixDQUFQO0FBQ0gsTUFMRDs7QUFPQXN3QyxPQUFFZ0wsS0FBRixHQUFVLFVBQVVsaUMsUUFBVixFQUFvQmc1QixLQUFwQixDQUEwQixXQUExQixFQUF1QztBQUM3QyxhQUFJaUosV0FBV3RKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsZ0JBQU8sWUFBWTtBQUNmLGlCQUFJaXhELFdBQVdJLFNBQVM5a0QsTUFBVCxDQUFnQnc3QyxZQUFZL25ELFNBQVosQ0FBaEIsQ0FBZjtBQUNBLGlCQUFJb3JELFdBQVcxa0QsT0FBZjtBQUNBdXFELHNCQUFTOS9DLElBQVQsQ0FBY2k2QyxTQUFTYyxnQkFBVCxFQUFkO0FBQ0Esc0JBQVNxRixLQUFULEdBQWlCO0FBQ2Isd0JBQU9uaUMsU0FBU3J2QixLQUFULENBQWVxb0QsS0FBZixFQUFzQnBvRCxTQUF0QixDQUFQO0FBQ0g7QUFDRHNtRCxlQUFFaUwsS0FBRixFQUFTekIsTUFBVCxDQUFnQm1CLFFBQWhCLEVBQTBCTixJQUExQixDQUErQnZGLFNBQVNya0QsTUFBeEM7QUFDQSxvQkFBT3FrRCxTQUFTcGtELE9BQWhCO0FBQ0gsVUFURDtBQVVILE1BWkQ7O0FBY0F3TSxhQUFRNVQsU0FBUixDQUFrQjB4RCxLQUFsQixHQUEwQixZQUFVLGtCQUFvQjtBQUNwRCxhQUFJdDdDLE9BQU8reEMsWUFBWS9uRCxTQUFaLEVBQXVCLENBQXZCLENBQVg7QUFDQWdXLGNBQUtrZSxPQUFMLENBQWEsSUFBYjtBQUNBLGdCQUFPb3lCLEVBQUVnTCxLQUFGLENBQVF2eEQsS0FBUixDQUFjLEtBQUssQ0FBbkIsRUFBc0JpVyxJQUF0QixDQUFQO0FBQ0gsTUFKRDs7QUFNQTs7Ozs7Ozs7O0FBU0Fzd0MsT0FBRWtMLE9BQUYsR0FBWTtBQUNabEwsT0FBRW1MLEtBQUYsR0FBVSxVQUFVN0ksTUFBVixFQUFrQjluRCxJQUFsQixFQUF3QmtWLElBQXhCLEVBQThCO0FBQ3BDLGdCQUFPc3dDLEVBQUVzQyxNQUFGLEVBQVU2SSxLQUFWLENBQWdCM3dELElBQWhCLEVBQXNCa1YsSUFBdEIsQ0FBUDtBQUNILE1BSEQ7O0FBS0F4QyxhQUFRNVQsU0FBUixDQUFrQjR4RCxPQUFsQixHQUE0QjtBQUM1QmgrQyxhQUFRNVQsU0FBUixDQUFrQjZ4RCxLQUFsQixHQUEwQixVQUFVM3dELElBQVYsRUFBZ0JrVixJQUFoQixFQUFzQjtBQUM1QyxhQUFJaTdDLFdBQVdsSixZQUFZL3hDLFFBQVEsRUFBcEIsQ0FBZjtBQUNBLGFBQUlvMUMsV0FBVzFrRCxPQUFmO0FBQ0F1cUQsa0JBQVM5L0MsSUFBVCxDQUFjaTZDLFNBQVNjLGdCQUFULEVBQWQ7QUFDQSxjQUFLNEMsUUFBTCxDQUFjLE1BQWQsRUFBc0IsQ0FBQ2h1RCxJQUFELEVBQU9td0QsUUFBUCxDQUF0QixFQUF3Q04sSUFBeEMsQ0FBNkN2RixTQUFTcmtELE1BQXREO0FBQ0EsZ0JBQU9xa0QsU0FBU3BrRCxPQUFoQjtBQUNILE1BUEQ7O0FBU0E7Ozs7Ozs7Ozs7QUFVQXMvQyxPQUFFb0wsS0FBRixHQUFVO0FBQ1ZwTCxPQUFFcUwsTUFBRixHQUFXO0FBQ1hyTCxPQUFFc0wsT0FBRixHQUFZLFVBQVVoSixNQUFWLEVBQWtCOW5ELElBQWxCLENBQXVCLFdBQXZCLEVBQW9DO0FBQzVDLGFBQUltd0QsV0FBV2xKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsYUFBSW9yRCxXQUFXMWtELE9BQWY7QUFDQXVxRCxrQkFBUzkvQyxJQUFULENBQWNpNkMsU0FBU2MsZ0JBQVQsRUFBZDtBQUNBNUYsV0FBRXNDLE1BQUYsRUFBVWtHLFFBQVYsQ0FBbUIsTUFBbkIsRUFBMkIsQ0FBQ2h1RCxJQUFELEVBQU9td0QsUUFBUCxDQUEzQixFQUE2Q04sSUFBN0MsQ0FBa0R2RixTQUFTcmtELE1BQTNEO0FBQ0EsZ0JBQU9xa0QsU0FBU3BrRCxPQUFoQjtBQUNILE1BUkQ7O0FBVUF3TSxhQUFRNVQsU0FBUixDQUFrQjh4RCxLQUFsQixHQUEwQjtBQUMxQmwrQyxhQUFRNVQsU0FBUixDQUFrQit4RCxNQUFsQixHQUEyQjtBQUMzQm4rQyxhQUFRNVQsU0FBUixDQUFrQmd5RCxPQUFsQixHQUE0QixVQUFVOXdELElBQVYsQ0FBZSxXQUFmLEVBQTRCO0FBQ3BELGFBQUltd0QsV0FBV2xKLFlBQVkvbkQsU0FBWixFQUF1QixDQUF2QixDQUFmO0FBQ0EsYUFBSW9yRCxXQUFXMWtELE9BQWY7QUFDQXVxRCxrQkFBUzkvQyxJQUFULENBQWNpNkMsU0FBU2MsZ0JBQVQsRUFBZDtBQUNBLGNBQUs0QyxRQUFMLENBQWMsTUFBZCxFQUFzQixDQUFDaHVELElBQUQsRUFBT213RCxRQUFQLENBQXRCLEVBQXdDTixJQUF4QyxDQUE2Q3ZGLFNBQVNya0QsTUFBdEQ7QUFDQSxnQkFBT3FrRCxTQUFTcGtELE9BQWhCO0FBQ0gsTUFSRDs7QUFVQTs7Ozs7Ozs7OztBQVVBcy9DLE9BQUV1TCxPQUFGLEdBQVlBLE9BQVo7QUFDQSxjQUFTQSxPQUFULENBQWlCakosTUFBakIsRUFBeUJrSixRQUF6QixFQUFtQztBQUMvQixnQkFBT3hMLEVBQUVzQyxNQUFGLEVBQVVpSixPQUFWLENBQWtCQyxRQUFsQixDQUFQO0FBQ0g7O0FBRUR0K0MsYUFBUTVULFNBQVIsQ0FBa0JpeUQsT0FBbEIsR0FBNEIsVUFBVUMsUUFBVixFQUFvQjtBQUM1QyxhQUFJQSxRQUFKLEVBQWM7QUFDVixrQkFBSy9yRCxJQUFMLENBQVUsVUFBVW1DLEtBQVYsRUFBaUI7QUFDdkJvK0MsbUJBQUVwekMsUUFBRixDQUFXLFlBQVk7QUFDbkI0K0MsOEJBQVMsSUFBVCxFQUFlNXBELEtBQWY7QUFDSCxrQkFGRDtBQUdILGNBSkQsRUFJRyxVQUFVN0IsS0FBVixFQUFpQjtBQUNoQmlnRCxtQkFBRXB6QyxRQUFGLENBQVcsWUFBWTtBQUNuQjQrQyw4QkFBU3pyRCxLQUFUO0FBQ0gsa0JBRkQ7QUFHSCxjQVJEO0FBU0gsVUFWRCxNQVVPO0FBQ0gsb0JBQU8sSUFBUDtBQUNIO0FBQ0osTUFkRDs7QUFnQkFpZ0QsT0FBRWxqRCxVQUFGLEdBQWUsWUFBVztBQUN0QixlQUFNLElBQUltaEQsS0FBSixDQUFVLG9EQUFWLENBQU47QUFDSCxNQUZEOztBQUlBO0FBQ0EsU0FBSWdHLGNBQWM5RCxhQUFsQjs7QUFFQSxZQUFPSCxDQUFQO0FBRUMsRUE1L0RELEU7Ozs7Ozs7OztBQzVCQSxLQUFJdm1ELFFBQVFKLFNBQVNDLFNBQVQsQ0FBbUJHLEtBQS9COztBQUVBOztBQUVBZCxTQUFRMFUsVUFBUixHQUFxQixZQUFXO0FBQzlCLFVBQU8sSUFBSW8rQyxPQUFKLENBQVloeUQsTUFBTUYsSUFBTixDQUFXOFQsVUFBWCxFQUF1Qm5TLE1BQXZCLEVBQStCeEIsU0FBL0IsQ0FBWixFQUF1RHlrRCxZQUF2RCxDQUFQO0FBQ0QsRUFGRDtBQUdBeGxELFNBQVEreUQsV0FBUixHQUFzQixZQUFXO0FBQy9CLFVBQU8sSUFBSUQsT0FBSixDQUFZaHlELE1BQU1GLElBQU4sQ0FBV215RCxXQUFYLEVBQXdCeHdELE1BQXhCLEVBQWdDeEIsU0FBaEMsQ0FBWixFQUF3RGl5RCxhQUF4RCxDQUFQO0FBQ0QsRUFGRDtBQUdBaHpELFNBQVF3bEQsWUFBUixHQUNBeGxELFFBQVFnekQsYUFBUixHQUF3QixVQUFTdnZDLE9BQVQsRUFBa0I7QUFDeEMsT0FBSUEsT0FBSixFQUFhO0FBQ1hBLGFBQVE4d0IsS0FBUjtBQUNEO0FBQ0YsRUFMRDs7QUFPQSxVQUFTdWUsT0FBVCxDQUFpQjVzRCxFQUFqQixFQUFxQitzRCxPQUFyQixFQUE4QjtBQUM1QixRQUFLQyxHQUFMLEdBQVdodEQsRUFBWDtBQUNBLFFBQUtpdEQsUUFBTCxHQUFnQkYsT0FBaEI7QUFDRDtBQUNESCxTQUFRbnlELFNBQVIsQ0FBa0J5eUQsS0FBbEIsR0FBMEJOLFFBQVFueUQsU0FBUixDQUFrQit4QixHQUFsQixHQUF3QixZQUFXLENBQUUsQ0FBL0Q7QUFDQW9nQyxTQUFRbnlELFNBQVIsQ0FBa0I0ekMsS0FBbEIsR0FBMEIsWUFBVztBQUNuQyxRQUFLNGUsUUFBTCxDQUFjdnlELElBQWQsQ0FBbUIyQixNQUFuQixFQUEyQixLQUFLMndELEdBQWhDO0FBQ0QsRUFGRDs7QUFJQTtBQUNBbHpELFNBQVFxekQsTUFBUixHQUFpQixVQUFTdG9ELElBQVQsRUFBZXVvRCxLQUFmLEVBQXNCO0FBQ3JDOU4sZ0JBQWF6NkMsS0FBS3dvRCxjQUFsQjtBQUNBeG9ELFFBQUt5b0QsWUFBTCxHQUFvQkYsS0FBcEI7QUFDRCxFQUhEOztBQUtBdHpELFNBQVF5ekQsUUFBUixHQUFtQixVQUFTMW9ELElBQVQsRUFBZTtBQUNoQ3k2QyxnQkFBYXo2QyxLQUFLd29ELGNBQWxCO0FBQ0F4b0QsUUFBS3lvRCxZQUFMLEdBQW9CLENBQUMsQ0FBckI7QUFDRCxFQUhEOztBQUtBeHpELFNBQVEwekQsWUFBUixHQUF1QjF6RCxRQUFRK0YsTUFBUixHQUFpQixVQUFTZ0YsSUFBVCxFQUFlO0FBQ3JEeTZDLGdCQUFhejZDLEtBQUt3b0QsY0FBbEI7O0FBRUEsT0FBSUQsUUFBUXZvRCxLQUFLeW9ELFlBQWpCO0FBQ0EsT0FBSUYsU0FBUyxDQUFiLEVBQWdCO0FBQ2R2b0QsVUFBS3dvRCxjQUFMLEdBQXNCNytDLFdBQVcsU0FBU2kvQyxTQUFULEdBQXFCO0FBQ3BELFdBQUk1b0QsS0FBSzZvRCxVQUFULEVBQ0U3b0QsS0FBSzZvRCxVQUFMO0FBQ0gsTUFIcUIsRUFHbkJOLEtBSG1CLENBQXRCO0FBSUQ7QUFDRixFQVZEOztBQVlBO0FBQ0Esb0JBQUFPLENBQVEsRUFBUjtBQUNBN3pELFNBQVFvb0QsWUFBUixHQUF1QkEsWUFBdkI7QUFDQXBvRCxTQUFROHpELGNBQVIsR0FBeUJBLGNBQXpCLEM7Ozs7Ozs7O0FDcERDLFlBQVV0Z0QsTUFBVixFQUFrQnRTLFNBQWxCLEVBQTZCO0FBQzFCOztBQUVBLFNBQUlzUyxPQUFPNDBDLFlBQVgsRUFBeUI7QUFDckI7QUFDSDs7QUFFRCxTQUFJMkwsYUFBYSxDQUFqQixDQVAwQixDQU9OO0FBQ3BCLFNBQUlDLGdCQUFnQixFQUFwQjtBQUNBLFNBQUlDLHdCQUF3QixLQUE1QjtBQUNBLFNBQUlDLE1BQU0xZ0QsT0FBTzlRLFFBQWpCO0FBQ0EsU0FBSXl4RCxpQkFBSjs7QUFFQSxjQUFTL0wsWUFBVCxDQUFzQmo0QixRQUF0QixFQUFnQztBQUM5QjtBQUNBLGFBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0Esd0JBQVcsSUFBSXp2QixRQUFKLENBQWEsS0FBS3l2QixRQUFsQixDQUFYO0FBQ0Q7QUFDRDtBQUNBLGFBQUlwWixPQUFPLElBQUlySyxLQUFKLENBQVUzTCxVQUFVUSxNQUFWLEdBQW1CLENBQTdCLENBQVg7QUFDQSxjQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSXlWLEtBQUt4VixNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDbEN5VixrQkFBS3pWLENBQUwsSUFBVVAsVUFBVU8sSUFBSSxDQUFkLENBQVY7QUFDSDtBQUNEO0FBQ0EsYUFBSXFtRCxPQUFPLEVBQUV4M0IsVUFBVUEsUUFBWixFQUFzQnBaLE1BQU1BLElBQTVCLEVBQVg7QUFDQWk5Qyx1QkFBY0QsVUFBZCxJQUE0QnBNLElBQTVCO0FBQ0F3TSwyQkFBa0JKLFVBQWxCO0FBQ0EsZ0JBQU9BLFlBQVA7QUFDRDs7QUFFRCxjQUFTRCxjQUFULENBQXdCTSxNQUF4QixFQUFnQztBQUM1QixnQkFBT0osY0FBY0ksTUFBZCxDQUFQO0FBQ0g7O0FBRUQsY0FBUy9xQyxHQUFULENBQWFzK0IsSUFBYixFQUFtQjtBQUNmLGFBQUl4M0IsV0FBV3czQixLQUFLeDNCLFFBQXBCO0FBQ0EsYUFBSXBaLE9BQU80d0MsS0FBSzV3QyxJQUFoQjtBQUNBLGlCQUFRQSxLQUFLeFYsTUFBYjtBQUNBLGtCQUFLLENBQUw7QUFDSTR1QjtBQUNBO0FBQ0osa0JBQUssQ0FBTDtBQUNJQSwwQkFBU3BaLEtBQUssQ0FBTCxDQUFUO0FBQ0E7QUFDSixrQkFBSyxDQUFMO0FBQ0lvWiwwQkFBU3BaLEtBQUssQ0FBTCxDQUFULEVBQWtCQSxLQUFLLENBQUwsQ0FBbEI7QUFDQTtBQUNKLGtCQUFLLENBQUw7QUFDSW9aLDBCQUFTcFosS0FBSyxDQUFMLENBQVQsRUFBa0JBLEtBQUssQ0FBTCxDQUFsQixFQUEyQkEsS0FBSyxDQUFMLENBQTNCO0FBQ0E7QUFDSjtBQUNJb1osMEJBQVNydkIsS0FBVCxDQUFlSSxTQUFmLEVBQTBCNlYsSUFBMUI7QUFDQTtBQWZKO0FBaUJIOztBQUVELGNBQVNzOUMsWUFBVCxDQUFzQkQsTUFBdEIsRUFBOEI7QUFDMUI7QUFDQTtBQUNBLGFBQUlILHFCQUFKLEVBQTJCO0FBQ3ZCO0FBQ0E7QUFDQXYvQyx3QkFBVzIvQyxZQUFYLEVBQXlCLENBQXpCLEVBQTRCRCxNQUE1QjtBQUNILFVBSkQsTUFJTztBQUNILGlCQUFJek0sT0FBT3FNLGNBQWNJLE1BQWQsQ0FBWDtBQUNBLGlCQUFJek0sSUFBSixFQUFVO0FBQ05zTSx5Q0FBd0IsSUFBeEI7QUFDQSxxQkFBSTtBQUNBNXFDLHlCQUFJcytCLElBQUo7QUFDSCxrQkFGRCxTQUVVO0FBQ05tTSxvQ0FBZU0sTUFBZjtBQUNBSCw2Q0FBd0IsS0FBeEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRCxjQUFTSyw2QkFBVCxHQUF5QztBQUNyQ0gsNkJBQW9CLDJCQUFTQyxNQUFULEVBQWlCO0FBQ2pDeGxELHFCQUFRcUYsUUFBUixDQUFpQixZQUFZO0FBQUVvZ0QsOEJBQWFELE1BQWI7QUFBdUIsY0FBdEQ7QUFDSCxVQUZEO0FBR0g7O0FBRUQsY0FBU0csaUJBQVQsR0FBNkI7QUFDekI7QUFDQTtBQUNBLGFBQUkvZ0QsT0FBT20xQyxXQUFQLElBQXNCLENBQUNuMUMsT0FBT2doRCxhQUFsQyxFQUFpRDtBQUM3QyxpQkFBSUMsNEJBQTRCLElBQWhDO0FBQ0EsaUJBQUlDLGVBQWVsaEQsT0FBT2cxQyxTQUExQjtBQUNBaDFDLG9CQUFPZzFDLFNBQVAsR0FBbUIsWUFBVztBQUMxQmlNLDZDQUE0QixLQUE1QjtBQUNILGNBRkQ7QUFHQWpoRCxvQkFBT20xQyxXQUFQLENBQW1CLEVBQW5CLEVBQXVCLEdBQXZCO0FBQ0FuMUMsb0JBQU9nMUMsU0FBUCxHQUFtQmtNLFlBQW5CO0FBQ0Esb0JBQU9ELHlCQUFQO0FBQ0g7QUFDSjs7QUFFRCxjQUFTRSxnQ0FBVCxHQUE0QztBQUN4QztBQUNBO0FBQ0E7O0FBRUEsYUFBSUMsZ0JBQWdCLGtCQUFrQmpyRCxLQUFLa3JELE1BQUwsRUFBbEIsR0FBa0MsR0FBdEQ7QUFDQSxhQUFJQyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVN4dEQsS0FBVCxFQUFnQjtBQUNsQyxpQkFBSUEsTUFBTXNtQixNQUFOLEtBQWlCcGEsTUFBakIsSUFDQSxPQUFPbE0sTUFBTVQsSUFBYixLQUFzQixRQUR0QixJQUVBUyxNQUFNVCxJQUFOLENBQVc3RCxPQUFYLENBQW1CNHhELGFBQW5CLE1BQXNDLENBRjFDLEVBRTZDO0FBQ3pDUCw4QkFBYSxDQUFDL3NELE1BQU1ULElBQU4sQ0FBVzNELEtBQVgsQ0FBaUIweEQsY0FBY3J6RCxNQUEvQixDQUFkO0FBQ0g7QUFDSixVQU5EOztBQVFBLGFBQUlpUyxPQUFPSCxnQkFBWCxFQUE2QjtBQUN6Qkcsb0JBQU9ILGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DeWhELGVBQW5DLEVBQW9ELEtBQXBEO0FBQ0gsVUFGRCxNQUVPO0FBQ0h0aEQsb0JBQU91aEQsV0FBUCxDQUFtQixXQUFuQixFQUFnQ0QsZUFBaEM7QUFDSDs7QUFFRFgsNkJBQW9CLDJCQUFTQyxNQUFULEVBQWlCO0FBQ2pDNWdELG9CQUFPbTFDLFdBQVAsQ0FBbUJpTSxnQkFBZ0JSLE1BQW5DLEVBQTJDLEdBQTNDO0FBQ0gsVUFGRDtBQUdIOztBQUVELGNBQVNZLG1DQUFULEdBQStDO0FBQzNDLGFBQUkxTSxVQUFVLElBQUlELGNBQUosRUFBZDtBQUNBQyxpQkFBUUMsS0FBUixDQUFjQyxTQUFkLEdBQTBCLFVBQVNsaEQsS0FBVCxFQUFnQjtBQUN0QyxpQkFBSThzRCxTQUFTOXNELE1BQU1ULElBQW5CO0FBQ0F3dEQsMEJBQWFELE1BQWI7QUFDSCxVQUhEOztBQUtBRCw2QkFBb0IsMkJBQVNDLE1BQVQsRUFBaUI7QUFDakM5TCxxQkFBUUksS0FBUixDQUFjQyxXQUFkLENBQTBCeUwsTUFBMUI7QUFDSCxVQUZEO0FBR0g7O0FBRUQsY0FBU2EscUNBQVQsR0FBaUQ7QUFDN0MsYUFBSTVmLE9BQU82ZSxJQUFJblAsZUFBZjtBQUNBb1AsNkJBQW9CLDJCQUFTQyxNQUFULEVBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBSWMsU0FBU2hCLElBQUlqbUMsYUFBSixDQUFrQixRQUFsQixDQUFiO0FBQ0FpbkMsb0JBQU9DLGtCQUFQLEdBQTRCLFlBQVk7QUFDcENkLDhCQUFhRCxNQUFiO0FBQ0FjLHdCQUFPQyxrQkFBUCxHQUE0QixJQUE1QjtBQUNBOWYsc0JBQUt0YixXQUFMLENBQWlCbTdCLE1BQWpCO0FBQ0FBLDBCQUFTLElBQVQ7QUFDSCxjQUxEO0FBTUE3ZixrQkFBS3JiLFdBQUwsQ0FBaUJrN0IsTUFBakI7QUFDSCxVQVhEO0FBWUg7O0FBRUQsY0FBU0UsK0JBQVQsR0FBMkM7QUFDdkNqQiw2QkFBb0IsMkJBQVNDLE1BQVQsRUFBaUI7QUFDakMxL0Msd0JBQVcyL0MsWUFBWCxFQUF5QixDQUF6QixFQUE0QkQsTUFBNUI7QUFDSCxVQUZEO0FBR0g7O0FBRUQ7QUFDQSxTQUFJaUIsV0FBV250RCxPQUFPb3RELGNBQVAsSUFBeUJwdEQsT0FBT290RCxjQUFQLENBQXNCOWhELE1BQXRCLENBQXhDO0FBQ0E2aEQsZ0JBQVdBLFlBQVlBLFNBQVMzZ0QsVUFBckIsR0FBa0MyZ0QsUUFBbEMsR0FBNkM3aEQsTUFBeEQ7O0FBRUE7QUFDQSxTQUFJLEdBQUdwSyxRQUFILENBQVl4SSxJQUFaLENBQWlCNFMsT0FBTzVFLE9BQXhCLE1BQXFDLGtCQUF6QyxFQUE2RDtBQUN6RDtBQUNBMGxEO0FBRUgsTUFKRCxNQUlPLElBQUlDLG1CQUFKLEVBQXlCO0FBQzVCO0FBQ0FJO0FBRUgsTUFKTSxNQUlBLElBQUluaEQsT0FBTzYwQyxjQUFYLEVBQTJCO0FBQzlCO0FBQ0EyTTtBQUVILE1BSk0sTUFJQSxJQUFJZCxPQUFPLHdCQUF3QkEsSUFBSWptQyxhQUFKLENBQWtCLFFBQWxCLENBQW5DLEVBQWdFO0FBQ25FO0FBQ0FnbkM7QUFFSCxNQUpNLE1BSUE7QUFDSDtBQUNBRztBQUNIOztBQUVEQyxjQUFTak4sWUFBVCxHQUF3QkEsWUFBeEI7QUFDQWlOLGNBQVN2QixjQUFULEdBQTBCQSxjQUExQjtBQUNILEVBekxBLEVBeUxDLE9BQU85eEQsSUFBUCxLQUFnQixXQUFoQixHQUE4QixPQUFPd1IsTUFBUCxLQUFrQixXQUFsQixlQUF1Q0EsTUFBckUsR0FBOEV4UixJQXpML0UsQ0FBRCxDOzs7Ozs7Ozs7QUNBQWpDLFFBQU9DLE9BQVAsR0FBaUIsVUFBU0QsTUFBVCxFQUFpQjtBQUNqQyxNQUFHLENBQUNBLE9BQU93MUQsZUFBWCxFQUE0QjtBQUMzQngxRCxVQUFPeXJELFNBQVAsR0FBbUIsWUFBVyxDQUFFLENBQWhDO0FBQ0F6ckQsVUFBT3kxRCxLQUFQLEdBQWUsRUFBZjtBQUNBO0FBQ0F6MUQsVUFBTzZlLFFBQVAsR0FBa0IsRUFBbEI7QUFDQTdlLFVBQU93MUQsZUFBUCxHQUF5QixDQUF6QjtBQUNBO0FBQ0QsU0FBT3gxRCxNQUFQO0FBQ0EsRUFURCxDOzs7Ozs7Ozs7Ozs7QUNBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLG9CQUFJc0QsUUFBSixDQUFhLE9BQWI7O0FBRUEsS0FBTW95RCxlQUFlLFNBQWZBLFlBQWUsQ0FBU3JyRCxHQUFULEVBQWM7QUFDakMsVUFBT0EsSUFBSXVCLE9BQUosQ0FBWSxxQ0FBWixFQUFtRCxNQUFuRCxDQUFQO0FBQ0QsRUFGRDs7QUFJQSxLQUFNK3BELFNBQVM7QUFDYnhnQyxVQURhLG1CQUNMM1EsR0FESyxFQUNBbFQsT0FEQSxFQUNTO0FBQ3BCLHdCQUFJdEssS0FBSixDQUFVc0ssT0FBVjtBQUNBLFNBQU1za0QsZ0JBQWdCLDZCQUFRdGtELFFBQVFqTSxLQUFoQixFQUF1QmlNLFFBQVFoTSxNQUEvQixFQUF1QztBQUMzRHV3RCxpQkFBVTtBQURpRCxNQUF2QyxDQUF0QjtBQUdBLFNBQU1DLGVBQWVGLGNBQWNHLFNBQWQsQ0FBd0J6a0QsUUFBUS9MLEtBQWhDLENBQXJCOztBQUVBLFNBQU15d0QsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTQyxNQUFULEVBQWlCO0FBQ3RDLFdBQU14dUQsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQW91RCxvQkFBYUksVUFBYjtBQUNBSixvQkFBYUssTUFBYixDQUFvQkYsTUFBcEIsRUFBNEIsVUFBU24xRCxDQUFULEVBQVlnekMsT0FBWixFQUFxQjtBQUMvQyxhQUFJaHpDLENBQUosRUFBTztBQUNMLDhCQUFJa0csS0FBSixDQUFVbEcsQ0FBVjtBQUNBMkcsYUFBRU0sTUFBRixDQUFTakgsQ0FBVDtBQUNELFVBSEQsTUFHTztBQUNMczFELDhCQUFtQnRpQixRQUFRdWlCLElBQTNCLEVBQ0N0dkQsSUFERCxDQUNNLFlBQVc7QUFDZlUsZUFBRUksT0FBRixDQUFVaXNDLFFBQVF1aUIsSUFBbEI7QUFDRCxZQUhEO0FBSUQ7QUFDRixRQVZEO0FBV0EsY0FBTzV1RCxFQUFFTyxPQUFUO0FBQ0QsTUFmRDs7QUFpQkEsU0FBTVUsY0FBYyxTQUFkQSxXQUFjLENBQVM0dEQsTUFBVCxFQUFpQkMsVUFBakIsRUFBNkJDLFdBQTdCLEVBQTBDO0FBQzVELFdBQU0vdUQsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQSxXQUFNdXVELFNBQVM7QUFDYmx3RCxnQkFBT3d3RCxVQURNO0FBRWJuMEIsa0JBQVNrMEIsT0FBTzkwRCxNQUFQLEdBQWdCLGFBQWE4MEQsTUFBN0IsR0FBc0MsRUFGbEM7QUFHYkUsc0JBQWFBLGVBQWU7QUFIZixRQUFmO0FBS0EsMEJBQUl4dkQsS0FBSixDQUFVaXZELE1BQVY7QUFDQUQsc0JBQWVDLE1BQWYsRUFDQ2x2RCxJQURELENBQ00sVUFBU3N2RCxJQUFULEVBQWU7QUFDbkIsNEJBQUlydkQsS0FBSixDQUFVcXZELElBQVY7QUFDQTV1RCxXQUFFSSxPQUFGLENBQVV3dUQsSUFBVjtBQUNELFFBSkQsRUFJR2p2RCxLQUpILENBSVMsVUFBU3RHLENBQVQsRUFBWTtBQUNuQjJHLFdBQUVNLE1BQUYsQ0FBU2pILENBQVQ7QUFDRCxRQU5EO0FBT0EsY0FBTzJHLEVBQUVPLE9BQVQ7QUFDRCxNQWhCRDs7QUFrQkEsU0FBTW91RCxxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFTSyxLQUFULEVBQWdCO0FBQ3pDLFdBQU1odkQsSUFBSSxZQUFFQyxLQUFGLEVBQVY7QUFDQSxXQUFNekYsT0FBTyxJQUFiO0FBQ0EsV0FBTWd2RCxXQUFXLEVBQWpCO0FBQ0F3RixhQUFNcHVELE9BQU4sQ0FBYyxVQUFTcXVELElBQVQsRUFBZTtBQUMzQkEsY0FBS0MsU0FBTCxHQUFpQixFQUFqQjtBQUNBLGFBQUlELEtBQUtFLFNBQVQsRUFBb0I7QUFDbEJGLGdCQUFLRSxTQUFMLENBQWV2dUQsT0FBZixDQUF1QixVQUFTK0MsR0FBVCxFQUFjO0FBQ25DLGlCQUFNcUosSUFBSSxZQUFFL00sS0FBRixFQUFWO0FBQ0FtdkQscUJBQVF6ckQsR0FBUixFQUNDckUsSUFERCxDQUNNLFVBQVMrc0MsT0FBVCxFQUFrQjtBQUN0QjRpQixvQkFBS0MsU0FBTCxDQUFldnJELEdBQWYsSUFBc0Iwb0MsT0FBdEI7QUFDQXIvQixpQkFBRTVNLE9BQUYsQ0FBVWlzQyxPQUFWO0FBQ0QsY0FKRDtBQUtBbWQsc0JBQVM5K0MsSUFBVCxDQUFjc0MsRUFBRXpNLE9BQWhCO0FBQ0QsWUFSRDtBQVNEO0FBQ0YsUUFiRDtBQWNBLDBCQUFJaEIsS0FBSixDQUFVaXFELFFBQVY7QUFDQSxtQkFBRVEsVUFBRixDQUFhUixRQUFiLEVBQ0NscUQsSUFERCxDQUNNLFVBQVM0QixPQUFULEVBQWtCO0FBQ3RCbEIsV0FBRUksT0FBRixDQUFVYyxPQUFWO0FBQ0QsUUFIRCxFQUdHdkIsS0FISCxDQUdTLFVBQVN0RyxDQUFULEVBQVk7QUFDbkIsNEJBQUlrRyxLQUFKLENBQVVsRyxDQUFWO0FBQ0EyRyxXQUFFTSxNQUFGLENBQVNqSCxDQUFUO0FBQ0QsUUFORDtBQU9BLGNBQU8yRyxFQUFFTyxPQUFUO0FBQ0QsTUEzQkQ7O0FBNkJBLFNBQU02dUQsVUFBVSxTQUFWQSxPQUFVLENBQVNDLFFBQVQsRUFBbUI7QUFDakMsV0FBTXJ2RCxJQUFJLFlBQUVDLEtBQUYsRUFBVjtBQUNBb3VELG9CQUFhaUIsU0FBYixDQUF1QkQsUUFBdkIsRUFBaUMsVUFBU2gyRCxDQUFULEVBQVlnekMsT0FBWixFQUFxQjtBQUNwRCxhQUFJaHpDLENBQUosRUFBTztBQUNMLDhCQUFJa0csS0FBSixDQUFVbEcsQ0FBVjtBQUNBMkcsYUFBRU0sTUFBRixDQUFTakgsQ0FBVDtBQUNELFVBSEQsTUFHTztBQUNMMkcsYUFBRUksT0FBRixDQUFVaXNDLE9BQVY7QUFDRDtBQUNGLFFBUEQ7QUFRQSxjQUFPcnNDLEVBQUVPLE9BQVQ7QUFDRCxNQVhEOztBQWFBLFNBQU1ndkQsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTVixNQUFULEVBQWlCQyxVQUFqQixFQUE2QjtBQUNsRCxXQUFNOXVELElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0EsV0FBTXV2RCxZQUFZLEdBQWxCO0FBQ0EsV0FBTUMsa0JBQWtCLEVBQXhCO0FBQ0EsV0FBTVYsY0FBYzVzRCxLQUFLdXRELEdBQUwsQ0FBU3Z0RCxLQUFLdVAsR0FBTCxDQUFTdlAsS0FBS3d0RCxJQUFMLENBQVUsTUFBTWIsV0FBVy8wRCxNQUFYLEdBQW9CeTFELFNBQTFCLENBQVYsQ0FBVCxFQUEwRCxDQUExRCxDQUFULEVBQXVFLEVBQXZFLENBQXBCO0FBQ0EsWUFBSyxJQUFJMTFELElBQUksQ0FBYixFQUFnQkEsSUFBSWcxRCxXQUFXLzBELE1BQS9CLEVBQXVDRCxLQUFLMDFELFNBQTVDLEVBQXVEO0FBQ3JEQyx5QkFBZ0Iva0QsSUFBaEIsQ0FBcUJva0QsV0FBV3h4QixTQUFYLENBQXFCeGpDLENBQXJCLEVBQXdCQSxJQUFFMDFELFNBQTFCLENBQXJCO0FBQ0Q7QUFDRCxXQUFNaEcsV0FBV2lHLGdCQUFnQjNzRCxHQUFoQixDQUFvQixVQUFTOHNELENBQVQsRUFBWTF1QyxDQUFaLEVBQWU7QUFDbEQsZ0JBQU9qZ0IsWUFBWTR0RCxNQUFaLEVBQW9CZSxDQUFwQixFQUF1QmIsV0FBdkIsQ0FBUDtBQUNELFFBRmdCLENBQWpCO0FBR0EsbUJBQUUvRSxVQUFGLENBQWFSLFFBQWIsRUFDQ2xxRCxJQURELENBQ00sVUFBUzRCLE9BQVQsRUFBa0I7QUFDdEIsYUFBSUEsVUFBVSxHQUFHNEUsTUFBSCxDQUFVeE0sS0FBVixDQUFnQixFQUFoQixFQUFvQjRILFFBQVE0QixHQUFSLENBQVksVUFBUytzRCxDQUFULEVBQVk7QUFBQyxrQkFBT0EsRUFBRXB1RCxLQUFUO0FBQWUsVUFBeEMsQ0FBcEIsQ0FBZDtBQUNBUCxtQkFBVTR1RCxpQkFBaUI1dUQsT0FBakIsRUFBMEIsVUFBMUIsQ0FBVjtBQUNBLDRCQUFJM0IsS0FBSixDQUFVMkIsT0FBVjtBQUNBbEIsV0FBRUksT0FBRixDQUFVYyxPQUFWO0FBQ0QsUUFORCxFQU9DdkIsS0FQRCxDQU9PLFVBQVN0RyxDQUFULEVBQVk7QUFDakIsNEJBQUlrRyxLQUFKLENBQVVsRyxDQUFWO0FBQ0QsUUFURDtBQVVBLGNBQU8yRyxFQUFFTyxPQUFUO0FBQ0QsTUF0QkQ7O0FBd0JBLFNBQU11dkQsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU0MsYUFBVCxFQUF3QkMsTUFBeEIsRUFBZ0M7QUFDdkQsV0FBSUMsZUFBZSxFQUFuQjtBQUFBLFdBQXVCQyxTQUFTLEVBQWhDO0FBQUEsV0FBb0N6dUQsS0FBcEM7QUFDQSxZQUFJLElBQUkzSCxJQUFJLENBQVosRUFBZUEsSUFBSWkyRCxjQUFjaDJELE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1QzJILGlCQUFRc3VELGNBQWNqMkQsQ0FBZCxFQUFpQmsyRCxNQUFqQixDQUFSO0FBQ0EsYUFBR0UsT0FBTzEwRCxPQUFQLENBQWVpRyxLQUFmLE1BQTBCLENBQUMsQ0FBOUIsRUFBaUM7QUFDL0J3dUQsd0JBQWF2bEQsSUFBYixDQUFrQnFsRCxjQUFjajJELENBQWQsQ0FBbEI7QUFDQW8yRCxrQkFBT3hsRCxJQUFQLENBQVlqSixLQUFaO0FBQ0Q7QUFDRjtBQUNELGNBQU93dUQsWUFBUDtBQUNELE1BVkQ7O0FBWUEsU0FBTUUsZUFBZSxTQUFmQSxZQUFlLENBQVMzdkQsUUFBVCxFQUFtQlUsT0FBbkIsRUFBNEI7QUFDL0M7QUFDQSxXQUFNa3ZELGNBQWMsQ0FDbEIsV0FEa0IsRUFFbEIsT0FGa0IsRUFHbEIsTUFIa0IsRUFJbEIsTUFKa0IsRUFLbEIsTUFMa0IsRUFNbEIsTUFOa0IsRUFPbEIsTUFQa0IsRUFRbEIsTUFSa0IsRUFTbEIsS0FUa0IsRUFVbEIsS0FWa0IsRUFXbEIsSUFYa0IsRUFZbEIsSUFaa0IsRUFhbEIsSUFia0IsQ0FBcEI7QUFlQSxXQUFNeEIsT0FBTyxFQUFiO0FBQ0ExdEQsZUFBUU4sT0FBUixDQUFnQixVQUFTNk8sTUFBVCxFQUFpQjNWLENBQWpCLEVBQW9CO0FBQ2xDLDRCQUFJeUYsS0FBSixDQUFVLEtBQVY7QUFDQSw0QkFBSUEsS0FBSixDQUFVekYsQ0FBVjtBQUNBLGFBQUl1MkQsUUFBUSxFQUFaO0FBQ0E1Z0QsZ0JBQU84SCxPQUFQLENBQWUzVyxPQUFmLENBQXVCLFVBQVN5RCxDQUFULEVBQVk7QUFDakMsZUFBSTdELFNBQVM4dkQsUUFBVCxDQUFrQjkwRCxPQUFsQixDQUEwQjZJLEVBQUU1QyxLQUE1QixJQUFxQyxDQUFDLENBQXRDLElBQ0RtdEQsS0FBS3B6RCxPQUFMLENBQWFpVSxPQUFPNC9DLFFBQXBCLEtBQWlDLENBQUMsQ0FEakMsSUFFRGhyRCxFQUFFNUMsS0FGRCxJQUVVNEMsRUFBRTVDLEtBQUYsQ0FBUTFILE1BQVIsR0FBaUIsQ0FGM0IsSUFHRHEyRCxZQUFZNTBELE9BQVosQ0FBb0I2SSxFQUFFNUMsS0FBdEIsS0FBZ0MsQ0FBQyxDQUhoQyxJQUlENHVELE1BQU03MEQsT0FBTixDQUFjNkksRUFBRTVDLEtBQWhCLEtBQTBCLENBQUMsQ0FKOUIsRUFJaUM7QUFDL0IsZ0NBQUlsQyxLQUFKLENBQVU4RSxFQUFFNUMsS0FBWjtBQUNBNHVELG1CQUFNM2xELElBQU4sQ0FBV3JHLEVBQUU1QyxLQUFiO0FBQ0EsY0FBQzRDLEVBQUU1QyxLQUFGLENBQVEwSSxLQUFSLENBQWMsSUFBZCxLQUF1QixFQUF4QixFQUE0QnZKLE9BQTVCLENBQW9DLFlBQVc7QUFDN0N5dkQscUJBQU0zbEQsSUFBTixDQUFXckcsRUFBRTVDLEtBQWI7QUFDRCxjQUZEO0FBR0Q7QUFDRixVQVpEO0FBYUEsYUFBSTR1RCxNQUFNdDJELE1BQU4sR0FBZSxDQUFuQixFQUFzQjtBQUNwQiw4QkFBSXdGLEtBQUosQ0FBVWtRLE9BQU84Z0QsUUFBakI7QUFDQTNCLGdCQUFLbGtELElBQUwsQ0FBVStFLE1BQVY7QUFDRDtBQUNELDRCQUFJbFEsS0FBSixDQUFVLEtBQVY7QUFDRCxRQXRCRDs7QUF3QkE7QUFDQTtBQUNBLGNBQU8sRUFBUDtBQUNELE1BN0NEOztBQStDQSxTQUFNaXhELG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVMzQixNQUFULEVBQWlCcnVELFFBQWpCLEVBQTJCO0FBQ25ELFdBQU1SLElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0EsMEJBQUlWLEtBQUosQ0FBVWlCLFFBQVY7QUFDQSxXQUFNaXdELFVBQVVqd0QsU0FBU2t3RCxPQUFULENBQWlCdnNELE9BQWpCLENBQXlCLE1BQXpCLEVBQWdDLEVBQWhDLEVBQW9DQSxPQUFwQyxDQUE0QyxRQUE1QyxFQUFxRCxFQUFyRCxFQUF5REEsT0FBekQsQ0FBaUUsTUFBakUsRUFBd0UsRUFBeEUsQ0FBaEI7QUFDQSxXQUFNcXFELFNBQVM7QUFDYmx3RCxnQkFBTyxFQURNO0FBRWJxOEIsa0JBQVMsYUFBYWswQixNQUFiLEdBQXNCLG9CQUF0QixHQUE2QzRCLE9BQTdDLEdBQXVELGtCQUF2RCxHQUE0RUEsT0FBNUUsR0FBc0Ysc0JBQXRGLEdBQStHQSxPQUEvRyxHQUF5SCx3QkFBekgsR0FBb0pBLE9BQXBKLEdBQThKLHNCQUE5SixHQUF1TEEsT0FBdkwsR0FBaU0sa0JBQWpNLEdBQXNOQSxPQUF0TixHQUFnTyxzQkFBaE8sR0FBeVBBLE9BQXpQLEdBQW1RLHdCQUFuUSxHQUE4UkEsT0FBOVIsR0FBd1M7QUFGcFMsUUFBZjtBQUlBLDBCQUFJbHhELEtBQUosQ0FBVSxRQUFWO0FBQ0EsMEJBQUlBLEtBQUosQ0FBVWl2RCxNQUFWO0FBQ0FELHNCQUFlQyxNQUFmLEVBQ0NsdkQsSUFERCxDQUNNLFVBQVNxeEQsU0FBVCxFQUFvQjtBQUN4Qiw0QkFBSXB4RCxLQUFKLENBQVUsV0FBVjtBQUNBLDRCQUFJQSxLQUFKLENBQVVveEQsU0FBVjtBQUNBM3dELFdBQUVJLE9BQUYsQ0FBVXV3RCxTQUFWO0FBQ0QsUUFMRCxFQUtHaHhELEtBTEgsQ0FLUyxVQUFTdEcsQ0FBVCxFQUFZO0FBQ25CMkcsV0FBRU0sTUFBRixDQUFTakgsQ0FBVDtBQUNELFFBUEQ7QUFRQSxjQUFPMkcsRUFBRU8sT0FBVDtBQUNELE1BbkJEOztBQXFCQSxTQUFNZCxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVNvdkQsTUFBVCxFQUFpQnJ1RCxRQUFqQixFQUEyQm93RCxZQUEzQixFQUF5QztBQUM5RCxXQUFNNXdELElBQUksWUFBRUMsS0FBRixFQUFWO0FBQ0E7QUFDQSxXQUFNNHdELGNBQWM7QUFDbEJqQyxlQUFNLEVBRFk7QUFFbEIrQixvQkFBVyxFQUZPO0FBR2xCRyxnQkFBTyxFQUhXO0FBSWxCQyxtQkFBVTtBQUpRLFFBQXBCO0FBTUEsMEJBQUl4eEQsS0FBSixDQUFVc3ZELE1BQVYsRUFBa0JydUQsUUFBbEI7QUFDQSxXQUFNd3dELHFCQUFxQixDQUN6QixpQkFEeUIsRUFFekIsT0FGeUIsRUFHekIscUJBSHlCLEVBSXpCLFFBSnlCLEVBS3pCLE1BTHlCLEVBTXpCLFNBTnlCLEVBT3pCLFFBUHlCLEVBUXpCLE9BUnlCLEVBU3pCLFNBVHlCLEVBVXpCLFdBVnlCLEVBV3pCLFFBWHlCLEVBWXpCLE1BWnlCLEVBYXpCLHlDQWJ5QixFQWN6QixRQWR5QixFQWV6QixRQWZ5QixFQWdCekIsV0FoQnlCLEVBaUJ6QixNQWpCeUIsRUFrQnpCLGdDQWxCeUIsRUFtQnpCLElBbkJ5QixFQW9CekIsU0FwQnlCLEVBcUJ6QixRQXJCeUIsRUFzQnpCLGtCQXRCeUIsRUF1QnpCLG1CQXZCeUIsRUF3QnpCLHdCQXhCeUIsRUF5QnpCLFVBekJ5QixFQTBCekIsV0ExQnlCLEVBMkJ6QixTQTNCeUIsQ0FBM0I7QUE2QkFBLDBCQUFtQnB3RCxPQUFuQixDQUEyQixVQUFTcXdELE1BQVQsRUFBaUI7QUFDMUN6d0Qsa0JBQVM4dkQsUUFBVCxHQUFvQjl2RCxTQUFTOHZELFFBQVQsQ0FBa0Juc0QsT0FBbEIsQ0FBMEI4c0QsTUFBMUIsRUFBa0MsRUFBbEMsQ0FBcEI7QUFDRCxRQUZEO0FBR0EsV0FBTWIsY0FBYyxDQUNsQixHQURrQixFQUVsQixHQUZrQixFQUdsQixJQUhrQixFQUlsQixJQUprQixFQUtsQixJQUxrQixFQU1sQixJQU5rQixFQU9sQixJQVBrQixFQVFsQixJQVJrQixFQVNsQixLQVRrQixFQVVsQixLQVZrQixFQVdsQixLQVhrQixFQVlsQixLQVprQixFQWFsQixLQWJrQixFQWNsQixLQWRrQixFQWVsQixLQWZrQixFQWdCbEIsTUFoQmtCLEVBaUJsQixNQWpCa0IsRUFrQmxCLE1BbEJrQixFQW1CbEIsTUFuQmtCLEVBb0JsQixNQXBCa0IsRUFxQmxCLE9BckJrQixFQXNCbEIsV0F0QmtCLENBQXBCOztBQXlCQSxXQUFJO0FBQ0YsYUFBTWMsV0FBVyxFQUFqQjtBQUNBTixzQkFBYWh3RCxPQUFiLENBQXFCLFVBQVNxdUQsSUFBVCxFQUFlO0FBQ2xDLGVBQUlrQyxRQUFRLENBQVo7QUFDQWxDLGdCQUFLMTNDLE9BQUwsQ0FBYTNXLE9BQWIsQ0FBcUIsVUFBU3d3RCxNQUFULEVBQWlCO0FBQ3BDLGlCQUFNcHZELE1BQU1RLE9BQU80dUQsT0FBTzN2RCxLQUFkLENBQVo7QUFDQSxpQkFBSTJ1RCxZQUFZNTBELE9BQVosQ0FBb0J3RyxJQUFJa0IsV0FBSixFQUFwQixLQUEwQyxDQUFDLENBQTNDLElBQWdEbEIsSUFBSWpJLE1BQUosR0FBYSxDQUFqRSxFQUFvRTtBQUNsRSxtQkFBTXMzRCxNQUFNLElBQUk1aUMsTUFBSixDQUFXdy9CLGFBQWFqc0QsR0FBYixDQUFYLEVBQThCLElBQTlCLENBQVo7QUFDQSxtQkFBTXN2RCxTQUFTLENBQUM5d0QsU0FBUzh2RCxRQUFULENBQWtCbm1ELEtBQWxCLENBQXdCa25ELEdBQXhCLEtBQWdDLEVBQWpDLEVBQXFDdDNELE1BQXJDLEdBQThDaUksSUFBSWpJLE1BQWpFO0FBQ0FvM0Qsd0JBQVNHLE1BQVQ7QUFDQSxtQkFBSUEsTUFBSixFQUFZO0FBQ1YscUJBQUlKLFNBQVMxMUQsT0FBVCxDQUFpQndHLEdBQWpCLEtBQXlCLENBQUMsQ0FBOUIsRUFBaUNrdkQsU0FBU3htRCxJQUFULENBQWMxSSxHQUFkO0FBQ2xDO0FBQ0Y7QUFDRixZQVZEO0FBV0EsZUFBSW12RCxRQUFRLEdBQVosRUFBaUI7QUFDZk4seUJBQVlqQyxJQUFaLENBQWlCbGtELElBQWpCLENBQXNCdWtELElBQXRCO0FBQ0QsWUFGRCxNQUVPLElBQUlrQyxRQUFRLENBQVosRUFBZTtBQUNwQk4seUJBQVlFLFFBQVosQ0FBcUJybUQsSUFBckIsQ0FBMEJ1a0QsSUFBMUI7QUFDRDtBQUNGLFVBbEJEO0FBbUJBLDRCQUFJaDFELEtBQUosQ0FBVWkzRCxRQUFWOztBQUVBTCxxQkFBWUYsU0FBWixHQUF3QkMsYUFBYTl2RCxNQUFiLENBQW9CLFVBQVNtdUQsSUFBVCxFQUFlO0FBQ3pELGVBQU13QixVQUFVandELFNBQVNrd0QsT0FBVCxDQUFpQnZzRCxPQUFqQixDQUF5QixNQUF6QixFQUFnQyxFQUFoQyxFQUFvQ0EsT0FBcEMsQ0FBNEMsUUFBNUMsRUFBcUQsRUFBckQsRUFBeURBLE9BQXpELENBQWlFLE1BQWpFLEVBQXdFLEVBQXhFLENBQWhCO0FBQ0EsOEJBQUl0RixJQUFKLENBQVNvd0QsS0FBS3NDLFVBQWQ7QUFDQSxrQkFBT3RDLEtBQUtzQyxVQUFMLEtBQW9CdEMsS0FBS3NDLFVBQUwsQ0FBZ0IvMUQsT0FBaEIsQ0FBd0JpMUQsT0FBeEIsSUFBbUMsQ0FBQyxDQUFwQyxJQUF5Q3hCLEtBQUtzQyxVQUFMLENBQWdCLzFELE9BQWhCLENBQXdCaTFELE9BQXhCLElBQW1DLENBQUMsQ0FBakcsQ0FBUDtBQUNELFVBSnVCLENBQXhCO0FBS0FJLHFCQUFZQyxLQUFaLEdBQW9CRCxZQUFZRixTQUFoQyxDQTVCRSxDQTRCd0M7QUFDMUNFLHFCQUFZQyxLQUFaLENBQWtCbHdELE9BQWxCLENBQTBCLFVBQVM0d0QsSUFBVCxFQUFlO0FBQUVBLGdCQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQXVCLFVBQWxFO0FBQ0E7QUFDQVoscUJBQVlFLFFBQVosR0FBdUJqQixpQkFBaUJlLFlBQVlFLFFBQTdCLEVBQXVDLFVBQXZDLENBQXZCO0FBQ0EsNEJBQUk5MkQsS0FBSixDQUFVNDJELFdBQVY7QUFDQTd3RCxXQUFFSSxPQUFGLENBQVV5d0QsV0FBVjtBQUNELFFBbENELENBa0NFLE9BQU14M0QsQ0FBTixFQUFTO0FBQ1QsNEJBQUl1RyxLQUFKLENBQVV2RyxDQUFWO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFPMkcsRUFBRU8sT0FBVDtBQUNELE1BdElEOztBQXdJQSxVQUFLZ3VELGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0EsVUFBS3R0RCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLFVBQUtzdUQsY0FBTCxHQUFzQkEsY0FBdEI7QUFDQSxVQUFLOXZELGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0Q7QUF6VVksRUFBZjs7bUJBNlVleXVELE07Ozs7OztBQ3ZWZjs7QUFFQSxLQUFJd0QsZ0JBQWdCLG1CQUFBckYsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsS0FBSXNGLHNCQUFzQixtQkFBQXRGLENBQVEsRUFBUixDQUExQjs7QUFFQTl6RCxRQUFPQyxPQUFQLEdBQWlCbTVELG9CQUFvQkQsYUFBcEIsQ0FBakIsQzs7Ozs7Ozs7OztBQ0xBbjVELFFBQU9DLE9BQVAsR0FBaUJrNUQsYUFBakI7O0FBRUEsS0FBSUUsUUFBUSxtQkFBQXZGLENBQVEsRUFBUixDQUFaO0FBQ0EsS0FBSXJJLFlBQVksbUJBQUFxSSxDQUFRLEVBQVIsQ0FBaEI7QUFDQSxLQUFJd0Ysb0JBQW9CLG1CQUFBeEYsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsS0FBSXlGLG9CQUFvQixtQkFBQXpGLENBQVEsRUFBUixDQUF4QjtBQUNBLEtBQUkwRixXQUFXLG1CQUFBMUYsQ0FBUSxFQUFSLENBQWY7QUFDQSxLQUFJclEsU0FBUyxtQkFBQXFRLENBQVEsRUFBUixDQUFiOztBQUVBLFVBQVNxRixhQUFULEdBQXlCO0FBQ3ZCSSxxQkFBa0J4NEQsS0FBbEIsQ0FBd0IsSUFBeEIsRUFBOEJDLFNBQTlCO0FBQ0Q7O0FBRUR3NEQsVUFBU0wsYUFBVCxFQUF3QkksaUJBQXhCOztBQUVBOzs7Ozs7OztBQVFBSixlQUFjdjRELFNBQWQsQ0FBd0I2NEQsV0FBeEIsR0FBc0MsVUFBU0MsU0FBVCxFQUFvQnRwQyxRQUFwQixFQUE4QjtBQUNsRSxVQUFPLEtBQUt1cEMsWUFBTCxDQUFrQjtBQUN2Qmw1RCxhQUFRLFFBRGU7QUFFdkJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQjYyRCxTQUFuQixDQUZFO0FBR3ZCRSxlQUFVLE9BSGE7QUFJdkJ4cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUFQRDs7QUFTQTs7Ozs7Ozs7O0FBU0Erb0MsZUFBY3Y0RCxTQUFkLENBQXdCaTVELFNBQXhCLEdBQW9DLFVBQVNDLFlBQVQsRUFBdUJDLFlBQXZCLEVBQXFDM3BDLFFBQXJDLEVBQStDO0FBQ2pGLE9BQUk0cEMsVUFBVTtBQUNaQyxnQkFBVyxNQURDLEVBQ09DLGFBQWFIO0FBRHBCLElBQWQ7QUFHQSxVQUFPLEtBQUtKLFlBQUwsQ0FBa0I7QUFDdkJsNUQsYUFBUSxNQURlO0FBRXZCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJpM0QsWUFBbkIsQ0FBaEIsR0FBbUQsWUFGakM7QUFHdkJwbkIsV0FBTXNuQixPQUhpQjtBQUl2QkosZUFBVSxPQUphO0FBS3ZCeHBDLGVBQVVBO0FBTGEsSUFBbEIsQ0FBUDtBQU9ELEVBWEQ7O0FBYUE7Ozs7Ozs7OztBQVNBK29DLGVBQWN2NEQsU0FBZCxDQUF3QnU1RCxTQUF4QixHQUFvQyxVQUFTTCxZQUFULEVBQXVCQyxZQUF2QixFQUFxQzNwQyxRQUFyQyxFQUErQztBQUNqRixPQUFJNHBDLFVBQVU7QUFDWkMsZ0JBQVcsTUFEQyxFQUNPQyxhQUFhSDtBQURwQixJQUFkO0FBR0EsVUFBTyxLQUFLSixZQUFMLENBQWtCO0FBQ3ZCbDVELGFBQVEsTUFEZTtBQUV2Qm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CaTNELFlBQW5CLENBQWhCLEdBQW1ELFlBRmpDO0FBR3ZCcG5CLFdBQU1zbkIsT0FIaUI7QUFJdkJKLGVBQVUsT0FKYTtBQUt2QnhwQyxlQUFVQTtBQUxhLElBQWxCLENBQVA7QUFPRCxFQVhEOztBQWFBOzs7Ozs7Ozs7OztBQVdBK29DLGVBQWN2NEQsU0FBZCxDQUF3Qnc1RCxPQUF4QixHQUFrQyxVQUFTQyxNQUFULEVBQWlCNzRELE1BQWpCLEVBQXlCNHVCLFFBQXpCLEVBQW1DO0FBQ25FLE9BQUlnakIsUUFBUSxtQkFBQTBnQixDQUFRLEVBQVIsQ0FBWjtBQUNBLE9BQUltQyxTQUFTLEVBQWI7QUFDQSxPQUFJLFFBQU9vRSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDO0FBQzlCO0FBQ0FwRSxjQUFTN2lCLE1BQU1pbkIsTUFBTixDQUFUO0FBQ0FqcUMsZ0JBQVc1dUIsTUFBWDtBQUNELElBSkQsTUFJTyxJQUFJUixVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU82NEQsTUFBUCxLQUFrQixVQUFoRCxFQUE0RDtBQUNqRTtBQUNBanFDLGdCQUFXaXFDLE1BQVg7QUFDRCxJQUhNLE1BR0EsSUFBSXI1RCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU9BLE1BQVAsS0FBa0IsVUFBaEQsRUFBNEQ7QUFDakU7QUFDQTR1QixnQkFBVzV1QixNQUFYO0FBQ0F5MEQsWUFBT29FLE1BQVAsR0FBZ0JBLE1BQWhCO0FBQ0QsSUFKTSxNQUlBO0FBQ0w7QUFDQXBFLFlBQU9vRSxNQUFQLEdBQWdCQSxNQUFoQjtBQUNBcEUsWUFBT3owRCxNQUFQLEdBQWdCQSxNQUFoQjtBQUNEOztBQUVELE9BQUl5MEQsT0FBT29FLE1BQVAsS0FBa0JsNUQsU0FBdEIsRUFBaUM4MEQsT0FBT29FLE1BQVAsR0FBZ0IsQ0FBaEI7QUFDakMsT0FBSXBFLE9BQU96MEQsTUFBUCxLQUFrQkwsU0FBdEIsRUFBaUM4MEQsT0FBT3owRCxNQUFQLEdBQWdCLEVBQWhCOztBQUVqQyxVQUFPLEtBQUttNEQsWUFBTCxDQUFrQjtBQUN2Qmw1RCxhQUFRLEtBRGU7QUFFdkJtRyxVQUFLLGFBQWEsS0FBSzB6RCxnQkFBTCxDQUFzQnJFLE1BQXRCLEVBQThCLEVBQTlCLENBRks7QUFHdkIyRCxlQUFVLE1BSGE7QUFJdkJ4cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUE3QkQ7O0FBK0JBOzs7Ozs7OztBQVFBK29DLGVBQWN2NEQsU0FBZCxDQUF3QjI1RCxXQUF4QixHQUFzQyxVQUFTQyxJQUFULEVBQWVwcUMsUUFBZixFQUF5QjtBQUM3RCxPQUFJNmxDLFNBQVMsRUFBYjs7QUFFQSxPQUFJdUUsU0FBU3I1RCxTQUFULElBQXNCLE9BQU9xNUQsSUFBUCxLQUFnQixVQUExQyxFQUFzRDtBQUNwRHBxQyxnQkFBV29xQyxJQUFYO0FBQ0QsSUFGRCxNQUVPO0FBQ0x2RSxjQUFTLFdBQVd1RSxJQUFwQjtBQUNEOztBQUVELFVBQU8sS0FBS2IsWUFBTCxDQUFrQjtBQUN2Qmw1RCxhQUFRLEtBRGU7QUFFdkJtRyxVQUFLLGVBQWVxdkQsTUFGRztBQUd2QjJELGVBQVUsTUFIYTtBQUl2QnhwQyxlQUFVQTtBQUphLElBQWxCLENBQVA7QUFNRCxFQWZEOztBQWlCQTs7Ozs7O0FBTUErb0MsZUFBY3Y0RCxTQUFkLENBQXdCbTFELFNBQXhCLEdBQW9DLFVBQVMyRCxTQUFULEVBQW9CO0FBQ3RELFVBQU8sSUFBSUwsS0FBSixDQUFVLElBQVYsRUFBZ0JLLFNBQWhCLENBQVA7QUFDRCxFQUZEOztBQUlBOzs7QUFHQVAsZUFBY3Y0RCxTQUFkLENBQXdCNjVELFlBQXhCLEdBQXVDaFAsVUFBVSxVQUFTcjdCLFFBQVQsRUFBbUI7QUFDbEUsVUFBTyxLQUFLc3FDLFdBQUwsQ0FBaUJ0cUMsUUFBakIsQ0FBUDtBQUNELEVBRnNDLEVBRXBDa3BDLGtCQUFrQix1QkFBbEIsRUFBMkMsc0JBQTNDLENBRm9DLENBQXZDOztBQUlBOzs7Ozs7O0FBT0FILGVBQWN2NEQsU0FBZCxDQUF3Qjg1RCxXQUF4QixHQUFzQyxVQUFTdHFDLFFBQVQsRUFBbUI7QUFDdkQsVUFBTyxLQUFLdXBDLFlBQUwsQ0FBa0I7QUFDdkJsNUQsYUFBUSxLQURlO0FBRXZCbUcsVUFBSyxTQUZrQjtBQUd2Qmd6RCxlQUFVLE1BSGE7QUFJdkJ4cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUFQRDs7QUFTQTs7O0FBR0Erb0MsZUFBY3Y0RCxTQUFkLENBQXdCKzVELGFBQXhCLEdBQXdDbFAsVUFBVSxVQUFTcmdELEdBQVQsRUFBY2dsQixRQUFkLEVBQXdCO0FBQ3hFLFVBQU8sS0FBS3dxQyxTQUFMLENBQWV4dkQsR0FBZixFQUFvQmdsQixRQUFwQixDQUFQO0FBQ0QsRUFGdUMsRUFFckNrcEMsa0JBQWtCLHdCQUFsQixFQUE0QyxvQkFBNUMsQ0FGcUMsQ0FBeEM7O0FBSUE7Ozs7Ozs7O0FBUUFILGVBQWN2NEQsU0FBZCxDQUF3Qmc2RCxTQUF4QixHQUFvQyxVQUFTeHZELEdBQVQsRUFBY2dsQixRQUFkLEVBQXdCO0FBQzFELFVBQU8sS0FBS3VwQyxZQUFMLENBQWtCO0FBQ3ZCbDVELGFBQVEsS0FEZTtBQUV2Qm1HLFVBQUssYUFBYXdFLEdBRks7QUFHdkJ3dUQsZUFBVSxNQUhhO0FBSXZCeHBDLGVBQVVBO0FBSmEsSUFBbEIsQ0FBUDtBQU1ELEVBUEQ7O0FBU0E7OztBQUdBK29DLGVBQWN2NEQsU0FBZCxDQUF3Qmk2RCxhQUF4QixHQUF3Q3BQLFVBQVUsVUFBU3JnRCxHQUFULEVBQWNnbEIsUUFBZCxFQUF3QjtBQUN4RSxVQUFPLEtBQUswcUMsWUFBTCxDQUFrQjF2RCxHQUFsQixFQUF1QmdsQixRQUF2QixDQUFQO0FBQ0QsRUFGdUMsRUFFckNrcEMsa0JBQWtCLHdCQUFsQixFQUE0Qyx1QkFBNUMsQ0FGcUMsQ0FBeEM7O0FBSUE7Ozs7Ozs7QUFPQUgsZUFBY3Y0RCxTQUFkLENBQXdCazZELFlBQXhCLEdBQXVDLFVBQVMxdkQsR0FBVCxFQUFjZ2xCLFFBQWQsRUFBd0I7QUFDN0QsVUFBTyxLQUFLdXBDLFlBQUwsQ0FBa0I7QUFDdkJsNUQsYUFBUSxRQURlO0FBRXZCbUcsVUFBSyxhQUFhd0UsR0FGSztBQUd2Qnd1RCxlQUFVLE9BSGE7QUFJdkJ4cEMsZUFBVUE7QUFKYSxJQUFsQixDQUFQO0FBTUQsRUFQRDs7QUFTQTs7O0FBR0Erb0MsZUFBY3Y0RCxTQUFkLENBQXdCbTZELFVBQXhCLEdBQXFDdFAsVUFBVSxVQUFTdVAsSUFBVCxFQUFlL0UsTUFBZixFQUF1QjdsQyxRQUF2QixFQUFpQztBQUM5RSxVQUFPLEtBQUs2cUMsU0FBTCxDQUFlRCxJQUFmLEVBQXFCL0UsTUFBckIsRUFBNkI3bEMsUUFBN0IsQ0FBUDtBQUNELEVBRm9DLEVBRWxDa3BDLGtCQUFrQixxQkFBbEIsRUFBeUMsb0JBQXpDLENBRmtDLENBQXJDOztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBSCxlQUFjdjRELFNBQWQsQ0FBd0JxNkQsU0FBeEIsR0FBb0MsVUFBU0QsSUFBVCxFQUFlL0UsTUFBZixFQUF1QjdsQyxRQUF2QixFQUFpQztBQUNuRSxPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJb0gsUUFBUSwwREFBWjs7QUFFQSxPQUFJLENBQUNwdEQsUUFBUWt0RCxJQUFSLENBQUwsRUFBb0I7QUFDbEIsV0FBTSxJQUFJelYsS0FBSixDQUFVMlYsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsT0FBSWw2RCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU95MEQsTUFBUCxLQUFrQixVQUFoRCxFQUE0RDtBQUMxRDdsQyxnQkFBVzZsQyxNQUFYO0FBQ0FBLGNBQVMsSUFBVDtBQUNEOztBQUVELE9BQUkrRCxVQUFVO0FBQ1ptQixVQUFLSDtBQURPLElBQWQ7O0FBSUEsT0FBSS9FLE1BQUosRUFBWTtBQUNWK0QsYUFBUW9CLFFBQVIsR0FBbUJuRixPQUFPbUYsUUFBMUI7QUFDQXBCLGFBQVFxQixzQkFBUixHQUFpQ3BGLE9BQU9vRixzQkFBeEM7QUFDQXJCLGFBQVFzQixlQUFSLEdBQTBCckYsT0FBT3FGLGVBQWpDO0FBQ0F0QixhQUFRdUIsT0FBUixHQUFrQnRGLE9BQU9zRixPQUF6QjtBQUNBdkIsYUFBUXdCLFdBQVIsR0FBc0J2RixPQUFPdUYsV0FBN0I7O0FBRUEsU0FBSXZGLE9BQU93RixlQUFYLEVBQTRCO0FBQzFCekIsZUFBUXlCLGVBQVIsR0FBMEIsS0FBS25CLGdCQUFMLENBQXNCckUsT0FBT3dGLGVBQTdCLEVBQThDLEVBQTlDLENBQTFCO0FBQ0Q7O0FBRUR6QixhQUFRMEIsUUFBUixHQUFtQnpGLE9BQU95RixRQUExQjtBQUNEOztBQUVELFVBQU8sS0FBSy9CLFlBQUwsQ0FBa0I7QUFDdkJsNUQsYUFBUSxNQURlO0FBRXZCbUcsVUFBSyxTQUZrQjtBQUd2QjhyQyxXQUFNc25CLE9BSGlCO0FBSXZCSixlQUFVLE9BSmE7QUFLdkJ4cEMsZUFBVUE7QUFMYSxJQUFsQixDQUFQO0FBT0QsRUF0Q0Q7O0FBd0NBOzs7QUFHQStvQyxlQUFjdjRELFNBQWQsQ0FBd0IrNkQsc0JBQXhCLEdBQWlEbFEsVUFBVSxVQUFTdVAsSUFBVCxFQUFlL0UsTUFBZixFQUF1QjdsQyxRQUF2QixFQUFpQztBQUMxRixVQUFPLEtBQUs2cUMsU0FBTCxDQUFlRCxJQUFmLEVBQXFCL0UsTUFBckIsRUFBNkI3bEMsUUFBN0IsQ0FBUDtBQUNELEVBRmdELEVBRTlDa3BDLGtCQUFrQixpQ0FBbEIsRUFBcUQsb0JBQXJELENBRjhDLENBQWpEOztBQUlBOzs7QUFHQUgsZUFBY3Y0RCxTQUFkLENBQXdCZzdELGFBQXhCLEdBQXdDblEsVUFBVSxVQUFTcmdELEdBQVQsRUFBYzR2RCxJQUFkLEVBQW9CL0UsTUFBcEIsRUFBNEI3bEMsUUFBNUIsRUFBc0M7QUFDdEYsVUFBTyxLQUFLeXJDLFlBQUwsQ0FBa0J6d0QsR0FBbEIsRUFBdUI0dkQsSUFBdkIsRUFBNkIvRSxNQUE3QixFQUFxQzdsQyxRQUFyQyxDQUFQO0FBQ0QsRUFGdUMsRUFFckNrcEMsa0JBQWtCLHdCQUFsQixFQUE0Qyx1QkFBNUMsQ0FGcUMsQ0FBeEM7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0FILGVBQWN2NEQsU0FBZCxDQUF3Qmk3RCxZQUF4QixHQUF1QyxVQUFTendELEdBQVQsRUFBYzR2RCxJQUFkLEVBQW9CL0UsTUFBcEIsRUFBNEI3bEMsUUFBNUIsRUFBc0M7QUFDM0UsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSW9ILFFBQVEsa0VBQVo7O0FBRUEsT0FBSSxDQUFDcHRELFFBQVFrdEQsSUFBUixDQUFMLEVBQW9CO0FBQ2xCLFdBQU0sSUFBSXpWLEtBQUosQ0FBVTJWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUlsNkQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPeTBELE1BQVAsS0FBa0IsVUFBaEQsRUFBNEQ7QUFDMUQ3bEMsZ0JBQVc2bEMsTUFBWDtBQUNBQSxjQUFTLElBQVQ7QUFDRDs7QUFFRCxPQUFJNkYsU0FBUztBQUNYWCxVQUFLSDtBQURNLElBQWI7O0FBSUEsT0FBSS9FLE1BQUosRUFBWTtBQUNWNkYsWUFBT1YsUUFBUCxHQUFrQm5GLE9BQU9tRixRQUF6QjtBQUNBVSxZQUFPVCxzQkFBUCxHQUFnQ3BGLE9BQU9vRixzQkFBdkM7QUFDQVMsWUFBT1IsZUFBUCxHQUF5QnJGLE9BQU9xRixlQUFoQztBQUNBUSxZQUFPUCxPQUFQLEdBQWlCdEYsT0FBT3NGLE9BQXhCO0FBQ0FPLFlBQU9OLFdBQVAsR0FBcUJ2RixPQUFPdUYsV0FBNUI7O0FBRUEsU0FBSXZGLE9BQU93RixlQUFYLEVBQTRCO0FBQzFCSyxjQUFPTCxlQUFQLEdBQXlCLEtBQUtuQixnQkFBTCxDQUFzQnJFLE9BQU93RixlQUE3QixFQUE4QyxFQUE5QyxDQUF6QjtBQUNEOztBQUVESyxZQUFPSixRQUFQLEdBQWtCekYsT0FBT3lGLFFBQXpCO0FBQ0Q7O0FBRUQsVUFBTyxLQUFLL0IsWUFBTCxDQUFrQjtBQUN2Qmw1RCxhQUFRLEtBRGU7QUFFdkJtRyxVQUFLLGFBQWF3RSxHQUZLO0FBR3ZCc25DLFdBQU1vcEIsTUFIaUI7QUFJdkJsQyxlQUFVLE9BSmE7QUFLdkJ4cEMsZUFBVUE7QUFMYSxJQUFsQixDQUFQO0FBT0QsRUF0Q0Q7O0FBd0NBOzs7O0FBSUErb0MsZUFBY3Y0RCxTQUFkLENBQXdCbTdELGlCQUF4QixHQUE0Q3RRLFVBQVUsU0FBU3VRLDJCQUFULEdBQXVDO0FBQzNGLFFBQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0QsRUFGMkMsRUFFekMzQyxrQkFBa0IsNEJBQWxCLEVBQWdELGlCQUFoRCxDQUZ5QyxDQUE1Qzs7QUFJQTs7OztBQUlBSCxlQUFjdjRELFNBQWQsQ0FBd0JzN0QsZUFBeEIsR0FBMEN6USxVQUFVLFNBQVMwUSx5QkFBVCxDQUFtQ3pDLFNBQW5DLEVBQThDM3pELEtBQTlDLEVBQXFEaVIsSUFBckQsRUFBMkQ7QUFDN0csUUFBS2lsRCxNQUFMLENBQVk5cEQsSUFBWixDQUFpQjtBQUNmdW5ELGdCQUFXQSxTQURJO0FBRWYzekQsWUFBT0EsS0FGUTtBQUdma3dELGFBQVFqL0M7QUFITyxJQUFqQjtBQUtELEVBTnlDLEVBTXZDc2lELGtCQUFrQiwwQkFBbEIsRUFBOEMsaUJBQTlDLENBTnVDLENBQTFDOztBQVFBOzs7O0FBSUFILGVBQWN2NEQsU0FBZCxDQUF3Qnc3RCxnQkFBeEIsR0FBMkMzUSxVQUFVLFNBQVM0USwwQkFBVCxDQUFvQ2pzQyxRQUFwQyxFQUE4QztBQUNqRyxVQUFPLEtBQUsrbEMsTUFBTCxDQUFZLEtBQUs4RixNQUFqQixFQUF5QjdyQyxRQUF6QixDQUFQO0FBQ0QsRUFGMEMsRUFFeENrcEMsa0JBQWtCLDJCQUFsQixFQUErQyxpQkFBL0MsQ0FGd0MsQ0FBM0M7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQUgsZUFBY3Y0RCxTQUFkLENBQXdCMDdELEtBQXhCLEdBQWdDLFVBQVNDLFVBQVQsRUFBcUJuc0MsUUFBckIsRUFBK0I7QUFDN0QsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSW9ILFFBQVEsNkNBQVo7O0FBRUEsT0FBSSxDQUFDcHRELFFBQVF5dUQsVUFBUixDQUFMLEVBQTBCO0FBQ3hCLFdBQU0sSUFBSWhYLEtBQUosQ0FBVTJWLEtBQVYsQ0FBTjtBQUNEOztBQUVELFVBQU8sS0FBS3ZCLFlBQUwsQ0FBa0I7QUFDdkJsNUQsYUFBUSxNQURlO0FBRXZCbUcsVUFBSyxvQkFGa0I7QUFHdkI4ckMsV0FBTTtBQUNKOHBCLGlCQUFVRDtBQUROLE1BSGlCO0FBTXZCM0MsZUFBVSxPQU5hO0FBT3ZCeHBDLGVBQVVBO0FBUGEsSUFBbEIsQ0FBUDtBQVNELEVBakJEOztBQW1CQTtBQUNBK29DLGVBQWN2NEQsU0FBZCxDQUF3Qm91QixPQUF4QixHQUFrQ3l0QyxjQUFsQztBQUNBdEQsZUFBY3Y0RCxTQUFkLENBQXdCODdELHNCQUF4QixHQUFpREQsY0FBakQ7QUFDQXRELGVBQWN2NEQsU0FBZCxDQUF3Qis3RCx1QkFBeEIsR0FBa0RGLGNBQWxEO0FBQ0F0RCxlQUFjdjRELFNBQWQsQ0FBd0JnOEQsZ0JBQXhCLEdBQTJDSCxjQUEzQztBQUNBdEQsZUFBY3Y0RCxTQUFkLENBQXdCaThELG9CQUF4QixHQUErQ0osY0FBL0M7QUFDQXRELGVBQWN2NEQsU0FBZCxDQUF3Qms4RCxxQkFBeEIsR0FBZ0RMLGNBQWhEOztBQUVBLFVBQVNBLGNBQVQsR0FBMEI7QUFDeEIsT0FBSTFQLFVBQVUsMkNBQ1osNkRBREY7O0FBR0EsU0FBTSxJQUFJdEosT0FBT3NaLGtCQUFYLENBQThCaFEsT0FBOUIsQ0FBTjtBQUNELEU7Ozs7Ozs7Ozs7QUMzZUQsS0FBSXlNLFdBQVcsbUJBQUExRixDQUFRLEVBQVIsQ0FBZjtBQUNBLEtBQUlrSixZQUFZLG1CQUFBbEosQ0FBUSxFQUFSLENBQWhCO0FBQ0EsS0FBSXJJLFlBQVksbUJBQUFxSSxDQUFRLEVBQVIsQ0FBaEI7QUFDQSxLQUFJd0Ysb0JBQW9CLG1CQUFBeEYsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsS0FBSW1KLGNBQWMsbUJBQUFuSixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxLQUFJclEsU0FBUyxtQkFBQXFRLENBQVEsRUFBUixDQUFiOztBQUVBLEtBQUlvSiwyQkFBMkJ6UixVQUM3QixZQUFXLENBQUUsQ0FEZ0IsRUFFN0I2TixrQkFBa0IsaUJBQWxCLEVBQXFDLG1CQUFyQyxDQUY2QixDQUEvQjs7QUFLQXQ1RCxRQUFPQyxPQUFQLEdBQWlCbzVELEtBQWpCOztBQUVBLFVBQVNBLEtBQVQsR0FBaUI7QUFDZjJELGFBQVVqOEQsS0FBVixDQUFnQixJQUFoQixFQUFzQkMsU0FBdEI7QUFDRDs7QUFFRHc0RCxVQUFTSCxLQUFULEVBQWdCMkQsU0FBaEI7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTNELE9BQU16NEQsU0FBTixDQUFnQnU4RCxTQUFoQixHQUE0QixVQUFTcnBCLE9BQVQsRUFBa0JnakIsUUFBbEIsRUFBNEIxbUMsUUFBNUIsRUFBc0M7QUFDaEUsT0FBSWd0QyxXQUFXLElBQWY7O0FBRUEsT0FBSXA4RCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU9zMUQsUUFBUCxLQUFvQixVQUFsRCxFQUE4RDtBQUM1RDFtQyxnQkFBVzBtQyxRQUFYO0FBQ0FBLGdCQUFXMzFELFNBQVg7QUFDRDs7QUFFRCxVQUFPLEtBQUtrOEQsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRcTJELGFBQWEzMUQsU0FBYixHQUNSLEtBRFEsR0FDQTtBQUNSLFdBSDBCLEVBR2xCO0FBQ1J5RixVQUFLLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTMUQsU0FBNUIsQ0FBaEIsS0FBeUQ7QUFDN0Q1QyxrQkFBYTMxRCxTQUFiLEdBQXlCLE1BQU0wQixtQkFBbUJpMEQsUUFBbkIsQ0FBL0IsR0FBOEQsRUFEMUQsQ0FKcUIsRUFLMEM7QUFDcEVwa0IsV0FBTW9CLE9BTm9CO0FBTzFCOGxCLGVBQVUsT0FQZ0I7QUFRMUJ4cEMsZUFBVUE7QUFSZ0IsSUFBckIsQ0FBUDtBQVVELEVBbEJEOztBQW9CQTs7Ozs7Ozs7QUFRQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0IwOEQsVUFBaEIsR0FBNkIsVUFBU0MsT0FBVCxFQUFrQm50QyxRQUFsQixFQUE0QjtBQUN2RCxPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJb0gsUUFBUSxxREFBWjs7QUFFQSxPQUFJLENBQUNwdEQsUUFBUXl2RCxPQUFSLENBQUwsRUFBdUI7QUFDckIsV0FBTSxJQUFJaFksS0FBSixDQUFVMlYsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsT0FBSWtDLFdBQVcsSUFBZjtBQUNBLE9BQUlwRCxVQUFVO0FBQ1p3QyxlQUFVO0FBREUsSUFBZDtBQUdBLFFBQUssSUFBSWo3RCxJQUFJLENBQWIsRUFBZ0JBLElBQUlnOEQsUUFBUS83RCxNQUE1QixFQUFvQyxFQUFFRCxDQUF0QyxFQUF5QztBQUN2QyxTQUFJa0YsVUFBVTtBQUNaTCxlQUFRLFdBREk7QUFFWnNzQyxhQUFNNnFCLFFBQVFoOEQsQ0FBUjtBQUZNLE1BQWQ7QUFJQXk0RCxhQUFRd0MsUUFBUixDQUFpQnJxRCxJQUFqQixDQUFzQjFMLE9BQXRCO0FBQ0Q7QUFDRCxVQUFPLEtBQUs0MkQsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELFFBRnBDO0FBRzFCaG5CLFdBQU1zbkIsT0FIb0I7QUFJMUJKLGVBQVUsT0FKZ0I7QUFLMUJ4cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBMUJEOztBQTRCQTs7Ozs7Ozs7OztBQVVBaXBDLE9BQU16NEQsU0FBTixDQUFnQjQ4RCxtQkFBaEIsR0FBc0MsVUFBU0MsYUFBVCxFQUF3QkMsaUJBQXhCLEVBQTJDdHRDLFFBQTNDLEVBQXFEO0FBQ3pGLE9BQUlwdkIsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPazhELGlCQUFQLEtBQTZCLFVBQTNELEVBQXVFO0FBQ3JFdHRDLGdCQUFXc3RDLGlCQUFYO0FBQ0FBLHlCQUFvQnY4RCxTQUFwQjtBQUNEOztBQUVELE9BQUlpOEQsV0FBVyxJQUFmO0FBQ0EsT0FBSXgyRCxNQUFNLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTMUQsU0FBNUIsQ0FBaEIsR0FBeUQsR0FBekQsR0FBK0Q3MkQsbUJBQW1CNDZELGNBQWMzRyxRQUFqQyxDQUEvRCxHQUE0RyxVQUF0SDtBQUNBLE9BQUk0RyxzQkFBc0IsS0FBMUIsRUFBaUM7QUFDL0I5MkQsWUFBTywwQkFBUDtBQUNEOztBQUVELFVBQU8sS0FBS3kyRCxFQUFMLENBQVExRCxZQUFSLENBQXFCO0FBQzFCbDVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLQSxHQUZxQjtBQUcxQjhyQyxXQUFNK3FCLGFBSG9CO0FBSTFCN0QsZUFBVSxPQUpnQjtBQUsxQnhwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFuQkQ7O0FBcUJBOzs7Ozs7OztBQVFBaXBDLE9BQU16NEQsU0FBTixDQUFnQis4RCxvQkFBaEIsR0FBdUMsVUFBU0osT0FBVCxFQUFrQkcsaUJBQWxCLEVBQXFDdHRDLFFBQXJDLEVBQStDO0FBQ3BGLE9BQUlwdkIsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPazhELGlCQUFQLEtBQTZCLFVBQTNELEVBQXVFO0FBQ3JFdHRDLGdCQUFXc3RDLGlCQUFYO0FBQ0FBLHlCQUFvQixJQUFwQjtBQUNEOztBQUVELE9BQUk1dkQsVUFBVSxtQkFBQWdtRCxDQUFRLEVBQVIsQ0FBZDtBQUNBLE9BQUlvSCxRQUFRLCtEQUFaOztBQUVBLE9BQUksQ0FBQ3B0RCxRQUFReXZELE9BQVIsQ0FBTCxFQUF1QjtBQUNyQixXQUFNLElBQUloWSxLQUFKLENBQVUyVixLQUFWLENBQU47QUFDRDs7QUFFRCxPQUFJa0MsV0FBVyxJQUFmO0FBQ0EsT0FBSXBELFVBQVU7QUFDWndDLGVBQVU7QUFERSxJQUFkO0FBR0EsUUFBSyxJQUFJajdELElBQUksQ0FBYixFQUFnQkEsSUFBSWc4RCxRQUFRLzdELE1BQTVCLEVBQW9DLEVBQUVELENBQXRDLEVBQXlDO0FBQ3ZDLFNBQUlrRixVQUFVO0FBQ1pMLGVBQVFzM0Qsc0JBQXNCLElBQXRCLEdBQTZCLHFCQUE3QixHQUFxRCw2QkFEakQ7QUFFWjVHLGlCQUFVeUcsUUFBUWg4RCxDQUFSLEVBQVd1MUQsUUFGVDtBQUdacGtCLGFBQU02cUIsUUFBUWg4RCxDQUFSO0FBSE0sTUFBZDtBQUtBeTRELGFBQVF3QyxRQUFSLENBQWlCcnFELElBQWpCLENBQXNCMUwsT0FBdEI7QUFDRDtBQUNELFVBQU8sS0FBSzQyRCxFQUFMLENBQVExRCxZQUFSLENBQXFCO0FBQzFCbDVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTMUQsU0FBNUIsQ0FBaEIsR0FBeUQsUUFGcEM7QUFHMUJobkIsV0FBTXNuQixPQUhvQjtBQUkxQkosZUFBVSxPQUpnQjtBQUsxQnhwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFoQ0Q7O0FBa0NBOzs7Ozs7OztBQVFBaXBDLE9BQU16NEQsU0FBTixDQUFnQmc5RCxVQUFoQixHQUE2QixVQUFTaFUsTUFBVCxFQUFpQng1QixRQUFqQixFQUEyQjtBQUN0RCxPQUFJZ3RDLFdBQVcsSUFBZjtBQUNBLFVBQU8sS0FBS0MsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLEtBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELEdBQXpELEdBQStENzJELG1CQUFtQittRCxPQUFPa04sUUFBMUIsQ0FGMUM7QUFHMUJwa0IsV0FBTWtYLE1BSG9CO0FBSTFCZ1EsZUFBVSxPQUpnQjtBQUsxQnhwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFURDs7QUFXQTs7Ozs7Ozs7QUFRQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0JpOUQsV0FBaEIsR0FBOEIsVUFBU04sT0FBVCxFQUFrQm50QyxRQUFsQixFQUE0QjtBQUN4RCxPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJb0gsUUFBUSxzREFBWjs7QUFFQSxPQUFJLENBQUNwdEQsUUFBUXl2RCxPQUFSLENBQUwsRUFBdUI7QUFDckIsV0FBTSxJQUFJaFksS0FBSixDQUFVMlYsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsT0FBSWtDLFdBQVcsSUFBZjtBQUNBLE9BQUlwRCxVQUFVO0FBQ1p3QyxlQUFVO0FBREUsSUFBZDtBQUdBLFFBQUssSUFBSWo3RCxJQUFJLENBQWIsRUFBZ0JBLElBQUlnOEQsUUFBUS83RCxNQUE1QixFQUFvQyxFQUFFRCxDQUF0QyxFQUF5QztBQUN2QyxTQUFJa0YsVUFBVTtBQUNaTCxlQUFRLGNBREk7QUFFWjB3RCxpQkFBVXlHLFFBQVFoOEQsQ0FBUixFQUFXdTFELFFBRlQ7QUFHWnBrQixhQUFNNnFCLFFBQVFoOEQsQ0FBUjtBQUhNLE1BQWQ7QUFLQXk0RCxhQUFRd0MsUUFBUixDQUFpQnJxRCxJQUFqQixDQUFzQjFMLE9BQXRCO0FBQ0Q7QUFDRCxVQUFPLEtBQUs0MkQsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELFFBRnBDO0FBRzFCaG5CLFdBQU1zbkIsT0FIb0I7QUFJMUJKLGVBQVUsT0FKZ0I7QUFLMUJ4cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBM0JEOztBQTZCQTs7Ozs7Ozs7QUFRQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0JrOUQsWUFBaEIsR0FBK0IsVUFBU2hILFFBQVQsRUFBbUIxbUMsUUFBbkIsRUFBNkI7QUFDMUQsT0FBSSxPQUFPMG1DLFFBQVAsS0FBb0IsVUFBcEIsSUFBa0MsT0FBT0EsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxPQUFPQSxRQUFQLEtBQW9CLFFBQTFGLEVBQW9HO0FBQ2xHLFNBQUl6a0QsTUFBTSxJQUFJb3hDLE9BQU9zWixrQkFBWCxDQUE4Qiw2Q0FBOUIsQ0FBVjtBQUNBM3NDLGdCQUFXMG1DLFFBQVg7QUFDQSxTQUFJLE9BQU8xbUMsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQyxjQUFPQSxTQUFTL2QsR0FBVCxDQUFQO0FBQ0Q7O0FBRUQsWUFBTyxLQUFLZ3JELEVBQUwsQ0FBUVUsUUFBUixDQUFpQmgyRCxNQUFqQixDQUF3QnNLLEdBQXhCLENBQVA7QUFDRDs7QUFFRCxPQUFJK3FELFdBQVcsSUFBZjtBQUNBLFVBQU8sS0FBS0MsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLFFBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELEdBQXpELEdBQStENzJELG1CQUFtQmkwRCxRQUFuQixDQUYxQztBQUcxQjhDLGVBQVUsT0FIZ0I7QUFJMUJ4cEMsZUFBVUE7QUFKZ0IsSUFBckIsQ0FBUDtBQU1ELEVBbEJEOztBQW9CQTs7Ozs7Ozs7QUFRQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0JvOUQsYUFBaEIsR0FBZ0MsVUFBU0MsU0FBVCxFQUFvQjd0QyxRQUFwQixFQUE4QjtBQUM1RCxPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJdnBELE1BQU0sbUJBQUF1cEQsQ0FBUSxFQUFSLENBQVY7O0FBRUEsT0FBSW9ILFFBQVEsMERBQVo7O0FBRUEsT0FBSSxDQUFDcHRELFFBQVFtd0QsU0FBUixDQUFMLEVBQXlCO0FBQ3ZCLFdBQU0sSUFBSTFZLEtBQUosQ0FBVTJWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUlrQyxXQUFXLElBQWY7QUFDQSxPQUFJcEQsVUFBVTtBQUNad0MsZUFBVWp5RCxJQUFJMHpELFNBQUosRUFBZSxTQUFTQyxjQUFULENBQXdCcEgsUUFBeEIsRUFBa0M7QUFDekQsY0FBTztBQUNMMXdELGlCQUFRLGNBREg7QUFFTDB3RCxtQkFBVUEsUUFGTDtBQUdMcGtCLGVBQU07QUFDSm9rQixxQkFBVUE7QUFETjtBQUhELFFBQVA7QUFPRCxNQVJTO0FBREUsSUFBZDs7QUFZQSxVQUFPLEtBQUt1RyxFQUFMLENBQVExRCxZQUFSLENBQXFCO0FBQzFCbDVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQnU2RCxTQUFTMUQsU0FBNUIsQ0FBaEIsR0FBeUQsUUFGcEM7QUFHMUJobkIsV0FBTXNuQixPQUhvQjtBQUkxQkosZUFBVSxPQUpnQjtBQUsxQnhwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUE5QkQ7O0FBZ0NBOzs7Ozs7OztBQVFBaXBDLE9BQU16NEQsU0FBTixDQUFnQnU5RCxhQUFoQixHQUFnQyxVQUFTcDRELEtBQVQsRUFBZ0Jrd0QsTUFBaEIsRUFBd0I3bEMsUUFBeEIsRUFBa0M7QUFDaEUsT0FBSWdqQixRQUFRLG1CQUFBMGdCLENBQVEsRUFBUixDQUFaO0FBQ0EsT0FBSXZwRCxNQUFNLG1CQUFBdXBELENBQVEsRUFBUixDQUFWOztBQUVBLE9BQUlzSixXQUFXLElBQWY7QUFDQSxPQUFJZ0IsU0FBU2hCLFNBQVNDLEVBQXRCOztBQUVBLE9BQUlyOEQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPeTBELE1BQVAsS0FBa0IsVUFBaEQsRUFBNEQ7QUFDMUQ3bEMsZ0JBQVc2bEMsTUFBWDtBQUNBQSxjQUFTLEVBQVQ7QUFDRCxJQUhELE1BR087QUFDTEEsY0FBUzdpQixNQUFNNmlCLE1BQU4sQ0FBVDtBQUNEOztBQUVEQSxVQUFPb0ksb0JBQVAsR0FBOEIsVUFBOUI7QUFDQXBJLFVBQU9PLFdBQVAsR0FBcUIsSUFBckI7QUFDQVAsVUFBT3FJLFFBQVAsR0FBa0IsS0FBbEI7O0FBRUE7QUFDQTtBQUNBLFFBQUtwSSxVQUFMOztBQUVBO0FBQ0E7QUFDQSxPQUFJbHVELFVBQVUsS0FDYm11RCxNQURhLENBQ05wd0QsS0FETSxFQUNDa3dELE1BREQsRUFFYmx2RCxJQUZhLENBRVJ3M0QsWUFGUSxDQUFkOztBQUlBLFlBQVNBLFlBQVQsQ0FBc0JDLGFBQXRCLEVBQXFDO0FBQ25DO0FBQ0EsU0FBSUEsY0FBY0MsTUFBZCxLQUF5QixDQUE3QixFQUFnQztBQUM5QjtBQUNBLGNBQU9ELGFBQVA7QUFDRDs7QUFFRDtBQUNBLFNBQUlQLFlBQVkxekQsSUFBSWkwRCxjQUFjbkksSUFBbEIsRUFBd0IsU0FBU3FJLFdBQVQsQ0FBcUI5VSxNQUFyQixFQUE2QjtBQUNuRSxjQUFPQSxPQUFPa04sUUFBZDtBQUNELE1BRmUsQ0FBaEI7O0FBSUEsWUFBT3NHLFNBQ05ZLGFBRE0sQ0FDUUMsU0FEUixFQUVObDNELElBRk0sQ0FFRDQzRCxRQUZDLEVBR041M0QsSUFITSxDQUdENjNELGVBSEMsQ0FBUDtBQUlEOztBQUVELFlBQVNELFFBQVQsQ0FBa0JFLG9CQUFsQixFQUF3QztBQUN0QyxZQUFPekIsU0FBU3VCLFFBQVQsQ0FBa0JFLHFCQUFxQkMsTUFBdkMsQ0FBUDtBQUNEOztBQUVELFlBQVNGLGVBQVQsR0FBMkI7QUFDekIsWUFBT3hCLFNBQVNlLGFBQVQsQ0FBdUJwNEQsS0FBdkIsRUFBOEJrd0QsTUFBOUIsQ0FBUDtBQUNEOztBQUVELE9BQUksQ0FBQzdsQyxRQUFMLEVBQWU7QUFDYixZQUFPcG9CLE9BQVA7QUFDRDs7QUFFREEsV0FBUWpCLElBQVIsQ0FBYWc0RCxPQUFiLEVBQXNCQyxPQUF0Qjs7QUFFQSxZQUFTRCxPQUFULEdBQW1CO0FBQ2pCOUIsaUJBQVksU0FBUzdVLElBQVQsR0FBZ0I7QUFDMUJoNEIsZ0JBQVMsSUFBVDtBQUNELE1BRkQsRUFFR2d1QyxPQUFPYSxXQUFQLElBQXNCdHFELFVBRnpCO0FBR0Q7O0FBRUQsWUFBU3FxRCxPQUFULENBQWlCM3NELEdBQWpCLEVBQXNCO0FBQ3BCNHFELGlCQUFZLFNBQVM3VSxJQUFULEdBQWdCO0FBQzFCaDRCLGdCQUFTL2QsR0FBVDtBQUNELE1BRkQsRUFFRytyRCxPQUFPYSxXQUFQLElBQXNCdHFELFVBRnpCO0FBR0Q7QUFDRixFQXZFRDs7QUF5RUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTBrRCxPQUFNejRELFNBQU4sQ0FBZ0JzK0QsU0FBaEIsR0FBNEIsVUFBU241RCxLQUFULEVBQWdCMDFELGVBQWhCLEVBQWlDO0FBQzNELE9BQUksUUFBTzExRCxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQXJCLEVBQStCO0FBQzdCMDFELHVCQUFrQjExRCxLQUFsQjtBQUNBQSxhQUFRNUUsU0FBUjtBQUNEOztBQUVELE9BQUlnK0QsUUFBUSxtQkFBQXJMLENBQVEsRUFBUixDQUFaOztBQUVBLE9BQUlzTCxlQUFlLG1CQUFBdEwsQ0FBUSxFQUFSLENBQW5COztBQUVBLE9BQUl4TixVQUFVLElBQUk4WSxZQUFKLEVBQWQ7QUFDQSxPQUFJaEIsU0FBUyxLQUFLZixFQUFsQjtBQUNBLE9BQUk5M0QsUUFBUSxJQUFaO0FBQ0EsT0FBSTB3RCxTQUFTbUksT0FBTzlELGdCQUFQLENBQ1g2RSxNQUFNLEVBQU4sRUFBVTFELG1CQUFtQixFQUE3QixFQUFpQztBQUMvQjExRCxZQUFPQTtBQUR3QixJQUFqQyxDQURXLEVBR1AsRUFITyxDQUFiOztBQU1BO0FBQ0FzNUQ7O0FBRUEsWUFBU0EsVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEI7QUFDMUIsU0FBSWhaLFFBQVFpWixRQUFaLEVBQXNCO0FBQ3BCO0FBQ0Q7O0FBRUQsU0FBSTdzQixJQUFKOztBQUVBLFNBQUk0c0IsV0FBV24rRCxTQUFmLEVBQTBCO0FBQ3hCdXhDLGNBQU87QUFDTDRzQixpQkFBUUE7QUFESCxRQUFQO0FBR0QsTUFKRCxNQUlPO0FBQ0w1c0IsY0FBTztBQUNMdWpCLGlCQUFRQTtBQURILFFBQVA7QUFHRDs7QUFFRG1JLFlBQU96RSxZQUFQLENBQW9CO0FBQ2xCbDVELGVBQVEsTUFEVTtBQUVsQm1HLFlBQUssZ0JBQWdCL0QsbUJBQW1CMEMsTUFBTW0wRCxTQUF6QixDQUFoQixHQUFzRCxTQUZ6QztBQUdsQkUsaUJBQVUsTUFIUTtBQUlsQmxuQixhQUFNQSxJQUpZO0FBS2xCdGlCLGlCQUFVb3ZDO0FBTFEsTUFBcEI7QUFPRDs7QUFFRCxZQUFTQSxjQUFULENBQXdCbnRELEdBQXhCLEVBQTZCeWhDLE9BQTdCLEVBQXNDO0FBQ3BDLFNBQUl3UyxRQUFRaVosUUFBWixFQUFzQjtBQUNwQjtBQUNEOztBQUVELFNBQUlsdEQsR0FBSixFQUFTO0FBQ1BpMEMsZUFBUW1aLE1BQVIsQ0FBZXB0RCxHQUFmO0FBQ0E7QUFDRDs7QUFFRGkwQyxhQUFRb1osT0FBUixDQUFnQjVyQixPQUFoQjs7QUFFQTtBQUNBLFNBQUlBLFFBQVF3ckIsTUFBUixLQUFtQm4rRCxTQUF2QixFQUFrQztBQUNoQ21sRCxlQUFRcVosSUFBUjtBQUNBO0FBQ0Q7O0FBRUROLGdCQUFXdnJCLFFBQVF3ckIsTUFBbkI7QUFDRDs7QUFFRCxVQUFPaFosT0FBUDtBQUNELEVBdEVEOztBQXdFQTs7OztBQUlBK1MsT0FBTXo0RCxTQUFOLENBQWdCZy9ELFNBQWhCLEdBQTRCblUsVUFBVSxVQUFTd0ssTUFBVCxFQUFpQjtBQUNyRCxPQUFJaDBELE9BQU8sSUFBWDtBQUNBLFVBQU8sU0FBUzI5RCxTQUFULENBQW1CNzVELEtBQW5CLEVBQTBCODVELE1BQTFCLEVBQWtDQyxPQUFsQyxFQUEyQztBQUNoRCxTQUFJMXFELEVBQUo7O0FBRUEsU0FBSSxPQUFPMHFELE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakM7QUFDQTFxRCxZQUFLMHFELE9BQUw7QUFDRCxNQUhELE1BR087QUFDTDtBQUNBMXFELFlBQUt5cUQsTUFBTDtBQUNEOztBQUVENTlELFVBQUtrMEQsTUFBTCxDQUFZcHdELEtBQVosRUFBbUJrd0QsTUFBbkIsRUFBMkIsU0FBUzhKLFVBQVQsQ0FBb0IxdEQsR0FBcEIsRUFBeUJ5aEMsT0FBekIsRUFBa0M7QUFDM0QsV0FBSXpoQyxHQUFKLEVBQVM7QUFDUCtDLFlBQUcvQyxHQUFIO0FBQ0E7QUFDRDs7QUFFRCtDLFVBQUcwK0IsUUFBUXVpQixJQUFYO0FBQ0QsTUFQRDtBQVFELElBbkJEO0FBb0JELEVBdEIyQixFQXVCNUIsa0ZBQ0EsNkVBeEI0QixDQUE1Qjs7QUEwQkE7Ozs7Ozs7OztBQVNBZ0QsT0FBTXo0RCxTQUFOLENBQWdCKzlELFFBQWhCLEdBQTJCLFVBQVNHLE1BQVQsRUFBaUIxdUMsUUFBakIsRUFBMkI7QUFDcEQ7QUFDQSxPQUFJNHZDLFlBQVksR0FBaEI7QUFDQTtBQUNBLE9BQUlDLFdBQVcsSUFBZjtBQUNBLE9BQUkvekMsT0FBTyxDQUFYOztBQUVBO0FBQ0E7QUFDQSxPQUFJa3hDLFdBQVcsSUFBZjtBQUNBLE9BQUlnQixTQUFTaEIsU0FBU0MsRUFBdEI7O0FBRUEsT0FBSXIxRCxVQUFVazRELFdBQWQ7O0FBRUEsWUFBU0EsU0FBVCxHQUFxQjtBQUNuQixZQUFPOUIsT0FBT3pFLFlBQVAsQ0FBb0I7QUFDekJsNUQsZUFBUSxLQURpQjtBQUV6Qm01RCxpQkFBVSxNQUZlO0FBR3pCaHpELFlBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVMxRCxTQUE1QixDQUFoQixHQUF5RCxRQUF6RCxHQUFvRW9GO0FBSGhELE1BQXBCLEVBSUovM0QsSUFKSSxDQUlDLFNBQVNnNEQsT0FBVCxDQUFpQmpyQixPQUFqQixFQUEwQjtBQUNoQzVuQjtBQUNBLFdBQUl6SSxRQUFRdThDLFlBQVk5ekMsSUFBWixHQUFtQkEsSUFBL0I7QUFDQSxXQUFJekksUUFBUXc4QyxRQUFaLEVBQXNCO0FBQ3BCeDhDLGlCQUFRdzhDLFFBQVI7QUFDRDs7QUFFRCxXQUFJbnNCLFFBQVFxc0IsTUFBUixLQUFtQixXQUF2QixFQUFvQztBQUNsQyxnQkFBTy9CLE9BQU9MLFFBQVAsQ0FBZ0J0NkMsS0FBaEIsQ0FBc0JBLEtBQXRCLEVBQTZCMWMsSUFBN0IsQ0FBa0NtNUQsU0FBbEMsQ0FBUDtBQUNEOztBQUVELGNBQU9wc0IsT0FBUDtBQUNELE1BaEJNLENBQVA7QUFpQkQ7O0FBRUQsT0FBSSxDQUFDMWpCLFFBQUwsRUFBZTtBQUNiLFlBQU9wb0IsT0FBUDtBQUNEOztBQUVEQSxXQUFRakIsSUFBUixDQUFhcTVELFNBQWIsRUFBd0JDLFNBQXhCOztBQUVBLFlBQVNELFNBQVQsQ0FBbUJ0c0IsT0FBbkIsRUFBNEI7QUFDMUJtcEIsaUJBQVksU0FBUzdVLElBQVQsR0FBZ0I7QUFDMUJoNEIsZ0JBQVMsSUFBVCxFQUFlMGpCLE9BQWY7QUFDRCxNQUZELEVBRUdzcUIsT0FBT2EsV0FBUCxJQUFzQnRxRCxVQUZ6QjtBQUdEOztBQUVELFlBQVMwckQsU0FBVCxDQUFtQmh1RCxHQUFuQixFQUF3QjtBQUN0QjRxRCxpQkFBWSxTQUFTN1UsSUFBVCxHQUFnQjtBQUMxQmg0QixnQkFBUy9kLEdBQVQ7QUFDRCxNQUZELEVBRUcrckQsT0FBT2EsV0FBUCxJQUFzQnRxRCxVQUZ6QjtBQUdEO0FBQ0YsRUFuREQ7O0FBcURBOzs7Ozs7O0FBT0Ewa0QsT0FBTXo0RCxTQUFOLENBQWdCMC9ELFVBQWhCLEdBQTZCLFVBQVNsd0MsUUFBVCxFQUFtQjtBQUM5QyxPQUFJZ3RDLFdBQVcsSUFBZjtBQUNBLFVBQU8sS0FBS0MsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELFFBRnBDO0FBRzFCRSxlQUFVLE9BSGdCO0FBSTFCeHBDLGVBQVVBO0FBSmdCLElBQXJCLENBQVA7QUFNRCxFQVJEOztBQVVBOzs7Ozs7O0FBT0FpcEMsT0FBTXo0RCxTQUFOLENBQWdCMi9ELFdBQWhCLEdBQThCLFVBQVNud0MsUUFBVCxFQUFtQjtBQUMvQyxPQUFJZ3RDLFdBQVcsSUFBZjtBQUNBLFVBQU8sS0FBS0MsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLEtBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELHdCQUZwQztBQUcxQkUsZUFBVSxNQUhnQjtBQUkxQnhwQyxlQUFVQTtBQUpnQixJQUFyQixDQUFQO0FBTUQsRUFSRDs7QUFVQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0I0L0QsY0FBaEIsR0FBaUMsVUFBU3ZLLE1BQVQsRUFBaUI3bEMsUUFBakIsRUFBMkI7QUFDMUQsT0FBSSxPQUFPNmxDLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDaEM3bEMsZ0JBQVc2bEMsTUFBWDtBQUNBQSxjQUFTLEVBQVQ7QUFDRCxJQUhELE1BR08sSUFBSUEsV0FBVzkwRCxTQUFmLEVBQTBCO0FBQy9CODBELGNBQVMsRUFBVDtBQUNEOztBQUVELFVBQU8sS0FBS29ILEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsa0JBRmhDO0FBRzFCaG5CLFdBQU11akIsTUFIb0I7QUFJMUIyRCxlQUFVLE1BSmdCO0FBSzFCeHBDLGVBQVVBO0FBTGdCLElBQXJCLENBQVA7QUFPRCxFQWZEOztBQWlCQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0I2L0QsV0FBaEIsR0FBOEIsVUFBU0MsT0FBVCxFQUFrQnR0RCxJQUFsQixFQUF3QmdkLFFBQXhCLEVBQWtDO0FBQzlELE9BQUksT0FBT2hkLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUJnZCxnQkFBV2hkLElBQVg7QUFDQUEsWUFBTyxFQUFQO0FBQ0QsSUFIRCxNQUdPLElBQUlBLFNBQVNqUyxTQUFiLEVBQXdCO0FBQzdCaVMsWUFBTyxFQUFQO0FBQ0Q7O0FBRUQsT0FBSUEsS0FBS3V0RCxlQUFMLEtBQXlCeC9ELFNBQTdCLEVBQXdDKzdEO0FBQ3hDLE9BQUkwRCxvQkFBcUJ4dEQsS0FBS3V0RCxlQUFMLElBQXdCdnRELEtBQUt3dEQsaUJBQTlCLEdBQW1ELE1BQW5ELEdBQTRELE9BQXBGOztBQUVBLFVBQU8sS0FBS3ZELEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsWUFBckQsR0FBb0U3MkQsbUJBQW1CNjlELFFBQVE1SixRQUEzQixDQUFwRSxHQUNILHFCQURHLEdBQ3FCOEosaUJBSEE7QUFJMUJsdUIsV0FBTWd1QixPQUpvQjtBQUsxQjlHLGVBQVUsT0FMZ0I7QUFNMUJ4cEMsZUFBVUE7QUFOZ0IsSUFBckIsQ0FBUDtBQVFELEVBbkJEOztBQXFCQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0JpZ0UsVUFBaEIsR0FBNkIsVUFBUy9KLFFBQVQsRUFBbUIxbUMsUUFBbkIsRUFBNkI7QUFDeEQsVUFBTyxLQUFLaXRDLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsWUFBckQsR0FBb0U3MkQsbUJBQW1CaTBELFFBQW5CLENBRi9DO0FBRzFCOEMsZUFBVSxNQUhnQjtBQUkxQnhwQyxlQUFVQTtBQUpnQixJQUFyQixDQUFQO0FBTUQsRUFQRDs7QUFTQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0JrZ0UsYUFBaEIsR0FBZ0MsVUFBU2hLLFFBQVQsRUFBbUIxakQsSUFBbkIsRUFBeUJnZCxRQUF6QixFQUFtQztBQUNqRSxPQUFJLE9BQU9oZCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCZ2QsZ0JBQVdoZCxJQUFYO0FBQ0FBLFlBQU8sRUFBUDtBQUNELElBSEQsTUFHTyxJQUFJQSxTQUFTalMsU0FBYixFQUF3QjtBQUM3QmlTLFlBQU8sRUFBUDtBQUNEOztBQUVELE9BQUlBLEtBQUt1dEQsZUFBTCxLQUF5QngvRCxTQUE3QixFQUF3Qys3RDtBQUN4QyxPQUFJMEQsb0JBQXFCeHRELEtBQUt1dEQsZUFBTCxJQUF3QnZ0RCxLQUFLd3RELGlCQUE5QixHQUFtRCxNQUFuRCxHQUE0RCxPQUFwRjs7QUFFQSxVQUFPLEtBQUt2RCxFQUFMLENBQVExRCxZQUFSLENBQXFCO0FBQzFCbDVELGFBQVEsUUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLNjJELFNBQXhCLENBQWhCLEdBQXFELFlBQXJELEdBQW9FNzJELG1CQUFtQmkwRCxRQUFuQixDQUFwRSxHQUNILHFCQURHLEdBQ3FCOEosaUJBSEE7QUFJMUJoSCxlQUFVLE9BSmdCO0FBSzFCeHBDLGVBQVVBO0FBTGdCLElBQXJCLENBQVA7QUFPRCxFQWxCRDs7QUFvQkFpcEMsT0FBTXo0RCxTQUFOLENBQWdCbWdFLGFBQWhCLEdBQWdDLFVBQVMzdEQsSUFBVCxFQUFlZ2QsUUFBZixFQUF5QjtBQUN2RCxPQUFJLE9BQU9oZCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCZ2QsZ0JBQVdoZCxJQUFYO0FBQ0FBLFlBQU8sRUFBUDtBQUNELElBSEQsTUFHTyxJQUFJQSxTQUFTalMsU0FBYixFQUF3QjtBQUM3QmlTLFlBQU8sRUFBUDtBQUNEOztBQUVELE9BQUlBLEtBQUt1dEQsZUFBTCxLQUF5QngvRCxTQUE3QixFQUF3Qys3RDtBQUN4QyxPQUFJMEQsb0JBQXFCeHRELEtBQUt1dEQsZUFBTCxJQUF3QnZ0RCxLQUFLd3RELGlCQUE5QixHQUFtRCxNQUFuRCxHQUE0RCxPQUFwRjs7QUFFQSxVQUFPLEtBQUt2RCxFQUFMLENBQVExRCxZQUFSLENBQXFCO0FBQzFCbDVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLNjJELFNBQXhCLENBQWhCLEdBQXFELGlCQUFyRCxHQUNILHFCQURHLEdBQ3FCa0gsaUJBSEE7QUFJMUJoSCxlQUFVLE9BSmdCO0FBSzFCeHBDLGVBQVVBO0FBTGdCLElBQXJCLENBQVA7QUFPRCxFQWxCRDs7QUFvQkFpcEMsT0FBTXo0RCxTQUFOLENBQWdCb2dFLGFBQWhCLEdBQWdDLFVBQVNDLFFBQVQsRUFBbUI3dEQsSUFBbkIsRUFBeUJnZCxRQUF6QixFQUFtQztBQUNqRSxPQUFJLE9BQU9oZCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCZ2QsZ0JBQVdoZCxJQUFYO0FBQ0FBLFlBQU8sRUFBUDtBQUNELElBSEQsTUFHTyxJQUFJQSxTQUFTalMsU0FBYixFQUF3QjtBQUM3QmlTLFlBQU8sRUFBUDtBQUNEOztBQUVELE9BQUlBLEtBQUt1dEQsZUFBTCxLQUF5QngvRCxTQUE3QixFQUF3Qys3RDtBQUN4QyxPQUFJMEQsb0JBQXFCeHRELEtBQUt1dEQsZUFBTCxJQUF3QnZ0RCxLQUFLd3RELGlCQUE5QixHQUFtRCxNQUFuRCxHQUE0RCxPQUFwRjs7QUFFQSxVQUFPLEtBQUt2RCxFQUFMLENBQVExRCxZQUFSLENBQXFCO0FBQzFCbDVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLGdCQUFnQi9ELG1CQUFtQixLQUFLNjJELFNBQXhCLENBQWhCLEdBQXFELGlCQUFyRCxHQUNILHFCQURHLEdBQ3FCa0gsaUJBRHJCLEdBRUgsMkJBRkcsSUFFNEJ4dEQsS0FBSzh0RCx1QkFBTCxHQUErQixNQUEvQixHQUF3QyxPQUZwRSxDQUZxQjtBQUsxQnRILGVBQVUsT0FMZ0I7QUFNMUJsbkIsV0FBTXV1QixRQU5vQjtBQU8xQjd3QyxlQUFVQTtBQVBnQixJQUFyQixDQUFQO0FBU0QsRUFwQkQ7O0FBc0JBaXBDLE9BQU16NEQsU0FBTixDQUFnQnVnRSxXQUFoQixHQUE4QixVQUFTbEwsTUFBVCxFQUFpQjdsQyxRQUFqQixFQUEyQjtBQUN2RCxPQUFJLE9BQU82bEMsTUFBUCxLQUFrQixVQUF0QixFQUFrQztBQUNoQzdsQyxnQkFBVzZsQyxNQUFYO0FBQ0FBLGNBQVMsRUFBVDtBQUNELElBSEQsTUFHTyxJQUFJQSxXQUFXOTBELFNBQWYsRUFBMEI7QUFDL0I4MEQsY0FBUyxFQUFUO0FBQ0Q7O0FBRUQsVUFBTyxLQUFLb0gsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzYyRCxTQUF4QixDQUFoQixHQUFxRCxlQUZoQztBQUcxQmhuQixXQUFNdWpCLE1BSG9CO0FBSTFCMkQsZUFBVSxNQUpnQjtBQUsxQnhwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFmRDs7QUFpQkFpcEMsT0FBTXo0RCxTQUFOLENBQWdCd2dFLFFBQWhCLEdBQTJCLFVBQVNDLElBQVQsRUFBZWp1RCxJQUFmLEVBQXFCZ2QsUUFBckIsRUFBK0I7QUFDeEQsT0FBSSxPQUFPaGQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJd3RELG9CQUFvQnh0RCxLQUFLd3RELGlCQUFMLEtBQTJCLElBQTNCLEdBQWtDLE1BQWxDLEdBQTJDLE9BQW5FOztBQUVBLFVBQU8sS0FBS3ZELEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsU0FBckQsR0FBaUU3MkQsbUJBQW1CdytELEtBQUt2SyxRQUF4QixDQUFqRSxHQUNILHFCQURHLEdBQ3FCOEosaUJBSEE7QUFJMUJsdUIsV0FBTTJ1QixJQUpvQjtBQUsxQnpILGVBQVUsT0FMZ0I7QUFNMUJ4cEMsZUFBVUE7QUFOZ0IsSUFBckIsQ0FBUDtBQVFELEVBbEJEOztBQW9CQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0IwZ0UsT0FBaEIsR0FBMEIsVUFBU3hLLFFBQVQsRUFBbUIxbUMsUUFBbkIsRUFBNkI7QUFDckQsVUFBTyxLQUFLaXRDLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsU0FBckQsR0FBaUU3MkQsbUJBQW1CaTBELFFBQW5CLENBRjVDO0FBRzFCOEMsZUFBVSxNQUhnQjtBQUkxQnhwQyxlQUFVQTtBQUpnQixJQUFyQixDQUFQO0FBTUQsRUFQRDs7QUFTQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0IyZ0UsVUFBaEIsR0FBNkIsVUFBU3pLLFFBQVQsRUFBbUIxakQsSUFBbkIsRUFBeUJnZCxRQUF6QixFQUFtQztBQUM5RCxPQUFJLE9BQU9oZCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCZ2QsZ0JBQVdoZCxJQUFYO0FBQ0FBLFlBQU8sRUFBUDtBQUNELElBSEQsTUFHTyxJQUFJQSxTQUFTalMsU0FBYixFQUF3QjtBQUM3QmlTLFlBQU8sRUFBUDtBQUNEOztBQUVELE9BQUl3dEQsb0JBQW9CeHRELEtBQUt3dEQsaUJBQUwsS0FBMkIsSUFBM0IsR0FBa0MsTUFBbEMsR0FBMkMsT0FBbkU7O0FBRUEsVUFBTyxLQUFLdkQsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLFFBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzYyRCxTQUF4QixDQUFoQixHQUFxRCxTQUFyRCxHQUFpRTcyRCxtQkFBbUJpMEQsUUFBbkIsQ0FBakUsR0FDSCxxQkFERyxHQUNxQjhKLGlCQUhBO0FBSTFCaEgsZUFBVSxPQUpnQjtBQUsxQnhwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFqQkQ7O0FBbUJBaXBDLE9BQU16NEQsU0FBTixDQUFnQjRnRSxVQUFoQixHQUE2QixVQUFTcHVELElBQVQsRUFBZWdkLFFBQWYsRUFBeUI7QUFDcEQsT0FBSSxPQUFPaGQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJd3RELG9CQUFvQnh0RCxLQUFLd3RELGlCQUFMLEtBQTJCLElBQTNCLEdBQWtDLE1BQWxDLEdBQTJDLE9BQW5FOztBQUVBLFVBQU8sS0FBS3ZELEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsY0FBckQsR0FDSCxxQkFERyxHQUNxQmtILGlCQUhBO0FBSTFCaEgsZUFBVSxPQUpnQjtBQUsxQnhwQyxlQUFVQTtBQUxnQixJQUFyQixDQUFQO0FBT0QsRUFqQkQ7O0FBbUJBaXBDLE9BQU16NEQsU0FBTixDQUFnQjZnRSxVQUFoQixHQUE2QixVQUFTQyxLQUFULEVBQWdCdHVELElBQWhCLEVBQXNCZ2QsUUFBdEIsRUFBZ0M7QUFDM0QsT0FBSSxPQUFPaGQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJd3RELG9CQUFvQnh0RCxLQUFLd3RELGlCQUFMLEtBQTJCLElBQTNCLEdBQWtDLE1BQWxDLEdBQTJDLE9BQW5FOztBQUVBLFVBQU8sS0FBS3ZELEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsY0FBckQsR0FDSCxxQkFERyxHQUNxQmtILGlCQURyQixHQUVILHNCQUZHLElBRXVCeHRELEtBQUt1dUQsa0JBQUwsS0FBNEIsSUFBNUIsR0FBbUMsTUFBbkMsR0FBNEMsT0FGbkUsQ0FGcUI7QUFLMUIvSCxlQUFVLE9BTGdCO0FBTTFCbG5CLFdBQU1ndkIsS0FOb0I7QUFPMUJ0eEMsZUFBVUE7QUFQZ0IsSUFBckIsQ0FBUDtBQVNELEVBbkJEOztBQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1RUFpcEMsT0FBTXo0RCxTQUFOLENBQWdCZ2hFLFdBQWhCLEdBQThCLFVBQVNDLFFBQVQsRUFBbUJ6dUQsSUFBbkIsRUFBeUJnZCxRQUF6QixFQUFtQztBQUMvRCxPQUFJcHZCLFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBTzRSLElBQVAsS0FBZ0IsVUFBOUMsRUFBMEQ7QUFDeERnZCxnQkFBV2hkLElBQVg7QUFDQUEsWUFBTyxFQUFQO0FBQ0Q7O0FBRUQsT0FBSUEsS0FBS3V0RCxlQUFMLEtBQXlCeC9ELFNBQTdCLEVBQXdDKzdEO0FBQ3hDLE9BQUkwRCxvQkFBcUJ4dEQsS0FBS3V0RCxlQUFMLElBQXdCdnRELEtBQUt3dEQsaUJBQTlCLEdBQW1ELE1BQW5ELEdBQTRELE9BQXBGOztBQUVBLE9BQUl4RCxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVMxRCxTQUE1QixDQUFoQixHQUF5RCw4QkFBekQsR0FDRGtILGlCQUhzQjtBQUkxQmhILGVBQVUsT0FKZ0I7QUFLMUJsbkIsV0FBTW12QixRQUxvQjtBQU0xQnp4QyxlQUFVQTtBQU5nQixJQUFyQixDQUFQO0FBUUQsRUFsQkQ7O0FBb0JBOzs7QUFHQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0I2NUQsWUFBaEIsR0FBK0JoUCxVQUFVLFVBQVNyN0IsUUFBVCxFQUFtQjtBQUMxRCxVQUFPLEtBQUtzcUMsV0FBTCxDQUFpQnRxQyxRQUFqQixDQUFQO0FBQ0QsRUFGOEIsRUFFNUJrcEMsa0JBQWtCLHNCQUFsQixFQUEwQyxxQkFBMUMsQ0FGNEIsQ0FBL0I7O0FBSUE7Ozs7Ozs7QUFPQUQsT0FBTXo0RCxTQUFOLENBQWdCODVELFdBQWhCLEdBQThCLFVBQVN0cUMsUUFBVCxFQUFtQjtBQUMvQyxPQUFJZ3RDLFdBQVcsSUFBZjtBQUNBLFVBQU8sS0FBS0MsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLEtBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELE9BRnBDO0FBRzFCRSxlQUFVLE1BSGdCO0FBSTFCeHBDLGVBQVVBO0FBSmdCLElBQXJCLENBQVA7QUFNRCxFQVJEOztBQVVBOzs7QUFHQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0IrNUQsYUFBaEIsR0FBZ0NsUCxVQUFVLFVBQVNyZ0QsR0FBVCxFQUFjZ2xCLFFBQWQsRUFBd0I7QUFDaEUsVUFBTyxLQUFLd3FDLFNBQUwsQ0FBZXh2RCxHQUFmLEVBQW9CZ2xCLFFBQXBCLENBQVA7QUFDRCxFQUYrQixFQUU3QmtwQyxrQkFBa0IsdUJBQWxCLEVBQTJDLG1CQUEzQyxDQUY2QixDQUFoQzs7QUFLQTs7Ozs7Ozs7QUFRQUQsT0FBTXo0RCxTQUFOLENBQWdCZzZELFNBQWhCLEdBQTRCLFVBQVN4dkQsR0FBVCxFQUFjZ2xCLFFBQWQsRUFBd0I7QUFDbEQsT0FBSWd0QyxXQUFXLElBQWY7QUFDQSxVQUFPLEtBQUtDLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVMxRCxTQUE1QixDQUFoQixHQUF5RCxRQUF6RCxHQUFvRXR1RCxHQUYvQztBQUcxQnd1RCxlQUFVLE1BSGdCO0FBSTFCeHBDLGVBQVVBO0FBSmdCLElBQXJCLENBQVA7QUFNRCxFQVJEOztBQVVBOzs7QUFHQWlwQyxPQUFNejRELFNBQU4sQ0FBZ0JpNkQsYUFBaEIsR0FBZ0NwUCxVQUFVLFVBQVNyZ0QsR0FBVCxFQUFjZ2xCLFFBQWQsRUFBd0I7QUFDaEUsVUFBTyxLQUFLMHFDLFlBQUwsQ0FBa0IxdkQsR0FBbEIsRUFBdUJnbEIsUUFBdkIsQ0FBUDtBQUNELEVBRitCLEVBRTdCa3BDLGtCQUFrQix1QkFBbEIsRUFBMkMsc0JBQTNDLENBRjZCLENBQWhDOztBQUlBOzs7Ozs7OztBQVFBRCxPQUFNejRELFNBQU4sQ0FBZ0JrNkQsWUFBaEIsR0FBK0IsVUFBUzF2RCxHQUFULEVBQWNnbEIsUUFBZCxFQUF3QjtBQUNyRCxPQUFJZ3RDLFdBQVcsSUFBZjtBQUNBLFVBQU8sS0FBS0MsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLFFBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELFFBQXpELEdBQW9FdHVELEdBRi9DO0FBRzFCd3VELGVBQVUsT0FIZ0I7QUFJMUJ4cEMsZUFBVUE7QUFKZ0IsSUFBckIsQ0FBUDtBQU1ELEVBUkQ7O0FBVUE7OztBQUdBaXBDLE9BQU16NEQsU0FBTixDQUFnQm02RCxVQUFoQixHQUE2QnRQLFVBQVUsVUFBU3VQLElBQVQsRUFBZS9FLE1BQWYsRUFBdUI3bEMsUUFBdkIsRUFBaUM7QUFDdEUsVUFBTyxLQUFLNnFDLFNBQUwsQ0FBZUQsSUFBZixFQUFxQi9FLE1BQXJCLEVBQTZCN2xDLFFBQTdCLENBQVA7QUFDRCxFQUY0QixFQUUxQmtwQyxrQkFBa0Isb0JBQWxCLEVBQXdDLG1CQUF4QyxDQUYwQixDQUE3Qjs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBRCxPQUFNejRELFNBQU4sQ0FBZ0JxNkQsU0FBaEIsR0FBNEIsVUFBU0QsSUFBVCxFQUFlL0UsTUFBZixFQUF1QjdsQyxRQUF2QixFQUFpQztBQUMzRCxPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJb0gsUUFBUSx5REFBWjs7QUFFQSxPQUFJLENBQUNwdEQsUUFBUWt0RCxJQUFSLENBQUwsRUFBb0I7QUFDbEIsV0FBTSxJQUFJelYsS0FBSixDQUFVMlYsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsT0FBSWw2RCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU95MEQsTUFBUCxLQUFrQixVQUFoRCxFQUE0RDtBQUMxRDdsQyxnQkFBVzZsQyxNQUFYO0FBQ0FBLGNBQVMsSUFBVDtBQUNEOztBQUVELE9BQUkrRCxVQUFVO0FBQ1ptQixVQUFLSDtBQURPLElBQWQ7O0FBSUEsT0FBSS9FLE1BQUosRUFBWTtBQUNWK0QsYUFBUW9CLFFBQVIsR0FBbUJuRixPQUFPbUYsUUFBMUI7QUFDQXBCLGFBQVFxQixzQkFBUixHQUFpQ3BGLE9BQU9vRixzQkFBeEM7QUFDQXJCLGFBQVFzQixlQUFSLEdBQTBCckYsT0FBT3FGLGVBQWpDO0FBQ0F0QixhQUFRd0IsV0FBUixHQUFzQnZGLE9BQU91RixXQUE3Qjs7QUFFQSxTQUFJdkYsT0FBT3dGLGVBQVgsRUFBNEI7QUFDMUJ6QixlQUFReUIsZUFBUixHQUEwQixLQUFLNEIsRUFBTCxDQUFRL0MsZ0JBQVIsQ0FBeUJyRSxPQUFPd0YsZUFBaEMsRUFBaUQsRUFBakQsQ0FBMUI7QUFDRDs7QUFFRHpCLGFBQVEwQixRQUFSLEdBQW1CekYsT0FBT3lGLFFBQTFCO0FBQ0Q7O0FBRUQsVUFBTyxLQUFLMkIsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzYyRCxTQUF4QixDQUFoQixHQUFxRCxPQUZoQztBQUcxQmhuQixXQUFNc25CLE9BSG9CO0FBSTFCSixlQUFVLE9BSmdCO0FBSzFCeHBDLGVBQVVBO0FBTGdCLElBQXJCLENBQVA7QUFPRCxFQXJDRDs7QUF1Q0E7OztBQUdBaXBDLE9BQU16NEQsU0FBTixDQUFnQis2RCxzQkFBaEIsR0FBeUNsUSxVQUFVLFNBQVNxVyxnQ0FBVCxDQUEwQzlHLElBQTFDLEVBQWdEL0UsTUFBaEQsRUFBd0Q3bEMsUUFBeEQsRUFBa0U7QUFDbkgsVUFBTyxLQUFLNnFDLFNBQUwsQ0FBZUQsSUFBZixFQUFxQi9FLE1BQXJCLEVBQTZCN2xDLFFBQTdCLENBQVA7QUFDRCxFQUZ3QyxFQUV0Q2twQyxrQkFBa0IsZ0NBQWxCLEVBQW9ELG1CQUFwRCxDQUZzQyxDQUF6Qzs7QUFJQTs7O0FBR0FELE9BQU16NEQsU0FBTixDQUFnQmc3RCxhQUFoQixHQUFnQ25RLFVBQVUsVUFBU3JnRCxHQUFULEVBQWM0dkQsSUFBZCxFQUFvQi9FLE1BQXBCLEVBQTRCN2xDLFFBQTVCLEVBQXNDO0FBQzlFLFVBQU8sS0FBS3lyQyxZQUFMLENBQWtCendELEdBQWxCLEVBQXVCNHZELElBQXZCLEVBQTZCL0UsTUFBN0IsRUFBcUM3bEMsUUFBckMsQ0FBUDtBQUNELEVBRitCLEVBRTdCa3BDLGtCQUFrQix1QkFBbEIsRUFBMkMsc0JBQTNDLENBRjZCLENBQWhDOztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0FELE9BQU16NEQsU0FBTixDQUFnQmk3RCxZQUFoQixHQUErQixVQUFTendELEdBQVQsRUFBYzR2RCxJQUFkLEVBQW9CL0UsTUFBcEIsRUFBNEI3bEMsUUFBNUIsRUFBc0M7QUFDbkUsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSW9ILFFBQVEsaUVBQVo7O0FBRUEsT0FBSSxDQUFDcHRELFFBQVFrdEQsSUFBUixDQUFMLEVBQW9CO0FBQ2xCLFdBQU0sSUFBSXpWLEtBQUosQ0FBVTJWLEtBQVYsQ0FBTjtBQUNEOztBQUVELE9BQUlsNkQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPeTBELE1BQVAsS0FBa0IsVUFBaEQsRUFBNEQ7QUFDMUQ3bEMsZ0JBQVc2bEMsTUFBWDtBQUNBQSxjQUFTLElBQVQ7QUFDRDs7QUFFRCxPQUFJNkYsU0FBUztBQUNYWCxVQUFLSDtBQURNLElBQWI7O0FBSUEsT0FBSS9FLE1BQUosRUFBWTtBQUNWNkYsWUFBT1YsUUFBUCxHQUFrQm5GLE9BQU9tRixRQUF6QjtBQUNBVSxZQUFPVCxzQkFBUCxHQUFnQ3BGLE9BQU9vRixzQkFBdkM7QUFDQVMsWUFBT1IsZUFBUCxHQUF5QnJGLE9BQU9xRixlQUFoQztBQUNBUSxZQUFPTixXQUFQLEdBQXFCdkYsT0FBT3VGLFdBQTVCOztBQUVBLFNBQUl2RixPQUFPd0YsZUFBWCxFQUE0QjtBQUMxQkssY0FBT0wsZUFBUCxHQUF5QixLQUFLNEIsRUFBTCxDQUFRL0MsZ0JBQVIsQ0FBeUJyRSxPQUFPd0YsZUFBaEMsRUFBaUQsRUFBakQsQ0FBekI7QUFDRDs7QUFFREssWUFBT0osUUFBUCxHQUFrQnpGLE9BQU95RixRQUF6QjtBQUNEOztBQUVELFVBQU8sS0FBSzJCLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxLQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CLEtBQUs2MkQsU0FBeEIsQ0FBaEIsR0FBcUQsUUFBckQsR0FBZ0V0dUQsR0FGM0M7QUFHMUJzbkMsV0FBTW9wQixNQUhvQjtBQUkxQmxDLGVBQVUsT0FKZ0I7QUFLMUJ4cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBckNELEM7Ozs7Ozs7O0FDbmxDQSxLQUFJLE9BQU9qb0IsT0FBT3FDLE1BQWQsS0FBeUIsVUFBN0IsRUFBeUM7QUFDdkM7QUFDQXhLLFVBQU9DLE9BQVAsR0FBaUIsU0FBU3U1RCxRQUFULENBQWtCdUksSUFBbEIsRUFBd0JDLFNBQXhCLEVBQW1DO0FBQ2xERCxVQUFLRSxNQUFMLEdBQWNELFNBQWQ7QUFDQUQsVUFBS25oRSxTQUFMLEdBQWlCdUgsT0FBT3FDLE1BQVAsQ0FBY3czRCxVQUFVcGhFLFNBQXhCLEVBQW1DO0FBQ2xEc1Isb0JBQWE7QUFDWGhKLGdCQUFPNjRELElBREk7QUFFWDd4RCxxQkFBWSxLQUZEO0FBR1hFLG1CQUFVLElBSEM7QUFJWEMsdUJBQWM7QUFKSDtBQURxQyxNQUFuQyxDQUFqQjtBQVFELElBVkQ7QUFXRCxFQWJELE1BYU87QUFDTDtBQUNBclEsVUFBT0MsT0FBUCxHQUFpQixTQUFTdTVELFFBQVQsQ0FBa0J1SSxJQUFsQixFQUF3QkMsU0FBeEIsRUFBbUM7QUFDbERELFVBQUtFLE1BQUwsR0FBY0QsU0FBZDtBQUNBLFNBQUlFLFdBQVcsU0FBWEEsUUFBVyxHQUFZLENBQUUsQ0FBN0I7QUFDQUEsY0FBU3RoRSxTQUFULEdBQXFCb2hFLFVBQVVwaEUsU0FBL0I7QUFDQW1oRSxVQUFLbmhFLFNBQUwsR0FBaUIsSUFBSXNoRSxRQUFKLEVBQWpCO0FBQ0FILFVBQUtuaEUsU0FBTCxDQUFlc1IsV0FBZixHQUE2QjZ2RCxJQUE3QjtBQUNELElBTkQ7QUFPRCxFOzs7Ozs7Ozs7O0FDdEJELEtBQUlJLG9CQUFvQixtQkFBQXJPLENBQVEsRUFBUixDQUF4QjtBQUNBLEtBQUlySSxZQUFZLG1CQUFBcUksQ0FBUSxFQUFSLENBQWhCO0FBQ0EsS0FBSXdGLG9CQUFvQixtQkFBQXhGLENBQVEsRUFBUixDQUF4Qjs7QUFFQTl6RCxRQUFPQyxPQUFQLEdBQWlCKzhELFNBQWpCOztBQUVBOzs7O0FBSUEsVUFBU0EsU0FBVCxDQUFtQm9GLGFBQW5CLEVBQWtDMUksU0FBbEMsRUFBNkM7QUFDM0MsUUFBS0EsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxRQUFLMkQsRUFBTCxHQUFVK0UsYUFBVjtBQUNBLFFBQUtDLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxRQUFLQyxvQkFBTCxHQUE0QixJQUE1Qjs7QUFFQTtBQUNBLFFBQUsvMkQsS0FBTCxHQUFhLEVBQWI7QUFDRDs7QUFFRDs7O0FBR0F5eEQsV0FBVXA4RCxTQUFWLENBQW9CczFELFVBQXBCLEdBQWlDLFlBQVc7QUFDMUMsUUFBSzNxRCxLQUFMLEdBQWEsRUFBYjtBQUNELEVBRkQ7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0ZBeXhELFdBQVVwOEQsU0FBVixDQUFvQnUxRCxNQUFwQixHQUE2QmdNLGtCQUFrQixPQUFsQixDQUE3Qjs7QUFFQTs7Ozs7Ozs7OztBQVVBbkYsV0FBVXA4RCxTQUFWLENBQW9CMmhFLGFBQXBCLEdBQW9DSixrQkFBa0IsY0FBbEIsQ0FBcEM7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBbkYsV0FBVXA4RCxTQUFWLENBQW9CNGhFLE1BQXBCLEdBQTZCLFVBQVN6OEQsS0FBVCxFQUFnQjAxRCxlQUFoQixFQUFpQ3JyQyxRQUFqQyxFQUEyQztBQUN0RSxPQUFJK3VDLFFBQVEsbUJBQUFyTCxDQUFRLEVBQVIsQ0FBWjs7QUFFQSxPQUFJc0osV0FBVyxJQUFmOztBQUVBLE9BQUk1QyxJQUFKO0FBQ0EsT0FBSWhFLFdBQUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBSXgxRCxVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCUixVQUFVUSxNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU9SLFVBQVUsQ0FBVixDQUFQLEtBQXdCLFVBQWhGLEVBQTRGO0FBQzFGdzVELFlBQU8sQ0FBUDtBQUNBcHFDLGdCQUFXcHZCLFVBQVUsQ0FBVixDQUFYO0FBQ0ErRSxhQUFRNUUsU0FBUjtBQUNELElBSkQsTUFJTyxJQUFJLE9BQU9ILFVBQVUsQ0FBVixDQUFQLEtBQXdCLFFBQTVCLEVBQXNDO0FBQzNDO0FBQ0F3NUQsWUFBT3g1RCxVQUFVLENBQVYsQ0FBUDtBQUNBLFNBQUksT0FBT0EsVUFBVSxDQUFWLENBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDcEN3MUQscUJBQWN4MUQsVUFBVSxDQUFWLENBQWQ7QUFDRCxNQUZELE1BRU8sSUFBSSxPQUFPQSxVQUFVLENBQVYsQ0FBUCxLQUF3QixVQUE1QixFQUF3QztBQUM3Q292QixrQkFBV3B2QixVQUFVLENBQVYsQ0FBWDtBQUNBdzFELHFCQUFjcjFELFNBQWQ7QUFDRDtBQUNENEUsYUFBUTVFLFNBQVI7QUFDQXM2RCx1QkFBa0J0NkQsU0FBbEI7QUFDRCxJQVhNLE1BV0EsSUFBSSxRQUFPSCxVQUFVLENBQVYsQ0FBUCxNQUF3QixRQUE1QixFQUFzQztBQUMzQztBQUNBLFNBQUksT0FBT0EsVUFBVSxDQUFWLENBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDdENvdkIsa0JBQVdwdkIsVUFBVSxDQUFWLENBQVg7QUFDRDtBQUNEeTZELHVCQUFrQno2RCxVQUFVLENBQVYsQ0FBbEI7QUFDQStFLGFBQVE1RSxTQUFSO0FBQ0QsSUFQTSxNQU9BLElBQUksT0FBT0gsVUFBVSxDQUFWLENBQVAsS0FBd0IsUUFBeEIsSUFBb0MsT0FBT0EsVUFBVSxDQUFWLENBQVAsS0FBd0IsVUFBaEUsRUFBNEU7QUFDakY7QUFDQW92QixnQkFBV3B2QixVQUFVLENBQVYsQ0FBWDtBQUNBeTZELHVCQUFrQnQ2RCxTQUFsQjtBQUNEOztBQUVEOztBQUVBO0FBQ0E7QUFDQXM2RCxxQkFBa0IwRCxNQUFNLEVBQU4sRUFBVTFELG1CQUFtQixFQUE3QixFQUFpQztBQUNqRGpCLFdBQU1BLElBRDJDO0FBRWpEaEUsa0JBQWFBLFdBRm9DO0FBR2pEendELFlBQU9BO0FBSDBDLElBQWpDLENBQWxCOztBQU1BLE9BQUlrd0QsU0FBUyxLQUFLb0gsRUFBTCxDQUFRL0MsZ0JBQVIsQ0FBeUJtQixlQUF6QixFQUEwQyxFQUExQyxDQUFiOztBQUVBLFVBQU8sS0FBSzRCLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQWdCL0QsbUJBQW1CdTZELFNBQVMxRCxTQUE1QixDQUFoQixHQUF5RCxTQUZwQztBQUcxQmhuQixXQUFNLEVBQUN1akIsUUFBUUEsTUFBVCxFQUhvQjtBQUkxQjJELGVBQVUsTUFKZ0I7QUFLMUJ4cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBMUREOztBQTREQTs7Ozs7Ozs7Ozs7OztBQWFBNHNDLFdBQVVwOEQsU0FBVixDQUFvQjZoRSxVQUFwQixHQUFpQyxVQUFTbkQsTUFBVCxFQUFpQmx2QyxRQUFqQixFQUEyQjtBQUMxRCxVQUFPLEtBQUtpdEMsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLE1BRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzYyRCxTQUF4QixDQUFoQixHQUFxRCxTQUZoQztBQUcxQmhuQixXQUFNLEVBQUM0c0IsUUFBUUEsTUFBVCxFQUhvQjtBQUkxQjFGLGVBQVUsTUFKZ0I7QUFLMUJ4cEMsZUFBVUE7QUFMZ0IsSUFBckIsQ0FBUDtBQU9ELEVBUkQ7O0FBVUE7Ozs7Ozs7Ozs7OztBQVlBNHNDLFdBQVVwOEQsU0FBVixDQUFvQjhoRSxvQkFBcEIsR0FBMkMsVUFBU3pNLE1BQVQsRUFBaUI3bEMsUUFBakIsRUFBMkI7QUFDcEUsT0FBSWdqQixRQUFRLG1CQUFBMGdCLENBQVEsRUFBUixDQUFaO0FBQ0EsT0FBSTZPLE9BQU8sbUJBQUE3TyxDQUFRLEVBQVIsQ0FBWDtBQUNBLE9BQUlvSCxRQUFRLG1GQUFaOztBQUVBLE9BQUlqRixPQUFPMk0sU0FBUCxLQUFxQnpoRSxTQUFyQixJQUFrQzgwRCxPQUFPNE0sVUFBUCxLQUFzQjFoRSxTQUE1RCxFQUF1RTtBQUNyRSxXQUFNLElBQUlva0QsS0FBSixDQUFVMlYsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsT0FBSTBILFlBQVkzTSxPQUFPMk0sU0FBdkI7QUFDQSxPQUFJRSxpQkFBaUJILEtBQUt2dkIsTUFBTTZpQixNQUFOLENBQUwsRUFBb0IsVUFBUzhNLE9BQVQsRUFBa0I7QUFDekQsWUFBT0EsWUFBWSxXQUFuQjtBQUNELElBRm9CLENBQXJCO0FBR0EsT0FBSUMsbUJBQW1CLEtBQUszRixFQUFMLENBQVEvQyxnQkFBUixDQUF5QndJLGNBQXpCLEVBQXlDLEVBQXpDLENBQXZCOztBQUVBLFVBQU8sS0FBS3pGLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsYUFBUSxNQURrQjtBQUUxQm1HLFVBQUssZ0JBQ0gvRCxtQkFBbUIsS0FBSzYyRCxTQUF4QixDQURHLEdBQ2tDLFVBRGxDLEdBQytDNzJELG1CQUFtQisvRCxTQUFuQixDQUQvQyxHQUMrRSxRQUgxRDtBQUkxQmhKLGVBQVUsTUFKZ0I7QUFLMUJsbkIsV0FBTSxFQUFDdWpCLFFBQVErTSxnQkFBVCxFQUxvQjtBQU0xQjV5QyxlQUFVQTtBQU5nQixJQUFyQixDQUFQO0FBUUQsRUF2QkQ7O0FBeUJBNHNDLFdBQVVwOEQsU0FBVixDQUFvQnFpRSxXQUFwQixHQUFrQ3hYLFVBQVUsVUFBU3dLLE1BQVQsRUFBaUI3bEMsUUFBakIsRUFBMkI7QUFDckUsVUFBTyxLQUFLc3lDLG9CQUFMLENBQTBCek0sTUFBMUIsRUFBa0M3bEMsUUFBbEMsQ0FBUDtBQUNELEVBRmlDLEVBRS9Ca3BDLGtCQUNELHVDQURDLEVBRUQsZ0RBRkMsQ0FGK0IsQ0FBbEM7O0FBT0EwRCxXQUFVcDhELFNBQVYsQ0FBb0JzaUUsT0FBcEIsR0FBOEIsVUFBU2pOLE1BQVQsRUFBaUJydkQsR0FBakIsRUFBc0J3cEIsUUFBdEIsRUFBZ0MreUMsWUFBaEMsRUFBOEM7QUFDMUUsVUFBTyxLQUFLOUYsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQnB1RCxZQUFPLEtBQUtBLEtBRGM7QUFFMUI5SyxhQUFRLE1BRmtCO0FBRzFCbUcsVUFBS0EsT0FBTyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzYyRCxTQUF4QixDQUFoQixHQUFxRCxRQUh2QztBQUkxQmhuQixXQUFNLEVBQUN1akIsUUFBUUEsTUFBVCxFQUpvQjtBQUsxQjJELGVBQVUsTUFMZ0I7QUFNMUI5b0MsZUFBVTtBQUNScndCLGVBQVEsS0FEQTtBQUVSbUcsWUFBSyxnQkFBZ0IvRCxtQkFBbUIsS0FBSzYyRCxTQUF4QixDQUZiO0FBR1JobkIsYUFBTSxFQUFDdWpCLFFBQVFBLE1BQVQ7QUFIRSxNQU5nQjtBQVcxQjdsQyxlQUFVQSxRQVhnQjtBQVkxQit5QyxtQkFBY0E7QUFaWSxJQUFyQixDQUFQO0FBY0QsRUFmRDs7QUFpQkE7Ozs7Ozs7OztBQVNBbkcsV0FBVXA4RCxTQUFWLENBQW9CbTJELFNBQXBCLEdBQWdDLFVBQVNELFFBQVQsRUFBbUJsMUMsS0FBbkIsRUFBMEJ3TyxRQUExQixFQUFvQztBQUNsRSxPQUFJZ3RDLFdBQVcsSUFBZjs7QUFFQSxPQUFJcDhELFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBT29nQixLQUFQLEtBQWlCLFVBQS9DLEVBQTJEO0FBQ3pEd08sZ0JBQVd4TyxLQUFYO0FBQ0FBLGFBQVF6Z0IsU0FBUjtBQUNEOztBQUVELE9BQUk4MEQsU0FBUyxFQUFiO0FBQ0EsT0FBSXIwQyxVQUFVemdCLFNBQWQsRUFBeUI7QUFDdkI4MEQsY0FBUyxjQUFUO0FBQ0EsVUFBSyxJQUFJMTBELElBQUksQ0FBYixFQUFnQkEsSUFBSXFnQixNQUFNcGdCLE1BQTFCLEVBQWtDLEVBQUVELENBQXBDLEVBQXVDO0FBQ3JDLFdBQUlBLE1BQU0sQ0FBVixFQUFhO0FBQ1gwMEQsbUJBQVUsR0FBVjtBQUNEO0FBQ0RBLGlCQUFVcjBDLE1BQU1yZ0IsQ0FBTixDQUFWO0FBQ0Q7QUFDRjs7QUFFRCxVQUFPLEtBQUs4N0QsRUFBTCxDQUFRMUQsWUFBUixDQUFxQjtBQUMxQmw1RCxhQUFRLEtBRGtCO0FBRTFCbUcsVUFBSyxnQkFBZ0IvRCxtQkFBbUJ1NkQsU0FBUzFELFNBQTVCLENBQWhCLEdBQXlELEdBQXpELEdBQStENzJELG1CQUFtQmkwRCxRQUFuQixDQUEvRCxHQUE4RmIsTUFGekU7QUFHMUIyRCxlQUFVLE1BSGdCO0FBSTFCeHBDLGVBQVVBO0FBSmdCLElBQXJCLENBQVA7QUFNRCxFQXpCRDs7QUEyQkE7Ozs7O0FBS0E0c0MsV0FBVXA4RCxTQUFWLENBQW9Cd2lFLFVBQXBCLEdBQWlDLFVBQVNuRixTQUFULEVBQW9CSSxvQkFBcEIsRUFBMENqdUMsUUFBMUMsRUFBb0Q7QUFDbkYsT0FBSXRpQixVQUFVLG1CQUFBZ21ELENBQVEsRUFBUixDQUFkO0FBQ0EsT0FBSXZwRCxNQUFNLG1CQUFBdXBELENBQVEsRUFBUixDQUFWOztBQUVBLE9BQUlvSCxRQUFRLHVEQUFaOztBQUVBLE9BQUksQ0FBQ3B0RCxRQUFRbXdELFNBQVIsQ0FBTCxFQUF5QjtBQUN2QixXQUFNLElBQUkxWSxLQUFKLENBQVUyVixLQUFWLENBQU47QUFDRDs7QUFFRCxPQUFJa0MsV0FBVyxJQUFmOztBQUVBLE9BQUlwOEQsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPNjhELG9CQUFQLEtBQWdDLFVBQTlELEVBQTBFO0FBQ3hFanVDLGdCQUFXaXVDLG9CQUFYO0FBQ0FBLDRCQUF1Qmw5RCxTQUF2QjtBQUNEOztBQUVELE9BQUl1eEMsT0FBTztBQUNUOHBCLGVBQVVqeUQsSUFBSTB6RCxTQUFKLEVBQWUsU0FBU0MsY0FBVCxDQUF3QnBILFFBQXhCLEVBQWtDO0FBQ3pELFdBQUlyd0QsVUFBVTtBQUNaaXpELG9CQUFXMEQsU0FBUzFELFNBRFI7QUFFWjVDLG1CQUFVQTtBQUZFLFFBQWQ7O0FBS0EsV0FBSXVILG9CQUFKLEVBQTBCO0FBQ3hCNTNELGlCQUFRNDNELG9CQUFSLEdBQStCQSxxQkFBcUI1d0QsSUFBckIsQ0FBMEIsR0FBMUIsQ0FBL0I7QUFDRDs7QUFFRCxjQUFPaEgsT0FBUDtBQUNELE1BWFM7QUFERCxJQUFYOztBQWVBLFVBQU8sS0FBSzQyRCxFQUFMLENBQVExRCxZQUFSLENBQXFCO0FBQzFCbDVELGFBQVEsTUFEa0I7QUFFMUJtRyxVQUFLLHNCQUZxQjtBQUcxQmd6RCxlQUFVLE1BSGdCO0FBSTFCbG5CLFdBQU1BLElBSm9CO0FBSzFCdGlCLGVBQVVBO0FBTGdCLElBQXJCLENBQVA7QUFPRCxFQXZDRDs7QUF5Q0E0c0MsV0FBVXA4RCxTQUFWLENBQW9CeThELEVBQXBCLEdBQXlCLElBQXpCO0FBQ0FMLFdBQVVwOEQsU0FBVixDQUFvQjg0RCxTQUFwQixHQUFnQyxJQUFoQztBQUNBc0QsV0FBVXA4RCxTQUFWLENBQW9CeWhFLGFBQXBCLEdBQW9DLElBQXBDO0FBQ0FyRixXQUFVcDhELFNBQVYsQ0FBb0IwaEUsb0JBQXBCLEdBQTJDLElBQTNDLEM7Ozs7Ozs7Ozs7QUM5WEF0aUUsUUFBT0MsT0FBUCxHQUFpQmtpRSxpQkFBakI7O0FBRUEsS0FBSTFlLFNBQVMsbUJBQUFxUSxDQUFRLEVBQVIsQ0FBYjs7QUFFQTs7Ozs7O0FBTUEsVUFBU3FPLGlCQUFULENBQTJCa0IsVUFBM0IsRUFBdUN6OEQsR0FBdkMsRUFBNEM7QUFDMUM7Ozs7Ozs7QUFPQSxVQUFPLFNBQVN1dkQsTUFBVCxDQUFnQnB3RCxLQUFoQixFQUF1QmlSLElBQXZCLEVBQTZCb1osUUFBN0IsRUFBdUM7QUFDNUM7QUFDQSxTQUFJLE9BQU9ycUIsS0FBUCxLQUFpQixVQUFqQixJQUErQixRQUFPaVIsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUEvQyxJQUNGLFFBQU9vWixRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBRHRCLEVBQ2dDO0FBQzlCO0FBQ0E7QUFDQSxhQUFNLElBQUlxekIsT0FBT3NaLGtCQUFYLENBQThCLHVEQUE5QixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFJLzdELFVBQVVRLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsT0FBT3VFLEtBQVAsS0FBaUIsVUFBL0MsRUFBMkQ7QUFDekQ7QUFDQXFxQixrQkFBV3JxQixLQUFYO0FBQ0FBLGVBQVEsRUFBUjtBQUNELE1BSkQsTUFJTyxJQUFJL0UsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixPQUFPd1YsSUFBUCxLQUFnQixVQUE5QyxFQUEwRDtBQUMvRDtBQUNBb1osa0JBQVdwWixJQUFYO0FBQ0FBLGNBQU83VixTQUFQO0FBQ0Q7QUFDRDs7QUFFQTtBQUNBLFNBQUksUUFBTzRFLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBakIsSUFBNkJBLFVBQVUsSUFBM0MsRUFBaUQ7QUFDL0NpUixjQUFPalIsS0FBUDtBQUNBQSxlQUFRNUUsU0FBUjtBQUNELE1BSEQsTUFHTyxJQUFJNEUsVUFBVTVFLFNBQVYsSUFBdUI0RSxVQUFVLElBQXJDLEVBQTJDO0FBQUU7QUFDbERBLGVBQVEsRUFBUjtBQUNEOztBQUVELFNBQUlrd0QsU0FBUyxFQUFiOztBQUVBLFNBQUlsd0QsVUFBVTVFLFNBQWQsRUFBeUI7QUFDdkI4MEQsaUJBQVVvTixhQUFhLEdBQWIsR0FBbUJ4Z0UsbUJBQW1Ca0QsS0FBbkIsQ0FBN0I7QUFDRDs7QUFFRCxTQUFJbzlELFlBQUo7QUFDQSxTQUFJbnNELFNBQVM3VixTQUFiLEVBQXdCO0FBQ3RCLFdBQUk2VixLQUFLbXNELFlBQVQsRUFBdUI7QUFDckJBLHdCQUFlbnNELEtBQUttc0QsWUFBcEI7QUFDQSxnQkFBT25zRCxLQUFLbXNELFlBQVo7QUFDRDtBQUNEO0FBQ0FsTixnQkFBUyxLQUFLb0gsRUFBTCxDQUFRL0MsZ0JBQVIsQ0FBeUJ0akQsSUFBekIsRUFBK0JpL0MsTUFBL0IsQ0FBVDtBQUNEOztBQUdELFlBQU8sS0FBS2lOLE9BQUwsQ0FBYWpOLE1BQWIsRUFBcUJydkQsR0FBckIsRUFBMEJ3cEIsUUFBMUIsRUFBb0MreUMsWUFBcEMsQ0FBUDtBQUNELElBL0NEO0FBZ0RELEU7Ozs7OztBQ2xFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTNKLFdBQVcsbUJBQUExRixDQUFRLEVBQVIsQ0FBZjs7QUFFQSxVQUFTaUosa0JBQVQsQ0FBNEJoUSxPQUE1QixFQUFxQ3VXLGVBQXJDLEVBQXNEO0FBQ3BELE9BQUlqN0QsVUFBVSxtQkFBQXlyRCxDQUFRLEVBQVIsQ0FBZDs7QUFFQSxPQUFJenNELFFBQVEsSUFBWjs7QUFFQTtBQUNBLE9BQUksT0FBT2srQyxNQUFNZ2UsaUJBQWIsS0FBbUMsVUFBdkMsRUFBbUQ7QUFDakRoZSxXQUFNZ2UsaUJBQU4sQ0FBd0IsSUFBeEIsRUFBOEIsS0FBS3J4RCxXQUFuQztBQUNELElBRkQsTUFFTztBQUNMN0ssV0FBTWt3QyxLQUFOLEdBQWUsSUFBSWdPLEtBQUosRUFBRCxDQUFjaE8sS0FBZCxJQUF1Qiw2Q0FBckM7QUFDRDs7QUFFRCxRQUFLejFDLElBQUwsR0FBWSxvQkFBWjtBQUNBLFFBQUtpckQsT0FBTCxHQUFlQSxXQUFXLGVBQTFCOztBQUVBLE9BQUl1VyxlQUFKLEVBQXFCO0FBQ25CajdELGFBQVFpN0QsZUFBUixFQUF5QixTQUFTRSxnQkFBVCxDQUEwQnQ2RCxLQUExQixFQUFpQ2tDLEdBQWpDLEVBQXNDO0FBQzdEL0QsYUFBTStELEdBQU4sSUFBYWxDLEtBQWI7QUFDRCxNQUZEO0FBR0Q7QUFDRjs7QUFFRHN3RCxVQUFTdUQsa0JBQVQsRUFBNkJ4WCxLQUE3Qjs7QUFFQSxVQUFTa2UsaUJBQVQsQ0FBMkIzaEUsSUFBM0IsRUFBaUNpckQsT0FBakMsRUFBMEM7QUFDeEMsWUFBUzJXLHdCQUFULEdBQW9DO0FBQ2xDLFNBQUkxc0QsT0FBT3JLLE1BQU0vTCxTQUFOLENBQWdCdUMsS0FBaEIsQ0FBc0J0QyxJQUF0QixDQUEyQkcsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWDs7QUFFQTtBQUNBLFNBQUksT0FBT2dXLEtBQUssQ0FBTCxDQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CQSxZQUFLa2UsT0FBTCxDQUFhNjNCLE9BQWI7QUFDRDs7QUFFRGdRLHdCQUFtQmg4RCxLQUFuQixDQUF5QixJQUF6QixFQUErQmlXLElBQS9CO0FBQ0EsVUFBS2xWLElBQUwsR0FBWSxrQkFBa0JBLElBQWxCLEdBQXlCLE9BQXJDO0FBQ0Q7O0FBRUQwM0QsWUFBU2tLLHdCQUFULEVBQW1DM0csa0JBQW5DOztBQUVBLFVBQU8yRyx3QkFBUDtBQUNEOztBQUVEO0FBQ0ExakUsUUFBT0MsT0FBUCxHQUFpQjtBQUNmODhELHVCQUFvQkEsa0JBREw7QUFFZjRHLG1CQUFnQkYsa0JBQ2QsZ0JBRGMsRUFFZCx5RUFGYyxDQUZEO0FBTWZHLG1CQUFnQkgsa0JBQ2QsZ0JBRGMsRUFFZCw0Q0FGYyxDQU5EO0FBVWZJLFlBQVNKLGtCQUNQLFNBRE8sRUFFUCx5Q0FGTyxDQVZNO0FBY2ZLLG9CQUFpQkwsa0JBQ2YsaUJBRGUsRUFFZiw0REFGZSxDQWRGO0FBa0JmTSxxQkFBa0JOLGtCQUNoQixrQkFEZ0IsRUFFaEIsdURBRmdCLENBbEJIO0FBc0JmTyxZQUFTUCxrQkFDUCxTQURPLEVBRVAsdUJBRk87QUF0Qk0sRUFBakIsQzs7Ozs7Ozs7QUNsREEsS0FBSXQ0RCxTQUFTaEQsT0FBT3ZILFNBQVAsQ0FBaUJzSyxjQUE5QjtBQUNBLEtBQUk3QixXQUFXbEIsT0FBT3ZILFNBQVAsQ0FBaUJ5SSxRQUFoQzs7QUFFQXJKLFFBQU9DLE9BQVAsR0FBaUIsU0FBU29JLE9BQVQsQ0FBa0I5SCxHQUFsQixFQUF1QitLLEVBQXZCLEVBQTJCYSxHQUEzQixFQUFnQztBQUM3QyxTQUFJOUMsU0FBU3hJLElBQVQsQ0FBY3lLLEVBQWQsTUFBc0IsbUJBQTFCLEVBQStDO0FBQzNDLGVBQU0sSUFBSXJILFNBQUosQ0FBYyw2QkFBZCxDQUFOO0FBQ0g7QUFDRCxTQUFJcUksSUFBSS9MLElBQUlpQixNQUFaO0FBQ0EsU0FBSThLLE1BQU0sQ0FBQ0EsQ0FBWCxFQUFjO0FBQ1YsY0FBSyxJQUFJL0ssSUFBSSxDQUFiLEVBQWdCQSxJQUFJK0ssQ0FBcEIsRUFBdUIvSyxHQUF2QixFQUE0QjtBQUN4QitKLGdCQUFHekssSUFBSCxDQUFRc0wsR0FBUixFQUFhNUwsSUFBSWdCLENBQUosQ0FBYixFQUFxQkEsQ0FBckIsRUFBd0JoQixHQUF4QjtBQUNIO0FBQ0osTUFKRCxNQUlPO0FBQ0gsY0FBSyxJQUFJMGpFLENBQVQsSUFBYzFqRSxHQUFkLEVBQW1CO0FBQ2YsaUJBQUk0SyxPQUFPdEssSUFBUCxDQUFZTixHQUFaLEVBQWlCMGpFLENBQWpCLENBQUosRUFBeUI7QUFDckIzNEQsb0JBQUd6SyxJQUFILENBQVFzTCxHQUFSLEVBQWE1TCxJQUFJMGpFLENBQUosQ0FBYixFQUFxQkEsQ0FBckIsRUFBd0IxakUsR0FBeEI7QUFDSDtBQUNKO0FBQ0o7QUFDSixFQWhCRCxDOzs7Ozs7OztBQ0pBUCxRQUFPQyxPQUFQLEdBQWlCLFNBQVN3ckQsU0FBVCxDQUFtQm5nRCxFQUFuQixFQUF1QnloRCxPQUF2QixFQUFnQztBQUMvQyxPQUFJMVMsU0FBUyxLQUFiOztBQUVBLFlBQVM2cEIsVUFBVCxHQUFzQjtBQUNwQixTQUFJLENBQUM3cEIsTUFBTCxFQUFhO0FBQ1g7QUFDQW41QyxlQUFReVAsSUFBUixDQUFhbzhDLE9BQWI7QUFDQTFTLGdCQUFTLElBQVQ7QUFDRDs7QUFFRCxZQUFPL3VDLEdBQUd2SyxLQUFILENBQVMsSUFBVCxFQUFlQyxTQUFmLENBQVA7QUFDRDs7QUFFRCxVQUFPa2pFLFVBQVA7QUFDRCxFQWRELEM7Ozs7Ozs7O0FDQUFsa0UsUUFBT0MsT0FBUCxHQUFpQixTQUFTcTVELGlCQUFULENBQTJCNkssYUFBM0IsRUFBMENDLFFBQTFDLEVBQW9EO0FBQ25FLE9BQUlDLG1CQUFtQkYsY0FBY3g1RCxXQUFkLEdBQ3BCaUIsT0FEb0IsQ0FDWixXQURZLEVBQ0MsRUFERCxDQUF2Qjs7QUFHQSxVQUFPLHFCQUFxQnU0RCxhQUFyQixHQUFxQyxxQkFBckMsR0FBNkRDLFFBQTdELEdBQ0wsMkZBREssR0FDeUZDLGdCQURoRztBQUVELEVBTkQsQzs7Ozs7Ozs7OztBQ0FBLEtBQUlDLFVBQVUsbUJBQUF4USxDQUFRLEVBQVIsQ0FBZDs7QUFFQTl6RCxRQUFPQyxPQUFQLEdBQWlCLFNBQVNrL0QsS0FBVCxDQUFlakYsV0FBZixDQUEwQixlQUExQixFQUEyQztBQUMxRCxPQUFJcUssVUFBVTUzRCxNQUFNL0wsU0FBTixDQUFnQnVDLEtBQWhCLENBQXNCdEMsSUFBdEIsQ0FBMkJHLFNBQTNCLENBQWQ7O0FBRUFzakUsV0FBUUMsT0FBUixFQUFpQixVQUFTMTJDLE1BQVQsRUFBaUI7QUFDaEMsVUFBSyxJQUFJazFDLE9BQVQsSUFBb0JsMUMsTUFBcEIsRUFBNEI7QUFDMUIsV0FBSUEsT0FBTzNpQixjQUFQLENBQXNCNjNELE9BQXRCLENBQUosRUFBb0M7QUFDbEMsYUFBSSxRQUFPN0ksWUFBWTZJLE9BQVosQ0FBUCxNQUFnQyxRQUFoQyxJQUE0QyxRQUFPbDFDLE9BQU9rMUMsT0FBUCxDQUFQLE1BQTJCLFFBQTNFLEVBQXFGO0FBQ25GN0ksdUJBQVk2SSxPQUFaLElBQXVCNUQsTUFBTSxFQUFOLEVBQVVqRixZQUFZNkksT0FBWixDQUFWLEVBQWdDbDFDLE9BQU9rMUMsT0FBUCxDQUFoQyxDQUF2QjtBQUNELFVBRkQsTUFFTyxJQUFJbDFDLE9BQU9rMUMsT0FBUCxNQUFvQjVoRSxTQUF4QixFQUFtQztBQUN4Qys0RCx1QkFBWTZJLE9BQVosSUFBdUJsMUMsT0FBT2sxQyxPQUFQLENBQXZCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsSUFWRDs7QUFZQSxVQUFPN0ksV0FBUDtBQUNELEVBaEJELEM7Ozs7Ozs7O0FDRkFsNkQsUUFBT0MsT0FBUCxHQUFpQixTQUFTbXpDLEtBQVQsQ0FBZTd5QyxHQUFmLEVBQW9CO0FBQ25DLFVBQU93SixLQUFLa3dDLEtBQUwsQ0FBV2x3QyxLQUFLQyxTQUFMLENBQWV6SixHQUFmLENBQVgsQ0FBUDtBQUNELEVBRkQsQzs7Ozs7Ozs7QUNBQVAsUUFBT0MsT0FBUCxHQUFpQixTQUFTMGlFLElBQVQsQ0FBY3BpRSxHQUFkLEVBQW1Ca1EsSUFBbkIsRUFBeUI7QUFDeEMsT0FBSXJJLE9BQU8sbUJBQUEwckQsQ0FBUSxFQUFSLENBQVg7QUFDQSxPQUFJd1EsVUFBVSxtQkFBQXhRLENBQVEsRUFBUixDQUFkOztBQUVBLE9BQUkwUSxXQUFXLEVBQWY7O0FBRUFGLFdBQVFsOEQsS0FBSzdILEdBQUwsQ0FBUixFQUFtQixTQUFTa2tFLFFBQVQsQ0FBa0IxQixPQUFsQixFQUEyQjtBQUM1QyxTQUFJdHlELEtBQUtzeUQsT0FBTCxNQUFrQixJQUF0QixFQUE0QjtBQUMxQnlCLGdCQUFTekIsT0FBVCxJQUFvQnhpRSxJQUFJd2lFLE9BQUosQ0FBcEI7QUFDRDtBQUNGLElBSkQ7O0FBTUEsVUFBT3lCLFFBQVA7QUFDRCxFQWJELEM7Ozs7OztBQ0FBOztBQUVBOzs7O0FBQ0EsS0FBSS91RCxNQUFNdE4sT0FBT3ZILFNBQVAsQ0FBaUJzSyxjQUEzQjtBQUNBLEtBQUl3NUQsUUFBUXY4RCxPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQTdCO0FBQ0EsS0FBSWxHLFFBQVF3SixNQUFNL0wsU0FBTixDQUFnQnVDLEtBQTVCO0FBQ0EsS0FBSXdoRSxTQUFTLG1CQUFBN1EsQ0FBUSxFQUFSLENBQWI7QUFDQSxLQUFJOFEsZUFBZXo4RCxPQUFPdkgsU0FBUCxDQUFpQmlrRSxvQkFBcEM7QUFDQSxLQUFJQyxpQkFBaUIsQ0FBQ0YsYUFBYS9qRSxJQUFiLENBQWtCLEVBQUV3SSxVQUFVLElBQVosRUFBbEIsRUFBc0MsVUFBdEMsQ0FBdEI7QUFDQSxLQUFJMDdELGtCQUFrQkgsYUFBYS9qRSxJQUFiLENBQWtCLFlBQVksQ0FBRSxDQUFoQyxFQUFrQyxXQUFsQyxDQUF0QjtBQUNBLEtBQUlta0UsWUFBWSxDQUNmLFVBRGUsRUFFZixnQkFGZSxFQUdmLFNBSGUsRUFJZixnQkFKZSxFQUtmLGVBTGUsRUFNZixzQkFOZSxFQU9mLGFBUGUsQ0FBaEI7QUFTQSxLQUFJQyw2QkFBNkIsU0FBN0JBLDBCQUE2QixDQUFVbjFCLENBQVYsRUFBYTtBQUM3QyxNQUFJaXlCLE9BQU9qeUIsRUFBRTU5QixXQUFiO0FBQ0EsU0FBTzZ2RCxRQUFRQSxLQUFLbmhFLFNBQUwsS0FBbUJrdkMsQ0FBbEM7QUFDQSxFQUhEO0FBSUEsS0FBSW8xQixlQUFlO0FBQ2xCQyxZQUFVLElBRFE7QUFFbEJDLGFBQVcsSUFGTztBQUdsQkMsVUFBUSxJQUhVO0FBSWxCQyxpQkFBZSxJQUpHO0FBS2xCQyxXQUFTLElBTFM7QUFNbEJDLGdCQUFjLElBTkk7QUFPbEJDLGVBQWEsSUFQSztBQVFsQkMsZ0JBQWMsSUFSSTtBQVNsQkMsZUFBYSxJQVRLO0FBVWxCQyxnQkFBYyxJQVZJO0FBV2xCQyxnQkFBYyxJQVhJO0FBWWxCL3pELFdBQVMsSUFaUztBQWFsQmcwRCxlQUFhLElBYks7QUFjbEJDLGNBQVksSUFkTTtBQWVsQkMsWUFBVSxJQWZRO0FBZ0JsQkMsWUFBVSxJQWhCUTtBQWlCbEJDLFNBQU8sSUFqQlc7QUFrQmxCQyxvQkFBa0IsSUFsQkE7QUFtQmxCQyxzQkFBb0IsSUFuQkY7QUFvQmxCQyxXQUFTO0FBcEJTLEVBQW5CO0FBc0JBLEtBQUlDLDJCQUE0QixZQUFZO0FBQzNDO0FBQ0EsTUFBSSxPQUFPOWpFLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFBRSxVQUFPLEtBQVA7QUFBZTtBQUNwRCxPQUFLLElBQUl5aEUsQ0FBVCxJQUFjemhFLE1BQWQsRUFBc0I7QUFDckIsT0FBSTtBQUNILFFBQUksQ0FBQzBpRSxhQUFhLE1BQU1qQixDQUFuQixDQUFELElBQTBCeHVELElBQUk1VSxJQUFKLENBQVMyQixNQUFULEVBQWlCeWhFLENBQWpCLENBQTFCLElBQWlEemhFLE9BQU95aEUsQ0FBUCxNQUFjLElBQS9ELElBQXVFLFFBQU96aEUsT0FBT3loRSxDQUFQLENBQVAsTUFBcUIsUUFBaEcsRUFBMEc7QUFDekcsU0FBSTtBQUNIZ0IsaUNBQTJCemlFLE9BQU95aEUsQ0FBUCxDQUEzQjtBQUNBLE1BRkQsQ0FFRSxPQUFPbmpFLENBQVAsRUFBVTtBQUNYLGFBQU8sSUFBUDtBQUNBO0FBQ0Q7QUFDRCxJQVJELENBUUUsT0FBT0EsQ0FBUCxFQUFVO0FBQ1gsV0FBTyxJQUFQO0FBQ0E7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNBLEVBakIrQixFQUFoQztBQWtCQSxLQUFJeWxFLHVDQUF1QyxTQUF2Q0Esb0NBQXVDLENBQVV6MkIsQ0FBVixFQUFhO0FBQ3ZEO0FBQ0EsTUFBSSxPQUFPdHRDLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsQ0FBQzhqRSx3QkFBdEMsRUFBZ0U7QUFDL0QsVUFBT3JCLDJCQUEyQm4xQixDQUEzQixDQUFQO0FBQ0E7QUFDRCxNQUFJO0FBQ0gsVUFBT20xQiwyQkFBMkJuMUIsQ0FBM0IsQ0FBUDtBQUNBLEdBRkQsQ0FFRSxPQUFPaHZDLENBQVAsRUFBVTtBQUNYLFVBQU8sS0FBUDtBQUNBO0FBQ0QsRUFWRDs7QUFZQSxLQUFJMGxFLFdBQVcsU0FBU3ArRCxJQUFULENBQWN3aEQsTUFBZCxFQUFzQjtBQUNwQyxNQUFJemdELFdBQVd5Z0QsV0FBVyxJQUFYLElBQW1CLFFBQU9BLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBcEQ7QUFDQSxNQUFJNmMsYUFBYS9CLE1BQU03akUsSUFBTixDQUFXK29ELE1BQVgsTUFBdUIsbUJBQXhDO0FBQ0EsTUFBSThjLGNBQWMvQixPQUFPL2EsTUFBUCxDQUFsQjtBQUNBLE1BQUkrYyxXQUFXeDlELFlBQVl1N0QsTUFBTTdqRSxJQUFOLENBQVcrb0QsTUFBWCxNQUF1QixpQkFBbEQ7QUFDQSxNQUFJZ2QsVUFBVSxFQUFkOztBQUVBLE1BQUksQ0FBQ3o5RCxRQUFELElBQWEsQ0FBQ3M5RCxVQUFkLElBQTRCLENBQUNDLFdBQWpDLEVBQThDO0FBQzdDLFNBQU0sSUFBSXppRSxTQUFKLENBQWMsb0NBQWQsQ0FBTjtBQUNBOztBQUVELE1BQUk0aUUsWUFBWTlCLG1CQUFtQjBCLFVBQW5DO0FBQ0EsTUFBSUUsWUFBWS9jLE9BQU9wb0QsTUFBUCxHQUFnQixDQUE1QixJQUFpQyxDQUFDaVUsSUFBSTVVLElBQUosQ0FBUytvRCxNQUFULEVBQWlCLENBQWpCLENBQXRDLEVBQTJEO0FBQzFELFFBQUssSUFBSXJvRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlxb0QsT0FBT3BvRCxNQUEzQixFQUFtQyxFQUFFRCxDQUFyQyxFQUF3QztBQUN2Q3FsRSxZQUFRejBELElBQVIsQ0FBYWxJLE9BQU8xSSxDQUFQLENBQWI7QUFDQTtBQUNEOztBQUVELE1BQUltbEUsZUFBZTljLE9BQU9wb0QsTUFBUCxHQUFnQixDQUFuQyxFQUFzQztBQUNyQyxRQUFLLElBQUltbkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaWhDLE9BQU9wb0QsTUFBM0IsRUFBbUMsRUFBRW1uQixDQUFyQyxFQUF3QztBQUN2Q2krQyxZQUFRejBELElBQVIsQ0FBYWxJLE9BQU8wZSxDQUFQLENBQWI7QUFDQTtBQUNELEdBSkQsTUFJTztBQUNOLFFBQUssSUFBSTdtQixJQUFULElBQWlCOG5ELE1BQWpCLEVBQXlCO0FBQ3hCLFFBQUksRUFBRWlkLGFBQWEva0UsU0FBUyxXQUF4QixLQUF3QzJULElBQUk1VSxJQUFKLENBQVMrb0QsTUFBVCxFQUFpQjluRCxJQUFqQixDQUE1QyxFQUFvRTtBQUNuRThrRSxhQUFRejBELElBQVIsQ0FBYWxJLE9BQU9uSSxJQUFQLENBQWI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsTUFBSWdqRSxjQUFKLEVBQW9CO0FBQ25CLE9BQUlnQyxrQkFBa0JQLHFDQUFxQzNjLE1BQXJDLENBQXRCOztBQUVBLFFBQUssSUFBSXFhLElBQUksQ0FBYixFQUFnQkEsSUFBSWUsVUFBVXhqRSxNQUE5QixFQUFzQyxFQUFFeWlFLENBQXhDLEVBQTJDO0FBQzFDLFFBQUksRUFBRTZDLG1CQUFtQjlCLFVBQVVmLENBQVYsTUFBaUIsYUFBdEMsS0FBd0R4dUQsSUFBSTVVLElBQUosQ0FBUytvRCxNQUFULEVBQWlCb2IsVUFBVWYsQ0FBVixDQUFqQixDQUE1RCxFQUE0RjtBQUMzRjJDLGFBQVF6MEQsSUFBUixDQUFhNnlELFVBQVVmLENBQVYsQ0FBYjtBQUNBO0FBQ0Q7QUFDRDtBQUNELFNBQU8yQyxPQUFQO0FBQ0EsRUF4Q0Q7O0FBMENBSixVQUFTTyxJQUFULEdBQWdCLFNBQVNDLGNBQVQsR0FBMEI7QUFDekMsTUFBSTcrRCxPQUFPQyxJQUFYLEVBQWlCO0FBQ2hCLE9BQUk2K0QseUJBQTBCLFlBQVk7QUFDekM7QUFDQSxXQUFPLENBQUM5K0QsT0FBT0MsSUFBUCxDQUFZcEgsU0FBWixLQUEwQixFQUEzQixFQUErQlEsTUFBL0IsS0FBMEMsQ0FBakQ7QUFDQSxJQUg2QixDQUc1QixDQUg0QixFQUd6QixDQUh5QixDQUE5QjtBQUlBLE9BQUksQ0FBQ3lsRSxzQkFBTCxFQUE2QjtBQUM1QixRQUFJQyxlQUFlLytELE9BQU9DLElBQTFCO0FBQ0FELFdBQU9DLElBQVAsR0FBYyxTQUFTQSxJQUFULENBQWN3aEQsTUFBZCxFQUFzQjtBQUNuQyxTQUFJK2EsT0FBTy9hLE1BQVAsQ0FBSixFQUFvQjtBQUNuQixhQUFPc2QsYUFBYS9qRSxNQUFNdEMsSUFBTixDQUFXK29ELE1BQVgsQ0FBYixDQUFQO0FBQ0EsTUFGRCxNQUVPO0FBQ04sYUFBT3NkLGFBQWF0ZCxNQUFiLENBQVA7QUFDQTtBQUNELEtBTkQ7QUFPQTtBQUNELEdBZkQsTUFlTztBQUNOemhELFVBQU9DLElBQVAsR0FBY28rRCxRQUFkO0FBQ0E7QUFDRCxTQUFPcitELE9BQU9DLElBQVAsSUFBZW8rRCxRQUF0QjtBQUNBLEVBcEJEOztBQXNCQXhtRSxRQUFPQyxPQUFQLEdBQWlCdW1FLFFBQWpCLEM7Ozs7OztBQzNJQTs7OztBQUVBLEtBQUk5QixRQUFRdjhELE9BQU92SCxTQUFQLENBQWlCeUksUUFBN0I7O0FBRUFySixRQUFPQyxPQUFQLEdBQWlCLFNBQVN5bUUsV0FBVCxDQUFxQng5RCxLQUFyQixFQUE0QjtBQUM1QyxNQUFJbUIsTUFBTXE2RCxNQUFNN2pFLElBQU4sQ0FBV3FJLEtBQVgsQ0FBVjtBQUNBLE1BQUl5N0QsU0FBU3Q2RCxRQUFRLG9CQUFyQjtBQUNBLE1BQUksQ0FBQ3M2RCxNQUFMLEVBQWE7QUFDWkEsWUFBU3Q2RCxRQUFRLGdCQUFSLElBQ1JuQixVQUFVLElBREYsSUFFUixRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBRlQsSUFHUixPQUFPQSxNQUFNMUgsTUFBYixLQUF3QixRQUhoQixJQUlSMEgsTUFBTTFILE1BQU4sSUFBZ0IsQ0FKUixJQUtSa2pFLE1BQU03akUsSUFBTixDQUFXcUksTUFBTWkrRCxNQUFqQixNQUE2QixtQkFMOUI7QUFNQTtBQUNELFNBQU94QyxNQUFQO0FBQ0EsRUFaRCxDOzs7Ozs7OztBQ0pBLEtBQUl0N0QsV0FBVyxHQUFHQSxRQUFsQjs7QUFFQXJKLFFBQU9DLE9BQVAsR0FBaUIwTSxNQUFNbUIsT0FBTixJQUFpQixVQUFVL0MsR0FBVixFQUFlO0FBQy9DLFVBQU8xQixTQUFTeEksSUFBVCxDQUFja0ssR0FBZCxLQUFzQixnQkFBN0I7QUFDRCxFQUZELEM7Ozs7Ozs7O0FDRkEsS0FBSXU1RCxVQUFVLG1CQUFBeFEsQ0FBUSxFQUFSLENBQWQ7O0FBRUE5ekQsUUFBT0MsT0FBUCxHQUFpQixTQUFTc0ssR0FBVCxDQUFhUSxHQUFiLEVBQWtCTyxFQUFsQixFQUFzQjtBQUNyQyxPQUFJODdELFNBQVMsRUFBYjtBQUNBOUMsV0FBUXY1RCxHQUFSLEVBQWEsVUFBU0MsSUFBVCxFQUFlcThELFNBQWYsRUFBMEI7QUFDckNELFlBQU9qMUQsSUFBUCxDQUFZN0csR0FBR04sSUFBSCxFQUFTcThELFNBQVQsRUFBb0J0OEQsR0FBcEIsQ0FBWjtBQUNELElBRkQ7QUFHQSxVQUFPcThELE1BQVA7QUFDRCxFQU5ELEM7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQXBuRSxRQUFPQyxPQUFQLEdBQWlCLFNBQVNnOUQsV0FBVCxDQUFxQjN4RCxFQUFyQixFQUF5QjJ6RCxXQUF6QixFQUFzQztBQUNyREEsZUFBWTN6RCxFQUFaLEVBQWdCLENBQWhCO0FBQ0QsRUFGRCxDOzs7Ozs7QUNKQTs7QUFFQTs7QUFFQXRMLFFBQU9DLE9BQVAsR0FBaUJtL0QsWUFBakI7O0FBRUEsS0FBSTVGLFdBQVcsbUJBQUExRixDQUFRLEVBQVIsQ0FBZjtBQUNBLEtBQUl3VCxlQUFlLG1CQUFBeFQsQ0FBUSxFQUFSLEVBQWtCd1QsWUFBckM7O0FBRUEsVUFBU2xJLFlBQVQsR0FBd0IsQ0FDdkI7O0FBRUQ1RixVQUFTNEYsWUFBVCxFQUF1QmtJLFlBQXZCOztBQUVBbEksY0FBYXgrRCxTQUFiLENBQXVCaytDLElBQXZCLEdBQThCLFlBQVc7QUFDdkMsUUFBS3lnQixRQUFMLEdBQWdCLElBQWhCO0FBQ0EsUUFBS2dJLE1BQUw7QUFDRCxFQUhEOztBQUtBbkksY0FBYXgrRCxTQUFiLENBQXVCKytELElBQXZCLEdBQThCLFlBQVc7QUFDdkMsUUFBSzkxQyxJQUFMLENBQVUsS0FBVjtBQUNBLFFBQUswOUMsTUFBTDtBQUNELEVBSEQ7O0FBS0FuSSxjQUFheCtELFNBQWIsQ0FBdUI2K0QsTUFBdkIsR0FBZ0MsVUFBU3B0RCxHQUFULEVBQWM7QUFDNUMsUUFBS3dYLElBQUwsQ0FBVSxPQUFWLEVBQW1CeFgsR0FBbkI7QUFDQSxRQUFLazFELE1BQUw7QUFDRCxFQUhEOztBQUtBbkksY0FBYXgrRCxTQUFiLENBQXVCOCtELE9BQXZCLEdBQWlDLFVBQVM1ckIsT0FBVCxFQUFrQjtBQUNqRCxRQUFLanFCLElBQUwsQ0FBVSxRQUFWLEVBQW9CaXFCLE9BQXBCO0FBQ0QsRUFGRDs7QUFJQXNyQixjQUFheCtELFNBQWIsQ0FBdUIybUUsTUFBdkIsR0FBZ0MsWUFBVztBQUN6QyxRQUFLNWdCLGtCQUFMLENBQXdCLE1BQXhCO0FBQ0EsUUFBS0Esa0JBQUwsQ0FBd0IsS0FBeEI7QUFDQSxRQUFLQSxrQkFBTCxDQUF3QixPQUF4QjtBQUNBLFFBQUtBLGtCQUFMLENBQXdCLFFBQXhCO0FBQ0QsRUFMRCxDOzs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUzJnQixZQUFULEdBQXdCO0FBQ3RCLFFBQUt6akQsT0FBTCxHQUFlLEtBQUtBLE9BQUwsSUFBZ0IsRUFBL0I7QUFDQSxRQUFLMmpELGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxJQUFzQnJtRSxTQUEzQztBQUNEO0FBQ0RuQixRQUFPQyxPQUFQLEdBQWlCcW5FLFlBQWpCOztBQUVBO0FBQ0FBLGNBQWFBLFlBQWIsR0FBNEJBLFlBQTVCOztBQUVBQSxjQUFhMW1FLFNBQWIsQ0FBdUJpakIsT0FBdkIsR0FBaUMxaUIsU0FBakM7QUFDQW1tRSxjQUFhMW1FLFNBQWIsQ0FBdUI0bUUsYUFBdkIsR0FBdUNybUUsU0FBdkM7O0FBRUE7QUFDQTtBQUNBbW1FLGNBQWFHLG1CQUFiLEdBQW1DLEVBQW5DOztBQUVBO0FBQ0E7QUFDQUgsY0FBYTFtRSxTQUFiLENBQXVCOG1FLGVBQXZCLEdBQXlDLFVBQVNoK0QsQ0FBVCxFQUFZO0FBQ25ELE9BQUksQ0FBQ2krRCxTQUFTaitELENBQVQsQ0FBRCxJQUFnQkEsSUFBSSxDQUFwQixJQUF5QlMsTUFBTVQsQ0FBTixDQUE3QixFQUNFLE1BQU16RixVQUFVLDZCQUFWLENBQU47QUFDRixRQUFLdWpFLGFBQUwsR0FBcUI5OUQsQ0FBckI7QUFDQSxVQUFPLElBQVA7QUFDRCxFQUxEOztBQU9BNDlELGNBQWExbUUsU0FBYixDQUF1QmlwQixJQUF2QixHQUE4QixVQUFTcFAsSUFBVCxFQUFlO0FBQzNDLE9BQUltdEQsRUFBSixFQUFRaDdDLE9BQVIsRUFBaUIzVixHQUFqQixFQUFzQkQsSUFBdEIsRUFBNEJ6VixDQUE1QixFQUErQndpQixTQUEvQjs7QUFFQSxPQUFJLENBQUMsS0FBS0YsT0FBVixFQUNFLEtBQUtBLE9BQUwsR0FBZSxFQUFmOztBQUVGO0FBQ0EsT0FBSXBKLFNBQVMsT0FBYixFQUFzQjtBQUNwQixTQUFJLENBQUMsS0FBS29KLE9BQUwsQ0FBYXhjLEtBQWQsSUFDQzhCLFNBQVMsS0FBSzBhLE9BQUwsQ0FBYXhjLEtBQXRCLEtBQWdDLENBQUMsS0FBS3djLE9BQUwsQ0FBYXhjLEtBQWIsQ0FBbUI3RixNQUR6RCxFQUNrRTtBQUNoRW9tRSxZQUFLNW1FLFVBQVUsQ0FBVixDQUFMO0FBQ0EsV0FBSTRtRSxjQUFjcmlCLEtBQWxCLEVBQXlCO0FBQ3ZCLGVBQU1xaUIsRUFBTixDQUR1QixDQUNiO0FBQ1gsUUFGRCxNQUVPO0FBQ0w7QUFDQSxhQUFJdjFELE1BQU0sSUFBSWt6QyxLQUFKLENBQVUsMkNBQTJDcWlCLEVBQTNDLEdBQWdELEdBQTFELENBQVY7QUFDQXYxRCxhQUFJMk0sT0FBSixHQUFjNG9ELEVBQWQ7QUFDQSxlQUFNdjFELEdBQU47QUFDRDtBQUNGO0FBQ0Y7O0FBRUR1YSxhQUFVLEtBQUsvSSxPQUFMLENBQWFwSixJQUFiLENBQVY7O0FBRUEsT0FBSW90RCxZQUFZajdDLE9BQVosQ0FBSixFQUNFLE9BQU8sS0FBUDs7QUFFRixPQUFJNjVDLFdBQVc3NUMsT0FBWCxDQUFKLEVBQXlCO0FBQ3ZCLGFBQVE1ckIsVUFBVVEsTUFBbEI7QUFDRTtBQUNBLFlBQUssQ0FBTDtBQUNFb3JCLGlCQUFRL3JCLElBQVIsQ0FBYSxJQUFiO0FBQ0E7QUFDRixZQUFLLENBQUw7QUFDRStyQixpQkFBUS9yQixJQUFSLENBQWEsSUFBYixFQUFtQkcsVUFBVSxDQUFWLENBQW5CO0FBQ0E7QUFDRixZQUFLLENBQUw7QUFDRTRyQixpQkFBUS9yQixJQUFSLENBQWEsSUFBYixFQUFtQkcsVUFBVSxDQUFWLENBQW5CLEVBQWlDQSxVQUFVLENBQVYsQ0FBakM7QUFDQTtBQUNGO0FBQ0E7QUFDRWdXLGdCQUFPckssTUFBTS9MLFNBQU4sQ0FBZ0J1QyxLQUFoQixDQUFzQnRDLElBQXRCLENBQTJCRyxTQUEzQixFQUFzQyxDQUF0QyxDQUFQO0FBQ0E0ckIsaUJBQVE3ckIsS0FBUixDQUFjLElBQWQsRUFBb0JpVyxJQUFwQjtBQWRKO0FBZ0JELElBakJELE1BaUJPLElBQUk3TixTQUFTeWpCLE9BQVQsQ0FBSixFQUF1QjtBQUM1QjVWLFlBQU9ySyxNQUFNL0wsU0FBTixDQUFnQnVDLEtBQWhCLENBQXNCdEMsSUFBdEIsQ0FBMkJHLFNBQTNCLEVBQXNDLENBQXRDLENBQVA7QUFDQStpQixpQkFBWTZJLFFBQVF6cEIsS0FBUixFQUFaO0FBQ0E4VCxXQUFNOE0sVUFBVXZpQixNQUFoQjtBQUNBLFVBQUtELElBQUksQ0FBVCxFQUFZQSxJQUFJMFYsR0FBaEIsRUFBcUIxVixHQUFyQjtBQUNFd2lCLGlCQUFVeGlCLENBQVYsRUFBYVIsS0FBYixDQUFtQixJQUFuQixFQUF5QmlXLElBQXpCO0FBREY7QUFFRDs7QUFFRCxVQUFPLElBQVA7QUFDRCxFQXJERDs7QUF1REFzd0QsY0FBYTFtRSxTQUFiLENBQXVCZ0YsV0FBdkIsR0FBcUMsVUFBUzZVLElBQVQsRUFBZXF0RCxRQUFmLEVBQXlCO0FBQzVELE9BQUl4NkQsQ0FBSjs7QUFFQSxPQUFJLENBQUNtNUQsV0FBV3FCLFFBQVgsQ0FBTCxFQUNFLE1BQU03akUsVUFBVSw2QkFBVixDQUFOOztBQUVGLE9BQUksQ0FBQyxLQUFLNGYsT0FBVixFQUNFLEtBQUtBLE9BQUwsR0FBZSxFQUFmOztBQUVGO0FBQ0E7QUFDQSxPQUFJLEtBQUtBLE9BQUwsQ0FBYWtrRCxXQUFqQixFQUNFLEtBQUtsK0MsSUFBTCxDQUFVLGFBQVYsRUFBeUJwUCxJQUF6QixFQUNVZ3NELFdBQVdxQixTQUFTQSxRQUFwQixJQUNBQSxTQUFTQSxRQURULEdBQ29CQSxRQUY5Qjs7QUFJRixPQUFJLENBQUMsS0FBS2prRCxPQUFMLENBQWFwSixJQUFiLENBQUw7QUFDRTtBQUNBLFVBQUtvSixPQUFMLENBQWFwSixJQUFiLElBQXFCcXRELFFBQXJCLENBRkYsS0FHSyxJQUFJMytELFNBQVMsS0FBSzBhLE9BQUwsQ0FBYXBKLElBQWIsQ0FBVCxDQUFKO0FBQ0g7QUFDQSxVQUFLb0osT0FBTCxDQUFhcEosSUFBYixFQUFtQnRJLElBQW5CLENBQXdCMjFELFFBQXhCLEVBRkc7QUFJSDtBQUNBLFVBQUtqa0QsT0FBTCxDQUFhcEosSUFBYixJQUFxQixDQUFDLEtBQUtvSixPQUFMLENBQWFwSixJQUFiLENBQUQsRUFBcUJxdEQsUUFBckIsQ0FBckI7O0FBRUY7QUFDQSxPQUFJMytELFNBQVMsS0FBSzBhLE9BQUwsQ0FBYXBKLElBQWIsQ0FBVCxLQUFnQyxDQUFDLEtBQUtvSixPQUFMLENBQWFwSixJQUFiLEVBQW1CNC9CLE1BQXhELEVBQWdFO0FBQzlELFNBQUksQ0FBQ3d0QixZQUFZLEtBQUtMLGFBQWpCLENBQUwsRUFBc0M7QUFDcENsNkQsV0FBSSxLQUFLazZELGFBQVQ7QUFDRCxNQUZELE1BRU87QUFDTGw2RCxXQUFJZzZELGFBQWFHLG1CQUFqQjtBQUNEOztBQUVELFNBQUluNkQsS0FBS0EsSUFBSSxDQUFULElBQWMsS0FBS3VXLE9BQUwsQ0FBYXBKLElBQWIsRUFBbUJqWixNQUFuQixHQUE0QjhMLENBQTlDLEVBQWlEO0FBQy9DLFlBQUt1VyxPQUFMLENBQWFwSixJQUFiLEVBQW1CNC9CLE1BQW5CLEdBQTRCLElBQTVCO0FBQ0FuNUMsZUFBUW1HLEtBQVIsQ0FBYyxrREFDQSxxQ0FEQSxHQUVBLGtEQUZkLEVBR2MsS0FBS3djLE9BQUwsQ0FBYXBKLElBQWIsRUFBbUJqWixNQUhqQztBQUlBLFdBQUksT0FBT04sUUFBUThGLEtBQWYsS0FBeUIsVUFBN0IsRUFBeUM7QUFDdkM7QUFDQTlGLGlCQUFROEYsS0FBUjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxVQUFPLElBQVA7QUFDRCxFQWhERDs7QUFrREFzZ0UsY0FBYTFtRSxTQUFiLENBQXVCcWdCLEVBQXZCLEdBQTRCcW1ELGFBQWExbUUsU0FBYixDQUF1QmdGLFdBQW5EOztBQUVBMGhFLGNBQWExbUUsU0FBYixDQUF1QndOLElBQXZCLEdBQThCLFVBQVNxTSxJQUFULEVBQWVxdEQsUUFBZixFQUF5QjtBQUNyRCxPQUFJLENBQUNyQixXQUFXcUIsUUFBWCxDQUFMLEVBQ0UsTUFBTTdqRSxVQUFVLDZCQUFWLENBQU47O0FBRUYsT0FBSStqRSxRQUFRLEtBQVo7O0FBRUEsWUFBU3B4QixDQUFULEdBQWE7QUFDWCxVQUFLOFAsY0FBTCxDQUFvQmpzQyxJQUFwQixFQUEwQm04QixDQUExQjs7QUFFQSxTQUFJLENBQUNveEIsS0FBTCxFQUFZO0FBQ1ZBLGVBQVEsSUFBUjtBQUNBRixnQkFBUy9tRSxLQUFULENBQWUsSUFBZixFQUFxQkMsU0FBckI7QUFDRDtBQUNGOztBQUVENDFDLEtBQUVreEIsUUFBRixHQUFhQSxRQUFiO0FBQ0EsUUFBSzdtRCxFQUFMLENBQVF4RyxJQUFSLEVBQWNtOEIsQ0FBZDs7QUFFQSxVQUFPLElBQVA7QUFDRCxFQW5CRDs7QUFxQkE7QUFDQTB3QixjQUFhMW1FLFNBQWIsQ0FBdUI4bEQsY0FBdkIsR0FBd0MsVUFBU2pzQyxJQUFULEVBQWVxdEQsUUFBZixFQUF5QjtBQUMvRCxPQUFJcjlELElBQUosRUFBVXc5RCxRQUFWLEVBQW9Cem1FLE1BQXBCLEVBQTRCRCxDQUE1Qjs7QUFFQSxPQUFJLENBQUNrbEUsV0FBV3FCLFFBQVgsQ0FBTCxFQUNFLE1BQU03akUsVUFBVSw2QkFBVixDQUFOOztBQUVGLE9BQUksQ0FBQyxLQUFLNGYsT0FBTixJQUFpQixDQUFDLEtBQUtBLE9BQUwsQ0FBYXBKLElBQWIsQ0FBdEIsRUFDRSxPQUFPLElBQVA7O0FBRUZoUSxVQUFPLEtBQUtvWixPQUFMLENBQWFwSixJQUFiLENBQVA7QUFDQWpaLFlBQVNpSixLQUFLakosTUFBZDtBQUNBeW1FLGNBQVcsQ0FBQyxDQUFaOztBQUVBLE9BQUl4OUQsU0FBU3E5RCxRQUFULElBQ0NyQixXQUFXaDhELEtBQUtxOUQsUUFBaEIsS0FBNkJyOUQsS0FBS3E5RCxRQUFMLEtBQWtCQSxRQURwRCxFQUMrRDtBQUM3RCxZQUFPLEtBQUtqa0QsT0FBTCxDQUFhcEosSUFBYixDQUFQO0FBQ0EsU0FBSSxLQUFLb0osT0FBTCxDQUFhNmlDLGNBQWpCLEVBQ0UsS0FBSzc4QixJQUFMLENBQVUsZ0JBQVYsRUFBNEJwUCxJQUE1QixFQUFrQ3F0RCxRQUFsQztBQUVILElBTkQsTUFNTyxJQUFJMytELFNBQVNzQixJQUFULENBQUosRUFBb0I7QUFDekIsVUFBS2xKLElBQUlDLE1BQVQsRUFBaUJELE1BQU0sQ0FBdkIsR0FBMkI7QUFDekIsV0FBSWtKLEtBQUtsSixDQUFMLE1BQVl1bUUsUUFBWixJQUNDcjlELEtBQUtsSixDQUFMLEVBQVF1bUUsUUFBUixJQUFvQnI5RCxLQUFLbEosQ0FBTCxFQUFRdW1FLFFBQVIsS0FBcUJBLFFBRDlDLEVBQ3lEO0FBQ3ZERyxvQkFBVzFtRSxDQUFYO0FBQ0E7QUFDRDtBQUNGOztBQUVELFNBQUkwbUUsV0FBVyxDQUFmLEVBQ0UsT0FBTyxJQUFQOztBQUVGLFNBQUl4OUQsS0FBS2pKLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckJpSixZQUFLakosTUFBTCxHQUFjLENBQWQ7QUFDQSxjQUFPLEtBQUtxaUIsT0FBTCxDQUFhcEosSUFBYixDQUFQO0FBQ0QsTUFIRCxNQUdPO0FBQ0xoUSxZQUFLUSxNQUFMLENBQVlnOUQsUUFBWixFQUFzQixDQUF0QjtBQUNEOztBQUVELFNBQUksS0FBS3BrRCxPQUFMLENBQWE2aUMsY0FBakIsRUFDRSxLQUFLNzhCLElBQUwsQ0FBVSxnQkFBVixFQUE0QnBQLElBQTVCLEVBQWtDcXRELFFBQWxDO0FBQ0g7O0FBRUQsVUFBTyxJQUFQO0FBQ0QsRUEzQ0Q7O0FBNkNBUixjQUFhMW1FLFNBQWIsQ0FBdUIrbEQsa0JBQXZCLEdBQTRDLFVBQVNsc0MsSUFBVCxFQUFlO0FBQ3pELE9BQUlyUCxHQUFKLEVBQVMyWSxTQUFUOztBQUVBLE9BQUksQ0FBQyxLQUFLRixPQUFWLEVBQ0UsT0FBTyxJQUFQOztBQUVGO0FBQ0EsT0FBSSxDQUFDLEtBQUtBLE9BQUwsQ0FBYTZpQyxjQUFsQixFQUFrQztBQUNoQyxTQUFJMWxELFVBQVVRLE1BQVYsS0FBcUIsQ0FBekIsRUFDRSxLQUFLcWlCLE9BQUwsR0FBZSxFQUFmLENBREYsS0FFSyxJQUFJLEtBQUtBLE9BQUwsQ0FBYXBKLElBQWIsQ0FBSixFQUNILE9BQU8sS0FBS29KLE9BQUwsQ0FBYXBKLElBQWIsQ0FBUDtBQUNGLFlBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0EsT0FBSXpaLFVBQVVRLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsVUFBSzRKLEdBQUwsSUFBWSxLQUFLeVksT0FBakIsRUFBMEI7QUFDeEIsV0FBSXpZLFFBQVEsZ0JBQVosRUFBOEI7QUFDOUIsWUFBS3U3QyxrQkFBTCxDQUF3QnY3QyxHQUF4QjtBQUNEO0FBQ0QsVUFBS3U3QyxrQkFBTCxDQUF3QixnQkFBeEI7QUFDQSxVQUFLOWlDLE9BQUwsR0FBZSxFQUFmO0FBQ0EsWUFBTyxJQUFQO0FBQ0Q7O0FBRURFLGVBQVksS0FBS0YsT0FBTCxDQUFhcEosSUFBYixDQUFaOztBQUVBLE9BQUlnc0QsV0FBVzFpRCxTQUFYLENBQUosRUFBMkI7QUFDekIsVUFBSzJpQyxjQUFMLENBQW9CanNDLElBQXBCLEVBQTBCc0osU0FBMUI7QUFDRCxJQUZELE1BRU8sSUFBSUEsU0FBSixFQUFlO0FBQ3BCO0FBQ0EsWUFBT0EsVUFBVXZpQixNQUFqQjtBQUNFLFlBQUtrbEQsY0FBTCxDQUFvQmpzQyxJQUFwQixFQUEwQnNKLFVBQVVBLFVBQVV2aUIsTUFBVixHQUFtQixDQUE3QixDQUExQjtBQURGO0FBRUQ7QUFDRCxVQUFPLEtBQUtxaUIsT0FBTCxDQUFhcEosSUFBYixDQUFQOztBQUVBLFVBQU8sSUFBUDtBQUNELEVBdENEOztBQXdDQTZzRCxjQUFhMW1FLFNBQWIsQ0FBdUJtakIsU0FBdkIsR0FBbUMsVUFBU3RKLElBQVQsRUFBZTtBQUNoRCxPQUFJL04sR0FBSjtBQUNBLE9BQUksQ0FBQyxLQUFLbVgsT0FBTixJQUFpQixDQUFDLEtBQUtBLE9BQUwsQ0FBYXBKLElBQWIsQ0FBdEIsRUFDRS9OLE1BQU0sRUFBTixDQURGLEtBRUssSUFBSSs1RCxXQUFXLEtBQUs1aUQsT0FBTCxDQUFhcEosSUFBYixDQUFYLENBQUosRUFDSC9OLE1BQU0sQ0FBQyxLQUFLbVgsT0FBTCxDQUFhcEosSUFBYixDQUFELENBQU4sQ0FERyxLQUdIL04sTUFBTSxLQUFLbVgsT0FBTCxDQUFhcEosSUFBYixFQUFtQnRYLEtBQW5CLEVBQU47QUFDRixVQUFPdUosR0FBUDtBQUNELEVBVEQ7O0FBV0E0NkQsY0FBYTFtRSxTQUFiLENBQXVCc25FLGFBQXZCLEdBQXVDLFVBQVN6dEQsSUFBVCxFQUFlO0FBQ3BELE9BQUksS0FBS29KLE9BQVQsRUFBa0I7QUFDaEIsU0FBSXNrRCxhQUFhLEtBQUt0a0QsT0FBTCxDQUFhcEosSUFBYixDQUFqQjs7QUFFQSxTQUFJZ3NELFdBQVcwQixVQUFYLENBQUosRUFDRSxPQUFPLENBQVAsQ0FERixLQUVLLElBQUlBLFVBQUosRUFDSCxPQUFPQSxXQUFXM21FLE1BQWxCO0FBQ0g7QUFDRCxVQUFPLENBQVA7QUFDRCxFQVZEOztBQVlBOGxFLGNBQWFZLGFBQWIsR0FBNkIsVUFBU0UsT0FBVCxFQUFrQjN0RCxJQUFsQixFQUF3QjtBQUNuRCxVQUFPMnRELFFBQVFGLGFBQVIsQ0FBc0J6dEQsSUFBdEIsQ0FBUDtBQUNELEVBRkQ7O0FBSUEsVUFBU2dzRCxVQUFULENBQW9CNWpDLEdBQXBCLEVBQXlCO0FBQ3ZCLFVBQU8sT0FBT0EsR0FBUCxLQUFlLFVBQXRCO0FBQ0Q7O0FBRUQsVUFBUzhrQyxRQUFULENBQWtCOWtDLEdBQWxCLEVBQXVCO0FBQ3JCLFVBQU8sT0FBT0EsR0FBUCxLQUFlLFFBQXRCO0FBQ0Q7O0FBRUQsVUFBUzE1QixRQUFULENBQWtCMDVCLEdBQWxCLEVBQXVCO0FBQ3JCLFVBQU8sUUFBT0EsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQWYsSUFBMkJBLFFBQVEsSUFBMUM7QUFDRDs7QUFFRCxVQUFTZ2xDLFdBQVQsQ0FBcUJobEMsR0FBckIsRUFBMEI7QUFDeEIsVUFBT0EsUUFBUSxLQUFLLENBQXBCO0FBQ0QsRTs7Ozs7Ozs7QUM3U0Q3aUMsUUFBT0MsT0FBUCxHQUFpQnM1RCxpQkFBakI7O0FBRUEsS0FBSTlWLFNBQVMsbUJBQUFxUSxDQUFRLEVBQVIsQ0FBYjtBQUNBLEtBQUltSixjQUFjLG1CQUFBbkosQ0FBUSxFQUFSLENBQWxCO0FBQ0EsS0FBSWtKLFlBQVksbUJBQUFsSixDQUFRLEVBQVIsQ0FBaEI7QUFDQSxLQUFJdVUsUUFBUSxtQkFBQXZVLENBQVEsRUFBUixDQUFaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUl3VSxxQkFBcUIsR0FBekI7QUFDQSxLQUFJQyx1QkFDRjE1RCxRQUFRQyxHQUFSLENBQVl5NUQsb0JBQVosSUFBb0Mxb0IsU0FBU2h4QyxRQUFRQyxHQUFSLENBQVl5NUQsb0JBQXJCLEVBQTJDLEVBQTNDLENBQXBDLElBQ0EsS0FBSyxDQUFMLEdBQVMsSUFGWCxDLENBRWlCOztBQUVqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxVQUFTaFAsaUJBQVQsQ0FBMkJpUCxhQUEzQixFQUEwQ2xqRSxNQUExQyxFQUFrRDhOLElBQWxELEVBQXdEO0FBQ3RELE9BQUkxUixRQUFRLG1CQUFBb3lELENBQVEsRUFBUixFQUFpQixlQUFqQixDQUFaOztBQUVBLE9BQUkxZ0IsUUFBUSxtQkFBQTBnQixDQUFRLEVBQVIsQ0FBWjtBQUNBLE9BQUlobUQsVUFBVSxtQkFBQWdtRCxDQUFRLEVBQVIsQ0FBZDtBQUNBLE9BQUl2cEQsTUFBTSxtQkFBQXVwRCxDQUFRLEVBQVIsQ0FBVjs7QUFFQSxPQUFJb0gsUUFBUSxtREFBWjs7QUFFQSxPQUFJOW5ELEtBQUtxMUQsc0JBQUwsS0FBZ0MsSUFBaEMsSUFBd0MsQ0FBQ0QsYUFBN0MsRUFBNEQ7QUFDMUQsV0FBTSxJQUFJL2tCLE9BQU9zWixrQkFBWCxDQUE4Qix1Q0FBdUM3QixLQUFyRSxDQUFOO0FBQ0Q7O0FBRUQsT0FBSTluRCxLQUFLcTFELHNCQUFMLEtBQWdDLElBQWhDLElBQXdDLENBQUNuakUsTUFBN0MsRUFBcUQ7QUFDbkQsV0FBTSxJQUFJbStDLE9BQU9zWixrQkFBWCxDQUE4QixnQ0FBZ0M3QixLQUE5RCxDQUFOO0FBQ0Q7O0FBRUQsUUFBS3NOLGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsUUFBS2xqRSxNQUFMLEdBQWNBLE1BQWQ7O0FBRUEsUUFBS29qRSxLQUFMLEdBQWE7QUFDWEMsV0FBTSxFQURLO0FBRVhDLFlBQU87QUFGSSxJQUFiOztBQUtBeDFELFVBQU9BLFFBQVEsRUFBZjs7QUFFQSxPQUFJeWlELFdBQVd6aUQsS0FBS3lpRCxRQUFMLElBQWlCLFFBQWhDO0FBQ0EsUUFBS2dULFNBQUwsR0FBaUJ6MUQsS0FBSzAxRCxRQUFMLElBQWlCO0FBQ2hDQyxjQUFTLElBQUksSUFEbUIsRUFDYjtBQUNuQkosV0FBTSxJQUFJLElBRnNCO0FBR2hDQyxZQUFPLEtBQUs7QUFIb0IsSUFBbEM7O0FBTUE7QUFDQSxPQUFJeDFELEtBQUtzUSxPQUFULEVBQWtCO0FBQ2hCLFVBQUttbEQsU0FBTCxDQUFlRSxPQUFmLEdBQXlCLEtBQUtGLFNBQUwsQ0FBZUYsSUFBZixHQUFzQixLQUFLRSxTQUFMLENBQWVELEtBQWYsR0FBdUJ4MUQsS0FBS3NRLE9BQTNFO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQUksQ0FBQyxLQUFLalQsSUFBTCxDQUFVb2xELFFBQVYsQ0FBTCxFQUEwQjtBQUN4QkEsZ0JBQVdBLFdBQVcsR0FBdEI7QUFDRDs7QUFFRCxPQUFJemlELEtBQUt5aUQsUUFBTCxLQUFrQixPQUFsQixJQUE2QnppRCxLQUFLeWlELFFBQUwsS0FBa0IsUUFBbkQsRUFBNkQ7QUFDM0QsV0FBTSxJQUFJcFMsT0FBT3NaLGtCQUFYLENBQThCLGdEQUFnRDNwRCxLQUFLeWlELFFBQXJELEdBQWdFLElBQTlGLENBQU47QUFDRDs7QUFFRCxRQUFLbVQsZUFBTDs7QUFFQSxPQUFJLENBQUM1MUQsS0FBS3MxRCxLQUFWLEVBQWlCO0FBQ2YsU0FBSU8sZUFBZTErRCxJQUFJLEtBQUsyK0QsY0FBVCxFQUF5QixVQUFTQyxVQUFULEVBQXFCO0FBQy9ELGNBQU9YLGdCQUFnQixHQUFoQixHQUFzQlcsVUFBdEIsR0FBbUMsaUJBQTFDO0FBQ0QsTUFGa0IsQ0FBbkI7O0FBSUE7QUFDQSxVQUFLVCxLQUFMLENBQVdDLElBQVgsR0FBa0IsQ0FBQyxLQUFLSCxhQUFMLEdBQXFCLGtCQUF0QixFQUEwQ2o3RCxNQUExQyxDQUFpRDA3RCxZQUFqRCxDQUFsQjtBQUNBLFVBQUtQLEtBQUwsQ0FBV0UsS0FBWCxHQUFtQixDQUFDLEtBQUtKLGFBQUwsR0FBcUIsY0FBdEIsRUFBc0NqN0QsTUFBdEMsQ0FBNkMwN0QsWUFBN0MsQ0FBbkI7QUFDRCxJQVJELE1BUU8sSUFBSW43RCxRQUFRc0YsS0FBS3MxRCxLQUFiLENBQUosRUFBeUI7QUFDOUI7QUFDQTtBQUNBLFVBQUtBLEtBQUwsQ0FBV0MsSUFBWCxHQUFrQnYxQixNQUFNaGdDLEtBQUtzMUQsS0FBWCxDQUFsQjtBQUNBLFVBQUtBLEtBQUwsQ0FBV0UsS0FBWCxHQUFtQngxQixNQUFNaGdDLEtBQUtzMUQsS0FBWCxDQUFuQjtBQUNELElBTE0sTUFLQTtBQUNMLFVBQUtBLEtBQUwsQ0FBV0MsSUFBWCxHQUFrQnYxQixNQUFNaGdDLEtBQUtzMUQsS0FBTCxDQUFXQyxJQUFqQixDQUFsQjtBQUNBLFVBQUtELEtBQUwsQ0FBV0UsS0FBWCxHQUFtQngxQixNQUFNaGdDLEtBQUtzMUQsS0FBTCxDQUFXRSxLQUFqQixDQUFuQjtBQUNEOztBQUVEO0FBQ0EsUUFBS0YsS0FBTCxDQUFXQyxJQUFYLEdBQWtCcCtELElBQUksS0FBS20rRCxLQUFMLENBQVdDLElBQWYsRUFBcUJTLFlBQVl2VCxRQUFaLENBQXJCLENBQWxCO0FBQ0EsUUFBSzZTLEtBQUwsQ0FBV0UsS0FBWCxHQUFtQnIrRCxJQUFJLEtBQUttK0QsS0FBTCxDQUFXRSxLQUFmLEVBQXNCUSxZQUFZdlQsUUFBWixDQUF0QixDQUFuQjs7QUFFQSxRQUFLd1QsWUFBTCxHQUFvQixFQUFwQjs7QUFFQTtBQUNBLFFBQUs5OUQsS0FBTCxHQUFhNkgsS0FBS2syRCxNQUFMLElBQWUsRUFBNUI7O0FBRUEsUUFBS0MsR0FBTCxHQUFXbjJELEtBQUttMkQsR0FBaEI7QUFDQSxRQUFLQyxTQUFMLEdBQWlCcDJELEtBQUtvMkQsU0FBTCxLQUFtQnJvRSxTQUFuQixJQUFnQ2lTLEtBQUtrMkQsTUFBckMsR0FBOEMsSUFBOUMsR0FBcURsMkQsS0FBS28yRCxTQUEzRTtBQUNBLFFBQUtDLFlBQUwsR0FBb0JyMkQsS0FBS3MyRCxXQUFMLEtBQXFCdm9FLFNBQXJCLEdBQWlDLElBQWpDLEdBQXdDaVMsS0FBS3MyRCxXQUFqRTs7QUFFQSxRQUFLekssV0FBTCxHQUFtQjdyRCxLQUFLNnJELFdBQXhCOztBQUVBdjlELFNBQU0sZUFBTixFQUF1QixJQUF2QjtBQUNEOztBQUVEOzs7Ozs7QUFNQTYzRCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEJtMUQsU0FBNUIsR0FBd0MsVUFBUzJELFNBQVQsRUFBb0I7QUFDMUQsVUFBTyxJQUFJc0QsU0FBSixDQUFjLElBQWQsRUFBb0J0RCxTQUFwQixDQUFQO0FBQ0QsRUFGRDs7QUFJQTs7Ozs7O0FBTUFILG1CQUFrQjM0RCxTQUFsQixDQUE0QitvRSxjQUE1QixHQUE2QyxVQUFTN25FLElBQVQsRUFBZW9ILEtBQWYsRUFBc0I7QUFDakUsUUFBS21nRSxZQUFMLENBQWtCdm5FLEtBQUs2SSxXQUFMLEVBQWxCLElBQXdDekIsS0FBeEM7QUFDRCxFQUZEOztBQUlBOzs7OztBQUtBcXdELG1CQUFrQjM0RCxTQUFsQixDQUE0QmdwRSxjQUE1QixHQUE2QyxVQUFTOW5FLElBQVQsRUFBZTtBQUMxRCxVQUFPLEtBQUt1bkUsWUFBTCxDQUFrQnZuRSxLQUFLNkksV0FBTCxFQUFsQixDQUFQO0FBQ0QsRUFGRDs7QUFJQTs7Ozs7QUFLQTR1RCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEJpcEUsZ0JBQTVCLEdBQStDLFVBQVMvbkUsSUFBVCxFQUFlO0FBQzVELFVBQU8sS0FBS3VuRSxZQUFMLENBQWtCdm5FLEtBQUs2SSxXQUFMLEVBQWxCLENBQVA7QUFDRCxFQUZEOztBQUlBOzs7Ozs7QUFNQTR1RCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEJrcEUsZUFBNUIsR0FBOEMsVUFBU0MsWUFBVCxFQUF1QjtBQUNuRSxPQUFJLEtBQUtSLEdBQUwsQ0FBU3RtRSxPQUFULENBQWlCLE1BQU04bUUsWUFBdkIsTUFBeUMsQ0FBQyxDQUE5QyxFQUFpRDtBQUMvQyxVQUFLUixHQUFMLElBQVksTUFBTVEsWUFBbEI7QUFDRDtBQUNGLEVBSkQ7O0FBTUE7OztBQUdBeFEsbUJBQWtCMzRELFNBQWxCLENBQTRCKzRELFlBQTVCLEdBQTJDLFVBQVNxUSxXQUFULEVBQXNCO0FBQy9ELFFBQUtoQixlQUFMOztBQUVBLE9BQUlpQixlQUFlLG1CQUFBblcsQ0FBUSxFQUFSLEVBQWlCLG1CQUFtQmtXLFlBQVlwakUsR0FBaEQsQ0FBbkI7O0FBRUEsT0FBSThyQyxJQUFKO0FBQ0EsT0FBSXl3QixlQUFlNkcsWUFBWTdHLFlBQVosSUFBNEIsRUFBL0M7QUFDQSxPQUFJNTNELFFBQVF5K0QsWUFBWXorRCxLQUF4QjtBQUNBLE9BQUk2eUQsU0FBUyxJQUFiO0FBQ0EsT0FBSThMLFFBQVEsQ0FBWjtBQUNBLE9BQUlDLGdCQUFnQixLQUFwQjtBQUNBLE9BQUlDLGNBQWNoTSxPQUFPcUwsWUFBUCxJQUF1QnJMLE9BQU9pTSxRQUFQLENBQWdCdjVDLFFBQXZDLElBQW1EazVDLFlBQVlsNUMsUUFBakY7QUFDQSxPQUFJdzVDLE9BQUo7O0FBRUEsT0FDRSxLQUFLaGxFLE1BQUwsQ0FBWTlELE1BQVosR0FBcUI4bUUsa0JBQXJCLElBQ0EwQixZQUFZdDNCLElBQVosS0FBcUJ2eEMsU0FEckIsS0FFQzZvRSxZQUFZdDNCLElBQVosQ0FBaUJ1akIsTUFBakIsS0FBNEI5MEQsU0FBNUIsSUFBeUM7QUFDMUM2b0UsZUFBWXQzQixJQUFaLENBQWlCOHBCLFFBQWpCLEtBQThCcjdELFNBSDlCLENBREYsQ0FJMkM7QUFKM0MsS0FLRTtBQUNBNm9FLG1CQUFZdDNCLElBQVosQ0FBaUJwdEMsTUFBakIsR0FBMEIsS0FBS0EsTUFBL0I7QUFDQWdsRSxpQkFBVSxLQUFLQyxzQkFBTCxDQUE0QnBILFlBQTVCLEVBQTBDLEtBQTFDLENBQVY7QUFDRCxNQVJELE1BUU87QUFDTG1ILGVBQVUsS0FBS0Msc0JBQUwsQ0FBNEJwSCxZQUE1QixDQUFWO0FBQ0Q7O0FBRUQsT0FBSTZHLFlBQVl0M0IsSUFBWixLQUFxQnZ4QyxTQUF6QixFQUFvQztBQUNsQ3V4QyxZQUFPODNCLGtCQUFrQlIsWUFBWXQzQixJQUE5QixDQUFQO0FBQ0Q7O0FBRUR1M0IsZ0JBQWEsZUFBYjtBQUNBLE9BQUlRLFlBQVksRUFBaEI7O0FBRUEsWUFBU0MsU0FBVCxDQUFtQkMsU0FBbkIsRUFBOEJDLE9BQTlCLEVBQXVDO0FBQ3JDeE0sWUFBTzRLLGVBQVA7O0FBRUEsU0FBSTZCLFlBQVksSUFBSXBpRSxJQUFKLEVBQWhCO0FBQ0EsU0FBSXFpRSxPQUFKOztBQUVBLFNBQUkxTSxPQUFPb0wsU0FBWCxFQUFzQjtBQUNwQnNCLGlCQUFVZCxZQUFZcGpFLEdBQXRCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQUl3M0QsT0FBT29MLFNBQVAsSUFBb0I5MkIsSUFBeEIsRUFBOEI7QUFDNUJvNEIsa0JBQVcsV0FBV0YsUUFBUWw0QixJQUE5QjtBQUNEOztBQUVEO0FBQ0EsU0FBSTByQixPQUFPb0wsU0FBUCxJQUFvQmorRCxLQUFwQixJQUE2QkEsTUFBTXUvRCxPQUFOLE1BQW1CM3BFLFNBQXBELEVBQStEO0FBQzdEOG9FLG9CQUFhLDZCQUFiO0FBQ0EsY0FBTzdMLE9BQU9MLFFBQVAsQ0FBZ0JsMkQsT0FBaEIsQ0FBd0JrQyxLQUFLa3dDLEtBQUwsQ0FBVzF1QyxNQUFNdS9ELE9BQU4sQ0FBWCxDQUF4QixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFJWixTQUFTOUwsT0FBT3NLLEtBQVAsQ0FBYXNCLFlBQVlwUSxRQUF6QixFQUFtQ3A0RCxNQUFoRCxFQUF3RDtBQUN0RCxXQUFJLENBQUM0b0UsV0FBRCxJQUFnQkQsYUFBcEIsRUFBbUM7QUFDakNGLHNCQUFhLDRCQUFiO0FBQ0E7QUFDQSxnQkFBTzdMLE9BQU9MLFFBQVAsQ0FBZ0JoMkQsTUFBaEIsQ0FBdUIsSUFBSTA3QyxPQUFPc1osa0JBQVgsQ0FDNUIsNkNBQ0Esd0VBREEsR0FFQSx1QkFGQSxHQUUwQnFCLE9BQU9vSyxhQUhMLEVBR29CLEVBQUNpQyxXQUFXQSxTQUFaLEVBSHBCLENBQXZCLENBQVA7QUFLRDs7QUFFRFIsb0JBQWEsdUJBQWI7O0FBRUE7QUFDQUMsZUFBUSxDQUFSOztBQUVBO0FBQ0FVLGVBQVFucUUsTUFBUixHQUFpQnVwRSxZQUFZbDVDLFFBQVosQ0FBcUJyd0IsTUFBdEM7QUFDQW1xRSxlQUFRaGtFLEdBQVIsR0FBY29qRSxZQUFZbDVDLFFBQVosQ0FBcUJscUIsR0FBbkM7QUFDQWdrRSxlQUFRRyxRQUFSLEdBQW1CZixZQUFZbDVDLFFBQVosQ0FBcUI0aEIsSUFBeEM7QUFDQSxXQUFJazRCLFFBQVFHLFFBQVosRUFBc0I7QUFDcEJILGlCQUFRbDRCLElBQVIsR0FBZTgzQixrQkFBa0JJLFFBQVFHLFFBQTFCLENBQWY7QUFDRDtBQUNEO0FBQ0FULGlCQUFVbE0sT0FBT21NLHNCQUFQLENBQThCcEgsWUFBOUIsQ0FBVjs7QUFFQXlILGVBQVE5QixRQUFSLEdBQW1CMUssT0FBTzRNLHNCQUFQLENBQThCaEIsWUFBWXBRLFFBQTFDLENBQW5CO0FBQ0F3RSxjQUFPNk0sbUJBQVAsQ0FBMkIsQ0FBM0IsRUFBOEJqQixZQUFZcFEsUUFBMUM7QUFDQXVRLHVCQUFnQixJQUFoQixDQTVCc0QsQ0E0QmhDO0FBQ3RCLGNBQU9PLFVBQVV0TSxPQUFPaU0sUUFBUCxDQUFnQnY1QyxRQUExQixFQUFvQzg1QyxPQUFwQyxDQUFQO0FBQ0Q7O0FBRUQsU0FBSU0sY0FBYzlNLE9BQU8rTSxjQUFQLENBQXNCbkIsWUFBWXBRLFFBQWxDLENBQWxCOztBQUVBLFNBQUloekQsTUFBTXNrRSxjQUFjTixRQUFRaGtFLEdBQWhDO0FBQ0EsU0FBSTBLLFVBQVU7QUFDWm9oQyxhQUFNazRCLFFBQVFsNEIsSUFERjtBQUVacTRCLGlCQUFVSCxRQUFRRyxRQUZOO0FBR1p0cUUsZUFBUW1xRSxRQUFRbnFFLE1BSEo7QUFJWjZwRSxnQkFBU0EsT0FKRztBQUtaeEIsaUJBQVU4QixRQUFROUIsUUFMTjtBQU1acG5FLGNBQU91b0U7QUFOSyxNQUFkOztBQVNBQSxrQkFBYSxnREFBYixFQUNFMzRELFFBQVE3USxNQURWLEVBQ2tCbUcsR0FEbEIsRUFDdUIwSyxRQUFRZzVELE9BRC9CLEVBQ3dDaDVELFFBQVF3M0QsUUFEaEQ7O0FBR0EsU0FBSTZCLGNBQWN2TSxPQUFPaU0sUUFBUCxDQUFnQnY1QyxRQUFsQyxFQUE0QztBQUMxQ201QyxvQkFBYSxnQkFBYjtBQUNEOztBQUVEO0FBQ0E7QUFDQSxZQUFPVSxVQUFVOXBFLElBQVYsQ0FBZXU5RCxNQUFmLEVBQXVCeDNELEdBQXZCLEVBQTRCMEssT0FBNUIsRUFBcUN2SyxJQUFyQyxDQUEwQ2c0RCxPQUExQyxFQUFtRHFNLFdBQW5ELENBQVA7O0FBRUEsY0FBU3JNLE9BQVQsQ0FBaUJzTSxZQUFqQixFQUErQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBSWxMLFNBQVNrTCxnQkFBZ0JBLGFBQWEzNEIsSUFBN0IsSUFBcUMyNEIsYUFBYTM0QixJQUFiLENBQWtCcWEsT0FBdkQsSUFBa0VzZSxhQUFhMzRCLElBQWIsQ0FBa0J5dEIsTUFBcEY7O0FBRVg7QUFDQTtBQUNBO0FBQ0FrTCxvQkFBYUMsVUFMRjs7QUFPWDtBQUNBO0FBQ0E7QUFDQUQsdUJBQWdCQSxhQUFhMzRCLElBQTdCLElBQXFDLEdBVnZDOztBQVlBdTNCLG9CQUFhLHlFQUFiLEVBQ0VvQixhQUFhQyxVQURmLEVBQzJCbkwsTUFEM0IsRUFDbUNrTCxhQUFhZixPQURoRDs7QUFHQSxXQUFJaUIsaUJBQWlCM2hFLEtBQUtDLEtBQUwsQ0FBV3MyRCxTQUFTLEdBQXBCLE1BQTZCLENBQWxEOztBQUVBLFdBQUlxTCxVQUFVLElBQUkvaUUsSUFBSixFQUFkO0FBQ0FnaUUsaUJBQVV0NEQsSUFBVixDQUFlO0FBQ2IrNEQsc0JBQWFBLFdBREE7QUFFYlosa0JBQVNtQixrQkFBa0JuQixPQUFsQixDQUZJO0FBR2J4MkIsa0JBQVNwQixRQUFRLElBSEo7QUFJYmc1Qix3QkFBZWg1QixTQUFTdnhDLFNBQVQsR0FBcUJ1eEMsS0FBS2x4QyxNQUExQixHQUFtQyxJQUpyQztBQUtiZixpQkFBUW1xRSxRQUFRbnFFLE1BTEg7QUFNYnFvRSxtQkFBVThCLFFBQVE5QixRQU5MO0FBT2JsaUUsY0FBS2drRSxRQUFRaGtFLEdBUEE7QUFRYmlrRSxvQkFBV0EsU0FSRTtBQVNiVyxrQkFBU0EsT0FUSTtBQVVicCtCLG1CQUFVbytCLFVBQVVYLFNBVlA7QUFXYlMscUJBQVluTDtBQVhDLFFBQWY7O0FBY0EsV0FBSW9MLGNBQUosRUFBb0I7QUFDbEIsYUFBSW5OLE9BQU9vTCxTQUFQLElBQW9CaitELEtBQXhCLEVBQStCO0FBQzdCQSxpQkFBTXUvRCxPQUFOLElBQWlCTyxhQUFhTSxZQUE5QjtBQUNEOztBQUVELGdCQUFPTixhQUFhMzRCLElBQXBCO0FBQ0Q7O0FBRUQsV0FBSWs1QixjQUFjaGlFLEtBQUtDLEtBQUwsQ0FBV3MyRCxTQUFTLEdBQXBCLE1BQTZCLENBQS9DOztBQUVBLFdBQUl5TCxXQUFKLEVBQWlCO0FBQ2YxQixrQkFBUyxDQUFUO0FBQ0EsZ0JBQU8yQixjQUFQO0FBQ0Q7O0FBRUQ1QixvQkFBYSxxQkFBYjs7QUFFQTtBQUNBLFdBQUk2QixxQkFBcUIsSUFBSXJvQixPQUFPc1osa0JBQVgsQ0FDdkJzTyxhQUFhMzRCLElBQWIsSUFBcUIyNEIsYUFBYTM0QixJQUFiLENBQWtCcWEsT0FEaEIsRUFDeUIsRUFBQzBkLFdBQVdBLFNBQVosRUFBdUJhLFlBQVluTCxNQUFuQyxFQUR6QixDQUF6Qjs7QUFJQSxjQUFPL0IsT0FBT0wsUUFBUCxDQUFnQmgyRCxNQUFoQixDQUF1QitqRSxrQkFBdkIsQ0FBUDtBQUNEOztBQUVELGNBQVNWLFdBQVQsQ0FBcUIvNEQsR0FBckIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTQzRCxvQkFBYSxzQkFBYixFQUFxQzUzRCxJQUFJMDZDLE9BQXpDLEVBQWtEMTZDLElBQUlrbEMsS0FBdEQ7O0FBRUEsV0FBSWkwQixVQUFVLElBQUkvaUUsSUFBSixFQUFkO0FBQ0FnaUUsaUJBQVV0NEQsSUFBVixDQUFlO0FBQ2IrNEQsc0JBQWFBLFdBREE7QUFFYlosa0JBQVNtQixrQkFBa0JuQixPQUFsQixDQUZJO0FBR2J4MkIsa0JBQVNwQixRQUFRLElBSEo7QUFJYmc1Qix3QkFBZWg1QixTQUFTdnhDLFNBQVQsR0FBcUJ1eEMsS0FBS2x4QyxNQUExQixHQUFtQyxJQUpyQztBQUtiZixpQkFBUW1xRSxRQUFRbnFFLE1BTEg7QUFNYnFvRSxtQkFBVThCLFFBQVE5QixRQU5MO0FBT2JsaUUsY0FBS2drRSxRQUFRaGtFLEdBUEE7QUFRYmlrRSxvQkFBV0EsU0FSRTtBQVNiVyxrQkFBU0EsT0FUSTtBQVVicCtCLG1CQUFVbytCLFVBQVVYO0FBVlAsUUFBZjs7QUFhQSxXQUFJLEVBQUV4NEQsZUFBZW94QyxPQUFPc1osa0JBQXhCLENBQUosRUFBaUQ7QUFDL0MxcUQsZUFBTSxJQUFJb3hDLE9BQU91Z0IsT0FBWCxDQUFtQjN4RCxPQUFPQSxJQUFJMDZDLE9BQTlCLEVBQXVDMTZDLEdBQXZDLENBQU47QUFDRDs7QUFFRDYzRCxnQkFBUyxDQUFUOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E3M0Qsc0JBQWVveEMsT0FBT3VnQixPQUF0Qjs7QUFFQTtBQUNBM3hELHNCQUFlb3hDLE9BQU9rZ0IsY0FIdEI7O0FBS0E7QUFDQXVHLGdCQUFTOUwsT0FBT3NLLEtBQVAsQ0FBYXNCLFlBQVlwUSxRQUF6QixFQUFtQ3A0RCxNQUE1QyxLQUNDMm9FLGlCQUFpQixDQUFDQyxXQURuQixDQVRGLEVBVW1DO0FBQ2pDO0FBQ0EvM0QsYUFBSW80RCxTQUFKLEdBQWdCQSxTQUFoQjtBQUNBLGdCQUFPck0sT0FBT0wsUUFBUCxDQUFnQmgyRCxNQUFoQixDQUF1QnNLLEdBQXZCLENBQVA7QUFDRDs7QUFFRDtBQUNBLFdBQUlBLGVBQWVveEMsT0FBT21nQixjQUExQixFQUEwQztBQUN4QyxnQkFBT21JLCtCQUFQO0FBQ0Q7O0FBRUQsY0FBT0YsY0FBUDtBQUNEOztBQUVELGNBQVNBLFlBQVQsR0FBd0I7QUFDdEI1QixvQkFBYSxrQkFBYjtBQUNBN0wsY0FBTzROLG1CQUFQLENBQTJCaEMsWUFBWXBRLFFBQXZDO0FBQ0EsY0FBTzhRLFVBQVVDLFNBQVYsRUFBcUJDLE9BQXJCLENBQVA7QUFDRDs7QUFFRCxjQUFTbUIsNkJBQVQsR0FBeUM7QUFDdkM5QixvQkFBYSxzQ0FBYjtBQUNBN0wsY0FBTzROLG1CQUFQLENBQTJCaEMsWUFBWXBRLFFBQXZDO0FBQ0F3RSxjQUFPNk4sMEJBQVA7QUFDQXJCLGVBQVE5QixRQUFSLEdBQW1CMUssT0FBTzRNLHNCQUFQLENBQThCaEIsWUFBWXBRLFFBQTFDLENBQW5CO0FBQ0EsY0FBTzhRLFVBQVVDLFNBQVYsRUFBcUJDLE9BQXJCLENBQVA7QUFDRDtBQUNGOztBQUVELE9BQUk1aUUsVUFBVTBpRSxVQUNadE0sT0FBT2lNLFFBREssRUFDSztBQUNmempFLFVBQUtvakUsWUFBWXBqRSxHQURGO0FBRWZuRyxhQUFRdXBFLFlBQVl2cEUsTUFGTDtBQUdmaXlDLFdBQU1BLElBSFM7QUFJZnE0QixlQUFVZixZQUFZdDNCLElBSlA7QUFLZm8yQixlQUFVMUssT0FBTzRNLHNCQUFQLENBQThCaEIsWUFBWXBRLFFBQTFDO0FBTEssSUFETCxDQUFkOztBQVVBO0FBQ0E7QUFDQSxPQUFJLE9BQU9vUSxZQUFZNTVDLFFBQW5CLEtBQWdDLFVBQXBDLEVBQWdEO0FBQzlDcG9CLGFBQVFqQixJQUFSLENBQWEsU0FBU21sRSxJQUFULENBQWNwNEIsT0FBZCxFQUF1QjtBQUNsQ21wQixtQkFBWSxZQUFXO0FBQ3JCK00scUJBQVk1NUMsUUFBWixDQUFxQixJQUFyQixFQUEyQjBqQixPQUEzQjtBQUNELFFBRkQsRUFFR3NxQixPQUFPYSxXQUFQLElBQXNCdHFELFVBRnpCO0FBR0QsTUFKRCxFQUlHLFNBQVN3M0QsTUFBVCxDQUFnQjk1RCxHQUFoQixFQUFxQjtBQUN0QjRxRCxtQkFBWSxZQUFXO0FBQ3JCK00scUJBQVk1NUMsUUFBWixDQUFxQi9kLEdBQXJCO0FBQ0QsUUFGRCxFQUVHK3JELE9BQU9hLFdBQVAsSUFBc0J0cUQsVUFGekI7QUFHRCxNQVJEO0FBU0QsSUFWRCxNQVVPO0FBQ0wsWUFBTzNNLE9BQVA7QUFDRDtBQUNGLEVBblJEOztBQXFSQTs7Ozs7O0FBTUF1eEQsbUJBQWtCMzRELFNBQWxCLENBQTRCMDVELGdCQUE1QixHQUErQyxVQUFTdGpELElBQVQsRUFBZWkvQyxNQUFmLEVBQXVCO0FBQ3BFLE9BQUlqL0MsU0FBUzdWLFNBQVQsSUFBc0I2VixTQUFTLElBQW5DLEVBQXlDO0FBQ3ZDLFlBQU9pL0MsTUFBUDtBQUNEO0FBQ0QsUUFBSyxJQUFJN3FELEdBQVQsSUFBZ0I0TCxJQUFoQixFQUFzQjtBQUNwQixTQUFJNUwsUUFBUSxJQUFSLElBQWdCNEwsS0FBSzVMLEdBQUwsTUFBY2pLLFNBQTlCLElBQTJDNlYsS0FBSzlMLGNBQUwsQ0FBb0JFLEdBQXBCLENBQS9DLEVBQXlFO0FBQ3ZFNnFELGlCQUFVQSxXQUFXLEVBQVgsR0FBZ0IsRUFBaEIsR0FBcUIsR0FBL0I7QUFDQUEsaUJBQVU3cUQsTUFBTSxHQUFOLEdBQVl2SSxtQkFBbUJzRixPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpCLENBQTBCeEksSUFBMUIsQ0FBK0JtVyxLQUFLNUwsR0FBTCxDQUEvQixNQUE4QyxnQkFBOUMsR0FBaUVvL0Qsa0JBQWtCeHpELEtBQUs1TCxHQUFMLENBQWxCLENBQWpFLEdBQWdHNEwsS0FBSzVMLEdBQUwsQ0FBbkgsQ0FBdEI7QUFDRDtBQUNGO0FBQ0QsVUFBTzZxRCxNQUFQO0FBQ0QsRUFYRDs7QUFhQXNELG1CQUFrQjM0RCxTQUFsQixDQUE0QjJwRSxzQkFBNUIsR0FBcUQsVUFBU3BILFlBQVQsRUFBdUJpSixVQUF2QixFQUFtQztBQUN0RixPQUFJL2pFLFVBQVUsbUJBQUF5ckQsQ0FBUSxFQUFSLENBQWQ7O0FBRUEsT0FBSXVZLEtBQUtsSixlQUNQLEtBQUtvRyxHQUFMLEdBQVcsR0FBWCxHQUFpQnBHLFlBRFYsR0FFUCxLQUFLb0csR0FGUDs7QUFJQSxPQUFJK0MsaUJBQWlCO0FBQ25CLHdCQUFtQkQsRUFEQTtBQUVuQixpQ0FBNEIsS0FBSzdEO0FBRmQsSUFBckI7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFJNEQsZUFBZSxLQUFuQixFQUEwQjtBQUN4QkUsb0JBQWUsbUJBQWYsSUFBc0MsS0FBS2huRSxNQUEzQztBQUNEOztBQUVELE9BQUksS0FBS2luRSxTQUFULEVBQW9CO0FBQ2xCRCxvQkFBZSxxQkFBZixJQUF3QyxLQUFLQyxTQUE3QztBQUNEOztBQUVELE9BQUksS0FBS0MsWUFBVCxFQUF1QjtBQUNyQkYsb0JBQWUsc0JBQWYsSUFBeUMsS0FBS0UsWUFBOUM7QUFDRDs7QUFFRG5rRSxXQUFRLEtBQUtnaEUsWUFBYixFQUEyQixTQUFTb0QsbUJBQVQsQ0FBNkJ2akUsS0FBN0IsRUFBb0NrQyxHQUFwQyxFQUF5QztBQUNsRWtoRSxvQkFBZWxoRSxHQUFmLElBQXNCbEMsS0FBdEI7QUFDRCxJQUZEOztBQUlBLFVBQU9vakUsY0FBUDtBQUNELEVBakNEOztBQW1DQTs7Ozs7Ozs7O0FBU0EvUyxtQkFBa0IzNEQsU0FBbEIsQ0FBNEJ1MUQsTUFBNUIsR0FBcUMsVUFBU3VXLE9BQVQsRUFBa0J0NUQsSUFBbEIsRUFBd0JnZCxRQUF4QixFQUFrQztBQUNyRSxPQUFJdGlCLFVBQVUsbUJBQUFnbUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxPQUFJdnBELE1BQU0sbUJBQUF1cEQsQ0FBUSxFQUFSLENBQVY7O0FBRUEsT0FBSW9ILFFBQVEsa0RBQVo7O0FBRUEsT0FBSSxDQUFDcHRELFFBQVE0K0QsT0FBUixDQUFMLEVBQXVCO0FBQ3JCLFdBQU0sSUFBSW5uQixLQUFKLENBQVUyVixLQUFWLENBQU47QUFDRDs7QUFFRCxPQUFJLE9BQU85bkQsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QmdkLGdCQUFXaGQsSUFBWDtBQUNBQSxZQUFPLEVBQVA7QUFDRCxJQUhELE1BR08sSUFBSUEsU0FBU2pTLFNBQWIsRUFBd0I7QUFDN0JpUyxZQUFPLEVBQVA7QUFDRDs7QUFFRCxPQUFJZ3JELFNBQVMsSUFBYjs7QUFFQSxPQUFJcEUsVUFBVTtBQUNad0MsZUFBVWp5RCxJQUFJbWlFLE9BQUosRUFBYSxTQUFTeE8sY0FBVCxDQUF3Qm40RCxLQUF4QixFQUErQjtBQUNwRCxXQUFJa3dELFNBQVMsRUFBYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFJbHdELE1BQU1BLEtBQU4sS0FBZ0I1RSxTQUFwQixFQUErQjtBQUM3QjgwRCxtQkFBVSxXQUFXcHpELG1CQUFtQmtELE1BQU1BLEtBQXpCLENBQXJCO0FBQ0Q7O0FBRUQsY0FBTztBQUNMMnpELG9CQUFXM3pELE1BQU0yekQsU0FEWjtBQUVMekQsaUJBQVFtSSxPQUFPOUQsZ0JBQVAsQ0FBd0J2MEQsTUFBTWt3RCxNQUE5QixFQUFzQ0EsTUFBdEM7QUFGSCxRQUFQO0FBSUQsTUFkUztBQURFLElBQWQ7O0FBa0JBLE9BQUkwVyxjQUFjcGlFLElBQUl5dkQsUUFBUXdDLFFBQVosRUFBc0IsU0FBU29RLGtCQUFULENBQTRCbm1FLE9BQTVCLEVBQXFDb21FLFNBQXJDLEVBQWdEO0FBQ3RGLFlBQU9BLFlBQVksR0FBWixHQUNMaHFFLG1CQUNFLGdCQUFnQkEsbUJBQW1CNEQsUUFBUWl6RCxTQUEzQixDQUFoQixHQUF3RCxHQUF4RCxHQUNBanpELFFBQVF3dkQsTUFGVixDQURGO0FBS0QsSUFOaUIsRUFNZnhvRCxJQU5lLENBTVYsR0FOVSxDQUFsQjs7QUFRQSxPQUFJN0csTUFBTSxzQkFBVjs7QUFFQSxPQUFJd00sS0FBSzA1RCxRQUFMLEtBQWtCM3JFLFNBQXRCLEVBQWlDO0FBQy9CeUYsWUFBTyxlQUFld00sS0FBSzA1RCxRQUEzQjtBQUNEOztBQUVELFVBQU8sS0FBS25ULFlBQUwsQ0FBa0I7QUFDdkJwdUQsWUFBTyxLQUFLQSxLQURXO0FBRXZCOUssYUFBUSxNQUZlO0FBR3ZCbUcsVUFBS0EsR0FIa0I7QUFJdkI4ckMsV0FBTXNuQixPQUppQjtBQUt2QkosZUFBVSxNQUxhO0FBTXZCOW9DLGVBQVU7QUFDUnJ3QixlQUFRLEtBREE7QUFFUm1HLFlBQUssY0FGRztBQUdSOHJDLGFBQU07QUFDSnVqQixpQkFBUTBXO0FBREo7QUFIRSxNQU5hO0FBYXZCdjhDLGVBQVVBO0FBYmEsSUFBbEIsQ0FBUDtBQWVELEVBbEVEOztBQW9FQTs7OztBQUlBbXBDLG1CQUFrQjM0RCxTQUFsQixDQUE0Qm1zRSxlQUE1QixHQUE4QyxVQUFTQyxJQUFULEVBQWU7QUFDM0QsT0FBSTdrRSxPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpCLENBQTBCeEksSUFBMUIsQ0FBK0Jtc0UsSUFBL0IsTUFBeUMsZ0JBQTdDLEVBQStEO0FBQzdELFNBQUlDLFVBQVUsRUFBZDtBQUNBLFVBQUssSUFBSTFyRSxJQUFJLENBQWIsRUFBZ0JBLElBQUl5ckUsS0FBS3hyRSxNQUF6QixFQUFpQyxFQUFFRCxDQUFuQyxFQUFzQztBQUNwQyxXQUFJNEcsT0FBT3ZILFNBQVAsQ0FBaUJ5SSxRQUFqQixDQUEwQnhJLElBQTFCLENBQStCbXNFLEtBQUt6ckUsQ0FBTCxDQUEvQixNQUE0QyxnQkFBaEQsRUFBa0U7QUFDaEUsYUFBSTJyRSxXQUFXLEVBQWY7QUFDQSxjQUFLLElBQUl2a0QsSUFBSSxDQUFiLEVBQWdCQSxJQUFJcWtELEtBQUt6ckUsQ0FBTCxFQUFRQyxNQUE1QixFQUFvQyxFQUFFbW5CLENBQXRDLEVBQXlDO0FBQ3ZDdWtELG9CQUFTLzZELElBQVQsQ0FBYzY2RCxLQUFLenJFLENBQUwsRUFBUW9uQixDQUFSLENBQWQ7QUFDRDtBQUNEc2tELGlCQUFROTZELElBQVIsQ0FBYSxNQUFNKzZELFNBQVN6L0QsSUFBVCxDQUFjLEdBQWQsQ0FBTixHQUEyQixHQUF4QztBQUNELFFBTkQsTUFNTztBQUNMdy9ELGlCQUFROTZELElBQVIsQ0FBYTY2RCxLQUFLenJFLENBQUwsQ0FBYjtBQUNEO0FBQ0Y7QUFDRHlyRSxZQUFPQyxRQUFReC9ELElBQVIsQ0FBYSxHQUFiLENBQVA7QUFDRDs7QUFFRCxRQUFLKytELFlBQUwsR0FBb0JRLElBQXBCO0FBQ0QsRUFsQkQ7O0FBb0JBOzs7O0FBSUF6VCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEJ1c0UsWUFBNUIsR0FBMkMsVUFBU1osU0FBVCxFQUFvQjtBQUM3RCxRQUFLQSxTQUFMLEdBQWlCQSxTQUFqQjtBQUNELEVBRkQ7O0FBSUE7Ozs7QUFJQWhULG1CQUFrQjM0RCxTQUFsQixDQUE0QnMxRCxVQUE1QixHQUF5QyxZQUFXO0FBQ2xELFFBQUszcUQsS0FBTCxHQUFhLEVBQWI7QUFDRCxFQUZEOztBQUlBOzs7OztBQUtBZ3VELG1CQUFrQjM0RCxTQUFsQixDQUE0QndzRSxpQkFBNUIsR0FBZ0QsVUFBU0MsWUFBVCxFQUF1QjtBQUNyRSxPQUFJQSxZQUFKLEVBQWtCO0FBQ2hCLFVBQUt4RSxTQUFMLENBQWVFLE9BQWYsR0FBeUIsS0FBS0YsU0FBTCxDQUFlRixJQUFmLEdBQXNCLEtBQUtFLFNBQUwsQ0FBZUQsS0FBZixHQUF1QnlFLFlBQXRFO0FBQ0Q7QUFDRixFQUpEOztBQU1BOzs7O0FBSUE5VCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEIwc0UsV0FBNUIsR0FBMEMsVUFBU3hFLFFBQVQsRUFBbUI7QUFDM0QsUUFBS0QsU0FBTCxHQUFpQkMsUUFBakI7QUFDRCxFQUZEOztBQUlBOzs7O0FBSUF2UCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEIyc0UsV0FBNUIsR0FBMEMsWUFBVztBQUNuRCxVQUFPLEtBQUsxRSxTQUFaO0FBQ0QsRUFGRDs7QUFJQXRQLG1CQUFrQjM0RCxTQUFsQixDQUE0QjRzRSxhQUE1QixHQUE0QyxZQUFXO0FBQ3JELE9BQUkxbUUsT0FBT3VoRSxNQUFNaDFELEdBQU4sQ0FBVSxLQUFLbTFELGFBQWYsQ0FBWDtBQUNBLE9BQUkxaEUsU0FBUyxJQUFiLEVBQW1CLEtBQUsybUUsZUFBTCxDQUFxQjNtRSxJQUFyQjtBQUNuQixVQUFPQSxJQUFQO0FBQ0QsRUFKRDs7QUFNQXl5RCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEI4c0UsYUFBNUIsR0FBNEMsVUFBUzVtRSxJQUFULEVBQWU7QUFDekRBLFFBQUs2bUUsVUFBTCxHQUFtQixJQUFJbGxFLElBQUosRUFBRCxDQUFhbWxFLE9BQWIsRUFBbEI7QUFDQSxRQUFLSCxlQUFMLENBQXFCM21FLElBQXJCO0FBQ0EsVUFBT3VoRSxNQUFNN3lELEdBQU4sQ0FBVSxLQUFLZ3pELGFBQWYsRUFBOEIxaEUsSUFBOUIsQ0FBUDtBQUNELEVBSkQ7O0FBTUF5eUQsbUJBQWtCMzRELFNBQWxCLENBQTRCb29FLGVBQTVCLEdBQThDLFlBQVc7QUFDdkQsT0FBSWxpRSxPQUFPLEtBQUswbUUsYUFBTCxFQUFYO0FBQ0EsT0FBSWhsRSxNQUFPLElBQUlDLElBQUosRUFBRCxDQUFhbWxFLE9BQWIsRUFBVjtBQUNBLE9BQUk5bUUsU0FBUyxJQUFULElBQWlCMEIsTUFBTTFCLEtBQUs2bUUsVUFBWCxHQUF3QnBGLG9CQUE3QyxFQUFtRTtBQUNqRSxZQUFPLEtBQUtzRixzQkFBTCxDQUE0Qi9tRSxJQUE1QixDQUFQO0FBQ0Q7O0FBRUQsVUFBT0EsSUFBUDtBQUNELEVBUkQ7O0FBVUF5eUQsbUJBQWtCMzRELFNBQWxCLENBQTRCaXRFLHNCQUE1QixHQUFxRCxVQUFTL21FLElBQVQsRUFBZTtBQUNsRSxPQUFJcW1CLFVBQVVybUIsUUFBUSxFQUF0QjtBQUNBcW1CLFdBQVEyZ0QsV0FBUixHQUFzQixFQUFDbkYsTUFBTSxDQUFQLEVBQVVDLE9BQU8sQ0FBakIsRUFBdEI7QUFDQXo3QyxXQUFRNGdELGlCQUFSLEdBQTRCLENBQTVCO0FBQ0E1Z0QsV0FBUTZnRCxhQUFSLEdBQXdCN2dELFFBQVE2Z0QsYUFBUixJQUF5QkMsUUFBUSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFSLENBQWpEO0FBQ0EsVUFBTyxLQUFLUCxhQUFMLENBQW1CdmdELE9BQW5CLENBQVA7QUFDRCxFQU5EOztBQVFBb3NDLG1CQUFrQjM0RCxTQUFsQixDQUE0QjZzRSxlQUE1QixHQUE4QyxVQUFTM21FLElBQVQsRUFBZTtBQUMzRCxRQUFLb25FLFlBQUwsR0FBb0JwbkUsS0FBS2duRSxXQUF6QjtBQUNBLFFBQUtLLGtCQUFMLEdBQTBCcm5FLEtBQUtpbkUsaUJBQS9CO0FBQ0EsUUFBSzdFLGNBQUwsR0FBc0JwaUUsS0FBS2tuRSxhQUEzQjtBQUNELEVBSkQ7O0FBTUF6VSxtQkFBa0IzNEQsU0FBbEIsQ0FBNEJ3dEUsdUJBQTVCLEdBQXNELFVBQVNqaEQsT0FBVCxFQUFrQjtBQUN0RSxPQUFJbTNDLFVBQVUsbUJBQUF4USxDQUFRLEVBQVIsQ0FBZDtBQUNBLE9BQUl1YSxjQUFjLEtBQUtiLGFBQUwsRUFBbEI7QUFDQWxKLFdBQVFuM0MsT0FBUixFQUFpQixVQUFTamtCLEtBQVQsRUFBZ0JrQyxHQUFoQixFQUFxQjtBQUNwQ2lqRSxpQkFBWWpqRSxHQUFaLElBQW1CbEMsS0FBbkI7QUFDRCxJQUZEOztBQUlBLFVBQU8sS0FBS3drRSxhQUFMLENBQW1CVyxXQUFuQixDQUFQO0FBQ0QsRUFSRDs7QUFVQTlVLG1CQUFrQjM0RCxTQUFsQixDQUE0QnVxRSxjQUE1QixHQUE2QyxVQUFTdlIsUUFBVCxFQUFtQjtBQUM5RCxVQUFPLEtBQUs4TyxLQUFMLENBQVc5TyxRQUFYLEVBQXFCLEtBQUswVSxtQkFBTCxDQUF5QjFVLFFBQXpCLENBQXJCLENBQVA7QUFDRCxFQUZEOztBQUlBTCxtQkFBa0IzNEQsU0FBbEIsQ0FBNEIydEUscUJBQTVCLEdBQW9ELFlBQVc7QUFDN0QsVUFBTyxLQUFLSixrQkFBWjtBQUNELEVBRkQ7O0FBSUE1VSxtQkFBa0IzNEQsU0FBbEIsQ0FBNEIwdEUsbUJBQTVCLEdBQWtELFVBQVMxVSxRQUFULEVBQW1CO0FBQ25FLFVBQU8sS0FBS3NVLFlBQUwsQ0FBa0J0VSxRQUFsQixDQUFQO0FBQ0QsRUFGRDs7QUFJQUwsbUJBQWtCMzRELFNBQWxCLENBQTRCcXFFLG1CQUE1QixHQUFrRCxVQUFTdUQsU0FBVCxFQUFvQjVVLFFBQXBCLEVBQThCO0FBQzlFLE9BQUl4bUIsUUFBUSxtQkFBQTBnQixDQUFRLEVBQVIsQ0FBWjtBQUNBLE9BQUkyYSxpQkFBaUJyN0IsTUFBTSxLQUFLODZCLFlBQVgsQ0FBckI7QUFDQU8sa0JBQWU3VSxRQUFmLElBQTJCNFUsU0FBM0I7QUFDQSxRQUFLSix1QkFBTCxDQUE2QixFQUFDTixhQUFhVyxjQUFkLEVBQTdCO0FBQ0EsVUFBT0QsU0FBUDtBQUNELEVBTkQ7O0FBUUFqVixtQkFBa0IzNEQsU0FBbEIsQ0FBNEJvckUsbUJBQTVCLEdBQWtELFVBQVNwUyxRQUFULEVBQW1CO0FBQ25FLFVBQU8sS0FBS3FSLG1CQUFMLENBQ0wsQ0FBQyxLQUFLcUQsbUJBQUwsQ0FBeUIxVSxRQUF6QixJQUFxQyxDQUF0QyxJQUEyQyxLQUFLOE8sS0FBTCxDQUFXOU8sUUFBWCxFQUFxQnA0RCxNQUQzRCxFQUNtRW80RCxRQURuRSxDQUFQO0FBR0QsRUFKRDs7QUFNQUwsbUJBQWtCMzRELFNBQWxCLENBQTRCcXJFLDBCQUE1QixHQUF5RCxZQUFXO0FBQ2xFLE9BQUk4QixvQkFBb0Jua0UsS0FBS3VQLEdBQUwsQ0FBUyxLQUFLZzFELGtCQUFMLEdBQTBCLENBQW5DLEVBQXNDLENBQXRDLENBQXhCO0FBQ0EsVUFBTyxLQUFLQyx1QkFBTCxDQUE2QixFQUFDTCxtQkFBbUJBLGlCQUFwQixFQUE3QixDQUFQO0FBQ0QsRUFIRDs7QUFLQXhVLG1CQUFrQjM0RCxTQUFsQixDQUE0Qm9xRSxzQkFBNUIsR0FBcUQsVUFBU3BSLFFBQVQsRUFBbUI7QUFDdEUsVUFBTztBQUNMbVAsY0FBUyxLQUFLRixTQUFMLENBQWVFLE9BQWYsR0FBeUIsS0FBS29GLGtCQURsQztBQUVMTyxlQUFVLEtBQUs3RixTQUFMLENBQWVqUCxRQUFmLElBQTJCLEtBQUt1VTtBQUZyQyxJQUFQO0FBSUQsRUFMRDs7QUFPQSxVQUFTL0UsV0FBVCxDQUFxQnZULFFBQXJCLEVBQStCO0FBQzdCLFVBQU8sU0FBUzhZLE9BQVQsQ0FBaUJDLElBQWpCLEVBQXVCO0FBQzVCLFlBQU8vWSxXQUFXLElBQVgsR0FBa0IrWSxLQUFLamtFLFdBQUwsRUFBekI7QUFDRCxJQUZEO0FBR0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTNi9ELGlCQUFULENBQTJCanFFLEdBQTNCLEVBQWdDO0FBQzlCOztBQUVBLE9BQUlvTSxNQUFNL0wsU0FBTixDQUFnQml1RSxNQUFoQixLQUEyQjF0RSxTQUEvQixFQUEwQztBQUN4QyxZQUFPNEksS0FBS0MsU0FBTCxDQUFlekosR0FBZixDQUFQO0FBQ0Q7O0FBRUQsT0FBSXN1RSxTQUFTbGlFLE1BQU0vTCxTQUFOLENBQWdCaXVFLE1BQTdCO0FBQ0EsVUFBT2xpRSxNQUFNL0wsU0FBTixDQUFnQml1RSxNQUF2QjtBQUNBLE9BQUlDLE1BQU0va0UsS0FBS0MsU0FBTCxDQUFlekosR0FBZixDQUFWO0FBQ0FvTSxTQUFNL0wsU0FBTixDQUFnQml1RSxNQUFoQixHQUF5QkEsTUFBekI7O0FBRUEsVUFBT0MsR0FBUDtBQUNEOztBQUVELFVBQVNiLE9BQVQsQ0FBaUI3bkIsS0FBakIsRUFBd0I7QUFDdEIsT0FBSTJvQixlQUFlM29CLE1BQU01a0QsTUFBekI7QUFDQSxPQUFJd3RFLGNBQUo7QUFDQSxPQUFJQyxXQUFKOztBQUVBO0FBQ0EsVUFBT0YsaUJBQWlCLENBQXhCLEVBQTJCO0FBQ3pCO0FBQ0FFLG1CQUFjcmxFLEtBQUtDLEtBQUwsQ0FBV0QsS0FBS2tyRCxNQUFMLEtBQWdCaWEsWUFBM0IsQ0FBZDtBQUNBQSxxQkFBZ0IsQ0FBaEI7O0FBRUE7QUFDQUMsc0JBQWlCNW9CLE1BQU0yb0IsWUFBTixDQUFqQjtBQUNBM29CLFdBQU0yb0IsWUFBTixJQUFzQjNvQixNQUFNNm9CLFdBQU4sQ0FBdEI7QUFDQTdvQixXQUFNNm9CLFdBQU4sSUFBcUJELGNBQXJCO0FBQ0Q7O0FBRUQsVUFBTzVvQixLQUFQO0FBQ0Q7O0FBRUQsVUFBU3FsQixpQkFBVCxDQUEyQm5CLE9BQTNCLEVBQW9DO0FBQ2xDLE9BQUk0RSxhQUFhLEVBQWpCOztBQUVBLFFBQUssSUFBSUMsVUFBVCxJQUF1QjdFLE9BQXZCLEVBQWdDO0FBQzlCLFNBQUluaUUsT0FBT3ZILFNBQVAsQ0FBaUJzSyxjQUFqQixDQUFnQ3JLLElBQWhDLENBQXFDeXBFLE9BQXJDLEVBQThDNkUsVUFBOUMsQ0FBSixFQUErRDtBQUM3RCxXQUFJam1FLEtBQUo7O0FBRUEsV0FBSWltRSxlQUFlLG1CQUFmLElBQXNDQSxlQUFlLDBCQUF6RCxFQUFxRjtBQUNuRmptRSxpQkFBUSxrQ0FBUjtBQUNELFFBRkQsTUFFTztBQUNMQSxpQkFBUW9oRSxRQUFRNkUsVUFBUixDQUFSO0FBQ0Q7O0FBRURELGtCQUFXQyxVQUFYLElBQXlCam1FLEtBQXpCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFPZ21FLFVBQVA7QUFDRCxFOzs7Ozs7Ozs7QUNyeUJELEtBQUl4dEUsUUFBUSxtQkFBQW95RCxDQUFRLEVBQVIsRUFBaUIscUNBQWpCLENBQVo7QUFDQSxLQUFJc2Isd0JBQXdCLHlCQUE1Qjs7QUFFQSxLQUFJL0csS0FBSjtBQUNBLEtBQUlnSCxjQUFjO0FBQ2hCNXVCLFVBQU8sRUFEUztBQUVoQmpyQyxRQUFLLGFBQVNwSyxHQUFULEVBQWN0RSxJQUFkLEVBQW9CO0FBQ3ZCLFVBQUsyNUMsS0FBTCxDQUFXcjFDLEdBQVgsSUFBa0J0RSxJQUFsQjtBQUNBLFlBQU8sS0FBSzI1QyxLQUFMLENBQVdyMUMsR0FBWCxDQUFQO0FBQ0QsSUFMZTtBQU1oQmlJLFFBQUssYUFBU2pJLEdBQVQsRUFBYztBQUNqQixZQUFPLEtBQUtxMUMsS0FBTCxDQUFXcjFDLEdBQVgsS0FBbUIsSUFBMUI7QUFDRDtBQVJlLEVBQWxCOztBQVdBLEtBQUlra0Usb0JBQW9CO0FBQ3RCOTVELFFBQUssYUFBU3BLLEdBQVQsRUFBY3RFLElBQWQsRUFBb0I7QUFDdkJ1b0UsaUJBQVk3NUQsR0FBWixDQUFnQnBLLEdBQWhCLEVBQXFCdEUsSUFBckIsRUFEdUIsQ0FDSzs7QUFFNUIsU0FBSTtBQUNGLFdBQUk2eUIsWUFBWTV2QixLQUFLa3dDLEtBQUwsQ0FBV3htQyxPQUFPaFIsWUFBUCxDQUFvQjJzRSxxQkFBcEIsQ0FBWCxDQUFoQjtBQUNBejFDLGlCQUFVdnVCLEdBQVYsSUFBaUJ0RSxJQUFqQjtBQUNBMk0sY0FBT2hSLFlBQVAsQ0FBb0Iyc0UscUJBQXBCLElBQTZDcmxFLEtBQUtDLFNBQUwsQ0FBZTJ2QixTQUFmLENBQTdDO0FBQ0EsY0FBT0EsVUFBVXZ1QixHQUFWLENBQVA7QUFDRCxNQUxELENBS0UsT0FBT3RLLENBQVAsRUFBVTtBQUNWLGNBQU95dUUsb0JBQW9CbmtFLEdBQXBCLEVBQXlCdEssQ0FBekIsQ0FBUDtBQUNEO0FBQ0YsSUFacUI7QUFhdEJ1UyxRQUFLLGFBQVNqSSxHQUFULEVBQWM7QUFDakIsU0FBSTtBQUNGLGNBQU9yQixLQUFLa3dDLEtBQUwsQ0FBV3htQyxPQUFPaFIsWUFBUCxDQUFvQjJzRSxxQkFBcEIsQ0FBWCxFQUF1RGhrRSxHQUF2RCxLQUErRCxJQUF0RTtBQUNELE1BRkQsQ0FFRSxPQUFPdEssQ0FBUCxFQUFVO0FBQ1YsY0FBT3l1RSxvQkFBb0Jua0UsR0FBcEIsRUFBeUJ0SyxDQUF6QixDQUFQO0FBQ0Q7QUFDRjtBQW5CcUIsRUFBeEI7O0FBc0JBLFVBQVN5dUUsbUJBQVQsQ0FBNkJua0UsR0FBN0IsRUFBa0N0SyxDQUFsQyxFQUFxQztBQUNuQ1ksU0FBTSwwQkFBTixFQUFrQ1osQ0FBbEM7QUFDQTB1RTtBQUNBbkgsV0FBUWdILFdBQVI7QUFDQSxVQUFPaEgsTUFBTWgxRCxHQUFOLENBQVVqSSxHQUFWLENBQVA7QUFDRDs7QUFFRGk5RCxTQUFRb0gseUJBQXlCSCxpQkFBekIsR0FBNkNELFdBQXJEOztBQUVBcnZFLFFBQU9DLE9BQVAsR0FBaUI7QUFDZm9ULFFBQUtxOEQsUUFEVTtBQUVmbDZELFFBQUtrNkQsUUFGVTtBQUdmRCx5QkFBc0JBO0FBSFAsRUFBakI7O0FBTUEsVUFBU0MsUUFBVCxDQUFrQnRrRSxHQUFsQixFQUF1QnRFLElBQXZCLEVBQTZCO0FBQzNCLE9BQUk5RixVQUFVUSxNQUFWLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLFlBQU82bUUsTUFBTWgxRCxHQUFOLENBQVVqSSxHQUFWLENBQVA7QUFDRDs7QUFFRCxVQUFPaTlELE1BQU03eUQsR0FBTixDQUFVcEssR0FBVixFQUFldEUsSUFBZixDQUFQO0FBQ0Q7O0FBRUQsVUFBUzJvRSxvQkFBVCxHQUFnQztBQUM5QixPQUFJO0FBQ0YsU0FBSSxrQkFBa0JoOEQsTUFBbEIsSUFDRkEsT0FBT2hSLFlBQVAsS0FBd0IsSUFEMUIsRUFDZ0M7QUFDOUIsV0FBSSxDQUFDZ1IsT0FBT2hSLFlBQVAsQ0FBb0Iyc0UscUJBQXBCLENBQUwsRUFBaUQ7QUFDL0M7QUFDQTM3RCxnQkFBT2hSLFlBQVAsQ0FBb0JrdEUsT0FBcEIsQ0FBNEJQLHFCQUE1QixFQUFtRHJsRSxLQUFLQyxTQUFMLENBQWUsRUFBZixDQUFuRDtBQUNEO0FBQ0QsY0FBTyxJQUFQO0FBQ0Q7O0FBRUQsWUFBTyxLQUFQO0FBQ0QsSUFYRCxDQVdFLE9BQU82QixDQUFQLEVBQVU7QUFDVixZQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQSxVQUFTMmpFLE9BQVQsR0FBbUI7QUFDakIsT0FBSTtBQUNGLzdELFlBQU9oUixZQUFQLENBQW9CbXRFLFVBQXBCLENBQStCUixxQkFBL0I7QUFDRCxJQUZELENBRUUsT0FBT3ZqRSxDQUFQLEVBQVU7QUFDVjtBQUNEO0FBQ0YsRTs7Ozs7Ozs7Ozs7QUNyRkQ7Ozs7OztBQU1BNUwsV0FBVUQsT0FBT0MsT0FBUCxHQUFpQixtQkFBQTZ6RCxDQUFRLEVBQVIsQ0FBM0I7QUFDQTd6RCxTQUFRQyxHQUFSLEdBQWNBLEdBQWQ7QUFDQUQsU0FBUTR2RSxVQUFSLEdBQXFCQSxVQUFyQjtBQUNBNXZFLFNBQVE2dkUsSUFBUixHQUFlQSxJQUFmO0FBQ0E3dkUsU0FBUTh2RSxJQUFSLEdBQWVBLElBQWY7QUFDQTl2RSxTQUFRK3ZFLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0EvdkUsU0FBUWd3RSxPQUFSLEdBQWtCLGVBQWUsT0FBT3hxRSxNQUF0QixJQUNBLGVBQWUsT0FBT0EsT0FBT3dxRSxPQUQ3QixHQUVFeHFFLE9BQU93cUUsT0FBUCxDQUFlcHJFLEtBRmpCLEdBR0VxckUsY0FIcEI7O0FBS0E7Ozs7QUFJQWp3RSxTQUFRa3dFLE1BQVIsR0FBaUIsQ0FDZixlQURlLEVBRWYsYUFGZSxFQUdmLFdBSGUsRUFJZixZQUplLEVBS2YsWUFMZSxFQU1mLFNBTmUsQ0FBakI7O0FBU0E7Ozs7Ozs7O0FBUUEsVUFBU0gsU0FBVCxHQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxPQUFJLE9BQU94dEUsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT3FNLE9BQXhDLElBQW1Eck0sT0FBT3FNLE9BQVAsQ0FBZTRMLElBQWYsS0FBd0IsVUFBL0UsRUFBMkY7QUFDekYsWUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQVEsT0FBTzlYLFFBQVAsS0FBb0IsV0FBcEIsSUFBbUNBLFNBQVNxaUQsZUFBNUMsSUFBK0RyaUQsU0FBU3FpRCxlQUFULENBQXlCdGQsS0FBeEYsSUFBaUcva0MsU0FBU3FpRCxlQUFULENBQXlCdGQsS0FBekIsQ0FBK0Iwb0MsZ0JBQWpJO0FBQ0w7QUFDQyxVQUFPNXRFLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE9BQU90QixPQUF4QyxLQUFvRHNCLE9BQU90QixPQUFQLENBQWVtdkUsT0FBZixJQUEyQjd0RSxPQUFPdEIsT0FBUCxDQUFlNm9ELFNBQWYsSUFBNEJ2bkQsT0FBT3RCLE9BQVAsQ0FBZW92RSxLQUExSCxDQUZJO0FBR0w7QUFDQTtBQUNDLFVBQU83OUQsU0FBUCxLQUFxQixXQUFyQixJQUFvQ0EsVUFBVUMsU0FBOUMsSUFBMkRELFVBQVVDLFNBQVYsQ0FBb0IvSCxXQUFwQixHQUFrQ2lILEtBQWxDLENBQXdDLGdCQUF4QyxDQUEzRCxJQUF3SGl1QyxTQUFTM3BCLE9BQU9xNkMsRUFBaEIsRUFBb0IsRUFBcEIsS0FBMkIsRUFML0k7QUFNTDtBQUNDLFVBQU85OUQsU0FBUCxLQUFxQixXQUFyQixJQUFvQ0EsVUFBVUMsU0FBOUMsSUFBMkRELFVBQVVDLFNBQVYsQ0FBb0IvSCxXQUFwQixHQUFrQ2lILEtBQWxDLENBQXdDLG9CQUF4QyxDQVA5RDtBQVFEOztBQUVEOzs7O0FBSUEzUixTQUFRdXdFLFVBQVIsQ0FBbUI3bkQsQ0FBbkIsR0FBdUIsVUFBUzlmLENBQVQsRUFBWTtBQUNqQyxPQUFJO0FBQ0YsWUFBT2tCLEtBQUtDLFNBQUwsQ0FBZW5CLENBQWYsQ0FBUDtBQUNELElBRkQsQ0FFRSxPQUFPd0osR0FBUCxFQUFZO0FBQ1osWUFBTyxpQ0FBaUNBLElBQUkwNkMsT0FBNUM7QUFDRDtBQUNGLEVBTkQ7O0FBU0E7Ozs7OztBQU1BLFVBQVM4aUIsVUFBVCxDQUFvQjc0RCxJQUFwQixFQUEwQjtBQUN4QixPQUFJZzVELFlBQVksS0FBS0EsU0FBckI7O0FBRUFoNUQsUUFBSyxDQUFMLElBQVUsQ0FBQ2c1RCxZQUFZLElBQVosR0FBbUIsRUFBcEIsSUFDTixLQUFLcjJDLFNBREMsSUFFTHEyQyxZQUFZLEtBQVosR0FBb0IsR0FGZixJQUdOaDVELEtBQUssQ0FBTCxDQUhNLElBSUxnNUQsWUFBWSxLQUFaLEdBQW9CLEdBSmYsSUFLTixHQUxNLEdBS0EvdkUsUUFBUXd3RSxRQUFSLENBQWlCLEtBQUtDLElBQXRCLENBTFY7O0FBT0EsT0FBSSxDQUFDVixTQUFMLEVBQWdCOztBQUVoQixPQUFJbGtFLElBQUksWUFBWSxLQUFLNmtFLEtBQXpCO0FBQ0EzNUQsUUFBSy9MLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQmEsQ0FBbEIsRUFBcUIsZ0JBQXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQUl2RyxRQUFRLENBQVo7QUFDQSxPQUFJcXJFLFFBQVEsQ0FBWjtBQUNBNTVELFFBQUssQ0FBTCxFQUFRcEwsT0FBUixDQUFnQixhQUFoQixFQUErQixVQUFTZ0csS0FBVCxFQUFnQjtBQUM3QyxTQUFJLFNBQVNBLEtBQWIsRUFBb0I7QUFDcEJyTTtBQUNBLFNBQUksU0FBU3FNLEtBQWIsRUFBb0I7QUFDbEI7QUFDQTtBQUNBZy9ELGVBQVFyckUsS0FBUjtBQUNEO0FBQ0YsSUFSRDs7QUFVQXlSLFFBQUsvTCxNQUFMLENBQVkybEUsS0FBWixFQUFtQixDQUFuQixFQUFzQjlrRSxDQUF0QjtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsVUFBUzVMLEdBQVQsR0FBZTtBQUNiO0FBQ0E7QUFDQSxVQUFPLHFCQUFvQmdCLE9BQXBCLHlDQUFvQkEsT0FBcEIsTUFDRkEsUUFBUWhCLEdBRE4sSUFFRlMsU0FBU0MsU0FBVCxDQUFtQkcsS0FBbkIsQ0FBeUJGLElBQXpCLENBQThCSyxRQUFRaEIsR0FBdEMsRUFBMkNnQixPQUEzQyxFQUFvREYsU0FBcEQsQ0FGTDtBQUdEOztBQUVEOzs7Ozs7O0FBT0EsVUFBUzh1RSxJQUFULENBQWNlLFVBQWQsRUFBMEI7QUFDeEIsT0FBSTtBQUNGLFNBQUksUUFBUUEsVUFBWixFQUF3QjtBQUN0QjV3RSxlQUFRZ3dFLE9BQVIsQ0FBZ0JMLFVBQWhCLENBQTJCLE9BQTNCO0FBQ0QsTUFGRCxNQUVPO0FBQ0wzdkUsZUFBUWd3RSxPQUFSLENBQWdCdnVFLEtBQWhCLEdBQXdCbXZFLFVBQXhCO0FBQ0Q7QUFDRixJQU5ELENBTUUsT0FBTS92RSxDQUFOLEVBQVMsQ0FBRTtBQUNkOztBQUVEOzs7Ozs7O0FBT0EsVUFBU2l2RSxJQUFULEdBQWdCO0FBQ2QsT0FBSXpZLENBQUo7QUFDQSxPQUFJO0FBQ0ZBLFNBQUlyM0QsUUFBUWd3RSxPQUFSLENBQWdCdnVFLEtBQXBCO0FBQ0QsSUFGRCxDQUVFLE9BQU1aLENBQU4sRUFBUyxDQUFFOztBQUViO0FBQ0EsT0FBSSxDQUFDdzJELENBQUQsSUFBTSxPQUFPem9ELE9BQVAsS0FBbUIsV0FBekIsSUFBd0MsU0FBU0EsT0FBckQsRUFBOEQ7QUFDNUR5b0QsU0FBSXpvRCxRQUFRQyxHQUFSLENBQVlnaUUsS0FBaEI7QUFDRDs7QUFFRCxVQUFPeFosQ0FBUDtBQUNEOztBQUVEOzs7O0FBSUFyM0QsU0FBUTh3RSxNQUFSLENBQWVoQixNQUFmOztBQUVBOzs7Ozs7Ozs7OztBQVdBLFVBQVNHLFlBQVQsR0FBd0I7QUFDdEIsT0FBSTtBQUNGLFlBQU8xdEUsT0FBT0MsWUFBZDtBQUNELElBRkQsQ0FFRSxPQUFPM0IsQ0FBUCxFQUFVLENBQUU7QUFDZixFOzs7Ozs7Ozs7QUN2TEQ7Ozs7Ozs7QUFPQWIsV0FBVUQsT0FBT0MsT0FBUCxHQUFpQit3RSxZQUFZdHZFLEtBQVosR0FBb0JzdkUsWUFBWSxTQUFaLElBQXlCQSxXQUF4RTtBQUNBL3dFLFNBQVEyckQsTUFBUixHQUFpQkEsTUFBakI7QUFDQTNyRCxTQUFRZ3hFLE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0FoeEUsU0FBUTh3RSxNQUFSLEdBQWlCQSxNQUFqQjtBQUNBOXdFLFNBQVFpeEUsT0FBUixHQUFrQkEsT0FBbEI7QUFDQWp4RSxTQUFRd3dFLFFBQVIsR0FBbUIsbUJBQUEzYyxDQUFRLEVBQVIsQ0FBbkI7O0FBRUE7Ozs7QUFJQTd6RCxTQUFRa3hFLEtBQVIsR0FBZ0IsRUFBaEI7QUFDQWx4RSxTQUFRbXhFLEtBQVIsR0FBZ0IsRUFBaEI7O0FBRUE7Ozs7OztBQU1BbnhFLFNBQVF1d0UsVUFBUixHQUFxQixFQUFyQjs7QUFFQTs7OztBQUlBLEtBQUlhLFFBQUo7O0FBRUE7Ozs7Ozs7QUFPQSxVQUFTQyxXQUFULENBQXFCMzNDLFNBQXJCLEVBQWdDO0FBQzlCLE9BQUkzWCxPQUFPLENBQVg7QUFBQSxPQUFjemdCLENBQWQ7O0FBRUEsUUFBS0EsQ0FBTCxJQUFVbzRCLFNBQVYsRUFBcUI7QUFDbkIzWCxZQUFTLENBQUNBLFFBQVEsQ0FBVCxJQUFjQSxJQUFmLEdBQXVCMlgsVUFBVTNwQixVQUFWLENBQXFCek8sQ0FBckIsQ0FBL0I7QUFDQXlnQixhQUFRLENBQVIsQ0FGbUIsQ0FFUjtBQUNaOztBQUVELFVBQU8vaEIsUUFBUWt3RSxNQUFSLENBQWV2bUUsS0FBSzJuRSxHQUFMLENBQVN2dkQsSUFBVCxJQUFpQi9oQixRQUFRa3dFLE1BQVIsQ0FBZTN1RSxNQUEvQyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsVUFBU3d2RSxXQUFULENBQXFCcjNDLFNBQXJCLEVBQWdDOztBQUU5QixZQUFTajRCLEtBQVQsR0FBaUI7QUFDZjtBQUNBLFNBQUksQ0FBQ0EsTUFBTXd2RSxPQUFYLEVBQW9COztBQUVwQixTQUFJanZFLE9BQU9QLEtBQVg7O0FBRUE7QUFDQSxTQUFJOHZFLE9BQU8sQ0FBQyxJQUFJL29FLElBQUosRUFBWjtBQUNBLFNBQUlxcEQsS0FBSzBmLFFBQVFILFlBQVlHLElBQXBCLENBQVQ7QUFDQXZ2RSxVQUFLeXVFLElBQUwsR0FBWTVlLEVBQVo7QUFDQTd2RCxVQUFLa2dDLElBQUwsR0FBWWt2QyxRQUFaO0FBQ0FwdkUsVUFBS3V2RSxJQUFMLEdBQVlBLElBQVo7QUFDQUgsZ0JBQVdHLElBQVg7O0FBRUE7QUFDQSxTQUFJeDZELE9BQU8sSUFBSXJLLEtBQUosQ0FBVTNMLFVBQVVRLE1BQXBCLENBQVg7QUFDQSxVQUFLLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSXlWLEtBQUt4VixNQUF6QixFQUFpQ0QsR0FBakMsRUFBc0M7QUFDcEN5VixZQUFLelYsQ0FBTCxJQUFVUCxVQUFVTyxDQUFWLENBQVY7QUFDRDs7QUFFRHlWLFVBQUssQ0FBTCxJQUFVL1csUUFBUTJyRCxNQUFSLENBQWU1MEMsS0FBSyxDQUFMLENBQWYsQ0FBVjs7QUFFQSxTQUFJLGFBQWEsT0FBT0EsS0FBSyxDQUFMLENBQXhCLEVBQWlDO0FBQy9CO0FBQ0FBLFlBQUtrZSxPQUFMLENBQWEsSUFBYjtBQUNEOztBQUVEO0FBQ0EsU0FBSTN2QixRQUFRLENBQVo7QUFDQXlSLFVBQUssQ0FBTCxJQUFVQSxLQUFLLENBQUwsRUFBUXBMLE9BQVIsQ0FBZ0IsZUFBaEIsRUFBaUMsVUFBU2dHLEtBQVQsRUFBZ0I2L0QsTUFBaEIsRUFBd0I7QUFDakU7QUFDQSxXQUFJNy9ELFVBQVUsSUFBZCxFQUFvQixPQUFPQSxLQUFQO0FBQ3BCck07QUFDQSxXQUFJbXNFLFlBQVl6eEUsUUFBUXV3RSxVQUFSLENBQW1CaUIsTUFBbkIsQ0FBaEI7QUFDQSxXQUFJLGVBQWUsT0FBT0MsU0FBMUIsRUFBcUM7QUFDbkMsYUFBSWpvRSxNQUFNdU4sS0FBS3pSLEtBQUwsQ0FBVjtBQUNBcU0saUJBQVE4L0QsVUFBVTd3RSxJQUFWLENBQWVvQixJQUFmLEVBQXFCd0gsR0FBckIsQ0FBUjs7QUFFQTtBQUNBdU4sY0FBSy9MLE1BQUwsQ0FBWTFGLEtBQVosRUFBbUIsQ0FBbkI7QUFDQUE7QUFDRDtBQUNELGNBQU9xTSxLQUFQO0FBQ0QsTUFkUyxDQUFWOztBQWdCQTtBQUNBM1IsYUFBUTR2RSxVQUFSLENBQW1CaHZFLElBQW5CLENBQXdCb0IsSUFBeEIsRUFBOEIrVSxJQUE5Qjs7QUFFQSxTQUFJMjZELFFBQVFqd0UsTUFBTXhCLEdBQU4sSUFBYUQsUUFBUUMsR0FBckIsSUFBNEJnQixRQUFRaEIsR0FBUixDQUFZUSxJQUFaLENBQWlCUSxPQUFqQixDQUF4QztBQUNBeXdFLFdBQU01d0UsS0FBTixDQUFZa0IsSUFBWixFQUFrQitVLElBQWxCO0FBQ0Q7O0FBRUR0VixTQUFNaTRCLFNBQU4sR0FBa0JBLFNBQWxCO0FBQ0FqNEIsU0FBTXd2RSxPQUFOLEdBQWdCanhFLFFBQVFpeEUsT0FBUixDQUFnQnYzQyxTQUFoQixDQUFoQjtBQUNBajRCLFNBQU1zdUUsU0FBTixHQUFrQi92RSxRQUFRK3ZFLFNBQVIsRUFBbEI7QUFDQXR1RSxTQUFNaXZFLEtBQU4sR0FBY1csWUFBWTMzQyxTQUFaLENBQWQ7O0FBRUE7QUFDQSxPQUFJLGVBQWUsT0FBTzE1QixRQUFRcXVCLElBQWxDLEVBQXdDO0FBQ3RDcnVCLGFBQVFxdUIsSUFBUixDQUFhNXNCLEtBQWI7QUFDRDs7QUFFRCxVQUFPQSxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsVUFBU3F2RSxNQUFULENBQWdCRixVQUFoQixFQUE0QjtBQUMxQjV3RSxXQUFRNnZFLElBQVIsQ0FBYWUsVUFBYjs7QUFFQTV3RSxXQUFRa3hFLEtBQVIsR0FBZ0IsRUFBaEI7QUFDQWx4RSxXQUFRbXhFLEtBQVIsR0FBZ0IsRUFBaEI7O0FBRUEsT0FBSTFtRSxRQUFRLENBQUMsT0FBT21tRSxVQUFQLEtBQXNCLFFBQXRCLEdBQWlDQSxVQUFqQyxHQUE4QyxFQUEvQyxFQUFtRG5tRSxLQUFuRCxDQUF5RCxRQUF6RCxDQUFaO0FBQ0EsT0FBSXVNLE1BQU12TSxNQUFNbEosTUFBaEI7O0FBRUEsUUFBSyxJQUFJRCxJQUFJLENBQWIsRUFBZ0JBLElBQUkwVixHQUFwQixFQUF5QjFWLEdBQXpCLEVBQThCO0FBQzVCLFNBQUksQ0FBQ21KLE1BQU1uSixDQUFOLENBQUwsRUFBZSxTQURhLENBQ0g7QUFDekJzdkUsa0JBQWFubUUsTUFBTW5KLENBQU4sRUFBU3FLLE9BQVQsQ0FBaUIsS0FBakIsRUFBd0IsS0FBeEIsQ0FBYjtBQUNBLFNBQUlpbEUsV0FBVyxDQUFYLE1BQWtCLEdBQXRCLEVBQTJCO0FBQ3pCNXdFLGVBQVFteEUsS0FBUixDQUFjai9ELElBQWQsQ0FBbUIsSUFBSStqQixNQUFKLENBQVcsTUFBTTI2QyxXQUFXZSxNQUFYLENBQWtCLENBQWxCLENBQU4sR0FBNkIsR0FBeEMsQ0FBbkI7QUFDRCxNQUZELE1BRU87QUFDTDN4RSxlQUFRa3hFLEtBQVIsQ0FBY2gvRCxJQUFkLENBQW1CLElBQUkrakIsTUFBSixDQUFXLE1BQU0yNkMsVUFBTixHQUFtQixHQUE5QixDQUFuQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O0FBTUEsVUFBU0ksT0FBVCxHQUFtQjtBQUNqQmh4RSxXQUFROHdFLE1BQVIsQ0FBZSxFQUFmO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsVUFBU0csT0FBVCxDQUFpQnB2RSxJQUFqQixFQUF1QjtBQUNyQixPQUFJUCxDQUFKLEVBQU8wVixHQUFQO0FBQ0EsUUFBSzFWLElBQUksQ0FBSixFQUFPMFYsTUFBTWhYLFFBQVFteEUsS0FBUixDQUFjNXZFLE1BQWhDLEVBQXdDRCxJQUFJMFYsR0FBNUMsRUFBaUQxVixHQUFqRCxFQUFzRDtBQUNwRCxTQUFJdEIsUUFBUW14RSxLQUFSLENBQWM3dkUsQ0FBZCxFQUFpQmtQLElBQWpCLENBQXNCM08sSUFBdEIsQ0FBSixFQUFpQztBQUMvQixjQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsUUFBS1AsSUFBSSxDQUFKLEVBQU8wVixNQUFNaFgsUUFBUWt4RSxLQUFSLENBQWMzdkUsTUFBaEMsRUFBd0NELElBQUkwVixHQUE1QyxFQUFpRDFWLEdBQWpELEVBQXNEO0FBQ3BELFNBQUl0QixRQUFRa3hFLEtBQVIsQ0FBYzV2RSxDQUFkLEVBQWlCa1AsSUFBakIsQ0FBc0IzTyxJQUF0QixDQUFKLEVBQWlDO0FBQy9CLGNBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxVQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxVQUFTOHBELE1BQVQsQ0FBZ0JuaUQsR0FBaEIsRUFBcUI7QUFDbkIsT0FBSUEsZUFBZTg3QyxLQUFuQixFQUEwQixPQUFPOTdDLElBQUk4dEMsS0FBSixJQUFhOXRDLElBQUlzakQsT0FBeEI7QUFDMUIsVUFBT3RqRCxHQUFQO0FBQ0QsRTs7Ozs7Ozs7OztBQ3pNRDs7OztBQUlBLEtBQUkyaUMsSUFBSSxJQUFSO0FBQ0EsS0FBSTkrQixJQUFJOCtCLElBQUksRUFBWjtBQUNBLEtBQUluZSxJQUFJM2dCLElBQUksRUFBWjtBQUNBLEtBQUk3RixJQUFJd21CLElBQUksRUFBWjtBQUNBLEtBQUlzL0IsSUFBSTlsRCxJQUFJLE1BQVo7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0F6SCxRQUFPQyxPQUFQLEdBQWlCLFVBQVN3SixHQUFULEVBQWM2SCxPQUFkLEVBQXVCO0FBQ3RDQSxhQUFVQSxXQUFXLEVBQXJCO0FBQ0EsT0FBSW1KLGNBQWNoUixHQUFkLHlDQUFjQSxHQUFkLENBQUo7QUFDQSxPQUFJZ1IsU0FBUyxRQUFULElBQXFCaFIsSUFBSWpJLE1BQUosR0FBYSxDQUF0QyxFQUF5QztBQUN2QyxZQUFPeTRDLE1BQU14d0MsR0FBTixDQUFQO0FBQ0QsSUFGRCxNQUVPLElBQUlnUixTQUFTLFFBQVQsSUFBcUJ0USxNQUFNVixHQUFOLE1BQWUsS0FBeEMsRUFBK0M7QUFDcEQsWUFBTzZILFFBQVF1Z0UsSUFBUixHQUFlQyxRQUFRcm9FLEdBQVIsQ0FBZixHQUE4QnNvRSxTQUFTdG9FLEdBQVQsQ0FBckM7QUFDRDtBQUNELFNBQU0sSUFBSTg3QyxLQUFKLENBQ0osMERBQ0V4N0MsS0FBS0MsU0FBTCxDQUFlUCxHQUFmLENBRkUsQ0FBTjtBQUlELEVBWkQ7O0FBY0E7Ozs7Ozs7O0FBUUEsVUFBU3d3QyxLQUFULENBQWU1dkMsR0FBZixFQUFvQjtBQUNsQkEsU0FBTUosT0FBT0ksR0FBUCxDQUFOO0FBQ0EsT0FBSUEsSUFBSTdJLE1BQUosR0FBYSxHQUFqQixFQUFzQjtBQUNwQjtBQUNEO0FBQ0QsT0FBSW9RLFFBQVEsd0hBQXdIMU8sSUFBeEgsQ0FDVm1ILEdBRFUsQ0FBWjtBQUdBLE9BQUksQ0FBQ3VILEtBQUwsRUFBWTtBQUNWO0FBQ0Q7QUFDRCxPQUFJbEksSUFBSUMsV0FBV2lJLE1BQU0sQ0FBTixDQUFYLENBQVI7QUFDQSxPQUFJNkksT0FBTyxDQUFDN0ksTUFBTSxDQUFOLEtBQVksSUFBYixFQUFtQmpILFdBQW5CLEVBQVg7QUFDQSxXQUFROFAsSUFBUjtBQUNFLFVBQUssT0FBTDtBQUNBLFVBQUssTUFBTDtBQUNBLFVBQUssS0FBTDtBQUNBLFVBQUssSUFBTDtBQUNBLFVBQUssR0FBTDtBQUNFLGNBQU8vUSxJQUFJNmpELENBQVg7QUFDRixVQUFLLE1BQUw7QUFDQSxVQUFLLEtBQUw7QUFDQSxVQUFLLEdBQUw7QUFDRSxjQUFPN2pELElBQUlqQyxDQUFYO0FBQ0YsVUFBSyxPQUFMO0FBQ0EsVUFBSyxNQUFMO0FBQ0EsVUFBSyxLQUFMO0FBQ0EsVUFBSyxJQUFMO0FBQ0EsVUFBSyxHQUFMO0FBQ0UsY0FBT2lDLElBQUl1a0IsQ0FBWDtBQUNGLFVBQUssU0FBTDtBQUNBLFVBQUssUUFBTDtBQUNBLFVBQUssTUFBTDtBQUNBLFVBQUssS0FBTDtBQUNBLFVBQUssR0FBTDtBQUNFLGNBQU92a0IsSUFBSTRELENBQVg7QUFDRixVQUFLLFNBQUw7QUFDQSxVQUFLLFFBQUw7QUFDQSxVQUFLLE1BQUw7QUFDQSxVQUFLLEtBQUw7QUFDQSxVQUFLLEdBQUw7QUFDRSxjQUFPNUQsSUFBSTBpQyxDQUFYO0FBQ0YsVUFBSyxjQUFMO0FBQ0EsVUFBSyxhQUFMO0FBQ0EsVUFBSyxPQUFMO0FBQ0EsVUFBSyxNQUFMO0FBQ0EsVUFBSyxJQUFMO0FBQ0UsY0FBTzFpQyxDQUFQO0FBQ0Y7QUFDRSxjQUFPdkksU0FBUDtBQXBDSjtBQXNDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxVQUFTNHdFLFFBQVQsQ0FBa0JqZ0IsRUFBbEIsRUFBc0I7QUFDcEIsT0FBSUEsTUFBTXJxRCxDQUFWLEVBQWE7QUFDWCxZQUFPbUMsS0FBS29vRSxLQUFMLENBQVdsZ0IsS0FBS3JxRCxDQUFoQixJQUFxQixHQUE1QjtBQUNEO0FBQ0QsT0FBSXFxRCxNQUFNN2pDLENBQVYsRUFBYTtBQUNYLFlBQU9ya0IsS0FBS29vRSxLQUFMLENBQVdsZ0IsS0FBSzdqQyxDQUFoQixJQUFxQixHQUE1QjtBQUNEO0FBQ0QsT0FBSTZqQyxNQUFNeGtELENBQVYsRUFBYTtBQUNYLFlBQU8xRCxLQUFLb29FLEtBQUwsQ0FBV2xnQixLQUFLeGtELENBQWhCLElBQXFCLEdBQTVCO0FBQ0Q7QUFDRCxPQUFJd2tELE1BQU0xbEIsQ0FBVixFQUFhO0FBQ1gsWUFBT3hpQyxLQUFLb29FLEtBQUwsQ0FBV2xnQixLQUFLMWxCLENBQWhCLElBQXFCLEdBQTVCO0FBQ0Q7QUFDRCxVQUFPMGxCLEtBQUssSUFBWjtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFVBQVNnZ0IsT0FBVCxDQUFpQmhnQixFQUFqQixFQUFxQjtBQUNuQixVQUFPbWdCLE9BQU9uZ0IsRUFBUCxFQUFXcnFELENBQVgsRUFBYyxLQUFkLEtBQ0x3cUUsT0FBT25nQixFQUFQLEVBQVc3akMsQ0FBWCxFQUFjLE1BQWQsQ0FESyxJQUVMZ2tELE9BQU9uZ0IsRUFBUCxFQUFXeGtELENBQVgsRUFBYyxRQUFkLENBRkssSUFHTDJrRSxPQUFPbmdCLEVBQVAsRUFBVzFsQixDQUFYLEVBQWMsUUFBZCxDQUhLLElBSUwwbEIsS0FBSyxLQUpQO0FBS0Q7O0FBRUQ7Ozs7QUFJQSxVQUFTbWdCLE1BQVQsQ0FBZ0JuZ0IsRUFBaEIsRUFBb0Jwb0QsQ0FBcEIsRUFBdUI1SCxJQUF2QixFQUE2QjtBQUMzQixPQUFJZ3dELEtBQUtwb0QsQ0FBVCxFQUFZO0FBQ1Y7QUFDRDtBQUNELE9BQUlvb0QsS0FBS3BvRCxJQUFJLEdBQWIsRUFBa0I7QUFDaEIsWUFBT0UsS0FBS0MsS0FBTCxDQUFXaW9ELEtBQUtwb0QsQ0FBaEIsSUFBcUIsR0FBckIsR0FBMkI1SCxJQUFsQztBQUNEO0FBQ0QsVUFBTzhILEtBQUt3dEQsSUFBTCxDQUFVdEYsS0FBS3BvRCxDQUFmLElBQW9CLEdBQXBCLEdBQTBCNUgsSUFBMUIsR0FBaUMsR0FBeEM7QUFDRCxFOzs7Ozs7QUN2SkQ7O0FBRUEsS0FBSTJSLFNBQVMsbUJBQUFxZ0QsQ0FBUSxFQUFSLENBQWI7QUFDQSxLQUFJdC9DLFVBQVVmLE9BQU9lLE9BQVAsSUFBa0IsbUJBQUFzL0MsQ0FBUSxFQUFSLEVBQXVCdC9DLE9BQXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBeFUsUUFBT0MsT0FBUCxHQUFpQixTQUFTbTVELG1CQUFULENBQTZCRCxhQUE3QixFQUE0QytZLFFBQTVDLEVBQXNEO0FBQ3JFLE9BQUkxWSxXQUFXLG1CQUFBMUYsQ0FBUSxFQUFSLENBQWY7QUFDQSxPQUFJclEsU0FBUyxtQkFBQXFRLENBQVEsRUFBUixDQUFiO0FBQ0EsT0FBSXFlLGdCQUFnQixtQkFBQXJlLENBQVEsRUFBUixDQUFwQjtBQUNBLE9BQUlzZSxlQUFlLG1CQUFBdGUsQ0FBUSxFQUFSLENBQW5CO0FBQ0EsT0FBSXVlLFNBQVMsbUJBQUF2ZSxDQUFRLEVBQVIsQ0FBYjtBQUNBb2UsY0FBV0EsWUFBWSxFQUF2Qjs7QUFFQSxPQUFJcmpFLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixPQUE3QixFQUFzQztBQUNwQytrRCxLQUFBLG1CQUFBQSxDQUFRLEVBQVIsRUFBaUJpZCxNQUFqQixDQUF3QixnQkFBeEI7QUFDRDs7QUFFRCxZQUFTM08sYUFBVCxDQUF1Qm9HLGFBQXZCLEVBQXNDbGpFLE1BQXRDLEVBQThDOE4sSUFBOUMsRUFBb0Q7QUFDbEQsU0FBSWsvRCxZQUFZLG1CQUFBeGUsQ0FBUSxFQUFSLENBQWhCOztBQUVBLFNBQUl5ZSxzQkFBc0IsbUJBQUF6ZSxDQUFRLEVBQVIsQ0FBMUI7O0FBRUExZ0QsWUFBT2svRCxVQUFVbC9ELFFBQVEsRUFBbEIsQ0FBUDs7QUFFQSxTQUFJQSxLQUFLeWlELFFBQUwsS0FBa0IxMEQsU0FBdEIsRUFBaUM7QUFDL0JpUyxZQUFLeWlELFFBQUwsR0FBZ0IwYyxxQkFBaEI7QUFDRDs7QUFFRG4vRCxVQUFLbTJELEdBQUwsR0FBV24yRCxLQUFLbTJELEdBQUwsSUFBWW5ILGNBQWNpSyxFQUFyQzs7QUFFQSxZQUFPLElBQUltRyxvQkFBSixDQUF5QmhLLGFBQXpCLEVBQXdDbGpFLE1BQXhDLEVBQWdEOE4sSUFBaEQsQ0FBUDtBQUNEOztBQUVEZ3ZELGlCQUFjOXFDLE9BQWQsR0FBd0IsbUJBQUF3OEIsQ0FBUSxFQUFSLENBQXhCO0FBQ0FzTyxpQkFBY2lLLEVBQWQsR0FBbUIsb0NBQW9DNkYsUUFBcEMsR0FBK0M5UCxjQUFjOXFDLE9BQWhGO0FBQ0E4cUMsaUJBQWNxUSxVQUFkLEdBQTJCSixPQUFPalEsYUFBUCxDQUEzQjs7QUFFQTtBQUNBO0FBQ0EzdUQsVUFBT2kvRCxTQUFQLEdBQW1CO0FBQ2pCaHhFLFlBQU8sbUJBQUFveUQsQ0FBUSxFQUFSLENBRFU7QUFFakJzTyxvQkFBZUE7QUFGRSxJQUFuQjs7QUFLQSxPQUFJdVEsVUFBVTtBQUNaQyx3QkFBbUIsb0JBQW9Cbi9ELE1BRDNCO0FBRVpvL0Qsd0JBQW1CLG9CQUFvQnAvRDtBQUYzQixJQUFkOztBQUtBLE9BQUlrL0QsUUFBUUMsaUJBQVosRUFBK0I7QUFDN0JELGFBQVFHLElBQVIsR0FBZSxxQkFBcUIsSUFBSUMsY0FBSixFQUFwQztBQUNEOztBQUVELFlBQVNQLG9CQUFULEdBQWdDO0FBQzlCO0FBQ0FyWixtQkFBY3A0RCxLQUFkLENBQW9CLElBQXBCLEVBQTBCQyxTQUExQjtBQUNEOztBQUVEdzRELFlBQVNnWixvQkFBVCxFQUErQnJaLGFBQS9COztBQUVBcVosd0JBQXFCNXhFLFNBQXJCLENBQStCeXBFLFFBQS9CLEdBQTBDLFNBQVM1akUsT0FBVCxDQUFpQkcsR0FBakIsRUFBc0J3TSxJQUF0QixFQUE0QjtBQUNwRSxZQUFPLElBQUlvQixPQUFKLENBQVksU0FBU3crRCxXQUFULENBQXFCbnJFLE9BQXJCLEVBQThCRSxNQUE5QixFQUFzQztBQUN2RDtBQUNBLFdBQUksQ0FBQzRxRSxRQUFRRyxJQUFULElBQWlCLENBQUNILFFBQVFFLGlCQUE5QixFQUFpRDtBQUMvQztBQUNBOXFFLGdCQUFPLElBQUkwN0MsT0FBT29nQixPQUFYLENBQW1CLG9CQUFuQixDQUFQO0FBQ0E7QUFDRDs7QUFFRGo5RCxhQUFNdXJFLGNBQWN2ckUsR0FBZCxFQUFtQndNLEtBQUtrM0QsT0FBeEIsQ0FBTjs7QUFFQSxXQUFJNTNCLE9BQU90L0IsS0FBS3MvQixJQUFoQjtBQUNBLFdBQUl1Z0MsTUFBTU4sUUFBUUcsSUFBUixHQUFlLElBQUlDLGNBQUosRUFBZixHQUFzQyxJQUFJRyxjQUFKLEVBQWhEO0FBQ0EsV0FBSUMsVUFBSjtBQUNBLFdBQUlDLFFBQUo7QUFDQSxXQUFJQyxZQUFZLEtBQWhCOztBQUVBRixvQkFBYXgrRCxXQUFXaS9DLFNBQVgsRUFBc0J4Z0QsS0FBSzAxRCxRQUFMLENBQWNDLE9BQXBDLENBQWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FrSyxXQUFJSyxVQUFKLEdBQWlCL2hCLFVBQWpCO0FBQ0EsV0FBSSx3QkFBd0IwaEIsR0FBNUIsRUFBaUNBLElBQUk3ZCxrQkFBSixHQUF5Qm1lLGtCQUF6QjtBQUNqQ04sV0FBSU8sTUFBSixHQUFhQyxNQUFiO0FBQ0FSLFdBQUkxa0IsT0FBSixHQUFjbWxCLE9BQWQ7O0FBRUE7QUFDQTtBQUNBLFdBQUlULGVBQWVGLGNBQW5CLEVBQW1DO0FBQ2pDRSxhQUFJMStCLElBQUosQ0FBU25oQyxLQUFLM1MsTUFBZCxFQUFzQm1HLEdBQXRCLEVBQTJCLElBQTNCO0FBQ0QsUUFGRCxNQUVPO0FBQ0xxc0UsYUFBSTErQixJQUFKLENBQVNuaEMsS0FBSzNTLE1BQWQsRUFBc0JtRyxHQUF0QjtBQUNEOztBQUVEO0FBQ0EsV0FBSStyRSxRQUFRRyxJQUFaLEVBQWtCO0FBQ2hCLGFBQUlwZ0MsSUFBSixFQUFVO0FBQ1IsZUFBSXQvQixLQUFLM1MsTUFBTCxLQUFnQixNQUFwQixFQUE0QjtBQUMxQjtBQUNBd3lFLGlCQUFJVSxnQkFBSixDQUFxQixjQUFyQixFQUFxQyxtQ0FBckM7QUFDRCxZQUhELE1BR087QUFDTFYsaUJBQUlVLGdCQUFKLENBQXFCLGNBQXJCLEVBQXFDLGtCQUFyQztBQUNEO0FBQ0Y7QUFDRFYsYUFBSVUsZ0JBQUosQ0FBcUIsUUFBckIsRUFBK0Isa0JBQS9CO0FBQ0Q7O0FBRURWLFdBQUl0aUIsSUFBSixDQUFTamUsSUFBVDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQVMrZ0MsTUFBVCxHQUFnQixXQUFhO0FBQzNCO0FBQ0E7QUFDQSxhQUFJTCxRQUFKLEVBQWM7QUFDWjtBQUNEOztBQUVEM3RCLHNCQUFhMHRCLFVBQWI7O0FBRUEsYUFBSXJFLEdBQUo7O0FBRUEsYUFBSTtBQUNGQSxpQkFBTTtBQUNKcDhCLG1CQUFNM29DLEtBQUtrd0MsS0FBTCxDQUFXZzVCLElBQUl0SCxZQUFmLENBREY7QUFFSkEsMkJBQWNzSCxJQUFJdEgsWUFGZDtBQUdKTCx5QkFBWTJILElBQUk5UyxNQUhaO0FBSUo7QUFDQW1LLHNCQUFTMkksSUFBSVcscUJBQUosSUFBNkJYLElBQUlXLHFCQUFKLEVBQTdCLElBQTREO0FBTGpFLFlBQU47QUFPRCxVQVJELENBUUUsT0FBTzl5RSxDQUFQLEVBQVU7QUFDVmd1RSxpQkFBTSxJQUFJcnJCLE9BQU9rZ0IsY0FBWCxDQUEwQjtBQUM5QmtRLG1CQUFNWixJQUFJdEg7QUFEb0IsWUFBMUIsQ0FBTjtBQUdEOztBQUVELGFBQUltRCxlQUFlcnJCLE9BQU9rZ0IsY0FBMUIsRUFBMEM7QUFDeEM1N0Qsa0JBQU8rbUUsR0FBUDtBQUNELFVBRkQsTUFFTztBQUNMam5FLG1CQUFRaW5FLEdBQVI7QUFDRDtBQUNGOztBQUVELGdCQUFTNEUsT0FBVCxDQUFpQm5zRSxLQUFqQixFQUF3QjtBQUN0QixhQUFJNnJFLFFBQUosRUFBYztBQUNaO0FBQ0Q7O0FBRUQzdEIsc0JBQWEwdEIsVUFBYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQXByRSxnQkFDRSxJQUFJMDdDLE9BQU9vZ0IsT0FBWCxDQUFtQjtBQUNqQmdRLGlCQUFNdHNFO0FBRFcsVUFBbkIsQ0FERjtBQUtEOztBQUVELGdCQUFTcXNELFNBQVQsR0FBcUI7QUFDbkJ3ZixvQkFBVyxJQUFYO0FBQ0FILGFBQUlhLEtBQUo7O0FBRUEvckUsZ0JBQU8sSUFBSTA3QyxPQUFPbWdCLGNBQVgsRUFBUDtBQUNEOztBQUVELGdCQUFTbVEsU0FBVCxHQUFxQjtBQUNuQlYscUJBQVksSUFBWjtBQUNBNXRCLHNCQUFhMHRCLFVBQWI7QUFDQUEsc0JBQWF4K0QsV0FBV2kvQyxTQUFYLEVBQXNCeGdELEtBQUswMUQsUUFBTCxDQUFjNEYsUUFBcEMsQ0FBYjtBQUNEOztBQUVELGdCQUFTbmQsVUFBVCxHQUFzQjtBQUNwQixhQUFJLENBQUM4aEIsU0FBTCxFQUFnQlU7QUFDakI7O0FBRUQsZ0JBQVNSLGtCQUFULEdBQThCO0FBQzVCLGFBQUksQ0FBQ0YsU0FBRCxJQUFjSixJQUFJZSxVQUFKLEdBQWlCLENBQW5DLEVBQXNDRDtBQUN2QztBQUNGLE1BekhNLENBQVA7QUEwSEQsSUEzSEQ7O0FBNkhBdkIsd0JBQXFCNXhFLFNBQXJCLENBQStCeXBFLFFBQS9CLENBQXdDdjVDLFFBQXhDLEdBQW1ELFNBQVNtakQsZUFBVCxDQUF5QnJ0RSxHQUF6QixFQUE4QndNLElBQTlCLEVBQW9DO0FBQ3JGeE0sV0FBTXVyRSxjQUFjdnJFLEdBQWQsRUFBbUJ3TSxLQUFLazNELE9BQXhCLENBQU47O0FBRUEsWUFBTyxJQUFJOTFELE9BQUosQ0FBWSxTQUFTMC9ELGdCQUFULENBQTBCcnNFLE9BQTFCLEVBQW1DRSxNQUFuQyxFQUEyQztBQUM1RHFxRSxvQkFBYXhyRSxHQUFiLEVBQWtCd00sSUFBbEIsRUFBd0IsU0FBUytnRSxnQkFBVCxDQUEwQjloRSxHQUExQixFQUErQnloQyxPQUEvQixFQUF3QztBQUM5RCxhQUFJemhDLEdBQUosRUFBUztBQUNQdEssa0JBQU9zSyxHQUFQO0FBQ0E7QUFDRDs7QUFFRHhLLGlCQUFRaXNDLE9BQVI7QUFDRCxRQVBEO0FBUUQsTUFUTSxDQUFQO0FBVUQsSUFiRDs7QUFlQTArQix3QkFBcUI1eEUsU0FBckIsQ0FBK0JtOUQsUUFBL0IsR0FBMEM7QUFDeENoMkQsYUFBUSxTQUFTcXNFLGFBQVQsQ0FBdUIzcUUsR0FBdkIsRUFBNEI7QUFDbEMsY0FBTytLLFFBQVF6TSxNQUFSLENBQWUwQixHQUFmLENBQVA7QUFDRCxNQUh1QztBQUl4QzVCLGNBQVMsU0FBU3dzRSxjQUFULENBQXdCNXFFLEdBQXhCLEVBQTZCO0FBQ3BDLGNBQU8rSyxRQUFRM00sT0FBUixDQUFnQjRCLEdBQWhCLENBQVA7QUFDRCxNQU51QztBQU94Q2dhLFlBQU8sU0FBUzZ3RCxZQUFULENBQXNCeGlCLEVBQXRCLEVBQTBCO0FBQy9CLGNBQU8sSUFBSXQ5QyxPQUFKLENBQVksU0FBUysvRCxnQkFBVCxDQUEwQjFzRSxPQUExQixDQUFpQyxhQUFqQyxFQUFnRDtBQUNqRThNLG9CQUFXOU0sT0FBWCxFQUFvQmlxRCxFQUFwQjtBQUNELFFBRk0sQ0FBUDtBQUdEO0FBWHVDLElBQTFDOztBQWNBLFVBQU9zUSxhQUFQO0FBQ0QsRUFsTkQsQzs7Ozs7Ozs7O0FDUkEsS0FBSW9TLEdBQUo7O0FBRUEsS0FBSSxPQUFPaHlFLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDL0JneUUsV0FBTWh5RSxNQUFOO0FBQ0gsRUFGRCxNQUVPLElBQUksT0FBT2lSLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDdEMrZ0UsV0FBTS9nRSxNQUFOO0FBQ0gsRUFGTSxNQUVBLElBQUksT0FBT3hSLElBQVAsS0FBZ0IsV0FBcEIsRUFBZ0M7QUFDbkN1eUUsV0FBTXZ5RSxJQUFOO0FBQ0gsRUFGTSxNQUVBO0FBQ0h1eUUsV0FBTSxFQUFOO0FBQ0g7O0FBRUR4MEUsUUFBT0MsT0FBUCxHQUFpQnUwRSxHQUFqQixDOzs7Ozs7Ozs7OztBQ1pBOzs7Ozs7OztBQVFDLFlBQVUvZ0UsTUFBVixFQUFrQnpSLE9BQWxCLEVBQTJCO0FBQzNCLG1DQUFPL0IsT0FBUCxPQUFtQixRQUFuQixJQUErQixPQUFPRCxNQUFQLEtBQWtCLFdBQWpELEdBQStEQSxPQUFPQyxPQUFQLEdBQWlCK0IsU0FBaEYsR0FDQSxRQUE2QyxvQ0FBT0EsT0FBUCxtVEFBN0MsR0FDQ3lSLE9BQU9naEUsVUFBUCxHQUFvQnp5RSxTQUZyQjtBQUdBLEVBSkEsYUFJUSxZQUFZO0FBQUU7O0FBRXZCLFlBQVMweUUsZ0JBQVQsQ0FBMEJwbkIsQ0FBMUIsRUFBNkI7QUFDM0IsU0FBSTd5QyxjQUFjNnlDLENBQWQseUNBQWNBLENBQWQsQ0FBSjtBQUNBLFlBQU9BLE1BQU0sSUFBTixLQUFlN3lDLFNBQVMsUUFBVCxJQUFxQkEsU0FBUyxVQUE3QyxDQUFQO0FBQ0Q7O0FBRUQsWUFBU2dzRCxVQUFULENBQW9CblosQ0FBcEIsRUFBdUI7QUFDckIsWUFBTyxPQUFPQSxDQUFQLEtBQWEsVUFBcEI7QUFDRDs7QUFFRCxPQUFJcW5CLFdBQVd4ekUsU0FBZjtBQUNBLE9BQUl3TCxNQUFNbUIsT0FBVixFQUFtQjtBQUNqQjZtRSxnQkFBV2hvRSxNQUFNbUIsT0FBakI7QUFDRCxJQUZELE1BRU87QUFDTDZtRSxnQkFBVyxrQkFBVXJuQixDQUFWLEVBQWE7QUFDdEIsY0FBT25sRCxPQUFPdkgsU0FBUCxDQUFpQnlJLFFBQWpCLENBQTBCeEksSUFBMUIsQ0FBK0J5c0QsQ0FBL0IsTUFBc0MsZ0JBQTdDO0FBQ0QsTUFGRDtBQUdEOztBQUVELE9BQUl4L0MsVUFBVTZtRSxRQUFkOztBQUVBLE9BQUkxOUQsTUFBTSxDQUFWO0FBQ0EsT0FBSTI5RCxZQUFZenpFLFNBQWhCO0FBQ0EsT0FBSTB6RSxvQkFBb0IxekUsU0FBeEI7O0FBRUEsT0FBSTJ6RSxPQUFPLFNBQVNBLElBQVQsQ0FBYzFrRCxRQUFkLEVBQXdCeVMsR0FBeEIsRUFBNkI7QUFDdENoYSxXQUFNNVIsR0FBTixJQUFhbVosUUFBYjtBQUNBdkgsV0FBTTVSLE1BQU0sQ0FBWixJQUFpQjRyQixHQUFqQjtBQUNBNXJCLFlBQU8sQ0FBUDtBQUNBLFNBQUlBLFFBQVEsQ0FBWixFQUFlO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBSTQ5RCxpQkFBSixFQUF1QjtBQUNyQkEsMkJBQWtCNXNCLEtBQWxCO0FBQ0QsUUFGRCxNQUVPO0FBQ0w4c0I7QUFDRDtBQUNGO0FBQ0YsSUFkRDs7QUFnQkEsWUFBU0MsWUFBVCxDQUFzQkMsVUFBdEIsRUFBa0M7QUFDaENKLHlCQUFvQkksVUFBcEI7QUFDRDs7QUFFRCxZQUFTQyxPQUFULENBQWlCQyxNQUFqQixFQUF5QjtBQUN2QkwsWUFBT0ssTUFBUDtBQUNEOztBQUVELE9BQUlDLGdCQUFnQixPQUFPNXlFLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDckIsU0FBN0Q7QUFDQSxPQUFJazBFLGdCQUFnQkQsaUJBQWlCLEVBQXJDO0FBQ0EsT0FBSUUsMEJBQTBCRCxjQUFjemdFLGdCQUFkLElBQWtDeWdFLGNBQWNFLHNCQUE5RTtBQUNBLE9BQUlDLFNBQVMsT0FBT3Z6RSxJQUFQLEtBQWdCLFdBQWhCLElBQStCLE9BQU80TSxPQUFQLEtBQW1CLFdBQWxELElBQWtFLEVBQUQsQ0FBS3hGLFFBQUwsQ0FBY3hJLElBQWQsQ0FBbUJnTyxPQUFuQixNQUFnQyxrQkFBOUc7O0FBRUE7QUFDQSxPQUFJNG1FLFdBQVcsT0FBT0MsaUJBQVAsS0FBNkIsV0FBN0IsSUFBNEMsT0FBT2poQixhQUFQLEtBQXlCLFdBQXJFLElBQW9GLE9BQU9uTSxjQUFQLEtBQTBCLFdBQTdIOztBQUVBO0FBQ0EsWUFBU3F0QixXQUFULEdBQXVCO0FBQ3JCO0FBQ0E7QUFDQSxZQUFPLFlBQVk7QUFDakIsY0FBTzltRSxRQUFRcUYsUUFBUixDQUFpQit6QyxLQUFqQixDQUFQO0FBQ0QsTUFGRDtBQUdEOztBQUVEO0FBQ0EsWUFBUzJ0QixhQUFULEdBQXlCO0FBQ3ZCLFNBQUksT0FBT2hCLFNBQVAsS0FBcUIsV0FBekIsRUFBc0M7QUFDcEMsY0FBTyxZQUFZO0FBQ2pCQSxtQkFBVTNzQixLQUFWO0FBQ0QsUUFGRDtBQUdEOztBQUVELFlBQU80dEIsZUFBUDtBQUNEOztBQUVELFlBQVNDLG1CQUFULEdBQStCO0FBQzdCLFNBQUlDLGFBQWEsQ0FBakI7QUFDQSxTQUFJamhFLFdBQVcsSUFBSXdnRSx1QkFBSixDQUE0QnJ0QixLQUE1QixDQUFmO0FBQ0EsU0FBSWhvQyxPQUFPdGQsU0FBU3FTLGNBQVQsQ0FBd0IsRUFBeEIsQ0FBWDtBQUNBRixjQUFTRyxPQUFULENBQWlCZ0wsSUFBakIsRUFBdUIsRUFBRS9LLGVBQWUsSUFBakIsRUFBdkI7O0FBRUEsWUFBTyxZQUFZO0FBQ2pCK0ssWUFBS25aLElBQUwsR0FBWWl2RSxhQUFhLEVBQUVBLFVBQUYsR0FBZSxDQUF4QztBQUNELE1BRkQ7QUFHRDs7QUFFRDtBQUNBLFlBQVNDLGlCQUFULEdBQTZCO0FBQzNCLFNBQUl6dEIsVUFBVSxJQUFJRCxjQUFKLEVBQWQ7QUFDQUMsYUFBUUMsS0FBUixDQUFjQyxTQUFkLEdBQTBCUixLQUExQjtBQUNBLFlBQU8sWUFBWTtBQUNqQixjQUFPTSxRQUFRSSxLQUFSLENBQWNDLFdBQWQsQ0FBMEIsQ0FBMUIsQ0FBUDtBQUNELE1BRkQ7QUFHRDs7QUFFRCxZQUFTaXRCLGFBQVQsR0FBeUI7QUFDdkI7QUFDQTtBQUNBLFNBQUlJLG1CQUFtQnRoRSxVQUF2QjtBQUNBLFlBQU8sWUFBWTtBQUNqQixjQUFPc2hFLGlCQUFpQmh1QixLQUFqQixFQUF3QixDQUF4QixDQUFQO0FBQ0QsTUFGRDtBQUdEOztBQUVELE9BQUlwL0IsUUFBUSxJQUFJbGMsS0FBSixDQUFVLElBQVYsQ0FBWjtBQUNBLFlBQVNzN0MsS0FBVCxHQUFpQjtBQUNmLFVBQUssSUFBSTFtRCxJQUFJLENBQWIsRUFBZ0JBLElBQUkwVixHQUFwQixFQUF5QjFWLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0IsV0FBSTZ1QixXQUFXdkgsTUFBTXRuQixDQUFOLENBQWY7QUFDQSxXQUFJc2hDLE1BQU1oYSxNQUFNdG5CLElBQUksQ0FBVixDQUFWOztBQUVBNnVCLGdCQUFTeVMsR0FBVDs7QUFFQWhhLGFBQU10bkIsQ0FBTixJQUFXSixTQUFYO0FBQ0EwbkIsYUFBTXRuQixJQUFJLENBQVYsSUFBZUosU0FBZjtBQUNEOztBQUVEOFYsV0FBTSxDQUFOO0FBQ0Q7O0FBRUQsWUFBU2kvRCxZQUFULEdBQXdCO0FBQ3RCLFNBQUk7QUFDRixXQUFJNWUsSUFBSXhELE9BQVI7QUFDQSxXQUFJcWlCLFFBQVEsbUJBQUE3ZSxDQUFFLEVBQUYsQ0FBWjtBQUNBc2QsbUJBQVl1QixNQUFNQyxTQUFOLElBQW1CRCxNQUFNRSxZQUFyQztBQUNBLGNBQU9ULGVBQVA7QUFDRCxNQUxELENBS0UsT0FBTzkwRSxDQUFQLEVBQVU7QUFDVixjQUFPKzBFLGVBQVA7QUFDRDtBQUNGOztBQUVELE9BQUlkLGdCQUFnQjV6RSxTQUFwQjtBQUNBO0FBQ0EsT0FBSXEwRSxNQUFKLEVBQVk7QUFDVlQscUJBQWdCWSxhQUFoQjtBQUNELElBRkQsTUFFTyxJQUFJTCx1QkFBSixFQUE2QjtBQUNsQ1AscUJBQWdCZSxxQkFBaEI7QUFDRCxJQUZNLE1BRUEsSUFBSUwsUUFBSixFQUFjO0FBQ25CVixxQkFBZ0JpQixtQkFBaEI7QUFDRCxJQUZNLE1BRUEsSUFBSVosa0JBQWtCajBFLFNBQWxCLElBQStCLGVBQW1CLFVBQXRELEVBQWtFO0FBQ3ZFNHpFLHFCQUFnQm1CLGNBQWhCO0FBQ0QsSUFGTSxNQUVBO0FBQ0xuQixxQkFBZ0JjLGVBQWhCO0FBQ0Q7O0FBRUQsWUFBUzl1RSxJQUFULENBQWN1dkUsYUFBZCxFQUE2QkMsV0FBN0IsRUFBMEM7QUFDeEMsU0FBSUMsYUFBYXgxRSxTQUFqQjs7QUFFQSxTQUFJd1ksU0FBUyxJQUFiOztBQUVBLFNBQUlDLFFBQVEsSUFBSSxLQUFLdkgsV0FBVCxDQUFxQi9SLElBQXJCLENBQVo7O0FBRUEsU0FBSXNaLE1BQU1nOUQsVUFBTixNQUFzQnQxRSxTQUExQixFQUFxQztBQUNuQ3dzRCxtQkFBWWwwQyxLQUFaO0FBQ0Q7O0FBRUQsU0FBSWk5RCxTQUFTbDlELE9BQU9rOUQsTUFBcEI7O0FBRUEsU0FBSUEsTUFBSixFQUFZO0FBQ1YsUUFBQyxZQUFZO0FBQ1gsYUFBSXRtRCxXQUFXb21ELFdBQVdFLFNBQVMsQ0FBcEIsQ0FBZjtBQUNBNUIsY0FBSyxZQUFZO0FBQ2Ysa0JBQU82QixlQUFlRCxNQUFmLEVBQXVCajlELEtBQXZCLEVBQThCMlcsUUFBOUIsRUFBd0M1VyxPQUFPa21ELE9BQS9DLENBQVA7QUFDRCxVQUZEO0FBR0QsUUFMRDtBQU1ELE1BUEQsTUFPTztBQUNMa1gsaUJBQVVwOUQsTUFBVixFQUFrQkMsS0FBbEIsRUFBeUI2OEQsYUFBekIsRUFBd0NDLFdBQXhDO0FBQ0Q7O0FBRUQsWUFBTzk4RCxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkEsWUFBU285RCxTQUFULENBQW1CanRCLE1BQW5CLEVBQTJCO0FBQ3pCO0FBQ0EsU0FBSWt0QixjQUFjLElBQWxCOztBQUVBLFNBQUlsdEIsVUFBVSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQTVCLElBQXdDQSxPQUFPMTNDLFdBQVAsS0FBdUI0a0UsV0FBbkUsRUFBZ0Y7QUFDOUUsY0FBT2x0QixNQUFQO0FBQ0Q7O0FBRUQsU0FBSTVoRCxVQUFVLElBQUk4dUUsV0FBSixDQUFnQjMyRSxJQUFoQixDQUFkO0FBQ0EwSCxhQUFRRyxPQUFSLEVBQWlCNGhELE1BQWpCO0FBQ0EsWUFBTzVoRCxPQUFQO0FBQ0Q7O0FBRUQsT0FBSXl1RSxhQUFhN3NFLEtBQUtrckQsTUFBTCxHQUFjenJELFFBQWQsQ0FBdUIsRUFBdkIsRUFBMkIwN0IsU0FBM0IsQ0FBcUMsRUFBckMsQ0FBakI7O0FBRUEsWUFBUzVrQyxJQUFULEdBQWdCLENBQUU7O0FBRWxCLE9BQUk0MkUsVUFBVSxLQUFLLENBQW5CO0FBQ0EsT0FBSUMsWUFBWSxDQUFoQjtBQUNBLE9BQUlDLFdBQVcsQ0FBZjs7QUFFQSxPQUFJQyxpQkFBaUIsSUFBSUMsV0FBSixFQUFyQjs7QUFFQSxZQUFTQyxlQUFULEdBQTJCO0FBQ3pCLFlBQU8sSUFBSW56RSxTQUFKLENBQWMsMENBQWQsQ0FBUDtBQUNEOztBQUVELFlBQVNvekUsZUFBVCxHQUEyQjtBQUN6QixZQUFPLElBQUlwekUsU0FBSixDQUFjLHNEQUFkLENBQVA7QUFDRDs7QUFFRCxZQUFTcXpFLE9BQVQsQ0FBaUJ0dkUsT0FBakIsRUFBMEI7QUFDeEIsU0FBSTtBQUNGLGNBQU9BLFFBQVFqQixJQUFmO0FBQ0QsTUFGRCxDQUVFLE9BQU9NLEtBQVAsRUFBYztBQUNkNnZFLHNCQUFlN3ZFLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0EsY0FBTzZ2RSxjQUFQO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTSyxPQUFULENBQWlCQyxPQUFqQixFQUEwQnR1RSxLQUExQixFQUFpQ3V1RSxrQkFBakMsRUFBcURDLGdCQUFyRCxFQUF1RTtBQUNyRSxTQUFJO0FBQ0ZGLGVBQVEzMkUsSUFBUixDQUFhcUksS0FBYixFQUFvQnV1RSxrQkFBcEIsRUFBd0NDLGdCQUF4QztBQUNELE1BRkQsQ0FFRSxPQUFPNTJFLENBQVAsRUFBVTtBQUNWLGNBQU9BLENBQVA7QUFDRDtBQUNGOztBQUVELFlBQVM2MkUscUJBQVQsQ0FBK0IzdkUsT0FBL0IsRUFBd0M0dkUsUUFBeEMsRUFBa0RKLE9BQWxELEVBQTJEO0FBQ3pEMUMsVUFBSyxVQUFVOXNFLE9BQVYsRUFBbUI7QUFDdEIsV0FBSTBzQixTQUFTLEtBQWI7QUFDQSxXQUFJcnRCLFFBQVFrd0UsUUFBUUMsT0FBUixFQUFpQkksUUFBakIsRUFBMkIsVUFBVTF1RSxLQUFWLEVBQWlCO0FBQ3RELGFBQUl3ckIsTUFBSixFQUFZO0FBQ1Y7QUFDRDtBQUNEQSxrQkFBUyxJQUFUO0FBQ0EsYUFBSWtqRCxhQUFhMXVFLEtBQWpCLEVBQXdCO0FBQ3RCckIsbUJBQVFHLE9BQVIsRUFBaUJrQixLQUFqQjtBQUNELFVBRkQsTUFFTztBQUNMMmlELG1CQUFRN2pELE9BQVIsRUFBaUJrQixLQUFqQjtBQUNEO0FBQ0YsUUFWVyxFQVVULFVBQVVxYSxNQUFWLEVBQWtCO0FBQ25CLGFBQUltUixNQUFKLEVBQVk7QUFDVjtBQUNEO0FBQ0RBLGtCQUFTLElBQVQ7O0FBRUEzc0IsZ0JBQU9DLE9BQVAsRUFBZ0J1YixNQUFoQjtBQUNELFFBakJXLEVBaUJULGNBQWN2YixRQUFRNnZFLE1BQVIsSUFBa0Isa0JBQWhDLENBakJTLENBQVo7O0FBbUJBLFdBQUksQ0FBQ25qRCxNQUFELElBQVdydEIsS0FBZixFQUFzQjtBQUNwQnF0QixrQkFBUyxJQUFUO0FBQ0Ezc0IsZ0JBQU9DLE9BQVAsRUFBZ0JYLEtBQWhCO0FBQ0Q7QUFDRixNQXpCRCxFQXlCR1csT0F6Qkg7QUEwQkQ7O0FBRUQsWUFBUzh2RSxpQkFBVCxDQUEyQjl2RSxPQUEzQixFQUFvQzR2RSxRQUFwQyxFQUE4QztBQUM1QyxTQUFJQSxTQUFTbEIsTUFBVCxLQUFvQk0sU0FBeEIsRUFBbUM7QUFDakNuckIsZUFBUTdqRCxPQUFSLEVBQWlCNHZFLFNBQVNsWSxPQUExQjtBQUNELE1BRkQsTUFFTyxJQUFJa1ksU0FBU2xCLE1BQVQsS0FBb0JPLFFBQXhCLEVBQWtDO0FBQ3ZDbHZFLGNBQU9DLE9BQVAsRUFBZ0I0dkUsU0FBU2xZLE9BQXpCO0FBQ0QsTUFGTSxNQUVBO0FBQ0xrWCxpQkFBVWdCLFFBQVYsRUFBb0J6MkUsU0FBcEIsRUFBK0IsVUFBVStILEtBQVYsRUFBaUI7QUFDOUMsZ0JBQU9yQixRQUFRRyxPQUFSLEVBQWlCa0IsS0FBakIsQ0FBUDtBQUNELFFBRkQsRUFFRyxVQUFVcWEsTUFBVixFQUFrQjtBQUNuQixnQkFBT3hiLE9BQU9DLE9BQVAsRUFBZ0J1YixNQUFoQixDQUFQO0FBQ0QsUUFKRDtBQUtEO0FBQ0Y7O0FBRUQsWUFBU3cwRCxtQkFBVCxDQUE2Qi92RSxPQUE3QixFQUFzQ2d3RSxhQUF0QyxFQUFxRFIsT0FBckQsRUFBOEQ7QUFDNUQsU0FBSVEsY0FBYzlsRSxXQUFkLEtBQThCbEssUUFBUWtLLFdBQXRDLElBQXFEc2xFLFlBQVl6d0UsSUFBakUsSUFBeUVpeEUsY0FBYzlsRSxXQUFkLENBQTBCckssT0FBMUIsS0FBc0NndkUsU0FBbkgsRUFBOEg7QUFDNUhpQix5QkFBa0I5dkUsT0FBbEIsRUFBMkJnd0UsYUFBM0I7QUFDRCxNQUZELE1BRU87QUFDTCxXQUFJUixZQUFZTixjQUFoQixFQUFnQztBQUM5Qm52RSxnQkFBT0MsT0FBUCxFQUFnQmt2RSxlQUFlN3ZFLEtBQS9CO0FBQ0E2dkUsd0JBQWU3dkUsS0FBZixHQUF1QixJQUF2QjtBQUNELFFBSEQsTUFHTyxJQUFJbXdFLFlBQVlyMkUsU0FBaEIsRUFBMkI7QUFDaEMwcUQsaUJBQVE3akQsT0FBUixFQUFpQmd3RSxhQUFqQjtBQUNELFFBRk0sTUFFQSxJQUFJdlIsV0FBVytRLE9BQVgsQ0FBSixFQUF5QjtBQUM5QkcsK0JBQXNCM3ZFLE9BQXRCLEVBQStCZ3dFLGFBQS9CLEVBQThDUixPQUE5QztBQUNELFFBRk0sTUFFQTtBQUNMM3JCLGlCQUFRN2pELE9BQVIsRUFBaUJnd0UsYUFBakI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBU253RSxPQUFULENBQWlCRyxPQUFqQixFQUEwQmtCLEtBQTFCLEVBQWlDO0FBQy9CLFNBQUlsQixZQUFZa0IsS0FBaEIsRUFBdUI7QUFDckJuQixjQUFPQyxPQUFQLEVBQWdCb3ZFLGlCQUFoQjtBQUNELE1BRkQsTUFFTyxJQUFJMUMsaUJBQWlCeHJFLEtBQWpCLENBQUosRUFBNkI7QUFDbEM2dUUsMkJBQW9CL3ZFLE9BQXBCLEVBQTZCa0IsS0FBN0IsRUFBb0NvdUUsUUFBUXB1RSxLQUFSLENBQXBDO0FBQ0QsTUFGTSxNQUVBO0FBQ0wyaUQsZUFBUTdqRCxPQUFSLEVBQWlCa0IsS0FBakI7QUFDRDtBQUNGOztBQUVELFlBQVMrdUUsZ0JBQVQsQ0FBMEJqd0UsT0FBMUIsRUFBbUM7QUFDakMsU0FBSUEsUUFBUWt3RSxRQUFaLEVBQXNCO0FBQ3BCbHdFLGVBQVFrd0UsUUFBUixDQUFpQmx3RSxRQUFRMDNELE9BQXpCO0FBQ0Q7O0FBRUR5WSxhQUFRbndFLE9BQVI7QUFDRDs7QUFFRCxZQUFTNmpELE9BQVQsQ0FBaUI3akQsT0FBakIsRUFBMEJrQixLQUExQixFQUFpQztBQUMvQixTQUFJbEIsUUFBUTB1RSxNQUFSLEtBQW1CSyxPQUF2QixFQUFnQztBQUM5QjtBQUNEOztBQUVEL3VFLGFBQVEwM0QsT0FBUixHQUFrQngyRCxLQUFsQjtBQUNBbEIsYUFBUTB1RSxNQUFSLEdBQWlCTSxTQUFqQjs7QUFFQSxTQUFJaHZFLFFBQVFvd0UsWUFBUixDQUFxQjUyRSxNQUFyQixLQUFnQyxDQUFwQyxFQUF1QztBQUNyQ3N6RSxZQUFLcUQsT0FBTCxFQUFjbndFLE9BQWQ7QUFDRDtBQUNGOztBQUVELFlBQVNELE1BQVQsQ0FBZ0JDLE9BQWhCLEVBQXlCdWIsTUFBekIsRUFBaUM7QUFDL0IsU0FBSXZiLFFBQVEwdUUsTUFBUixLQUFtQkssT0FBdkIsRUFBZ0M7QUFDOUI7QUFDRDtBQUNEL3VFLGFBQVEwdUUsTUFBUixHQUFpQk8sUUFBakI7QUFDQWp2RSxhQUFRMDNELE9BQVIsR0FBa0JuOEMsTUFBbEI7O0FBRUF1eEQsVUFBS21ELGdCQUFMLEVBQXVCandFLE9BQXZCO0FBQ0Q7O0FBRUQsWUFBUzR1RSxTQUFULENBQW1CcDlELE1BQW5CLEVBQTJCQyxLQUEzQixFQUFrQzY4RCxhQUFsQyxFQUFpREMsV0FBakQsRUFBOEQ7QUFDNUQsU0FBSTZCLGVBQWU1K0QsT0FBTzQrRCxZQUExQjtBQUNBLFNBQUk1MkUsU0FBUzQyRSxhQUFhNTJFLE1BQTFCOztBQUVBZ1ksWUFBTzArRCxRQUFQLEdBQWtCLElBQWxCOztBQUVBRSxrQkFBYTUyRSxNQUFiLElBQXVCaVksS0FBdkI7QUFDQTIrRCxrQkFBYTUyRSxTQUFTdzFFLFNBQXRCLElBQW1DVixhQUFuQztBQUNBOEIsa0JBQWE1MkUsU0FBU3kxRSxRQUF0QixJQUFrQ1YsV0FBbEM7O0FBRUEsU0FBSS8wRSxXQUFXLENBQVgsSUFBZ0JnWSxPQUFPazlELE1BQTNCLEVBQW1DO0FBQ2pDNUIsWUFBS3FELE9BQUwsRUFBYzMrRCxNQUFkO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTMitELE9BQVQsQ0FBaUJud0UsT0FBakIsRUFBMEI7QUFDeEIsU0FBSXF3RSxjQUFjcndFLFFBQVFvd0UsWUFBMUI7QUFDQSxTQUFJRSxVQUFVdHdFLFFBQVEwdUUsTUFBdEI7O0FBRUEsU0FBSTJCLFlBQVk3MkUsTUFBWixLQUF1QixDQUEzQixFQUE4QjtBQUM1QjtBQUNEOztBQUVELFNBQUlpWSxRQUFRdFksU0FBWjtBQUFBLFNBQ0lpdkIsV0FBV2p2QixTQURmO0FBQUEsU0FFSW8zRSxTQUFTdndFLFFBQVEwM0QsT0FGckI7O0FBSUEsVUFBSyxJQUFJbitELElBQUksQ0FBYixFQUFnQkEsSUFBSTgyRSxZQUFZNzJFLE1BQWhDLEVBQXdDRCxLQUFLLENBQTdDLEVBQWdEO0FBQzlDa1ksZUFBUTQrRCxZQUFZOTJFLENBQVosQ0FBUjtBQUNBNnVCLGtCQUFXaW9ELFlBQVk5MkUsSUFBSSsyRSxPQUFoQixDQUFYOztBQUVBLFdBQUk3K0QsS0FBSixFQUFXO0FBQ1RrOUQsd0JBQWUyQixPQUFmLEVBQXdCNytELEtBQXhCLEVBQStCMlcsUUFBL0IsRUFBeUNtb0QsTUFBekM7QUFDRCxRQUZELE1BRU87QUFDTG5vRCxrQkFBU21vRCxNQUFUO0FBQ0Q7QUFDRjs7QUFFRHZ3RSxhQUFRb3dFLFlBQVIsQ0FBcUI1MkUsTUFBckIsR0FBOEIsQ0FBOUI7QUFDRDs7QUFFRCxZQUFTMjFFLFdBQVQsR0FBdUI7QUFDckIsVUFBSzl2RSxLQUFMLEdBQWEsSUFBYjtBQUNEOztBQUVELE9BQUlteEUsa0JBQWtCLElBQUlyQixXQUFKLEVBQXRCOztBQUVBLFlBQVNzQixRQUFULENBQWtCcm9ELFFBQWxCLEVBQTRCbW9ELE1BQTVCLEVBQW9DO0FBQ2xDLFNBQUk7QUFDRixjQUFPbm9ELFNBQVNtb0QsTUFBVCxDQUFQO0FBQ0QsTUFGRCxDQUVFLE9BQU96M0UsQ0FBUCxFQUFVO0FBQ1YwM0UsdUJBQWdCbnhFLEtBQWhCLEdBQXdCdkcsQ0FBeEI7QUFDQSxjQUFPMDNFLGVBQVA7QUFDRDtBQUNGOztBQUVELFlBQVM3QixjQUFULENBQXdCMkIsT0FBeEIsRUFBaUN0d0UsT0FBakMsRUFBMENvb0IsUUFBMUMsRUFBb0Rtb0QsTUFBcEQsRUFBNEQ7QUFDMUQsU0FBSUcsY0FBY2pTLFdBQVdyMkMsUUFBWCxDQUFsQjtBQUFBLFNBQ0lsbkIsUUFBUS9ILFNBRFo7QUFBQSxTQUVJa0csUUFBUWxHLFNBRlo7QUFBQSxTQUdJdzNFLFlBQVl4M0UsU0FIaEI7QUFBQSxTQUlJeTNFLFNBQVN6M0UsU0FKYjs7QUFNQSxTQUFJdTNFLFdBQUosRUFBaUI7QUFDZnh2RSxlQUFRdXZFLFNBQVNyb0QsUUFBVCxFQUFtQm1vRCxNQUFuQixDQUFSOztBQUVBLFdBQUlydkUsVUFBVXN2RSxlQUFkLEVBQStCO0FBQzdCSSxrQkFBUyxJQUFUO0FBQ0F2eEUsaUJBQVE2QixNQUFNN0IsS0FBZDtBQUNBNkIsZUFBTTdCLEtBQU4sR0FBYyxJQUFkO0FBQ0QsUUFKRCxNQUlPO0FBQ0xzeEUscUJBQVksSUFBWjtBQUNEOztBQUVELFdBQUkzd0UsWUFBWWtCLEtBQWhCLEVBQXVCO0FBQ3JCbkIsZ0JBQU9DLE9BQVAsRUFBZ0JxdkUsaUJBQWhCO0FBQ0E7QUFDRDtBQUNGLE1BZkQsTUFlTztBQUNMbnVFLGVBQVFxdkUsTUFBUjtBQUNBSSxtQkFBWSxJQUFaO0FBQ0Q7O0FBRUQsU0FBSTN3RSxRQUFRMHVFLE1BQVIsS0FBbUJLLE9BQXZCLEVBQWdDO0FBQzlCO0FBQ0QsTUFGRCxNQUVPLElBQUkyQixlQUFlQyxTQUFuQixFQUE4QjtBQUNqQzl3RSxlQUFRRyxPQUFSLEVBQWlCa0IsS0FBakI7QUFDRCxNQUZJLE1BRUUsSUFBSTB2RSxNQUFKLEVBQVk7QUFDakI3d0UsY0FBT0MsT0FBUCxFQUFnQlgsS0FBaEI7QUFDRCxNQUZNLE1BRUEsSUFBSWl4RSxZQUFZdEIsU0FBaEIsRUFBMkI7QUFDaENuckIsZUFBUTdqRCxPQUFSLEVBQWlCa0IsS0FBakI7QUFDRCxNQUZNLE1BRUEsSUFBSW92RSxZQUFZckIsUUFBaEIsRUFBMEI7QUFDL0JsdkUsY0FBT0MsT0FBUCxFQUFnQmtCLEtBQWhCO0FBQ0Q7QUFDSjs7QUFFRCxZQUFTMnZFLGlCQUFULENBQTJCN3dFLE9BQTNCLEVBQW9DbWxELFFBQXBDLEVBQThDO0FBQzVDLFNBQUk7QUFDRkEsZ0JBQVMsU0FBU2tuQixjQUFULENBQXdCbnJFLEtBQXhCLEVBQStCO0FBQ3RDckIsaUJBQVFHLE9BQVIsRUFBaUJrQixLQUFqQjtBQUNELFFBRkQsRUFFRyxTQUFTa3JFLGFBQVQsQ0FBdUI3d0QsTUFBdkIsRUFBK0I7QUFDaEN4YixnQkFBT0MsT0FBUCxFQUFnQnViLE1BQWhCO0FBQ0QsUUFKRDtBQUtELE1BTkQsQ0FNRSxPQUFPemlCLENBQVAsRUFBVTtBQUNWaUgsY0FBT0MsT0FBUCxFQUFnQmxILENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxPQUFJcUYsS0FBSyxDQUFUO0FBQ0EsWUFBUzJ5RSxNQUFULEdBQWtCO0FBQ2hCLFlBQU8zeUUsSUFBUDtBQUNEOztBQUVELFlBQVN3bkQsV0FBVCxDQUFxQjNsRCxPQUFyQixFQUE4QjtBQUM1QkEsYUFBUXl1RSxVQUFSLElBQXNCdHdFLElBQXRCO0FBQ0E2QixhQUFRMHVFLE1BQVIsR0FBaUJ2MUUsU0FBakI7QUFDQTZHLGFBQVEwM0QsT0FBUixHQUFrQnYrRCxTQUFsQjtBQUNBNkcsYUFBUW93RSxZQUFSLEdBQXVCLEVBQXZCO0FBQ0Q7O0FBRUQsWUFBU1csWUFBVCxDQUFzQmpDLFdBQXRCLEVBQW1Da0MsS0FBbkMsRUFBMEM7QUFDeEMsVUFBS0Msb0JBQUwsR0FBNEJuQyxXQUE1QjtBQUNBLFVBQUs5dUUsT0FBTCxHQUFlLElBQUk4dUUsV0FBSixDQUFnQjMyRSxJQUFoQixDQUFmOztBQUVBLFNBQUksQ0FBQyxLQUFLNkgsT0FBTCxDQUFheXVFLFVBQWIsQ0FBTCxFQUErQjtBQUM3QjlvQixtQkFBWSxLQUFLM2xELE9BQWpCO0FBQ0Q7O0FBRUQsU0FBSThGLFFBQVFrckUsS0FBUixDQUFKLEVBQW9CO0FBQ2xCLFlBQUt4M0UsTUFBTCxHQUFjdzNFLE1BQU14M0UsTUFBcEI7QUFDQSxZQUFLMDNFLFVBQUwsR0FBa0JGLE1BQU14M0UsTUFBeEI7O0FBRUEsWUFBS2srRCxPQUFMLEdBQWUsSUFBSS95RCxLQUFKLENBQVUsS0FBS25MLE1BQWYsQ0FBZjs7QUFFQSxXQUFJLEtBQUtBLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckJxcUQsaUJBQVEsS0FBSzdqRCxPQUFiLEVBQXNCLEtBQUswM0QsT0FBM0I7QUFDRCxRQUZELE1BRU87QUFDTCxjQUFLbCtELE1BQUwsR0FBYyxLQUFLQSxNQUFMLElBQWUsQ0FBN0I7QUFDQSxjQUFLMjNFLFVBQUwsQ0FBZ0JILEtBQWhCO0FBQ0EsYUFBSSxLQUFLRSxVQUFMLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3pCcnRCLG1CQUFRLEtBQUs3akQsT0FBYixFQUFzQixLQUFLMDNELE9BQTNCO0FBQ0Q7QUFDRjtBQUNGLE1BZkQsTUFlTztBQUNMMzNELGNBQU8sS0FBS0MsT0FBWixFQUFxQm94RSxpQkFBckI7QUFDRDtBQUNGOztBQUVELFlBQVNBLGVBQVQsR0FBMkI7QUFDekIsWUFBTyxJQUFJN3pCLEtBQUosQ0FBVSx5Q0FBVixDQUFQO0FBQ0Q7O0FBRUR3ekIsZ0JBQWFuNEUsU0FBYixDQUF1QnU0RSxVQUF2QixHQUFvQyxVQUFVSCxLQUFWLEVBQWlCO0FBQ25ELFVBQUssSUFBSXozRSxJQUFJLENBQWIsRUFBZ0IsS0FBS20xRSxNQUFMLEtBQWdCSyxPQUFoQixJQUEyQngxRSxJQUFJeTNFLE1BQU14M0UsTUFBckQsRUFBNkRELEdBQTdELEVBQWtFO0FBQ2hFLFlBQUs4M0UsVUFBTCxDQUFnQkwsTUFBTXozRSxDQUFOLENBQWhCLEVBQTBCQSxDQUExQjtBQUNEO0FBQ0YsSUFKRDs7QUFNQXczRSxnQkFBYW40RSxTQUFiLENBQXVCeTRFLFVBQXZCLEdBQW9DLFVBQVVDLEtBQVYsRUFBaUIvM0UsQ0FBakIsRUFBb0I7QUFDdEQsU0FBSXVLLElBQUksS0FBS210RSxvQkFBYjtBQUNBLFNBQUlNLGFBQWF6dEUsRUFBRWpFLE9BQW5COztBQUVBLFNBQUkweEUsZUFBZTFDLFNBQW5CLEVBQThCO0FBQzVCLFdBQUkyQyxRQUFRbEMsUUFBUWdDLEtBQVIsQ0FBWjs7QUFFQSxXQUFJRSxVQUFVenlFLElBQVYsSUFBa0J1eUUsTUFBTTVDLE1BQU4sS0FBaUJLLE9BQXZDLEVBQWdEO0FBQzlDLGNBQUswQyxVQUFMLENBQWdCSCxNQUFNNUMsTUFBdEIsRUFBOEJuMUUsQ0FBOUIsRUFBaUMrM0UsTUFBTTVaLE9BQXZDO0FBQ0QsUUFGRCxNQUVPLElBQUksT0FBTzhaLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7QUFDdEMsY0FBS04sVUFBTDtBQUNBLGNBQUt4WixPQUFMLENBQWFuK0QsQ0FBYixJQUFrQiszRSxLQUFsQjtBQUNELFFBSE0sTUFHQSxJQUFJeHRFLE1BQU00dEUsU0FBVixFQUFxQjtBQUMxQixhQUFJMXhFLFVBQVUsSUFBSThELENBQUosQ0FBTTNMLElBQU4sQ0FBZDtBQUNBNDNFLDZCQUFvQi92RSxPQUFwQixFQUE2QnN4RSxLQUE3QixFQUFvQ0UsS0FBcEM7QUFDQSxjQUFLRyxhQUFMLENBQW1CM3hFLE9BQW5CLEVBQTRCekcsQ0FBNUI7QUFDRCxRQUpNLE1BSUE7QUFDTCxjQUFLbzRFLGFBQUwsQ0FBbUIsSUFBSTd0RSxDQUFKLENBQU0sVUFBVXl0RSxVQUFWLEVBQXNCO0FBQzdDLGtCQUFPQSxXQUFXRCxLQUFYLENBQVA7QUFDRCxVQUZrQixDQUFuQixFQUVJLzNFLENBRko7QUFHRDtBQUNGLE1BakJELE1BaUJPO0FBQ0wsWUFBS280RSxhQUFMLENBQW1CSixXQUFXRCxLQUFYLENBQW5CLEVBQXNDLzNFLENBQXRDO0FBQ0Q7QUFDRixJQXhCRDs7QUEwQkF3M0UsZ0JBQWFuNEUsU0FBYixDQUF1QjY0RSxVQUF2QixHQUFvQyxVQUFVaDVCLEtBQVYsRUFBaUJsL0MsQ0FBakIsRUFBb0IySCxLQUFwQixFQUEyQjtBQUM3RCxTQUFJbEIsVUFBVSxLQUFLQSxPQUFuQjs7QUFFQSxTQUFJQSxRQUFRMHVFLE1BQVIsS0FBbUJLLE9BQXZCLEVBQWdDO0FBQzlCLFlBQUttQyxVQUFMOztBQUVBLFdBQUl6NEIsVUFBVXcyQixRQUFkLEVBQXdCO0FBQ3RCbHZFLGdCQUFPQyxPQUFQLEVBQWdCa0IsS0FBaEI7QUFDRCxRQUZELE1BRU87QUFDTCxjQUFLdzJELE9BQUwsQ0FBYW4rRCxDQUFiLElBQWtCMkgsS0FBbEI7QUFDRDtBQUNGOztBQUVELFNBQUksS0FBS2d3RSxVQUFMLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3pCcnRCLGVBQVE3akQsT0FBUixFQUFpQixLQUFLMDNELE9BQXRCO0FBQ0Q7QUFDRixJQWhCRDs7QUFrQkFxWixnQkFBYW40RSxTQUFiLENBQXVCKzRFLGFBQXZCLEdBQXVDLFVBQVUzeEUsT0FBVixFQUFtQnpHLENBQW5CLEVBQXNCO0FBQzNELFNBQUlxNEUsYUFBYSxJQUFqQjs7QUFFQWhELGVBQVU1dUUsT0FBVixFQUFtQjdHLFNBQW5CLEVBQThCLFVBQVUrSCxLQUFWLEVBQWlCO0FBQzdDLGNBQU8wd0UsV0FBV0gsVUFBWCxDQUFzQnpDLFNBQXRCLEVBQWlDejFFLENBQWpDLEVBQW9DMkgsS0FBcEMsQ0FBUDtBQUNELE1BRkQsRUFFRyxVQUFVcWEsTUFBVixFQUFrQjtBQUNuQixjQUFPcTJELFdBQVdILFVBQVgsQ0FBc0J4QyxRQUF0QixFQUFnQzExRSxDQUFoQyxFQUFtQ2dpQixNQUFuQyxDQUFQO0FBQ0QsTUFKRDtBQUtELElBUkQ7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBLFlBQVNzMkQsS0FBVCxDQUFlQyxPQUFmLEVBQXdCO0FBQ3RCLFlBQU8sSUFBSWYsWUFBSixDQUFpQixJQUFqQixFQUF1QmUsT0FBdkIsRUFBZ0M5eEUsT0FBdkM7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpRUEsWUFBUyt4RSxNQUFULENBQWdCRCxPQUFoQixFQUF5QjtBQUN2QjtBQUNBLFNBQUloRCxjQUFjLElBQWxCOztBQUVBLFNBQUksQ0FBQ2hwRSxRQUFRZ3NFLE9BQVIsQ0FBTCxFQUF1QjtBQUNyQixjQUFPLElBQUloRCxXQUFKLENBQWdCLFVBQVVqckUsQ0FBVixFQUFhOUQsTUFBYixFQUFxQjtBQUMxQyxnQkFBT0EsT0FBTyxJQUFJOUQsU0FBSixDQUFjLGlDQUFkLENBQVAsQ0FBUDtBQUNELFFBRk0sQ0FBUDtBQUdELE1BSkQsTUFJTztBQUNMLGNBQU8sSUFBSTZ5RSxXQUFKLENBQWdCLFVBQVVqdkUsT0FBVixFQUFtQkUsTUFBbkIsRUFBMkI7QUFDaEQsYUFBSXZHLFNBQVNzNEUsUUFBUXQ0RSxNQUFyQjtBQUNBLGNBQUssSUFBSUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJQyxNQUFwQixFQUE0QkQsR0FBNUIsRUFBaUM7QUFDL0J1MUUsdUJBQVlqdkUsT0FBWixDQUFvQml5RSxRQUFRdjRFLENBQVIsQ0FBcEIsRUFBZ0N3RixJQUFoQyxDQUFxQ2MsT0FBckMsRUFBOENFLE1BQTlDO0FBQ0Q7QUFDRixRQUxNLENBQVA7QUFNRDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBLFlBQVNpeUUsUUFBVCxDQUFrQnoyRCxNQUFsQixFQUEwQjtBQUN4QjtBQUNBLFNBQUl1ekQsY0FBYyxJQUFsQjtBQUNBLFNBQUk5dUUsVUFBVSxJQUFJOHVFLFdBQUosQ0FBZ0IzMkUsSUFBaEIsQ0FBZDtBQUNBNEgsWUFBT0MsT0FBUCxFQUFnQnViLE1BQWhCO0FBQ0EsWUFBT3ZiLE9BQVA7QUFDRDs7QUFFRCxZQUFTaXlFLGFBQVQsR0FBeUI7QUFDdkIsV0FBTSxJQUFJaDJFLFNBQUosQ0FBYyxvRkFBZCxDQUFOO0FBQ0Q7O0FBRUQsWUFBU2kyRSxRQUFULEdBQW9CO0FBQ2xCLFdBQU0sSUFBSWoyRSxTQUFKLENBQWMsdUhBQWQsQ0FBTjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUdBLFlBQVN5MUUsU0FBVCxDQUFtQnZzQixRQUFuQixFQUE2QjtBQUMzQixVQUFLc3BCLFVBQUwsSUFBbUJxQyxRQUFuQjtBQUNBLFVBQUtwWixPQUFMLEdBQWUsS0FBS2dYLE1BQUwsR0FBY3YxRSxTQUE3QjtBQUNBLFVBQUtpM0UsWUFBTCxHQUFvQixFQUFwQjs7QUFFQSxTQUFJajRFLFNBQVNndEQsUUFBYixFQUF1QjtBQUNyQixjQUFPQSxRQUFQLEtBQW9CLFVBQXBCLElBQWtDOHNCLGVBQWxDO0FBQ0EsdUJBQWdCUCxTQUFoQixHQUE0QmIsa0JBQWtCLElBQWxCLEVBQXdCMXJCLFFBQXhCLENBQTVCLEdBQWdFK3NCLFVBQWhFO0FBQ0Q7QUFDRjs7QUFFRFIsYUFBVTdnQyxHQUFWLEdBQWdCZ2hDLEtBQWhCO0FBQ0FILGFBQVV0c0IsSUFBVixHQUFpQjJzQixNQUFqQjtBQUNBTCxhQUFVN3hFLE9BQVYsR0FBb0JndkUsU0FBcEI7QUFDQTZDLGFBQVUzeEUsTUFBVixHQUFtQml5RSxRQUFuQjtBQUNBTixhQUFVUyxhQUFWLEdBQTBCbkYsWUFBMUI7QUFDQTBFLGFBQVVVLFFBQVYsR0FBcUJsRixPQUFyQjtBQUNBd0UsYUFBVVcsS0FBVixHQUFrQnZGLElBQWxCOztBQUVBNEUsYUFBVTk0RSxTQUFWLEdBQXNCO0FBQ3BCc1Isa0JBQWF3bkUsU0FETzs7QUFHcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpTUEzeUUsV0FBTUEsSUFwTWM7O0FBc01wQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBLGNBQVMsU0FBU3V6RSxNQUFULENBQWdCL0QsV0FBaEIsRUFBNkI7QUFDcEMsY0FBTyxLQUFLeHZFLElBQUwsQ0FBVSxJQUFWLEVBQWdCd3ZFLFdBQWhCLENBQVA7QUFDRDtBQW5PbUIsSUFBdEI7O0FBc09BO0FBQ0EsWUFBU2dFLFVBQVQsR0FBc0I7QUFDbEIsU0FBSTExRSxRQUFRMUQsU0FBWjs7QUFFQSxTQUFJLE9BQU9zUyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0FBQy9CNU8sZUFBUTRPLE1BQVI7QUFDSCxNQUZELE1BRU8sSUFBSSxPQUFPeFIsSUFBUCxLQUFnQixXQUFwQixFQUFpQztBQUNwQzRDLGVBQVE1QyxJQUFSO0FBQ0gsTUFGTSxNQUVBO0FBQ0gsV0FBSTtBQUNBNEMsaUJBQVFsRSxTQUFTLGFBQVQsR0FBUjtBQUNILFFBRkQsQ0FFRSxPQUFPRyxDQUFQLEVBQVU7QUFDUixlQUFNLElBQUl5a0QsS0FBSixDQUFVLDBFQUFWLENBQU47QUFDSDtBQUNKOztBQUVELFNBQUlpMUIsSUFBSTMxRSxNQUFNMlAsT0FBZDs7QUFFQSxTQUFJZ21FLENBQUosRUFBTztBQUNILFdBQUlDLGtCQUFrQixJQUF0QjtBQUNBLFdBQUk7QUFDQUEsMkJBQWtCdHlFLE9BQU92SCxTQUFQLENBQWlCeUksUUFBakIsQ0FBMEJ4SSxJQUExQixDQUErQjI1RSxFQUFFM3lFLE9BQUYsRUFBL0IsQ0FBbEI7QUFDSCxRQUZELENBRUUsT0FBTy9HLENBQVAsRUFBVTtBQUNSO0FBQ0g7O0FBRUQsV0FBSTI1RSxvQkFBb0Isa0JBQXBCLElBQTBDLENBQUNELEVBQUVFLElBQWpELEVBQXVEO0FBQ25EO0FBQ0g7QUFDSjs7QUFFRDcxRSxXQUFNMlAsT0FBTixHQUFnQmtsRSxTQUFoQjtBQUNIOztBQUVEO0FBQ0FBLGFBQVVpQixRQUFWLEdBQXFCSixVQUFyQjtBQUNBYixhQUFVbGxFLE9BQVYsR0FBb0JrbEUsU0FBcEI7O0FBRUEsVUFBT0EsU0FBUDtBQUVDLEVBMW5DQSxDQUFEOztBQTRuQ0EscUM7Ozs7Ozs7QUNwb0NBLGdCOzs7Ozs7QUNBQTs7QUFFQTE1RSxRQUFPQyxPQUFQLEdBQWlCa3lFLGFBQWpCOztBQUVBLEtBQUl5SSxTQUFTLG1CQUFBOW1CLENBQVEsRUFBUixDQUFiOztBQUVBLFVBQVNxZSxhQUFULENBQXVCdnJFLEdBQXZCLEVBQTRCMGpFLE9BQTVCLEVBQXFDO0FBQ25DLE9BQUksS0FBSzc1RCxJQUFMLENBQVU3SixHQUFWLENBQUosRUFBb0I7QUFDbEJBLFlBQU8sR0FBUDtBQUNELElBRkQsTUFFTztBQUNMQSxZQUFPLEdBQVA7QUFDRDs7QUFFRCxVQUFPQSxNQUFNZzBFLE9BQU90USxPQUFQLENBQWI7QUFDRCxFOzs7Ozs7QUNkRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBRUEsS0FBSXVRLHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQVNoeUUsQ0FBVCxFQUFZO0FBQ25DLGtCQUFlQSxDQUFmLHlDQUFlQSxDQUFmO0FBQ0UsVUFBSyxRQUFMO0FBQ0UsY0FBT0EsQ0FBUDs7QUFFRixVQUFLLFNBQUw7QUFDRSxjQUFPQSxJQUFJLE1BQUosR0FBYSxPQUFwQjs7QUFFRixVQUFLLFFBQUw7QUFDRSxjQUFPaUIsU0FBU2pCLENBQVQsSUFBY0EsQ0FBZCxHQUFrQixFQUF6Qjs7QUFFRjtBQUNFLGNBQU8sRUFBUDtBQVhKO0FBYUQsRUFkRDs7QUFnQkE3SSxRQUFPQyxPQUFQLEdBQWlCLFVBQVNNLEdBQVQsRUFBY3U2RSxHQUFkLEVBQW1CQyxFQUFuQixFQUF1Qmo1RSxJQUF2QixFQUE2QjtBQUM1Q2c1RSxTQUFNQSxPQUFPLEdBQWI7QUFDQUMsUUFBS0EsTUFBTSxHQUFYO0FBQ0EsT0FBSXg2RSxRQUFRLElBQVosRUFBa0I7QUFDaEJBLFdBQU1ZLFNBQU47QUFDRDs7QUFFRCxPQUFJLFFBQU9aLEdBQVAseUNBQU9BLEdBQVAsT0FBZSxRQUFuQixFQUE2QjtBQUMzQixZQUFPZ0ssSUFBSXl3RSxXQUFXejZFLEdBQVgsQ0FBSixFQUFxQixVQUFTMGpFLENBQVQsRUFBWTtBQUN0QyxXQUFJZ1gsS0FBS3A0RSxtQkFBbUJnNEUsbUJBQW1CNVcsQ0FBbkIsQ0FBbkIsSUFBNEM4VyxFQUFyRDtBQUNBLFdBQUlqdEUsUUFBUXZOLElBQUkwakUsQ0FBSixDQUFSLENBQUosRUFBcUI7QUFDbkIsZ0JBQU8xNUQsSUFBSWhLLElBQUkwakUsQ0FBSixDQUFKLEVBQVksVUFBU3A3RCxDQUFULEVBQVk7QUFDN0Isa0JBQU9veUUsS0FBS3A0RSxtQkFBbUJnNEUsbUJBQW1CaHlFLENBQW5CLENBQW5CLENBQVo7QUFDRCxVQUZNLEVBRUo0RSxJQUZJLENBRUNxdEUsR0FGRCxDQUFQO0FBR0QsUUFKRCxNQUlPO0FBQ0wsZ0JBQU9HLEtBQUtwNEUsbUJBQW1CZzRFLG1CQUFtQnQ2RSxJQUFJMGpFLENBQUosQ0FBbkIsQ0FBbkIsQ0FBWjtBQUNEO0FBQ0YsTUFUTSxFQVNKeDJELElBVEksQ0FTQ3F0RSxHQVRELENBQVA7QUFXRDs7QUFFRCxPQUFJLENBQUNoNUUsSUFBTCxFQUFXLE9BQU8sRUFBUDtBQUNYLFVBQU9lLG1CQUFtQmc0RSxtQkFBbUIvNEUsSUFBbkIsQ0FBbkIsSUFBK0NpNUUsRUFBL0MsR0FDQWw0RSxtQkFBbUJnNEUsbUJBQW1CdDZFLEdBQW5CLENBQW5CLENBRFA7QUFFRCxFQXhCRDs7QUEwQkEsS0FBSXVOLFVBQVVuQixNQUFNbUIsT0FBTixJQUFpQixVQUFVb3RFLEVBQVYsRUFBYztBQUMzQyxVQUFPL3lFLE9BQU92SCxTQUFQLENBQWlCeUksUUFBakIsQ0FBMEJ4SSxJQUExQixDQUErQnE2RSxFQUEvQixNQUF1QyxnQkFBOUM7QUFDRCxFQUZEOztBQUlBLFVBQVMzd0UsR0FBVCxDQUFjMndFLEVBQWQsRUFBa0J2b0MsQ0FBbEIsRUFBcUI7QUFDbkIsT0FBSXVvQyxHQUFHM3dFLEdBQVAsRUFBWSxPQUFPMndFLEdBQUczd0UsR0FBSCxDQUFPb29DLENBQVAsQ0FBUDtBQUNaLE9BQUl0c0MsTUFBTSxFQUFWO0FBQ0EsUUFBSyxJQUFJOUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMjVFLEdBQUcxNUUsTUFBdkIsRUFBK0JELEdBQS9CLEVBQW9DO0FBQ2xDOEUsU0FBSThMLElBQUosQ0FBU3dnQyxFQUFFdW9DLEdBQUczNUUsQ0FBSCxDQUFGLEVBQVNBLENBQVQsQ0FBVDtBQUNEO0FBQ0QsVUFBTzhFLEdBQVA7QUFDRDs7QUFFRCxLQUFJMjBFLGFBQWE3eUUsT0FBT0MsSUFBUCxJQUFlLFVBQVU3SCxHQUFWLEVBQWU7QUFDN0MsT0FBSThGLE1BQU0sRUFBVjtBQUNBLFFBQUssSUFBSStFLEdBQVQsSUFBZ0I3SyxHQUFoQixFQUFxQjtBQUNuQixTQUFJNEgsT0FBT3ZILFNBQVAsQ0FBaUJzSyxjQUFqQixDQUFnQ3JLLElBQWhDLENBQXFDTixHQUFyQyxFQUEwQzZLLEdBQTFDLENBQUosRUFBb0QvRSxJQUFJOEwsSUFBSixDQUFTL0csR0FBVDtBQUNyRDtBQUNELFVBQU8vRSxHQUFQO0FBQ0QsRUFORCxDOzs7Ozs7QUM5RUE7O0FBRUFyRyxRQUFPQyxPQUFQLEdBQWlCbXlFLFlBQWpCOztBQUVBLEtBQUkzdUIsU0FBUyxtQkFBQXFRLENBQVEsRUFBUixDQUFiOztBQUVBLEtBQUlxbkIsZUFBZSxDQUFuQjs7QUFFQSxVQUFTL0ksWUFBVCxDQUFzQnhyRSxHQUF0QixFQUEyQndNLElBQTNCLEVBQWlDZ0MsRUFBakMsRUFBcUM7QUFDbkMsT0FBSWhDLEtBQUszUyxNQUFMLEtBQWdCLEtBQXBCLEVBQTJCO0FBQ3pCMlUsUUFBRyxJQUFJbXdDLEtBQUosQ0FBVSxZQUFZbnlDLEtBQUszUyxNQUFqQixHQUEwQixHQUExQixHQUFnQ21HLEdBQWhDLEdBQXNDLDZCQUFoRCxDQUFIO0FBQ0E7QUFDRDs7QUFFRHdNLFFBQUsxUixLQUFMLENBQVcsY0FBWDs7QUFFQSxPQUFJMDVFLFdBQVcsS0FBZjtBQUNBLE9BQUloSSxXQUFXLEtBQWY7O0FBRUErSCxtQkFBZ0IsQ0FBaEI7QUFDQSxPQUFJeHpCLE9BQU9obEQsU0FBUzA0RSxvQkFBVCxDQUE4QixNQUE5QixFQUFzQyxDQUF0QyxDQUFYO0FBQ0EsT0FBSWxtQixTQUFTeHlELFNBQVN1ckIsYUFBVCxDQUF1QixRQUF2QixDQUFiO0FBQ0EsT0FBSW90RCxTQUFTLGtCQUFrQkgsWUFBL0I7QUFDQSxPQUFJbnRCLE9BQU8sS0FBWDs7QUFFQXhyRCxVQUFPODRFLE1BQVAsSUFBaUIsVUFBU3gwRSxJQUFULEVBQWU7QUFDOUJ5MEU7O0FBRUEsU0FBSW5JLFFBQUosRUFBYztBQUNaaGdFLFlBQUsxUixLQUFMLENBQVcsOEJBQVg7QUFDQTtBQUNEOztBQUVEMDVFLGdCQUFXLElBQVg7O0FBRUFJOztBQUVBcG1FLFFBQUcsSUFBSCxFQUFTO0FBQ1BzOUIsYUFBTTVyQyxJQURDLENBQ0c7Ozs7QUFESCxNQUFUO0FBTUQsSUFsQkQ7O0FBb0JBO0FBQ0FGLFVBQU8sZUFBZTAwRSxNQUF0Qjs7QUFFQTtBQUNBLE9BQUlsb0UsS0FBSzIzRCxRQUFMLElBQWlCMzNELEtBQUsyM0QsUUFBTCxDQUFjOVUsTUFBbkMsRUFBMkM7QUFDekNydkQsWUFBTyxNQUFNd00sS0FBSzIzRCxRQUFMLENBQWM5VSxNQUEzQjtBQUNEOztBQUVELE9BQUl3bEIsWUFBWTltRSxXQUFXK08sT0FBWCxFQUFvQnRRLEtBQUswMUQsUUFBTCxDQUFjNEYsUUFBbEMsQ0FBaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0F2WixVQUFPQyxrQkFBUCxHQUE0QnNtQixnQkFBNUI7QUFDQXZtQixVQUFPcWUsTUFBUCxHQUFnQnpVLE9BQWhCO0FBQ0E1SixVQUFPNUcsT0FBUCxHQUFpQmxuRCxLQUFqQjs7QUFFQTh0RCxVQUFPcEYsS0FBUCxHQUFlLElBQWY7QUFDQW9GLFVBQU96dEQsS0FBUCxHQUFlLElBQWY7QUFDQXl0RCxVQUFPLzhDLEdBQVAsR0FBYXhSLEdBQWI7QUFDQStnRCxRQUFLMXRCLFdBQUwsQ0FBaUJrN0IsTUFBakI7O0FBRUEsWUFBUzRKLE9BQVQsR0FBbUI7QUFDakIzckQsVUFBSzFSLEtBQUwsQ0FBVyxnQkFBWDs7QUFFQSxTQUFJc3NELFFBQVFvbEIsUUFBWixFQUFzQjtBQUNwQjtBQUNEOztBQUVEcGxCLFlBQU8sSUFBUDs7QUFFQTtBQUNBLFNBQUksQ0FBQ290QixRQUFMLEVBQWU7QUFDYmhvRSxZQUFLMVIsS0FBTCxDQUFXLDBEQUFYO0FBQ0E4NUU7QUFDQXBtRSxVQUFHLElBQUlxdUMsT0FBT3FnQixlQUFYLEVBQUg7QUFDRDtBQUNGOztBQUVELFlBQVM0WCxnQkFBVCxHQUE0QjtBQUMxQixTQUFJLEtBQUsxSCxVQUFMLEtBQW9CLFFBQXBCLElBQWdDLEtBQUtBLFVBQUwsS0FBb0IsVUFBeEQsRUFBb0U7QUFDbEVqVjtBQUNEO0FBQ0Y7O0FBRUQsWUFBU3ljLEtBQVQsR0FBaUI7QUFDZi8xQixrQkFBYWcyQixTQUFiO0FBQ0F0bUIsWUFBT3FlLE1BQVAsR0FBZ0IsSUFBaEI7QUFDQXJlLFlBQU9DLGtCQUFQLEdBQTRCLElBQTVCO0FBQ0FELFlBQU81RyxPQUFQLEdBQWlCLElBQWpCO0FBQ0E1RyxVQUFLM3RCLFdBQUwsQ0FBaUJtN0IsTUFBakI7QUFDRDs7QUFFRCxZQUFTb21CLGFBQVQsR0FBeUI7QUFDdkIsU0FBSTtBQUNGLGNBQU8vNEUsT0FBTzg0RSxNQUFQLENBQVA7QUFDQSxjQUFPOTRFLE9BQU84NEUsU0FBUyxTQUFoQixDQUFQO0FBQ0QsTUFIRCxDQUdFLE9BQU94NkUsQ0FBUCxFQUFVO0FBQ1YwQixjQUFPODRFLE1BQVAsSUFBaUI5NEUsT0FBTzg0RSxTQUFTLFNBQWhCLElBQTZCbjZFLFNBQTlDO0FBQ0Q7QUFDRjs7QUFFRCxZQUFTdWlCLE9BQVQsR0FBbUI7QUFDakJ0USxVQUFLMVIsS0FBTCxDQUFXLHVCQUFYO0FBQ0EweEUsZ0JBQVcsSUFBWDtBQUNBb0k7QUFDQXBtRSxRQUFHLElBQUlxdUMsT0FBT21nQixjQUFYLEVBQUg7QUFDRDs7QUFFRCxZQUFTdjhELEtBQVQsR0FBaUI7QUFDZitMLFVBQUsxUixLQUFMLENBQVcscUJBQVg7O0FBRUEsU0FBSXNzRCxRQUFRb2xCLFFBQVosRUFBc0I7QUFDcEI7QUFDRDs7QUFFRG9JO0FBQ0FwbUUsUUFBRyxJQUFJcXVDLE9BQU9zZ0IsZ0JBQVgsRUFBSDtBQUNEO0FBQ0YsRTs7Ozs7Ozs7OztBQzVIRC9qRSxRQUFPQyxPQUFQLEdBQWlCMDdFLGtCQUFqQjs7QUFFQSxLQUFJeFosb0JBQW9CLG1CQUFBck8sQ0FBUSxFQUFSLENBQXhCOztBQUVBLFVBQVM2bkIsa0JBQVQsQ0FBNEJ2WixhQUE1QixFQUEyQztBQUN6QyxVQUFPLFNBQVNpUSxNQUFULENBQWdCaHRFLEtBQWhCLEVBQXVCQyxNQUF2QixFQUErQjhOLElBQS9CLEVBQXFDO0FBQzFDLFNBQUlrL0QsWUFBWSxtQkFBQXhlLENBQVEsRUFBUixDQUFoQjs7QUFFQTFnRCxZQUFPQSxRQUFRay9ELFVBQVVsL0QsSUFBVixDQUFSLElBQTJCLEVBQWxDO0FBQ0FBLFVBQUtzMUQsS0FBTCxHQUFhdDFELEtBQUtzMUQsS0FBTCxJQUFjLENBQ3pCLHdCQUR5QixFQUV6Qix5QkFGeUIsRUFHekIseUJBSHlCLEVBSXpCLHlCQUp5QixDQUEzQjs7QUFPQTtBQUNBLFNBQUkxbkUsVUFBVVEsTUFBVixLQUFxQixDQUFyQixJQUEwQixRQUFPNkQsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUEzQyxJQUF1REEsVUFBVWxFLFNBQXJFLEVBQWdGO0FBQzlFa0UsZUFBUSxFQUFSO0FBQ0FDLGdCQUFTLEVBQVQ7QUFDQThOLFlBQUtxMUQsc0JBQUwsR0FBOEIsSUFBOUI7QUFDRDs7QUFFRCxTQUFJckssU0FBU2dFLGNBQWMvOEQsS0FBZCxFQUFxQkMsTUFBckIsRUFBNkI4TixJQUE3QixDQUFiO0FBQ0EsU0FBSTdOLFFBQVE2NEQsT0FBT3JJLFNBQVAsQ0FBaUIsUUFBakIsQ0FBWjtBQUNBeHdELFdBQU00d0QsTUFBTixHQUFlZ00sa0JBQWtCLE9BQWxCLEVBQTJCLGlCQUEzQixDQUFmO0FBQ0E1OEQsV0FBTXd4RCxTQUFOLEdBQWtCLFVBQVNELFFBQVQsRUFBbUIxbUMsUUFBbkIsRUFBNkI7QUFDN0MsY0FBTyxLQUFLaXRDLEVBQUwsQ0FBUTFELFlBQVIsQ0FBcUI7QUFDMUJsNUQsaUJBQVEsS0FEa0I7QUFFMUJtRyxjQUFLLGVBQWUvRCxtQkFBbUJpMEQsUUFBbkIsQ0FGTTtBQUcxQjhDLG1CQUFVLE1BSGdCO0FBSTFCeHBDLG1CQUFVQTtBQUpnQixRQUFyQixDQUFQO0FBTUQsTUFQRDtBQVFBLFlBQU83cUIsS0FBUDtBQUNELElBOUJEO0FBK0JELEU7Ozs7OztBQ3BDRDs7QUFFQXZGLFFBQU9DLE9BQVAsR0FBaUJzeUUsbUJBQWpCOztBQUVBLFVBQVNBLG1CQUFULEdBQStCO0FBQzdCLE9BQUkxYyxXQUFXcnpELE9BQU9HLFFBQVAsQ0FBZ0JLLFFBQWhCLENBQXlCNnlELFFBQXhDOztBQUVBO0FBQ0EsT0FBSUEsYUFBYSxPQUFiLElBQXdCQSxhQUFhLFFBQXpDLEVBQW1EO0FBQ2pEQSxnQkFBVyxPQUFYO0FBQ0Q7O0FBRUQsVUFBT0EsUUFBUDtBQUNELEU7Ozs7OztBQ2JEOztBQUVBNzFELFFBQU9DLE9BQVAsR0FBaUIsUUFBakIsQyIsImZpbGUiOiJldmVudC1wYWdlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNGNhYTg3ZjEyYTkzNDIzMTU4ODQiLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCdcbmltcG9ydCBRIGZyb20gJ3EnXG5cbmltcG9ydCBFeHBsYWFpblNlYXJjaCBmcm9tICcuLi9wbHVnaW5zL2V4cGxhYWluLXNlYXJjaC5qcyc7XG5cbmxvZy5zZXRMZXZlbCgnZGVidWcnKVxuXG5jb25zdCBVc2VySURzID0ge1xuICBsaXZlOiB7XG4gICAgSmVyZW15OiAnMTYyNzg4ODgwMDU2OTMwOScsXG4gICAgTWF0dDogJzE0NTU3MDcyNDc4NTAwNjknLFxuICAgIENhcm9sOiAnMTQ1OTA2ODk5MDg3ODA3NycsXG4gICAgSGFycmlldDogJzE0Nzg3NzYyMzIxNjE0NjgnLFxuICAgIEpvbm55OiAnMTUxMzU1NDQzODcyOTc1MycsXG4gIH0sXG4gIHN0YWdpbmc6IHtcbiAgICBKZXJlbXk6ICcxMzY2NzQ2MzcwMDg5NTI3JyxcbiAgICBNYXR0OiAnMTUyODEzNDk5MDU2MzIwMicsXG4gIH0sXG4gIGxvY2FsOiB7XG4gICAgSmVyZW15OiAnMTMwMDEyMDg4MDExMDc3MycsXG4gICAgTWF0dDogJzE0Mjg0MTkxMDA1Mjg0MzgnLFxuICB9LFxuICBkcml2ZToge1xuICAgIEplcmVteTogJzEwNDM4MDExMDI3OTY1ODkyMDE3NScsXG4gICAgQUNNRTogJzEwMTExODM4NzMwMTI4NjIzMjIyMidcbiAgfVxufVxuXG5jb25zdCBVc2VySUQgPSBVc2VySURzLmRyaXZlLkFDTUVcbnZhciBQYWdlUmVzdWx0cyA9IHt9XG52YXIgVXNlckNhcmRzID0gW11cbnZhciBMYXN0UmVmcmVzaCA9IDBcblxuY29uc3QgYWxnb2xpYVBhcmFtcyA9IHsgLy8gTmVlZCB0byBzZW5kIHRoZXNlIHRvIGFwcC52dWUgdG8gYXZvaWQgZHVwbGljYXRpb24hXG4gIGFwcElEOiAnSTJWS01OTkFYSScsXG4gIGFwaUtleTogJzJiODQwNmY4NGNkNGNjNTA3ZGExNzMwMzJjNDZlZTdiJyxcbiAgaW5kZXg6ICdGb3JnZXRNZU5vdF9Db250ZXh0X1Rlc3QnXG59XG5WdWUudXNlKEV4cGxhYWluU2VhcmNoLCBhbGdvbGlhUGFyYW1zKVxuXG5jaHJvbWUuYnJvd3NlckFjdGlvbi5vbkNsaWNrZWQuYWRkTGlzdGVuZXIoZnVuY3Rpb24odGFiKSB7XG4gIGNocm9tZS50YWJzLnF1ZXJ5KHthY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWV9LCBmdW5jdGlvbih0YWJzKXtcbiAgICBjaHJvbWUudGFicy5zZW5kTWVzc2FnZSh0YWJzWzBdLmlkLCB7YWN0aW9uOiAndG9nZ2xlRHJhd2VyJ30sIGZ1bmN0aW9uKHJlcykge1xuICAgICAgbG9nLmluZm8ocmVzKVxuICAgIH0pXG4gIH0pXG59KTtcblxuY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHJlcXVlc3QsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKChzZW5kZXIudGFiID8gXCJGcm9tIGEgY29udGVudCBzY3JpcHQ6IFwiICsgc2VuZGVyLnRhYi51cmwgOiBcIkZyb20gdGhlIGV4dGVuc2lvblwiKSwgcmVxdWVzdClcblxuICAgIGlmKHJlcXVlc3QuYWN0aW9uID09IFwiZ2V0UGFnZVJlc3VsdHNcIil7XG4gICAgICBnZXRDdXJyZW50UGFnZVJlc3VsdHMocmVxdWVzdC5kYXRhKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhyZXMpXG4gICAgICAgIHNlbmRSZXNwb25zZShyZXMpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LmFjdGlvbiA9PSBcImNoZWNrUGFnZVwiKSB7XG4gICAgICBsb2cudHJhY2UocmVxdWVzdC5kYXRhKTtcbiAgICAgIGNoZWNrUmVmcmVzaCgpXG4gICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEV4cGxhYWluU2VhcmNoLmdldFBhZ2VSZXN1bHRzKFVzZXJJRCwgcmVxdWVzdC5kYXRhLCBVc2VyQ2FyZHMpXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBhZGRUb1BhZ2VSZXN1bHRzKHNlbmRlci50YWIuaWQsIHJlcylcbiAgICAgICAgUGFnZVJlc3VsdHMgPSByZXM7XG4gICAgICAgIHNlbmRSZXNwb25zZShyZXMpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBsb2cuZXJyb3IoZSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYocmVxdWVzdC5hY3Rpb24gPT0gXCJnZXRVc2VyXCIpe1xuICAgICAgc2VuZFJlc3BvbnNlKFVzZXJJRCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYocmVxdWVzdC5hY3Rpb24gPT0gXCJyZWZyZXNoQ2FyZHNcIil7XG4gICAgICBnZXRBbGxVc2VyQ2FyZHMoKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmKHJlcXVlc3QuZXZlbnQgPT0gXCJwb3B1cE9wZW5lZFwiKXtcbiAgICAgIGNocm9tZS50YWJzLnF1ZXJ5KHthY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWV9LCBmdW5jdGlvbih0YWJzKXtcbiAgICAgICAgY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UodGFic1swXS5pZCwge2V2ZW50OiAncG9wdXBPcGVuZWQnfSwgZnVuY3Rpb24ocmVzcG9uc2UpIHt9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICBsb2cuZXJyb3IoZSlcbiAgfVxufSlcblxuY29uc3QgZ2V0Q3VycmVudFBhZ2VSZXN1bHRzID0gZnVuY3Rpb24oZGF0YSkge1xuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIHZhciB0YWJJRDtcbiAgbG9nLmRlYnVnKDEpXG4gIGNoZWNrUmVmcmVzaCgpXG4gIC50aGVuKGdldEN1cnJlbnRUYWIpXG4gIC50aGVuKGZ1bmN0aW9uKHRhYikge1xuICAgIGxvZy5kZWJ1Zyh0YWIuaWQpXG4gICAgdGFiSUQgPSB0YWIuaWRcbiAgICBsb2cuZGVidWcoUGFnZVJlc3VsdHMpXG4gICAgaWYgKFBhZ2VSZXN1bHRzW3RhYklEXSkge1xuICAgICAgZC5yZXNvbHZlKFBhZ2VSZXN1bHRzW3RhYklEXSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFkYXRhKSBkYXRhID0ge3RhYklEOiB0YWJJRH1cbiAgICAgIGxvZy5kZWJ1ZyhkYXRhKVxuICAgICAgZ2V0UGFnZURhdGEoZGF0YSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBsb2cuZGVidWcocmVzKVxuICAgICAgICByZXR1cm4gRXhwbGFhaW5TZWFyY2guZ2V0UGFnZVJlc3VsdHMoVXNlcklELCByZXMsIFVzZXJDYXJkcylcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhyZXMpXG4gICAgICAgIGFkZFRvUGFnZVJlc3VsdHModGFiSUQsIHJlcylcbiAgICAgICAgZC5yZXNvbHZlKHJlcylcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgIH0pXG4gICAgfVxuICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgZC5yZWplY3QoZSlcbiAgfSlcbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBnZXRDdXJyZW50VGFiID0gZnVuY3Rpb24oKSB7XG4gIC8vIE5lZWQgZXJyb3IgY2F0Y2hpbmcgaGVyZVxuICBjb25zdCBkID0gUS5kZWZlcigpXG4gIGNocm9tZS50YWJzLnF1ZXJ5KHthY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWV9LCBmdW5jdGlvbih0YWJzKXtcbiAgICBkLnJlc29sdmUodGFic1swXSlcbiAgfSlcbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBnZXRQYWdlRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBpZiAoZGF0YS5wYWdlRGF0YSkge1xuICAgIGQucmVzb2x2ZShkYXRhLnBhZ2VEYXRhKVxuICB9IGVsc2UgaWYgKGRhdGEudGFiSUQpIHtcbiAgICBzZW5kTWVzc2FnZVRvVGFiKHRhYklELCB7YWN0aW9uOiAnZ2V0UGFnZURhdGEnfSlcbiAgICAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIGQucmVzb2x2ZShyZXMpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBkLnJlamVjdCgpXG4gIH1cbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBzZW5kTWVzc2FnZVRvVGFiID0gZnVuY3Rpb24odGFiSUQsIGRhdGEpIHtcbiAgLy8gTmVlZCBlcnJvciBjYXRjaGluZyBoZXJlXG4gIGNvbnN0IGQgPSBRLmRlZmVyKClcbiAgY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UodGFiSUQsIGRhdGEsIGZ1bmN0aW9uKHJlcykge1xuICAgIGxvZy5kZWJ1ZyhyZXMpXG4gICAgZC5yZXNvbHZlKHJlcylcbiAgfSlcbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBhZGRUb1BhZ2VSZXN1bHRzID0gZnVuY3Rpb24odGFiSUQsIGRhdGEpIHtcbiAgUGFnZVJlc3VsdHNbdGFiSURdID0gZGF0YVxuICBjaHJvbWUudGFicy5xdWVyeSh7YWN0aXZlOiB0cnVlLCBjdXJyZW50V2luZG93OiB0cnVlfSwgZnVuY3Rpb24odGFicyl7XG4gICAgT2JqZWN0LmtleXMoUGFnZVJlc3VsdHMpLmZvckVhY2goZnVuY3Rpb24ocGFnZVRhYklEKSB7XG4gICAgICBpZiAoIHRhYnMuZmlsdGVyKGZ1bmN0aW9uKHRhYikge3JldHVybiB0YWIuaWQgPT0gcGFnZVRhYklEfSkubGVuZ3RoID09IDAgKVxuICAgICAgICBkZWxldGUgUGFnZVJlc3VsdHNbcGFnZVRhYklEXVxuICAgIH0pXG4gICAgbG9nLmRlYnVnKFBhZ2VSZXN1bHRzKVxuICB9KVxufVxuXG5jb25zdCBjaGVja1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGlmIChub3cgLSBMYXN0UmVmcmVzaCA+IDMwMDAwMCkge1xuICAgIGdldEFsbFVzZXJDYXJkcygpXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBkLnJlc29sdmUoKVxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIGxvZy5lcnJvcihlKVxuICAgICAgZC5yZWplY3QoZSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGQucmVzb2x2ZSgpXG4gIH1cbiAgcmV0dXJuIGQucHJvbWlzZVxufVxuXG5jb25zdCBnZXRBbGxVc2VyQ2FyZHMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICBMYXN0UmVmcmVzaCA9IG5ldyBEYXRlKClcbiAgRXhwbGFhaW5TZWFyY2guc2VhcmNoQ2FyZHMoVXNlcklELCAnJywgMTAwMClcbiAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIFVzZXJDYXJkcyA9IHJlc3VsdHM7XG4gICAgbG9nLmRlYnVnKFVzZXJDYXJkcyk7XG4gICAgZC5yZXNvbHZlKClcbiAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgIGxvZy5lcnJvcihlKVxuICAgIGQucmVqZWN0KGUpXG4gIH0pXG4gIHJldHVybiBkLnByb21pc2Vcbn1cbmdldEFsbFVzZXJDYXJkcygpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvc2NyaXB0cy9ldmVudC1wYWdlLmpzIiwiLyohXG4gKiBWdWUuanMgdjIuNC4yXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZml4IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuLmNhbGwodGhpcywgcGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMpIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSBpbmplY3RbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChjb21wLl9fZXNNb2R1bGUgJiYgY29tcC5kZWZhdWx0KSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBrZWVwaW5nIGEgZGV0YWNoZWQgRE9NIHRyZWUgaW4gbWVtb3J5ICgjNTg1MSlcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuc2VycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnM7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uVHlwZSAodm0sIG5hbWUpIHtcbiAgdmFyIG9wdGlvbiA9IHZtLiRvcHRpb25zW25hbWVdO1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0aW9uKSkge1xuICAgIHdhcm4oXG4gICAgICAoXCJjb21wb25lbnQgb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgc2hvdWxkIGJlIGFuIG9iamVjdC5cIiksXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSB8fCBjb25maWcuaXNSZXNlcnZlZEF0dHIoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ2NvbXB1dGVkJyk7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIgfHwgbm9vcCwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnbWV0aG9kcycpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ3dhdGNoJyk7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAga2V5T3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc291cmNlKSB7XG4gICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQob3VycywgZXhpc3RpbmcpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzLCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzLCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgVnVlLnByb3RvdHlwZS5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLWluaXQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKCgodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBjdXJyZW50LCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgaWYgKGNhY2hlZE5vZGUgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuNC4yJztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAobW9kZWxScy5leHApICsgXCIsIFwiICsgKG1vZGVsUnMuaWR4KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoZW5jb2RlZCkgPiAwXG59XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKGxhc3RUYWcsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14sXSopLChbXixdKikoPzosKFteLF0qKSk/XFwpLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9O1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhYXR0cnMubGVuZ3RoO1xuXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMl0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQpIHtcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFszXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW25hbWVdO1xuICAgIC8vICM1MzMwOiB3YXJuIGNsaWNrLnJpZ2h0LCBzaW5jZSByaWdodCBjbGlja3MgZG8gbm90IGFjdHVhbGx5IGZpcmUgY2xpY2sgZXZlbnRzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBuYW1lID09PSAnY2xpY2snICYmXG4gICAgICBoYW5kbGVyICYmIGhhbmRsZXIubW9kaWZpZXJzICYmIGhhbmRsZXIubW9kaWZpZXJzLnJpZ2h0XG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlVzZSBcXFwiY29udGV4dG1lbnVcXFwiIGluc3RlYWQgb2YgXFxcImNsaWNrLnJpZ2h0XFxcIiBzaW5jZSByaWdodCBjbGlja3MgXCIgK1xuICAgICAgICBcImRvIG5vdCBhY3R1YWxseSBmaXJlIFxcXCJjbGlja1xcXCIgZXZlbnRzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcikpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIHJldHVybiBpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgID8gaGFuZGxlci52YWx1ZVxuICAgICAgOiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwiKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIgYWxpYXMgPSBrZXlDb2Rlc1trZXldO1xuICByZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyAoYWxpYXMgPyAnLCcgKyBKU09OLnN0cmluZ2lmeShhbGlhcykgOiAnJykgKyBcIilcIilcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIChrZXkgPyAoXCIsXCIgKyBrZXkpIDogXCJcIikgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSlcbiAgfVxuICByZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn19XCJcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG4gICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxNyBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9ibG9iL3YxL0xJQ0VOU0VcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IFR5bGVyIENsb3NlXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDA5IFR5bGVyIENsb3NlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIFggbGljZW5zZSBmb3VuZFxuICogYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5odG1sXG4gKiBGb3JrZWQgYXQgcmVmX3NlbmQuanMgdmVyc2lvbjogMjAwOS0wNS0xMVxuICpcbiAqIFdpdGggcGFydHMgYnkgTWFyayBNaWxsZXJcbiAqIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFRoaXMgZmlsZSB3aWxsIGZ1bmN0aW9uIHByb3Blcmx5IGFzIGEgPHNjcmlwdD4gdGFnLCBvciBhIG1vZHVsZVxuICAgIC8vIHVzaW5nIENvbW1vbkpTIGFuZCBOb2RlSlMgb3IgUmVxdWlyZUpTIG1vZHVsZSBmb3JtYXRzLiAgSW5cbiAgICAvLyBDb21tb24vTm9kZS9SZXF1aXJlSlMsIHRoZSBtb2R1bGUgZXhwb3J0cyB0aGUgUSBBUEkgYW5kIHdoZW5cbiAgICAvLyBleGVjdXRlZCBhcyBhIHNpbXBsZSA8c2NyaXB0PiwgaXQgY3JlYXRlcyBhIFEgZ2xvYmFsIGluc3RlYWQuXG5cbiAgICAvLyBNb250YWdlIFJlcXVpcmVcbiAgICBpZiAodHlwZW9mIGJvb3RzdHJhcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGJvb3RzdHJhcChcInByb21pc2VcIiwgZGVmaW5pdGlvbik7XG5cbiAgICAvLyBDb21tb25KU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcblxuICAgIC8vIFJlcXVpcmVKU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuXG4gICAgLy8gU0VTIChTZWN1cmUgRWNtYVNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKCFzZXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VzLm1ha2VRID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuXG4gICAgLy8gPHNjcmlwdD5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gUHJlZmVyIHdpbmRvdyBvdmVyIHNlbGYgZm9yIGFkZC1vbiBzY3JpcHRzLiBVc2Ugc2VsZiBmb3JcbiAgICAgICAgLy8gbm9uLXdpbmRvd2VkIGNvbnRleHRzLlxuICAgICAgICB2YXIgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBgd2luZG93YCBvYmplY3QsIHNhdmUgdGhlIHByZXZpb3VzIFEgZ2xvYmFsXG4gICAgICAgIC8vIGFuZCBpbml0aWFsaXplIFEgYXMgYSBnbG9iYWwuXG4gICAgICAgIHZhciBwcmV2aW91c1EgPSBnbG9iYWwuUTtcbiAgICAgICAgZ2xvYmFsLlEgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAgICAgLy8gQWRkIGEgbm9Db25mbGljdCBmdW5jdGlvbiBzbyBRIGNhbiBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgIC8vIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIGdsb2JhbC5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnbG9iYWwuUSA9IHByZXZpb3VzUTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaXBhdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuICAgIC8vIHF1ZXVlIGZvciBsYXRlIHRhc2tzLCB1c2VkIGJ5IHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmdcbiAgICB2YXIgbGF0ZXJRdWV1ZSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgdGFzaywgZG9tYWluO1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pO1xuXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxhdGVyUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXNrID0gbGF0ZXJRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBydW5zIGEgc2luZ2xlIGZ1bmN0aW9uIGluIHRoZSBhc3luYyBxdWV1ZVxuICAgIGZ1bmN0aW9uIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHByb2Nlc3MudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgICAvLyBFbnN1cmUgUSBpcyBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudCwgd2l0aCBhIGBwcm9jZXNzLm5leHRUaWNrYC5cbiAgICAgICAgLy8gVG8gc2VlIHRocm91Z2ggZmFrZSBOb2RlIGVudmlyb25tZW50czpcbiAgICAgICAgLy8gKiBNb2NoYSB0ZXN0IHJ1bm5lciAtIGV4cG9zZXMgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgXG4gICAgICAgIC8vICogQnJvd3NlcmlmeSAtIGV4cG9zZXMgYSBgcHJvY2Vzcy5uZXhUaWNrYCBmdW5jdGlvbiB0aGF0IHVzZXNcbiAgICAgICAgLy8gICBgc2V0VGltZW91dGAuIEluIHRoaXMgY2FzZSBgc2V0SW1tZWRpYXRlYCBpcyBwcmVmZXJyZWQgYmVjYXVzZVxuICAgICAgICAvLyAgICBpdCBpcyBmYXN0ZXIuIEJyb3dzZXJpZnkncyBgcHJvY2Vzcy50b1N0cmluZygpYCB5aWVsZHNcbiAgICAgICAgLy8gICBcIltvYmplY3QgT2JqZWN0XVwiLCB3aGlsZSBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudFxuICAgICAgICAvLyAgIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkcyBcIltvYmplY3QgcHJvY2Vzc11cIi5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBydW5zIGEgdGFzayBhZnRlciBhbGwgb3RoZXIgdGFza3MgaGF2ZSBiZWVuIHJ1blxuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciB1bmhhbmRsZWQgcmVqZWN0aW9uIHRyYWNraW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgYWxsIGB0aGVuYGQgdGFza3MgaGF2ZSBiZWVuIHJ1bi5cbiAgICBuZXh0VGljay5ydW5BZnRlciA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGxhdGVyUXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5leHRUaWNrO1xufSkoKTtcblxuLy8gQXR0ZW1wdCB0byBtYWtlIGdlbmVyaWNzIHNhZmUgaW4gdGhlIGZhY2Ugb2YgZG93bnN0cmVhbVxuLy8gbW9kaWZpY2F0aW9ucy5cbi8vIFRoZXJlIGlzIG5vIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIG5lY2Vzc2FyeS5cbi8vIElmIHlvdSBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLCB0aGVzZSBwcmltb3JkaWFscyBuZWVkIHRvIGJlXG4vLyBkZWVwbHkgZnJvemVuIGFueXdheSwgYW5kIGlmIHlvdSBkb27igJl0IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsXG4vLyB0aGlzIGlzIGp1c3QgcGxhaW4gcGFyYW5vaWQuXG4vLyBIb3dldmVyLCB0aGlzICoqbWlnaHQqKiBoYXZlIHRoZSBuaWNlIHNpZGUtZWZmZWN0IG9mIHJlZHVjaW5nIHRoZSBzaXplIG9mXG4vLyB0aGUgbWluaWZpZWQgY29kZSBieSByZWR1Y2luZyB4LmNhbGwoKSB0byBtZXJlbHkgeCgpXG4vLyBTZWUgTWFyayBNaWxsZXLigJlzIGV4cGxhbmF0aW9uIG9mIHdoYXQgdGhpcyBkb2VzLlxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9Y29udmVudGlvbnM6c2FmZV9tZXRhX3Byb2dyYW1taW5nXG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLy8gVGhpcyBpcyBlcXVpdmFsZW50LCBidXQgc2xvd2VyOlxuLy8gdW5jdXJyeVRoaXMgPSBGdW5jdGlvbl9iaW5kLmJpbmQoRnVuY3Rpb25fYmluZC5jYWxsKTtcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VuY3Vycnl0aGlzXG5cbnZhciBhcnJheV9zbGljZSA9IHVuY3VycnlUaGlzKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbnZhciBhcnJheV9yZWR1Y2UgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzaXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBjb25jZXJuaW5nIHRoZSBpbml0aWFsIHZhbHVlLCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYXJyYXksIGFjY291bnRpbmdcbiAgICAgICAgICAgIC8vIGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCBpcyBpcyBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzID0gdGhpc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdWNlXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGFycmF5IGlzIHNwYXJzZVxuICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBiYXNpcyA9IGNhbGxiYWNrKGJhc2lzLCB0aGlzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNpcztcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfaW5kZXhPZiA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBub3QgYSB2ZXJ5IGdvb2Qgc2hpbSwgYnV0IGdvb2QgZW5vdWdoIGZvciBvdXIgb25lIHVzZSBvZiBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfbWFwID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbGxlY3QgPSBbXTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHNlbGYsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc3AsIHZhbHVlLCBpbmRleCwgc2VsZikpO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICByZXR1cm4gY29sbGVjdDtcbiAgICB9XG4pO1xuXG52YXIgb2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgIGZ1bmN0aW9uIFR5cGUoKSB7IH1cbiAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IFR5cGUoKTtcbn07XG5cbnZhciBvYmplY3RfZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgIG9ialtwcm9wXSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBvYmplY3RfaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxudmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0X2hhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgb2JqZWN0X3RvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBPYmplY3QodmFsdWUpO1xufVxuXG4vLyBnZW5lcmF0b3IgcmVsYXRlZCBzaGltc1xuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuZnVuY3Rpb24gaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICAgIG9iamVjdF90b1N0cmluZyhleGNlcHRpb24pID09PSBcIltvYmplY3QgU3RvcEl0ZXJhdGlvbl1cIiB8fFxuICAgICAgICBleGNlcHRpb24gaW5zdGFuY2VvZiBRUmV0dXJuVmFsdWVcbiAgICApO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaGVscGVyIGFuZCBRLnJldHVybiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpblxuLy8gU3BpZGVyTW9ua2V5LlxudmFyIFFSZXR1cm5WYWx1ZTtcbmlmICh0eXBlb2YgUmV0dXJuVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBSZXR1cm5WYWx1ZTtcbn0gZWxzZSB7XG4gICAgUVJldHVyblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xufVxuXG4vLyBsb25nIHN0YWNrIHRyYWNlc1xuXG52YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCI7XG5cbmZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFFcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBwcm9taXNlYC4gU2VlICM1Ny5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIHByb21pc2Uuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjayAmJiAoIWVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fIHx8IGVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fID4gcC5zdGFja0NvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0X2RlZmluZVByb3BlcnR5KGVycm9yLCBcIl9fbWluaW11bVN0YWNrQ291bnRlcl9fXCIsIHt2YWx1ZTogcC5zdGFja0NvdW50ZXIsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgICAgICBvYmplY3RfZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwic3RhY2tcIiwge3ZhbHVlOiBzdGFjaywgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGNvdW50ZXIgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHN0b3BwaW5nIHBvaW50IGZvciBidWlsZGluZ1xuICogbG9uZyBzdGFjayB0cmFjZXMuIEluIG1ha2VTdGFja1RyYWNlTG9uZyB3ZSB3YWxrIGJhY2t3YXJkcyB0aHJvdWdoXG4gKiB0aGUgbGlua2VkIGxpc3Qgb2YgcHJvbWlzZXMsIG9ubHkgc3RhY2tzIHdoaWNoIHdlcmUgY3JlYXRlZCBiZWZvcmVcbiAqIHRoZSByZWplY3Rpb24gYXJlIGNvbmNhdGVuYXRlZC5cbiAqL1xudmFyIGxvbmdTdGFja0NvdW50ZXIgPSAxO1xuXG4vLyBlbmFibGUgbG9uZyBzdGFja3MgaWYgUV9ERUJVRyBpcyBzZXRcbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LlFfREVCVUcpIHtcbiAgICBRLmxvbmdTdGFja1N1cHBvcnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSBvYmplY3QuXG4gKlxuICogYHJlc29sdmVgIGlzIGEgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggYSBtb3JlIHJlc29sdmVkIHZhbHVlIGZvciB0aGVcbiAqIHByb21pc2UuIFRvIGZ1bGZpbGwgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhbnkgdmFsdWUgdGhhdCBpc1xuICogbm90IGEgdGhlbmFibGUuIFRvIHJlamVjdCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGEgcmVqZWN0ZWRcbiAqIHRoZW5hYmxlLCBvciBpbnZva2UgYHJlamVjdGAgd2l0aCB0aGUgcmVhc29uIGRpcmVjdGx5LiBUbyByZXNvbHZlIHRoZVxuICogcHJvbWlzZSB0byBhbm90aGVyIHRoZW5hYmxlLCB0aHVzIHB1dHRpbmcgaXQgaW4gdGhlIHNhbWUgc3RhdGUsIGludm9rZVxuICogYHJlc29sdmVgIHdpdGggdGhhdCBvdGhlciB0aGVuYWJsZS5cbiAqL1xuUS5kZWZlciA9IGRlZmVyO1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgLy8gaWYgXCJtZXNzYWdlc1wiIGlzIGFuIFwiQXJyYXlcIiwgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvbWlzZSBoYXMgbm90IHlldFxuICAgIC8vIGJlZW4gcmVzb2x2ZWQuICBJZiBpdCBpcyBcInVuZGVmaW5lZFwiLCBpdCBoYXMgYmVlbiByZXNvbHZlZC4gIEVhY2hcbiAgICAvLyBlbGVtZW50IG9mIHRoZSBtZXNzYWdlcyBhcnJheSBpcyBpdHNlbGYgYW4gYXJyYXkgb2YgY29tcGxldGUgYXJndW1lbnRzIHRvXG4gICAgLy8gZm9yd2FyZCB0byB0aGUgcmVzb2x2ZWQgcHJvbWlzZS4gIFdlIGNvZXJjZSB0aGUgcmVzb2x1dGlvbiB2YWx1ZSB0byBhXG4gICAgLy8gcHJvbWlzZSB1c2luZyB0aGUgYHJlc29sdmVgIGZ1bmN0aW9uIGJlY2F1c2UgaXQgaGFuZGxlcyBib3RoIGZ1bGx5XG4gICAgLy8gbm9uLXRoZW5hYmxlIHZhbHVlcyBhbmQgb3RoZXIgdGhlbmFibGVzIGdyYWNlZnVsbHkuXG4gICAgdmFyIG1lc3NhZ2VzID0gW10sIHByb2dyZXNzTGlzdGVuZXJzID0gW10sIHJlc29sdmVkUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9IG9iamVjdF9jcmVhdGUoZGVmZXIucHJvdG90eXBlKTtcbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIG9wZXJhbmRzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBcIndoZW5cIiAmJiBvcGVyYW5kc1sxXSkgeyAvLyBwcm9ncmVzcyBvcGVyYW5kXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KHJlc29sdmVkUHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZFxuICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhcmVyVmFsdWUgPSBuZWFyZXIocmVzb2x2ZWRQcm9taXNlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShuZWFyZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5lYXJlclZhbHVlOyAvLyBzaG9ydGVuIGNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlclZhbHVlO1xuICAgIH07XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJwZW5kaW5nXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlLmluc3BlY3QoKTtcbiAgICB9O1xuXG4gICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBkb24ndCB0cnkgdG8gdXNlIGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAgb3IgdHJhbnNmZXIgdGhlXG4gICAgICAgICAgICAvLyBhY2Nlc3NvciBhcm91bmQ7IHRoYXQgY2F1c2VzIG1lbW9yeSBsZWFrcyBhcyBwZXIgR0gtMTExLiBKdXN0XG4gICAgICAgICAgICAvLyByZWlmeSB0aGUgc3RhY2sgdHJhY2UgYXMgYSBzdHJpbmcgQVNBUC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lOyBpdCdzIGFsd2F5cyBqdXN0XG4gICAgICAgICAgICAvLyBcIltvYmplY3QgUHJvbWlzZV1cXG5cIiwgYXMgcGVyIHRoZSBgdG9TdHJpbmdgLlxuICAgICAgICAgICAgcHJvbWlzZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZihcIlxcblwiKSArIDEpO1xuICAgICAgICAgICAgcHJvbWlzZS5zdGFja0NvdW50ZXIgPSBsb25nU3RhY2tDb3VudGVyKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcblxuICAgICAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICAgICAgLy8gT25seSBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBuZXcgcHJvbWlzZSBpZiBsb25nIHN0YWNrc1xuICAgICAgICAgICAgLy8gYXJlIGVuYWJsZWQgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZVxuICAgICAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG4gKiBwcm9taXNlLlxuICogQHJldHVybnMgYSBub2RlYmFja1xuICovXG5kZWZlci5wcm90b3R5cGUubWFrZU5vZGVSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZShhcnJheV9zbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVzb2x2ZXIge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub3RoaW5nIGFuZCBhY2NlcHRzXG4gKiB0aGUgcmVzb2x2ZSwgcmVqZWN0LCBhbmQgbm90aWZ5IGZ1bmN0aW9ucyBmb3IgYSBkZWZlcnJlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IG1heSBiZSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiByZXNvbHZlIGFuZCByZWplY3RcbiAqIGZ1bmN0aW9ucywgb3IgcmVqZWN0ZWQgYnkgYSB0aHJvd24gZXhjZXB0aW9uIGluIHJlc29sdmVyXG4gKi9cblEuUHJvbWlzZSA9IHByb21pc2U7IC8vIEVTNlxuUS5wcm9taXNlID0gcHJvbWlzZTtcbmZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbnByb21pc2UucmFjZSA9IHJhY2U7IC8vIEVTNlxucHJvbWlzZS5hbGwgPSBhbGw7IC8vIEVTNlxucHJvbWlzZS5yZWplY3QgPSByZWplY3Q7IC8vIEVTNlxucHJvbWlzZS5yZXNvbHZlID0gUTsgLy8gRVM2XG5cbi8vIFhYWCBleHBlcmltZW50YWwuICBUaGlzIG1ldGhvZCBpcyBhIHdheSB0byBkZW5vdGUgdGhhdCBhIGxvY2FsIHZhbHVlIGlzXG4vLyBzZXJpYWxpemFibGUgYW5kIHNob3VsZCBiZSBpbW1lZGlhdGVseSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIHVwb24gcmVxdWVzdCxcbi8vIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZS5cblEucGFzc0J5Q29weSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHR3byBwcm9taXNlcyBldmVudHVhbGx5IGZ1bGZpbGwgdG8gdGhlIHNhbWUgdmFsdWUsIHByb21pc2VzIHRoYXQgdmFsdWUsXG4gKiBidXQgb3RoZXJ3aXNlIHJlamVjdHMuXG4gKiBAcGFyYW0geCB7QW55Kn1cbiAqIEBwYXJhbSB5IHtBbnkqfVxuICogQHJldHVybnMge0FueSp9IGEgcHJvbWlzZSBmb3IgeCBhbmQgeSBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYnV0IGEgcmVqZWN0aW9uXG4gKiBvdGhlcndpc2UuXG4gKlxuICovXG5RLmpvaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBRKHgpLmpvaW4oeSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICByZXR1cm4gUShbdGhpcywgdGhhdF0pLnNwcmVhZChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIHNldHRsZWQuXG4gKiBAcGFyYW0gYW5zd2VycyB7QXJyYXlbQW55Kl19IHByb21pc2VzIHRvIHJhY2VcbiAqIEByZXR1cm5zIHtBbnkqfSB0aGUgZmlyc3QgcHJvbWlzZSB0byBiZSBzZXR0bGVkXG4gKi9cblEucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGFuc3dlclBzKSB7XG4gICAgcmV0dXJuIHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24gKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcnJheV9pbmRleE9mKHVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuaGFuZGxlZFJlamVjdGlvblwiLCByZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXRSZXBvcnQgPSBhcnJheV9pbmRleE9mKHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0UmVwb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJyZWplY3Rpb25IYW5kbGVkXCIsIHVuaGFuZGxlZFJlYXNvbnNbYXRdLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdFJlcG9ydCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoYXQsIDEpO1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnNwbGljZShhdCwgMSk7XG4gICAgfVxufVxuXG5RLnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucyA9IHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucztcblxuUS5nZXRVbmhhbmRsZWRSZWFzb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIHRoYXQgY29uc3VtZXJzIGNhbid0IGludGVyZmVyZSB3aXRoIG91ciBpbnRlcm5hbCBzdGF0ZS5cbiAgICByZXR1cm4gdW5oYW5kbGVkUmVhc29ucy5zbGljZSgpO1xufTtcblxuUS5zdG9wVW5oYW5kbGVkUmVqZWN0aW9uVHJhY2tpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gZmFsc2U7XG59O1xuXG5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcblxuLy8vLyBFTkQgVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWplY3RlZCBwcm9taXNlLlxuICogQHBhcmFtIHJlYXNvbiB2YWx1ZSBkZXNjcmliaW5nIHRoZSBmYWlsdXJlXG4gKi9cblEucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciByZWplY3Rpb24gPSBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoZSBlcnJvciBoYXMgYmVlbiBoYW5kbGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1bnRyYWNrUmVqZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQocmVhc29uKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGUgcmVhc29uIGhhcyBub3QgYmVlbiBoYW5kbGVkLlxuICAgIHRyYWNrUmVqZWN0aW9uKHJlamVjdGlvbiwgcmVhc29uKTtcblxuICAgIHJldHVybiByZWplY3Rpb247XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZ1bGZpbGxlZCBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2VcbiAqL1xuUS5mdWxmaWxsID0gZnVsZmlsbDtcbmZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0XCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwic2V0XCI6IGZ1bmN0aW9uIChuYW1lLCByaHMpIHtcbiAgICAgICAgICAgIHZhbHVlW25hbWVdID0gcmhzO1xuICAgICAgICB9LFxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInBvc3RcIjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgTWlsbGVyIHByb3Bvc2VzIHRoYXQgcG9zdCB3aXRoIG5vIG5hbWUgc2hvdWxkIGFwcGx5IGFcbiAgICAgICAgICAgIC8vIHByb21pc2VkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwgfHwgbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYXBwbHlcIjogZnVuY3Rpb24gKHRoaXNwLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpc3AsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBcImtleXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF9rZXlzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZW5hYmxlcyB0byBRIHByb21pc2VzLlxuICogQHBhcmFtIHByb21pc2UgdGhlbmFibGUgcHJvbWlzZVxuICogQHJldHVybnMgYSBRIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gY29lcmNlKHByb21pc2UpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEFubm90YXRlcyBhbiBvYmplY3Qgc3VjaCB0aGF0IGl0IHdpbGwgbmV2ZXIgYmVcbiAqIHRyYW5zZmVycmVkIGF3YXkgZnJvbSB0aGlzIHByb2Nlc3Mgb3ZlciBhbnkgcHJvbWlzZVxuICogY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgcHJvbWlzZSBhIHdyYXBwaW5nIG9mIHRoYXQgb2JqZWN0IHRoYXRcbiAqIGFkZGl0aW9uYWxseSByZXNwb25kcyB0byB0aGUgXCJpc0RlZlwiIG1lc3NhZ2VcbiAqIHdpdGhvdXQgYSByZWplY3Rpb24uXG4gKi9cblEubWFzdGVyID0gbWFzdGVyO1xuZnVuY3Rpb24gbWFzdGVyKG9iamVjdCkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJpc0RlZlwiOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKG9wLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBRKG9iamVjdCkuaW5zcGVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFNwcmVhZHMgdGhlIHZhbHVlcyBvZiBhIHByb21pc2VkIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZVxuICogZnVsZmlsbG1lbnQgY2FsbGJhY2suXG4gKiBAcGFyYW0gZnVsZmlsbGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdmFyaWFkaWMgYXJndW1lbnRzIGZyb20gdGhlXG4gKiBwcm9taXNlZCBhcnJheVxuICogQHBhcmFtIHJlamVjdGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgcHJvbWlzZVxuICogaXMgcmVqZWN0ZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb3IgdGhyb3duIGV4Y2VwdGlvbiBvZlxuICogZWl0aGVyIGNhbGxiYWNrLlxuICovXG5RLnNwcmVhZCA9IHNwcmVhZDtcbmZ1bmN0aW9uIHNwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRoZSBhc3luYyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciBmb3IgZ2VuZXJhdG9yIGZ1bmN0aW9ucywgdHVybmluZ1xuICogdGhlbSBpbnRvIGFzeW5jaHJvbm91cyBnZW5lcmF0b3JzLiAgQWx0aG91Z2ggZ2VuZXJhdG9ycyBhcmUgb25seSBwYXJ0XG4gKiBvZiB0aGUgbmV3ZXN0IEVDTUFTY3JpcHQgNiBkcmFmdHMsIHRoaXMgY29kZSBkb2VzIG5vdCBjYXVzZSBzeW50YXhcbiAqIGVycm9ycyBpbiBvbGRlciBlbmdpbmVzLiAgVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrIGFuZCB3aWxsXG4gKiBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiAtLWhhcm1vbnktZ2VuZXJhdG9ycyBydW50aW1lIGZsYWcgZW5hYmxlZC4gIFNwaWRlck1vbmtleSBoYXMgaGFkIHRoZW1cbiAqIGZvciBsb25nZXIsIGJ1dCB1bmRlciBhbiBvbGRlciBQeXRob24taW5zcGlyZWQgZm9ybS4gIFRoaXMgZnVuY3Rpb25cbiAqIHdvcmtzIG9uIGJvdGgga2luZHMgb2YgZ2VuZXJhdG9ycy5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IGFzeW5jO1xuZnVuY3Rpb24gYXN5bmMobWFrZUdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAvLyBVbnRpbCBWOCAzLjE5IC8gQ2hyb21pdW0gMjkgaXMgcmVsZWFzZWQsIFNwaWRlck1vbmtleSBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gZW5naW5lIHRoYXQgaGFzIGEgZGVwbG95ZWQgYmFzZSBvZiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIFNNJ3MgZ2VuZXJhdG9ycyB1c2UgdGhlIFB5dGhvbi1pbnNwaXJlZCBzZW1hbnRpY3Mgb2ZcbiAgICAgICAgICAgIC8vIG91dGRhdGVkIEVTNiBkcmFmdHMuICBXZSB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgRVM2LCBidXQgd2UnZCBhbHNvXG4gICAgICAgICAgICAvLyBsaWtlIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGdlbmVyYXRvcnMgaW4gZGVwbG95ZWQgYnJvd3NlcnMsIHNvXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIHN1cHBvcnQgUHl0aG9uLXN0eWxlIGdlbmVyYXRvcnMuICBBdCBzb21lIHBvaW50IHdlIGNhbiByZW1vdmVcbiAgICAgICAgICAgIC8vIHRoaXMgYmxvY2suXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3RvcEl0ZXJhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIEVTNiBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBRKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LnZhbHVlLCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTcGlkZXJNb25rZXkgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBjYXNlIHdoZW4gU00gZG9lcyBFUzYgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShleGNlcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBtYWtlR2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJuZXh0XCIpO1xuICAgICAgICB2YXIgZXJyYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJ0aHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc3Bhd24gZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBhc3luYyB0aGF0IGltbWVkaWF0ZWx5XG4gKiBjYWxscyB0aGUgZ2VuZXJhdG9yIGFuZCBhbHNvIGVuZHMgdGhlIHByb21pc2UgY2hhaW4sIHNvIHRoYXQgYW55XG4gKiB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW5zdGVhZCBvZiBmb3J3YXJkZWQgdG8gdGhlIGVycm9yXG4gKiBoYW5kbGVyLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0J3MgZXh0cmVtZWx5IGNvbW1vbiB0byBydW5cbiAqIGdlbmVyYXRvcnMgYXQgdGhlIHRvcC1sZXZlbCB0byB3b3JrIHdpdGggbGlicmFyaWVzLlxuICovXG5RLnNwYXduID0gc3Bhd247XG5mdW5jdGlvbiBzcGF3bihtYWtlR2VuZXJhdG9yKSB7XG4gICAgUS5kb25lKFEuYXN5bmMobWFrZUdlbmVyYXRvcikoKSk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbnRlcmZhY2Ugb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuLyoqXG4gKiBUaHJvd3MgYSBSZXR1cm5WYWx1ZSBleGNlcHRpb24gdG8gc3RvcCBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGEgc3RvcC1nYXAgbWVhc3VyZSB0byBzdXBwb3J0IGdlbmVyYXRvciByZXR1cm5cbiAqIHZhbHVlcyBpbiBvbGRlciBGaXJlZm94L1NwaWRlck1vbmtleS4gIEluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBFUzZcbiAqIGdlbmVyYXRvcnMgbGlrZSBDaHJvbWl1bSAyOSwganVzdCB1c2UgXCJyZXR1cm5cIiBpbiB5b3VyIGdlbmVyYXRvclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGUgc3Vycm91bmRpbmcgZ2VuZXJhdG9yXG4gKiBAdGhyb3dzIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzYgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24qICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgcmV0dXJuIGZvbyArIGJhcjtcbiAqIH0pXG4gKiAvLyBPbGRlciBTcGlkZXJNb25rZXkgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24gKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICBRLnJldHVybihmb28gKyBiYXIpO1xuICogfSlcbiAqL1xuUVtcInJldHVyblwiXSA9IF9yZXR1cm47XG5mdW5jdGlvbiBfcmV0dXJuKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFFSZXR1cm5WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIHByb21pc2VkIGZ1bmN0aW9uIGRlY29yYXRvciBlbnN1cmVzIHRoYXQgYW55IHByb21pc2UgYXJndW1lbnRzXG4gKiBhcmUgc2V0dGxlZCBhbmQgcGFzc2VkIGFzIHZhbHVlcyAoYHRoaXNgIGlzIGFsc28gc2V0dGxlZCBhbmQgcGFzc2VkXG4gKiBhcyBhIHZhbHVlKS4gIEl0IHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gaXNcbiAqIGFsd2F5cyBhIHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBRLnByb21pc2VkKGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgICAgcmV0dXJuIGEgKyBiO1xuICogfSk7XG4gKiBhZGQoUShhKSwgUShCKSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGRlY29yYXRlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQuXG4gKi9cblEucHJvbWlzZWQgPSBwcm9taXNlZDtcbmZ1bmN0aW9uIHByb21pc2VkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNwcmVhZChbdGhpcywgYWxsKGFyZ3VtZW50cyldLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHNlbmRzIGEgbWVzc2FnZSB0byBhIHZhbHVlIGluIGEgZnV0dXJlIHR1cm5cbiAqIEBwYXJhbSBvYmplY3QqIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBvcCB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBvcGVyYXRpb24sIGUuZy4sIFwid2hlblwiLFxuICogQHBhcmFtIGFyZ3MgZnVydGhlciBhcmd1bWVudHMgdG8gYmUgZm9yd2FyZGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHJlc3VsdCB7UHJvbWlzZX0gYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAqL1xuUS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuZnVuY3Rpb24gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2gob3AsIGFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChkZWZlcnJlZC5yZXNvbHZlLCBvcCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZ2V0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICovXG5RLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIG9iamVjdCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSAgICAgbmV3IHZhbHVlIG9mIHByb3BlcnR5XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZGVsZXRlXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5kZWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIHZhbHVlICAgICBhIHZhbHVlIHRvIHBvc3QsIHR5cGljYWxseSBhbiBhcnJheSBvZlxuICogICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uIGFyZ3VtZW50cyBmb3IgcHJvbWlzZXMgdGhhdFxuICogICAgICAgICAgICAgICAgICBhcmUgdWx0aW1hdGVseSBiYWNrZWQgd2l0aCBgcmVzb2x2ZWAgdmFsdWVzLFxuICogICAgICAgICAgICAgICAgICBhcyBvcHBvc2VkIHRvIHRob3NlIGJhY2tlZCB3aXRoIFVSTHNcbiAqICAgICAgICAgICAgICAgICAgd2hlcmVpbiB0aGUgcG9zdGVkIHZhbHVlIGNhbiBiZSBhbnlcbiAqICAgICAgICAgICAgICAgICAgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cbi8vIGJvdW5kIGxvY2FsbHkgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IG90aGVyIG1ldGhvZHNcblEubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgaW52b2NhdGlvbiBhcmd1bWVudHNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5Qcm9taXNlLnByb3RvdHlwZS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIGFyZ3MgICAgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYXBwbHkgPSBmdW5jdGlvbiAob2JqZWN0LCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUVtcInRyeVwiXSA9XG5RLmZjYWxsID0gZnVuY3Rpb24gKG9iamVjdCAvKiAuLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cyldKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uLCB0cmFuc2Zvcm1pbmcgcmV0dXJuIHZhbHVlcyBpbnRvIGEgZnVsZmlsbGVkXG4gKiBwcm9taXNlIGFuZCB0aHJvd24gZXJyb3JzIGludG8gYSByZWplY3RlZCBvbmUuXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZiaW5kID0gZnVuY3Rpb24gKG9iamVjdCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gUShvYmplY3QpO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblByb21pc2UucHJvdG90eXBlLmZiaW5kID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgbmFtZXMgb2YgdGhlIG93bmVkIHByb3BlcnRpZXMgb2YgYSBwcm9taXNlZFxuICogb2JqZWN0IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUga2V5cyBvZiB0aGUgZXZlbnR1YWxseSBzZXR0bGVkIG9iamVjdFxuICovXG5RLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkuICBJZiBhbnkgb2ZcbiAqIHRoZSBwcm9taXNlcyBnZXRzIHJlamVjdGVkLCB0aGUgd2hvbGUgYXJyYXkgaXMgcmVqZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqL1xuLy8gQnkgTWFyayBNaWxsZXJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmNvbmN1cnJlbmN5JnJldj0xMzA4Nzc2NTIxI2FsbGZ1bGZpbGxlZFxuUS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb21pc2UsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNQcm9taXNlKHByb21pc2UpICYmXG4gICAgICAgICAgICAgICAgKHNuYXBzaG90ID0gcHJvbWlzZS5pbnNwZWN0KCkpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSBzbmFwc2hvdC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytwZW5kaW5nQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hlbihcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHsgaW5kZXg6IGluZGV4LCB2YWx1ZTogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2Ugb2YgYW4gYXJyYXkuIFByaW9yIHJlamVjdGVkIHByb21pc2VzIGFyZVxuICogaWdub3JlZC4gIFJlamVjdHMgb25seSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIG9yIHByb21pc2VzIGZvciB2YWx1ZXNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2UsXG4gKiBvciBhIHJlamVjdGVkIHByb21pc2UgaWYgYWxsIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqL1xuUS5hbnkgPSBhbnk7XG5cbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFEucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZlcnJlZCA9IFEuZGVmZXIoKTtcbiAgICB2YXIgcGVuZGluZ0NvdW50ID0gMDtcbiAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VzW2luZGV4XTtcblxuICAgICAgICBwZW5kaW5nQ291bnQrKztcblxuICAgICAgICB3aGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcbiAgICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZWplY3RlZChlcnIpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gKFwiUSBjYW4ndCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgZnJvbSBhbnkgcHJvbWlzZSwgYWxsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwcm9taXNlcyB3ZXJlIHJlamVjdGVkLiBMYXN0IGVycm9yIG1lc3NhZ2U6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9ncmVzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB1bmRlZmluZWQpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrLmFwcGx5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCBhcHBseSBmaW5hbGx5IGNhbGxiYWNrXCIpO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgYXQgdGhlIGVuZCBvZiBhIGNoYWluIG9mIHByb21pc2VzXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cblEuZG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kb25lKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBmb3J3YXJkIHRvIGEgZnV0dXJlIHR1cm4gc28gdGhhdCBgYHdoZW5gYFxuICAgICAgICAvLyBkb2VzIG5vdCBjYXRjaCBpdCBhbmQgdHVybiBpdCBpbnRvIGEgcmVqZWN0aW9uLlxuICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge0FueSp9IGN1c3RvbSBlcnJvciBtZXNzYWdlIG9yIEVycm9yIG9iamVjdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIChvYmplY3QsIG1zLCBlcnJvcikge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgZXJyb3IpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgZXJyb3IpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlcnJvciB8fCBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yIHx8IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgbXMgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSwgbXMpO1xuXG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGdpdmVuIHZhbHVlIChvciBwcm9taXNlZCB2YWx1ZSksIHNvbWVcbiAqIG1pbGxpc2Vjb25kcyBhZnRlciBpdCByZXNvbHZlZC4gUGFzc2VzIHJlamVjdGlvbnMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgYWZ0ZXIgbWlsbGlzZWNvbmRzXG4gKiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlLlxuICogSWYgdGhlIGdpdmVuIHByb21pc2UgcmVqZWN0cywgdGhhdCBpcyBwYXNzZWQgaW1tZWRpYXRlbHkuXG4gKi9cblEuZGVsYXkgPSBmdW5jdGlvbiAob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBhcyBhbiBhcnJheSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqICAgICAgUS5uZmFwcGx5KEZTLnJlYWRGaWxlLCBbX19maWxlbmFtZV0pXG4gKiAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiAgICAgIH0pXG4gKlxuICovXG5RLm5mYXBwbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGluZGl2aWR1YWxseSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZjYWxsKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKVxuICogLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqIH0pXG4gKlxuICovXG5RLm5mY2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBOb2RlSlMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZiaW5kKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKShcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5uZmJpbmQgPVxuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRIGNhbid0IHdyYXAgYW4gdW5kZWZpbmVkIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBRKGNhbGxiYWNrKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLmRlbm9kZWlmeS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuUS5uYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3AgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5iaW5kID0gZnVuY3Rpb24gKC8qdGhpc3AsIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEubmJpbmQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjayB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5ucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5wb3N0KG5hbWUsIGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5ucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyB8fCBbXSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrLCBmb3J3YXJkaW5nIHRoZSBnaXZlbiB2YXJpYWRpYyBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZFxuICogY2FsbGJhY2sgYXJndW1lbnQuXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0gLi4uYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2sgd2lsbFxuICogYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5RLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblEubmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUHJvbWlzZS5wcm90b3R5cGUubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUHJvbWlzZS5wcm90b3R5cGUubmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIElmIGEgZnVuY3Rpb24gd291bGQgbGlrZSB0byBzdXBwb3J0IGJvdGggTm9kZSBjb250aW51YXRpb24tcGFzc2luZy1zdHlsZSBhbmRcbiAqIHByb21pc2UtcmV0dXJuaW5nLXN0eWxlLCBpdCBjYW4gZW5kIGl0cyBpbnRlcm5hbCBwcm9taXNlIGNoYWluIHdpdGhcbiAqIGBub2RlaWZ5KG5vZGViYWNrKWAsIGZvcndhcmRpbmcgdGhlIG9wdGlvbmFsIG5vZGViYWNrIGFyZ3VtZW50LiAgSWYgdGhlIHVzZXJcbiAqIGVsZWN0cyB0byB1c2UgYSBub2RlYmFjaywgdGhlIHJlc3VsdCB3aWxsIGJlIHNlbnQgdGhlcmUuICBJZiB0aGV5IGRvIG5vdFxuICogcGFzcyBhIG5vZGViYWNrLCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IHByb21pc2UuXG4gKiBAcGFyYW0gb2JqZWN0IGEgcmVzdWx0IChvciBhIHByb21pc2UgZm9yIGEgcmVzdWx0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbm9kZWJhY2sgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyBlaXRoZXIgdGhlIHByb21pc2Ugb3Igbm90aGluZ1xuICovXG5RLm5vZGVpZnkgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShvYmplY3QsIG5vZGViYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ub2RlaWZ5KG5vZGViYWNrKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaykge1xuICAgIGlmIChub2RlYmFjaykge1xuICAgICAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuUS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUS5ub0NvbmZsaWN0IG9ubHkgd29ya3Mgd2hlbiBRIGlzIHVzZWQgYXMgYSBnbG9iYWxcIik7XG59O1xuXG4vLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxudmFyIHFFbmRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcblxucmV0dXJuIFE7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9xL3EuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IFEgZnJvbSAncSc7XG5pbXBvcnQgQWxnb2xpYSBmcm9tICdhbGdvbGlhc2VhcmNoJztcblxubG9nLnNldExldmVsKCdkZWJ1ZycpXG5cbmNvbnN0IGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuY29uc3QgU2VhcmNoID0ge1xuICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgIGxvZy50cmFjZShvcHRpb25zKTtcbiAgICBjb25zdCBBbGdvbGlhQ2xpZW50ID0gQWxnb2xpYShvcHRpb25zLmFwcElELCBvcHRpb25zLmFwaUtleSwge1xuICAgICAgcHJvdG9jb2w6ICdodHRwczonXG4gICAgfSlcbiAgICBjb25zdCBBbGdvbGlhSW5kZXggPSBBbGdvbGlhQ2xpZW50LmluaXRJbmRleChvcHRpb25zLmluZGV4KTtcblxuICAgIGNvbnN0IGFkdmFuY2VkU2VhcmNoID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBBbGdvbGlhSW5kZXguY2xlYXJDYWNoZSgpXG4gICAgICBBbGdvbGlhSW5kZXguc2VhcmNoKHBhcmFtcywgZnVuY3Rpb24oZSwgY29udGVudCkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGxvZy50cmFjZShlKTtcbiAgICAgICAgICBkLnJlamVjdChlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoTGlzdEl0ZW1DYXJkcyhjb250ZW50LmhpdHMpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkLnJlc29sdmUoY29udGVudC5oaXRzKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IHNlYXJjaENhcmRzID0gZnVuY3Rpb24odXNlcklELCBzZWFyY2hUZXh0LCBoaXRzUGVyUGFnZSkge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBxdWVyeTogc2VhcmNoVGV4dCxcbiAgICAgICAgZmlsdGVyczogdXNlcklELmxlbmd0aCA/ICd1c2VySUQ6ICcgKyB1c2VySUQgOiAnJyxcbiAgICAgICAgaGl0c1BlclBhZ2U6IGhpdHNQZXJQYWdlIHx8IG51bGxcbiAgICAgIH07XG4gICAgICBsb2cudHJhY2UocGFyYW1zKTtcbiAgICAgIGFkdmFuY2VkU2VhcmNoKHBhcmFtcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGhpdHMpIHtcbiAgICAgICAgbG9nLnRyYWNlKGhpdHMpO1xuICAgICAgICBkLnJlc29sdmUoaGl0cylcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSk7XG4gICAgICB9KVxuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGZldGNoTGlzdEl0ZW1DYXJkcyA9IGZ1bmN0aW9uKGNhcmRzKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAgICAgY2FyZHMuZm9yRWFjaChmdW5jdGlvbihjYXJkKSB7XG4gICAgICAgIGNhcmQubGlzdENhcmRzID0ge31cbiAgICAgICAgaWYgKGNhcmQubGlzdEl0ZW1zKSB7XG4gICAgICAgICAgY2FyZC5saXN0SXRlbXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBRLmRlZmVyKClcbiAgICAgICAgICAgIGdldENhcmQoa2V5KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgICBjYXJkLmxpc3RDYXJkc1trZXldID0gY29udGVudDtcbiAgICAgICAgICAgICAgcC5yZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocC5wcm9taXNlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBsb2cudHJhY2UocHJvbWlzZXMpO1xuICAgICAgUS5hbGxTZXR0bGVkKHByb21pc2VzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICBkLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGxvZy50cmFjZShlKTtcbiAgICAgICAgZC5yZWplY3QoZSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q2FyZCA9IGZ1bmN0aW9uKG9iamVjdElEKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBBbGdvbGlhSW5kZXguZ2V0T2JqZWN0KG9iamVjdElELCBmdW5jdGlvbihlLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgbG9nLnRyYWNlKGUpO1xuICAgICAgICAgIGQucmVqZWN0KGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZC5yZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvdW5kU2VhcmNoID0gZnVuY3Rpb24odXNlcklELCBzZWFyY2hUZXh0KSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICBjb25zdCBtYXhMZW5ndGggPSA0MDA7XG4gICAgICBjb25zdCBzZWFyY2hUZXh0QXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IGhpdHNQZXJQYWdlID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5jZWlsKDEwIC8gKHNlYXJjaFRleHQubGVuZ3RoIC8gbWF4TGVuZ3RoKSksIDMpLCAxMik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlYXJjaFRleHQubGVuZ3RoOyBpICs9IG1heExlbmd0aCkge1xuICAgICAgICBzZWFyY2hUZXh0QXJyYXkucHVzaChzZWFyY2hUZXh0LnN1YnN0cmluZyhpLCBpK21heExlbmd0aCkpXG4gICAgICB9XG4gICAgICBjb25zdCBwcm9taXNlcyA9IHNlYXJjaFRleHRBcnJheS5tYXAoZnVuY3Rpb24odCwgaikge1xuICAgICAgICByZXR1cm4gc2VhcmNoQ2FyZHModXNlcklELCB0LCBoaXRzUGVyUGFnZSk7XG4gICAgICB9KTtcbiAgICAgIFEuYWxsU2V0dGxlZChwcm9taXNlcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIHJlc3VsdHMubWFwKGZ1bmN0aW9uKHIpIHtyZXR1cm4gci52YWx1ZX0pKTtcbiAgICAgICAgcmVzdWx0cyA9IHJlbW92ZUR1cGxpY2F0ZXMocmVzdWx0cywgJ29iamVjdElEJylcbiAgICAgICAgbG9nLnRyYWNlKHJlc3VsdHMpO1xuICAgICAgICBkLnJlc29sdmUocmVzdWx0cylcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBsb2cudHJhY2UoZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkLnByb21pc2VcbiAgICB9XG5cbiAgICBjb25zdCByZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24ob3JpZ2luYWxBcnJheSwgb2JqS2V5KSB7XG4gICAgICB2YXIgdHJpbW1lZEFycmF5ID0gW10sIHZhbHVlcyA9IFtdLCB2YWx1ZTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb3JpZ2luYWxBcnJheVtpXVtvYmpLZXldO1xuICAgICAgICBpZih2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgdHJpbW1lZEFycmF5LnB1c2gob3JpZ2luYWxBcnJheVtpXSk7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJpbW1lZEFycmF5O1xuICAgIH1cblxuICAgIGNvbnN0IGNoZWNrUGFnZUhpdCA9IGZ1bmN0aW9uKHBhZ2VEYXRhLCByZXN1bHRzKSB7XG4gICAgICAvL05vdCB5ZXQgYWNjb3VudGluZyBmb3IgY2FwaXRhbHNcbiAgICAgIGNvbnN0IGJvcmluZ1dvcmRzID0gW1xuICAgICAgICAnZmF2b3VyaXRlJyxcbiAgICAgICAgJ3dvcmxkJyxcbiAgICAgICAgJ25hbWUnLFxuICAgICAgICAndGhpcycsXG4gICAgICAgICdwbGFuJyxcbiAgICAgICAgJ25lZWQnLFxuICAgICAgICAnYmVzdCcsXG4gICAgICAgICdsaWtlJyxcbiAgICAgICAgJ3RoZScsXG4gICAgICAgICdhcmUnLFxuICAgICAgICAnaXMnLFxuICAgICAgICAnbXknLFxuICAgICAgICAnbXknLFxuICAgICAgXVxuICAgICAgY29uc3QgaGl0cyA9IFtdO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKHJlc3VsdCwgaSkge1xuICAgICAgICBsb2cudHJhY2UoJy0tLScpO1xuICAgICAgICBsb2cudHJhY2UoaSk7XG4gICAgICAgIHZhciBjb3VudCA9IFtdO1xuICAgICAgICByZXN1bHQuY29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICBpZiAocGFnZURhdGEucGFnZVRleHQuaW5kZXhPZihjLnZhbHVlKSA+IC0xXG4gICAgICAgICAgJiYgaGl0cy5pbmRleE9mKHJlc3VsdC5vYmplY3RJRCkgPT0gLTFcbiAgICAgICAgICAmJiBjLnZhbHVlICYmIGMudmFsdWUubGVuZ3RoID4gM1xuICAgICAgICAgICYmIGJvcmluZ1dvcmRzLmluZGV4T2YoYy52YWx1ZSkgPT0gLTFcbiAgICAgICAgICAmJiBjb3VudC5pbmRleE9mKGMudmFsdWUpID09IC0xKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYy52YWx1ZSk7XG4gICAgICAgICAgICBjb3VudC5wdXNoKGMudmFsdWUpO1xuICAgICAgICAgICAgKGMudmFsdWUubWF0Y2goLyAvZykgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNvdW50LnB1c2goYy52YWx1ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGNvdW50Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBsb2cudHJhY2UocmVzdWx0LnNlbnRlbmNlKTtcbiAgICAgICAgICBoaXRzLnB1c2gocmVzdWx0KVxuICAgICAgICB9XG4gICAgICAgIGxvZy50cmFjZSgnLS0tJyk7XG4gICAgICB9KVxuXG4gICAgICAvLyByZXR1cm4gaGl0cztcbiAgICAgIC8vRm9yY2Ugbm8gaGl0c1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGNoZWNrUGFnZVJlbWluZGVyID0gZnVuY3Rpb24odXNlcklELCBwYWdlRGF0YSkge1xuICAgICAgY29uc3QgZCA9IFEuZGVmZXIoKVxuICAgICAgbG9nLnRyYWNlKHBhZ2VEYXRhKTtcbiAgICAgIGNvbnN0IHVybFJvb3QgPSBwYWdlRGF0YS5iYXNlVXJsLnJlcGxhY2UoJy5jb20nLCcnKS5yZXBsYWNlKCcuY28udWsnLCcnKS5yZXBsYWNlKCcub3JnJywnJylcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgcXVlcnk6ICcnLFxuICAgICAgICBmaWx0ZXJzOiAndXNlcklEOiAnICsgdXNlcklEICsgJyBBTkQgKHRyaWdnZXJVcmw6ICcgKyB1cmxSb290ICsgJyBPUiB0cmlnZ2VyVXJsOiAnICsgdXJsUm9vdCArICcuY29tIE9SIHRyaWdnZXJVcmw6ICcgKyB1cmxSb290ICsgJy5jby51ayBPUiB0cmlnZ2VyVXJsOiAnICsgdXJsUm9vdCArICcub3JnIE9SIHRyaWdnZXJVUkw6ICcgKyB1cmxSb290ICsgJyBPUiB0cmlnZ2VyVVJMOiAnICsgdXJsUm9vdCArICcuY29tIE9SIHRyaWdnZXJVUkw6ICcgKyB1cmxSb290ICsgJy5jby51ayBPUiB0cmlnZ2VyVVJMOiAnICsgdXJsUm9vdCArICcub3JnKSdcbiAgICAgIH07XG4gICAgICBsb2cudHJhY2UoJ3BhcmFtcycpO1xuICAgICAgbG9nLnRyYWNlKHBhcmFtcyk7XG4gICAgICBhZHZhbmNlZFNlYXJjaChwYXJhbXMpXG4gICAgICAudGhlbihmdW5jdGlvbihyZW1pbmRlcnMpIHtcbiAgICAgICAgbG9nLnRyYWNlKCdyZW1pbmRlcnMnKTtcbiAgICAgICAgbG9nLnRyYWNlKHJlbWluZGVycyk7XG4gICAgICAgIGQucmVzb2x2ZShyZW1pbmRlcnMpXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGQucmVqZWN0KGUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGdldFBhZ2VSZXN1bHRzID0gZnVuY3Rpb24odXNlcklELCBwYWdlRGF0YSwgYWxsVXNlckNhcmRzKSB7XG4gICAgICBjb25zdCBkID0gUS5kZWZlcigpXG4gICAgICAvLyBHZXRzIGFsbCByZXN1bHRzXG4gICAgICBjb25zdCBwYWdlUmVzdWx0cyA9IHtcbiAgICAgICAgaGl0czogW10sXG4gICAgICAgIHJlbWluZGVyczogW10sXG4gICAgICAgIHBpbmdzOiBbXSxcbiAgICAgICAgbWVtb3JpZXM6IFtdLFxuICAgICAgfTtcbiAgICAgIGxvZy50cmFjZSh1c2VySUQsIHBhZ2VEYXRhKTtcbiAgICAgIGNvbnN0IGdtYWlsQm9yaW5nUGhyYXNlcyA9IFtcbiAgICAgICAgJ1NraXAgdG8gY29udGVudCcsXG4gICAgICAgICdVc2luZycsXG4gICAgICAgICd3aXRoIHNjcmVlbiByZWFkZXJzJyxcbiAgICAgICAgJ1NlYXJjaCcsXG4gICAgICAgICdNYWlsJyxcbiAgICAgICAgJ0NPTVBPU0UnLFxuICAgICAgICAnTGFiZWxzJyxcbiAgICAgICAgJ0luYm94JyxcbiAgICAgICAgJ1N0YXJyZWQnLFxuICAgICAgICAnU2VudCBNYWlsJyxcbiAgICAgICAgJ0RyYWZ0cycsXG4gICAgICAgICdNb3JlJyxcbiAgICAgICAgJy0tLS0tLS0tLS0gRm9yd2FyZGVkIG1lc3NhZ2UgLS0tLS0tLS0tLScsXG4gICAgICAgICdGcm9tOiAnLFxuICAgICAgICAnRGF0ZTogJyxcbiAgICAgICAgJ1N1YmplY3Q6ICcsXG4gICAgICAgICdUbzogJyxcbiAgICAgICAgJ0NsaWNrIGhlcmUgdG8gUmVwbHkgb3IgRm9yd2FyZCcsXG4gICAgICAgICdHQicsXG4gICAgICAgICdHQiB1c2VkJyxcbiAgICAgICAgJ01hbmFnZScsXG4gICAgICAgICdQcm9ncmFtIFBvbGljaWVzJyxcbiAgICAgICAgJ1Bvd2VyZWQgYnkgR29vZ2xlJyxcbiAgICAgICAgJ0xhc3QgYWNjb3VudCBhY3Rpdml0eTonLFxuICAgICAgICAnaG91ciBhZ28nLFxuICAgICAgICAnaG91cnMgYWdvJyxcbiAgICAgICAgJ0RldGFpbHMnLFxuICAgICAgXVxuICAgICAgZ21haWxCb3JpbmdQaHJhc2VzLmZvckVhY2goZnVuY3Rpb24ocGhyYXNlKSB7XG4gICAgICAgIHBhZ2VEYXRhLnBhZ2VUZXh0ID0gcGFnZURhdGEucGFnZVRleHQucmVwbGFjZShwaHJhc2UsICcnKVxuICAgICAgfSlcbiAgICAgIGNvbnN0IGJvcmluZ1dvcmRzID0gW1xuICAgICAgICBcImlcIixcbiAgICAgICAgXCJhXCIsXG4gICAgICAgIFwib2ZcIixcbiAgICAgICAgXCJtZVwiLFxuICAgICAgICBcIm15XCIsXG4gICAgICAgIFwiaXNcIixcbiAgICAgICAgXCJpbVwiLFxuICAgICAgICBcInNvXCIsXG4gICAgICAgIFwiYWxsXCIsXG4gICAgICAgIFwiZ2V0XCIsXG4gICAgICAgIFwiaG93XCIsXG4gICAgICAgIFwibmV3XCIsXG4gICAgICAgIFwib3V0XCIsXG4gICAgICAgIFwidGhlXCIsXG4gICAgICAgIFwidXNlXCIsXG4gICAgICAgIFwiYmVzdFwiLFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJuZXh0XCIsXG4gICAgICAgIFwidGFrZVwiLFxuICAgICAgICBcIndoYXRcIixcbiAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICBcInNvbWV0aGluZ1wiLFxuICAgICAgXVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGxXb3JkcyA9IFtdXG4gICAgICAgIGFsbFVzZXJDYXJkcy5mb3JFYWNoKGZ1bmN0aW9uKGNhcmQpIHtcbiAgICAgICAgICB2YXIgc2NvcmUgPSAwXG4gICAgICAgICAgY2FyZC5jb250ZXh0LmZvckVhY2goZnVuY3Rpb24oZW50aXR5KSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBTdHJpbmcoZW50aXR5LnZhbHVlKVxuICAgICAgICAgICAgaWYgKGJvcmluZ1dvcmRzLmluZGV4T2YodmFsLnRvTG93ZXJDYXNlKCkpID09IC0xICYmIHZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHZhbCksIFwiZ2lcIik7XG4gICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IChwYWdlRGF0YS5wYWdlVGV4dC5tYXRjaChyZWcpIHx8IFtdKS5sZW5ndGggKiB2YWwubGVuZ3RoXG4gICAgICAgICAgICAgIHNjb3JlICs9IHBvaW50c1xuICAgICAgICAgICAgICBpZiAocG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbFdvcmRzLmluZGV4T2YodmFsKSA9PSAtMSkgYWxsV29yZHMucHVzaCh2YWwpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmIChzY29yZSA+IDEwMCkge1xuICAgICAgICAgICAgcGFnZVJlc3VsdHMuaGl0cy5wdXNoKGNhcmQpXG4gICAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+IDApIHtcbiAgICAgICAgICAgIHBhZ2VSZXN1bHRzLm1lbW9yaWVzLnB1c2goY2FyZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGxvZy5kZWJ1ZyhhbGxXb3JkcylcblxuICAgICAgICBwYWdlUmVzdWx0cy5yZW1pbmRlcnMgPSBhbGxVc2VyQ2FyZHMuZmlsdGVyKGZ1bmN0aW9uKGNhcmQpIHtcbiAgICAgICAgICBjb25zdCB1cmxSb290ID0gcGFnZURhdGEuYmFzZVVybC5yZXBsYWNlKCcuY29tJywnJykucmVwbGFjZSgnLmNvLnVrJywnJykucmVwbGFjZSgnLm9yZycsJycpXG4gICAgICAgICAgbG9nLmluZm8oY2FyZC50cmlnZ2VyVVJMKVxuICAgICAgICAgIHJldHVybiBjYXJkLnRyaWdnZXJVUkwgJiYgKGNhcmQudHJpZ2dlclVSTC5pbmRleE9mKHVybFJvb3QpID4gLTEgfHwgY2FyZC50cmlnZ2VyVVJMLmluZGV4T2YodXJsUm9vdCkgPiAtMSlcbiAgICAgICAgfSlcbiAgICAgICAgcGFnZVJlc3VsdHMucGluZ3MgPSBwYWdlUmVzdWx0cy5yZW1pbmRlcnMgLy8uY29uY2F0KHBhZ2VSZXN1bHRzLmhpdHMpXG4gICAgICAgIHBhZ2VSZXN1bHRzLnBpbmdzLmZvckVhY2goZnVuY3Rpb24ocGluZykgeyBwaW5nLmhpZ2hsaWdodCA9IHRydWUgfSlcbiAgICAgICAgLy8gcGFnZVJlc3VsdHMubWVtb3JpZXMgPSBwYWdlUmVzdWx0cy5waW5ncy5jb25jYXQocGFnZVJlc3VsdHMubWVtb3JpZXMpXG4gICAgICAgIHBhZ2VSZXN1bHRzLm1lbW9yaWVzID0gcmVtb3ZlRHVwbGljYXRlcyhwYWdlUmVzdWx0cy5tZW1vcmllcywgJ29iamVjdElEJylcbiAgICAgICAgbG9nLmRlYnVnKHBhZ2VSZXN1bHRzKTtcbiAgICAgICAgZC5yZXNvbHZlKHBhZ2VSZXN1bHRzKVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxvZy5lcnJvcihlKVxuICAgICAgfVxuXG4gICAgICAvLyBjb21wb3VuZFNlYXJjaCh1c2VySUQsIHBhZ2VEYXRhLnBhZ2VUZXh0KVxuICAgICAgLy8gLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgLy8gICBsb2cudHJhY2UoMSk7XG4gICAgICAvLyAgIGxvZy50cmFjZShyZXN1bHRzKTtcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMubWVtb3JpZXMgPSByZXN1bHRzO1xuICAgICAgLy8gICAvLyBDaGVja3Mgd2hldGhlciBhIHBpbmcgaXMgcmVxdWlyZWRcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMuaGl0cyA9IGNoZWNrUGFnZUhpdChwYWdlRGF0YSwgcmVzdWx0cyk7XG4gICAgICAvLyAgIGxvZy50cmFjZSgyKTtcbiAgICAgIC8vICAgbG9nLnRyYWNlKHBhZ2VSZXN1bHRzLmhpdHMpO1xuICAgICAgLy8gICByZXR1cm4gY2hlY2tQYWdlUmVtaW5kZXIodXNlcklELCBwYWdlRGF0YSlcbiAgICAgIC8vIH0pLnRoZW4oZnVuY3Rpb24ocmVtaW5kZXJzKSB7XG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLnJlbWluZGVycyA9IHJlbWluZGVycztcbiAgICAgIC8vICAgbG9nLnRyYWNlKDMpO1xuICAgICAgLy8gICBsb2cudHJhY2UocGFnZVJlc3VsdHMucmVtaW5kZXJzKTtcbiAgICAgIC8vICAgLy8gUmV0dXJucyByZXN1bHRzIHBsdXMgcGluZ1xuICAgICAgLy8gICBwYWdlUmVzdWx0cy5waW5ncyA9IHBhZ2VSZXN1bHRzLnJlbWluZGVycy5jb25jYXQocGFnZVJlc3VsdHMuaGl0cylcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMucGluZ3MuZm9yRWFjaChmdW5jdGlvbihwaW5nKSB7XG4gICAgICAvLyAgICAgbG9nLnRyYWNlKHBpbmcub2JqZWN0SUQpO1xuICAgICAgLy8gICAgIHBpbmcuaGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIC8vICAgfSlcbiAgICAgIC8vICAgcGFnZVJlc3VsdHMubWVtb3JpZXMgPSBwYWdlUmVzdWx0cy5waW5ncy5jb25jYXQocGFnZVJlc3VsdHMubWVtb3JpZXMpXG4gICAgICAvLyAgIHBhZ2VSZXN1bHRzLm1lbW9yaWVzID0gcmVtb3ZlRHVwbGljYXRlcyhwYWdlUmVzdWx0cy5tZW1vcmllcywgJ29iamVjdElEJylcbiAgICAgIC8vICAgbG9nLnRyYWNlKHBhZ2VSZXN1bHRzKTtcbiAgICAgIC8vICAgZC5yZXNvbHZlKHBhZ2VSZXN1bHRzKVxuICAgICAgLy8gfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgLy8gICBsb2cudHJhY2UoZSk7XG4gICAgICAvLyAgIGQucmVqZWN0KGUpXG4gICAgICAvLyB9KVxuICAgICAgcmV0dXJuIGQucHJvbWlzZVxuICAgIH1cblxuICAgIHRoaXMuYWR2YW5jZWRTZWFyY2ggPSBhZHZhbmNlZFNlYXJjaDtcbiAgICB0aGlzLnNlYXJjaENhcmRzID0gc2VhcmNoQ2FyZHM7XG4gICAgdGhpcy5jb21wb3VuZFNlYXJjaCA9IGNvbXBvdW5kU2VhcmNoO1xuICAgIHRoaXMuZ2V0UGFnZVJlc3VsdHMgPSBnZXRQYWdlUmVzdWx0cztcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9wbHVnaW5zL2V4cGxhYWluLXNlYXJjaC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFsZ29saWFTZWFyY2ggPSByZXF1aXJlKCcuLi8uLi9BbGdvbGlhU2VhcmNoLmpzJyk7XG52YXIgY3JlYXRlQWxnb2xpYXNlYXJjaCA9IHJlcXVpcmUoJy4uL2NyZWF0ZUFsZ29saWFzZWFyY2guanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBbGdvbGlhc2VhcmNoKEFsZ29saWFTZWFyY2gpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2J1aWxkcy9hbGdvbGlhc2VhcmNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBBbGdvbGlhU2VhcmNoO1xuXG52YXIgSW5kZXggPSByZXF1aXJlKCcuL0luZGV4LmpzJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUuanMnKTtcbnZhciBkZXByZWNhdGVkTWVzc2FnZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZE1lc3NhZ2UuanMnKTtcbnZhciBBbGdvbGlhU2VhcmNoQ29yZSA9IHJlcXVpcmUoJy4vQWxnb2xpYVNlYXJjaENvcmUuanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuZnVuY3Rpb24gQWxnb2xpYVNlYXJjaCgpIHtcbiAgQWxnb2xpYVNlYXJjaENvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoQWxnb2xpYVNlYXJjaCwgQWxnb2xpYVNlYXJjaENvcmUpO1xuXG4vKlxuICogRGVsZXRlIGFuIGluZGV4XG4gKlxuICogQHBhcmFtIGluZGV4TmFtZSB0aGUgbmFtZSBvZiBpbmRleCB0byBkZWxldGVcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgdGFzayBJRFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kZWxldGVJbmRleCA9IGZ1bmN0aW9uKGluZGV4TmFtZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE5hbWUpLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogTW92ZSBhbiBleGlzdGluZyBpbmRleC5cbiAqIEBwYXJhbSBzcmNJbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXggdG8gY29weS5cbiAqIEBwYXJhbSBkc3RJbmRleE5hbWUgdGhlIG5ldyBpbmRleCBuYW1lIHRoYXQgd2lsbCBjb250YWlucyBhIGNvcHkgb2ZcbiAqIHNyY0luZGV4TmFtZSAoZGVzdGluYXRpb24gd2lsbCBiZSBvdmVycml0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdCkuXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUubW92ZUluZGV4ID0gZnVuY3Rpb24oc3JjSW5kZXhOYW1lLCBkc3RJbmRleE5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBwb3N0T2JqID0ge1xuICAgIG9wZXJhdGlvbjogJ21vdmUnLCBkZXN0aW5hdGlvbjogZHN0SW5kZXhOYW1lXG4gIH07XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHNyY0luZGV4TmFtZSkgKyAnL29wZXJhdGlvbicsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvcHkgYW4gZXhpc3RpbmcgaW5kZXguXG4gKiBAcGFyYW0gc3JjSW5kZXhOYW1lIHRoZSBuYW1lIG9mIGluZGV4IHRvIGNvcHkuXG4gKiBAcGFyYW0gZHN0SW5kZXhOYW1lIHRoZSBuZXcgaW5kZXggbmFtZSB0aGF0IHdpbGwgY29udGFpbnMgYSBjb3B5XG4gKiBvZiBzcmNJbmRleE5hbWUgKGRlc3RpbmF0aW9uIHdpbGwgYmUgb3ZlcnJpdGVuIGlmIGl0IGFscmVhZHkgZXhpc3QpLlxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIHRoZSB0YXNrIElEXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmNvcHlJbmRleCA9IGZ1bmN0aW9uKHNyY0luZGV4TmFtZSwgZHN0SW5kZXhOYW1lLCBjYWxsYmFjaykge1xuICB2YXIgcG9zdE9iaiA9IHtcbiAgICBvcGVyYXRpb246ICdjb3B5JywgZGVzdGluYXRpb246IGRzdEluZGV4TmFtZVxuICB9O1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChzcmNJbmRleE5hbWUpICsgJy9vcGVyYXRpb24nLFxuICAgIGJvZHk6IHBvc3RPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gbGFzdCBsb2cgZW50cmllcy5cbiAqIEBwYXJhbSBvZmZzZXQgU3BlY2lmeSB0aGUgZmlyc3QgZW50cnkgdG8gcmV0cmlldmUgKDAtYmFzZWQsIDAgaXMgdGhlIG1vc3QgcmVjZW50IGxvZyBlbnRyeSkuXG4gKiBAcGFyYW0gbGVuZ3RoIFNwZWNpZnkgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gcmV0cmlldmUgc3RhcnRpbmdcbiAqIGF0IG9mZnNldC4gTWF4aW11bSBhbGxvd2VkIHZhbHVlOiAxMDAwLlxuICogQHBhcmFtIHR5cGUgU3BlY2lmeSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyB0byByZXRyaWV2ZSBzdGFydGluZ1xuICogYXQgb2Zmc2V0LiBNYXhpbXVtIGFsbG93ZWQgdmFsdWU6IDEwMDAuXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZ2V0TG9ncyA9IGZ1bmN0aW9uKG9mZnNldCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG4gIHZhciBwYXJhbXMgPSB7fTtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gZ2V0TG9ncyhwYXJhbXMpXG4gICAgcGFyYW1zID0gY2xvbmUob2Zmc2V0KTtcbiAgICBjYWxsYmFjayA9IGxlbmd0aDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBnZXRMb2dzKFtjYl0pXG4gICAgY2FsbGJhY2sgPSBvZmZzZXQ7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgbGVuZ3RoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZ2V0TG9ncygxLCBbY2IpXVxuICAgIGNhbGxiYWNrID0gbGVuZ3RoO1xuICAgIHBhcmFtcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2V0TG9ncygxLCAyLCBbY2JdKVxuICAgIHBhcmFtcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcGFyYW1zLmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChwYXJhbXMub2Zmc2V0ID09PSB1bmRlZmluZWQpIHBhcmFtcy5vZmZzZXQgPSAwO1xuICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSBwYXJhbXMubGVuZ3RoID0gMTA7XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2xvZ3M/JyArIHRoaXMuX2dldFNlYXJjaFBhcmFtcyhwYXJhbXMsICcnKSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gKiBMaXN0IGFsbCBleGlzdGluZyBpbmRleGVzIChwYWdpbmF0ZWQpXG4gKlxuICogQHBhcmFtIHBhZ2UgVGhlIHBhZ2UgdG8gcmV0cmlldmUsIHN0YXJ0aW5nIGF0IDAuXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggaW5kZXggbGlzdFxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5saXN0SW5kZXhlcyA9IGZ1bmN0aW9uKHBhZ2UsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXJhbXMgPSAnJztcblxuICBpZiAocGFnZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBwYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYWdlO1xuICB9IGVsc2Uge1xuICAgIHBhcmFtcyA9ICc/cGFnZT0nICsgcGFnZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzJyArIHBhcmFtcyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gKiBHZXQgdGhlIGluZGV4IG9iamVjdCBpbml0aWFsaXplZFxuICpcbiAqIEBwYXJhbSBpbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXhcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIHdpdGggb25lIGFyZ3VtZW50ICh0aGUgSW5kZXggaW5zdGFuY2UpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmluaXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4TmFtZSkge1xuICByZXR1cm4gbmV3IEluZGV4KHRoaXMsIGluZGV4TmFtZSk7XG59O1xuXG4vKlxuICogQGRlcHJlY2F0ZWQgdXNlIGNsaWVudC5saXN0QXBpS2V5c1xuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5saXN0VXNlcktleXMgPSBkZXByZWNhdGUoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMubGlzdEFwaUtleXMoY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5saXN0VXNlcktleXMoKScsICdjbGllbnQubGlzdEFwaUtleXMoKScpKTtcblxuLypcbiAqIExpc3QgYWxsIGV4aXN0aW5nIGFwaSBrZXlzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCBBQ0xzXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIGFwaSBrZXlzIGxpc3RcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUubGlzdEFwaUtleXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiAnLzEva2V5cycsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuICogQGRlcHJlY2F0ZWQgc2VlIGNsaWVudC5nZXRBcGlLZXlcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZ2V0VXNlcktleUFDTCA9IGRlcHJlY2F0ZShmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmdldEFwaUtleShrZXksIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuZ2V0VXNlcktleUFDTCgpJywgJ2NsaWVudC5nZXRBcGlLZXkoKScpKTtcblxuLypcbiAqIEdldCBhbiBBUEkga2V5XG4gKlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSByaWdodCBBUEkga2V5XG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmdldEFwaUtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2tleXMvJyArIGtleSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gKiBAZGVwcmVjYXRlZCBzZWUgY2xpZW50LmRlbGV0ZUFwaUtleVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kZWxldGVVc2VyS2V5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZGVsZXRlQXBpS2V5KGtleSwgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5kZWxldGVVc2VyS2V5KCknLCAnY2xpZW50LmRlbGV0ZUFwaUtleSgpJykpO1xuXG4vKlxuICogRGVsZXRlIGFuIGV4aXN0aW5nIEFQSSBrZXlcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgZGF0ZSBvZiBkZWxldGlvblxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5kZWxldGVBcGlLZXkgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9rZXlzLycgKyBrZXksXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgY2xpZW50LmFkZEFwaUtleVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5hZGRVc2VyS2V5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYWRkQXBpS2V5KGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5hZGRVc2VyS2V5KCknLCAnY2xpZW50LmFkZEFwaUtleSgpJykpO1xuXG4vKlxuICogQWRkIGEgbmV3IGdsb2JhbCBBUEkga2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gYWNscyAtIFRoZSBsaXN0IG9mIEFDTCBmb3IgdGhpcyBrZXkuIERlZmluZWQgYnkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0XG4gKiAgIGNhbiBjb250YWlucyB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqICAgICAtIHNlYXJjaDogYWxsb3cgdG8gc2VhcmNoIChodHRwcyBhbmQgaHR0cClcbiAqICAgICAtIGFkZE9iamVjdDogYWxsb3dzIHRvIGFkZC91cGRhdGUgYW4gb2JqZWN0IGluIHRoZSBpbmRleCAoaHR0cHMgb25seSlcbiAqICAgICAtIGRlbGV0ZU9iamVjdCA6IGFsbG93cyB0byBkZWxldGUgYW4gZXhpc3Rpbmcgb2JqZWN0IChodHRwcyBvbmx5KVxuICogICAgIC0gZGVsZXRlSW5kZXggOiBhbGxvd3MgdG8gZGVsZXRlIGluZGV4IGNvbnRlbnQgKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBzZXR0aW5ncyA6IGFsbG93cyB0byBnZXQgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBlZGl0U2V0dGluZ3MgOiBhbGxvd3MgdG8gY2hhbmdlIGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9ubmFsIHBhcmFtZXRlcnMgdG8gc2V0IGZvciB0aGUga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbGlkaXR5IC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGtleSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCAoMCBtZWFucyBubyB0aW1lIGxpbWl0IGZvciB0aGlzIGtleSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91ciAtIE51bWJlciBvZiBBUEkgY2FsbHMgYWxsb3dlZCBmcm9tIGFuIElQIGFkZHJlc3MgcGVyIGhvdXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5IC0gTnVtYmVyIG9mIGhpdHMgdGhpcyBBUEkga2V5IGNhbiByZXRyaWV2ZSBpbiBvbmUgY2FsbFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmluZGV4ZXMgLSBBbGxvd2VkIHRhcmdldGVkIGluZGV4ZXMgZm9yIHRoaXMga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBmb3IgeW91ciBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5yZWZlcmVycyAtIEEgbGlzdCBvZiBhdXRob3JpemVkIHJlZmVyZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnF1ZXJ5UGFyYW1ldGVycyAtIEZvcmNlIHRoZSBrZXkgdG8gdXNlIHNwZWNpZmljIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAqICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgYWRkZWQgQVBJIGtleVxuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gKiBAZXhhbXBsZVxuICogY2xpZW50LmFkZFVzZXJLZXkoWydzZWFyY2gnXSwge1xuICogICB2YWxpZGl0eTogMzAwLFxuICogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuICogICBtYXhIaXRzUGVyUXVlcnk6IDMsXG4gKiAgIGluZGV4ZXM6IFsnZnJ1aXRzJ10sXG4gKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4gKiAgIHJlZmVyZXJzOiBbJyouYWxnb2xpYS5jb20nXSxcbiAqICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4gKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiAqICAgfVxuICogfSlcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNBZGRLZXl8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5hZGRBcGlLZXkgPSBmdW5jdGlvbihhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGNsaWVudC5hZGRBcGlLZXkoYXJyYXlPZkFjbHNbLCBwYXJhbXMsIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShhY2xzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwb3N0T2JqID0ge1xuICAgIGFjbDogYWNsc1xuICB9O1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBwb3N0T2JqLnZhbGlkaXR5ID0gcGFyYW1zLnZhbGlkaXR5O1xuICAgIHBvc3RPYmoubWF4UXVlcmllc1BlcklQUGVySG91ciA9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyO1xuICAgIHBvc3RPYmoubWF4SGl0c1BlclF1ZXJ5ID0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeTtcbiAgICBwb3N0T2JqLmluZGV4ZXMgPSBwYXJhbXMuaW5kZXhlcztcbiAgICBwb3N0T2JqLmRlc2NyaXB0aW9uID0gcGFyYW1zLmRlc2NyaXB0aW9uO1xuXG4gICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIHBvc3RPYmoucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMsICcnKTtcbiAgICB9XG5cbiAgICBwb3N0T2JqLnJlZmVyZXJzID0gcGFyYW1zLnJlZmVyZXJzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9rZXlzJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBjbGllbnQuYWRkQXBpS2V5KClcbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuYWRkVXNlcktleVdpdGhWYWxpZGl0eSA9IGRlcHJlY2F0ZShmdW5jdGlvbihhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFkZEFwaUtleShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuYWRkVXNlcktleVdpdGhWYWxpZGl0eSgpJywgJ2NsaWVudC5hZGRBcGlLZXkoKScpKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGNsaWVudC51cGRhdGVBcGlLZXkoKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS51cGRhdGVVc2VyS2V5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy51cGRhdGVBcGlLZXkoa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQudXBkYXRlVXNlcktleSgpJywgJ2NsaWVudC51cGRhdGVBcGlLZXkoKScpKTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgQVBJIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2xzIC0gVGhlIGxpc3Qgb2YgQUNMIGZvciB0aGlzIGtleS4gRGVmaW5lZCBieSBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXRcbiAqICAgY2FuIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICogICAgIC0gc2VhcmNoOiBhbGxvdyB0byBzZWFyY2ggKGh0dHBzIGFuZCBodHRwKVxuICogICAgIC0gYWRkT2JqZWN0OiBhbGxvd3MgdG8gYWRkL3VwZGF0ZSBhbiBvYmplY3QgaW4gdGhlIGluZGV4IChodHRwcyBvbmx5KVxuICogICAgIC0gZGVsZXRlT2JqZWN0IDogYWxsb3dzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBvYmplY3QgKGh0dHBzIG9ubHkpXG4gKiAgICAgLSBkZWxldGVJbmRleCA6IGFsbG93cyB0byBkZWxldGUgaW5kZXggY29udGVudCAoaHR0cHMgb25seSlcbiAqICAgICAtIHNldHRpbmdzIDogYWxsb3dzIHRvIGdldCBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAqICAgICAtIGVkaXRTZXR0aW5ncyA6IGFsbG93cyB0byBjaGFuZ2UgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25uYWwgcGFyYW1ldGVycyB0byBzZXQgZm9yIHRoZSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsaWRpdHkgLSBOdW1iZXIgb2Ygc2Vjb25kcyBhZnRlciB3aGljaCB0aGUga2V5IHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkICgwIG1lYW5zIG5vIHRpbWUgbGltaXQgZm9yIHRoaXMga2V5KVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyIC0gTnVtYmVyIG9mIEFQSSBjYWxscyBhbGxvd2VkIGZyb20gYW4gSVAgYWRkcmVzcyBwZXIgaG91clxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnkgLSBOdW1iZXIgb2YgaGl0cyB0aGlzIEFQSSBrZXkgY2FuIHJldHJpZXZlIGluIG9uZSBjYWxsXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuaW5kZXhlcyAtIEFsbG93ZWQgdGFyZ2V0ZWQgaW5kZXhlcyBmb3IgdGhpcyBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIGZvciB5b3VyIGtleVxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJlZmVyZXJzIC0gQSBsaXN0IG9mIGF1dGhvcml6ZWQgcmVmZXJlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucXVlcnlQYXJhbWV0ZXJzIC0gRm9yY2UgdGhlIGtleSB0byB1c2Ugc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAqICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBtb2RpZmllZCBBUEkga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiAqIEBleGFtcGxlXG4gKiBjbGllbnQudXBkYXRlQXBpS2V5KCdBUElLRVknLCBbJ3NlYXJjaCddLCB7XG4gKiAgIHZhbGlkaXR5OiAzMDAsXG4gKiAgIG1heFF1ZXJpZXNQZXJJUFBlckhvdXI6IDIwMDAsXG4gKiAgIG1heEhpdHNQZXJRdWVyeTogMyxcbiAqICAgaW5kZXhlczogWydmcnVpdHMnXSxcbiAqICAgZGVzY3JpcHRpb246ICdFYXQgdGhyZWUgZnJ1aXRzJyxcbiAqICAgcmVmZXJlcnM6IFsnKi5hbGdvbGlhLmNvbSddLFxuICogICBxdWVyeVBhcmFtZXRlcnM6IHtcbiAqICAgICB0YWdGaWx0ZXJzOiBbJ3B1YmxpYyddLFxuICogICB9XG4gKiB9KVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI1VwZGF0ZUluZGV4S2V5fEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAqL1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUudXBkYXRlQXBpS2V5ID0gZnVuY3Rpb24oa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGNsaWVudC51cGRhdGVBcGlLZXkoa2V5LCBhcnJheU9mQWNsc1ssIHBhcmFtcywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KGFjbHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSBudWxsO1xuICB9XG5cbiAgdmFyIHB1dE9iaiA9IHtcbiAgICBhY2w6IGFjbHNcbiAgfTtcblxuICBpZiAocGFyYW1zKSB7XG4gICAgcHV0T2JqLnZhbGlkaXR5ID0gcGFyYW1zLnZhbGlkaXR5O1xuICAgIHB1dE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgcHV0T2JqLm1heEhpdHNQZXJRdWVyeSA9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnk7XG4gICAgcHV0T2JqLmluZGV4ZXMgPSBwYXJhbXMuaW5kZXhlcztcbiAgICBwdXRPYmouZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb247XG5cbiAgICBpZiAocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgcHV0T2JqLnF1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuX2dldFNlYXJjaFBhcmFtcyhwYXJhbXMucXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG4gICAgfVxuXG4gICAgcHV0T2JqLnJlZmVyZXJzID0gcGFyYW1zLnJlZmVyZXJzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2tleXMvJyArIGtleSxcbiAgICBib2R5OiBwdXRPYmosXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGJhdGNoIG9mIHNlYXJjaCBxdWVyaWVzXG4gKiBAZGVwcmVjYXRlZCB1c2UgY2xpZW50LnNlYXJjaCgpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLnN0YXJ0UXVlcmllc0JhdGNoID0gZGVwcmVjYXRlKGZ1bmN0aW9uIHN0YXJ0UXVlcmllc0JhdGNoRGVwcmVjYXRlZCgpIHtcbiAgdGhpcy5fYmF0Y2ggPSBbXTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuc3RhcnRRdWVyaWVzQmF0Y2goKScsICdjbGllbnQuc2VhcmNoKCknKSk7XG5cbi8qKlxuICogQWRkIGEgc2VhcmNoIHF1ZXJ5IGluIHRoZSBiYXRjaFxuICogQGRlcHJlY2F0ZWQgdXNlIGNsaWVudC5zZWFyY2goKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5hZGRRdWVyeUluQmF0Y2ggPSBkZXByZWNhdGUoZnVuY3Rpb24gYWRkUXVlcnlJbkJhdGNoRGVwcmVjYXRlZChpbmRleE5hbWUsIHF1ZXJ5LCBhcmdzKSB7XG4gIHRoaXMuX2JhdGNoLnB1c2goe1xuICAgIGluZGV4TmFtZTogaW5kZXhOYW1lLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBwYXJhbXM6IGFyZ3NcbiAgfSk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmFkZFF1ZXJ5SW5CYXRjaCgpJywgJ2NsaWVudC5zZWFyY2goKScpKTtcblxuLyoqXG4gKiBMYXVuY2ggdGhlIGJhdGNoIG9mIHF1ZXJpZXMgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG4gKiBAZGVwcmVjYXRlZCB1c2UgY2xpZW50LnNlYXJjaCgpXG4gKi9cbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLnNlbmRRdWVyaWVzQmF0Y2ggPSBkZXByZWNhdGUoZnVuY3Rpb24gc2VuZFF1ZXJpZXNCYXRjaERlcHJlY2F0ZWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuc2VhcmNoKHRoaXMuX2JhdGNoLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LnNlbmRRdWVyaWVzQmF0Y2goKScsICdjbGllbnQuc2VhcmNoKCknKSk7XG5cbi8qKlxuICogUGVyZm9ybSB3cml0ZSBvcGVyYXRpb25zIGFjY3Jvc3MgbXVsdGlwbGUgaW5kZXhlcy5cbiAqXG4gKiBUbyByZWR1Y2UgdGhlIGFtb3VudCBvZiB0aW1lIHNwZW50IG9uIG5ldHdvcmsgcm91bmQgdHJpcHMsXG4gKiB5b3UgY2FuIGNyZWF0ZSwgdXBkYXRlLCBvciBkZWxldGUgc2V2ZXJhbCBvYmplY3RzIGluIG9uZSBjYWxsLFxuICogdXNpbmcgdGhlIGJhdGNoIGVuZHBvaW50IChhbGwgb3BlcmF0aW9ucyBhcmUgZG9uZSBpbiB0aGUgZ2l2ZW4gb3JkZXIpLlxuICpcbiAqIEF2YWlsYWJsZSBhY3Rpb25zOlxuICogICAtIGFkZE9iamVjdFxuICogICAtIHVwZGF0ZU9iamVjdFxuICogICAtIHBhcnRpYWxVcGRhdGVPYmplY3RcbiAqICAgLSBwYXJ0aWFsVXBkYXRlT2JqZWN0Tm9DcmVhdGVcbiAqICAgLSBkZWxldGVPYmplY3RcbiAqXG4gKiBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjSW5kZXhlc1xuICogQHBhcmFtICB7T2JqZWN0W119IG9wZXJhdGlvbnMgQW4gYXJyYXkgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtXG4gKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiAqIEBleGFtcGxlXG4gKiBjbGllbnQuYmF0Y2goW3tcbiAqICAgYWN0aW9uOiAnYWRkT2JqZWN0JyxcbiAqICAgaW5kZXhOYW1lOiAnY2xpZW50cycsXG4gKiAgIGJvZHk6IHtcbiAqICAgICBuYW1lOiAnQmlsbCdcbiAqICAgfVxuICogfSwge1xuICogICBhY3Rpb246ICd1ZHBhdGVPYmplY3QnLFxuICogICBpbmRleE5hbWU6ICdmcnVpdHMnLFxuICogICBib2R5OiB7XG4gKiAgICAgb2JqZWN0SUQ6ICcyOTEzOCcsXG4gKiAgICAgbmFtZTogJ2JhbmFuYSdcbiAqICAgfVxuICogfV0sIGNiKVxuICovXG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uKG9wZXJhdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGNsaWVudC5iYXRjaChvcGVyYXRpb25zWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9wZXJhdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8qL2JhdGNoJyxcbiAgICBib2R5OiB7XG4gICAgICByZXF1ZXN0czogb3BlcmF0aW9uc1xuICAgIH0sXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLy8gZW52aXJvbm1lbnQgc3BlY2lmaWMgbWV0aG9kc1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZGVzdHJveSA9IG5vdEltcGxlbWVudGVkO1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZW5hYmxlUmF0ZUxpbWl0Rm9yd2FyZCA9IG5vdEltcGxlbWVudGVkO1xuQWxnb2xpYVNlYXJjaC5wcm90b3R5cGUuZGlzYWJsZVJhdGVMaW1pdEZvcndhcmQgPSBub3RJbXBsZW1lbnRlZDtcbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLnVzZVNlY3VyZWRBUElLZXkgPSBub3RJbXBsZW1lbnRlZDtcbkFsZ29saWFTZWFyY2gucHJvdG90eXBlLmRpc2FibGVTZWN1cmVkQVBJS2V5ID0gbm90SW1wbGVtZW50ZWQ7XG5BbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5nZW5lcmF0ZVNlY3VyZWRBcGlLZXkgPSBub3RJbXBsZW1lbnRlZDtcblxuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7XG4gIHZhciBtZXNzYWdlID0gJ05vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGVudmlyb25tZW50LlxcbicgK1xuICAgICdJZiB5b3UgZmVlbCB0aGlzIGlzIGEgbWlzdGFrZSwgd3JpdGUgdG8gc3VwcG9ydEBhbGdvbGlhLmNvbSc7XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IobWVzc2FnZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0FsZ29saWFTZWFyY2guanMiLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEluZGV4Q29yZSA9IHJlcXVpcmUoJy4vSW5kZXhDb3JlLmpzJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUuanMnKTtcbnZhciBkZXByZWNhdGVkTWVzc2FnZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZE1lc3NhZ2UuanMnKTtcbnZhciBleGl0UHJvbWlzZSA9IHJlcXVpcmUoJy4vZXhpdFByb21pc2UuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG52YXIgZGVwcmVjYXRlRm9yd2FyZFRvU2xhdmVzID0gZGVwcmVjYXRlKFxuICBmdW5jdGlvbigpIHt9LFxuICBkZXByZWNhdGVkTWVzc2FnZSgnZm9yd2FyZFRvU2xhdmVzJywgJ2ZvcndhcmRUb1JlcGxpY2FzJylcbik7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXg7XG5cbmZ1bmN0aW9uIEluZGV4KCkge1xuICBJbmRleENvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoSW5kZXgsIEluZGV4Q29yZSk7XG5cbi8qXG4qIEFkZCBhbiBvYmplY3QgaW4gdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gY29udGVudCBjb250YWlucyB0aGUgamF2YXNjcmlwdCBvYmplY3QgdG8gYWRkIGluc2lkZSB0aGUgaW5kZXhcbiogQHBhcmFtIG9iamVjdElEIChvcHRpb25hbCkgYW4gb2JqZWN0SUQgeW91IHdhbnQgdG8gYXR0cmlidXRlIHRvIHRoaXMgb2JqZWN0XG4qIChpZiB0aGUgYXR0cmlidXRlIGFscmVhZHkgZXhpc3QgdGhlIG9sZCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdGUpXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiovXG5JbmRleC5wcm90b3R5cGUuYWRkT2JqZWN0ID0gZnVuY3Rpb24oY29udGVudCwgb2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIG9iamVjdElEID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvYmplY3RJRDtcbiAgICBvYmplY3RJRCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiBvYmplY3RJRCAhPT0gdW5kZWZpbmVkID9cbiAgICAnUFVUJyA6IC8vIHVwZGF0ZSBvciBjcmVhdGVcbiAgICAnUE9TVCcsIC8vIGNyZWF0ZSAoQVBJIGdlbmVyYXRlcyBhbiBvYmplY3RJRClcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArIC8vIGNyZWF0ZVxuICAgIChvYmplY3RJRCAhPT0gdW5kZWZpbmVkID8gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSA6ICcnKSwgLy8gdXBkYXRlIG9yIGNyZWF0ZVxuICAgIGJvZHk6IGNvbnRlbnQsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogQWRkIHNldmVyYWwgb2JqZWN0c1xuKlxuKiBAcGFyYW0gb2JqZWN0cyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIGFkZFxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IHVwZGF0ZUF0IGFuZCB0YXNrSURcbiovXG5JbmRleC5wcm90b3R5cGUuYWRkT2JqZWN0cyA9IGZ1bmN0aW9uKG9iamVjdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LmFkZE9iamVjdHMoYXJyYXlPZk9iamVjdHNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob2JqZWN0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgdmFyIHBvc3RPYmogPSB7XG4gICAgcmVxdWVzdHM6IFtdXG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgYWN0aW9uOiAnYWRkT2JqZWN0JyxcbiAgICAgIGJvZHk6IG9iamVjdHNbaV1cbiAgICB9O1xuICAgIHBvc3RPYmoucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgfVxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9iYXRjaCcsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBVcGRhdGUgcGFydGlhbGx5IGFuIG9iamVjdCAob25seSB1cGRhdGUgYXR0cmlidXRlcyBwYXNzZWQgaW4gYXJndW1lbnQpXG4qXG4qIEBwYXJhbSBwYXJ0aWFsT2JqZWN0IGNvbnRhaW5zIHRoZSBqYXZhc2NyaXB0IGF0dHJpYnV0ZXMgdG8gb3ZlcnJpZGUsIHRoZVxuKiAgb2JqZWN0IG11c3QgY29udGFpbnMgYW4gb2JqZWN0SUQgYXR0cmlidXRlXG4qIEBwYXJhbSBjcmVhdGVJZk5vdEV4aXN0cyAob3B0aW9uYWwpIGlmIGZhbHNlLCBhdm9pZCBhbiBhdXRvbWF0aWMgY3JlYXRpb24gb2YgdGhlIG9iamVjdFxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIDMgZWxlbWVudHM6IGNyZWF0ZUF0LCB0YXNrSWQgYW5kIG9iamVjdElEXG4qL1xuSW5kZXgucHJvdG90eXBlLnBhcnRpYWxVcGRhdGVPYmplY3QgPSBmdW5jdGlvbihwYXJ0aWFsT2JqZWN0LCBjcmVhdGVJZk5vdEV4aXN0cywgY2FsbGJhY2spIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGNyZWF0ZUlmTm90RXhpc3RzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVJZk5vdEV4aXN0cztcbiAgICBjcmVhdGVJZk5vdEV4aXN0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciB1cmwgPSAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQocGFydGlhbE9iamVjdC5vYmplY3RJRCkgKyAnL3BhcnRpYWwnO1xuICBpZiAoY3JlYXRlSWZOb3RFeGlzdHMgPT09IGZhbHNlKSB7XG4gICAgdXJsICs9ICc/Y3JlYXRlSWZOb3RFeGlzdHM9ZmFsc2UnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6IHVybCxcbiAgICBib2R5OiBwYXJ0aWFsT2JqZWN0LFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIFBhcnRpYWxseSBPdmVycmlkZSB0aGUgY29udGVudCBvZiBzZXZlcmFsIG9iamVjdHNcbipcbiogQHBhcmFtIG9iamVjdHMgY29udGFpbnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byB1cGRhdGUgKGVhY2ggb2JqZWN0IG11c3QgY29udGFpbnMgYSBvYmplY3RJRCBhdHRyaWJ1dGUpXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgdXBkYXRlQXQgYW5kIHRhc2tJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5wYXJ0aWFsVXBkYXRlT2JqZWN0cyA9IGZ1bmN0aW9uKG9iamVjdHMsIGNyZWF0ZUlmTm90RXhpc3RzLCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgY3JlYXRlSWZOb3RFeGlzdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUlmTm90RXhpc3RzO1xuICAgIGNyZWF0ZUlmTm90RXhpc3RzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LnBhcnRpYWxVcGRhdGVPYmplY3RzKGFycmF5T2ZPYmplY3RzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9iamVjdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciBwb3N0T2JqID0ge1xuICAgIHJlcXVlc3RzOiBbXVxuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgIGFjdGlvbjogY3JlYXRlSWZOb3RFeGlzdHMgPT09IHRydWUgPyAncGFydGlhbFVwZGF0ZU9iamVjdCcgOiAncGFydGlhbFVwZGF0ZU9iamVjdE5vQ3JlYXRlJyxcbiAgICAgIG9iamVjdElEOiBvYmplY3RzW2ldLm9iamVjdElELFxuICAgICAgYm9keTogb2JqZWN0c1tpXVxuICAgIH07XG4gICAgcG9zdE9iai5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICB9XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIE92ZXJyaWRlIHRoZSBjb250ZW50IG9mIG9iamVjdFxuKlxuKiBAcGFyYW0gb2JqZWN0IGNvbnRhaW5zIHRoZSBqYXZhc2NyaXB0IG9iamVjdCB0byBzYXZlLCB0aGUgb2JqZWN0IG11c3QgY29udGFpbnMgYW4gb2JqZWN0SUQgYXR0cmlidXRlXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgdXBkYXRlQXQgYW5kIHRhc2tJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5zYXZlT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0Lm9iamVjdElEKSxcbiAgICBib2R5OiBvYmplY3QsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufVxuXG4vKlxuKiBPdmVycmlkZSB0aGUgY29udGVudCBvZiBzZXZlcmFsIG9iamVjdHNcbipcbiogQHBhcmFtIG9iamVjdHMgY29udGFpbnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byB1cGRhdGUgKGVhY2ggb2JqZWN0IG11c3QgY29udGFpbnMgYSBvYmplY3RJRCBhdHRyaWJ1dGUpXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgdXBkYXRlQXQgYW5kIHRhc2tJRFxuKi9cbkluZGV4LnByb3RvdHlwZS5zYXZlT2JqZWN0cyA9IGZ1bmN0aW9uKG9iamVjdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LnNhdmVPYmplY3RzKGFycmF5T2ZPYmplY3RzWywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKCFpc0FycmF5KG9iamVjdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciBwb3N0T2JqID0ge1xuICAgIHJlcXVlc3RzOiBbXVxuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgIGFjdGlvbjogJ3VwZGF0ZU9iamVjdCcsXG4gICAgICBvYmplY3RJRDogb2JqZWN0c1tpXS5vYmplY3RJRCxcbiAgICAgIGJvZHk6IG9iamVjdHNbaV1cbiAgICB9O1xuICAgIHBvc3RPYmoucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgfVxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9iYXRjaCcsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBEZWxldGUgYW4gb2JqZWN0IGZyb20gdGhlIGluZGV4XG4qXG4qIEBwYXJhbSBvYmplY3RJRCB0aGUgdW5pcXVlIGlkZW50aWZpZXIgb2Ygb2JqZWN0IHRvIGRlbGV0ZVxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIDMgZWxlbWVudHM6IGNyZWF0ZUF0LCB0YXNrSWQgYW5kIG9iamVjdElEXG4qL1xuSW5kZXgucHJvdG90eXBlLmRlbGV0ZU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdElELCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9iamVjdElEID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmplY3RJRCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9iamVjdElEICE9PSAnbnVtYmVyJykge1xuICAgIHZhciBlcnIgPSBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcignQ2Fubm90IGRlbGV0ZSBhbiBvYmplY3Qgd2l0aG91dCBhbiBvYmplY3RJRCcpO1xuICAgIGNhbGxiYWNrID0gb2JqZWN0SUQ7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXMuX3Byb21pc2UucmVqZWN0KGVycik7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIERlbGV0ZSBzZXZlcmFsIG9iamVjdHMgZnJvbSBhbiBpbmRleFxuKlxuKiBAcGFyYW0gb2JqZWN0SURzIGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdElEIHRvIGRlbGV0ZVxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIDMgZWxlbWVudHM6IGNyZWF0ZUF0LCB0YXNrSWQgYW5kIG9iamVjdElEXG4qL1xuSW5kZXgucHJvdG90eXBlLmRlbGV0ZU9iamVjdHMgPSBmdW5jdGlvbihvYmplY3RJRHMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcblxuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGluZGV4LmRlbGV0ZU9iamVjdHMoYXJyYXlPZk9iamVjdElEc1ssIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShvYmplY3RJRHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciBwb3N0T2JqID0ge1xuICAgIHJlcXVlc3RzOiBtYXAob2JqZWN0SURzLCBmdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChvYmplY3RJRCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uOiAnZGVsZXRlT2JqZWN0JyxcbiAgICAgICAgb2JqZWN0SUQ6IG9iamVjdElELFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgb2JqZWN0SUQ6IG9iamVjdElEXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSlcbiAgfTtcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9iYXRjaCcsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKlxuKiBEZWxldGUgYWxsIG9iamVjdHMgbWF0Y2hpbmcgYSBxdWVyeVxuKlxuKiBAcGFyYW0gcXVlcnkgdGhlIHF1ZXJ5IHN0cmluZ1xuKiBAcGFyYW0gcGFyYW1zIHRoZSBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50XG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qL1xuSW5kZXgucHJvdG90eXBlLmRlbGV0ZUJ5UXVlcnkgPSBmdW5jdGlvbihxdWVyeSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG4gIHZhciBtYXAgPSByZXF1aXJlKCcuL21hcC5qcycpO1xuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHZhciBjbGllbnQgPSBpbmRleE9iai5hcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0ge307XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zID0gY2xvbmUocGFyYW1zKTtcbiAgfVxuXG4gIHBhcmFtcy5hdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9ICdvYmplY3RJRCc7XG4gIHBhcmFtcy5oaXRzUGVyUGFnZSA9IDEwMDA7XG4gIHBhcmFtcy5kaXN0aW5jdCA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gZGVsZXRpbmcsIHdlIHNob3VsZCBuZXZlciB1c2UgY2FjaGUgdG8gZ2V0IHRoZVxuICAvLyBzZWFyY2ggcmVzdWx0c1xuICB0aGlzLmNsZWFyQ2FjaGUoKTtcblxuICAvLyB0aGVyZSdzIGEgcHJvYmxlbSBpbiBob3cgd2UgdXNlIHRoZSBwcm9taXNlIGNoYWluLFxuICAvLyBzZWUgaG93IHdhaXRUYXNrIGlzIGRvbmVcbiAgdmFyIHByb21pc2UgPSB0aGlzXG4gIC5zZWFyY2gocXVlcnksIHBhcmFtcylcbiAgLnRoZW4oc3RvcE9yRGVsZXRlKTtcblxuICBmdW5jdGlvbiBzdG9wT3JEZWxldGUoc2VhcmNoQ29udGVudCkge1xuICAgIC8vIHN0b3AgaGVyZVxuICAgIGlmIChzZWFyY2hDb250ZW50Lm5iSGl0cyA9PT0gMCkge1xuICAgICAgLy8gcmV0dXJuIGluZGV4T2JqLmFzLl9yZXF1ZXN0LnJlc29sdmUoKTtcbiAgICAgIHJldHVybiBzZWFyY2hDb250ZW50O1xuICAgIH1cblxuICAgIC8vIGNvbnRpbnVlIGFuZCBkbyBhIHJlY3Vyc2l2ZSBjYWxsXG4gICAgdmFyIG9iamVjdElEcyA9IG1hcChzZWFyY2hDb250ZW50LmhpdHMsIGZ1bmN0aW9uIGdldE9iamVjdElEKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdC5vYmplY3RJRDtcbiAgICB9KTtcblxuICAgIHJldHVybiBpbmRleE9ialxuICAgIC5kZWxldGVPYmplY3RzKG9iamVjdElEcylcbiAgICAudGhlbih3YWl0VGFzaylcbiAgICAudGhlbihkb0RlbGV0ZUJ5UXVlcnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdFRhc2soZGVsZXRlT2JqZWN0c0NvbnRlbnQpIHtcbiAgICByZXR1cm4gaW5kZXhPYmoud2FpdFRhc2soZGVsZXRlT2JqZWN0c0NvbnRlbnQudGFza0lEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvRGVsZXRlQnlRdWVyeSgpIHtcbiAgICByZXR1cm4gaW5kZXhPYmouZGVsZXRlQnlRdWVyeShxdWVyeSwgcGFyYW1zKTtcbiAgfVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHByb21pc2UudGhlbihzdWNjZXNzLCBmYWlsdXJlKTtcblxuICBmdW5jdGlvbiBzdWNjZXNzKCkge1xuICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uIGV4aXQoKSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsdXJlKGVycikge1xuICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uIGV4aXQoKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgfVxufTtcblxuLypcbiogQnJvd3NlIGFsbCBjb250ZW50IGZyb20gYW4gaW5kZXggdXNpbmcgZXZlbnRzLiBCYXNpY2FsbHkgdGhpcyB3aWxsIGRvXG4qIC5icm93c2UoKSAtPiAuYnJvd3NlRnJvbSAtPiAuYnJvd3NlRnJvbSAtPiAuLiB1bnRpbCBhbGwgdGhlIHJlc3VsdHMgYXJlIHJldHVybmVkXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBmdWxsIHRleHQgcXVlcnlcbiogQHBhcmFtIHtPYmplY3R9IFtxdWVyeVBhcmFtZXRlcnNdIC0gQW55IHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJcbiogQHJldHVybiB7RXZlbnRFbWl0dGVyfVxuKiBAZXhhbXBsZVxuKiB2YXIgYnJvd3NlciA9IGluZGV4LmJyb3dzZUFsbCgnY29vbCBzb25ncycsIHtcbiogICB0YWdGaWx0ZXJzOiAncHVibGljLGNvbW1lbnRzJyxcbiogICBoaXRzUGVyUGFnZTogNTAwXG4qIH0pO1xuKlxuKiBicm93c2VyLm9uKCdyZXN1bHQnLCBmdW5jdGlvbiByZXN1bHRDYWxsYmFjayhjb250ZW50KSB7XG4qICAgY29uc29sZS5sb2coY29udGVudC5oaXRzKTtcbiogfSk7XG4qXG4qIC8vIGlmIGFueSBlcnJvciBvY2N1cnMsIHlvdSBnZXQgaXRcbiogYnJvd3Nlci5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiogICB0aHJvdyBlcnI7XG4qIH0pO1xuKlxuKiAvLyB3aGVuIHlvdSBoYXZlIGJyb3dzZWQgdGhlIHdob2xlIGluZGV4LCB5b3UgZ2V0IHRoaXMgZXZlbnRcbiogYnJvd3Nlci5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4qICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkJyk7XG4qIH0pO1xuKlxuKiAvLyBhdCBhbnkgcG9pbnQgaWYgeW91IHdhbnQgdG8gc3RvcCB0aGUgYnJvd3NpbmcgcHJvY2VzcywgeW91IGNhbiBzdG9wIGl0IG1hbnVhbGx5XG4qIC8vIG90aGVyd2lzZSBpdCB3aWxsIGdvIG9uIGFuZCBvblxuKiBicm93c2VyLnN0b3AoKTtcbipcbiogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0Jyb3dzZXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXgucHJvdG90eXBlLmJyb3dzZUFsbCA9IGZ1bmN0aW9uKHF1ZXJ5LCBxdWVyeVBhcmFtZXRlcnMpIHtcbiAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBxdWVyeVBhcmFtZXRlcnMgPSBxdWVyeTtcbiAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBtZXJnZSA9IHJlcXVpcmUoJy4vbWVyZ2UuanMnKTtcblxuICB2YXIgSW5kZXhCcm93c2VyID0gcmVxdWlyZSgnLi9JbmRleEJyb3dzZXInKTtcblxuICB2YXIgYnJvd3NlciA9IG5ldyBJbmRleEJyb3dzZXIoKTtcbiAgdmFyIGNsaWVudCA9IHRoaXMuYXM7XG4gIHZhciBpbmRleCA9IHRoaXM7XG4gIHZhciBwYXJhbXMgPSBjbGllbnQuX2dldFNlYXJjaFBhcmFtcyhcbiAgICBtZXJnZSh7fSwgcXVlcnlQYXJhbWV0ZXJzIHx8IHt9LCB7XG4gICAgICBxdWVyeTogcXVlcnlcbiAgICB9KSwgJydcbiAgKTtcblxuICAvLyBzdGFydCBicm93c2luZ1xuICBicm93c2VMb29wKCk7XG5cbiAgZnVuY3Rpb24gYnJvd3NlTG9vcChjdXJzb3IpIHtcbiAgICBpZiAoYnJvd3Nlci5fc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib2R5O1xuXG4gICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib2R5ID0ge1xuICAgICAgICBjdXJzb3I6IGN1cnNvclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2xpZW50Ll9qc29uUmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleC5pbmRleE5hbWUpICsgJy9icm93c2UnLFxuICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICBjYWxsYmFjazogYnJvd3NlQ2FsbGJhY2tcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJyb3dzZUNhbGxiYWNrKGVyciwgY29udGVudCkge1xuICAgIGlmIChicm93c2VyLl9zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgYnJvd3Nlci5fZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicm93c2VyLl9yZXN1bHQoY29udGVudCk7XG5cbiAgICAvLyBubyBjdXJzb3IgbWVhbnMgd2UgYXJlIGZpbmlzaGVkIGJyb3dzaW5nXG4gICAgaWYgKGNvbnRlbnQuY3Vyc29yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyb3dzZXIuX2VuZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyb3dzZUxvb3AoY29udGVudC5jdXJzb3IpO1xuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXI7XG59O1xuXG4vKlxuKiBHZXQgYSBUeXBlYWhlYWQuanMgYWRhcHRlclxuKiBAcGFyYW0gc2VhcmNoUGFyYW1zIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnMgKHNlZSBzZWFyY2ggZm9yIGRldGFpbHMpXG4qL1xuSW5kZXgucHJvdG90eXBlLnR0QWRhcHRlciA9IGRlcHJlY2F0ZShmdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gdHRBZGFwdGVyKHF1ZXJ5LCBzeW5jQ2IsIGFzeW5jQ2IpIHtcbiAgICB2YXIgY2I7XG5cbiAgICBpZiAodHlwZW9mIGFzeW5jQ2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHR5cGVhaGVhZCAwLjExXG4gICAgICBjYiA9IGFzeW5jQ2I7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHByZSB0eXBlYWhlYWQgMC4xMVxuICAgICAgY2IgPSBzeW5jQ2I7XG4gICAgfVxuXG4gICAgc2VsZi5zZWFyY2gocXVlcnksIHBhcmFtcywgZnVuY3Rpb24gc2VhcmNoRG9uZShlcnIsIGNvbnRlbnQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYihjb250ZW50LmhpdHMpO1xuICAgIH0pO1xuICB9O1xufSxcbid0dEFkYXB0ZXIgaXMgbm90IG5lY2Vzc2FyeSBhbnltb3JlIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgdmVyc2lvbixcXG4nICtcbidoYXZlIGEgbG9vayBhdCBhdXRvY29tcGxldGUuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2F1dG9jb21wbGV0ZS5qcyknKTtcblxuLypcbiogV2FpdCB0aGUgcHVibGljYXRpb24gb2YgYSB0YXNrIG9uIHRoZSBzZXJ2ZXIuXG4qIEFsbCBzZXJ2ZXIgdGFzayBhcmUgYXN5bmNocm9ub3VzIGFuZCB5b3UgY2FuIGNoZWNrIHdpdGggdGhpcyBtZXRob2QgdGhhdCB0aGUgdGFzayBpcyBwdWJsaXNoZWQuXG4qXG4qIEBwYXJhbSB0YXNrSUQgdGhlIGlkIG9mIHRoZSB0YXNrIHJldHVybmVkIGJ5IHNlcnZlclxuKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayB3aXRoIHdpdGggdHdvIGFyZ3VtZW50czpcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgcmVzdWx0c1xuKi9cbkluZGV4LnByb3RvdHlwZS53YWl0VGFzayA9IGZ1bmN0aW9uKHRhc2tJRCwgY2FsbGJhY2spIHtcbiAgLy8gd2FpdCBtaW5pbXVtIDEwMG1zIGJlZm9yZSByZXRyeWluZ1xuICB2YXIgYmFzZURlbGF5ID0gMTAwO1xuICAvLyB3YWl0IG1heGltdW0gNXMgYmVmb3JlIHJldHJ5aW5nXG4gIHZhciBtYXhEZWxheSA9IDUwMDA7XG4gIHZhciBsb29wID0gMDtcblxuICAvLyB3YWl0VGFzaygpIG11c3QgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBmcm9tIG90aGVyIG1ldGhvZHMsXG4gIC8vIGl0J3MgYSByZWN1cnNpdmUgbWV0aG9kIHVzaW5nIGEgdGltZW91dFxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICB2YXIgY2xpZW50ID0gaW5kZXhPYmouYXM7XG5cbiAgdmFyIHByb21pc2UgPSByZXRyeUxvb3AoKTtcblxuICBmdW5jdGlvbiByZXRyeUxvb3AoKSB7XG4gICAgcmV0dXJuIGNsaWVudC5fanNvblJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvdGFzay8nICsgdGFza0lEXG4gICAgfSkudGhlbihmdW5jdGlvbiBzdWNjZXNzKGNvbnRlbnQpIHtcbiAgICAgIGxvb3ArKztcbiAgICAgIHZhciBkZWxheSA9IGJhc2VEZWxheSAqIGxvb3AgKiBsb29wO1xuICAgICAgaWYgKGRlbGF5ID4gbWF4RGVsYXkpIHtcbiAgICAgICAgZGVsYXkgPSBtYXhEZWxheTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRlbnQuc3RhdHVzICE9PSAncHVibGlzaGVkJykge1xuICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLmRlbGF5KGRlbGF5KS50aGVuKHJldHJ5TG9vcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYiwgZmFpbHVyZUNiKTtcblxuICBmdW5jdGlvbiBzdWNjZXNzQ2IoY29udGVudCkge1xuICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uIGV4aXQoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBjb250ZW50KTtcbiAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsdXJlQ2IoZXJyKSB7XG4gICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSwgY2xpZW50Ll9zZXRUaW1lb3V0IHx8IHNldFRpbWVvdXQpO1xuICB9XG59O1xuXG4vKlxuKiBUaGlzIGZ1bmN0aW9uIGRlbGV0ZXMgdGhlIGluZGV4IGNvbnRlbnQuIFNldHRpbmdzIGFuZCBpbmRleCBzcGVjaWZpYyBBUEkga2V5cyBhcmUga2VwdCB1bnRvdWNoZWQuXG4qXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNldHRpbmdzIG9iamVjdCBvciB0aGUgZXJyb3IgbWVzc2FnZSBpZiBhIGZhaWx1cmUgb2NjdXJlZFxuKi9cbkluZGV4LnByb3RvdHlwZS5jbGVhckluZGV4ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvY2xlYXInLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIEdldCBzZXR0aW5ncyBvZiB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNldHRpbmdzIG9iamVjdCBvciB0aGUgZXJyb3IgbWVzc2FnZSBpZiBhIGZhaWx1cmUgb2NjdXJlZFxuKi9cbkluZGV4LnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvc2V0dGluZ3M/Z2V0VmVyc2lvbj0yJyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5zZWFyY2hTeW5vbnltcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSB7fTtcbiAgfSBlbHNlIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9zeW5vbnltcy9zZWFyY2gnLFxuICAgIGJvZHk6IHBhcmFtcyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5zYXZlU3lub255bSA9IGZ1bmN0aW9uKHN5bm9ueW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdHMuZm9yd2FyZFRvU2xhdmVzICE9PSB1bmRlZmluZWQpIGRlcHJlY2F0ZUZvcndhcmRUb1NsYXZlcygpO1xuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgfHwgb3B0cy5mb3J3YXJkVG9SZXBsaWNhcykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9zeW5vbnltcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN5bm9ueW0ub2JqZWN0SUQpICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzLFxuICAgIGJvZHk6IHN5bm9ueW0sXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmdldFN5bm9ueW0gPSBmdW5jdGlvbihvYmplY3RJRCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmRlbGV0ZVN5bm9ueW0gPSBmdW5jdGlvbihvYmplY3RJRCwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBpZiAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgIT09IHVuZGVmaW5lZCkgZGVwcmVjYXRlRm9yd2FyZFRvU2xhdmVzKCk7XG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IChvcHRzLmZvcndhcmRUb1NsYXZlcyB8fCBvcHRzLmZvcndhcmRUb1JlcGxpY2FzKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3N5bm9ueW1zLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5jbGVhclN5bm9ueW1zID0gZnVuY3Rpb24ob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBpZiAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgIT09IHVuZGVmaW5lZCkgZGVwcmVjYXRlRm9yd2FyZFRvU2xhdmVzKCk7XG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IChvcHRzLmZvcndhcmRUb1NsYXZlcyB8fCBvcHRzLmZvcndhcmRUb1JlcGxpY2FzKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9zeW5vbnltcy9jbGVhcicgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmJhdGNoU3lub255bXMgPSBmdW5jdGlvbihzeW5vbnltcywgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBpZiAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgIT09IHVuZGVmaW5lZCkgZGVwcmVjYXRlRm9yd2FyZFRvU2xhdmVzKCk7XG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IChvcHRzLmZvcndhcmRUb1NsYXZlcyB8fCBvcHRzLmZvcndhcmRUb1JlcGxpY2FzKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9zeW5vbnltcy9iYXRjaCcgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMgK1xuICAgICAgJyZyZXBsYWNlRXhpc3RpbmdTeW5vbnltcz0nICsgKG9wdHMucmVwbGFjZUV4aXN0aW5nU3lub255bXMgPyAndHJ1ZScgOiAnZmFsc2UnKSxcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBib2R5OiBzeW5vbnltcyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuc2VhcmNoUnVsZXMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0ge307XG4gIH0gZWxzZSBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcnVsZXMvc2VhcmNoJyxcbiAgICBib2R5OiBwYXJhbXMsXG4gICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5JbmRleC5wcm90b3R5cGUuc2F2ZVJ1bGUgPSBmdW5jdGlvbihydWxlLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJ1bGUub2JqZWN0SUQpICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzLFxuICAgIGJvZHk6IHJ1bGUsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmdldFJ1bGUgPSBmdW5jdGlvbihvYmplY3RJRCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3J1bGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQob2JqZWN0SUQpLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbihvYmplY3RJRCwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIgZm9yd2FyZFRvUmVwbGljYXMgPSBvcHRzLmZvcndhcmRUb1JlcGxpY2FzID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcnVsZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCkgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMsXG4gICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXgucHJvdG90eXBlLmNsZWFyUnVsZXMgPSBmdW5jdGlvbihvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9IGVsc2UgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IG9wdHMuZm9yd2FyZFRvUmVwbGljYXMgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvcnVsZXMvY2xlYXInICtcbiAgICAgICc/Zm9yd2FyZFRvUmVwbGljYXM9JyArIGZvcndhcmRUb1JlcGxpY2FzLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4LnByb3RvdHlwZS5iYXRjaFJ1bGVzID0gZnVuY3Rpb24ocnVsZXMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGZvcndhcmRUb1JlcGxpY2FzID0gb3B0cy5mb3J3YXJkVG9SZXBsaWNhcyA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9ydWxlcy9iYXRjaCcgK1xuICAgICAgJz9mb3J3YXJkVG9SZXBsaWNhcz0nICsgZm9yd2FyZFRvUmVwbGljYXMgK1xuICAgICAgJyZjbGVhckV4aXN0aW5nUnVsZXM9JyArIChvcHRzLmNsZWFyRXhpc3RpbmdSdWxlcyA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZScpLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGJvZHk6IHJ1bGVzLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIFNldCBzZXR0aW5ncyBmb3IgdGhpcyBpbmRleFxuKlxuKiBAcGFyYW0gc2V0dGlnbnMgdGhlIHNldHRpbmdzIG9iamVjdCB0aGF0IGNhbiBjb250YWlucyA6XG4qIC0gbWluV29yZFNpemVmb3IxVHlwbzogKGludGVnZXIpIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFjY2VwdCBvbmUgdHlwbyAoZGVmYXVsdCA9IDMpLlxuKiAtIG1pbldvcmRTaXplZm9yMlR5cG9zOiAoaW50ZWdlcikgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gYWNjZXB0IHR3byB0eXBvcyAoZGVmYXVsdCA9IDcpLlxuKiAtIGhpdHNQZXJQYWdlOiAoaW50ZWdlcikgdGhlIG51bWJlciBvZiBoaXRzIHBlciBwYWdlIChkZWZhdWx0ID0gMTApLlxuKiAtIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiAoYXJyYXkgb2Ygc3RyaW5ncykgZGVmYXVsdCBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gcmV0cmlldmUgaW4gb2JqZWN0cy5cbiogICBJZiBzZXQgdG8gbnVsbCwgYWxsIGF0dHJpYnV0ZXMgYXJlIHJldHJpZXZlZC5cbiogLSBhdHRyaWJ1dGVzVG9IaWdobGlnaHQ6IChhcnJheSBvZiBzdHJpbmdzKSBkZWZhdWx0IGxpc3Qgb2YgYXR0cmlidXRlcyB0byBoaWdobGlnaHQuXG4qICAgSWYgc2V0IHRvIG51bGwsIGFsbCBpbmRleGVkIGF0dHJpYnV0ZXMgYXJlIGhpZ2hsaWdodGVkLlxuKiAtIGF0dHJpYnV0ZXNUb1NuaXBwZXQqKjogKGFycmF5IG9mIHN0cmluZ3MpIGRlZmF1bHQgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIHNuaXBwZXQgYWxvbmdzaWRlIHRoZSBudW1iZXJcbiogb2Ygd29yZHMgdG8gcmV0dXJuIChzeW50YXggaXMgYXR0cmlidXRlTmFtZTpuYldvcmRzKS5cbiogICBCeSBkZWZhdWx0IG5vIHNuaXBwZXQgaXMgY29tcHV0ZWQuIElmIHNldCB0byBudWxsLCBubyBzbmlwcGV0IGlzIGNvbXB1dGVkLlxuKiAtIGF0dHJpYnV0ZXNUb0luZGV4OiAoYXJyYXkgb2Ygc3RyaW5ncykgdGhlIGxpc3Qgb2YgZmllbGRzIHlvdSB3YW50IHRvIGluZGV4LlxuKiAgIElmIHNldCB0byBudWxsLCBhbGwgdGV4dHVhbCBhbmQgbnVtZXJpY2FsIGF0dHJpYnV0ZXMgb2YgeW91ciBvYmplY3RzIGFyZSBpbmRleGVkLFxuKiAgIGJ1dCB5b3Ugc2hvdWxkIHVwZGF0ZSBpdCB0byBnZXQgb3B0aW1hbCByZXN1bHRzLlxuKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0d28gaW1wb3J0YW50IHVzZXM6XG4qICAgICAtIExpbWl0IHRoZSBhdHRyaWJ1dGVzIHRvIGluZGV4OiBGb3IgZXhhbXBsZSBpZiB5b3Ugc3RvcmUgYSBiaW5hcnkgaW1hZ2UgaW4gYmFzZTY0LFxuKiAgICAgeW91IHdhbnQgdG8gc3RvcmUgaXQgYW5kIGJlIGFibGUgdG9cbiogICAgICAgcmV0cmlldmUgaXQgYnV0IHlvdSBkb24ndCB3YW50IHRvIHNlYXJjaCBpbiB0aGUgYmFzZTY0IHN0cmluZy5cbiogICAgIC0gQ29udHJvbCBwYXJ0IG9mIHRoZSByYW5raW5nKjogKHNlZSB0aGUgcmFua2luZyBwYXJhbWV0ZXIgZm9yIGZ1bGwgZXhwbGFuYXRpb24pXG4qICAgICBNYXRjaGVzIGluIGF0dHJpYnV0ZXMgYXQgdGhlIGJlZ2lubmluZyBvZlxuKiAgICAgICB0aGUgbGlzdCB3aWxsIGJlIGNvbnNpZGVyZWQgbW9yZSBpbXBvcnRhbnQgdGhhbiBtYXRjaGVzIGluIGF0dHJpYnV0ZXMgZnVydGhlciBkb3duIHRoZSBsaXN0LlxuKiAgICAgICBJbiBvbmUgYXR0cmlidXRlLCBtYXRjaGluZyB0ZXh0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlXG4qICAgICAgIGNvbnNpZGVyZWQgbW9yZSBpbXBvcnRhbnQgdGhhbiB0ZXh0IGFmdGVyLCB5b3UgY2FuIGRpc2FibGVcbiogICAgICAgdGhpcyBiZWhhdmlvciBpZiB5b3UgYWRkIHlvdXIgYXR0cmlidXRlIGluc2lkZSBgdW5vcmRlcmVkKEF0dHJpYnV0ZU5hbWUpYCxcbiogICAgICAgZm9yIGV4YW1wbGUgYXR0cmlidXRlc1RvSW5kZXg6IFtcInRpdGxlXCIsIFwidW5vcmRlcmVkKHRleHQpXCJdLlxuKiAtIGF0dHJpYnV0ZXNGb3JGYWNldGluZzogKGFycmF5IG9mIHN0cmluZ3MpIFRoZSBsaXN0IG9mIGZpZWxkcyB5b3Ugd2FudCB0byB1c2UgZm9yIGZhY2V0aW5nLlxuKiAgIEFsbCBzdHJpbmdzIGluIHRoZSBhdHRyaWJ1dGUgc2VsZWN0ZWQgZm9yIGZhY2V0aW5nIGFyZSBleHRyYWN0ZWQgYW5kIGFkZGVkIGFzIGEgZmFjZXQuXG4qICAgSWYgc2V0IHRvIG51bGwsIG5vIGF0dHJpYnV0ZSBpcyB1c2VkIGZvciBmYWNldGluZy5cbiogLSBhdHRyaWJ1dGVGb3JEaXN0aW5jdDogKHN0cmluZykgVGhlIGF0dHJpYnV0ZSBuYW1lIHVzZWQgZm9yIHRoZSBEaXN0aW5jdCBmZWF0dXJlLlxuKiBUaGlzIGZlYXR1cmUgaXMgc2ltaWxhciB0byB0aGUgU1FMIFwiZGlzdGluY3RcIiBrZXl3b3JkOiB3aGVuIGVuYWJsZWRcbiogICBpbiBxdWVyeSB3aXRoIHRoZSBkaXN0aW5jdD0xIHBhcmFtZXRlciwgYWxsIGhpdHMgY29udGFpbmluZyBhIGR1cGxpY2F0ZVxuKiAgIHZhbHVlIGZvciB0aGlzIGF0dHJpYnV0ZSBhcmUgcmVtb3ZlZCBmcm9tIHJlc3VsdHMuXG4qICAgRm9yIGV4YW1wbGUsIGlmIHRoZSBjaG9zZW4gYXR0cmlidXRlIGlzIHNob3dfbmFtZSBhbmQgc2V2ZXJhbCBoaXRzIGhhdmVcbiogICB0aGUgc2FtZSB2YWx1ZSBmb3Igc2hvd19uYW1lLCB0aGVuIG9ubHkgdGhlIGJlc3Qgb25lIGlzIGtlcHQgYW5kIG90aGVycyBhcmUgcmVtb3ZlZC5cbiogLSByYW5raW5nOiAoYXJyYXkgb2Ygc3RyaW5ncykgY29udHJvbHMgdGhlIHdheSByZXN1bHRzIGFyZSBzb3J0ZWQuXG4qICAgV2UgaGF2ZSBzaXggYXZhaWxhYmxlIGNyaXRlcmlhOlxuKiAgICAtIHR5cG86IHNvcnQgYWNjb3JkaW5nIHRvIG51bWJlciBvZiB0eXBvcyxcbiogICAgLSBnZW86IHNvcnQgYWNjb3JkaW5nIHRvIGRlY3JlYXNzaW5nIGRpc3RhbmNlIHdoZW4gcGVyZm9ybWluZyBhIGdlby1sb2NhdGlvbiBiYXNlZCBzZWFyY2gsXG4qICAgIC0gcHJveGltaXR5OiBzb3J0IGFjY29yZGluZyB0byB0aGUgcHJveGltaXR5IG9mIHF1ZXJ5IHdvcmRzIGluIGhpdHMsXG4qICAgIC0gYXR0cmlidXRlOiBzb3J0IGFjY29yZGluZyB0byB0aGUgb3JkZXIgb2YgYXR0cmlidXRlcyBkZWZpbmVkIGJ5IGF0dHJpYnV0ZXNUb0luZGV4LFxuKiAgICAtIGV4YWN0OlxuKiAgICAgICAgLSBpZiB0aGUgdXNlciBxdWVyeSBjb250YWlucyBvbmUgd29yZDogc29ydCBvYmplY3RzIGhhdmluZyBhbiBhdHRyaWJ1dGVcbiogICAgICAgIHRoYXQgaXMgZXhhY3RseSB0aGUgcXVlcnkgd29yZCBiZWZvcmUgb3RoZXJzLlxuKiAgICAgICAgICBGb3IgZXhhbXBsZSBpZiB5b3Ugc2VhcmNoIGZvciB0aGUgXCJWXCIgVFYgc2hvdywgeW91IHdhbnQgdG8gZmluZCBpdFxuKiAgICAgICAgICB3aXRoIHRoZSBcIlZcIiBxdWVyeSBhbmQgYXZvaWQgdG8gaGF2ZSBhbGwgcG9wdWxhciBUVlxuKiAgICAgICAgICBzaG93IHN0YXJ0aW5nIGJ5IHRoZSB2IGxldHRlciBiZWZvcmUgaXQuXG4qICAgICAgICAtIGlmIHRoZSB1c2VyIHF1ZXJ5IGNvbnRhaW5zIG11bHRpcGxlIHdvcmRzOiBzb3J0IGFjY29yZGluZyB0byB0aGVcbiogICAgICAgIG51bWJlciBvZiB3b3JkcyB0aGF0IG1hdGNoZWQgZXhhY3RseSAoYW5kIG5vdCBhcyBhIHByZWZpeCkuXG4qICAgIC0gY3VzdG9tOiBzb3J0IGFjY29yZGluZyB0byBhIHVzZXIgZGVmaW5lZCBmb3JtdWxhIHNldCBpbiAqKmN1c3RvbVJhbmtpbmcqKiBhdHRyaWJ1dGUuXG4qICAgVGhlIHN0YW5kYXJkIG9yZGVyIGlzIFtcInR5cG9cIiwgXCJnZW9cIiwgXCJwcm94aW1pdHlcIiwgXCJhdHRyaWJ1dGVcIiwgXCJleGFjdFwiLCBcImN1c3RvbVwiXVxuKiAtIGN1c3RvbVJhbmtpbmc6IChhcnJheSBvZiBzdHJpbmdzKSBsZXRzIHlvdSBzcGVjaWZ5IHBhcnQgb2YgdGhlIHJhbmtpbmcuXG4qICAgVGhlIHN5bnRheCBvZiB0aGlzIGNvbmRpdGlvbiBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgYXR0cmlidXRlc1xuKiAgIHByZWZpeGVkIGJ5IGFzYyAoYXNjZW5kaW5nIG9yZGVyKSBvciBkZXNjIChkZXNjZW5kaW5nIG9yZGVyKSBvcGVyYXRvci5cbiogICBGb3IgZXhhbXBsZSBgXCJjdXN0b21SYW5raW5nXCIgPT4gW1wiZGVzYyhwb3B1bGF0aW9uKVwiLCBcImFzYyhuYW1lKVwiXWBcbiogLSBxdWVyeVR5cGU6IFNlbGVjdCBob3cgdGhlIHF1ZXJ5IHdvcmRzIGFyZSBpbnRlcnByZXRlZCwgaXQgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlOlxuKiAgIC0gcHJlZml4QWxsOiBhbGwgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkIGFzIHByZWZpeGVzLFxuKiAgIC0gcHJlZml4TGFzdDogb25seSB0aGUgbGFzdCB3b3JkIGlzIGludGVycHJldGVkIGFzIGEgcHJlZml4IChkZWZhdWx0IGJlaGF2aW9yKSxcbiogICAtIHByZWZpeE5vbmU6IG5vIHF1ZXJ5IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXguIFRoaXMgb3B0aW9uIGlzIG5vdCByZWNvbW1lbmRlZC5cbiogLSBoaWdobGlnaHRQcmVUYWc6IChzdHJpbmcpIFNwZWNpZnkgdGhlIHN0cmluZyB0aGF0IGlzIGluc2VydGVkIGJlZm9yZVxuKiB0aGUgaGlnaGxpZ2h0ZWQgcGFydHMgaW4gdGhlIHF1ZXJ5IHJlc3VsdCAoZGVmYXVsdCB0byBcIjxlbT5cIikuXG4qIC0gaGlnaGxpZ2h0UG9zdFRhZzogKHN0cmluZykgU3BlY2lmeSB0aGUgc3RyaW5nIHRoYXQgaXMgaW5zZXJ0ZWQgYWZ0ZXJcbiogdGhlIGhpZ2hsaWdodGVkIHBhcnRzIGluIHRoZSBxdWVyeSByZXN1bHQgKGRlZmF1bHQgdG8gXCI8L2VtPlwiKS5cbiogLSBvcHRpb25hbFdvcmRzOiAoYXJyYXkgb2Ygc3RyaW5ncykgU3BlY2lmeSBhIGxpc3Qgb2Ygd29yZHMgdGhhdCBzaG91bGRcbiogYmUgY29uc2lkZXJlZCBhcyBvcHRpb25hbCB3aGVuIGZvdW5kIGluIHRoZSBxdWVyeS5cbiogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciBvciB0aGUgZXJyb3IgbWVzc2FnZSBpZiBhIGZhaWx1cmUgb2NjdXJlZFxuKi9cbkluZGV4LnByb3RvdHlwZS5zZXRTZXR0aW5ncyA9IGZ1bmN0aW9uKHNldHRpbmdzLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBpZiAob3B0cy5mb3J3YXJkVG9TbGF2ZXMgIT09IHVuZGVmaW5lZCkgZGVwcmVjYXRlRm9yd2FyZFRvU2xhdmVzKCk7XG4gIHZhciBmb3J3YXJkVG9SZXBsaWNhcyA9IChvcHRzLmZvcndhcmRUb1NsYXZlcyB8fCBvcHRzLmZvcndhcmRUb1JlcGxpY2FzKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9zZXR0aW5ncz9mb3J3YXJkVG9SZXBsaWNhcz0nXG4gICAgICArIGZvcndhcmRUb1JlcGxpY2FzLFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGJvZHk6IHNldHRpbmdzLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gQGRlcHJlY2F0ZWQgc2VlIGluZGV4Lmxpc3RBcGlLZXlzXG4gKi9cbkluZGV4LnByb3RvdHlwZS5saXN0VXNlcktleXMgPSBkZXByZWNhdGUoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMubGlzdEFwaUtleXMoY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4Lmxpc3RVc2VyS2V5cygpJywgJ2luZGV4Lmxpc3RBcGlLZXlzKCknKSk7XG5cbi8qXG4qIExpc3QgYWxsIGV4aXN0aW5nIEFQSSBrZXlzIHRvIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCBBUEkga2V5cyBiZWxvbmdpbmcgdG8gdGhlIGluZGV4XG4qL1xuSW5kZXgucHJvdG90eXBlLmxpc3RBcGlLZXlzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9rZXlzJyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gQGRlcHJlY2F0ZWQgc2VlIGluZGV4LmdldEFwaUtleVxuICovXG5JbmRleC5wcm90b3R5cGUuZ2V0VXNlcktleUFDTCA9IGRlcHJlY2F0ZShmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmdldEFwaUtleShrZXksIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC5nZXRVc2VyS2V5QUNMKCknLCAnaW5kZXguZ2V0QXBpS2V5KCknKSk7XG5cblxuLypcbiogR2V0IGFuIEFQSSBrZXkgZnJvbSB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBrZXlcbiogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgcmlnaHQgQVBJIGtleVxuKi9cbkluZGV4LnByb3RvdHlwZS5nZXRBcGlLZXkgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcva2V5cy8nICsga2V5LFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiBAZGVwcmVjYXRlZCBzZWUgaW5kZXguZGVsZXRlQXBpS2V5XG4gKi9cbkluZGV4LnByb3RvdHlwZS5kZWxldGVVc2VyS2V5ID0gZGVwcmVjYXRlKGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZGVsZXRlQXBpS2V5KGtleSwgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4LmRlbGV0ZVVzZXJLZXkoKScsICdpbmRleC5kZWxldGVBcGlLZXkoKScpKTtcblxuLypcbiogRGVsZXRlIGFuIGV4aXN0aW5nIEFQSSBrZXkgYXNzb2NpYXRlZCB0byB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBrZXlcbiogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgZGVsZXRpb24gZGF0ZVxuKi9cbkluZGV4LnByb3RvdHlwZS5kZWxldGVBcGlLZXkgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcva2V5cy8nICsga2V5LFxuICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4gQGRlcHJlY2F0ZWQgc2VlIGluZGV4LmFkZEFwaUtleVxuICovXG5JbmRleC5wcm90b3R5cGUuYWRkVXNlcktleSA9IGRlcHJlY2F0ZShmdW5jdGlvbihhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFkZEFwaUtleShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC5hZGRVc2VyS2V5KCknLCAnaW5kZXguYWRkQXBpS2V5KCknKSk7XG5cbi8qXG4qIEFkZCBhIG5ldyBBUEkga2V5IHRvIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIHtzdHJpbmdbXX0gYWNscyAtIFRoZSBsaXN0IG9mIEFDTCBmb3IgdGhpcyBrZXkuIERlZmluZWQgYnkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0XG4qICAgY2FuIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuKiAgICAgLSBzZWFyY2g6IGFsbG93IHRvIHNlYXJjaCAoaHR0cHMgYW5kIGh0dHApXG4qICAgICAtIGFkZE9iamVjdDogYWxsb3dzIHRvIGFkZC91cGRhdGUgYW4gb2JqZWN0IGluIHRoZSBpbmRleCAoaHR0cHMgb25seSlcbiogICAgIC0gZGVsZXRlT2JqZWN0IDogYWxsb3dzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBvYmplY3QgKGh0dHBzIG9ubHkpXG4qICAgICAtIGRlbGV0ZUluZGV4IDogYWxsb3dzIHRvIGRlbGV0ZSBpbmRleCBjb250ZW50IChodHRwcyBvbmx5KVxuKiAgICAgLSBzZXR0aW5ncyA6IGFsbG93cyB0byBnZXQgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4qICAgICAtIGVkaXRTZXR0aW5ncyA6IGFsbG93cyB0byBjaGFuZ2UgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4qIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbm5hbCBwYXJhbWV0ZXJzIHRvIHNldCBmb3IgdGhlIGtleVxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbGlkaXR5IC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGtleSB3aWxsXG4qIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCAoMCBtZWFucyBubyB0aW1lIGxpbWl0IGZvciB0aGlzIGtleSlcbiogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyIC0gTnVtYmVyIG9mIEFQSSBjYWxscyBhbGxvd2VkIGZyb20gYW4gSVAgYWRkcmVzcyBwZXIgaG91clxuKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4qIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5yZWZlcmVycyAtIEEgbGlzdCBvZiBhdXRob3JpemVkIHJlZmVyZXJzXG4qIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucXVlcnlQYXJhbWV0ZXJzIC0gRm9yY2UgdGhlIGtleSB0byB1c2Ugc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBhZGRlZCBBUEkga2V5XG4qIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuKiBAZXhhbXBsZVxuKiBpbmRleC5hZGRVc2VyS2V5KFsnc2VhcmNoJ10sIHtcbiogICB2YWxpZGl0eTogMzAwLFxuKiAgIG1heFF1ZXJpZXNQZXJJUFBlckhvdXI6IDIwMDAsXG4qICAgbWF4SGl0c1BlclF1ZXJ5OiAzLFxuKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4qICAgcmVmZXJlcnM6IFsnKi5hbGdvbGlhLmNvbSddLFxuKiAgIHF1ZXJ5UGFyYW1ldGVyczoge1xuKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiogICB9XG4qIH0pXG4qIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNBZGRJbmRleEtleXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4qL1xuSW5kZXgucHJvdG90eXBlLmFkZEFwaUtleSA9IGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXguYWRkQXBpS2V5KGFycmF5T2ZBY2xzWywgcGFyYW1zLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkoYWNscykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IG51bGw7XG4gIH1cblxuICB2YXIgcG9zdE9iaiA9IHtcbiAgICBhY2w6IGFjbHNcbiAgfTtcblxuICBpZiAocGFyYW1zKSB7XG4gICAgcG9zdE9iai52YWxpZGl0eSA9IHBhcmFtcy52YWxpZGl0eTtcbiAgICBwb3N0T2JqLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgPSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91cjtcbiAgICBwb3N0T2JqLm1heEhpdHNQZXJRdWVyeSA9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnk7XG4gICAgcG9zdE9iai5kZXNjcmlwdGlvbiA9IHBhcmFtcy5kZXNjcmlwdGlvbjtcblxuICAgIGlmIChwYXJhbXMucXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICBwb3N0T2JqLnF1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhwYXJhbXMucXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG4gICAgfVxuXG4gICAgcG9zdE9iai5yZWZlcmVycyA9IHBhcmFtcy5yZWZlcmVycztcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcva2V5cycsXG4gICAgYm9keTogcG9zdE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiogQGRlcHJlY2F0ZWQgdXNlIGluZGV4LmFkZEFwaUtleSgpXG4qL1xuSW5kZXgucHJvdG90eXBlLmFkZFVzZXJLZXlXaXRoVmFsaWRpdHkgPSBkZXByZWNhdGUoZnVuY3Rpb24gZGVwcmVjYXRlZEFkZFVzZXJLZXlXaXRoVmFsaWRpdHkoYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5hZGRBcGlLZXkoYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG59LCBkZXByZWNhdGVkTWVzc2FnZSgnaW5kZXguYWRkVXNlcktleVdpdGhWYWxpZGl0eSgpJywgJ2luZGV4LmFkZEFwaUtleSgpJykpO1xuXG4vKlxuIEBkZXByZWNhdGVkIHNlZSBpbmRleC51cGRhdGVBcGlLZXlcbiAqL1xuSW5kZXgucHJvdG90eXBlLnVwZGF0ZVVzZXJLZXkgPSBkZXByZWNhdGUoZnVuY3Rpb24oa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnVwZGF0ZUFwaUtleShrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spO1xufSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2luZGV4LnVwZGF0ZVVzZXJLZXkoKScsICdpbmRleC51cGRhdGVBcGlLZXkoKScpKTtcblxuLyoqXG4qIFVwZGF0ZSBhbiBleGlzdGluZyBBUEkga2V5IG9mIHRoaXMgaW5kZXhcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gdXBkYXRlXG4qIEBwYXJhbSB7c3RyaW5nW119IGFjbHMgLSBUaGUgbGlzdCBvZiBBQ0wgZm9yIHRoaXMga2V5LiBEZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdFxuKiAgIGNhbiBjb250YWlucyB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiogICAgIC0gc2VhcmNoOiBhbGxvdyB0byBzZWFyY2ggKGh0dHBzIGFuZCBodHRwKVxuKiAgICAgLSBhZGRPYmplY3Q6IGFsbG93cyB0byBhZGQvdXBkYXRlIGFuIG9iamVjdCBpbiB0aGUgaW5kZXggKGh0dHBzIG9ubHkpXG4qICAgICAtIGRlbGV0ZU9iamVjdCA6IGFsbG93cyB0byBkZWxldGUgYW4gZXhpc3Rpbmcgb2JqZWN0IChodHRwcyBvbmx5KVxuKiAgICAgLSBkZWxldGVJbmRleCA6IGFsbG93cyB0byBkZWxldGUgaW5kZXggY29udGVudCAoaHR0cHMgb25seSlcbiogICAgIC0gc2V0dGluZ3MgOiBhbGxvd3MgdG8gZ2V0IGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuKiAgICAgLSBlZGl0U2V0dGluZ3MgOiBhbGxvd3MgdG8gY2hhbmdlIGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25uYWwgcGFyYW1ldGVycyB0byBzZXQgZm9yIHRoZSBrZXlcbiogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWxpZGl0eSAtIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBrZXkgd2lsbFxuKiBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgKDAgbWVhbnMgbm8gdGltZSBsaW1pdCBmb3IgdGhpcyBrZXkpXG4qIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91ciAtIE51bWJlciBvZiBBUEkgY2FsbHMgYWxsb3dlZCBmcm9tIGFuIElQIGFkZHJlc3MgcGVyIGhvdXJcbiogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnkgLSBOdW1iZXIgb2YgaGl0cyB0aGlzIEFQSSBrZXkgY2FuIHJldHJpZXZlIGluIG9uZSBjYWxsXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIGZvciB5b3VyIGtleVxuKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucmVmZXJlcnMgLSBBIGxpc3Qgb2YgYXV0aG9yaXplZCByZWZlcmVyc1xuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnF1ZXJ5UGFyYW1ldGVycyAtIEZvcmNlIHRoZSBrZXkgdG8gdXNlIHNwZWNpZmljIHF1ZXJ5IHBhcmFtZXRlcnNcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4qICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB1c2VyIGtleXMgbGlzdFxuKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiogQGV4YW1wbGVcbiogaW5kZXgudXBkYXRlQXBpS2V5KCdBUElLRVknLCBbJ3NlYXJjaCddLCB7XG4qICAgdmFsaWRpdHk6IDMwMCxcbiogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuKiAgIG1heEhpdHNQZXJRdWVyeTogMyxcbiogICBkZXNjcmlwdGlvbjogJ0VhdCB0aHJlZSBmcnVpdHMnLFxuKiAgIHJlZmVyZXJzOiBbJyouYWxnb2xpYS5jb20nXSxcbiogICBxdWVyeVBhcmFtZXRlcnM6IHtcbiogICAgIHRhZ0ZpbHRlcnM6IFsncHVibGljJ10sXG4qICAgfVxuKiB9KVxuKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjVXBkYXRlSW5kZXhLZXl8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuKi9cbkluZGV4LnByb3RvdHlwZS51cGRhdGVBcGlLZXkgPSBmdW5jdGlvbihrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4gIHZhciB1c2FnZSA9ICdVc2FnZTogaW5kZXgudXBkYXRlQXBpS2V5KGtleSwgYXJyYXlPZkFjbHNbLCBwYXJhbXMsIGNhbGxiYWNrXSknO1xuXG4gIGlmICghaXNBcnJheShhY2xzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwdXRPYmogPSB7XG4gICAgYWNsOiBhY2xzXG4gIH07XG5cbiAgaWYgKHBhcmFtcykge1xuICAgIHB1dE9iai52YWxpZGl0eSA9IHBhcmFtcy52YWxpZGl0eTtcbiAgICBwdXRPYmoubWF4UXVlcmllc1BlcklQUGVySG91ciA9IHBhcmFtcy5tYXhRdWVyaWVzUGVySVBQZXJIb3VyO1xuICAgIHB1dE9iai5tYXhIaXRzUGVyUXVlcnkgPSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5O1xuICAgIHB1dE9iai5kZXNjcmlwdGlvbiA9IHBhcmFtcy5kZXNjcmlwdGlvbjtcblxuICAgIGlmIChwYXJhbXMucXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICBwdXRPYmoucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5hcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMsICcnKTtcbiAgICB9XG5cbiAgICBwdXRPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcva2V5cy8nICsga2V5LFxuICAgIGJvZHk6IHB1dE9iaixcbiAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9JbmRleC5qcyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwidmFyIGJ1aWxkU2VhcmNoTWV0aG9kID0gcmVxdWlyZSgnLi9idWlsZFNlYXJjaE1ldGhvZC5qcycpO1xudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlLmpzJyk7XG52YXIgZGVwcmVjYXRlZE1lc3NhZ2UgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWRNZXNzYWdlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhDb3JlO1xuXG4vKlxuKiBJbmRleCBjbGFzcyBjb25zdHJ1Y3Rvci5cbiogWW91IHNob3VsZCBub3QgdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5IGJ1dCB1c2UgaW5pdEluZGV4KCkgZnVuY3Rpb25cbiovXG5mdW5jdGlvbiBJbmRleENvcmUoYWxnb2xpYXNlYXJjaCwgaW5kZXhOYW1lKSB7XG4gIHRoaXMuaW5kZXhOYW1lID0gaW5kZXhOYW1lO1xuICB0aGlzLmFzID0gYWxnb2xpYXNlYXJjaDtcbiAgdGhpcy50eXBlQWhlYWRBcmdzID0gbnVsbDtcbiAgdGhpcy50eXBlQWhlYWRWYWx1ZU9wdGlvbiA9IG51bGw7XG5cbiAgLy8gbWFrZSBzdXJlIGV2ZXJ5IGluZGV4IGluc3RhbmNlIGhhcyBpdCdzIG93biBjYWNoZVxuICB0aGlzLmNhY2hlID0ge307XG59XG5cbi8qXG4qIENsZWFyIGFsbCBxdWVyaWVzIGluIGNhY2hlXG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2FjaGUgPSB7fTtcbn07XG5cbi8qXG4qIFNlYXJjaCBpbnNpZGUgdGhlIGluZGV4IHVzaW5nIFhNTEh0dHBSZXF1ZXN0IHJlcXVlc3QgKFVzaW5nIGEgUE9TVCBxdWVyeSB0b1xuKiBtaW5pbWl6ZSBudW1iZXIgb2YgT1BUSU9OUyBxdWVyaWVzOiBDcm9zcy1PcmlnaW4gUmVzb3VyY2UgU2hhcmluZykuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBbcXVlcnldIHRoZSBmdWxsIHRleHQgcXVlcnlcbiogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAob3B0aW9uYWwpIGlmIHNldCwgY29udGFpbnMgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVyczpcbiogLSBwYWdlOiAoaW50ZWdlcikgUGFnaW5hdGlvbiBwYXJhbWV0ZXIgdXNlZCB0byBzZWxlY3QgdGhlIHBhZ2UgdG8gcmV0cmlldmUuXG4qICAgICAgICAgICAgICAgICAgIFBhZ2UgaXMgemVyby1iYXNlZCBhbmQgZGVmYXVsdHMgdG8gMC4gVGh1cyxcbiogICAgICAgICAgICAgICAgICAgdG8gcmV0cmlldmUgdGhlIDEwdGggcGFnZSB5b3UgbmVlZCB0byBzZXQgcGFnZT05XG4qIC0gaGl0c1BlclBhZ2U6IChpbnRlZ2VyKSBQYWdpbmF0aW9uIHBhcmFtZXRlciB1c2VkIHRvIHNlbGVjdCB0aGUgbnVtYmVyIG9mIGhpdHMgcGVyIHBhZ2UuIERlZmF1bHRzIHRvIDIwLlxuKiAtIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIG9iamVjdCBhdHRyaWJ1dGVzXG4qIHlvdSB3YW50IHRvIHJldHJpZXZlIChsZXQgeW91IG1pbmltaXplIHRoZSBhbnN3ZXIgc2l6ZSkuXG4qICAgQXR0cmlidXRlcyBhcmUgc2VwYXJhdGVkIHdpdGggYSBjb21tYSAoZm9yIGV4YW1wbGUgXCJuYW1lLGFkZHJlc3NcIikuXG4qICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoZm9yIGV4YW1wbGUgW1wibmFtZVwiLFwiYWRkcmVzc1wiXSkuXG4qICAgQnkgZGVmYXVsdCwgYWxsIGF0dHJpYnV0ZXMgYXJlIHJldHJpZXZlZC4gWW91IGNhbiBhbHNvIHVzZSAnKicgdG8gcmV0cmlldmUgYWxsXG4qICAgdmFsdWVzIHdoZW4gYW4gYXR0cmlidXRlc1RvUmV0cmlldmUgc2V0dGluZyBpcyBzcGVjaWZpZWQgZm9yIHlvdXIgaW5kZXguXG4qIC0gYXR0cmlidXRlc1RvSGlnaGxpZ2h0OiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIGF0dHJpYnV0ZXMgeW91XG4qICAgd2FudCB0byBoaWdobGlnaHQgYWNjb3JkaW5nIHRvIHRoZSBxdWVyeS5cbiogICBBdHRyaWJ1dGVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBjb21tYS4gWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoZm9yIGV4YW1wbGUgW1wibmFtZVwiLFwiYWRkcmVzc1wiXSkuXG4qICAgSWYgYW4gYXR0cmlidXRlIGhhcyBubyBtYXRjaCBmb3IgdGhlIHF1ZXJ5LCB0aGUgcmF3IHZhbHVlIGlzIHJldHVybmVkLlxuKiAgIEJ5IGRlZmF1bHQgYWxsIGluZGV4ZWQgdGV4dCBhdHRyaWJ1dGVzIGFyZSBoaWdobGlnaHRlZC5cbiogICBZb3UgY2FuIHVzZSBgKmAgaWYgeW91IHdhbnQgdG8gaGlnaGxpZ2h0IGFsbCB0ZXh0dWFsIGF0dHJpYnV0ZXMuXG4qICAgTnVtZXJpY2FsIGF0dHJpYnV0ZXMgYXJlIG5vdCBoaWdobGlnaHRlZC5cbiogICBBIG1hdGNoTGV2ZWwgaXMgcmV0dXJuZWQgZm9yIGVhY2ggaGlnaGxpZ2h0ZWQgYXR0cmlidXRlIGFuZCBjYW4gY29udGFpbjpcbiogICAgICAtIGZ1bGw6IGlmIGFsbCB0aGUgcXVlcnkgdGVybXMgd2VyZSBmb3VuZCBpbiB0aGUgYXR0cmlidXRlLFxuKiAgICAgIC0gcGFydGlhbDogaWYgb25seSBzb21lIG9mIHRoZSBxdWVyeSB0ZXJtcyB3ZXJlIGZvdW5kLFxuKiAgICAgIC0gbm9uZTogaWYgbm9uZSBvZiB0aGUgcXVlcnkgdGVybXMgd2VyZSBmb3VuZC5cbiogLSBhdHRyaWJ1dGVzVG9TbmlwcGV0OiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gc25pcHBldCBhbG9uZ3NpZGVcbiogdGhlIG51bWJlciBvZiB3b3JkcyB0byByZXR1cm4gKHN5bnRheCBpcyBgYXR0cmlidXRlTmFtZTpuYldvcmRzYCkuXG4qICAgIEF0dHJpYnV0ZXMgYXJlIHNlcGFyYXRlZCBieSBhIGNvbW1hIChFeGFtcGxlOiBhdHRyaWJ1dGVzVG9TbmlwcGV0PW5hbWU6MTAsY29udGVudDoxMCkuXG4qICAgIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKEV4YW1wbGU6IGF0dHJpYnV0ZXNUb1NuaXBwZXQ6IFsnbmFtZToxMCcsJ2NvbnRlbnQ6MTAnXSkuXG4qICAgIEJ5IGRlZmF1bHQgbm8gc25pcHBldCBpcyBjb21wdXRlZC5cbiogLSBtaW5Xb3JkU2l6ZWZvcjFUeXBvOiB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBhIHF1ZXJ5IHdvcmQgdG8gYWNjZXB0IG9uZSB0eXBvIGluIHRoaXMgd29yZC5cbiogRGVmYXVsdHMgdG8gMy5cbiogLSBtaW5Xb3JkU2l6ZWZvcjJUeXBvczogdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gYSBxdWVyeSB3b3JkXG4qIHRvIGFjY2VwdCB0d28gdHlwb3MgaW4gdGhpcyB3b3JkLiBEZWZhdWx0cyB0byA3LlxuKiAtIGdldFJhbmtpbmdJbmZvOiBpZiBzZXQgdG8gMSwgdGhlIHJlc3VsdCBoaXRzIHdpbGwgY29udGFpbiByYW5raW5nXG4qIGluZm9ybWF0aW9uIGluIF9yYW5raW5nSW5mbyBhdHRyaWJ1dGUuXG4qIC0gYXJvdW5kTGF0TG5nOiBzZWFyY2ggZm9yIGVudHJpZXMgYXJvdW5kIGEgZ2l2ZW5cbiogbGF0aXR1ZGUvbG9uZ2l0dWRlIChzcGVjaWZpZWQgYXMgdHdvIGZsb2F0cyBzZXBhcmF0ZWQgYnkgYSBjb21tYSkuXG4qICAgRm9yIGV4YW1wbGUgYXJvdW5kTGF0TG5nPTQ3LjMxNjY2OSw1LjAxNjY3MCkuXG4qICAgWW91IGNhbiBzcGVjaWZ5IHRoZSBtYXhpbXVtIGRpc3RhbmNlIGluIG1ldGVycyB3aXRoIHRoZSBhcm91bmRSYWRpdXMgcGFyYW1ldGVyIChpbiBtZXRlcnMpXG4qICAgYW5kIHRoZSBwcmVjaXNpb24gZm9yIHJhbmtpbmcgd2l0aCBhcm91bmRQcmVjaXNpb25cbiogICAoZm9yIGV4YW1wbGUgaWYgeW91IHNldCBhcm91bmRQcmVjaXNpb249MTAwLCB0d28gb2JqZWN0cyB0aGF0IGFyZSBkaXN0YW50IG9mXG4qICAgbGVzcyB0aGFuIDEwMG0gd2lsbCBiZSBjb25zaWRlcmVkIGFzIGlkZW50aWNhbCBmb3IgXCJnZW9cIiByYW5raW5nIHBhcmFtZXRlcikuXG4qICAgQXQgaW5kZXhpbmcsIHlvdSBzaG91bGQgc3BlY2lmeSBnZW9sb2Mgb2YgYW4gb2JqZWN0IHdpdGggdGhlIF9nZW9sb2MgYXR0cmlidXRlXG4qICAgKGluIHRoZSBmb3JtIHtcIl9nZW9sb2NcIjp7XCJsYXRcIjo0OC44NTM0MDksIFwibG5nXCI6Mi4zNDg4MDB9fSlcbiogLSBpbnNpZGVCb3VuZGluZ0JveDogc2VhcmNoIGVudHJpZXMgaW5zaWRlIGEgZ2l2ZW4gYXJlYSBkZWZpbmVkIGJ5IHRoZSB0d28gZXh0cmVtZSBwb2ludHNcbiogb2YgYSByZWN0YW5nbGUgKGRlZmluZWQgYnkgNCBmbG9hdHM6IHAxTGF0LHAxTG5nLHAyTGF0LHAyTG5nKS5cbiogICBGb3IgZXhhbXBsZSBpbnNpZGVCb3VuZGluZ0JveD00Ny4zMTY1LDQuOTY2NSw0Ny4zNDI0LDUuMDIwMSkuXG4qICAgQXQgaW5kZXhpbmcsIHlvdSBzaG91bGQgc3BlY2lmeSBnZW9sb2Mgb2YgYW4gb2JqZWN0IHdpdGggdGhlIF9nZW9sb2MgYXR0cmlidXRlXG4qICAgKGluIHRoZSBmb3JtIHtcIl9nZW9sb2NcIjp7XCJsYXRcIjo0OC44NTM0MDksIFwibG5nXCI6Mi4zNDg4MDB9fSlcbiogLSBudW1lcmljRmlsdGVyczogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBudW1lcmljIGZpbHRlcnMgeW91IHdhbnQgdG9cbiogYXBwbHkgc2VwYXJhdGVkIGJ5IGEgY29tbWEuXG4qICAgVGhlIHN5bnRheCBvZiBvbmUgZmlsdGVyIGlzIGBhdHRyaWJ1dGVOYW1lYCBmb2xsb3dlZCBieSBgb3BlcmFuZGAgZm9sbG93ZWQgYnkgYHZhbHVlYC5cbiogICBTdXBwb3J0ZWQgb3BlcmFuZHMgYXJlIGA8YCwgYDw9YCwgYD1gLCBgPmAgYW5kIGA+PWAuXG4qICAgWW91IGNhbiBoYXZlIG11bHRpcGxlIGNvbmRpdGlvbnMgb24gb25lIGF0dHJpYnV0ZSBsaWtlIGZvciBleGFtcGxlIG51bWVyaWNGaWx0ZXJzPXByaWNlPjEwMCxwcmljZTwxMDAwLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKGZvciBleGFtcGxlIG51bWVyaWNGaWx0ZXJzOiBbXCJwcmljZT4xMDBcIixcInByaWNlPDEwMDBcIl0pLlxuKiAtIHRhZ0ZpbHRlcnM6IGZpbHRlciB0aGUgcXVlcnkgYnkgYSBzZXQgb2YgdGFncy4gWW91IGNhbiBBTkQgdGFncyBieSBzZXBhcmF0aW5nIHRoZW0gYnkgY29tbWFzLlxuKiAgIFRvIE9SIHRhZ3MsIHlvdSBtdXN0IGFkZCBwYXJlbnRoZXNlcy4gRm9yIGV4YW1wbGUsIHRhZ3M9dGFnMSwodGFnMix0YWczKSBtZWFucyB0YWcxIEFORCAodGFnMiBPUiB0YWczKS5cbiogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5LCBmb3IgZXhhbXBsZSB0YWdGaWx0ZXJzOiBbXCJ0YWcxXCIsW1widGFnMlwiLFwidGFnM1wiXV1cbiogICBtZWFucyB0YWcxIEFORCAodGFnMiBPUiB0YWczKS5cbiogICBBdCBpbmRleGluZywgdGFncyBzaG91bGQgYmUgYWRkZWQgaW4gdGhlIF90YWdzKiogYXR0cmlidXRlXG4qICAgb2Ygb2JqZWN0cyAoZm9yIGV4YW1wbGUge1wiX3RhZ3NcIjpbXCJ0YWcxXCIsXCJ0YWcyXCJdfSkuXG4qIC0gZmFjZXRGaWx0ZXJzOiBmaWx0ZXIgdGhlIHF1ZXJ5IGJ5IGEgbGlzdCBvZiBmYWNldHMuXG4qICAgRmFjZXRzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzIGFuZCBlYWNoIGZhY2V0IGlzIGVuY29kZWQgYXMgYGF0dHJpYnV0ZU5hbWU6dmFsdWVgLlxuKiAgIEZvciBleGFtcGxlOiBgZmFjZXRGaWx0ZXJzPWNhdGVnb3J5OkJvb2ssYXV0aG9yOkpvaG4lMjBEb2VgLlxuKiAgIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKGZvciBleGFtcGxlIGBbXCJjYXRlZ29yeTpCb29rXCIsXCJhdXRob3I6Sm9obiUyMERvZVwiXWApLlxuKiAtIGZhY2V0czogTGlzdCBvZiBvYmplY3QgYXR0cmlidXRlcyB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgZmFjZXRpbmcuXG4qICAgQ29tbWEgc2VwYXJhdGVkIGxpc3Q6IGBcImNhdGVnb3J5LGF1dGhvclwiYCBvciBhcnJheSBgWydjYXRlZ29yeScsJ2F1dGhvciddYFxuKiAgIE9ubHkgYXR0cmlidXRlcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCBpbiAqKmF0dHJpYnV0ZXNGb3JGYWNldGluZyoqIGluZGV4IHNldHRpbmdcbiogICBjYW4gYmUgdXNlZCBpbiB0aGlzIHBhcmFtZXRlci5cbiogICBZb3UgY2FuIGFsc28gdXNlIGAqYCB0byBwZXJmb3JtIGZhY2V0aW5nIG9uIGFsbCBhdHRyaWJ1dGVzIHNwZWNpZmllZCBpbiAqKmF0dHJpYnV0ZXNGb3JGYWNldGluZyoqLlxuKiAtIHF1ZXJ5VHlwZTogc2VsZWN0IGhvdyB0aGUgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkLCBpdCBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWU6XG4qICAgIC0gcHJlZml4QWxsOiBhbGwgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkIGFzIHByZWZpeGVzLFxuKiAgICAtIHByZWZpeExhc3Q6IG9ubHkgdGhlIGxhc3Qgd29yZCBpcyBpbnRlcnByZXRlZCBhcyBhIHByZWZpeCAoZGVmYXVsdCBiZWhhdmlvciksXG4qICAgIC0gcHJlZml4Tm9uZTogbm8gcXVlcnkgd29yZCBpcyBpbnRlcnByZXRlZCBhcyBhIHByZWZpeC4gVGhpcyBvcHRpb24gaXMgbm90IHJlY29tbWVuZGVkLlxuKiAtIG9wdGlvbmFsV29yZHM6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2Ygd29yZHMgdGhhdCBzaG91bGRcbiogYmUgY29uc2lkZXJlZCBhcyBvcHRpb25hbCB3aGVuIGZvdW5kIGluIHRoZSBxdWVyeS5cbiogICBDb21tYSBzZXBhcmF0ZWQgYW5kIGFycmF5IGFyZSBhY2NlcHRlZC5cbiogLSBkaXN0aW5jdDogSWYgc2V0IHRvIDEsIGVuYWJsZSB0aGUgZGlzdGluY3QgZmVhdHVyZSAoZGlzYWJsZWQgYnkgZGVmYXVsdClcbiogaWYgdGhlIGF0dHJpYnV0ZUZvckRpc3RpbmN0IGluZGV4IHNldHRpbmcgaXMgc2V0LlxuKiAgIFRoaXMgZmVhdHVyZSBpcyBzaW1pbGFyIHRvIHRoZSBTUUwgXCJkaXN0aW5jdFwiIGtleXdvcmQ6IHdoZW4gZW5hYmxlZFxuKiAgIGluIGEgcXVlcnkgd2l0aCB0aGUgZGlzdGluY3Q9MSBwYXJhbWV0ZXIsXG4qICAgYWxsIGhpdHMgY29udGFpbmluZyBhIGR1cGxpY2F0ZSB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZUZvckRpc3RpbmN0IGF0dHJpYnV0ZSBhcmUgcmVtb3ZlZCBmcm9tIHJlc3VsdHMuXG4qICAgRm9yIGV4YW1wbGUsIGlmIHRoZSBjaG9zZW4gYXR0cmlidXRlIGlzIHNob3dfbmFtZSBhbmQgc2V2ZXJhbCBoaXRzIGhhdmVcbiogICB0aGUgc2FtZSB2YWx1ZSBmb3Igc2hvd19uYW1lLCB0aGVuIG9ubHkgdGhlIGJlc3RcbiogICBvbmUgaXMga2VwdCBhbmQgb3RoZXJzIGFyZSByZW1vdmVkLlxuKiAtIHJlc3RyaWN0U2VhcmNoYWJsZUF0dHJpYnV0ZXM6IExpc3Qgb2YgYXR0cmlidXRlcyB5b3Ugd2FudCB0byB1c2UgZm9yXG4qIHRleHR1YWwgc2VhcmNoIChtdXN0IGJlIGEgc3Vic2V0IG9mIHRoZSBhdHRyaWJ1dGVzVG9JbmRleCBpbmRleCBzZXR0aW5nKVxuKiBlaXRoZXIgY29tbWEgc2VwYXJhdGVkIG9yIGFzIGFuIGFycmF5XG4qIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKS4gSWYgZmFsc2UsIHRoZSBjb250ZW50IGNvbnRhaW5zIHRoZSBlcnJvci5cbiogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgcmVzdWx0cy5cbiovXG5JbmRleENvcmUucHJvdG90eXBlLnNlYXJjaCA9IGJ1aWxkU2VhcmNoTWV0aG9kKCdxdWVyeScpO1xuXG4vKlxuKiAtLSBCRVRBIC0tXG4qIFNlYXJjaCBhIHJlY29yZCBzaW1pbGFyIHRvIHRoZSBxdWVyeSBpbnNpZGUgdGhlIGluZGV4IHVzaW5nIFhNTEh0dHBSZXF1ZXN0IHJlcXVlc3QgKFVzaW5nIGEgUE9TVCBxdWVyeSB0b1xuKiBtaW5pbWl6ZSBudW1iZXIgb2YgT1BUSU9OUyBxdWVyaWVzOiBDcm9zcy1PcmlnaW4gUmVzb3VyY2UgU2hhcmluZykuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBbcXVlcnldIHRoZSBzaW1pbGFyIHF1ZXJ5XG4qIEBwYXJhbSB7b2JqZWN0fSBbYXJnc10gKG9wdGlvbmFsKSBpZiBzZXQsIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnMuXG4qICAgQWxsIHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBzdXBwb3J0ZWQgKHNlZSBzZWFyY2ggZnVuY3Rpb24pLCByZXN0cmljdFNlYXJjaGFibGVBdHRyaWJ1dGVzIGFuZCBmYWNldEZpbHRlcnNcbiogICBhcmUgdGhlIHR3byBtb3N0IHVzZWZ1bCB0byByZXN0cmljdCB0aGUgc2ltaWxhciByZXN1bHRzIGFuZCBnZXQgbW9yZSByZWxldmFudCBjb250ZW50XG4qL1xuSW5kZXhDb3JlLnByb3RvdHlwZS5zaW1pbGFyU2VhcmNoID0gYnVpbGRTZWFyY2hNZXRob2QoJ3NpbWlsYXJRdWVyeScpO1xuXG4vKlxuKiBCcm93c2UgaW5kZXggY29udGVudC4gVGhlIHJlc3BvbnNlIGNvbnRlbnQgd2lsbCBoYXZlIGEgYGN1cnNvcmAgcHJvcGVydHkgdGhhdCB5b3UgY2FuIHVzZVxuKiB0byBicm93c2Ugc3Vic2VxdWVudCBwYWdlcyBmb3IgdGhpcyBxdWVyeS4gVXNlIGBpbmRleC5icm93c2VGcm9tKGN1cnNvcilgIHdoZW4geW91IHdhbnQuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBmdWxsIHRleHQgcXVlcnlcbiogQHBhcmFtIHtPYmplY3R9IFtxdWVyeVBhcmFtZXRlcnNdIC0gQW55IHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBicm93c2UgcmVzdWx0XG4qIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuKiBAZXhhbXBsZVxuKiBpbmRleC5icm93c2UoJ2Nvb2wgc29uZ3MnLCB7XG4qICAgdGFnRmlsdGVyczogJ3B1YmxpYyxjb21tZW50cycsXG4qICAgaGl0c1BlclBhZ2U6IDUwMFxuKiB9LCBjYWxsYmFjayk7XG4qIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNCcm93c2V8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuYnJvd3NlID0gZnVuY3Rpb24ocXVlcnksIHF1ZXJ5UGFyYW1ldGVycywgY2FsbGJhY2spIHtcbiAgdmFyIG1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZS5qcycpO1xuXG4gIHZhciBpbmRleE9iaiA9IHRoaXM7XG5cbiAgdmFyIHBhZ2U7XG4gIHZhciBoaXRzUGVyUGFnZTtcblxuICAvLyB3ZSBjaGVjayB2YXJpYWRpYyBjYWxscyB0aGF0IGFyZSBub3QgdGhlIG9uZSBkZWZpbmVkXG4gIC8vIC5icm93c2UoKS8uYnJvd3NlKGZuKVxuICAvLyA9PiBwYWdlID0gMFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBwYWdlID0gMDtcbiAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIC8vIC5icm93c2UoMikvLmJyb3dzZSgyLCAxMCkvLmJyb3dzZSgyLCBmbikvLmJyb3dzZSgyLCAxMCwgZm4pXG4gICAgcGFnZSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGhpdHNQZXJQYWdlID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgICBoaXRzUGVyUGFnZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgcXVlcnlQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgLy8gLmJyb3dzZShxdWVyeVBhcmFtZXRlcnMpLy5icm93c2UocXVlcnlQYXJhbWV0ZXJzLCBjYilcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHF1ZXJ5UGFyYW1ldGVycyA9IGFyZ3VtZW50c1swXTtcbiAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLmJyb3dzZShxdWVyeSwgY2IpXG4gICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgcXVlcnlQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlIGl0J3MgYSAuYnJvd3NlKHF1ZXJ5KS8uYnJvd3NlKHF1ZXJ5LCBxdWVyeVBhcmFtZXRlcnMpLy5icm93c2UocXVlcnksIHF1ZXJ5UGFyYW1ldGVycywgY2IpXG5cbiAgLy8gZ2V0IHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJzIGNvbWJpbmluZyB2YXJpb3VzIHBvc3NpYmxlIGNhbGxzXG4gIC8vIHRvIC5icm93c2UoKTtcbiAgcXVlcnlQYXJhbWV0ZXJzID0gbWVyZ2Uoe30sIHF1ZXJ5UGFyYW1ldGVycyB8fCB7fSwge1xuICAgIHBhZ2U6IHBhZ2UsXG4gICAgaGl0c1BlclBhZ2U6IGhpdHNQZXJQYWdlLFxuICAgIHF1ZXJ5OiBxdWVyeVxuICB9KTtcblxuICB2YXIgcGFyYW1zID0gdGhpcy5hcy5fZ2V0U2VhcmNoUGFyYW1zKHF1ZXJ5UGFyYW1ldGVycywgJycpO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2Jyb3dzZScsXG4gICAgYm9keToge3BhcmFtczogcGFyYW1zfSxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIENvbnRpbnVlIGJyb3dzaW5nIGZyb20gYSBwcmV2aW91cyBwb3NpdGlvbiAoY3Vyc29yKSwgb2J0YWluZWQgdmlhIGEgY2FsbCB0byBgLmJyb3dzZSgpYC5cbipcbiogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGZ1bGwgdGV4dCBxdWVyeVxuKiBAcGFyYW0ge09iamVjdH0gW3F1ZXJ5UGFyYW1ldGVyc10gLSBBbnkgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlclxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4qICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdGhlIGJyb3dzZSByZXN1bHRcbiogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4qIEBleGFtcGxlXG4qIGluZGV4LmJyb3dzZUZyb20oJzE0bGtmc2FrbDMyJywgY2FsbGJhY2spO1xuKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiovXG5JbmRleENvcmUucHJvdG90eXBlLmJyb3dzZUZyb20gPSBmdW5jdGlvbihjdXJzb3IsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSArICcvYnJvd3NlJyxcbiAgICBib2R5OiB7Y3Vyc29yOiBjdXJzb3J9LFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLypcbiogU2VhcmNoIGZvciBmYWNldCB2YWx1ZXNcbiogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3QtYXBpL3NlYXJjaCNzZWFyY2gtZm9yLWZhY2V0LXZhbHVlc1xuKlxuKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZhY2V0TmFtZSBGYWNldCBuYW1lLCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gc2VhcmNoIGZvciB2YWx1ZXMgaW4uXG4qIE11c3QgYmUgZGVjbGFyZWQgYXMgYSBmYWNldFxuKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZhY2V0UXVlcnkgUXVlcnkgZm9yIHRoZSBmYWNldCBzZWFyY2hcbiogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuKl0gQW55IHNlYXJjaCBwYXJhbWV0ZXIgb2YgQWxnb2xpYSxcbiogc2VlIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9hcGktY2xpZW50L2phdmFzY3JpcHQvc2VhcmNoI3NlYXJjaC1wYXJhbWV0ZXJzXG4qIFBhZ2luYXRpb24gaXMgbm90IHN1cHBvcnRlZC4gVGhlIHBhZ2UgYW5kIGhpdHNQZXJQYWdlIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKVxuKi9cbkluZGV4Q29yZS5wcm90b3R5cGUuc2VhcmNoRm9yRmFjZXRWYWx1ZXMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKTtcbiAgdmFyIG9taXQgPSByZXF1aXJlKCcuL29taXQuanMnKTtcbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5zZWFyY2hGb3JGYWNldFZhbHVlcyh7ZmFjZXROYW1lLCBmYWNldFF1ZXJ5LCAuLi5wYXJhbXN9WywgY2FsbGJhY2tdKSc7XG5cbiAgaWYgKHBhcmFtcy5mYWNldE5hbWUgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMuZmFjZXRRdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgfVxuXG4gIHZhciBmYWNldE5hbWUgPSBwYXJhbXMuZmFjZXROYW1lO1xuICB2YXIgZmlsdGVyZWRQYXJhbXMgPSBvbWl0KGNsb25lKHBhcmFtcyksIGZ1bmN0aW9uKGtleU5hbWUpIHtcbiAgICByZXR1cm4ga2V5TmFtZSA9PT0gJ2ZhY2V0TmFtZSc7XG4gIH0pO1xuICB2YXIgc2VhcmNoUGFyYW1ldGVycyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhmaWx0ZXJlZFBhcmFtcywgJycpO1xuXG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiAnLzEvaW5kZXhlcy8nICtcbiAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL2ZhY2V0cy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGZhY2V0TmFtZSkgKyAnL3F1ZXJ5JyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGJvZHk6IHtwYXJhbXM6IHNlYXJjaFBhcmFtZXRlcnN9LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbkluZGV4Q29yZS5wcm90b3R5cGUuc2VhcmNoRmFjZXQgPSBkZXByZWNhdGUoZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5zZWFyY2hGb3JGYWNldFZhbHVlcyhwYXJhbXMsIGNhbGxiYWNrKTtcbn0sIGRlcHJlY2F0ZWRNZXNzYWdlKFxuICAnaW5kZXguc2VhcmNoRmFjZXQocGFyYW1zWywgY2FsbGJhY2tdKScsXG4gICdpbmRleC5zZWFyY2hGb3JGYWNldFZhbHVlcyhwYXJhbXNbLCBjYWxsYmFja10pJ1xuKSk7XG5cbkluZGV4Q29yZS5wcm90b3R5cGUuX3NlYXJjaCA9IGZ1bmN0aW9uKHBhcmFtcywgdXJsLCBjYWxsYmFjaywgYWRkaXRpb25hbFVBKSB7XG4gIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgY2FjaGU6IHRoaXMuY2FjaGUsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiB1cmwgfHwgJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL3F1ZXJ5JyxcbiAgICBib2R5OiB7cGFyYW1zOiBwYXJhbXN9LFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgZmFsbGJhY2s6IHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpLFxuICAgICAgYm9keToge3BhcmFtczogcGFyYW1zfVxuICAgIH0sXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIGFkZGl0aW9uYWxVQTogYWRkaXRpb25hbFVBXG4gIH0pO1xufTtcblxuLypcbiogR2V0IGFuIG9iamVjdCBmcm9tIHRoaXMgaW5kZXhcbipcbiogQHBhcmFtIG9iamVjdElEIHRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgb2JqZWN0IHRvIHJldHJpZXZlXG4qIEBwYXJhbSBhdHRycyAob3B0aW9uYWwpIGlmIHNldCwgY29udGFpbnMgdGhlIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byByZXRyaWV2ZVxuKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiogIGNvbnRlbnQ6IHRoZSBvYmplY3QgdG8gcmV0cmlldmUgb3IgdGhlIGVycm9yIG1lc3NhZ2UgaWYgYSBmYWlsdXJlIG9jY3VyZWRcbiovXG5JbmRleENvcmUucHJvdG90eXBlLmdldE9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdElELCBhdHRycywgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgYXR0cnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGF0dHJzO1xuICAgIGF0dHJzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHBhcmFtcyA9ICcnO1xuICBpZiAoYXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcyA9ICc/YXR0cmlidXRlcz0nO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHBhcmFtcyArPSAnLCc7XG4gICAgICB9XG4gICAgICBwYXJhbXMgKz0gYXR0cnNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSArIHBhcmFtcyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qXG4qIEdldCBzZXZlcmFsIG9iamVjdHMgZnJvbSB0aGlzIGluZGV4XG4qXG4qIEBwYXJhbSBvYmplY3RJRHMgdGhlIGFycmF5IG9mIHVuaXF1ZSBpZGVudGlmaWVyIG9mIG9iamVjdHMgdG8gcmV0cmlldmVcbiovXG5JbmRleENvcmUucHJvdG90eXBlLmdldE9iamVjdHMgPSBmdW5jdGlvbihvYmplY3RJRHMsIGF0dHJpYnV0ZXNUb1JldHJpZXZlLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwLmpzJyk7XG5cbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBpbmRleC5nZXRPYmplY3RzKGFycmF5T2ZPYmplY3RJRHNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkob2JqZWN0SURzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gIH1cblxuICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYXR0cmlidXRlc1RvUmV0cmlldmU7XG4gICAgYXR0cmlidXRlc1RvUmV0cmlldmUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgYm9keSA9IHtcbiAgICByZXF1ZXN0czogbWFwKG9iamVjdElEcywgZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3Qob2JqZWN0SUQpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICBpbmRleE5hbWU6IGluZGV4T2JqLmluZGV4TmFtZSxcbiAgICAgICAgb2JqZWN0SUQ6IG9iamVjdElEXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXR0cmlidXRlc1RvUmV0cmlldmUpIHtcbiAgICAgICAgcmVxdWVzdC5hdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9IGF0dHJpYnV0ZXNUb1JldHJpZXZlLmpvaW4oJywnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSlcbiAgfTtcblxuICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy8xL2luZGV4ZXMvKi9vYmplY3RzJyxcbiAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgIGJvZHk6IGJvZHksXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuSW5kZXhDb3JlLnByb3RvdHlwZS5hcyA9IG51bGw7XG5JbmRleENvcmUucHJvdG90eXBlLmluZGV4TmFtZSA9IG51bGw7XG5JbmRleENvcmUucHJvdG90eXBlLnR5cGVBaGVhZEFyZ3MgPSBudWxsO1xuSW5kZXhDb3JlLnByb3RvdHlwZS50eXBlQWhlYWRWYWx1ZU9wdGlvbiA9IG51bGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0luZGV4Q29yZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gYnVpbGRTZWFyY2hNZXRob2Q7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycy5qcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZWFyY2ggbWV0aG9kIHRvIGJlIHVzZWQgaW4gY2xpZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5UGFyYW0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciB0aGUgcXVlcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdGhlIHVybFxuICogQHJldHVybiB7ZnVuY3Rpb259IHRoZSBzZWFyY2ggbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU2VhcmNoTWV0aG9kKHF1ZXJ5UGFyYW0sIHVybCkge1xuICAvKipcbiAgICogVGhlIHNlYXJjaCBtZXRob2QuIFByZXBhcmVzIHRoZSBkYXRhIGFuZCBzZW5kIHRoZSBxdWVyeSB0byBBbGdvbGlhLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIHN0cmluZyB1c2VkIGZvciBxdWVyeSBzZWFyY2hcbiAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHNlbmQgd2l0aCB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjbGllbnQgZ2V0cyB0aGUgYW5zd2VyXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZHxQcm9taXNlfSBJZiB0aGUgY2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkIHRoZW4gdGhpcyBtZXRob2RzIHJldHVybnMgYSBQcm9taXNlXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoKHF1ZXJ5LCBhcmdzLCBjYWxsYmFjaykge1xuICAgIC8vIHdhcm4gVjIgdXNlcnMgb24gaG93IHRvIHNlYXJjaFxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnIHx8XG4gICAgICB0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyAuc2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIGNiKVxuICAgICAgLy8gLnNlYXJjaChjYiwgcGFyYW1zKVxuICAgICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ2luZGV4LnNlYXJjaCB1c2FnZSBpcyBpbmRleC5zZWFyY2gocXVlcnksIHBhcmFtcywgY2IpJyk7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXppbmcgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBxdWVyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVXNhZ2UgOiAuc2VhcmNoKCksIC5zZWFyY2goY2IpXG4gICAgICBjYWxsYmFjayA9IHF1ZXJ5O1xuICAgICAgcXVlcnkgPSAnJztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGFyZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFVzYWdlIDogLnNlYXJjaChxdWVyeS9hcmdzKSwgLnNlYXJjaChxdWVyeSwgY2IpXG4gICAgICBjYWxsYmFjayA9IGFyZ3M7XG4gICAgICBhcmdzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgMyBhcmd1bWVudHMgd2l0aCB2YWx1ZXNcblxuICAgIC8vIFVzYWdlIDogLnNlYXJjaChhcmdzKSAvLyBjYXJlZnVsOiB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAhPT0gbnVsbCkge1xuICAgICAgYXJncyA9IHF1ZXJ5O1xuICAgICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkIHx8IHF1ZXJ5ID09PSBudWxsKSB7IC8vIC5zZWFyY2godW5kZWZpbmVkL251bGwpXG4gICAgICBxdWVyeSA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSAnJztcblxuICAgIGlmIChxdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbXMgKz0gcXVlcnlQYXJhbSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSk7XG4gICAgfVxuXG4gICAgdmFyIGFkZGl0aW9uYWxVQTtcbiAgICBpZiAoYXJncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYXJncy5hZGRpdGlvbmFsVUEpIHtcbiAgICAgICAgYWRkaXRpb25hbFVBID0gYXJncy5hZGRpdGlvbmFsVUE7XG4gICAgICAgIGRlbGV0ZSBhcmdzLmFkZGl0aW9uYWxVQTtcbiAgICAgIH1cbiAgICAgIC8vIGBfZ2V0U2VhcmNoUGFyYW1zYCB3aWxsIGF1Z21lbnQgcGFyYW1zLCBkbyBub3QgYmUgZm9vbGVkIGJ5IHRoZSA9IHZlcnN1cyArPSBmcm9tIHByZXZpb3VzIGlmXG4gICAgICBwYXJhbXMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMoYXJncywgcGFyYW1zKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB0aGlzLl9zZWFyY2gocGFyYW1zLCB1cmwsIGNhbGxiYWNrLCBhZGRpdGlvbmFsVUEpO1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9idWlsZFNlYXJjaE1ldGhvZC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGhvc3RzIG91ciBlcnJvciBkZWZpbml0aW9uc1xuLy8gV2UgdXNlIGN1c3RvbSBlcnJvciBcInR5cGVzXCIgc28gdGhhdCB3ZSBjYW4gYWN0IG9uIHRoZW0gd2hlbiB3ZSBuZWVkIGl0XG4vLyBlLmcuOiBpZiBlcnJvciBpbnN0YW5jZW9mIGVycm9ycy5VbnBhcnNhYmxlSlNPTiB0aGVuLi5cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gQWxnb2xpYVNlYXJjaEVycm9yKG1lc3NhZ2UsIGV4dHJhUHJvcGVydGllcykge1xuICB2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcblxuICB2YXIgZXJyb3IgPSB0aGlzO1xuXG4gIC8vIHRyeSB0byBnZXQgYSBzdGFja3RyYWNlXG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2sgfHwgJ0Nhbm5vdCBnZXQgYSBzdGFja3RyYWNlLCBicm93c2VyIGlzIHRvbyBvbGQnO1xuICB9XG5cbiAgdGhpcy5uYW1lID0gJ0FsZ29saWFTZWFyY2hFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuXG4gIGlmIChleHRyYVByb3BlcnRpZXMpIHtcbiAgICBmb3JFYWNoKGV4dHJhUHJvcGVydGllcywgZnVuY3Rpb24gYWRkVG9FcnJvck9iamVjdCh2YWx1ZSwga2V5KSB7XG4gICAgICBlcnJvcltrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cbn1cblxuaW5oZXJpdHMoQWxnb2xpYVNlYXJjaEVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUVycm9yKG5hbWUsIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gQWxnb2xpYVNlYXJjaEN1c3RvbUVycm9yKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIC8vIGN1c3RvbSBtZXNzYWdlIG5vdCBzZXQsIHVzZSBkZWZhdWx0XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgYXJncy51bnNoaWZ0KG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIEFsZ29saWFTZWFyY2hFcnJvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB0aGlzLm5hbWUgPSAnQWxnb2xpYVNlYXJjaCcgKyBuYW1lICsgJ0Vycm9yJztcbiAgfVxuXG4gIGluaGVyaXRzKEFsZ29saWFTZWFyY2hDdXN0b21FcnJvciwgQWxnb2xpYVNlYXJjaEVycm9yKTtcblxuICByZXR1cm4gQWxnb2xpYVNlYXJjaEN1c3RvbUVycm9yO1xufVxuXG4vLyBsYXRlIGV4cG9ydHMgdG8gbGV0IHZhcmlvdXMgZm4gZGVmcyBhbmQgaW5oZXJpdHMgdGFrZSBwbGFjZVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFsZ29saWFTZWFyY2hFcnJvcjogQWxnb2xpYVNlYXJjaEVycm9yLFxuICBVbnBhcnNhYmxlSlNPTjogY3JlYXRlQ3VzdG9tRXJyb3IoXG4gICAgJ1VucGFyc2FibGVKU09OJyxcbiAgICAnQ291bGQgbm90IHBhcnNlIHRoZSBpbmNvbWluZyByZXNwb25zZSBhcyBKU09OLCBzZWUgZXJyLm1vcmUgZm9yIGRldGFpbHMnXG4gICksXG4gIFJlcXVlc3RUaW1lb3V0OiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnUmVxdWVzdFRpbWVvdXQnLFxuICAgICdSZXF1ZXN0IHRpbWVkb3V0IGJlZm9yZSBnZXR0aW5nIGEgcmVzcG9uc2UnXG4gICksXG4gIE5ldHdvcms6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdOZXR3b3JrJyxcbiAgICAnTmV0d29yayBpc3N1ZSwgc2VlIGVyci5tb3JlIGZvciBkZXRhaWxzJ1xuICApLFxuICBKU09OUFNjcmlwdEZhaWw6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICdKU09OUFNjcmlwdEZhaWwnLFxuICAgICc8c2NyaXB0PiB3YXMgbG9hZGVkIGJ1dCBkaWQgbm90IGNhbGwgb3VyIHByb3ZpZGVkIGNhbGxiYWNrJ1xuICApLFxuICBKU09OUFNjcmlwdEVycm9yOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnSlNPTlBTY3JpcHRFcnJvcicsXG4gICAgJzxzY3JpcHQ+IHVuYWJsZSB0byBsb2FkIGR1ZSB0byBhbiBgZXJyb3JgIGV2ZW50IG9uIGl0J1xuICApLFxuICBVbmtub3duOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAnVW5rbm93bicsXG4gICAgJ1Vua25vd24gZXJyb3Igb2NjdXJlZCdcbiAgKVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvZXJyb3JzLmpzIiwiXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAob2JqLCBmbiwgY3R4KSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgbCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGwgPT09ICtsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZm9yZWFjaC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtZXNzYWdlKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICAvKiBlc2xpbnQgbm8tY29uc29sZTowICovXG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9kZXByZWNhdGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlcHJlY2F0ZWRNZXNzYWdlKHByZXZpb3VzVXNhZ2UsIG5ld1VzYWdlKSB7XG4gIHZhciBnaXRodWJBbmNob3JMaW5rID0gcHJldmlvdXNVc2FnZS50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL1tcXC5cXChcXCldL2csICcnKTtcblxuICByZXR1cm4gJ2FsZ29saWFzZWFyY2g6IGAnICsgcHJldmlvdXNVc2FnZSArICdgIHdhcyByZXBsYWNlZCBieSBgJyArIG5ld1VzYWdlICtcbiAgICAnYC4gUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9hbGdvbGlhc2VhcmNoLWNsaWVudC1qYXZhc2NyaXB0L3dpa2kvRGVwcmVjYXRlZCMnICsgZ2l0aHViQW5jaG9yTGluaztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2RlcHJlY2F0ZWRNZXNzYWdlLmpzIiwidmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2UoZGVzdGluYXRpb24vKiAsIHNvdXJjZXMgKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGZvcmVhY2goc291cmNlcywgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgZm9yICh2YXIga2V5TmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5TmFtZSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltrZXlOYW1lXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNvdXJjZVtrZXlOYW1lXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltrZXlOYW1lXSA9IG1lcmdlKHt9LCBkZXN0aW5hdGlvbltrZXlOYW1lXSwgc291cmNlW2tleU5hbWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Vba2V5TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW2tleU5hbWVdID0gc291cmNlW2tleU5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGVzdGluYXRpb247XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9tZXJnZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvY2xvbmUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG9taXQob2JqLCB0ZXN0KSB7XG4gIHZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbiAgdmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbiAgdmFyIGZpbHRlcmVkID0ge307XG5cbiAgZm9yZWFjaChrZXlzKG9iaiksIGZ1bmN0aW9uIGRvRmlsdGVyKGtleU5hbWUpIHtcbiAgICBpZiAodGVzdChrZXlOYW1lKSAhPT0gdHJ1ZSkge1xuICAgICAgZmlsdGVyZWRba2V5TmFtZV0gPSBvYmpba2V5TmFtZV07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9vbWl0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG52YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcbnZhciBkb250RW51bXMgPSBbXG5cdCd0b1N0cmluZycsXG5cdCd0b0xvY2FsZVN0cmluZycsXG5cdCd2YWx1ZU9mJyxcblx0J2hhc093blByb3BlcnR5Jyxcblx0J2lzUHJvdG90eXBlT2YnLFxuXHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHQnY29uc3RydWN0b3InXG5dO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbn07XG52YXIgZXhjbHVkZWRLZXlzID0ge1xuXHQkY29uc29sZTogdHJ1ZSxcblx0JGV4dGVybmFsOiB0cnVlLFxuXHQkZnJhbWU6IHRydWUsXG5cdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdCRmcmFtZXM6IHRydWUsXG5cdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0JGlubmVyV2lkdGg6IHRydWUsXG5cdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0JG91dGVyV2lkdGg6IHRydWUsXG5cdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHQkcGFyZW50OiB0cnVlLFxuXHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0JHNjcm9sbFg6IHRydWUsXG5cdCRzY3JvbGxZOiB0cnVlLFxuXHQkc2VsZjogdHJ1ZSxcblx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHQkd2luZG93OiB0cnVlXG59O1xudmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59KCkpO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHR9XG5cblx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGVLZXlzO1xufTtcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0cmV0dXJuIChPYmplY3Qua2V5cyhhcmd1bWVudHMpIHx8ICcnKS5sZW5ndGggPT09IDI7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9+L29iamVjdC1rZXlzL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvfi9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL34vaXNhcnJheS9pbmRleC5qcyIsInZhciBmb3JlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gIHZhciBuZXdBcnIgPSBbXTtcbiAgZm9yZWFjaChhcnIsIGZ1bmN0aW9uKGl0ZW0sIGl0ZW1JbmRleCkge1xuICAgIG5ld0Fyci5wdXNoKGZuKGl0ZW0sIGl0ZW1JbmRleCwgYXJyKSk7XG4gIH0pO1xuICByZXR1cm4gbmV3QXJyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvbWFwLmpzIiwiLy8gUGFyc2UgY2xvdWQgZG9lcyBub3Qgc3VwcG9ydHMgc2V0VGltZW91dFxuLy8gV2UgZG8gbm90IHN0b3JlIGEgc2V0VGltZW91dCByZWZlcmVuY2UgaW4gdGhlIGNsaWVudCBldmVyeXRpbWVcbi8vIFdlIG9ubHkgZmFsbGJhY2sgdG8gYSBmYWtlIHNldFRpbWVvdXQgd2hlbiBub3QgYXZhaWxhYmxlXG4vLyBzZXRUaW1lb3V0IGNhbm5vdCBiZSBvdmVycmlkZSBnbG9iYWxseSBzYWRseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGl0UHJvbWlzZShmbiwgX3NldFRpbWVvdXQpIHtcbiAgX3NldFRpbWVvdXQoZm4sIDApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvZXhpdFByb21pc2UuanMiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgaXMgdGhlIG9iamVjdCByZXR1cm5lZCBieSB0aGUgYGluZGV4LmJyb3dzZUFsbCgpYCBtZXRob2RcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleEJyb3dzZXI7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5mdW5jdGlvbiBJbmRleEJyb3dzZXIoKSB7XG59XG5cbmluaGVyaXRzKEluZGV4QnJvd3NlciwgRXZlbnRFbWl0dGVyKTtcblxuSW5kZXhCcm93c2VyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICB0aGlzLl9jbGVhbigpO1xufTtcblxuSW5kZXhCcm93c2VyLnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZW5kJyk7XG4gIHRoaXMuX2NsZWFuKCk7XG59O1xuXG5JbmRleEJyb3dzZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5fY2xlYW4oKTtcbn07XG5cbkluZGV4QnJvd3Nlci5wcm90b3R5cGUuX3Jlc3VsdCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgdGhpcy5lbWl0KCdyZXN1bHQnLCBjb250ZW50KTtcbn07XG5cbkluZGV4QnJvd3Nlci5wcm90b3R5cGUuX2NsZWFuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdzdG9wJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZXN1bHQnKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL0luZGV4QnJvd3Nlci5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZXZlbnRzL2V2ZW50cy5qcyIsIm1vZHVsZS5leHBvcnRzID0gQWxnb2xpYVNlYXJjaENvcmU7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGV4aXRQcm9taXNlID0gcmVxdWlyZSgnLi9leGl0UHJvbWlzZS5qcycpO1xudmFyIEluZGV4Q29yZSA9IHJlcXVpcmUoJy4vSW5kZXhDb3JlLmpzJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuL3N0b3JlLmpzJyk7XG5cbi8vIFdlIHdpbGwgYWx3YXlzIHB1dCB0aGUgQVBJIEtFWSBpbiB0aGUgSlNPTiBib2R5IGluIGNhc2Ugb2YgdG9vIGxvbmcgQVBJIEtFWSxcbi8vIHRvIGF2b2lkIHF1ZXJ5IHN0cmluZyBiZWluZyB0b28gbG9uZyBhbmQgZmFpbGluZyBpbiB2YXJpb3VzIGNvbmRpdGlvbnMgKG91ciBzZXJ2ZXIgbGltaXQsIGJyb3dzZXIgbGltaXQsXG4vLyBwcm94aWVzIGxpbWl0KVxudmFyIE1BWF9BUElfS0VZX0xFTkdUSCA9IDUwMDtcbnZhciBSRVNFVF9BUFBfREFUQV9USU1FUiA9XG4gIHByb2Nlc3MuZW52LlJFU0VUX0FQUF9EQVRBX1RJTUVSICYmIHBhcnNlSW50KHByb2Nlc3MuZW52LlJFU0VUX0FQUF9EQVRBX1RJTUVSLCAxMCkgfHxcbiAgNjAgKiAyICogMTAwMDsgLy8gYWZ0ZXIgMiBtaW51dGVzIHJlc2V0IHRvIGZpcnN0IGhvc3RcblxuLypcbiAqIEFsZ29saWEgU2VhcmNoIGxpYnJhcnkgaW5pdGlhbGl6YXRpb25cbiAqIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBsaWNhdGlvbklEIC0gWW91ciBhcHBsaWNhdGlvbklELCBmb3VuZCBpbiB5b3VyIGRhc2hib2FyZFxuICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleSAtIFlvdXIgQVBJIGtleSwgZm91bmQgaW4geW91ciBkYXNoYm9hcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0PTIwMDBdIC0gVGhlIHJlcXVlc3QgdGltZW91dCBzZXQgaW4gbWlsbGlzZWNvbmRzLFxuICogYW5vdGhlciByZXF1ZXN0IHdpbGwgYmUgaXNzdWVkIGFmdGVyIHRoaXMgdGltZW91dFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByb3RvY29sPSdodHRwOiddIC0gVGhlIHByb3RvY29sIHVzZWQgdG8gcXVlcnkgQWxnb2xpYSBTZWFyY2ggQVBJLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0IHRvICdodHRwczonIHRvIGZvcmNlIHVzaW5nIGh0dHBzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0byBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCBpbiBicm93c2Vyc1xuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IFtvcHRzLmhvc3RzPXtcbiAqICAgICAgICAgICByZWFkOiBbdGhpcy5hcHBsaWNhdGlvbklEICsgJy1kc24uYWxnb2xpYS5uZXQnXS5jb25jYXQoW1xuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0xLmFsZ29saWFuZXQuY29tJyxcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMi5hbGdvbGlhbmV0LmNvbScsXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTMuYWxnb2xpYW5ldC5jb20nXVxuICogICAgICAgICAgIF0pLFxuICogICAgICAgICAgIHdyaXRlOiBbdGhpcy5hcHBsaWNhdGlvbklEICsgJy5hbGdvbGlhLm5ldCddLmNvbmNhdChbXG4gKiAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTEuYWxnb2xpYW5ldC5jb20nLFxuICogICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0yLmFsZ29saWFuZXQuY29tJyxcbiAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMy5hbGdvbGlhbmV0LmNvbSddXG4gKiAgICAgICAgICAgXSkgLSBUaGUgaG9zdHMgdG8gdXNlIGZvciBBbGdvbGlhIFNlYXJjaCBBUEkuXG4gKiAgICAgICAgICAgSWYgeW91IHByb3ZpZGUgdGhlbSwgeW91IHdpbGwgbGVzcyBiZW5lZml0IGZyb20gb3VyIEhBIGltcGxlbWVudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIEFsZ29saWFTZWFyY2hDb3JlKGFwcGxpY2F0aW9uSUQsIGFwaUtleSwgb3B0cykge1xuICB2YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdhbGdvbGlhc2VhcmNoJyk7XG5cbiAgdmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpO1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbiAgdmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwLmpzJyk7XG5cbiAgdmFyIHVzYWdlID0gJ1VzYWdlOiBhbGdvbGlhc2VhcmNoKGFwcGxpY2F0aW9uSUQsIGFwaUtleSwgb3B0cyknO1xuXG4gIGlmIChvcHRzLl9hbGxvd0VtcHR5Q3JlZGVudGlhbHMgIT09IHRydWUgJiYgIWFwcGxpY2F0aW9uSUQpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcignUGxlYXNlIHByb3ZpZGUgYW4gYXBwbGljYXRpb24gSUQuICcgKyB1c2FnZSk7XG4gIH1cblxuICBpZiAob3B0cy5fYWxsb3dFbXB0eUNyZWRlbnRpYWxzICE9PSB0cnVlICYmICFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcignUGxlYXNlIHByb3ZpZGUgYW4gQVBJIGtleS4gJyArIHVzYWdlKTtcbiAgfVxuXG4gIHRoaXMuYXBwbGljYXRpb25JRCA9IGFwcGxpY2F0aW9uSUQ7XG4gIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuXG4gIHRoaXMuaG9zdHMgPSB7XG4gICAgcmVhZDogW10sXG4gICAgd3JpdGU6IFtdXG4gIH07XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHByb3RvY29sID0gb3B0cy5wcm90b2NvbCB8fCAnaHR0cHM6JztcbiAgdGhpcy5fdGltZW91dHMgPSBvcHRzLnRpbWVvdXRzIHx8IHtcbiAgICBjb25uZWN0OiAxICogMTAwMCwgLy8gNTAwbXMgY29ubmVjdCBpcyBHUFJTIGxhdGVuY3lcbiAgICByZWFkOiAyICogMTAwMCxcbiAgICB3cml0ZTogMzAgKiAxMDAwXG4gIH07XG5cbiAgLy8gYmFja3dhcmQgY29tcGF0LCBpZiBvcHRzLnRpbWVvdXQgaXMgcGFzc2VkLCB3ZSB1c2UgaXQgdG8gY29uZmlndXJlIGFsbCB0aW1lb3V0cyBsaWtlIGJlZm9yZVxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgdGhpcy5fdGltZW91dHMuY29ubmVjdCA9IHRoaXMuX3RpbWVvdXRzLnJlYWQgPSB0aGlzLl90aW1lb3V0cy53cml0ZSA9IG9wdHMudGltZW91dDtcbiAgfVxuXG4gIC8vIHdoaWxlIHdlIGFkdm9jYXRlIGZvciBjb2xvbi1hdC10aGUtZW5kIHZhbHVlczogJ2h0dHA6JyBmb3IgYG9wdHMucHJvdG9jb2xgXG4gIC8vIHdlIGFsc28gYWNjZXB0IGBodHRwYCBhbmQgYGh0dHBzYC4gSXQncyBhIGNvbW1vbiBlcnJvci5cbiAgaWYgKCEvOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgcHJvdG9jb2wgPSBwcm90b2NvbCArICc6JztcbiAgfVxuXG4gIGlmIChvcHRzLnByb3RvY29sICE9PSAnaHR0cDonICYmIG9wdHMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ3Byb3RvY29sIG11c3QgYmUgYGh0dHA6YCBvciBgaHR0cHM6YCAod2FzIGAnICsgb3B0cy5wcm90b2NvbCArICdgKScpO1xuICB9XG5cbiAgdGhpcy5fY2hlY2tBcHBJZERhdGEoKTtcblxuICBpZiAoIW9wdHMuaG9zdHMpIHtcbiAgICB2YXIgZGVmYXVsdEhvc3RzID0gbWFwKHRoaXMuX3NodWZmbGVSZXN1bHQsIGZ1bmN0aW9uKGhvc3ROdW1iZXIpIHtcbiAgICAgIHJldHVybiBhcHBsaWNhdGlvbklEICsgJy0nICsgaG9zdE51bWJlciArICcuYWxnb2xpYW5ldC5jb20nO1xuICAgIH0pO1xuXG4gICAgLy8gbm8gaG9zdHMgZ2l2ZW4sIGNvbXB1dGUgZGVmYXVsdHNcbiAgICB0aGlzLmhvc3RzLnJlYWQgPSBbdGhpcy5hcHBsaWNhdGlvbklEICsgJy1kc24uYWxnb2xpYS5uZXQnXS5jb25jYXQoZGVmYXVsdEhvc3RzKTtcbiAgICB0aGlzLmhvc3RzLndyaXRlID0gW3RoaXMuYXBwbGljYXRpb25JRCArICcuYWxnb2xpYS5uZXQnXS5jb25jYXQoZGVmYXVsdEhvc3RzKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KG9wdHMuaG9zdHMpKSB7XG4gICAgLy8gd2hlbiBwYXNzaW5nIGN1c3RvbSBob3N0cywgd2UgbmVlZCB0byBoYXZlIGEgZGlmZmVyZW50IGhvc3QgaW5kZXggaWYgdGhlIG51bWJlclxuICAgIC8vIG9mIHdyaXRlL3JlYWQgaG9zdHMgYXJlIGRpZmZlcmVudC5cbiAgICB0aGlzLmhvc3RzLnJlYWQgPSBjbG9uZShvcHRzLmhvc3RzKTtcbiAgICB0aGlzLmhvc3RzLndyaXRlID0gY2xvbmUob3B0cy5ob3N0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ob3N0cy5yZWFkID0gY2xvbmUob3B0cy5ob3N0cy5yZWFkKTtcbiAgICB0aGlzLmhvc3RzLndyaXRlID0gY2xvbmUob3B0cy5ob3N0cy53cml0ZSk7XG4gIH1cblxuICAvLyBhZGQgcHJvdG9jb2wgYW5kIGxvd2VyY2FzZSBob3N0c1xuICB0aGlzLmhvc3RzLnJlYWQgPSBtYXAodGhpcy5ob3N0cy5yZWFkLCBwcmVwYXJlSG9zdChwcm90b2NvbCkpO1xuICB0aGlzLmhvc3RzLndyaXRlID0gbWFwKHRoaXMuaG9zdHMud3JpdGUsIHByZXBhcmVIb3N0KHByb3RvY29sKSk7XG5cbiAgdGhpcy5leHRyYUhlYWRlcnMgPSB7fTtcblxuICAvLyBJbiBzb21lIHNpdHVhdGlvbnMgeW91IG1pZ2h0IHdhbnQgdG8gd2FybSB0aGUgY2FjaGVcbiAgdGhpcy5jYWNoZSA9IG9wdHMuX2NhY2hlIHx8IHt9O1xuXG4gIHRoaXMuX3VhID0gb3B0cy5fdWE7XG4gIHRoaXMuX3VzZUNhY2hlID0gb3B0cy5fdXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRzLl9jYWNoZSA/IHRydWUgOiBvcHRzLl91c2VDYWNoZTtcbiAgdGhpcy5fdXNlRmFsbGJhY2sgPSBvcHRzLnVzZUZhbGxiYWNrID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy51c2VGYWxsYmFjaztcblxuICB0aGlzLl9zZXRUaW1lb3V0ID0gb3B0cy5fc2V0VGltZW91dDtcblxuICBkZWJ1ZygnaW5pdCBkb25lLCAlaicsIHRoaXMpO1xufVxuXG4vKlxuICogR2V0IHRoZSBpbmRleCBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqXG4gKiBAcGFyYW0gaW5kZXhOYW1lIHRoZSBuYW1lIG9mIGluZGV4XG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayB3aXRoIG9uZSBhcmd1bWVudCAodGhlIEluZGV4IGluc3RhbmNlKVxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuaW5pdEluZGV4ID0gZnVuY3Rpb24oaW5kZXhOYW1lKSB7XG4gIHJldHVybiBuZXcgSW5kZXhDb3JlKHRoaXMsIGluZGV4TmFtZSk7XG59O1xuXG4vKipcbiogQWRkIGFuIGV4dHJhIGZpZWxkIHRvIHRoZSBIVFRQIHJlcXVlc3RcbipcbiogQHBhcmFtIG5hbWUgdGhlIGhlYWRlciBmaWVsZCBuYW1lXG4qIEBwYXJhbSB2YWx1ZSB0aGUgaGVhZGVyIGZpZWxkIHZhbHVlXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldEV4dHJhSGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5leHRyYUhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xufTtcblxuLyoqXG4qIEdldCB0aGUgdmFsdWUgb2YgYW4gZXh0cmEgSFRUUCBoZWFkZXJcbipcbiogQHBhcmFtIG5hbWUgdGhlIGhlYWRlciBmaWVsZCBuYW1lXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLmdldEV4dHJhSGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5leHRyYUhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuKiBSZW1vdmUgYW4gZXh0cmEgZmllbGQgZnJvbSB0aGUgSFRUUCByZXF1ZXN0XG4qXG4qIEBwYXJhbSBuYW1lIHRoZSBoZWFkZXIgZmllbGQgbmFtZVxuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS51bnNldEV4dHJhSGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICBkZWxldGUgdGhpcy5leHRyYUhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuKiBBdWdtZW50IHNlbnQgeC1hbGdvbGlhLWFnZW50IHdpdGggbW9yZSBkYXRhLCBlYWNoIGFnZW50IHBhcnRcbiogaXMgYXV0b21hdGljYWxseSBzZXBhcmF0ZWQgZnJvbSB0aGUgb3RoZXJzIGJ5IGEgc2VtaWNvbG9uO1xuKlxuKiBAcGFyYW0gYWxnb2xpYUFnZW50IHRoZSBhZ2VudCB0byBhZGRcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuYWRkQWxnb2xpYUFnZW50ID0gZnVuY3Rpb24oYWxnb2xpYUFnZW50KSB7XG4gIGlmICh0aGlzLl91YS5pbmRleE9mKCc7JyArIGFsZ29saWFBZ2VudCkgPT09IC0xKSB7XG4gICAgdGhpcy5fdWEgKz0gJzsnICsgYWxnb2xpYUFnZW50O1xuICB9XG59O1xuXG4vKlxuICogV3JhcHBlciB0aGF0IHRyeSBhbGwgaG9zdHMgdG8gbWF4aW1pemUgdGhlIHF1YWxpdHkgb2Ygc2VydmljZVxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2pzb25SZXF1ZXN0ID0gZnVuY3Rpb24oaW5pdGlhbE9wdHMpIHtcbiAgdGhpcy5fY2hlY2tBcHBJZERhdGEoKTtcblxuICB2YXIgcmVxdWVzdERlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxnb2xpYXNlYXJjaDonICsgaW5pdGlhbE9wdHMudXJsKTtcblxuICB2YXIgYm9keTtcbiAgdmFyIGFkZGl0aW9uYWxVQSA9IGluaXRpYWxPcHRzLmFkZGl0aW9uYWxVQSB8fCAnJztcbiAgdmFyIGNhY2hlID0gaW5pdGlhbE9wdHMuY2FjaGU7XG4gIHZhciBjbGllbnQgPSB0aGlzO1xuICB2YXIgdHJpZXMgPSAwO1xuICB2YXIgdXNpbmdGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgaGFzRmFsbGJhY2sgPSBjbGllbnQuX3VzZUZhbGxiYWNrICYmIGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjayAmJiBpbml0aWFsT3B0cy5mYWxsYmFjaztcbiAgdmFyIGhlYWRlcnM7XG5cbiAgaWYgKFxuICAgIHRoaXMuYXBpS2V5Lmxlbmd0aCA+IE1BWF9BUElfS0VZX0xFTkdUSCAmJlxuICAgIGluaXRpYWxPcHRzLmJvZHkgIT09IHVuZGVmaW5lZCAmJlxuICAgIChpbml0aWFsT3B0cy5ib2R5LnBhcmFtcyAhPT0gdW5kZWZpbmVkIHx8IC8vIGluZGV4LnNlYXJjaCgpXG4gICAgaW5pdGlhbE9wdHMuYm9keS5yZXF1ZXN0cyAhPT0gdW5kZWZpbmVkKSAvLyBjbGllbnQuc2VhcmNoKClcbiAgKSB7XG4gICAgaW5pdGlhbE9wdHMuYm9keS5hcGlLZXkgPSB0aGlzLmFwaUtleTtcbiAgICBoZWFkZXJzID0gdGhpcy5fY29tcHV0ZVJlcXVlc3RIZWFkZXJzKGFkZGl0aW9uYWxVQSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGhlYWRlcnMgPSB0aGlzLl9jb21wdXRlUmVxdWVzdEhlYWRlcnMoYWRkaXRpb25hbFVBKTtcbiAgfVxuXG4gIGlmIChpbml0aWFsT3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBib2R5ID0gc2FmZUpTT05TdHJpbmdpZnkoaW5pdGlhbE9wdHMuYm9keSk7XG4gIH1cblxuICByZXF1ZXN0RGVidWcoJ3JlcXVlc3Qgc3RhcnQnKTtcbiAgdmFyIGRlYnVnRGF0YSA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRvUmVxdWVzdChyZXF1ZXN0ZXIsIHJlcU9wdHMpIHtcbiAgICBjbGllbnQuX2NoZWNrQXBwSWREYXRhKCk7XG5cbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICB2YXIgY2FjaGVJRDtcblxuICAgIGlmIChjbGllbnQuX3VzZUNhY2hlKSB7XG4gICAgICBjYWNoZUlEID0gaW5pdGlhbE9wdHMudXJsO1xuICAgIH1cblxuICAgIC8vIGFzIHdlIHNvbWV0aW1lIHVzZSBQT1NUIHJlcXVlc3RzIHRvIHBhc3MgcGFyYW1ldGVycyAobGlrZSBxdWVyeT0nYWEnKSxcbiAgICAvLyB0aGUgY2FjaGVJRCBtdXN0IGFsc28gaW5jbHVkZSB0aGUgYm9keSB0byBiZSBkaWZmZXJlbnQgYmV0d2VlbiBjYWxsc1xuICAgIGlmIChjbGllbnQuX3VzZUNhY2hlICYmIGJvZHkpIHtcbiAgICAgIGNhY2hlSUQgKz0gJ19ib2R5XycgKyByZXFPcHRzLmJvZHk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGNhY2hlIGV4aXN0ZW5jZVxuICAgIGlmIChjbGllbnQuX3VzZUNhY2hlICYmIGNhY2hlICYmIGNhY2hlW2NhY2hlSURdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3REZWJ1Zygnc2VydmluZyByZXNwb25zZSBmcm9tIGNhY2hlJyk7XG4gICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlc29sdmUoSlNPTi5wYXJzZShjYWNoZVtjYWNoZUlEXSkpO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIHJlYWNoZWQgbWF4IHRyaWVzXG4gICAgaWYgKHRyaWVzID49IGNsaWVudC5ob3N0c1tpbml0aWFsT3B0cy5ob3N0VHlwZV0ubGVuZ3RoKSB7XG4gICAgICBpZiAoIWhhc0ZhbGxiYWNrIHx8IHVzaW5nRmFsbGJhY2spIHtcbiAgICAgICAgcmVxdWVzdERlYnVnKCdjb3VsZCBub3QgZ2V0IGFueSByZXNwb25zZScpO1xuICAgICAgICAvLyB0aGVuIHN0b3BcbiAgICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5yZWplY3QobmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb25uZWN0IHRvIHRoZSBBbGdvbGlhU2VhcmNoIEFQSS4nICtcbiAgICAgICAgICAnIFNlbmQgYW4gZW1haWwgdG8gc3VwcG9ydEBhbGdvbGlhLmNvbSB0byByZXBvcnQgYW5kIHJlc29sdmUgdGhlIGlzc3VlLicgK1xuICAgICAgICAgICcgQXBwbGljYXRpb24gaWQgd2FzOiAnICsgY2xpZW50LmFwcGxpY2F0aW9uSUQsIHtkZWJ1Z0RhdGE6IGRlYnVnRGF0YX1cbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3REZWJ1Zygnc3dpdGNoaW5nIHRvIGZhbGxiYWNrJyk7XG5cbiAgICAgIC8vIGxldCdzIHRyeSB0aGUgZmFsbGJhY2sgc3RhcnRpbmcgZnJvbSBoZXJlXG4gICAgICB0cmllcyA9IDA7XG5cbiAgICAgIC8vIG1ldGhvZCwgdXJsIGFuZCBib2R5IGFyZSBmYWxsYmFjayBkZXBlbmRlbnRcbiAgICAgIHJlcU9wdHMubWV0aG9kID0gaW5pdGlhbE9wdHMuZmFsbGJhY2subWV0aG9kO1xuICAgICAgcmVxT3B0cy51cmwgPSBpbml0aWFsT3B0cy5mYWxsYmFjay51cmw7XG4gICAgICByZXFPcHRzLmpzb25Cb2R5ID0gaW5pdGlhbE9wdHMuZmFsbGJhY2suYm9keTtcbiAgICAgIGlmIChyZXFPcHRzLmpzb25Cb2R5KSB7XG4gICAgICAgIHJlcU9wdHMuYm9keSA9IHNhZmVKU09OU3RyaW5naWZ5KHJlcU9wdHMuanNvbkJvZHkpO1xuICAgICAgfVxuICAgICAgLy8gcmUtY29tcHV0ZSBoZWFkZXJzLCB0aGV5IGNvdWxkIGJlIG9taXR0aW5nIHRoZSBBUEkgS0VZXG4gICAgICBoZWFkZXJzID0gY2xpZW50Ll9jb21wdXRlUmVxdWVzdEhlYWRlcnMoYWRkaXRpb25hbFVBKTtcblxuICAgICAgcmVxT3B0cy50aW1lb3V0cyA9IGNsaWVudC5fZ2V0VGltZW91dHNGb3JSZXF1ZXN0KGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcbiAgICAgIGNsaWVudC5fc2V0SG9zdEluZGV4QnlUeXBlKDAsIGluaXRpYWxPcHRzLmhvc3RUeXBlKTtcbiAgICAgIHVzaW5nRmFsbGJhY2sgPSB0cnVlOyAvLyB0aGUgY3VycmVudCByZXF1ZXN0IGlzIG5vdyB1c2luZyBmYWxsYmFja1xuICAgICAgcmV0dXJuIGRvUmVxdWVzdChjbGllbnQuX3JlcXVlc3QuZmFsbGJhY2ssIHJlcU9wdHMpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SG9zdCA9IGNsaWVudC5fZ2V0SG9zdEJ5VHlwZShpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG5cbiAgICB2YXIgdXJsID0gY3VycmVudEhvc3QgKyByZXFPcHRzLnVybDtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGJvZHk6IHJlcU9wdHMuYm9keSxcbiAgICAgIGpzb25Cb2R5OiByZXFPcHRzLmpzb25Cb2R5LFxuICAgICAgbWV0aG9kOiByZXFPcHRzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICB0aW1lb3V0czogcmVxT3B0cy50aW1lb3V0cyxcbiAgICAgIGRlYnVnOiByZXF1ZXN0RGVidWdcbiAgICB9O1xuXG4gICAgcmVxdWVzdERlYnVnKCdtZXRob2Q6ICVzLCB1cmw6ICVzLCBoZWFkZXJzOiAlaiwgdGltZW91dHM6ICVkJyxcbiAgICAgIG9wdGlvbnMubWV0aG9kLCB1cmwsIG9wdGlvbnMuaGVhZGVycywgb3B0aW9ucy50aW1lb3V0cyk7XG5cbiAgICBpZiAocmVxdWVzdGVyID09PSBjbGllbnQuX3JlcXVlc3QuZmFsbGJhY2spIHtcbiAgICAgIHJlcXVlc3REZWJ1ZygndXNpbmcgZmFsbGJhY2snKTtcbiAgICB9XG5cbiAgICAvLyBgcmVxdWVzdGVyYCBpcyBhbnkgb2YgdGhpcy5fcmVxdWVzdCBvciB0aGlzLl9yZXF1ZXN0LmZhbGxiYWNrXG4gICAgLy8gdGh1cyBpdCBuZWVkcyB0byBiZSBjYWxsZWQgdXNpbmcgdGhlIGNsaWVudCBhcyBjb250ZXh0XG4gICAgcmV0dXJuIHJlcXVlc3Rlci5jYWxsKGNsaWVudCwgdXJsLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MsIHRyeUZhbGxiYWNrKTtcblxuICAgIGZ1bmN0aW9uIHN1Y2Nlc3MoaHR0cFJlc3BvbnNlKSB7XG4gICAgICAvLyBjb21wdXRlIHRoZSBzdGF0dXMgb2YgdGhlIHJlc3BvbnNlLFxuICAgICAgLy9cbiAgICAgIC8vIFdoZW4gaW4gYnJvd3NlciBtb2RlLCB1c2luZyBYRFIgb3IgSlNPTlAsIHdlIGhhdmUgbm8gc3RhdHVzQ29kZSBhdmFpbGFibGVcbiAgICAgIC8vIFNvIHdlIHJlbHkgb24gb3VyIEFQSSByZXNwb25zZSBgc3RhdHVzYCBwcm9wZXJ0eS5cbiAgICAgIC8vIEJ1dCBgd2FpdFRhc2tgIGNhbiBzZXQgYSBgc3RhdHVzYCBwcm9wZXJ0eSB3aGljaCBpcyBub3QgdGhlIHN0YXR1c0NvZGUgKGl0J3MgdGhlIHRhc2sgc3RhdHVzKVxuICAgICAgLy8gU28gd2UgY2hlY2sgaWYgdGhlcmUncyBhIGBtZXNzYWdlYCBhbG9uZyBgc3RhdHVzYCBhbmQgaXQgbWVhbnMgaXQncyBhbiBlcnJvclxuICAgICAgLy9cbiAgICAgIC8vIFRoYXQncyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGhhdmUgYSByZXNwb25zZS5zdGF0dXMgdGhhdCdzIG5vdCB0aGUgaHR0cCBzdGF0dXNDb2RlXG4gICAgICB2YXIgc3RhdHVzID0gaHR0cFJlc3BvbnNlICYmIGh0dHBSZXNwb25zZS5ib2R5ICYmIGh0dHBSZXNwb25zZS5ib2R5Lm1lc3NhZ2UgJiYgaHR0cFJlc3BvbnNlLmJvZHkuc3RhdHVzIHx8XG5cbiAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHJlcXVlc3Qgc3RhdHVzQ29kZSBBRlRFUiB0aGUgYm9keSBldmVudHVhbFxuICAgICAgICAvLyBzdGF0dXNDb2RlIGJlY2F1c2Ugc29tZSBpbXBsZW1lbnRhdGlvbnMgKGpRdWVyeSBYRG9tYWluUmVxdWVzdCB0cmFuc3BvcnQpIG1heVxuICAgICAgICAvLyBzZW5kIHN0YXR1c0NvZGUgMjAwIHdoaWxlIHdlIGhhZCBhbiBlcnJvclxuICAgICAgICBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSB8fFxuXG4gICAgICAgIC8vIFdoZW4gaW4gYnJvd3NlciBtb2RlLCB1c2luZyBYRFIgb3IgSlNPTlBcbiAgICAgICAgLy8gd2UgZGVmYXVsdCB0byBzdWNjZXNzIHdoZW4gbm8gZXJyb3IgKG5vIHJlc3BvbnNlLnN0YXR1cyAmJiByZXNwb25zZS5tZXNzYWdlKVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBKU09OLnBhcnNlKCkgZXJyb3IgdGhlbiBib2R5IGlzIG51bGwgYW5kIGl0IGZhaWxzXG4gICAgICAgIGh0dHBSZXNwb25zZSAmJiBodHRwUmVzcG9uc2UuYm9keSAmJiAyMDA7XG5cbiAgICAgIHJlcXVlc3REZWJ1ZygncmVjZWl2ZWQgcmVzcG9uc2U6IHN0YXR1c0NvZGU6ICVzLCBjb21wdXRlZCBzdGF0dXNDb2RlOiAlZCwgaGVhZGVyczogJWonLFxuICAgICAgICBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSwgc3RhdHVzLCBodHRwUmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICAgIHZhciBodHRwUmVzcG9uc2VPayA9IE1hdGguZmxvb3Ioc3RhdHVzIC8gMTAwKSA9PT0gMjtcblxuICAgICAgdmFyIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgZGVidWdEYXRhLnB1c2goe1xuICAgICAgICBjdXJyZW50SG9zdDogY3VycmVudEhvc3QsXG4gICAgICAgIGhlYWRlcnM6IHJlbW92ZUNyZWRlbnRpYWxzKGhlYWRlcnMpLFxuICAgICAgICBjb250ZW50OiBib2R5IHx8IG51bGwsXG4gICAgICAgIGNvbnRlbnRMZW5ndGg6IGJvZHkgIT09IHVuZGVmaW5lZCA/IGJvZHkubGVuZ3RoIDogbnVsbCxcbiAgICAgICAgbWV0aG9kOiByZXFPcHRzLm1ldGhvZCxcbiAgICAgICAgdGltZW91dHM6IHJlcU9wdHMudGltZW91dHMsXG4gICAgICAgIHVybDogcmVxT3B0cy51cmwsXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgICBlbmRUaW1lOiBlbmRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGh0dHBSZXNwb25zZU9rKSB7XG4gICAgICAgIGlmIChjbGllbnQuX3VzZUNhY2hlICYmIGNhY2hlKSB7XG4gICAgICAgICAgY2FjaGVbY2FjaGVJRF0gPSBodHRwUmVzcG9uc2UucmVzcG9uc2VUZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5ib2R5O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvdWxkUmV0cnkgPSBNYXRoLmZsb29yKHN0YXR1cyAvIDEwMCkgIT09IDQ7XG5cbiAgICAgIGlmIChzaG91bGRSZXRyeSkge1xuICAgICAgICB0cmllcyArPSAxO1xuICAgICAgICByZXR1cm4gcmV0cnlSZXF1ZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3REZWJ1ZygndW5yZWNvdmVyYWJsZSBlcnJvcicpO1xuXG4gICAgICAvLyBubyBzdWNjZXNzIGFuZCBubyByZXRyeSA9PiBmYWlsXG4gICAgICB2YXIgdW5yZWNvdmVyYWJsZUVycm9yID0gbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoXG4gICAgICAgIGh0dHBSZXNwb25zZS5ib2R5ICYmIGh0dHBSZXNwb25zZS5ib2R5Lm1lc3NhZ2UsIHtkZWJ1Z0RhdGE6IGRlYnVnRGF0YSwgc3RhdHVzQ29kZTogc3RhdHVzfVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5yZWplY3QodW5yZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cnlGYWxsYmFjayhlcnIpIHtcbiAgICAgIC8vIGVycm9yIGNhc2VzOlxuICAgICAgLy8gIFdoaWxlIG5vdCBpbiBmYWxsYmFjayBtb2RlOlxuICAgICAgLy8gICAgLSBDT1JTIG5vdCBzdXBwb3J0ZWRcbiAgICAgIC8vICAgIC0gbmV0d29yayBlcnJvclxuICAgICAgLy8gIFdoaWxlIGluIGZhbGxiYWNrIG1vZGU6XG4gICAgICAvLyAgICAtIHRpbWVvdXRcbiAgICAgIC8vICAgIC0gbmV0d29yayBlcnJvclxuICAgICAgLy8gICAgLSBiYWRseSBmb3JtYXR0ZWQgSlNPTlAgKHNjcmlwdCBsb2FkZWQsIGRpZCBub3QgY2FsbCBvdXIgY2FsbGJhY2spXG4gICAgICAvLyAgSW4gYm90aCBjYXNlczpcbiAgICAgIC8vICAgIC0gdW5jYXVnaHQgZXhjZXB0aW9uIG9jY3VycyAoVHlwZUVycm9yKVxuICAgICAgcmVxdWVzdERlYnVnKCdlcnJvcjogJXMsIHN0YWNrOiAlcycsIGVyci5tZXNzYWdlLCBlcnIuc3RhY2spO1xuXG4gICAgICB2YXIgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBkZWJ1Z0RhdGEucHVzaCh7XG4gICAgICAgIGN1cnJlbnRIb3N0OiBjdXJyZW50SG9zdCxcbiAgICAgICAgaGVhZGVyczogcmVtb3ZlQ3JlZGVudGlhbHMoaGVhZGVycyksXG4gICAgICAgIGNvbnRlbnQ6IGJvZHkgfHwgbnVsbCxcbiAgICAgICAgY29udGVudExlbmd0aDogYm9keSAhPT0gdW5kZWZpbmVkID8gYm9keS5sZW5ndGggOiBudWxsLFxuICAgICAgICBtZXRob2Q6IHJlcU9wdHMubWV0aG9kLFxuICAgICAgICB0aW1lb3V0czogcmVxT3B0cy50aW1lb3V0cyxcbiAgICAgICAgdXJsOiByZXFPcHRzLnVybCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lXG4gICAgICB9KTtcblxuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcikpIHtcbiAgICAgICAgZXJyID0gbmV3IGVycm9ycy5Vbmtub3duKGVyciAmJiBlcnIubWVzc2FnZSwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgdHJpZXMgKz0gMTtcblxuICAgICAgLy8gc3RvcCB0aGUgcmVxdWVzdCBpbXBsZW1lbnRhdGlvbiB3aGVuOlxuICAgICAgaWYgKFxuICAgICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIHRoaXMgZXJyb3IsXG4gICAgICAgIC8vIGl0IGNvbWVzIGZyb20gYSB0aHJvdyBpbiBzb21lIG90aGVyIHBpZWNlIG9mIGNvZGVcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgZXJyb3JzLlVua25vd24gfHxcblxuICAgICAgICAvLyBzZXJ2ZXIgc2VudCB1bnBhcnNhYmxlIEpTT05cbiAgICAgICAgZXJyIGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OIHx8XG5cbiAgICAgICAgLy8gbWF4IHRyaWVzIGFuZCBhbHJlYWR5IHVzaW5nIGZhbGxiYWNrIG9yIG5vIGZhbGxiYWNrXG4gICAgICAgIHRyaWVzID49IGNsaWVudC5ob3N0c1tpbml0aWFsT3B0cy5ob3N0VHlwZV0ubGVuZ3RoICYmXG4gICAgICAgICh1c2luZ0ZhbGxiYWNrIHx8ICFoYXNGYWxsYmFjaykpIHtcbiAgICAgICAgLy8gc3RvcCByZXF1ZXN0IGltcGxlbWVudGF0aW9uIGZvciB0aGlzIGNvbW1hbmRcbiAgICAgICAgZXJyLmRlYnVnRGF0YSA9IGRlYnVnRGF0YTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5fcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBhIHRpbWVvdXQgb2NjdXJlZCwgcmV0cnkgYnkgcmFpc2luZyB0aW1lb3V0XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgZXJyb3JzLlJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICAgIHJldHVybiByZXRyeVJlcXVlc3RXaXRoSGlnaGVyVGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0cnlSZXF1ZXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0cnlSZXF1ZXN0KCkge1xuICAgICAgcmVxdWVzdERlYnVnKCdyZXRyeWluZyByZXF1ZXN0Jyk7XG4gICAgICBjbGllbnQuX2luY3JlbWVudEhvc3RJbmRleChpbml0aWFsT3B0cy5ob3N0VHlwZSk7XG4gICAgICByZXR1cm4gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0cnlSZXF1ZXN0V2l0aEhpZ2hlclRpbWVvdXQoKSB7XG4gICAgICByZXF1ZXN0RGVidWcoJ3JldHJ5aW5nIHJlcXVlc3Qgd2l0aCBoaWdoZXIgdGltZW91dCcpO1xuICAgICAgY2xpZW50Ll9pbmNyZW1lbnRIb3N0SW5kZXgoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgY2xpZW50Ll9pbmNyZW1lbnRUaW1lb3V0TXVsdGlwbGVyKCk7XG4gICAgICByZXFPcHRzLnRpbWVvdXRzID0gY2xpZW50Ll9nZXRUaW1lb3V0c0ZvclJlcXVlc3QoaW5pdGlhbE9wdHMuaG9zdFR5cGUpO1xuICAgICAgcmV0dXJuIGRvUmVxdWVzdChyZXF1ZXN0ZXIsIHJlcU9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9taXNlID0gZG9SZXF1ZXN0KFxuICAgIGNsaWVudC5fcmVxdWVzdCwge1xuICAgICAgdXJsOiBpbml0aWFsT3B0cy51cmwsXG4gICAgICBtZXRob2Q6IGluaXRpYWxPcHRzLm1ldGhvZCxcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICBqc29uQm9keTogaW5pdGlhbE9wdHMuYm9keSxcbiAgICAgIHRpbWVvdXRzOiBjbGllbnQuX2dldFRpbWVvdXRzRm9yUmVxdWVzdChpbml0aWFsT3B0cy5ob3N0VHlwZSlcbiAgICB9XG4gICk7XG5cbiAgLy8gZWl0aGVyIHdlIGhhdmUgYSBjYWxsYmFja1xuICAvLyBlaXRoZXIgd2UgYXJlIHVzaW5nIHByb21pc2VzXG4gIGlmICh0eXBlb2YgaW5pdGlhbE9wdHMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gb2tDYihjb250ZW50KSB7XG4gICAgICBleGl0UHJvbWlzZShmdW5jdGlvbigpIHtcbiAgICAgICAgaW5pdGlhbE9wdHMuY2FsbGJhY2sobnVsbCwgY29udGVudCk7XG4gICAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gICAgfSwgZnVuY3Rpb24gbm9va0NiKGVycikge1xuICAgICAgZXhpdFByb21pc2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIGluaXRpYWxPcHRzLmNhbGxiYWNrKGVycik7XG4gICAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn07XG5cbi8qXG4qIFRyYW5zZm9ybSBzZWFyY2ggcGFyYW0gb2JqZWN0IGluIHF1ZXJ5IHN0cmluZ1xuKiBAcGFyYW0ge29iamVjdH0gYXJncyBhcmd1bWVudHMgdG8gYWRkIHRvIHRoZSBjdXJyZW50IHF1ZXJ5IHN0cmluZ1xuKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zIGN1cnJlbnQgcXVlcnkgc3RyaW5nXG4qIEByZXR1cm4ge3N0cmluZ30gdGhlIGZpbmFsIHF1ZXJ5IHN0cmluZ1xuKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24oYXJncywgcGFyYW1zKSB7XG4gIGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGFyZ3MpIHtcbiAgICBpZiAoa2V5ICE9PSBudWxsICYmIGFyZ3Nba2V5XSAhPT0gdW5kZWZpbmVkICYmIGFyZ3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcGFyYW1zICs9IHBhcmFtcyA9PT0gJycgPyAnJyA6ICcmJztcbiAgICAgIHBhcmFtcyArPSBrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3Nba2V5XSkgPT09ICdbb2JqZWN0IEFycmF5XScgPyBzYWZlSlNPTlN0cmluZ2lmeShhcmdzW2tleV0pIDogYXJnc1trZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fY29tcHV0ZVJlcXVlc3RIZWFkZXJzID0gZnVuY3Rpb24oYWRkaXRpb25hbFVBLCB3aXRoQVBJS2V5KSB7XG4gIHZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG4gIHZhciB1YSA9IGFkZGl0aW9uYWxVQSA/XG4gICAgdGhpcy5fdWEgKyAnOycgKyBhZGRpdGlvbmFsVUEgOlxuICAgIHRoaXMuX3VhO1xuXG4gIHZhciByZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAneC1hbGdvbGlhLWFnZW50JzogdWEsXG4gICAgJ3gtYWxnb2xpYS1hcHBsaWNhdGlvbi1pZCc6IHRoaXMuYXBwbGljYXRpb25JRFxuICB9O1xuXG4gIC8vIGJyb3dzZXIgd2lsbCBpbmxpbmUgaGVhZGVycyBpbiB0aGUgdXJsLCBub2RlLmpzIHdpbGwgdXNlIGh0dHAgaGVhZGVyc1xuICAvLyBidXQgaW4gc29tZSBzaXR1YXRpb25zLCB0aGUgQVBJIEtFWSB3aWxsIGJlIHRvbyBsb25nIChiaWcgc2VjdXJlZCBBUEkga2V5cylcbiAgLy8gc28gaWYgdGhlIHJlcXVlc3QgaXMgYSBQT1NUIGFuZCB0aGUgS0VZIGlzIHZlcnkgbG9uZywgd2Ugd2lsbCBiZSBhc2tlZCB0byBub3QgcHV0XG4gIC8vIGl0IGludG8gaGVhZGVycyBidXQgaW4gdGhlIEpTT04gYm9keVxuICBpZiAod2l0aEFQSUtleSAhPT0gZmFsc2UpIHtcbiAgICByZXF1ZXN0SGVhZGVyc1sneC1hbGdvbGlhLWFwaS1rZXknXSA9IHRoaXMuYXBpS2V5O1xuICB9XG5cbiAgaWYgKHRoaXMudXNlclRva2VuKSB7XG4gICAgcmVxdWVzdEhlYWRlcnNbJ3gtYWxnb2xpYS11c2VydG9rZW4nXSA9IHRoaXMudXNlclRva2VuO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VjdXJpdHlUYWdzKSB7XG4gICAgcmVxdWVzdEhlYWRlcnNbJ3gtYWxnb2xpYS10YWdmaWx0ZXJzJ10gPSB0aGlzLnNlY3VyaXR5VGFncztcbiAgfVxuXG4gIGZvckVhY2godGhpcy5leHRyYUhlYWRlcnMsIGZ1bmN0aW9uIGFkZFRvUmVxdWVzdEhlYWRlcnModmFsdWUsIGtleSkge1xuICAgIHJlcXVlc3RIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcXVlc3RIZWFkZXJzO1xufTtcblxuLyoqXG4gKiBTZWFyY2ggdGhyb3VnaCBtdWx0aXBsZSBpbmRpY2VzIGF0IHRoZSBzYW1lIHRpbWVcbiAqIEBwYXJhbSAge09iamVjdFtdfSAgIHF1ZXJpZXMgIEFuIGFycmF5IG9mIHF1ZXJpZXMgeW91IHdhbnQgdG8gcnVuLlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJpZXNbXS5pbmRleE5hbWUgVGhlIGluZGV4IG5hbWUgeW91IHdhbnQgdG8gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJpZXNbXS5xdWVyeV0gVGhlIHF1ZXJ5IHRvIGlzc3VlIG9uIHRoaXMgaW5kZXguIENhbiBhbHNvIGJlIHBhc3NlZCBpbnRvIGBwYXJhbXNgXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcmllc1tdLnBhcmFtcyBBbnkgc2VhcmNoIHBhcmFtIGxpa2UgaGl0c1BlclBhZ2UsIC4uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiAqL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHF1ZXJpZXMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAuanMnKTtcblxuICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGNsaWVudC5zZWFyY2goYXJyYXlPZlF1ZXJpZXNbLCBjYWxsYmFja10pJztcblxuICBpZiAoIWlzQXJyYXkocXVlcmllcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodXNhZ2UpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfSBlbHNlIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIgY2xpZW50ID0gdGhpcztcblxuICB2YXIgcG9zdE9iaiA9IHtcbiAgICByZXF1ZXN0czogbWFwKHF1ZXJpZXMsIGZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KHF1ZXJ5KSB7XG4gICAgICB2YXIgcGFyYW1zID0gJyc7XG5cbiAgICAgIC8vIGFsbG93IHF1ZXJ5LnF1ZXJ5XG4gICAgICAvLyBzbyB3ZSBhcmUgbWltaWNpbmcgdGhlIGluZGV4LnNlYXJjaChxdWVyeSwgcGFyYW1zKSBtZXRob2RcbiAgICAgIC8vIHtpbmRleE5hbWU6LCBxdWVyeTosIHBhcmFtczp9XG4gICAgICBpZiAocXVlcnkucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMgKz0gJ3F1ZXJ5PScgKyBlbmNvZGVVUklDb21wb25lbnQocXVlcnkucXVlcnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleE5hbWU6IHF1ZXJ5LmluZGV4TmFtZSxcbiAgICAgICAgcGFyYW1zOiBjbGllbnQuX2dldFNlYXJjaFBhcmFtcyhxdWVyeS5wYXJhbXMsIHBhcmFtcylcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcblxuICB2YXIgSlNPTlBQYXJhbXMgPSBtYXAocG9zdE9iai5yZXF1ZXN0cywgZnVuY3Rpb24gcHJlcGFyZUpTT05QUGFyYW1zKHJlcXVlc3QsIHJlcXVlc3RJZCkge1xuICAgIHJldHVybiByZXF1ZXN0SWQgKyAnPScgK1xuICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlcXVlc3QuaW5kZXhOYW1lKSArICc/JyArXG4gICAgICAgIHJlcXVlc3QucGFyYW1zXG4gICAgICApO1xuICB9KS5qb2luKCcmJyk7XG5cbiAgdmFyIHVybCA9ICcvMS9pbmRleGVzLyovcXVlcmllcyc7XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kgIT09IHVuZGVmaW5lZCkge1xuICAgIHVybCArPSAnP3N0cmF0ZWd5PScgKyBvcHRzLnN0cmF0ZWd5O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6IHVybCxcbiAgICBib2R5OiBwb3N0T2JqLFxuICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgZmFsbGJhY2s6IHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6ICcvMS9pbmRleGVzLyonLFxuICAgICAgYm9keToge1xuICAgICAgICBwYXJhbXM6IEpTT05QUGFyYW1zXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZXh0cmEgc2VjdXJpdHkgdGFnRmlsdGVycyBoZWFkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB0YWdzIFRoZSBsaXN0IG9mIHRhZ3MgZGVmaW5pbmcgdGhlIGN1cnJlbnQgc2VjdXJpdHkgZmlsdGVyc1xuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0U2VjdXJpdHlUYWdzID0gZnVuY3Rpb24odGFncykge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhZ3MpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgdmFyIHN0clRhZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFnc1tpXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgdmFyIG9yZWRUYWdzID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGFnc1tpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgIG9yZWRUYWdzLnB1c2godGFnc1tpXVtqXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyVGFncy5wdXNoKCcoJyArIG9yZWRUYWdzLmpvaW4oJywnKSArICcpJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJUYWdzLnB1c2godGFnc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRhZ3MgPSBzdHJUYWdzLmpvaW4oJywnKTtcbiAgfVxuXG4gIHRoaXMuc2VjdXJpdHlUYWdzID0gdGFncztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBleHRyYSB1c2VyIHRva2VuIGhlYWRlclxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJUb2tlbiBUaGUgdG9rZW4gaWRlbnRpZnlpbmcgYSB1bmlxIHVzZXIgKHVzZWQgdG8gYXBwbHkgcmF0ZSBsaW1pdHMpXG4gKi9cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5zZXRVc2VyVG9rZW4gPSBmdW5jdGlvbih1c2VyVG9rZW4pIHtcbiAgdGhpcy51c2VyVG9rZW4gPSB1c2VyVG9rZW47XG59O1xuXG4vKipcbiAqIENsZWFyIGFsbCBxdWVyaWVzIGluIGNsaWVudCdzIGNhY2hlXG4gKiBAcmV0dXJuIHVuZGVmaW5lZFxuICovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNhY2hlID0ge307XG59O1xuXG4vKipcbiogU2V0IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGEgcmVxdWVzdCBjYW4gdGFrZSBiZWZvcmUgYXV0b21hdGljYWxseSBiZWluZyB0ZXJtaW5hdGVkLlxuKiBAZGVwcmVjYXRlZFxuKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLnNldFJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24obWlsbGlzZWNvbmRzKSB7XG4gIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICB0aGlzLl90aW1lb3V0cy5jb25uZWN0ID0gdGhpcy5fdGltZW91dHMucmVhZCA9IHRoaXMuX3RpbWVvdXRzLndyaXRlID0gbWlsbGlzZWNvbmRzO1xuICB9XG59O1xuXG4vKipcbiogU2V0IHRoZSB0aHJlZSBkaWZmZXJlbnQgKGNvbm5lY3QsIHJlYWQsIHdyaXRlKSB0aW1lb3V0cyB0byBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZ1xuKiBAcGFyYW0ge09iamVjdH0gdGltZW91dHNcbiovXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuc2V0VGltZW91dHMgPSBmdW5jdGlvbih0aW1lb3V0cykge1xuICB0aGlzLl90aW1lb3V0cyA9IHRpbWVvdXRzO1xufTtcblxuLyoqXG4qIEdldCB0aGUgdGhyZWUgZGlmZmVyZW50IChjb25uZWN0LCByZWFkLCB3cml0ZSkgdGltZW91dHMgdG8gYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmdcbiogQHBhcmFtIHtPYmplY3R9IHRpbWVvdXRzXG4qL1xuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLmdldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aW1lb3V0cztcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0QXBwSWREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gc3RvcmUuZ2V0KHRoaXMuYXBwbGljYXRpb25JRCk7XG4gIGlmIChkYXRhICE9PSBudWxsKSB0aGlzLl9jYWNoZUFwcElkRGF0YShkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX3NldEFwcElkRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGF0YS5sYXN0Q2hhbmdlID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdGhpcy5fY2FjaGVBcHBJZERhdGEoZGF0YSk7XG4gIHJldHVybiBzdG9yZS5zZXQodGhpcy5hcHBsaWNhdGlvbklELCBkYXRhKTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fY2hlY2tBcHBJZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9nZXRBcHBJZERhdGEoKTtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIGlmIChkYXRhID09PSBudWxsIHx8IG5vdyAtIGRhdGEubGFzdENoYW5nZSA+IFJFU0VUX0FQUF9EQVRBX1RJTUVSKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2V0SW5pdGlhbEFwcElkRGF0YShkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9yZXNldEluaXRpYWxBcHBJZERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBuZXdEYXRhID0gZGF0YSB8fCB7fTtcbiAgbmV3RGF0YS5ob3N0SW5kZXhlcyA9IHtyZWFkOiAwLCB3cml0ZTogMH07XG4gIG5ld0RhdGEudGltZW91dE11bHRpcGxpZXIgPSAxO1xuICBuZXdEYXRhLnNodWZmbGVSZXN1bHQgPSBuZXdEYXRhLnNodWZmbGVSZXN1bHQgfHwgc2h1ZmZsZShbMSwgMiwgM10pO1xuICByZXR1cm4gdGhpcy5fc2V0QXBwSWREYXRhKG5ld0RhdGEpO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9jYWNoZUFwcElkRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5faG9zdEluZGV4ZXMgPSBkYXRhLmhvc3RJbmRleGVzO1xuICB0aGlzLl90aW1lb3V0TXVsdGlwbGllciA9IGRhdGEudGltZW91dE11bHRpcGxpZXI7XG4gIHRoaXMuX3NodWZmbGVSZXN1bHQgPSBkYXRhLnNodWZmbGVSZXN1bHQ7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX3BhcnRpYWxBcHBJZERhdGFVcGRhdGUgPSBmdW5jdGlvbihuZXdEYXRhKSB7XG4gIHZhciBmb3JlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuICB2YXIgY3VycmVudERhdGEgPSB0aGlzLl9nZXRBcHBJZERhdGEoKTtcbiAgZm9yZWFjaChuZXdEYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgY3VycmVudERhdGFba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gdGhpcy5fc2V0QXBwSWREYXRhKGN1cnJlbnREYXRhKTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0SG9zdEJ5VHlwZSA9IGZ1bmN0aW9uKGhvc3RUeXBlKSB7XG4gIHJldHVybiB0aGlzLmhvc3RzW2hvc3RUeXBlXVt0aGlzLl9nZXRIb3N0SW5kZXhCeVR5cGUoaG9zdFR5cGUpXTtcbn07XG5cbkFsZ29saWFTZWFyY2hDb3JlLnByb3RvdHlwZS5fZ2V0VGltZW91dE11bHRpcGxpZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbWVvdXRNdWx0aXBsaWVyO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRIb3N0SW5kZXhCeVR5cGUgPSBmdW5jdGlvbihob3N0VHlwZSkge1xuICByZXR1cm4gdGhpcy5faG9zdEluZGV4ZXNbaG9zdFR5cGVdO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9zZXRIb3N0SW5kZXhCeVR5cGUgPSBmdW5jdGlvbihob3N0SW5kZXgsIGhvc3RUeXBlKSB7XG4gIHZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbiAgdmFyIG5ld0hvc3RJbmRleGVzID0gY2xvbmUodGhpcy5faG9zdEluZGV4ZXMpO1xuICBuZXdIb3N0SW5kZXhlc1tob3N0VHlwZV0gPSBob3N0SW5kZXg7XG4gIHRoaXMuX3BhcnRpYWxBcHBJZERhdGFVcGRhdGUoe2hvc3RJbmRleGVzOiBuZXdIb3N0SW5kZXhlc30pO1xuICByZXR1cm4gaG9zdEluZGV4O1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9pbmNyZW1lbnRIb3N0SW5kZXggPSBmdW5jdGlvbihob3N0VHlwZSkge1xuICByZXR1cm4gdGhpcy5fc2V0SG9zdEluZGV4QnlUeXBlKFxuICAgICh0aGlzLl9nZXRIb3N0SW5kZXhCeVR5cGUoaG9zdFR5cGUpICsgMSkgJSB0aGlzLmhvc3RzW2hvc3RUeXBlXS5sZW5ndGgsIGhvc3RUeXBlXG4gICk7XG59O1xuXG5BbGdvbGlhU2VhcmNoQ29yZS5wcm90b3R5cGUuX2luY3JlbWVudFRpbWVvdXRNdWx0aXBsZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRpbWVvdXRNdWx0aXBsaWVyID0gTWF0aC5tYXgodGhpcy5fdGltZW91dE11bHRpcGxpZXIgKyAxLCA0KTtcbiAgcmV0dXJuIHRoaXMuX3BhcnRpYWxBcHBJZERhdGFVcGRhdGUoe3RpbWVvdXRNdWx0aXBsaWVyOiB0aW1lb3V0TXVsdGlwbGllcn0pO1xufTtcblxuQWxnb2xpYVNlYXJjaENvcmUucHJvdG90eXBlLl9nZXRUaW1lb3V0c0ZvclJlcXVlc3QgPSBmdW5jdGlvbihob3N0VHlwZSkge1xuICByZXR1cm4ge1xuICAgIGNvbm5lY3Q6IHRoaXMuX3RpbWVvdXRzLmNvbm5lY3QgKiB0aGlzLl90aW1lb3V0TXVsdGlwbGllcixcbiAgICBjb21wbGV0ZTogdGhpcy5fdGltZW91dHNbaG9zdFR5cGVdICogdGhpcy5fdGltZW91dE11bHRpcGxpZXJcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHByZXBhcmVIb3N0KHByb3RvY29sKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmVwYXJlKGhvc3QpIHtcbiAgICByZXR1cm4gcHJvdG9jb2wgKyAnLy8nICsgaG9zdC50b0xvd2VyQ2FzZSgpO1xuICB9O1xufVxuXG4vLyBQcm90b3R5cGUuanMgPCAxLjcsIGEgd2lkZWx5IHVzZWQgbGlicmFyeSwgZGVmaW5lcyBhIHdlaXJkXG4vLyBBcnJheS5wcm90b3R5cGUudG9KU09OIGZ1bmN0aW9uIHRoYXQgd2lsbCBmYWlsIHRvIHN0cmluZ2lmeSBvdXIgY29udGVudFxuLy8gYXBwcm9wcmlhdGVseVxuLy8gcmVmczpcbi8vICAgLSBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhdG9waWMvcHJvdG90eXBlLWNvcmUvRS1TQVZ2Vl9WOVFcbi8vICAgLSBodHRwczovL2dpdGh1Yi5jb20vc3N0ZXBoZW5zb24vcHJvdG90eXBlL2NvbW1pdC8wMzhhMjk4NWE3MDU5M2MxYTg2YzIzMGZhZGJkZmUyZTQ4OThhNDhjXG4vLyAgIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0ODQ0MS8xNDcwNzlcbmZ1bmN0aW9uIHNhZmVKU09OU3RyaW5naWZ5KG9iaikge1xuICAvKiBlc2xpbnQgbm8tZXh0ZW5kLW5hdGl2ZTowICovXG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS50b0pTT04gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9XG5cbiAgdmFyIHRvSlNPTiA9IEFycmF5LnByb3RvdHlwZS50b0pTT047XG4gIGRlbGV0ZSBBcnJheS5wcm90b3R5cGUudG9KU09OO1xuICB2YXIgb3V0ID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgQXJyYXkucHJvdG90eXBlLnRvSlNPTiA9IHRvSlNPTjtcblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gIHZhciBjdXJyZW50SW5kZXggPSBhcnJheS5sZW5ndGg7XG4gIHZhciB0ZW1wb3JhcnlWYWx1ZTtcbiAgdmFyIHJhbmRvbUluZGV4O1xuXG4gIC8vIFdoaWxlIHRoZXJlIHJlbWFpbiBlbGVtZW50cyB0byBzaHVmZmxlLi4uXG4gIHdoaWxlIChjdXJyZW50SW5kZXggIT09IDApIHtcbiAgICAvLyBQaWNrIGEgcmVtYWluaW5nIGVsZW1lbnQuLi5cbiAgICByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGN1cnJlbnRJbmRleCk7XG4gICAgY3VycmVudEluZGV4IC09IDE7XG5cbiAgICAvLyBBbmQgc3dhcCBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgdGVtcG9yYXJ5VmFsdWUgPSBhcnJheVtjdXJyZW50SW5kZXhdO1xuICAgIGFycmF5W2N1cnJlbnRJbmRleF0gPSBhcnJheVtyYW5kb21JbmRleF07XG4gICAgYXJyYXlbcmFuZG9tSW5kZXhdID0gdGVtcG9yYXJ5VmFsdWU7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNyZWRlbnRpYWxzKGhlYWRlcnMpIHtcbiAgdmFyIG5ld0hlYWRlcnMgPSB7fTtcblxuICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIGhlYWRlcnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIGhlYWRlck5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGlmIChoZWFkZXJOYW1lID09PSAneC1hbGdvbGlhLWFwaS1rZXknIHx8IGhlYWRlck5hbWUgPT09ICd4LWFsZ29saWEtYXBwbGljYXRpb24taWQnKSB7XG4gICAgICAgIHZhbHVlID0gJyoqaGlkZGVuIGZvciBzZWN1cml0eSBwdXJwb3NlcyoqJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gaGVhZGVyc1toZWFkZXJOYW1lXTtcbiAgICAgIH1cblxuICAgICAgbmV3SGVhZGVyc1toZWFkZXJOYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdIZWFkZXJzO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9BbGdvbGlhU2VhcmNoQ29yZS5qcyIsInZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2FsZ29saWFzZWFyY2g6c3JjL2hvc3RJbmRleFN0YXRlLmpzJyk7XG52YXIgbG9jYWxTdG9yYWdlTmFtZXNwYWNlID0gJ2FsZ29saWFzZWFyY2gtY2xpZW50LWpzJztcblxudmFyIHN0b3JlO1xudmFyIG1vZHVsZVN0b3JlID0ge1xuICBzdGF0ZToge30sXG4gIHNldDogZnVuY3Rpb24oa2V5LCBkYXRhKSB7XG4gICAgdGhpcy5zdGF0ZVtrZXldID0gZGF0YTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVtrZXldO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW2tleV0gfHwgbnVsbDtcbiAgfVxufTtcblxudmFyIGxvY2FsU3RvcmFnZVN0b3JlID0ge1xuICBzZXQ6IGZ1bmN0aW9uKGtleSwgZGF0YSkge1xuICAgIG1vZHVsZVN0b3JlLnNldChrZXksIGRhdGEpOyAvLyBhbHdheXMgcmVwbGljYXRlIGxvY2FsU3RvcmFnZVN0b3JlIHRvIG1vZHVsZVN0b3JlIGluIGNhc2Ugb2YgZmFpbHVyZVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBKU09OLnBhcnNlKGdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSk7XG4gICAgICBuYW1lc3BhY2Vba2V5XSA9IGRhdGE7XG4gICAgICBnbG9iYWwubG9jYWxTdG9yYWdlW2xvY2FsU3RvcmFnZU5hbWVzcGFjZV0gPSBKU09OLnN0cmluZ2lmeShuYW1lc3BhY2UpO1xuICAgICAgcmV0dXJuIG5hbWVzcGFjZVtrZXldO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VGYWlsdXJlKGtleSwgZSk7XG4gICAgfVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShnbG9iYWwubG9jYWxTdG9yYWdlW2xvY2FsU3RvcmFnZU5hbWVzcGFjZV0pW2tleV0gfHwgbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlRmFpbHVyZShrZXksIGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbG9jYWxTdG9yYWdlRmFpbHVyZShrZXksIGUpIHtcbiAgZGVidWcoJ2xvY2FsU3RvcmFnZSBmYWlsZWQgd2l0aCcsIGUpO1xuICBjbGVhbnVwKCk7XG4gIHN0b3JlID0gbW9kdWxlU3RvcmU7XG4gIHJldHVybiBzdG9yZS5nZXQoa2V5KTtcbn1cblxuc3RvcmUgPSBzdXBwb3J0c0xvY2FsU3RvcmFnZSgpID8gbG9jYWxTdG9yYWdlU3RvcmUgOiBtb2R1bGVTdG9yZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldDogZ2V0T3JTZXQsXG4gIHNldDogZ2V0T3JTZXQsXG4gIHN1cHBvcnRzTG9jYWxTdG9yYWdlOiBzdXBwb3J0c0xvY2FsU3RvcmFnZVxufTtcblxuZnVuY3Rpb24gZ2V0T3JTZXQoa2V5LCBkYXRhKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHN0b3JlLmdldChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlLnNldChrZXksIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0xvY2FsU3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoJ2xvY2FsU3RvcmFnZScgaW4gZ2xvYmFsICYmXG4gICAgICBnbG9iYWwubG9jYWxTdG9yYWdlICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlTmFtZXNwYWNlXSkge1xuICAgICAgICAvLyBhY3R1YWwgY3JlYXRpb24gb2YgdGhlIG5hbWVzcGFjZVxuICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxTdG9yYWdlTmFtZXNwYWNlLCBKU09OLnN0cmluZ2lmeSh7fSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEluIGNhc2Ugb2YgYW55IGVycm9yIG9uIGxvY2FsU3RvcmFnZSwgd2UgY2xlYW4gb3VyIG93biBuYW1lc3BhY2UsIHRoaXMgc2hvdWxkIGhhbmRsZVxuLy8gcXVvdGEgZXJyb3JzIHdoZW4gYSBsb3Qgb2Yga2V5cyArIGRhdGEgYXJlIHVzZWRcbmZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gIHRyeSB7XG4gICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGxvY2FsU3RvcmFnZU5hbWVzcGFjZSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBub3RoaW5nIHRvIGRvXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvc3RvcmUuanMiLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZGVidWcvc3JjL2RlYnVnLmpzIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tcy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJ2dsb2JhbCcpO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZSB8fCByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG5cbi8vIFRoaXMgaXMgdGhlIHN0YW5kYWxvbmUgYnJvd3NlciBidWlsZCBlbnRyeSBwb2ludFxuLy8gQnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQWxnb2xpYSBTZWFyY2ggSmF2YVNjcmlwdCBjbGllbnQsXG4vLyB1c2luZyBYTUxIdHRwUmVxdWVzdCwgWERvbWFpblJlcXVlc3QgYW5kIEpTT05QIGFzIGZhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUFsZ29saWFzZWFyY2goQWxnb2xpYVNlYXJjaCwgdWFTdWZmaXgpIHtcbiAgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbiAgdmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuICB2YXIgaW5saW5lSGVhZGVycyA9IHJlcXVpcmUoJy4vaW5saW5lLWhlYWRlcnMnKTtcbiAgdmFyIGpzb25wUmVxdWVzdCA9IHJlcXVpcmUoJy4vanNvbnAtcmVxdWVzdCcpO1xuICB2YXIgcGxhY2VzID0gcmVxdWlyZSgnLi4vcGxhY2VzLmpzJyk7XG4gIHVhU3VmZml4ID0gdWFTdWZmaXggfHwgJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGVidWcnKSB7XG4gICAgcmVxdWlyZSgnZGVidWcnKS5lbmFibGUoJ2FsZ29saWFzZWFyY2gqJyk7XG4gIH1cblxuICBmdW5jdGlvbiBhbGdvbGlhc2VhcmNoKGFwcGxpY2F0aW9uSUQsIGFwaUtleSwgb3B0cykge1xuICAgIHZhciBjbG9uZURlZXAgPSByZXF1aXJlKCcuLi9jbG9uZS5qcycpO1xuXG4gICAgdmFyIGdldERvY3VtZW50UHJvdG9jb2wgPSByZXF1aXJlKCcuL2dldC1kb2N1bWVudC1wcm90b2NvbCcpO1xuXG4gICAgb3B0cyA9IGNsb25lRGVlcChvcHRzIHx8IHt9KTtcblxuICAgIGlmIChvcHRzLnByb3RvY29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdHMucHJvdG9jb2wgPSBnZXREb2N1bWVudFByb3RvY29sKCk7XG4gICAgfVxuXG4gICAgb3B0cy5fdWEgPSBvcHRzLl91YSB8fCBhbGdvbGlhc2VhcmNoLnVhO1xuXG4gICAgcmV0dXJuIG5ldyBBbGdvbGlhU2VhcmNoQnJvd3NlcihhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpO1xuICB9XG5cbiAgYWxnb2xpYXNlYXJjaC52ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbi5qcycpO1xuICBhbGdvbGlhc2VhcmNoLnVhID0gJ0FsZ29saWEgZm9yIHZhbmlsbGEgSmF2YVNjcmlwdCAnICsgdWFTdWZmaXggKyBhbGdvbGlhc2VhcmNoLnZlcnNpb247XG4gIGFsZ29saWFzZWFyY2guaW5pdFBsYWNlcyA9IHBsYWNlcyhhbGdvbGlhc2VhcmNoKTtcblxuICAvLyB3ZSBleHBvc2UgaW50byB3aW5kb3cgbm8gbWF0dGVyIGhvdyB3ZSBhcmUgdXNlZCwgdGhpcyB3aWxsIGFsbG93XG4gIC8vIHVzIHRvIGVhc2lseSBkZWJ1ZyBhbnkgd2Vic2l0ZSBydW5uaW5nIGFsZ29saWFcbiAgZ2xvYmFsLl9fYWxnb2xpYSA9IHtcbiAgICBkZWJ1ZzogcmVxdWlyZSgnZGVidWcnKSxcbiAgICBhbGdvbGlhc2VhcmNoOiBhbGdvbGlhc2VhcmNoXG4gIH07XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgaGFzWE1MSHR0cFJlcXVlc3Q6ICdYTUxIdHRwUmVxdWVzdCcgaW4gZ2xvYmFsLFxuICAgIGhhc1hEb21haW5SZXF1ZXN0OiAnWERvbWFpblJlcXVlc3QnIGluIGdsb2JhbFxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lmhhc1hNTEh0dHBSZXF1ZXN0KSB7XG4gICAgc3VwcG9ydC5jb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBBbGdvbGlhU2VhcmNoQnJvd3NlcigpIHtcbiAgICAvLyBjYWxsIEFsZ29saWFTZWFyY2ggY29uc3RydWN0b3JcbiAgICBBbGdvbGlhU2VhcmNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0cyhBbGdvbGlhU2VhcmNoQnJvd3NlciwgQWxnb2xpYVNlYXJjaCk7XG5cbiAgQWxnb2xpYVNlYXJjaEJyb3dzZXIucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gd3JhcFJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvLyBubyBjb3JzIG9yIFhEb21haW5SZXF1ZXN0LCBubyByZXF1ZXN0XG4gICAgICBpZiAoIXN1cHBvcnQuY29ycyAmJiAhc3VwcG9ydC5oYXNYRG9tYWluUmVxdWVzdCkge1xuICAgICAgICAvLyB2ZXJ5IG9sZCBicm93c2VyLCBub3Qgc3VwcG9ydGVkXG4gICAgICAgIHJlamVjdChuZXcgZXJyb3JzLk5ldHdvcmsoJ0NPUlMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cmwgPSBpbmxpbmVIZWFkZXJzKHVybCwgb3B0cy5oZWFkZXJzKTtcblxuICAgICAgdmFyIGJvZHkgPSBvcHRzLmJvZHk7XG4gICAgICB2YXIgcmVxID0gc3VwcG9ydC5jb3JzID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIHZhciByZXFUaW1lb3V0O1xuICAgICAgdmFyIHRpbWVkT3V0O1xuICAgICAgdmFyIGNvbm5lY3RlZCA9IGZhbHNlO1xuXG4gICAgICByZXFUaW1lb3V0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIG9wdHMudGltZW91dHMuY29ubmVjdCk7XG4gICAgICAvLyB3ZSBzZXQgYW4gZW1wdHkgb25wcm9ncmVzcyBsaXN0ZW5lclxuICAgICAgLy8gc28gdGhhdCBYRG9tYWluUmVxdWVzdCBvbiBJRTkgaXMgbm90IGFib3J0ZWRcbiAgICAgIC8vIHJlZnM6XG4gICAgICAvLyAgLSBodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9hbGdvbGlhc2VhcmNoLWNsaWVudC1qcy9pc3N1ZXMvNzZcbiAgICAgIC8vICAtIGh0dHBzOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvaWUvZW4tVVMvMzBlZjNhZGQtNzY3Yy00NDM2LWI4YTktZjFjYTE5YjQ4MTJlL2llOS1ydG0teGRvbWFpbnJlcXVlc3QtaXNzdWVkLXJlcXVlc3RzLW1heS1hYm9ydC1pZi1hbGwtZXZlbnQtaGFuZGxlcnMtbm90LXNwZWNpZmllZD9mb3J1bT1pZXdlYmRldmVsb3BtZW50XG4gICAgICByZXEub25wcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gICAgICBpZiAoJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gcmVxKSByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gb25SZWFkeVN0YXRlQ2hhbmdlO1xuICAgICAgcmVxLm9ubG9hZCA9IG9uTG9hZDtcbiAgICAgIHJlcS5vbmVycm9yID0gb25FcnJvcjtcblxuICAgICAgLy8gZG8gbm90IHJlbHkgb24gZGVmYXVsdCBYSFIgYXN5bmMgZmxhZywgYXMgc29tZSBhbmFseXRpY3MgY29kZSBsaWtlIGhvdGphclxuICAgICAgLy8gYnJlYWtzIGl0IGFuZCBzZXQgaXQgdG8gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAgaWYgKHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJlcS5vcGVuKG9wdHMubWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLm9wZW4ob3B0cy5tZXRob2QsIHVybCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhlYWRlcnMgYXJlIG1lYW50IHRvIGJlIHNlbnQgYWZ0ZXIgb3BlblxuICAgICAgaWYgKHN1cHBvcnQuY29ycykge1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgIGlmIChvcHRzLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0FjY2Vzc19jb250cm9sX0NPUlMjU2ltcGxlX3JlcXVlc3RzXG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5zZW5kKGJvZHkpO1xuXG4gICAgICAvLyBldmVudCBvYmplY3Qgbm90IHJlY2VpdmVkIGluIElFOCwgYXQgbGVhc3RcbiAgICAgIC8vIGJ1dCB3ZSBkbyBub3QgdXNlIGl0LCBzdGlsbCBpbXBvcnRhbnQgdG8gbm90ZVxuICAgICAgZnVuY3Rpb24gb25Mb2FkKC8qIGV2ZW50ICovKSB7XG4gICAgICAgIC8vIFdoZW4gYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0cyByZXEudGltZW91dCwgd2UgY2FuXG4gICAgICAgIC8vIGhhdmUgYm90aCBhIGxvYWQgYW5kIHRpbWVvdXQgZXZlbnQsIHNpbmNlIGhhbmRsZWQgYnkgYSBkdW1iIHNldFRpbWVvdXRcbiAgICAgICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuXG4gICAgICAgIHZhciBvdXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvdXQgPSB7XG4gICAgICAgICAgICBib2R5OiBKU09OLnBhcnNlKHJlcS5yZXNwb25zZVRleHQpLFxuICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiByZXEucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVxLnN0YXR1cyxcbiAgICAgICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IGRvZXMgbm90IGhhdmUgYW55IHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcS5nZXRBbGxSZXNwb25zZUhlYWRlcnMgJiYgcmVxLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8IHt9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG91dCA9IG5ldyBlcnJvcnMuVW5wYXJzYWJsZUpTT04oe1xuICAgICAgICAgICAgbW9yZTogcmVxLnJlc3BvbnNlVGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dCBpbnN0YW5jZW9mIGVycm9ycy5VbnBhcnNhYmxlSlNPTikge1xuICAgICAgICAgIHJlamVjdChvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUob3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcblxuICAgICAgICAvLyBlcnJvciBldmVudCBpcyB0cmlnZXJyZWQgYm90aCB3aXRoIFhEUi9YSFIgb246XG4gICAgICAgIC8vICAgLSBETlMgZXJyb3JcbiAgICAgICAgLy8gICAtIHVuYWxsb3dlZCBjcm9zcyBkb21haW4gcmVxdWVzdFxuICAgICAgICByZWplY3QoXG4gICAgICAgICAgbmV3IGVycm9ycy5OZXR3b3JrKHtcbiAgICAgICAgICAgIG1vcmU6IGV2ZW50XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICAgIHJlcS5hYm9ydCgpO1xuXG4gICAgICAgIHJlamVjdChuZXcgZXJyb3JzLlJlcXVlc3RUaW1lb3V0KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkNvbm5lY3QoKSB7XG4gICAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcbiAgICAgICAgcmVxVGltZW91dCA9IHNldFRpbWVvdXQob25UaW1lb3V0LCBvcHRzLnRpbWVvdXRzLmNvbXBsZXRlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Qcm9ncmVzcygpIHtcbiAgICAgICAgaWYgKCFjb25uZWN0ZWQpIG9uQ29ubmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlYWR5U3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIGlmICghY29ubmVjdGVkICYmIHJlcS5yZWFkeVN0YXRlID4gMSkgb25Db25uZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgQWxnb2xpYVNlYXJjaEJyb3dzZXIucHJvdG90eXBlLl9yZXF1ZXN0LmZhbGxiYWNrID0gZnVuY3Rpb24gcmVxdWVzdEZhbGxiYWNrKHVybCwgb3B0cykge1xuICAgIHVybCA9IGlubGluZUhlYWRlcnModXJsLCBvcHRzLmhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIHdyYXBKc29ucFJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBqc29ucFJlcXVlc3QodXJsLCBvcHRzLCBmdW5jdGlvbiBqc29ucFJlcXVlc3REb25lKGVyciwgY29udGVudCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShjb250ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEFsZ29saWFTZWFyY2hCcm93c2VyLnByb3RvdHlwZS5fcHJvbWlzZSA9IHtcbiAgICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdFByb21pc2UodmFsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsKTtcbiAgICB9LFxuICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWwpO1xuICAgIH0sXG4gICAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5UHJvbWlzZShtcykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIHJlc29sdmVPblRpbWVvdXQocmVzb2x2ZS8qICwgcmVqZWN0Ki8pIHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGFsZ29saWFzZWFyY2g7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2NyZWF0ZUFsZ29saWFzZWFyY2guanMiLCJ2YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIHdpbiA9IHNlbGY7XG59IGVsc2Uge1xuICAgIHdpbiA9IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZ2xvYmFsL3dpbmRvdy5qcyIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgNC4xLjFcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHVuZGVmaW5lZDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHVuZGVmaW5lZDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAoe30pLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHIgPSByZXF1aXJlO1xuICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHVuZGVmaW5lZDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICBpZiAoX3N0YXRlKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IF9hcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxudmFyIEdFVF9USEVOX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ocHJvbWlzZSkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gR0VUX1RIRU5fRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgICAgR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB1bmRlZmluZWQsXG4gICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIEVycm9yT2JqZWN0KCkge1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgZXJyb3IgPSB1bmRlZmluZWQsXG4gICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG4gICAgICBmYWlsZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlLmVycm9yID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gRW51bWVyYXRvciQxKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gIH1cblxuICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG4gIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQyKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgfSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGksIHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgfVxufTtcblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gKHByb21pc2UsIGkpIHtcbiAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICB9KTtcbn07XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbCQxKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yJDEodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UkMShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuZnVuY3Rpb24gUHJvbWlzZSQyKHJlc29sdmVyKSB7XG4gIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSQyID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgfVxufVxuXG5Qcm9taXNlJDIuYWxsID0gYWxsJDE7XG5Qcm9taXNlJDIucmFjZSA9IHJhY2UkMTtcblByb21pc2UkMi5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQyLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQyLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDIuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQyLl9hc2FwID0gYXNhcDtcblxuUHJvbWlzZSQyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFByb21pc2UkMixcblxuICAvKipcbiAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBDaGFpbmluZ1xuICAgIC0tLS0tLS0tXG4gIFxuICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgIH0pO1xuICBcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICB9KTtcbiAgICBgYGBcbiAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQXNzaW1pbGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tXG4gIFxuICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IHJlc3VsdDtcbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IGF1dGhvciwgYm9va3M7XG4gIFxuICAgIHRyeSB7XG4gICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgXG4gICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICBcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kQXV0aG9yKCkuXG4gICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIHRoZW5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgdGhlbjogdGhlbixcblxuICAvKipcbiAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgXG4gICAgYGBganNcbiAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICB9XG4gIFxuICAgIC8vIHN5bmNocm9ub3VzXG4gICAgdHJ5IHtcbiAgICAgIGZpbmRBdXRob3IoKTtcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9XG4gIFxuICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgY2F0Y2hcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICAnY2F0Y2gnOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfVxufTtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCQxKCkge1xuICAgIHZhciBsb2NhbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgIGlmIChQKSB7XG4gICAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDI7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMi5wb2x5ZmlsbCA9IHBvbHlmaWxsJDE7XG5Qcm9taXNlJDIuUHJvbWlzZSA9IFByb21pc2UkMjtcblxucmV0dXJuIFByb21pc2UkMjtcblxufSkpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gdmVydHggKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDMgNCA1IDYiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5saW5lSGVhZGVycztcblxudmFyIGVuY29kZSA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUnKTtcblxuZnVuY3Rpb24gaW5saW5lSGVhZGVycyh1cmwsIGhlYWRlcnMpIHtcbiAgaWYgKC9cXD8vLnRlc3QodXJsKSkge1xuICAgIHVybCArPSAnJic7XG4gIH0gZWxzZSB7XG4gICAgdXJsICs9ICc/JztcbiAgfVxuXG4gIHJldHVybiB1cmwgKyBlbmNvZGUoaGVhZGVycyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvaW5saW5lLWhlYWRlcnMuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBqc29ucFJlcXVlc3Q7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxudmFyIEpTT05QQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGpzb25wUmVxdWVzdCh1cmwsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICBjYihuZXcgRXJyb3IoJ01ldGhvZCAnICsgb3B0cy5tZXRob2QgKyAnICcgKyB1cmwgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSlNPTlAuJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdHMuZGVidWcoJ0pTT05QOiBzdGFydCcpO1xuXG4gIHZhciBjYkNhbGxlZCA9IGZhbHNlO1xuICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcblxuICBKU09OUENvdW50ZXIgKz0gMTtcbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBjYk5hbWUgPSAnYWxnb2xpYUpTT05QXycgKyBKU09OUENvdW50ZXI7XG4gIHZhciBkb25lID0gZmFsc2U7XG5cbiAgd2luZG93W2NiTmFtZV0gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmVtb3ZlR2xvYmFscygpO1xuXG4gICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICBvcHRzLmRlYnVnKCdKU09OUDogTGF0ZSBhbnN3ZXIsIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2JDYWxsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW4oKTtcblxuICAgIGNiKG51bGwsIHtcbiAgICAgIGJvZHk6IGRhdGEvKiAsXG4gICAgICAvLyBXZSBkbyBub3Qgc2VuZCB0aGUgc3RhdHVzQ29kZSwgdGhlcmUncyBubyBzdGF0dXNDb2RlIGluIEpTT05QLCBpdCB3aWxsIGJlXG4gICAgICAvLyBjb21wdXRlZCB1c2luZyBkYXRhLnN0YXR1cyAmJiBkYXRhLm1lc3NhZ2UgbGlrZSB3aXRoIFhEUlxuICAgICAgc3RhdHVzQ29kZSovXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYWRkIGNhbGxiYWNrIGJ5IGhhbmRcbiAgdXJsICs9ICcmY2FsbGJhY2s9JyArIGNiTmFtZTtcblxuICAvLyBhZGQgYm9keSBwYXJhbXMgbWFudWFsbHlcbiAgaWYgKG9wdHMuanNvbkJvZHkgJiYgb3B0cy5qc29uQm9keS5wYXJhbXMpIHtcbiAgICB1cmwgKz0gJyYnICsgb3B0cy5qc29uQm9keS5wYXJhbXM7XG4gIH1cblxuICB2YXIgb250aW1lb3V0ID0gc2V0VGltZW91dCh0aW1lb3V0LCBvcHRzLnRpbWVvdXRzLmNvbXBsZXRlKTtcblxuICAvLyBzY3JpcHQgb25yZWFkeXN0YXRlY2hhbmdlIG5lZWRlZCBvbmx5IGZvclxuICAvLyA8PSBJRThcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvNDUyM1xuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZTtcbiAgc2NyaXB0Lm9ubG9hZCA9IHN1Y2Nlc3M7XG4gIHNjcmlwdC5vbmVycm9yID0gZXJyb3I7XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgb3B0cy5kZWJ1ZygnSlNPTlA6IHN1Y2Nlc3MnKTtcblxuICAgIGlmIChkb25lIHx8IHRpbWVkT3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9uZSA9IHRydWU7XG5cbiAgICAvLyBzY3JpcHQgbG9hZGVkIGJ1dCBkaWQgbm90IGNhbGwgdGhlIGZuID0+IHNjcmlwdCBsb2FkaW5nIGVycm9yXG4gICAgaWYgKCFjYkNhbGxlZCkge1xuICAgICAgb3B0cy5kZWJ1ZygnSlNPTlA6IEZhaWwuIFNjcmlwdCBsb2FkZWQgYnV0IGRpZCBub3QgY2FsbCB0aGUgY2FsbGJhY2snKTtcbiAgICAgIGNsZWFuKCk7XG4gICAgICBjYihuZXcgZXJyb3JzLkpTT05QU2NyaXB0RmFpbCgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgc3VjY2VzcygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgIGNsZWFyVGltZW91dChvbnRpbWVvdXQpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVHbG9iYWxzKCkge1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgd2luZG93W2NiTmFtZV07XG4gICAgICBkZWxldGUgd2luZG93W2NiTmFtZSArICdfbG9hZGVkJ107XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2luZG93W2NiTmFtZV0gPSB3aW5kb3dbY2JOYW1lICsgJ19sb2FkZWQnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lb3V0KCkge1xuICAgIG9wdHMuZGVidWcoJ0pTT05QOiBTY3JpcHQgdGltZW91dCcpO1xuICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICBjbGVhbigpO1xuICAgIGNiKG5ldyBlcnJvcnMuUmVxdWVzdFRpbWVvdXQoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICBvcHRzLmRlYnVnKCdKU09OUDogU2NyaXB0IGVycm9yJyk7XG5cbiAgICBpZiAoZG9uZSB8fCB0aW1lZE91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFuKCk7XG4gICAgY2IobmV3IGVycm9ycy5KU09OUFNjcmlwdEVycm9yKCkpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL2Jyb3dzZXIvanNvbnAtcmVxdWVzdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUGxhY2VzQ2xpZW50O1xuXG52YXIgYnVpbGRTZWFyY2hNZXRob2QgPSByZXF1aXJlKCcuL2J1aWxkU2VhcmNoTWV0aG9kLmpzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYWNlc0NsaWVudChhbGdvbGlhc2VhcmNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwbGFjZXMoYXBwSUQsIGFwaUtleSwgb3B0cykge1xuICAgIHZhciBjbG9uZURlZXAgPSByZXF1aXJlKCcuL2Nsb25lLmpzJyk7XG5cbiAgICBvcHRzID0gb3B0cyAmJiBjbG9uZURlZXAob3B0cykgfHwge307XG4gICAgb3B0cy5ob3N0cyA9IG9wdHMuaG9zdHMgfHwgW1xuICAgICAgJ3BsYWNlcy1kc24uYWxnb2xpYS5uZXQnLFxuICAgICAgJ3BsYWNlcy0xLmFsZ29saWFuZXQuY29tJyxcbiAgICAgICdwbGFjZXMtMi5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAncGxhY2VzLTMuYWxnb2xpYW5ldC5jb20nXG4gICAgXTtcblxuICAgIC8vIGFsbG93IGluaXRQbGFjZXMoKSBubyBhcmd1bWVudHMgPT4gY29tbXVuaXR5IHJhdGUgbGltaXRlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBhcHBJRCA9PT0gJ29iamVjdCcgfHwgYXBwSUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXBwSUQgPSAnJztcbiAgICAgIGFwaUtleSA9ICcnO1xuICAgICAgb3B0cy5fYWxsb3dFbXB0eUNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2xpZW50ID0gYWxnb2xpYXNlYXJjaChhcHBJRCwgYXBpS2V5LCBvcHRzKTtcbiAgICB2YXIgaW5kZXggPSBjbGllbnQuaW5pdEluZGV4KCdwbGFjZXMnKTtcbiAgICBpbmRleC5zZWFyY2ggPSBidWlsZFNlYXJjaE1ldGhvZCgncXVlcnknLCAnLzEvcGxhY2VzL3F1ZXJ5Jyk7XG4gICAgaW5kZXguZ2V0T2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0SUQsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6ICcvMS9wbGFjZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3RJRCksXG4gICAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FsZ29saWFzZWFyY2gvc3JjL3BsYWNlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZXREb2N1bWVudFByb3RvY29sO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudFByb3RvY29sKCkge1xuICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cuZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2w7XG5cbiAgLy8gd2hlbiBpbiBgZmlsZTpgIG1vZGUgKGxvY2FsIGh0bWwgZmlsZSksIGRlZmF1bHQgdG8gYGh0dHA6YFxuICBpZiAocHJvdG9jb2wgIT09ICdodHRwOicgJiYgcHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgcHJvdG9jb2wgPSAnaHR0cDonO1xuICB9XG5cbiAgcmV0dXJuIHByb3RvY29sO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbGdvbGlhc2VhcmNoL3NyYy9icm93c2VyL2dldC1kb2N1bWVudC1wcm90b2NvbC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMy4yNC4zJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYWxnb2xpYXNlYXJjaC9zcmMvdmVyc2lvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=